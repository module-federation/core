// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/bin/webpack.d.ts
#!/usr/bin/env node
export type CliOption = {
    /**
     * display name
     */
    name: string;
    /**
     * npm package name
     */
    package: string;
    /**
     * name of the executable file
     */
    binName: string;
    /**
     * currently installed?
     */
    installed: boolean;
    /**
     * homepage
     */
    url: string;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/LoaderContext.d.ts
import type { SourceMap } from "../lib/NormalModule";
import type { validate } from "schema-utils";
import type { AssetInfo } from "../lib/Compilation";
import type { ResolveOptionsWithDependencyType } from "../lib/ResolverFactory";
import type Compilation from "../lib/Compilation";
import type Compiler from "../lib/Compiler";
import type NormalModule from "../lib/NormalModule";
import type Hash from "../lib/util/Hash";
import type { InputFileSystem } from "../lib/util/fs";
import type { Logger } from "../lib/logging/Logger";
import type {
	ImportModuleCallback,
	ImportModuleOptions
} from "../lib/dependencies/LoaderPlugin";
import type { Resolver } from "enhanced-resolve";
import type { Environment } from "./WebpackOptions";

type ResolveCallback = Parameters<Resolver["resolve"]>[4];
type Schema = Parameters<typeof validate>[0];

/** These properties are added by the NormalModule */
export interface NormalModuleLoaderContext<OptionsType> {
	version: number;
	getOptions(): OptionsType;
	getOptions(schema: Schema): OptionsType;
	emitWarning(warning: Error): void;
	emitError(error: Error): void;
	getLogger(name?: string): Logger;
	resolve(context: string, request: string, callback: ResolveCallback): any;
	getResolve(
		options?: ResolveOptionsWithDependencyType
	): ((context: string, request: string, callback: ResolveCallback) => void) &
		((context: string, request: string) => Promise<string>);
	emitFile(
		name: string,
		content: string | Buffer,
		sourceMap?: string,
		assetInfo?: AssetInfo
	): void;
	addBuildDependency(dep: string): void;
	utils: {
		absolutify: (context: string, request: string) => string;
		contextify: (context: string, request: string) => string;
		createHash: (algorithm?: string) => Hash;
	};
	rootContext: string;
	fs: InputFileSystem;
	sourceMap?: boolean;
	mode: "development" | "production" | "none";
	webpack?: boolean;
	_module?: NormalModule;
	_compilation?: Compilation;
	_compiler?: Compiler;
}

/** These properties are added by the HotModuleReplacementPlugin */
export interface HotModuleReplacementPluginLoaderContext {
	hot?: boolean;
}

/** These properties are added by the LoaderPlugin */
export interface LoaderPluginLoaderContext {
	/**
	 * Resolves the given request to a module, applies all configured loaders and calls
	 * back with the generated source, the sourceMap and the module instance (usually an
	 * instance of NormalModule). Use this function if you need to know the source code
	 * of another module to generate the result.
	 */
	loadModule(
		request: string,
		callback: (
			err: Error | null,
			source: string,
			sourceMap: any,
			module: NormalModule
		) => void
	): void;

	importModule(
		request: string,
		options: ImportModuleOptions,
		callback: ImportModuleCallback
	): void;
	importModule(request: string, options?: ImportModuleOptions): Promise<any>;
}

/** The properties are added by https://github.com/webpack/loader-runner */
export interface LoaderRunnerLoaderContext<OptionsType> {
	/**
	 * Add a directory as dependency of the loader result.
	 */
	addContextDependency(context: string): void;

	/**
	 * Adds a file as dependency of the loader result in order to make them watchable.
	 * For example, html-loader uses this technique as it finds src and src-set attributes.
	 * Then, it sets the url's for those attributes as dependencies of the html file that is parsed.
	 */
	addDependency(file: string): void;

	addMissingDependency(context: string): void;

	/**
	 * Make this loader async.
	 */
	async(): WebpackLoaderContextCallback;

	/**
	 * Make this loader result cacheable. By default it's cacheable.
	 * A cacheable loader must have a deterministic result, when inputs and dependencies haven't changed.
	 * This means the loader shouldn't have other dependencies than specified with this.addDependency.
	 * Most loaders are deterministic and cacheable.
	 */
	cacheable(flag?: boolean): void;

	callback: WebpackLoaderContextCallback;

	/**
	 * Remove all dependencies of the loader result. Even initial dependencies and these of other loaders.
	 */
	clearDependencies(): void;

	/**
	 * The directory of the module. Can be used as context for resolving other stuff.
	 * eg '/workspaces/ts-loader/examples/vanilla/src'
	 */
	context: string;

	readonly currentRequest: string;

	readonly data: any;
	/**
	 * alias of addDependency
	 * Adds a file as dependency of the loader result in order to make them watchable.
	 * For example, html-loader uses this technique as it finds src and src-set attributes.
	 * Then, it sets the url's for those attributes as dependencies of the html file that is parsed.
	 */
	dependency(file: string): void;

	getContextDependencies(): string[];

	getDependencies(): string[];

	getMissingDependencies(): string[];

	/**
	 * The index in the loaders array of the current loader.
	 * In the example: in loader1: 0, in loader2: 1
	 */
	loaderIndex: number;

	readonly previousRequest: string;

	readonly query: string | OptionsType;

	readonly remainingRequest: string;

	readonly request: string;

	/**
	 * An array of all the loaders. It is writeable in the pitch phase.
	 * loaders = [{request: string, path: string, query: string, module: function}]
	 *
	 * In the example:
	 * [
	 *   { request: "/abc/loader1.js?xyz",
	 *     path: "/abc/loader1.js",
	 *     query: "?xyz",
	 *     module: [Function]
	 *   },
	 *   { request: "/abc/node_modules/loader2/index.js",
	 *     path: "/abc/node_modules/loader2/index.js",
	 *     query: "",
	 *     module: [Function]
	 *   }
	 * ]
	 */
	loaders: {
		request: string;
		path: string;
		query: string;
		fragment: string;
		options: object | string | undefined;
		ident: string;
		normal: Function | undefined;
		pitch: Function | undefined;
		raw: boolean | undefined;
		data: object | undefined;
		pitchExecuted: boolean;
		normalExecuted: boolean;
		type?: "commonjs" | "module" | undefined;
	}[];

	/**
	 * The resource path.
	 * In the example: "/abc/resource.js"
	 */
	resourcePath: string;

	/**
	 * The resource query string.
	 * Example: "?query"
	 */
	resourceQuery: string;

	/**
	 * The resource fragment.
	 * Example: "#frag"
	 */
	resourceFragment: string;

	/**
	 * The resource inclusive query and fragment.
	 * Example: "/abc/resource.js?query#frag"
	 */
	resource: string;

	/**
	 * Target of compilation.
	 * Example: "web"
	 */
	target: string;

	/**
	 * Tell what kind of ES-features may be used in the generated runtime-code.
	 * Example: { arrowFunction: true }
	 */
	environment: Environment;
}

type AdditionalData = {
	webpackAST: object;
	[index: string]: any;
};

type WebpackLoaderContextCallback = (
	err: Error | undefined | null,
	content?: string | Buffer,
	sourceMap?: string | SourceMap,
	additionalData?: AdditionalData
) => void;

type LoaderContext<OptionsType> = NormalModuleLoaderContext<OptionsType> &
	LoaderRunnerLoaderContext<OptionsType> &
	LoaderPluginLoaderContext &
	HotModuleReplacementPluginLoaderContext;

type PitchLoaderDefinitionFunction<OptionsType = {}, ContextAdditions = {}> = (
	this: LoaderContext<OptionsType> & ContextAdditions,
	remainingRequest: string,
	previousRequest: string,
	data: object
) => string | Buffer | Promise<string | Buffer> | void;

type LoaderDefinitionFunction<OptionsType = {}, ContextAdditions = {}> = (
	this: LoaderContext<OptionsType> & ContextAdditions,
	content: string,
	sourceMap?: string | SourceMap,
	additionalData?: AdditionalData
) => string | Buffer | Promise<string | Buffer> | void;

type RawLoaderDefinitionFunction<OptionsType = {}, ContextAdditions = {}> = (
	this: LoaderContext<OptionsType> & ContextAdditions,
	content: Buffer,
	sourceMap?: string | SourceMap,
	additionalData?: AdditionalData
) => string | Buffer | Promise<string | Buffer> | void;

export type LoaderDefinition<
	OptionsType = {},
	ContextAdditions = {}
> = LoaderDefinitionFunction<OptionsType, ContextAdditions> & {
	raw?: false;
	pitch?: PitchLoaderDefinitionFunction<OptionsType, ContextAdditions>;
};

export type RawLoaderDefinition<
	OptionsType = {},
	ContextAdditions = {}
> = RawLoaderDefinitionFunction<OptionsType, ContextAdditions> & {
	raw: true;
	pitch?: PitchLoaderDefinitionFunction<OptionsType, ContextAdditions>;
};

export interface LoaderModule<OptionsType = {}, ContextAdditions = {}> {
	default?:
		| RawLoaderDefinitionFunction<OptionsType, ContextAdditions>
		| LoaderDefinitionFunction<OptionsType, ContextAdditions>;
	raw?: false;
	pitch?: PitchLoaderDefinitionFunction<OptionsType, ContextAdditions>;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/WebpackOptions.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

/**
 * Set the value of `require.amd` and `define.amd`. Or disable AMD support.
 */
export type Amd =
	| false
	| {
			[k: string]: any;
	  };
/**
 * Report the first error as a hard error instead of tolerating it.
 */
export type Bail = boolean;
/**
 * Cache generated modules and chunks to improve performance for multiple incremental builds.
 */
export type CacheOptions = true | CacheOptionsNormalized;
/**
 * Cache generated modules and chunks to improve performance for multiple incremental builds.
 */
export type CacheOptionsNormalized =
	| false
	| MemoryCacheOptions
	| FileCacheOptions;
/**
 * The base directory (absolute path!) for resolving the `entry` option. If `output.pathinfo` is set, the included pathinfo is shortened to this directory.
 */
export type Context = string;
/**
 * References to other configurations to depend on.
 */
export type Dependencies = string[];
/**
 * A developer tool to enhance debugging (false | eval | [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map).
 */
export type DevTool = (false | "eval") | string;
/**
 * The entry point(s) of the compilation.
 */
export type Entry = EntryDynamic | EntryStatic;
/**
 * A Function returning an entry object, an entry string, an entry array or a promise to these things.
 */
export type EntryDynamic = () => EntryStatic | Promise<EntryStatic>;
/**
 * A static entry description.
 */
export type EntryStatic = EntryObject | EntryUnnamed;
/**
 * Module(s) that are loaded upon startup.
 */
export type EntryItem = string[] | string;
/**
 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
 */
export type ChunkLoading = false | ChunkLoadingType;
/**
 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
 */
export type ChunkLoadingType =
	| ("jsonp" | "import-scripts" | "require" | "async-node" | "import")
	| string;
/**
 * Specifies the filename of the output file on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
 */
export type EntryFilename = FilenameTemplate;
/**
 * Specifies the filename template of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
 */
export type FilenameTemplate =
	| string
	| ((
			pathData: import("../lib/Compilation").PathData,
			assetInfo?: import("../lib/Compilation").AssetInfo
	  ) => string);
/**
 * Specifies the layer in which modules of this entrypoint are placed.
 */
export type Layer = null | string;
/**
 * Add a container for define/require functions in the AMD module.
 */
export type AmdContainer = string;
/**
 * Add a comment in the UMD wrapper.
 */
export type AuxiliaryComment = string | LibraryCustomUmdCommentObject;
/**
 * Specify which export should be exposed as library.
 */
export type LibraryExport = string[] | string;
/**
 * The name of the library (some types allow unnamed libraries too).
 */
export type LibraryName = string[] | string | LibraryCustomUmdObject;
/**
 * Type of library (types included by default are 'var', 'module', 'assign', 'assign-properties', 'this', 'window', 'self', 'global', 'commonjs', 'commonjs2', 'commonjs-module', 'commonjs-static', 'amd', 'amd-require', 'umd', 'umd2', 'jsonp', 'system', but others might be added by plugins).
 */
export type LibraryType =
	| (
			| "var"
			| "module"
			| "assign"
			| "assign-properties"
			| "this"
			| "window"
			| "self"
			| "global"
			| "commonjs"
			| "commonjs2"
			| "commonjs-module"
			| "commonjs-static"
			| "amd"
			| "amd-require"
			| "umd"
			| "umd2"
			| "jsonp"
			| "system"
	  )
	| string;
/**
 * If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.
 */
export type UmdNamedDefine = boolean;
/**
 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
 */
export type PublicPath = "auto" | RawPublicPath;
/**
 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
 */
export type RawPublicPath =
	| string
	| ((
			pathData: import("../lib/Compilation").PathData,
			assetInfo?: import("../lib/Compilation").AssetInfo
	  ) => string);
/**
 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
 */
export type EntryRuntime = false | string;
/**
 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
 */
export type WasmLoading = false | WasmLoadingType;
/**
 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
 */
export type WasmLoadingType =
	| ("fetch-streaming" | "fetch" | "async-node")
	| string;
/**
 * An entry point without name.
 */
export type EntryUnnamed = EntryItem;
/**
 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
 */
export type Experiments = ExperimentsCommon & ExperimentsExtra;
/**
 * Extend configuration from another configuration (only works when using webpack-cli).
 */
export type Extends = ExtendsItem[] | ExtendsItem;
/**
 * Path to the configuration to be extended (only works when using webpack-cli).
 */
export type ExtendsItem = string;
/**
 * Specify dependencies that shouldn't be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.
 */
export type Externals = ExternalItem[] | ExternalItem;
/**
 * Specify dependency that shouldn't be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.
 */
export type ExternalItem =
	| RegExp
	| string
	| (ExternalItemObjectKnown & ExternalItemObjectUnknown)
	| (
			| ((
					data: ExternalItemFunctionData,
					callback: (err?: Error | null, result?: ExternalItemValue) => void
			  ) => void)
			| ((data: ExternalItemFunctionData) => Promise<ExternalItemValue>)
	  );
/**
 * Specifies the default type of externals ('amd*', 'umd*', 'system' and 'jsonp' depend on output.libraryTarget set to the same value).
 */
export type ExternalsType =
	| "var"
	| "module"
	| "assign"
	| "this"
	| "window"
	| "self"
	| "global"
	| "commonjs"
	| "commonjs2"
	| "commonjs-module"
	| "commonjs-static"
	| "amd"
	| "amd-require"
	| "umd"
	| "umd2"
	| "jsonp"
	| "system"
	| "promise"
	| "import"
	| "script"
	| "node-commonjs";
/**
 * Ignore specific warnings.
 */
export type IgnoreWarnings = (
	| RegExp
	| {
			/**
			 * A RegExp to select the origin file for the warning.
			 */
			file?: RegExp;
			/**
			 * A RegExp to select the warning message.
			 */
			message?: RegExp;
			/**
			 * A RegExp to select the origin module for the warning.
			 */
			module?: RegExp;
	  }
	| ((
			warning: import("../lib/WebpackError"),
			compilation: import("../lib/Compilation")
	  ) => boolean)
)[];
/**
 * Filtering values.
 */
export type FilterTypes = FilterItemTypes[] | FilterItemTypes;
/**
 * Filtering value, regexp or function.
 */
export type FilterItemTypes = RegExp | string | ((value: string) => boolean);
/**
 * Enable production optimizations or development hints.
 */
export type Mode = "development" | "production" | "none";
/**
 * These values will be ignored by webpack and created to be used with '&&' or '||' to improve readability of configurations.
 */
export type Falsy = false | 0 | "" | null | undefined;
/**
 * One or multiple rule conditions.
 */
export type RuleSetConditionOrConditions = RuleSetCondition | RuleSetConditions;
/**
 * A condition matcher.
 */
export type RuleSetCondition =
	| RegExp
	| string
	| ((value: string) => boolean)
	| RuleSetLogicalConditions
	| RuleSetConditions;
/**
 * A list of rule conditions.
 */
export type RuleSetConditions = RuleSetCondition[];
/**
 * One or multiple rule conditions matching an absolute path.
 */
export type RuleSetConditionOrConditionsAbsolute =
	| RuleSetConditionAbsolute
	| RuleSetConditionsAbsolute;
/**
 * A condition matcher matching an absolute path.
 */
export type RuleSetConditionAbsolute =
	| RegExp
	| string
	| ((value: string) => boolean)
	| RuleSetLogicalConditionsAbsolute
	| RuleSetConditionsAbsolute;
/**
 * A list of rule conditions matching an absolute path.
 */
export type RuleSetConditionsAbsolute = RuleSetConditionAbsolute[];
/**
 * A loader request.
 */
export type RuleSetLoader = string;
/**
 * Options passed to a loader.
 */
export type RuleSetLoaderOptions =
	| string
	| {
			[k: string]: any;
	  };
/**
 * Redirect module requests.
 */
export type ResolveAlias =
	| {
			/**
			 * New request.
			 */
			alias: string[] | false | string;
			/**
			 * Request to be redirected.
			 */
			name: string;
			/**
			 * Redirect only exact matching request.
			 */
			onlyModule?: boolean;
	  }[]
	| {
			/**
			 * New request.
			 */
			[k: string]: string[] | false | string;
	  };
/**
 * A list of descriptions of loaders applied.
 */
export type RuleSetUse =
	| (Falsy | RuleSetUseItem)[]
	| ((data: {
			resource: string;
			realResource: string;
			resourceQuery: string;
			issuer: string;
			compiler: string;
	  }) => (Falsy | RuleSetUseItem)[])
	| RuleSetUseItem;
/**
 * A description of an applied loader.
 */
export type RuleSetUseItem =
	| {
			/**
			 * Unique loader options identifier.
			 */
			ident?: string;
			/**
			 * Loader name.
			 */
			loader?: RuleSetLoader;
			/**
			 * Loader options.
			 */
			options?: RuleSetLoaderOptions;
	  }
	| ((data: object) => RuleSetUseItem | (Falsy | RuleSetUseItem)[])
	| RuleSetLoader;
/**
 * A list of rules.
 */
export type RuleSetRules = ("..." | Falsy | RuleSetRule)[];
/**
 * Specify options for each generator.
 */
export type GeneratorOptionsByModuleType = GeneratorOptionsByModuleTypeKnown &
	GeneratorOptionsByModuleTypeUnknown;
/**
 * Don't parse files matching. It's matched against the full resolved request.
 */
export type NoParse =
	| (RegExp | string | Function)[]
	| RegExp
	| string
	| Function;
/**
 * Specify options for each parser.
 */
export type ParserOptionsByModuleType = ParserOptionsByModuleTypeKnown &
	ParserOptionsByModuleTypeUnknown;
/**
 * Name of the configuration. Used when loading multiple configurations.
 */
export type Name = string;
/**
 * Include polyfills or mocks for various node stuff.
 */
export type Node = false | NodeOptions;
/**
 * Function acting as plugin.
 */
export type WebpackPluginFunction = (
	this: import("../lib/Compiler"),
	compiler: import("../lib/Compiler")
) => void;
/**
 * Create an additional chunk which contains only the webpack runtime and chunk hash maps.
 */
export type OptimizationRuntimeChunk =
	| ("single" | "multiple")
	| boolean
	| {
			/**
			 * The name or name factory for the runtime chunks.
			 */
			name?: string | Function;
	  };
/**
 * Size description for limits.
 */
export type OptimizationSplitChunksSizes =
	| number
	| {
			/**
			 * Size of the part of the chunk with the type of the key.
			 */
			[k: string]: number;
	  };
/**
 * The filename of asset modules as relative path inside the 'output.path' directory.
 */
export type AssetModuleFilename =
	| string
	| ((
			pathData: import("../lib/Compilation").PathData,
			assetInfo?: import("../lib/Compilation").AssetInfo
	  ) => string);
/**
 * Add charset attribute for script tag.
 */
export type Charset = boolean;
/**
 * Specifies the filename template of output files of non-initial chunks on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
 */
export type ChunkFilename = FilenameTemplate;
/**
 * The format of chunks (formats included by default are 'array-push' (web/WebWorker), 'commonjs' (node.js), 'module' (ESM), but others might be added by plugins).
 */
export type ChunkFormat =
	| ("array-push" | "commonjs" | "module" | false)
	| string;
/**
 * Number of milliseconds before chunk request expires.
 */
export type ChunkLoadTimeout = number;
/**
 * The global variable used by webpack for loading of chunks.
 */
export type ChunkLoadingGlobal = string;
/**
 * Clean the output directory before emit.
 */
export type Clean = boolean | CleanOptions;
/**
 * Check if to be emitted file already exists and have the same content before writing to output filesystem.
 */
export type CompareBeforeEmit = boolean;
/**
 * This option enables cross-origin loading of chunks.
 */
export type CrossOriginLoading = false | "anonymous" | "use-credentials";
/**
 * Specifies the filename template of non-initial output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
 */
export type CssChunkFilename = FilenameTemplate;
/**
 * Specifies the filename template of output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
 */
export type CssFilename = FilenameTemplate;
/**
 * Similar to `output.devtoolModuleFilenameTemplate`, but used in the case of duplicate module identifiers.
 */
export type DevtoolFallbackModuleFilenameTemplate = string | Function;
/**
 * Filename template string of function for the sources array in a generated SourceMap.
 */
export type DevtoolModuleFilenameTemplate = string | Function;
/**
 * Module namespace to use when interpolating filename template string for the sources array in a generated SourceMap. Defaults to `output.library` if not set. It's useful for avoiding runtime collisions in sourcemaps from multiple webpack projects built as libraries.
 */
export type DevtoolNamespace = string;
/**
 * List of chunk loading types enabled for use by entry points.
 */
export type EnabledChunkLoadingTypes = ChunkLoadingType[];
/**
 * List of library types enabled for use by entry points.
 */
export type EnabledLibraryTypes = LibraryType[];
/**
 * List of wasm loading types enabled for use by entry points.
 */
export type EnabledWasmLoadingTypes = WasmLoadingType[];
/**
 * Specifies the filename of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
 */
export type Filename = FilenameTemplate;
/**
 * An expression which is used to address the global object/scope in runtime code.
 */
export type GlobalObject = string;
/**
 * Digest type used for the hash.
 */
export type HashDigest = string;
/**
 * Number of chars which are used for the hash.
 */
export type HashDigestLength = number;
/**
 * Algorithm used for generation the hash (see node.js crypto package).
 */
export type HashFunction = string | typeof import("../lib/util/Hash");
/**
 * Any string which is added to the hash to salt it.
 */
export type HashSalt = string;
/**
 * The filename of the Hot Update Chunks. They are inside the output.path directory.
 */
export type HotUpdateChunkFilename = string;
/**
 * The global variable used by webpack for loading of hot update chunks.
 */
export type HotUpdateGlobal = string;
/**
 * The filename of the Hot Update Main File. It is inside the 'output.path' directory.
 */
export type HotUpdateMainFilename = string;
/**
 * Wrap javascript code into IIFE's to avoid leaking into global scope.
 */
export type Iife = boolean;
/**
 * The name of the native import() function (can be exchanged for a polyfill).
 */
export type ImportFunctionName = string;
/**
 * The name of the native import.meta object (can be exchanged for a polyfill).
 */
export type ImportMetaName = string;
/**
 * Make the output files a library, exporting the exports of the entry point.
 */
export type Library = LibraryName | LibraryOptions;
/**
 * Output javascript files as module source type.
 */
export type OutputModule = boolean;
/**
 * The output directory as **absolute path** (required).
 */
export type Path = string;
/**
 * Include comments with information about the modules.
 */
export type Pathinfo = "verbose" | boolean;
/**
 * This option enables loading async chunks via a custom script type, such as script type="module".
 */
export type ScriptType = false | "text/javascript" | "module";
/**
 * The filename of the SourceMaps for the JavaScript files. They are inside the 'output.path' directory.
 */
export type SourceMapFilename = string;
/**
 * Prefixes every line of the source in the bundle with this string.
 */
export type SourcePrefix = string;
/**
 * Handles error in module loading correctly at a performance cost. This will handle module error compatible with the EcmaScript Modules spec.
 */
export type StrictModuleErrorHandling = boolean;
/**
 * Handles exceptions in module loading correctly at a performance cost (Deprecated). This will handle module error compatible with the Node.js CommonJS way.
 */
export type StrictModuleExceptionHandling = boolean;
/**
 * A unique name of the webpack build to avoid multiple webpack runtimes to conflict when using globals.
 */
export type UniqueName = string;
/**
 * The filename of WebAssembly modules as relative path inside the 'output.path' directory.
 */
export type WebassemblyModuleFilename = string;
/**
 * Worker public path. Much like the public path, this sets the location where the worker script file is intended to be found. If not set, webpack will use the publicPath. Don't set this option unless your worker scripts are located at a different path from your other script files.
 */
export type WorkerPublicPath = string;
/**
 * The number of parallel processed modules in the compilation.
 */
export type Parallelism = number;
/**
 * Configuration for web performance recommendations.
 */
export type Performance = false | PerformanceOptions;
/**
 * Add additional plugins to the compiler.
 */
export type Plugins = (Falsy | WebpackPluginInstance | WebpackPluginFunction)[];
/**
 * Capture timing information for each module.
 */
export type Profile = boolean;
/**
 * Store compiler state to a json file.
 */
export type RecordsInputPath = false | string;
/**
 * Load compiler state from a json file.
 */
export type RecordsOutputPath = false | string;
/**
 * Store/Load compiler state from/to a json file. This will result in persistent ids of modules and chunks. An absolute path is expected. `recordsPath` is used for `recordsInputPath` and `recordsOutputPath` if they left undefined.
 */
export type RecordsPath = false | string;
/**
 * Options for the resolver.
 */
export type Resolve = ResolveOptions;
/**
 * Options for the resolver when resolving loaders.
 */
export type ResolveLoader = ResolveOptions;
/**
 * Stats options object or preset name.
 */
export type StatsValue =
	| (
			| "none"
			| "summary"
			| "errors-only"
			| "errors-warnings"
			| "minimal"
			| "normal"
			| "detailed"
			| "verbose"
	  )
	| boolean
	| StatsOptions;
/**
 * Filtering modules.
 */
export type ModuleFilterTypes = ModuleFilterItemTypes[] | ModuleFilterItemTypes;
/**
 * Filtering value, regexp or function.
 */
export type ModuleFilterItemTypes =
	| RegExp
	| string
	| ((
			name: string,
			module: import("../lib/stats/DefaultStatsFactoryPlugin").StatsModule,
			type: "module" | "chunk" | "root-of-chunk" | "nested"
	  ) => boolean);
/**
 * Filtering modules.
 */
export type AssetFilterTypes = AssetFilterItemTypes[] | AssetFilterItemTypes;
/**
 * Filtering value, regexp or function.
 */
export type AssetFilterItemTypes =
	| RegExp
	| string
	| ((
			name: string,
			asset: import("../lib/stats/DefaultStatsFactoryPlugin").StatsAsset
	  ) => boolean);
/**
 * Filtering warnings.
 */
export type WarningFilterTypes =
	| WarningFilterItemTypes[]
	| WarningFilterItemTypes;
/**
 * Filtering value, regexp or function.
 */
export type WarningFilterItemTypes =
	| RegExp
	| string
	| ((
			warning: import("../lib/stats/DefaultStatsFactoryPlugin").StatsError,
			value: string
	  ) => boolean);
/**
 * Environment to build for. An array of environments to build for all of them when possible.
 */
export type Target = string[] | false | string;
/**
 * Enter watch mode, which rebuilds on file change.
 */
export type Watch = boolean;
/**
 * The options for data url generator.
 */
export type AssetGeneratorDataUrl =
	| AssetGeneratorDataUrlOptions
	| AssetGeneratorDataUrlFunction;
/**
 * Function that executes for module and should return an DataUrl string. It can have a string as 'ident' property which contributes to the module hash.
 */
export type AssetGeneratorDataUrlFunction = (
	source: string | Buffer,
	context: {filename: string; module: import("../lib/Module")}
) => string;
/**
 * Generator options for asset modules.
 */
export type AssetGeneratorOptions = AssetInlineGeneratorOptions &
	AssetResourceGeneratorOptions;
/**
 * Emit the asset in the specified folder relative to 'output.path'. This should only be needed when custom 'publicPath' is specified to match the folder structure there.
 */
export type AssetModuleOutputPath =
	| string
	| ((
			pathData: import("../lib/Compilation").PathData,
			assetInfo?: import("../lib/Compilation").AssetInfo
	  ) => string);
/**
 * Function that executes for module and should return whenever asset should be inlined as DataUrl.
 */
export type AssetParserDataUrlFunction = (
	source: string | Buffer,
	context: {filename: string; module: import("../lib/Module")}
) => boolean;
/**
 * A Function returning a Promise resolving to a normalized entry.
 */
export type EntryDynamicNormalized = () => Promise<EntryStaticNormalized>;
/**
 * The entry point(s) of the compilation.
 */
export type EntryNormalized = EntryDynamicNormalized | EntryStaticNormalized;
/**
 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
 */
export type ExperimentsNormalized = ExperimentsCommon &
	ExperimentsNormalizedExtra;
/**
 * The dependency used for the external.
 */
export type ExternalItemValue =
	| string[]
	| boolean
	| string
	| {
			[k: string]: any;
	  };
/**
 * List of allowed URIs for building http resources.
 */
export type HttpUriAllowedUris = HttpUriOptionsAllowedUris;
/**
 * List of allowed URIs (resp. the beginning of them).
 */
export type HttpUriOptionsAllowedUris = (
	| RegExp
	| string
	| ((uri: string) => boolean)
)[];
/**
 * Ignore specific warnings.
 */
export type IgnoreWarningsNormalized = ((
	warning: import("../lib/WebpackError"),
	compilation: import("../lib/Compilation")
) => boolean)[];
/**
 * Create an additional chunk which contains only the webpack runtime and chunk hash maps.
 */
export type OptimizationRuntimeChunkNormalized =
	| false
	| {
			/**
			 * The name factory for the runtime chunks.
			 */
			name?: Function;
	  };
/**
 * A function returning cache groups.
 */
export type OptimizationSplitChunksGetCacheGroups = (
	module: import("../lib/Module")
) =>
	| OptimizationSplitChunksCacheGroup
	| OptimizationSplitChunksCacheGroup[]
	| void;

/**
 * Options object as provided by the user.
 */
export interface WebpackOptions {
	/**
	 * Set the value of `require.amd` and `define.amd`. Or disable AMD support.
	 */
	amd?: Amd;
	/**
	 * Report the first error as a hard error instead of tolerating it.
	 */
	bail?: Bail;
	/**
	 * Cache generated modules and chunks to improve performance for multiple incremental builds.
	 */
	cache?: CacheOptions;
	/**
	 * The base directory (absolute path!) for resolving the `entry` option. If `output.pathinfo` is set, the included pathinfo is shortened to this directory.
	 */
	context?: Context;
	/**
	 * References to other configurations to depend on.
	 */
	dependencies?: Dependencies;
	/**
	 * Options for the webpack-dev-server.
	 */
	devServer?: DevServer;
	/**
	 * A developer tool to enhance debugging (false | eval | [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map).
	 */
	devtool?: DevTool;
	/**
	 * The entry point(s) of the compilation.
	 */
	entry?: Entry;
	/**
	 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
	 */
	experiments?: Experiments;
	/**
	 * Extend configuration from another configuration (only works when using webpack-cli).
	 */
	extends?: Extends;
	/**
	 * Specify dependencies that shouldn't be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.
	 */
	externals?: Externals;
	/**
	 * Enable presets of externals for specific targets.
	 */
	externalsPresets?: ExternalsPresets;
	/**
	 * Specifies the default type of externals ('amd*', 'umd*', 'system' and 'jsonp' depend on output.libraryTarget set to the same value).
	 */
	externalsType?: ExternalsType;
	/**
	 * Ignore specific warnings.
	 */
	ignoreWarnings?: IgnoreWarnings;
	/**
	 * Options for infrastructure level logging.
	 */
	infrastructureLogging?: InfrastructureLogging;
	/**
	 * Custom values available in the loader context.
	 */
	loader?: Loader;
	/**
	 * Enable production optimizations or development hints.
	 */
	mode?: Mode;
	/**
	 * Options affecting the normal modules (`NormalModuleFactory`).
	 */
	module?: ModuleOptions;
	/**
	 * Name of the configuration. Used when loading multiple configurations.
	 */
	name?: Name;
	/**
	 * Include polyfills or mocks for various node stuff.
	 */
	node?: Node;
	/**
	 * Enables/Disables integrated optimizations.
	 */
	optimization?: Optimization;
	/**
	 * Options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
	 */
	output?: Output;
	/**
	 * The number of parallel processed modules in the compilation.
	 */
	parallelism?: Parallelism;
	/**
	 * Configuration for web performance recommendations.
	 */
	performance?: Performance;
	/**
	 * Add additional plugins to the compiler.
	 */
	plugins?: Plugins;
	/**
	 * Capture timing information for each module.
	 */
	profile?: Profile;
	/**
	 * Store compiler state to a json file.
	 */
	recordsInputPath?: RecordsInputPath;
	/**
	 * Load compiler state from a json file.
	 */
	recordsOutputPath?: RecordsOutputPath;
	/**
	 * Store/Load compiler state from/to a json file. This will result in persistent ids of modules and chunks. An absolute path is expected. `recordsPath` is used for `recordsInputPath` and `recordsOutputPath` if they left undefined.
	 */
	recordsPath?: RecordsPath;
	/**
	 * Options for the resolver.
	 */
	resolve?: Resolve;
	/**
	 * Options for the resolver when resolving loaders.
	 */
	resolveLoader?: ResolveLoader;
	/**
	 * Options affecting how file system snapshots are created and validated.
	 */
	snapshot?: SnapshotOptions;
	/**
	 * Stats options object or preset name.
	 */
	stats?: StatsValue;
	/**
	 * Environment to build for. An array of environments to build for all of them when possible.
	 */
	target?: Target;
	/**
	 * Enter watch mode, which rebuilds on file change.
	 */
	watch?: Watch;
	/**
	 * Options for the watcher.
	 */
	watchOptions?: WatchOptions;
}
/**
 * Options object for in-memory caching.
 */
export interface MemoryCacheOptions {
	/**
	 * Additionally cache computation of modules that are unchanged and reference only unchanged modules.
	 */
	cacheUnaffected?: boolean;
	/**
	 * Number of generations unused cache entries stay in memory cache at minimum (1 = may be removed after unused for a single compilation, ..., Infinity: kept forever).
	 */
	maxGenerations?: number;
	/**
	 * In memory caching.
	 */
	type: "memory";
}
/**
 * Options object for persistent file-based caching.
 */
export interface FileCacheOptions {
	/**
	 * Allows to collect unused memory allocated during deserialization. This requires copying data into smaller buffers and has a performance cost.
	 */
	allowCollectingMemory?: boolean;
	/**
	 * Dependencies the build depends on (in multiple categories, default categories: 'defaultWebpack').
	 */
	buildDependencies?: {
		/**
		 * List of dependencies the build depends on.
		 */
		[k: string]: string[];
	};
	/**
	 * Base directory for the cache (defaults to node_modules/.cache/webpack).
	 */
	cacheDirectory?: string;
	/**
	 * Locations for the cache (defaults to cacheDirectory / name).
	 */
	cacheLocation?: string;
	/**
	 * Compression type used for the cache files.
	 */
	compression?: false | "gzip" | "brotli";
	/**
	 * Algorithm used for generation the hash (see node.js crypto package).
	 */
	hashAlgorithm?: string;
	/**
	 * Time in ms after which idle period the cache storing should happen.
	 */
	idleTimeout?: number;
	/**
	 * Time in ms after which idle period the cache storing should happen when larger changes has been detected (cumulative build time > 2 x avg cache store time).
	 */
	idleTimeoutAfterLargeChanges?: number;
	/**
	 * Time in ms after which idle period the initial cache storing should happen.
	 */
	idleTimeoutForInitialStore?: number;
	/**
	 * List of paths that are managed by a package manager and contain a version or hash in its path so all files are immutable.
	 */
	immutablePaths?: (RegExp | string)[];
	/**
	 * List of paths that are managed by a package manager and can be trusted to not be modified otherwise.
	 */
	managedPaths?: (RegExp | string)[];
	/**
	 * Time for which unused cache entries stay in the filesystem cache at minimum (in milliseconds).
	 */
	maxAge?: number;
	/**
	 * Number of generations unused cache entries stay in memory cache at minimum (0 = no memory cache used, 1 = may be removed after unused for a single compilation, ..., Infinity: kept forever). Cache entries will be deserialized from disk when removed from memory cache.
	 */
	maxMemoryGenerations?: number;
	/**
	 * Additionally cache computation of modules that are unchanged and reference only unchanged modules in memory.
	 */
	memoryCacheUnaffected?: boolean;
	/**
	 * Name for the cache. Different names will lead to different coexisting caches.
	 */
	name?: string;
	/**
	 * Track and log detailed timing information for individual cache items.
	 */
	profile?: boolean;
	/**
	 * Enable/disable readonly mode.
	 */
	readonly?: boolean;
	/**
	 * When to store data to the filesystem. (pack: Store data when compiler is idle in a single file).
	 */
	store?: "pack";
	/**
	 * Filesystem caching.
	 */
	type: "filesystem";
	/**
	 * Version of the cache data. Different versions won't allow to reuse the cache and override existing content. Update the version when config changed in a way which doesn't allow to reuse cache. This will invalidate the cache.
	 */
	version?: string;
}
/**
 * Options for the webpack-dev-server.
 */
export interface DevServer {
	[k: string]: any;
}
/**
 * Multiple entry bundles are created. The key is the entry name. The value can be a string, an array or an entry description object.
 */
export interface EntryObject {
	/**
	 * An entry point with name.
	 */
	[k: string]: EntryItem | EntryDescription;
}
/**
 * An object with entry point description.
 */
export interface EntryDescription {
	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;
	/**
	 * Base uri for this entry.
	 */
	baseUri?: string;
	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: ChunkLoading;
	/**
	 * The entrypoints that the current entrypoint depend on. They must be loaded when this entrypoint is loaded.
	 */
	dependOn?: string[] | string;
	/**
	 * Specifies the filename of the output file on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: EntryFilename;
	/**
	 * Module(s) that are loaded upon startup.
	 */
	import: EntryItem;
	/**
	 * Specifies the layer in which modules of this entrypoint are placed.
	 */
	layer?: Layer;
	/**
	 * Options for library.
	 */
	library?: LibraryOptions;
	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: PublicPath;
	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: EntryRuntime;
	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: WasmLoading;
}
/**
 * Options for library.
 */
export interface LibraryOptions {
	/**
	 * Add a container for define/require functions in the AMD module.
	 */
	amdContainer?: AmdContainer;
	/**
	 * Add a comment in the UMD wrapper.
	 */
	auxiliaryComment?: AuxiliaryComment;
	/**
	 * Specify which export should be exposed as library.
	 */
	export?: LibraryExport;
	/**
	 * The name of the library (some types allow unnamed libraries too).
	 */
	name?: LibraryName;
	/**
	 * Type of library (types included by default are 'var', 'module', 'assign', 'assign-properties', 'this', 'window', 'self', 'global', 'commonjs', 'commonjs2', 'commonjs-module', 'commonjs-static', 'amd', 'amd-require', 'umd', 'umd2', 'jsonp', 'system', but others might be added by plugins).
	 */
	type: LibraryType;
	/**
	 * If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.
	 */
	umdNamedDefine?: UmdNamedDefine;
}
/**
 * Set explicit comments for `commonjs`, `commonjs2`, `amd`, and `root`.
 */
export interface LibraryCustomUmdCommentObject {
	/**
	 * Set comment for `amd` section in UMD.
	 */
	amd?: string;
	/**
	 * Set comment for `commonjs` (exports) section in UMD.
	 */
	commonjs?: string;
	/**
	 * Set comment for `commonjs2` (module.exports) section in UMD.
	 */
	commonjs2?: string;
	/**
	 * Set comment for `root` (global variable) section in UMD.
	 */
	root?: string;
}
/**
 * Description object for all UMD variants of the library name.
 */
export interface LibraryCustomUmdObject {
	/**
	 * Name of the exposed AMD library in the UMD.
	 */
	amd?: string;
	/**
	 * Name of the exposed commonjs export in the UMD.
	 */
	commonjs?: string;
	/**
	 * Name of the property exposed globally by a UMD library.
	 */
	root?: string[] | string;
}
/**
 * Enable presets of externals for specific targets.
 */
export interface ExternalsPresets {
	/**
	 * Treat common electron built-in modules in main and preload context like 'electron', 'ipc' or 'shell' as external and load them via require() when used.
	 */
	electron?: boolean;
	/**
	 * Treat electron built-in modules in the main context like 'app', 'ipc-main' or 'shell' as external and load them via require() when used.
	 */
	electronMain?: boolean;
	/**
	 * Treat electron built-in modules in the preload context like 'web-frame', 'ipc-renderer' or 'shell' as external and load them via require() when used.
	 */
	electronPreload?: boolean;
	/**
	 * Treat electron built-in modules in the renderer context like 'web-frame', 'ipc-renderer' or 'shell' as external and load them via require() when used.
	 */
	electronRenderer?: boolean;
	/**
	 * Treat node.js built-in modules like fs, path or vm as external and load them via require() when used.
	 */
	node?: boolean;
	/**
	 * Treat NW.js legacy nw.gui module as external and load it via require() when used.
	 */
	nwjs?: boolean;
	/**
	 * Treat references to 'http(s)://...' and 'std:...' as external and load them via import when used (Note that this changes execution order as externals are executed before any other code in the chunk).
	 */
	web?: boolean;
	/**
	 * Treat references to 'http(s)://...' and 'std:...' as external and load them via async import() when used (Note that this external type is an async module, which has various effects on the execution).
	 */
	webAsync?: boolean;
}
/**
 * Options for infrastructure level logging.
 */
export interface InfrastructureLogging {
	/**
	 * Only appends lines to the output. Avoids updating existing output e. g. for status messages. This option is only used when no custom console is provided.
	 */
	appendOnly?: boolean;
	/**
	 * Enables/Disables colorful output. This option is only used when no custom console is provided.
	 */
	colors?: boolean;
	/**
	 * Custom console used for logging.
	 */
	console?: Console;
	/**
	 * Enable debug logging for specific loggers.
	 */
	debug?: boolean | FilterTypes;
	/**
	 * Log level.
	 */
	level?: "none" | "error" | "warn" | "info" | "log" | "verbose";
	/**
	 * Stream used for logging output. Defaults to process.stderr. This option is only used when no custom console is provided.
	 */
	stream?: NodeJS.WritableStream;
}
/**
 * Custom values available in the loader context.
 */
export interface Loader {
	[k: string]: any;
}
/**
 * Options affecting the normal modules (`NormalModuleFactory`).
 */
export interface ModuleOptions {
	/**
	 * An array of rules applied by default for modules.
	 */
	defaultRules?: RuleSetRules;
	/**
	 * Enable warnings for full dynamic dependencies.
	 */
	exprContextCritical?: boolean;
	/**
	 * Enable recursive directory lookup for full dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.exprContextRecursive'.
	 */
	exprContextRecursive?: boolean;
	/**
	 * Sets the default regular expression for full dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.exprContextRegExp'.
	 */
	exprContextRegExp?: RegExp | boolean;
	/**
	 * Set the default request for full dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.exprContextRequest'.
	 */
	exprContextRequest?: string;
	/**
	 * Specify options for each generator.
	 */
	generator?: GeneratorOptionsByModuleType;
	/**
	 * Don't parse files matching. It's matched against the full resolved request.
	 */
	noParse?: NoParse;
	/**
	 * Specify options for each parser.
	 */
	parser?: ParserOptionsByModuleType;
	/**
	 * An array of rules applied for modules.
	 */
	rules?: RuleSetRules;
	/**
	 * Emit errors instead of warnings when imported names don't exist in imported module. Deprecated: This option has moved to 'module.parser.javascript.strictExportPresence'.
	 */
	strictExportPresence?: boolean;
	/**
	 * Handle the this context correctly according to the spec for namespace objects. Deprecated: This option has moved to 'module.parser.javascript.strictThisContextOnImports'.
	 */
	strictThisContextOnImports?: boolean;
	/**
	 * Enable warnings when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextCritical'.
	 */
	unknownContextCritical?: boolean;
	/**
	 * Enable recursive directory lookup when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextRecursive'.
	 */
	unknownContextRecursive?: boolean;
	/**
	 * Sets the regular expression when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextRegExp'.
	 */
	unknownContextRegExp?: RegExp | boolean;
	/**
	 * Sets the request when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextRequest'.
	 */
	unknownContextRequest?: string;
	/**
	 * Cache the resolving of module requests.
	 */
	unsafeCache?: boolean | Function;
	/**
	 * Enable warnings for partial dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.wrappedContextCritical'.
	 */
	wrappedContextCritical?: boolean;
	/**
	 * Enable recursive directory lookup for partial dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.wrappedContextRecursive'.
	 */
	wrappedContextRecursive?: boolean;
	/**
	 * Set the inner regular expression for partial dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.wrappedContextRegExp'.
	 */
	wrappedContextRegExp?: RegExp;
}
/**
 * A rule description with conditions and effects for modules.
 */
export interface RuleSetRule {
	/**
	 * Match on import assertions of the dependency.
	 */
	assert?: {
		[k: string]: RuleSetConditionOrConditions;
	};
	/**
	 * Match the child compiler name.
	 */
	compiler?: RuleSetConditionOrConditions;
	/**
	 * Match dependency type.
	 */
	dependency?: RuleSetConditionOrConditions;
	/**
	 * Match values of properties in the description file (usually package.json).
	 */
	descriptionData?: {
		[k: string]: RuleSetConditionOrConditions;
	};
	/**
	 * Enforce this rule as pre or post step.
	 */
	enforce?: "pre" | "post";
	/**
	 * Shortcut for resource.exclude.
	 */
	exclude?: RuleSetConditionOrConditionsAbsolute;
	/**
	 * The options for the module generator.
	 */
	generator?: {
		[k: string]: any;
	};
	/**
	 * Shortcut for resource.include.
	 */
	include?: RuleSetConditionOrConditionsAbsolute;
	/**
	 * Match the issuer of the module (The module pointing to this module).
	 */
	issuer?: RuleSetConditionOrConditionsAbsolute;
	/**
	 * Match layer of the issuer of this module (The module pointing to this module).
	 */
	issuerLayer?: RuleSetConditionOrConditions;
	/**
	 * Specifies the layer in which the module should be placed in.
	 */
	layer?: string;
	/**
	 * Shortcut for use.loader.
	 */
	loader?: RuleSetLoader;
	/**
	 * Match module mimetype when load from Data URI.
	 */
	mimetype?: RuleSetConditionOrConditions;
	/**
	 * Only execute the first matching rule in this array.
	 */
	oneOf?: (Falsy | RuleSetRule)[];
	/**
	 * Shortcut for use.options.
	 */
	options?: RuleSetLoaderOptions;
	/**
	 * Options for parsing.
	 */
	parser?: {
		[k: string]: any;
	};
	/**
	 * Match the real resource path of the module.
	 */
	realResource?: RuleSetConditionOrConditionsAbsolute;
	/**
	 * Options for the resolver.
	 */
	resolve?: ResolveOptions;
	/**
	 * Match the resource path of the module.
	 */
	resource?: RuleSetConditionOrConditionsAbsolute;
	/**
	 * Match the resource fragment of the module.
	 */
	resourceFragment?: RuleSetConditionOrConditions;
	/**
	 * Match the resource query of the module.
	 */
	resourceQuery?: RuleSetConditionOrConditions;
	/**
	 * Match and execute these rules when this rule is matched.
	 */
	rules?: (Falsy | RuleSetRule)[];
	/**
	 * Match module scheme.
	 */
	scheme?: RuleSetConditionOrConditions;
	/**
	 * Flags a module as with or without side effects.
	 */
	sideEffects?: boolean;
	/**
	 * Shortcut for resource.test.
	 */
	test?: RuleSetConditionOrConditionsAbsolute;
	/**
	 * Module type to use for the module.
	 */
	type?: string;
	/**
	 * Modifiers applied to the module when rule is matched.
	 */
	use?: RuleSetUse;
}
/**
 * Logic operators used in a condition matcher.
 */
export interface RuleSetLogicalConditions {
	/**
	 * Logical AND.
	 */
	and?: RuleSetConditions;
	/**
	 * Logical NOT.
	 */
	not?: RuleSetCondition;
	/**
	 * Logical OR.
	 */
	or?: RuleSetConditions;
}
/**
 * Logic operators used in a condition matcher.
 */
export interface RuleSetLogicalConditionsAbsolute {
	/**
	 * Logical AND.
	 */
	and?: RuleSetConditionsAbsolute;
	/**
	 * Logical NOT.
	 */
	not?: RuleSetConditionAbsolute;
	/**
	 * Logical OR.
	 */
	or?: RuleSetConditionsAbsolute;
}
/**
 * Options object for resolving requests.
 */
export interface ResolveOptions {
	/**
	 * Redirect module requests.
	 */
	alias?: ResolveAlias;
	/**
	 * Fields in the description file (usually package.json) which are used to redirect requests inside the module.
	 */
	aliasFields?: (string[] | string)[];
	/**
	 * Extra resolve options per dependency category. Typical categories are "commonjs", "amd", "esm".
	 */
	byDependency?: {
		/**
		 * Options object for resolving requests.
		 */
		[k: string]: ResolveOptions;
	};
	/**
	 * Enable caching of successfully resolved requests (cache entries are revalidated).
	 */
	cache?: boolean;
	/**
	 * Predicate function to decide which requests should be cached.
	 */
	cachePredicate?: (
		request: import("enhanced-resolve").ResolveRequest
	) => boolean;
	/**
	 * Include the context information in the cache identifier when caching.
	 */
	cacheWithContext?: boolean;
	/**
	 * Condition names for exports field entry point.
	 */
	conditionNames?: string[];
	/**
	 * Filenames used to find a description file (like a package.json).
	 */
	descriptionFiles?: string[];
	/**
	 * Enforce the resolver to use one of the extensions from the extensions option (User must specify requests without extension).
	 */
	enforceExtension?: boolean;
	/**
	 * Field names from the description file (usually package.json) which are used to provide entry points of a package.
	 */
	exportsFields?: string[];
	/**
	 * An object which maps extension to extension aliases.
	 */
	extensionAlias?: {
		/**
		 * Extension alias.
		 */
		[k: string]: string[] | string;
	};
	/**
	 * Extensions added to the request when trying to find the file.
	 */
	extensions?: string[];
	/**
	 * Redirect module requests when normal resolving fails.
	 */
	fallback?: ResolveAlias;
	/**
	 * Filesystem for the resolver.
	 */
	fileSystem?: import("../lib/util/fs").InputFileSystem;
	/**
	 * Treats the request specified by the user as fully specified, meaning no extensions are added and the mainFiles in directories are not resolved (This doesn't affect requests from mainFields, aliasFields or aliases).
	 */
	fullySpecified?: boolean;
	/**
	 * Field names from the description file (usually package.json) which are used to provide internal request of a package (requests starting with # are considered as internal).
	 */
	importsFields?: string[];
	/**
	 * Field names from the description file (package.json) which are used to find the default entry point.
	 */
	mainFields?: (string[] | string)[];
	/**
	 * Filenames used to find the default entry point if there is no description file or main field.
	 */
	mainFiles?: string[];
	/**
	 * Folder names or directory paths where to find modules.
	 */
	modules?: string[];
	/**
	 * Plugins for the resolver.
	 */
	plugins?: ("..." | Falsy | ResolvePluginInstance)[];
	/**
	 * Prefer to resolve server-relative URLs (starting with '/') as absolute paths before falling back to resolve in 'resolve.roots'.
	 */
	preferAbsolute?: boolean;
	/**
	 * Prefer to resolve module requests as relative request and fallback to resolving as module.
	 */
	preferRelative?: boolean;
	/**
	 * Custom resolver.
	 */
	resolver?: import("enhanced-resolve").Resolver;
	/**
	 * A list of resolve restrictions. Resolve results must fulfill all of these restrictions to resolve successfully. Other resolve paths are taken when restrictions are not met.
	 */
	restrictions?: (RegExp | string)[];
	/**
	 * A list of directories in which requests that are server-relative URLs (starting with '/') are resolved.
	 */
	roots?: string[];
	/**
	 * Enable resolving symlinks to the original location.
	 */
	symlinks?: boolean;
	/**
	 * Enable caching of successfully resolved requests (cache entries are not revalidated).
	 */
	unsafeCache?:
		| boolean
		| {
				[k: string]: any;
		  };
	/**
	 * Use synchronous filesystem calls for the resolver.
	 */
	useSyncFileSystemCalls?: boolean;
}
/**
 * Plugin instance.
 */
export interface ResolvePluginInstance {
	/**
	 * The run point of the plugin, required method.
	 */
	apply: (resolver: import("enhanced-resolve").Resolver) => void;
	[k: string]: any;
}
/**
 * Options object for node compatibility features.
 */
export interface NodeOptions {
	/**
	 * Include a polyfill for the '__dirname' variable.
	 */
	__dirname?: false | true | "warn-mock" | "mock" | "eval-only";
	/**
	 * Include a polyfill for the '__filename' variable.
	 */
	__filename?: false | true | "warn-mock" | "mock" | "eval-only";
	/**
	 * Include a polyfill for the 'global' variable.
	 */
	global?: false | true | "warn";
}
/**
 * Enables/Disables integrated optimizations.
 */
export interface Optimization {
	/**
	 * Check for incompatible wasm types when importing/exporting from/to ESM.
	 */
	checkWasmTypes?: boolean;
	/**
	 * Define the algorithm to choose chunk ids (named: readable ids for better debugging, deterministic: numeric hash ids for better long term caching, size: numeric ids focused on minimal initial download size, total-size: numeric ids focused on minimal total download size, false: no algorithm used, as custom one can be provided via plugin).
	 */
	chunkIds?:
		| "natural"
		| "named"
		| "deterministic"
		| "size"
		| "total-size"
		| false;
	/**
	 * Concatenate modules when possible to generate less modules, more efficient code and enable more optimizations by the minimizer.
	 */
	concatenateModules?: boolean;
	/**
	 * Emit assets even when errors occur. Critical errors are emitted into the generated code and will cause errors at runtime.
	 */
	emitOnErrors?: boolean;
	/**
	 * Also flag chunks as loaded which contain a subset of the modules.
	 */
	flagIncludedChunks?: boolean;
	/**
	 * Creates a module-internal dependency graph for top level symbols, exports and imports, to improve unused exports detection.
	 */
	innerGraph?: boolean;
	/**
	 * Rename exports when possible to generate shorter code (depends on optimization.usedExports and optimization.providedExports, true/"deterministic": generate short deterministic names optimized for caching, "size": generate the shortest possible names).
	 */
	mangleExports?: ("size" | "deterministic") | boolean;
	/**
	 * Reduce size of WASM by changing imports to shorter strings.
	 */
	mangleWasmImports?: boolean;
	/**
	 * Merge chunks which contain the same modules.
	 */
	mergeDuplicateChunks?: boolean;
	/**
	 * Enable minimizing the output. Uses optimization.minimizer.
	 */
	minimize?: boolean;
	/**
	 * Minimizer(s) to use for minimizing the output.
	 */
	minimizer?: ("..." | Falsy | WebpackPluginInstance | WebpackPluginFunction)[];
	/**
	 * Define the algorithm to choose module ids (natural: numeric ids in order of usage, named: readable ids for better debugging, hashed: (deprecated) short hashes as ids for better long term caching, deterministic: numeric hash ids for better long term caching, size: numeric ids focused on minimal initial download size, false: no algorithm used, as custom one can be provided via plugin).
	 */
	moduleIds?: "natural" | "named" | "hashed" | "deterministic" | "size" | false;
	/**
	 * Avoid emitting assets when errors occur (deprecated: use 'emitOnErrors' instead).
	 */
	noEmitOnErrors?: boolean;
	/**
	 * Set process.env.NODE_ENV to a specific value.
	 */
	nodeEnv?: false | string;
	/**
	 * Generate records with relative paths to be able to move the context folder.
	 */
	portableRecords?: boolean;
	/**
	 * Figure out which exports are provided by modules to generate more efficient code.
	 */
	providedExports?: boolean;
	/**
	 * Use real [contenthash] based on final content of the assets.
	 */
	realContentHash?: boolean;
	/**
	 * Removes modules from chunks when these modules are already included in all parents.
	 */
	removeAvailableModules?: boolean;
	/**
	 * Remove chunks which are empty.
	 */
	removeEmptyChunks?: boolean;
	/**
	 * Create an additional chunk which contains only the webpack runtime and chunk hash maps.
	 */
	runtimeChunk?: OptimizationRuntimeChunk;
	/**
	 * Skip over modules which contain no side effects when exports are not used (false: disabled, 'flag': only use manually placed side effects flag, true: also analyse source code for side effects).
	 */
	sideEffects?: "flag" | boolean;
	/**
	 * Optimize duplication and caching by splitting chunks by shared modules and cache group.
	 */
	splitChunks?: false | OptimizationSplitChunksOptions;
	/**
	 * Figure out which exports are used by modules to mangle export names, omit unused exports and generate more efficient code (true: analyse used exports for each runtime, "global": analyse exports globally for all runtimes combined).
	 */
	usedExports?: "global" | boolean;
}
/**
 * Plugin instance.
 */
export interface WebpackPluginInstance {
	/**
	 * The run point of the plugin, required method.
	 */
	apply: (compiler: import("../lib/Compiler")) => void;
	[k: string]: any;
}
/**
 * Options object for splitting chunks into smaller chunks.
 */
export interface OptimizationSplitChunksOptions {
	/**
	 * Sets the name delimiter for created chunks.
	 */
	automaticNameDelimiter?: string;
	/**
	 * Assign modules to a cache group (modules from different cache groups are tried to keep in separate chunks, default categories: 'default', 'defaultVendors').
	 */
	cacheGroups?: {
		/**
		 * Configuration for a cache group.
		 */
		[k: string]:
			| false
			| RegExp
			| string
			| Function
			| OptimizationSplitChunksCacheGroup;
	};
	/**
	 * Select chunks for determining shared modules (defaults to "async", "initial" and "all" requires adding these chunks to the HTML).
	 */
	chunks?:
		| ("initial" | "async" | "all")
		| RegExp
		| ((chunk: import("../lib/Chunk")) => boolean);
	/**
	 * Sets the size types which are used when a number is used for sizes.
	 */
	defaultSizeTypes?: string[];
	/**
	 * Size threshold at which splitting is enforced and other restrictions (minRemainingSize, maxAsyncRequests, maxInitialRequests) are ignored.
	 */
	enforceSizeThreshold?: OptimizationSplitChunksSizes;
	/**
	 * Options for modules not selected by any other cache group.
	 */
	fallbackCacheGroup?: {
		/**
		 * Sets the name delimiter for created chunks.
		 */
		automaticNameDelimiter?: string;
		/**
		 * Select chunks for determining shared modules (defaults to "async", "initial" and "all" requires adding these chunks to the HTML).
		 */
		chunks?:
			| ("initial" | "async" | "all")
			| RegExp
			| ((chunk: import("../lib/Chunk")) => boolean);
		/**
		 * Maximal size hint for the on-demand chunks.
		 */
		maxAsyncSize?: OptimizationSplitChunksSizes;
		/**
		 * Maximal size hint for the initial chunks.
		 */
		maxInitialSize?: OptimizationSplitChunksSizes;
		/**
		 * Maximal size hint for the created chunks.
		 */
		maxSize?: OptimizationSplitChunksSizes;
		/**
		 * Minimal size for the created chunk.
		 */
		minSize?: OptimizationSplitChunksSizes;
		/**
		 * Minimum size reduction due to the created chunk.
		 */
		minSizeReduction?: OptimizationSplitChunksSizes;
	};
	/**
	 * Sets the template for the filename for created chunks.
	 */
	filename?:
		| string
		| ((
				pathData: import("../lib/Compilation").PathData,
				assetInfo?: import("../lib/Compilation").AssetInfo
		  ) => string);
	/**
	 * Prevents exposing path info when creating names for parts splitted by maxSize.
	 */
	hidePathInfo?: boolean;
	/**
	 * Maximum number of requests which are accepted for on-demand loading.
	 */
	maxAsyncRequests?: number;
	/**
	 * Maximal size hint for the on-demand chunks.
	 */
	maxAsyncSize?: OptimizationSplitChunksSizes;
	/**
	 * Maximum number of initial chunks which are accepted for an entry point.
	 */
	maxInitialRequests?: number;
	/**
	 * Maximal size hint for the initial chunks.
	 */
	maxInitialSize?: OptimizationSplitChunksSizes;
	/**
	 * Maximal size hint for the created chunks.
	 */
	maxSize?: OptimizationSplitChunksSizes;
	/**
	 * Minimum number of times a module has to be duplicated until it's considered for splitting.
	 */
	minChunks?: number;
	/**
	 * Minimal size for the chunks the stay after moving the modules to a new chunk.
	 */
	minRemainingSize?: OptimizationSplitChunksSizes;
	/**
	 * Minimal size for the created chunks.
	 */
	minSize?: OptimizationSplitChunksSizes;
	/**
	 * Minimum size reduction due to the created chunk.
	 */
	minSizeReduction?: OptimizationSplitChunksSizes;
	/**
	 * Give chunks created a name (chunks with equal name are merged).
	 */
	name?: false | string | Function;
	/**
	 * Compare used exports when checking common modules. Modules will only be put in the same chunk when exports are equal.
	 */
	usedExports?: boolean;
}
/**
 * Options object for describing behavior of a cache group selecting modules that should be cached together.
 */
export interface OptimizationSplitChunksCacheGroup {
	/**
	 * Sets the name delimiter for created chunks.
	 */
	automaticNameDelimiter?: string;
	/**
	 * Select chunks for determining cache group content (defaults to "initial", "initial" and "all" requires adding these chunks to the HTML).
	 */
	chunks?:
		| ("initial" | "async" | "all")
		| RegExp
		| ((chunk: import("../lib/Chunk")) => boolean);
	/**
	 * Ignore minimum size, minimum chunks and maximum requests and always create chunks for this cache group.
	 */
	enforce?: boolean;
	/**
	 * Size threshold at which splitting is enforced and other restrictions (minRemainingSize, maxAsyncRequests, maxInitialRequests) are ignored.
	 */
	enforceSizeThreshold?: OptimizationSplitChunksSizes;
	/**
	 * Sets the template for the filename for created chunks.
	 */
	filename?:
		| string
		| ((
				pathData: import("../lib/Compilation").PathData,
				assetInfo?: import("../lib/Compilation").AssetInfo
		  ) => string);
	/**
	 * Sets the hint for chunk id.
	 */
	idHint?: string;
	/**
	 * Assign modules to a cache group by module layer.
	 */
	layer?: RegExp | string | Function;
	/**
	 * Maximum number of requests which are accepted for on-demand loading.
	 */
	maxAsyncRequests?: number;
	/**
	 * Maximal size hint for the on-demand chunks.
	 */
	maxAsyncSize?: OptimizationSplitChunksSizes;
	/**
	 * Maximum number of initial chunks which are accepted for an entry point.
	 */
	maxInitialRequests?: number;
	/**
	 * Maximal size hint for the initial chunks.
	 */
	maxInitialSize?: OptimizationSplitChunksSizes;
	/**
	 * Maximal size hint for the created chunks.
	 */
	maxSize?: OptimizationSplitChunksSizes;
	/**
	 * Minimum number of times a module has to be duplicated until it's considered for splitting.
	 */
	minChunks?: number;
	/**
	 * Minimal size for the chunks the stay after moving the modules to a new chunk.
	 */
	minRemainingSize?: OptimizationSplitChunksSizes;
	/**
	 * Minimal size for the created chunk.
	 */
	minSize?: OptimizationSplitChunksSizes;
	/**
	 * Minimum size reduction due to the created chunk.
	 */
	minSizeReduction?: OptimizationSplitChunksSizes;
	/**
	 * Give chunks for this cache group a name (chunks with equal name are merged).
	 */
	name?: false | string | Function;
	/**
	 * Priority of this cache group.
	 */
	priority?: number;
	/**
	 * Try to reuse existing chunk (with name) when it has matching modules.
	 */
	reuseExistingChunk?: boolean;
	/**
	 * Assign modules to a cache group by module name.
	 */
	test?: RegExp | string | Function;
	/**
	 * Assign modules to a cache group by module type.
	 */
	type?: RegExp | string | Function;
	/**
	 * Compare used exports when checking common modules. Modules will only be put in the same chunk when exports are equal.
	 */
	usedExports?: boolean;
}
/**
 * Options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
 */
export interface Output {
	/**
	 * Add a container for define/require functions in the AMD module.
	 */
	amdContainer?: AmdContainer;
	/**
	 * The filename of asset modules as relative path inside the 'output.path' directory.
	 */
	assetModuleFilename?: AssetModuleFilename;
	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;
	/**
	 * Add a comment in the UMD wrapper.
	 */
	auxiliaryComment?: AuxiliaryComment;
	/**
	 * Add charset attribute for script tag.
	 */
	charset?: Charset;
	/**
	 * Specifies the filename template of output files of non-initial chunks on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	chunkFilename?: ChunkFilename;
	/**
	 * The format of chunks (formats included by default are 'array-push' (web/WebWorker), 'commonjs' (node.js), 'module' (ESM), but others might be added by plugins).
	 */
	chunkFormat?: ChunkFormat;
	/**
	 * Number of milliseconds before chunk request expires.
	 */
	chunkLoadTimeout?: ChunkLoadTimeout;
	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: ChunkLoading;
	/**
	 * The global variable used by webpack for loading of chunks.
	 */
	chunkLoadingGlobal?: ChunkLoadingGlobal;
	/**
	 * Clean the output directory before emit.
	 */
	clean?: Clean;
	/**
	 * Check if to be emitted file already exists and have the same content before writing to output filesystem.
	 */
	compareBeforeEmit?: CompareBeforeEmit;
	/**
	 * This option enables cross-origin loading of chunks.
	 */
	crossOriginLoading?: CrossOriginLoading;
	/**
	 * Specifies the filename template of non-initial output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssChunkFilename?: CssChunkFilename;
	/**
	 * Specifies the filename template of output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssFilename?: CssFilename;
	/**
	 * Similar to `output.devtoolModuleFilenameTemplate`, but used in the case of duplicate module identifiers.
	 */
	devtoolFallbackModuleFilenameTemplate?: DevtoolFallbackModuleFilenameTemplate;
	/**
	 * Filename template string of function for the sources array in a generated SourceMap.
	 */
	devtoolModuleFilenameTemplate?: DevtoolModuleFilenameTemplate;
	/**
	 * Module namespace to use when interpolating filename template string for the sources array in a generated SourceMap. Defaults to `output.library` if not set. It's useful for avoiding runtime collisions in sourcemaps from multiple webpack projects built as libraries.
	 */
	devtoolNamespace?: DevtoolNamespace;
	/**
	 * List of chunk loading types enabled for use by entry points.
	 */
	enabledChunkLoadingTypes?: EnabledChunkLoadingTypes;
	/**
	 * List of library types enabled for use by entry points.
	 */
	enabledLibraryTypes?: EnabledLibraryTypes;
	/**
	 * List of wasm loading types enabled for use by entry points.
	 */
	enabledWasmLoadingTypes?: EnabledWasmLoadingTypes;
	/**
	 * The abilities of the environment where the webpack generated code should run.
	 */
	environment?: Environment;
	/**
	 * Specifies the filename of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: Filename;
	/**
	 * An expression which is used to address the global object/scope in runtime code.
	 */
	globalObject?: GlobalObject;
	/**
	 * Digest type used for the hash.
	 */
	hashDigest?: HashDigest;
	/**
	 * Number of chars which are used for the hash.
	 */
	hashDigestLength?: HashDigestLength;
	/**
	 * Algorithm used for generation the hash (see node.js crypto package).
	 */
	hashFunction?: HashFunction;
	/**
	 * Any string which is added to the hash to salt it.
	 */
	hashSalt?: HashSalt;
	/**
	 * The filename of the Hot Update Chunks. They are inside the output.path directory.
	 */
	hotUpdateChunkFilename?: HotUpdateChunkFilename;
	/**
	 * The global variable used by webpack for loading of hot update chunks.
	 */
	hotUpdateGlobal?: HotUpdateGlobal;
	/**
	 * The filename of the Hot Update Main File. It is inside the 'output.path' directory.
	 */
	hotUpdateMainFilename?: HotUpdateMainFilename;
	/**
	 * Ignore warnings in the browser.
	 */
	ignoreBrowserWarnings?: boolean;
	/**
	 * Wrap javascript code into IIFE's to avoid leaking into global scope.
	 */
	iife?: Iife;
	/**
	 * The name of the native import() function (can be exchanged for a polyfill).
	 */
	importFunctionName?: ImportFunctionName;
	/**
	 * The name of the native import.meta object (can be exchanged for a polyfill).
	 */
	importMetaName?: ImportMetaName;
	/**
	 * Make the output files a library, exporting the exports of the entry point.
	 */
	library?: Library;
	/**
	 * Specify which export should be exposed as library.
	 */
	libraryExport?: LibraryExport;
	/**
	 * Type of library (types included by default are 'var', 'module', 'assign', 'assign-properties', 'this', 'window', 'self', 'global', 'commonjs', 'commonjs2', 'commonjs-module', 'commonjs-static', 'amd', 'amd-require', 'umd', 'umd2', 'jsonp', 'system', but others might be added by plugins).
	 */
	libraryTarget?: LibraryType;
	/**
	 * Output javascript files as module source type.
	 */
	module?: OutputModule;
	/**
	 * The output directory as **absolute path** (required).
	 */
	path?: Path;
	/**
	 * Include comments with information about the modules.
	 */
	pathinfo?: Pathinfo;
	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: PublicPath;
	/**
	 * This option enables loading async chunks via a custom script type, such as script type="module".
	 */
	scriptType?: ScriptType;
	/**
	 * The filename of the SourceMaps for the JavaScript files. They are inside the 'output.path' directory.
	 */
	sourceMapFilename?: SourceMapFilename;
	/**
	 * Prefixes every line of the source in the bundle with this string.
	 */
	sourcePrefix?: SourcePrefix;
	/**
	 * Handles error in module loading correctly at a performance cost. This will handle module error compatible with the EcmaScript Modules spec.
	 */
	strictModuleErrorHandling?: StrictModuleErrorHandling;
	/**
	 * Handles exceptions in module loading correctly at a performance cost (Deprecated). This will handle module error compatible with the Node.js CommonJS way.
	 */
	strictModuleExceptionHandling?: StrictModuleExceptionHandling;
	/**
	 * Use a Trusted Types policy to create urls for chunks. 'output.uniqueName' is used a default policy name. Passing a string sets a custom policy name.
	 */
	trustedTypes?: true | string | TrustedTypes;
	/**
	 * If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.
	 */
	umdNamedDefine?: UmdNamedDefine;
	/**
	 * A unique name of the webpack build to avoid multiple webpack runtimes to conflict when using globals.
	 */
	uniqueName?: UniqueName;
	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: WasmLoading;
	/**
	 * The filename of WebAssembly modules as relative path inside the 'output.path' directory.
	 */
	webassemblyModuleFilename?: WebassemblyModuleFilename;
	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	workerChunkLoading?: ChunkLoading;
	/**
	 * Worker public path. Much like the public path, this sets the location where the worker script file is intended to be found. If not set, webpack will use the publicPath. Don't set this option unless your worker scripts are located at a different path from your other script files.
	 */
	workerPublicPath?: WorkerPublicPath;
	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	workerWasmLoading?: WasmLoading;
}
/**
 * Advanced options for cleaning assets.
 */
export interface CleanOptions {
	/**
	 * Log the assets that should be removed instead of deleting them.
	 */
	dry?: boolean;
	/**
	 * Keep these assets.
	 */
	keep?: RegExp | string | ((filename: string) => boolean);
}
/**
 * The abilities of the environment where the webpack generated code should run.
 */
export interface Environment {
	/**
	 * The environment supports arrow functions ('() => { ... }').
	 */
	arrowFunction?: boolean;
	/**
	 * The environment supports BigInt as literal (123n).
	 */
	bigIntLiteral?: boolean;
	/**
	 * The environment supports const and let for variable declarations.
	 */
	const?: boolean;
	/**
	 * The environment supports destructuring ('{ a, b } = obj').
	 */
	destructuring?: boolean;
	/**
	 * The environment supports an async import() function to import EcmaScript modules.
	 */
	dynamicImport?: boolean;
	/**
	 * The environment supports an async import() is available when creating a worker.
	 */
	dynamicImportInWorker?: boolean;
	/**
	 * The environment supports 'for of' iteration ('for (const x of array) { ... }').
	 */
	forOf?: boolean;
	/**
	 * The environment supports 'globalThis'.
	 */
	globalThis?: boolean;
	/**
	 * The environment supports EcmaScript Module syntax to import EcmaScript modules (import ... from '...').
	 */
	module?: boolean;
	/**
	 * The environment supports optional chaining ('obj?.a' or 'obj?.()').
	 */
	optionalChaining?: boolean;
	/**
	 * The environment supports template literals.
	 */
	templateLiteral?: boolean;
}
/**
 * Use a Trusted Types policy to create urls for chunks.
 */
export interface TrustedTypes {
	/**
	 * If the call to `trustedTypes.createPolicy(...)` fails -- e.g., due to the policy name missing from the CSP `trusted-types` list, or it being a duplicate name, etc. -- controls whether to continue with loading in the hope that `require-trusted-types-for 'script'` isn't enforced yet, versus fail immediately. Default behavior is 'stop'.
	 */
	onPolicyCreationFailure?: "continue" | "stop";
	/**
	 * The name of the Trusted Types policy created by webpack to serve bundle chunks.
	 */
	policyName?: string;
}
/**
 * Configuration object for web performance recommendations.
 */
export interface PerformanceOptions {
	/**
	 * Filter function to select assets that are checked.
	 */
	assetFilter?: Function;
	/**
	 * Sets the format of the hints: warnings, errors or nothing at all.
	 */
	hints?: false | "warning" | "error";
	/**
	 * File size limit (in bytes) when exceeded, that webpack will provide performance hints.
	 */
	maxAssetSize?: number;
	/**
	 * Total size of an entry point (in bytes).
	 */
	maxEntrypointSize?: number;
}
/**
 * Options affecting how file system snapshots are created and validated.
 */
export interface SnapshotOptions {
	/**
	 * Options for snapshotting build dependencies to determine if the whole cache need to be invalidated.
	 */
	buildDependencies?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};
	/**
	 * List of paths that are managed by a package manager and contain a version or hash in its path so all files are immutable.
	 */
	immutablePaths?: (RegExp | string)[];
	/**
	 * List of paths that are managed by a package manager and can be trusted to not be modified otherwise.
	 */
	managedPaths?: (RegExp | string)[];
	/**
	 * Options for snapshotting dependencies of modules to determine if they need to be built again.
	 */
	module?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};
	/**
	 * Options for snapshotting dependencies of request resolving to determine if requests need to be re-resolved.
	 */
	resolve?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};
	/**
	 * Options for snapshotting the resolving of build dependencies to determine if the build dependencies need to be re-resolved.
	 */
	resolveBuildDependencies?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};
}
/**
 * Stats options object.
 */
export interface StatsOptions {
	/**
	 * Fallback value for stats options when an option is not defined (has precedence over local webpack defaults).
	 */
	all?: boolean;
	/**
	 * Add assets information.
	 */
	assets?: boolean;
	/**
	 * Sort the assets by that field.
	 */
	assetsSort?: string;
	/**
	 * Space to display assets (groups will be collapsed to fit this space).
	 */
	assetsSpace?: number;
	/**
	 * Add built at time information.
	 */
	builtAt?: boolean;
	/**
	 * Add information about cached (not built) modules (deprecated: use 'cachedModules' instead).
	 */
	cached?: boolean;
	/**
	 * Show cached assets (setting this to `false` only shows emitted files).
	 */
	cachedAssets?: boolean;
	/**
	 * Add information about cached (not built) modules.
	 */
	cachedModules?: boolean;
	/**
	 * Add children information.
	 */
	children?: boolean;
	/**
	 * Display auxiliary assets in chunk groups.
	 */
	chunkGroupAuxiliary?: boolean;
	/**
	 * Display children of chunk groups.
	 */
	chunkGroupChildren?: boolean;
	/**
	 * Limit of assets displayed in chunk groups.
	 */
	chunkGroupMaxAssets?: number;
	/**
	 * Display all chunk groups with the corresponding bundles.
	 */
	chunkGroups?: boolean;
	/**
	 * Add built modules information to chunk information.
	 */
	chunkModules?: boolean;
	/**
	 * Space to display chunk modules (groups will be collapsed to fit this space, value is in number of modules/group).
	 */
	chunkModulesSpace?: number;
	/**
	 * Add the origins of chunks and chunk merging info.
	 */
	chunkOrigins?: boolean;
	/**
	 * Add information about parent, children and sibling chunks to chunk information.
	 */
	chunkRelations?: boolean;
	/**
	 * Add chunk information.
	 */
	chunks?: boolean;
	/**
	 * Sort the chunks by that field.
	 */
	chunksSort?: string;
	/**
	 * Enables/Disables colorful output.
	 */
	colors?:
		| boolean
		| {
				/**
				 * Custom color for bold text.
				 */
				bold?: string;
				/**
				 * Custom color for cyan text.
				 */
				cyan?: string;
				/**
				 * Custom color for green text.
				 */
				green?: string;
				/**
				 * Custom color for magenta text.
				 */
				magenta?: string;
				/**
				 * Custom color for red text.
				 */
				red?: string;
				/**
				 * Custom color for yellow text.
				 */
				yellow?: string;
		  };
	/**
	 * Context directory for request shortening.
	 */
	context?: string;
	/**
	 * Show chunk modules that are dependencies of other modules of the chunk.
	 */
	dependentModules?: boolean;
	/**
	 * Add module depth in module graph.
	 */
	depth?: boolean;
	/**
	 * Display the entry points with the corresponding bundles.
	 */
	entrypoints?: "auto" | boolean;
	/**
	 * Add --env information.
	 */
	env?: boolean;
	/**
	 * Add details to errors (like resolving log).
	 */
	errorDetails?: "auto" | boolean;
	/**
	 * Add internal stack trace to errors.
	 */
	errorStack?: boolean;
	/**
	 * Add errors.
	 */
	errors?: boolean;
	/**
	 * Add errors count.
	 */
	errorsCount?: boolean;
	/**
	 * Space to display errors (value is in number of lines).
	 */
	errorsSpace?: number;
	/**
	 * Please use excludeModules instead.
	 */
	exclude?: boolean | ModuleFilterTypes;
	/**
	 * Suppress assets that match the specified filters. Filters can be Strings, RegExps or Functions.
	 */
	excludeAssets?: AssetFilterTypes;
	/**
	 * Suppress modules that match the specified filters. Filters can be Strings, RegExps, Booleans or Functions.
	 */
	excludeModules?: boolean | ModuleFilterTypes;
	/**
	 * Group assets by how their are related to chunks.
	 */
	groupAssetsByChunk?: boolean;
	/**
	 * Group assets by their status (emitted, compared for emit or cached).
	 */
	groupAssetsByEmitStatus?: boolean;
	/**
	 * Group assets by their extension.
	 */
	groupAssetsByExtension?: boolean;
	/**
	 * Group assets by their asset info (immutable, development, hotModuleReplacement, etc).
	 */
	groupAssetsByInfo?: boolean;
	/**
	 * Group assets by their path.
	 */
	groupAssetsByPath?: boolean;
	/**
	 * Group modules by their attributes (errors, warnings, assets, optional, orphan, or dependent).
	 */
	groupModulesByAttributes?: boolean;
	/**
	 * Group modules by their status (cached or built and cacheable).
	 */
	groupModulesByCacheStatus?: boolean;
	/**
	 * Group modules by their extension.
	 */
	groupModulesByExtension?: boolean;
	/**
	 * Group modules by their layer.
	 */
	groupModulesByLayer?: boolean;
	/**
	 * Group modules by their path.
	 */
	groupModulesByPath?: boolean;
	/**
	 * Group modules by their type.
	 */
	groupModulesByType?: boolean;
	/**
	 * Group reasons by their origin module.
	 */
	groupReasonsByOrigin?: boolean;
	/**
	 * Add the hash of the compilation.
	 */
	hash?: boolean;
	/**
	 * Add ids.
	 */
	ids?: boolean;
	/**
	 * Add logging output.
	 */
	logging?: ("none" | "error" | "warn" | "info" | "log" | "verbose") | boolean;
	/**
	 * Include debug logging of specified loggers (i. e. for plugins or loaders). Filters can be Strings, RegExps or Functions.
	 */
	loggingDebug?: boolean | FilterTypes;
	/**
	 * Add stack traces to logging output.
	 */
	loggingTrace?: boolean;
	/**
	 * Add information about assets inside modules.
	 */
	moduleAssets?: boolean;
	/**
	 * Add dependencies and origin of warnings/errors.
	 */
	moduleTrace?: boolean;
	/**
	 * Add built modules information.
	 */
	modules?: boolean;
	/**
	 * Sort the modules by that field.
	 */
	modulesSort?: string;
	/**
	 * Space to display modules (groups will be collapsed to fit this space, value is in number of modules/groups).
	 */
	modulesSpace?: number;
	/**
	 * Add information about modules nested in other modules (like with module concatenation).
	 */
	nestedModules?: boolean;
	/**
	 * Space to display modules nested within other modules (groups will be collapsed to fit this space, value is in number of modules/group).
	 */
	nestedModulesSpace?: number;
	/**
	 * Show reasons why optimization bailed out for modules.
	 */
	optimizationBailout?: boolean;
	/**
	 * Add information about orphan modules.
	 */
	orphanModules?: boolean;
	/**
	 * Add output path information.
	 */
	outputPath?: boolean;
	/**
	 * Add performance hint flags.
	 */
	performance?: boolean;
	/**
	 * Preset for the default values.
	 */
	preset?: boolean | string;
	/**
	 * Show exports provided by modules.
	 */
	providedExports?: boolean;
	/**
	 * Add public path information.
	 */
	publicPath?: boolean;
	/**
	 * Add information about the reasons why modules are included.
	 */
	reasons?: boolean;
	/**
	 * Space to display reasons (groups will be collapsed to fit this space).
	 */
	reasonsSpace?: number;
	/**
	 * Add information about assets that are related to other assets (like SourceMaps for assets).
	 */
	relatedAssets?: boolean;
	/**
	 * Add information about runtime modules (deprecated: use 'runtimeModules' instead).
	 */
	runtime?: boolean;
	/**
	 * Add information about runtime modules.
	 */
	runtimeModules?: boolean;
	/**
	 * Add the source code of modules.
	 */
	source?: boolean;
	/**
	 * Add timing information.
	 */
	timings?: boolean;
	/**
	 * Show exports used by modules.
	 */
	usedExports?: boolean;
	/**
	 * Add webpack version information.
	 */
	version?: boolean;
	/**
	 * Add warnings.
	 */
	warnings?: boolean;
	/**
	 * Add warnings count.
	 */
	warningsCount?: boolean;
	/**
	 * Suppress listing warnings that match the specified filters (they will still be counted). Filters can be Strings, RegExps or Functions.
	 */
	warningsFilter?: WarningFilterTypes;
	/**
	 * Space to display warnings (value is in number of lines).
	 */
	warningsSpace?: number;
}
/**
 * Options for the watcher.
 */
export interface WatchOptions {
	/**
	 * Delay the rebuilt after the first change. Value is a time in ms.
	 */
	aggregateTimeout?: number;
	/**
	 * Resolve symlinks and watch symlink and real file. This is usually not needed as webpack already resolves symlinks ('resolve.symlinks').
	 */
	followSymlinks?: boolean;
	/**
	 * Ignore some files from watching (glob pattern or regexp).
	 */
	ignored?: string[] | RegExp | string;
	/**
	 * Enable polling mode for watching.
	 */
	poll?: number | boolean;
	/**
	 * Stop watching when stdin stream has ended.
	 */
	stdin?: boolean;
}
/**
 * Options object for data url generation.
 */
export interface AssetGeneratorDataUrlOptions {
	/**
	 * Asset encoding (defaults to base64).
	 */
	encoding?: false | "base64";
	/**
	 * Asset mimetype (getting from file extension by default).
	 */
	mimetype?: string;
}
/**
 * Generator options for asset/inline modules.
 */
export interface AssetInlineGeneratorOptions {
	/**
	 * The options for data url generator.
	 */
	dataUrl?: AssetGeneratorDataUrl;
}
/**
 * Options object for DataUrl condition.
 */
export interface AssetParserDataUrlOptions {
	/**
	 * Maximum size of asset that should be inline as modules. Default: 8kb.
	 */
	maxSize?: number;
}
/**
 * Parser options for asset modules.
 */
export interface AssetParserOptions {
	/**
	 * The condition for inlining the asset as DataUrl.
	 */
	dataUrlCondition?: AssetParserDataUrlOptions | AssetParserDataUrlFunction;
}
/**
 * Generator options for asset/resource modules.
 */
export interface AssetResourceGeneratorOptions {
	/**
	 * Emit an output asset from this asset module. This can be set to 'false' to omit emitting e. g. for SSR.
	 */
	emit?: boolean;
	/**
	 * Specifies the filename template of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: FilenameTemplate;
	/**
	 * Emit the asset in the specified folder relative to 'output.path'. This should only be needed when custom 'publicPath' is specified to match the folder structure there.
	 */
	outputPath?: AssetModuleOutputPath;
	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: RawPublicPath;
}
/**
 * Options for css handling.
 */
export interface CssExperimentOptions {
	/**
	 * Avoid generating and loading a stylesheet and only embed exports from css into output javascript files.
	 */
	exportsOnly?: boolean;
}
/**
 * Generator options for css modules.
 */
export interface CssGeneratorOptions {}
/**
 * Parser options for css modules.
 */
export interface CssParserOptions {}
/**
 * No generator options are supported for this module type.
 */
export interface EmptyGeneratorOptions {}
/**
 * No parser options are supported for this module type.
 */
export interface EmptyParserOptions {}
/**
 * An object with entry point description.
 */
export interface EntryDescriptionNormalized {
	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;
	/**
	 * Base uri for this entry.
	 */
	baseUri?: string;
	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: ChunkLoading;
	/**
	 * The entrypoints that the current entrypoint depend on. They must be loaded when this entrypoint is loaded.
	 */
	dependOn?: string[];
	/**
	 * Specifies the filename of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: Filename;
	/**
	 * Module(s) that are loaded upon startup. The last one is exported.
	 */
	import?: string[];
	/**
	 * Specifies the layer in which modules of this entrypoint are placed.
	 */
	layer?: Layer;
	/**
	 * Options for library.
	 */
	library?: LibraryOptions;
	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: PublicPath;
	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: EntryRuntime;
	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: WasmLoading;
}
/**
 * Multiple entry bundles are created. The key is the entry name. The value is an entry description object.
 */
export interface EntryStaticNormalized {
	/**
	 * An object with entry point description.
	 */
	[k: string]: EntryDescriptionNormalized;
}
/**
 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
 */
export interface ExperimentsCommon {
	/**
	 * Support WebAssembly as asynchronous EcmaScript Module.
	 */
	asyncWebAssembly?: boolean;
	/**
	 * Enable backward-compat layer with deprecation warnings for many webpack 4 APIs.
	 */
	backCompat?: boolean;
	/**
	 * Enable additional in memory caching of modules that are unchanged and reference only unchanged modules.
	 */
	cacheUnaffected?: boolean;
	/**
	 * Apply defaults of next major version.
	 */
	futureDefaults?: boolean;
	/**
	 * Enable module layers.
	 */
	layers?: boolean;
	/**
	 * Allow output javascript files as module source type.
	 */
	outputModule?: boolean;
	/**
	 * Support WebAssembly as synchronous EcmaScript Module (outdated).
	 */
	syncWebAssembly?: boolean;
	/**
	 * Allow using top-level-await in EcmaScript Modules.
	 */
	topLevelAwait?: boolean;
}
/**
 * Data object passed as argument when a function is set for 'externals'.
 */
export interface ExternalItemFunctionData {
	/**
	 * The directory in which the request is placed.
	 */
	context?: string;
	/**
	 * Contextual information.
	 */
	contextInfo?: import("../lib/ModuleFactory").ModuleFactoryCreateDataContextInfo;
	/**
	 * The category of the referencing dependencies.
	 */
	dependencyType?: string;
	/**
	 * Get a resolve function with the current resolver options.
	 */
	getResolve?: (
		options?: ResolveOptions
	) =>
		| ((
				context: string,
				request: string,
				callback: (err?: Error, result?: string) => void
		  ) => void)
		| ((context: string, request: string) => Promise<string>);
	/**
	 * The request as written by the user in the require/import expression/statement.
	 */
	request?: string;
}
/**
 * Options for building http resources.
 */
export interface HttpUriOptions {
	/**
	 * List of allowed URIs (resp. the beginning of them).
	 */
	allowedUris: HttpUriOptionsAllowedUris;
	/**
	 * Location where resource content is stored for lockfile entries. It's also possible to disable storing by passing false.
	 */
	cacheLocation?: false | string;
	/**
	 * When set, anything that would lead to a modification of the lockfile or any resource content, will result in an error.
	 */
	frozen?: boolean;
	/**
	 * Location of the lockfile.
	 */
	lockfileLocation?: string;
	/**
	 * Proxy configuration, which can be used to specify a proxy server to use for HTTP requests.
	 */
	proxy?: string;
	/**
	 * When set, resources of existing lockfile entries will be fetched and entries will be upgraded when resource content has changed.
	 */
	upgrade?: boolean;
}
/**
 * Parser options for javascript modules.
 */
export interface JavascriptParserOptions {
	/**
	 * Set the value of `require.amd` and `define.amd`. Or disable AMD support.
	 */
	amd?: Amd;
	/**
	 * Enable/disable special handling for browserify bundles.
	 */
	browserify?: boolean;
	/**
	 * Enable/disable parsing of CommonJs syntax.
	 */
	commonjs?: boolean;
	/**
	 * Enable/disable parsing of magic comments in CommonJs syntax.
	 */
	commonjsMagicComments?: boolean;
	/**
	 * Enable/disable parsing "import { createRequire } from "module"" and evaluating createRequire().
	 */
	createRequire?: boolean | string;
	/**
	 * Specifies global fetchPriority for dynamic import.
	 */
	dynamicImportFetchPriority?: "low" | "high" | "auto" | false;
	/**
	 * Specifies global mode for dynamic import.
	 */
	dynamicImportMode?: "eager" | "weak" | "lazy" | "lazy-once";
	/**
	 * Specifies global prefetch for dynamic import.
	 */
	dynamicImportPrefetch?: number | boolean;
	/**
	 * Specifies global preload for dynamic import.
	 */
	dynamicImportPreload?: number | boolean;
	/**
	 * Specifies the behavior of invalid export names in "import ... from ..." and "export ... from ...".
	 */
	exportsPresence?: "error" | "warn" | "auto" | false;
	/**
	 * Enable warnings for full dynamic dependencies.
	 */
	exprContextCritical?: boolean;
	/**
	 * Enable recursive directory lookup for full dynamic dependencies.
	 */
	exprContextRecursive?: boolean;
	/**
	 * Sets the default regular expression for full dynamic dependencies.
	 */
	exprContextRegExp?: RegExp | boolean;
	/**
	 * Set the default request for full dynamic dependencies.
	 */
	exprContextRequest?: string;
	/**
	 * Enable/disable parsing of EcmaScript Modules syntax.
	 */
	harmony?: boolean;
	/**
	 * Enable/disable parsing of import() syntax.
	 */
	import?: boolean;
	/**
	 * Specifies the behavior of invalid export names in "import ... from ...".
	 */
	importExportsPresence?: "error" | "warn" | "auto" | false;
	/**
	 * Enable/disable evaluating import.meta.
	 */
	importMeta?: boolean;
	/**
	 * Enable/disable evaluating import.meta.webpackContext.
	 */
	importMetaContext?: boolean;
	/**
	 * Include polyfills or mocks for various node stuff.
	 */
	node?: Node;
	/**
	 * Specifies the behavior of invalid export names in "export ... from ...". This might be useful to disable during the migration from "export ... from ..." to "export type ... from ..." when reexporting types in TypeScript.
	 */
	reexportExportsPresence?: "error" | "warn" | "auto" | false;
	/**
	 * Enable/disable parsing of require.context syntax.
	 */
	requireContext?: boolean;
	/**
	 * Enable/disable parsing of require.ensure syntax.
	 */
	requireEnsure?: boolean;
	/**
	 * Enable/disable parsing of require.include syntax.
	 */
	requireInclude?: boolean;
	/**
	 * Enable/disable parsing of require.js special syntax like require.config, requirejs.config, require.version and requirejs.onError.
	 */
	requireJs?: boolean;
	/**
	 * Deprecated in favor of "exportsPresence". Emit errors instead of warnings when imported names don't exist in imported module.
	 */
	strictExportPresence?: boolean;
	/**
	 * Handle the this context correctly according to the spec for namespace objects.
	 */
	strictThisContextOnImports?: boolean;
	/**
	 * Enable/disable parsing of System.js special syntax like System.import, System.get, System.set and System.register.
	 */
	system?: boolean;
	/**
	 * Enable warnings when using the require function in a not statically analyse-able way.
	 */
	unknownContextCritical?: boolean;
	/**
	 * Enable recursive directory lookup when using the require function in a not statically analyse-able way.
	 */
	unknownContextRecursive?: boolean;
	/**
	 * Sets the regular expression when using the require function in a not statically analyse-able way.
	 */
	unknownContextRegExp?: RegExp | boolean;
	/**
	 * Sets the request when using the require function in a not statically analyse-able way.
	 */
	unknownContextRequest?: string;
	/**
	 * Enable/disable parsing of new URL() syntax.
	 */
	url?: "relative" | boolean;
	/**
	 * Disable or configure parsing of WebWorker syntax like new Worker() or navigator.serviceWorker.register().
	 */
	worker?: string[] | boolean;
	/**
	 * Enable warnings for partial dynamic dependencies.
	 */
	wrappedContextCritical?: boolean;
	/**
	 * Enable recursive directory lookup for partial dynamic dependencies.
	 */
	wrappedContextRecursive?: boolean;
	/**
	 * Set the inner regular expression for partial dynamic dependencies.
	 */
	wrappedContextRegExp?: RegExp;
	[k: string]: any;
}
/**
 * Options for the default backend.
 */
export interface LazyCompilationDefaultBackendOptions {
	/**
	 * A custom client.
	 */
	client?: string;
	/**
	 * Specifies where to listen to from the server.
	 */
	listen?:
		| number
		| import("net").ListenOptions
		| ((server: import("net").Server) => void);
	/**
	 * Specifies the protocol the client should use to connect to the server.
	 */
	protocol?: "http" | "https";
	/**
	 * Specifies how to create the server handling the EventSource requests.
	 */
	server?:
		| (import("https").ServerOptions | import("http").ServerOptions)
		| (() => import("net").Server);
}
/**
 * Options for compiling entrypoints and import()s only when they are accessed.
 */
export interface LazyCompilationOptions {
	/**
	 * Specifies the backend that should be used for handling client keep alive.
	 */
	backend?:
		| (
				| ((
						compiler: import("../lib/Compiler"),
						callback: (
							err?: Error,
							api?: import("../lib/hmr/LazyCompilationPlugin").BackendApi
						) => void
				  ) => void)
				| ((
						compiler: import("../lib/Compiler")
				  ) => Promise<import("../lib/hmr/LazyCompilationPlugin").BackendApi>)
		  )
		| LazyCompilationDefaultBackendOptions;
	/**
	 * Enable/disable lazy compilation for entries.
	 */
	entries?: boolean;
	/**
	 * Enable/disable lazy compilation for import() modules.
	 */
	imports?: boolean;
	/**
	 * Specify which entrypoints or import()ed modules should be lazily compiled. This is matched with the imported module and not the entrypoint name.
	 */
	test?: RegExp | string | ((module: import("../lib/Module")) => boolean);
}
/**
 * Options affecting the normal modules (`NormalModuleFactory`).
 */
export interface ModuleOptionsNormalized {
	/**
	 * An array of rules applied by default for modules.
	 */
	defaultRules: RuleSetRules;
	/**
	 * Specify options for each generator.
	 */
	generator: GeneratorOptionsByModuleType;
	/**
	 * Don't parse files matching. It's matched against the full resolved request.
	 */
	noParse?: NoParse;
	/**
	 * Specify options for each parser.
	 */
	parser: ParserOptionsByModuleType;
	/**
	 * An array of rules applied for modules.
	 */
	rules: RuleSetRules;
	/**
	 * Cache the resolving of module requests.
	 */
	unsafeCache?: boolean | Function;
}
/**
 * Normalized options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
 */
export interface OutputNormalized {
	/**
	 * The filename of asset modules as relative path inside the 'output.path' directory.
	 */
	assetModuleFilename?: AssetModuleFilename;
	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;
	/**
	 * Add charset attribute for script tag.
	 */
	charset?: Charset;
	/**
	 * Specifies the filename template of output files of non-initial chunks on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	chunkFilename?: ChunkFilename;
	/**
	 * The format of chunks (formats included by default are 'array-push' (web/WebWorker), 'commonjs' (node.js), 'module' (ESM), but others might be added by plugins).
	 */
	chunkFormat?: ChunkFormat;
	/**
	 * Number of milliseconds before chunk request expires.
	 */
	chunkLoadTimeout?: ChunkLoadTimeout;
	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: ChunkLoading;
	/**
	 * The global variable used by webpack for loading of chunks.
	 */
	chunkLoadingGlobal?: ChunkLoadingGlobal;
	/**
	 * Clean the output directory before emit.
	 */
	clean?: Clean;
	/**
	 * Check if to be emitted file already exists and have the same content before writing to output filesystem.
	 */
	compareBeforeEmit?: CompareBeforeEmit;
	/**
	 * This option enables cross-origin loading of chunks.
	 */
	crossOriginLoading?: CrossOriginLoading;
	/**
	 * Specifies the filename template of non-initial output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssChunkFilename?: CssChunkFilename;
	/**
	 * Specifies the filename template of output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssFilename?: CssFilename;
	/**
	 * Similar to `output.devtoolModuleFilenameTemplate`, but used in the case of duplicate module identifiers.
	 */
	devtoolFallbackModuleFilenameTemplate?: DevtoolFallbackModuleFilenameTemplate;
	/**
	 * Filename template string of function for the sources array in a generated SourceMap.
	 */
	devtoolModuleFilenameTemplate?: DevtoolModuleFilenameTemplate;
	/**
	 * Module namespace to use when interpolating filename template string for the sources array in a generated SourceMap. Defaults to `output.library` if not set. It's useful for avoiding runtime collisions in sourcemaps from multiple webpack projects built as libraries.
	 */
	devtoolNamespace?: DevtoolNamespace;
	/**
	 * List of chunk loading types enabled for use by entry points.
	 */
	enabledChunkLoadingTypes?: EnabledChunkLoadingTypes;
	/**
	 * List of library types enabled for use by entry points.
	 */
	enabledLibraryTypes?: EnabledLibraryTypes;
	/**
	 * List of wasm loading types enabled for use by entry points.
	 */
	enabledWasmLoadingTypes?: EnabledWasmLoadingTypes;
	/**
	 * The abilities of the environment where the webpack generated code should run.
	 */
	environment?: Environment;
	/**
	 * Specifies the filename of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: Filename;
	/**
	 * An expression which is used to address the global object/scope in runtime code.
	 */
	globalObject?: GlobalObject;
	/**
	 * Digest type used for the hash.
	 */
	hashDigest?: HashDigest;
	/**
	 * Number of chars which are used for the hash.
	 */
	hashDigestLength?: HashDigestLength;
	/**
	 * Algorithm used for generation the hash (see node.js crypto package).
	 */
	hashFunction?: HashFunction;
	/**
	 * Any string which is added to the hash to salt it.
	 */
	hashSalt?: HashSalt;
	/**
	 * The filename of the Hot Update Chunks. They are inside the output.path directory.
	 */
	hotUpdateChunkFilename?: HotUpdateChunkFilename;
	/**
	 * The global variable used by webpack for loading of hot update chunks.
	 */
	hotUpdateGlobal?: HotUpdateGlobal;
	/**
	 * The filename of the Hot Update Main File. It is inside the 'output.path' directory.
	 */
	hotUpdateMainFilename?: HotUpdateMainFilename;
	/**
	 * Ignore warnings in the browser.
	 */
	ignoreBrowserWarnings?: boolean;
	/**
	 * Wrap javascript code into IIFE's to avoid leaking into global scope.
	 */
	iife?: Iife;
	/**
	 * The name of the native import() function (can be exchanged for a polyfill).
	 */
	importFunctionName?: ImportFunctionName;
	/**
	 * The name of the native import.meta object (can be exchanged for a polyfill).
	 */
	importMetaName?: ImportMetaName;
	/**
	 * Options for library.
	 */
	library?: LibraryOptions;
	/**
	 * Output javascript files as module source type.
	 */
	module?: OutputModule;
	/**
	 * The output directory as **absolute path** (required).
	 */
	path?: Path;
	/**
	 * Include comments with information about the modules.
	 */
	pathinfo?: Pathinfo;
	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: PublicPath;
	/**
	 * This option enables loading async chunks via a custom script type, such as script type="module".
	 */
	scriptType?: ScriptType;
	/**
	 * The filename of the SourceMaps for the JavaScript files. They are inside the 'output.path' directory.
	 */
	sourceMapFilename?: SourceMapFilename;
	/**
	 * Prefixes every line of the source in the bundle with this string.
	 */
	sourcePrefix?: SourcePrefix;
	/**
	 * Handles error in module loading correctly at a performance cost. This will handle module error compatible with the EcmaScript Modules spec.
	 */
	strictModuleErrorHandling?: StrictModuleErrorHandling;
	/**
	 * Handles exceptions in module loading correctly at a performance cost (Deprecated). This will handle module error compatible with the Node.js CommonJS way.
	 */
	strictModuleExceptionHandling?: StrictModuleExceptionHandling;
	/**
	 * Use a Trusted Types policy to create urls for chunks.
	 */
	trustedTypes?: TrustedTypes;
	/**
	 * A unique name of the webpack build to avoid multiple webpack runtimes to conflict when using globals.
	 */
	uniqueName?: UniqueName;
	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: WasmLoading;
	/**
	 * The filename of WebAssembly modules as relative path inside the 'output.path' directory.
	 */
	webassemblyModuleFilename?: WebassemblyModuleFilename;
	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	workerChunkLoading?: ChunkLoading;
	/**
	 * Worker public path. Much like the public path, this sets the location where the worker script file is intended to be found. If not set, webpack will use the publicPath. Don't set this option unless your worker scripts are located at a different path from your other script files.
	 */
	workerPublicPath?: WorkerPublicPath;
	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	workerWasmLoading?: WasmLoading;
}
/**
 * Normalized webpack options object.
 */
export interface WebpackOptionsNormalized {
	/**
	 * Set the value of `require.amd` and `define.amd`. Or disable AMD support.
	 */
	amd?: Amd;
	/**
	 * Report the first error as a hard error instead of tolerating it.
	 */
	bail?: Bail;
	/**
	 * Cache generated modules and chunks to improve performance for multiple incremental builds.
	 */
	cache: CacheOptionsNormalized;
	/**
	 * The base directory (absolute path!) for resolving the `entry` option. If `output.pathinfo` is set, the included pathinfo is shortened to this directory.
	 */
	context?: Context;
	/**
	 * References to other configurations to depend on.
	 */
	dependencies?: Dependencies;
	/**
	 * Options for the webpack-dev-server.
	 */
	devServer?: DevServer;
	/**
	 * A developer tool to enhance debugging (false | eval | [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map).
	 */
	devtool?: DevTool;
	/**
	 * The entry point(s) of the compilation.
	 */
	entry: EntryNormalized;
	/**
	 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
	 */
	experiments: ExperimentsNormalized;
	/**
	 * Specify dependencies that shouldn't be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.
	 */
	externals: Externals;
	/**
	 * Enable presets of externals for specific targets.
	 */
	externalsPresets: ExternalsPresets;
	/**
	 * Specifies the default type of externals ('amd*', 'umd*', 'system' and 'jsonp' depend on output.libraryTarget set to the same value).
	 */
	externalsType?: ExternalsType;
	/**
	 * Ignore specific warnings.
	 */
	ignoreWarnings?: IgnoreWarningsNormalized;
	/**
	 * Options for infrastructure level logging.
	 */
	infrastructureLogging: InfrastructureLogging;
	/**
	 * Custom values available in the loader context.
	 */
	loader?: Loader;
	/**
	 * Enable production optimizations or development hints.
	 */
	mode?: Mode;
	/**
	 * Options affecting the normal modules (`NormalModuleFactory`).
	 */
	module: ModuleOptionsNormalized;
	/**
	 * Name of the configuration. Used when loading multiple configurations.
	 */
	name?: Name;
	/**
	 * Include polyfills or mocks for various node stuff.
	 */
	node: Node;
	/**
	 * Enables/Disables integrated optimizations.
	 */
	optimization: Optimization;
	/**
	 * Normalized options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
	 */
	output: OutputNormalized;
	/**
	 * The number of parallel processed modules in the compilation.
	 */
	parallelism?: Parallelism;
	/**
	 * Configuration for web performance recommendations.
	 */
	performance?: Performance;
	/**
	 * Add additional plugins to the compiler.
	 */
	plugins: Plugins;
	/**
	 * Capture timing information for each module.
	 */
	profile?: Profile;
	/**
	 * Store compiler state to a json file.
	 */
	recordsInputPath?: RecordsInputPath;
	/**
	 * Load compiler state from a json file.
	 */
	recordsOutputPath?: RecordsOutputPath;
	/**
	 * Options for the resolver.
	 */
	resolve: Resolve;
	/**
	 * Options for the resolver when resolving loaders.
	 */
	resolveLoader: ResolveLoader;
	/**
	 * Options affecting how file system snapshots are created and validated.
	 */
	snapshot: SnapshotOptions;
	/**
	 * Stats options object or preset name.
	 */
	stats: StatsValue;
	/**
	 * Environment to build for. An array of environments to build for all of them when possible.
	 */
	target?: Target;
	/**
	 * Enter watch mode, which rebuilds on file change.
	 */
	watch?: Watch;
	/**
	 * Options for the watcher.
	 */
	watchOptions: WatchOptions;
}
/**
 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
 */
export interface ExperimentsExtra {
	/**
	 * Build http(s): urls using a lockfile and resource content cache.
	 */
	buildHttp?: HttpUriAllowedUris | HttpUriOptions;
	/**
	 * Enable css support.
	 */
	css?: boolean | CssExperimentOptions;
	/**
	 * Compile entrypoints and import()s only when they are accessed.
	 */
	lazyCompilation?: boolean | LazyCompilationOptions;
}
/**
 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
 */
export interface ExperimentsNormalizedExtra {
	/**
	 * Build http(s): urls using a lockfile and resource content cache.
	 */
	buildHttp?: HttpUriOptions;
	/**
	 * Enable css support.
	 */
	css?: false | CssExperimentOptions;
	/**
	 * Compile entrypoints and import()s only when they are accessed.
	 */
	lazyCompilation?: false | LazyCompilationOptions;
}
/**
 * If an dependency matches exactly a property of the object, the property value is used as dependency.
 */
export interface ExternalItemObjectKnown {
	/**
	 * Specify externals depending on the layer.
	 */
	byLayer?:
		| {
				[k: string]: ExternalItem;
		  }
		| ((layer: string | null) => ExternalItem);
}
/**
 * If an dependency matches exactly a property of the object, the property value is used as dependency.
 */
export interface ExternalItemObjectUnknown {
	[k: string]: ExternalItemValue;
}
/**
 * Specify options for each generator.
 */
export interface GeneratorOptionsByModuleTypeKnown {
	/**
	 * Generator options for asset modules.
	 */
	asset?: AssetGeneratorOptions;
	/**
	 * Generator options for asset/inline modules.
	 */
	"asset/inline"?: AssetInlineGeneratorOptions;
	/**
	 * Generator options for asset/resource modules.
	 */
	"asset/resource"?: AssetResourceGeneratorOptions;
	/**
	 * No generator options are supported for this module type.
	 */
	javascript?: EmptyGeneratorOptions;
	/**
	 * No generator options are supported for this module type.
	 */
	"javascript/auto"?: EmptyGeneratorOptions;
	/**
	 * No generator options are supported for this module type.
	 */
	"javascript/dynamic"?: EmptyGeneratorOptions;
	/**
	 * No generator options are supported for this module type.
	 */
	"javascript/esm"?: EmptyGeneratorOptions;
}
/**
 * Specify options for each generator.
 */
export interface GeneratorOptionsByModuleTypeUnknown {
	/**
	 * Options for generating.
	 */
	[k: string]: {
		[k: string]: any;
	};
}
/**
 * Specify options for each parser.
 */
export interface ParserOptionsByModuleTypeKnown {
	/**
	 * Parser options for asset modules.
	 */
	asset?: AssetParserOptions;
	/**
	 * No parser options are supported for this module type.
	 */
	"asset/inline"?: EmptyParserOptions;
	/**
	 * No parser options are supported for this module type.
	 */
	"asset/resource"?: EmptyParserOptions;
	/**
	 * No parser options are supported for this module type.
	 */
	"asset/source"?: EmptyParserOptions;
	/**
	 * Parser options for javascript modules.
	 */
	javascript?: JavascriptParserOptions;
	/**
	 * Parser options for javascript modules.
	 */
	"javascript/auto"?: JavascriptParserOptions;
	/**
	 * Parser options for javascript modules.
	 */
	"javascript/dynamic"?: JavascriptParserOptions;
	/**
	 * Parser options for javascript modules.
	 */
	"javascript/esm"?: JavascriptParserOptions;
}
/**
 * Specify options for each parser.
 */
export interface ParserOptionsByModuleTypeUnknown {
	/**
	 * Options for parsing.
	 */
	[k: string]: {
		[k: string]: any;
	};
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/index.d.ts
export type {
	LoaderModule,
	RawLoaderDefinition,
	LoaderDefinition,
	LoaderDefinitionFunction,
	PitchLoaderDefinitionFunction,
	RawLoaderDefinitionFunction,
	LoaderContext
} from "./LoaderContext";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/BannerPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export type BannerPluginArgument =
	| string
	| BannerPluginOptions
	| BannerFunction;
/**
 * The banner as function, it will be wrapped in a comment.
 */
export type BannerFunction = (data: {
	hash: string;
	chunk: import("../../lib/Chunk");
	filename: string;
}) => string;
/**
 * Filtering rules.
 */
export type Rules = Rule[] | Rule;
/**
 * Filtering rule as regex or string.
 */
export type Rule = RegExp | string;

export interface BannerPluginOptions {
	/**
	 * Specifies the banner.
	 */
	banner: string | BannerFunction;
	/**
	 * If true, the banner will only be added to the entry chunks.
	 */
	entryOnly?: boolean;
	/**
	 * Exclude all modules matching any of these conditions.
	 */
	exclude?: Rules;
	/**
	 * If true, banner will be placed at the end of the output.
	 */
	footer?: boolean;
	/**
	 * Include all modules matching any of these conditions.
	 */
	include?: Rules;
	/**
	 * If true, banner will not be wrapped in a comment.
	 */
	raw?: boolean;
	/**
	 * Include all modules that pass test assertion.
	 */
	test?: Rules;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/DllPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export interface DllPluginOptions {
	/**
	 * Context of requests in the manifest file (defaults to the webpack context).
	 */
	context?: string;
	/**
	 * If true, only entry points will be exposed (default: true).
	 */
	entryOnly?: boolean;
	/**
	 * If true, manifest json file (output) will be formatted.
	 */
	format?: boolean;
	/**
	 * Name of the exposed dll function (external name, use value of 'output.library').
	 */
	name?: string;
	/**
	 * Absolute path to the manifest json file (output).
	 */
	path: string;
	/**
	 * Type of the dll bundle (external type, use value of 'output.libraryTarget').
	 */
	type?: string;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/DllReferencePlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export type DllReferencePluginOptions =
	| {
			/**
			 * Context of requests in the manifest (or content property) as absolute path.
			 */
			context?: string;
			/**
			 * Extensions used to resolve modules in the dll bundle (only used when using 'scope').
			 */
			extensions?: string[];
			/**
			 * An object containing content and name or a string to the absolute path of the JSON manifest to be loaded upon compilation.
			 */
			manifest: string | DllReferencePluginOptionsManifest;
			/**
			 * The name where the dll is exposed (external name, defaults to manifest.name).
			 */
			name?: string;
			/**
			 * Prefix which is used for accessing the content of the dll.
			 */
			scope?: string;
			/**
			 * How the dll is exposed (libraryTarget, defaults to manifest.type).
			 */
			sourceType?: DllReferencePluginOptionsSourceType;
			/**
			 * The way how the export of the dll bundle is used.
			 */
			type?: "require" | "object";
	  }
	| {
			/**
			 * The mappings from request to module info.
			 */
			content: DllReferencePluginOptionsContent;
			/**
			 * Context of requests in the manifest (or content property) as absolute path.
			 */
			context?: string;
			/**
			 * Extensions used to resolve modules in the dll bundle (only used when using 'scope').
			 */
			extensions?: string[];
			/**
			 * The name where the dll is exposed (external name).
			 */
			name: string;
			/**
			 * Prefix which is used for accessing the content of the dll.
			 */
			scope?: string;
			/**
			 * How the dll is exposed (libraryTarget).
			 */
			sourceType?: DllReferencePluginOptionsSourceType;
			/**
			 * The way how the export of the dll bundle is used.
			 */
			type?: "require" | "object";
	  };
/**
 * The type how the dll is exposed (external type).
 */
export type DllReferencePluginOptionsSourceType =
	| "var"
	| "assign"
	| "this"
	| "window"
	| "global"
	| "commonjs"
	| "commonjs2"
	| "commonjs-module"
	| "amd"
	| "amd-require"
	| "umd"
	| "umd2"
	| "jsonp"
	| "system";

/**
 * An object containing content, name and type.
 */
export interface DllReferencePluginOptionsManifest {
	/**
	 * The mappings from request to module info.
	 */
	content: DllReferencePluginOptionsContent;
	/**
	 * The name where the dll is exposed (external name).
	 */
	name?: string;
	/**
	 * The type how the dll is exposed (external type).
	 */
	type?: DllReferencePluginOptionsSourceType;
}
/**
 * The mappings from request to module info.
 */
export interface DllReferencePluginOptionsContent {
	/**
	 * Module info.
	 */
	[k: string]: {
		/**
		 * Meta information about the module.
		 */
		buildMeta?: {
			[k: string]: any;
		};
		/**
		 * Information about the provided exports of the module.
		 */
		exports?: string[] | true;
		/**
		 * Module ID.
		 */
		id: number | string;
	};
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/HashedModuleIdsPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

/**
 * Algorithm used for generation the hash (see node.js crypto package).
 */
export type HashFunction = string | typeof import("../../lib/util/Hash");

export interface HashedModuleIdsPluginOptions {
	/**
	 * The context directory for creating names.
	 */
	context?: string;
	/**
	 * The encoding to use when generating the hash, defaults to 'base64'. All encodings from Node.JS' hash.digest are supported.
	 */
	hashDigest?: "hex" | "latin1" | "base64";
	/**
	 * The prefix length of the hash digest to use, defaults to 4.
	 */
	hashDigestLength?: number;
	/**
	 * The hashing algorithm to use, defaults to 'md4'. All functions from Node.JS' crypto.createHash are supported.
	 */
	hashFunction?: HashFunction;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/IgnorePlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export type IgnorePluginOptions =
	| {
			/**
			 * A RegExp to test the context (directory) against.
			 */
			contextRegExp?: RegExp;
			/**
			 * A RegExp to test the request against.
			 */
			resourceRegExp: RegExp;
	  }
	| {
			/**
			 * A filter function for resource and context.
			 */
			checkResource: (resource: string, context: string) => boolean;
	  };

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/JsonModulesPluginParser.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export interface JsonModulesPluginParserOptions {
	/**
	 * Function that executes for a module source string and should return json-compatible data.
	 */
	parse?: (input: string) => any;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/LoaderOptionsPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export interface LoaderOptionsPluginOptions {
	/**
	 * Whether loaders should be in debug mode or not. debug will be removed as of webpack 3.
	 */
	debug?: boolean;
	/**
	 * Where loaders can be switched to minimize mode.
	 */
	minimize?: boolean;
	/**
	 * A configuration object that can be used to configure older loaders.
	 */
	options?: {
		/**
		 * The context that can be used to configure older loaders.
		 */
		context?: string;
		[k: string]: any;
	};
	[k: string]: any;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/ProgressPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export type ProgressPluginArgument = ProgressPluginOptions | HandlerFunction;
/**
 * Function that executes for every progress step.
 */
export type HandlerFunction = (
	percentage: number,
	msg: string,
	...args: string[]
) => void;

/**
 * Options object for the ProgressPlugin.
 */
export interface ProgressPluginOptions {
	/**
	 * Show active modules count and one active module in progress message.
	 */
	activeModules?: boolean;
	/**
	 * Show dependencies count in progress message.
	 */
	dependencies?: boolean;
	/**
	 * Minimum dependencies count to start with. For better progress calculation. Default: 10000.
	 */
	dependenciesCount?: number;
	/**
	 * Show entries count in progress message.
	 */
	entries?: boolean;
	/**
	 * Function that executes for every progress step.
	 */
	handler?: HandlerFunction;
	/**
	 * Show modules count in progress message.
	 */
	modules?: boolean;
	/**
	 * Minimum modules count to start with. For better progress calculation. Default: 5000.
	 */
	modulesCount?: number;
	/**
	 * Collect percent algorithm. By default it calculates by a median from modules, entries and dependencies percent.
	 */
	percentBy?: "entries" | "modules" | "dependencies" | null;
	/**
	 * Collect profile data for progress steps. Default: false.
	 */
	profile?: true | false | null;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/SourceMapDevToolPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

/**
 * Include source maps for modules based on their extension (defaults to .js and .css).
 */
export type Rules = Rule[] | Rule;
/**
 * Include source maps for modules based on their extension (defaults to .js and .css).
 */
export type Rule = RegExp | string;

export interface SourceMapDevToolPluginOptions {
	/**
	 * Appends the given value to the original asset. Usually the #sourceMappingURL comment. [url] is replaced with a URL to the source map file. false disables the appending.
	 */
	append?:
		| (false | null)
		| string
		| ((
				pathData: import("../../lib/Compilation").PathData,
				assetInfo?: import("../../lib/Compilation").AssetInfo
		  ) => string);
	/**
	 * Indicates whether column mappings should be used (defaults to true).
	 */
	columns?: boolean;
	/**
	 * Exclude modules that match the given value from source map generation.
	 */
	exclude?: Rules;
	/**
	 * Generator string or function to create identifiers of modules for the 'sources' array in the SourceMap used only if 'moduleFilenameTemplate' would result in a conflict.
	 */
	fallbackModuleFilenameTemplate?: string | Function;
	/**
	 * Path prefix to which the [file] placeholder is relative to.
	 */
	fileContext?: string;
	/**
	 * Defines the output filename of the SourceMap (will be inlined if no value is provided).
	 */
	filename?: (false | null) | string;
	/**
	 * Include source maps for module paths that match the given value.
	 */
	include?: Rules;
	/**
	 * Indicates whether SourceMaps from loaders should be used (defaults to true).
	 */
	module?: boolean;
	/**
	 * Generator string or function to create identifiers of modules for the 'sources' array in the SourceMap.
	 */
	moduleFilenameTemplate?: string | Function;
	/**
	 * Namespace prefix to allow multiple webpack roots in the devtools.
	 */
	namespace?: string;
	/**
	 * Omit the 'sourceContents' array from the SourceMap.
	 */
	noSources?: boolean;
	/**
	 * Provide a custom public path for the SourceMapping comment.
	 */
	publicPath?: string;
	/**
	 * Provide a custom value for the 'sourceRoot' property in the SourceMap.
	 */
	sourceRoot?: string;
	/**
	 * Include source maps for modules based on their extension (defaults to .js and .css).
	 */
	test?: Rules;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/WatchIgnorePlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export interface WatchIgnorePluginOptions {
	/**
	 * A list of RegExps or absolute paths to directories or files that should be ignored.
	 */
	paths: (RegExp | string)[];
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/container/ContainerPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

/**
 * Modules that should be exposed by this container. When provided, property name is used as public name, otherwise public name is automatically inferred from request.
 */
export type Exposes = (ExposesItem | ExposesObject)[] | ExposesObject;
/**
 * Module that should be exposed by this container.
 */
export type ExposesItem = string;
/**
 * Modules that should be exposed by this container.
 */
export type ExposesItems = ExposesItem[];
/**
 * Add a container for define/require functions in the AMD module.
 */
export type AmdContainer = string;
/**
 * Add a comment in the UMD wrapper.
 */
export type AuxiliaryComment = string | LibraryCustomUmdCommentObject;
/**
 * Specify which export should be exposed as library.
 */
export type LibraryExport = string[] | string;
/**
 * The name of the library (some types allow unnamed libraries too).
 */
export type LibraryName = string[] | string | LibraryCustomUmdObject;
/**
 * Type of library (types included by default are 'var', 'module', 'assign', 'assign-properties', 'this', 'window', 'self', 'global', 'commonjs', 'commonjs2', 'commonjs-module', 'commonjs-static', 'amd', 'amd-require', 'umd', 'umd2', 'jsonp', 'system', but others might be added by plugins).
 */
export type LibraryType =
	| (
			| "var"
			| "module"
			| "assign"
			| "assign-properties"
			| "this"
			| "window"
			| "self"
			| "global"
			| "commonjs"
			| "commonjs2"
			| "commonjs-module"
			| "commonjs-static"
			| "amd"
			| "amd-require"
			| "umd"
			| "umd2"
			| "jsonp"
			| "system"
	  )
	| string;
/**
 * If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.
 */
export type UmdNamedDefine = boolean;
/**
 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
 */
export type EntryRuntime = false | string;

export interface ContainerPluginOptions {
	/**
	 * Modules that should be exposed by this container. When provided, property name is used as public name, otherwise public name is automatically inferred from request.
	 */
	exposes: Exposes;
	/**
	 * The filename for this container relative path inside the `output.path` directory.
	 */
	filename?: string;
	/**
	 * Options for library.
	 */
	library?: LibraryOptions;
	/**
	 * The name for this container.
	 */
	name: string;
	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: EntryRuntime;
	/**
	 * The name of the share scope which is shared with the host (defaults to 'default').
	 */
	shareScope?: string;
}
/**
 * Modules that should be exposed by this container. Property names are used as public paths.
 */
export interface ExposesObject {
	/**
	 * Modules that should be exposed by this container.
	 */
	[k: string]: ExposesConfig | ExposesItem | ExposesItems;
}
/**
 * Advanced configuration for modules that should be exposed by this container.
 */
export interface ExposesConfig {
	/**
	 * Request to a module that should be exposed by this container.
	 */
	import: ExposesItem | ExposesItems;
	/**
	 * Custom chunk name for the exposed module.
	 */
	name?: string;
}
/**
 * Options for library.
 */
export interface LibraryOptions {
	/**
	 * Add a container for define/require functions in the AMD module.
	 */
	amdContainer?: AmdContainer;
	/**
	 * Add a comment in the UMD wrapper.
	 */
	auxiliaryComment?: AuxiliaryComment;
	/**
	 * Specify which export should be exposed as library.
	 */
	export?: LibraryExport;
	/**
	 * The name of the library (some types allow unnamed libraries too).
	 */
	name?: LibraryName;
	/**
	 * Type of library (types included by default are 'var', 'module', 'assign', 'assign-properties', 'this', 'window', 'self', 'global', 'commonjs', 'commonjs2', 'commonjs-module', 'commonjs-static', 'amd', 'amd-require', 'umd', 'umd2', 'jsonp', 'system', but others might be added by plugins).
	 */
	type: LibraryType;
	/**
	 * If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.
	 */
	umdNamedDefine?: UmdNamedDefine;
}
/**
 * Set explicit comments for `commonjs`, `commonjs2`, `amd`, and `root`.
 */
export interface LibraryCustomUmdCommentObject {
	/**
	 * Set comment for `amd` section in UMD.
	 */
	amd?: string;
	/**
	 * Set comment for `commonjs` (exports) section in UMD.
	 */
	commonjs?: string;
	/**
	 * Set comment for `commonjs2` (module.exports) section in UMD.
	 */
	commonjs2?: string;
	/**
	 * Set comment for `root` (global variable) section in UMD.
	 */
	root?: string;
}
/**
 * Description object for all UMD variants of the library name.
 */
export interface LibraryCustomUmdObject {
	/**
	 * Name of the exposed AMD library in the UMD.
	 */
	amd?: string;
	/**
	 * Name of the exposed commonjs export in the UMD.
	 */
	commonjs?: string;
	/**
	 * Name of the property exposed globally by a UMD library.
	 */
	root?: string[] | string;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/container/ContainerReferencePlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

/**
 * Specifies the default type of externals ('amd*', 'umd*', 'system' and 'jsonp' depend on output.libraryTarget set to the same value).
 */
export type ExternalsType =
	| "var"
	| "module"
	| "assign"
	| "this"
	| "window"
	| "self"
	| "global"
	| "commonjs"
	| "commonjs2"
	| "commonjs-module"
	| "commonjs-static"
	| "amd"
	| "amd-require"
	| "umd"
	| "umd2"
	| "jsonp"
	| "system"
	| "promise"
	| "import"
	| "script"
	| "node-commonjs";
/**
 * Container locations and request scopes from which modules should be resolved and loaded at runtime. When provided, property name is used as request scope, otherwise request scope is automatically inferred from container location.
 */
export type Remotes = (RemotesItem | RemotesObject)[] | RemotesObject;
/**
 * Container location from which modules should be resolved and loaded at runtime.
 */
export type RemotesItem = string;
/**
 * Container locations from which modules should be resolved and loaded at runtime.
 */
export type RemotesItems = RemotesItem[];

export interface ContainerReferencePluginOptions {
	/**
	 * The external type of the remote containers.
	 */
	remoteType: ExternalsType;
	/**
	 * Container locations and request scopes from which modules should be resolved and loaded at runtime. When provided, property name is used as request scope, otherwise request scope is automatically inferred from container location.
	 */
	remotes: Remotes;
	/**
	 * The name of the share scope shared with all remotes (defaults to 'default').
	 */
	shareScope?: string;
}
/**
 * Container locations from which modules should be resolved and loaded at runtime. Property names are used as request scopes.
 */
export interface RemotesObject {
	/**
	 * Container locations from which modules should be resolved and loaded at runtime.
	 */
	[k: string]: RemotesConfig | RemotesItem | RemotesItems;
}
/**
 * Advanced configuration for container locations from which modules should be resolved and loaded at runtime.
 */
export interface RemotesConfig {
	/**
	 * Container locations from which modules should be resolved and loaded at runtime.
	 */
	external: RemotesItem | RemotesItems;
	/**
	 * The name of the share scope shared with this remote.
	 */
	shareScope?: string;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/container/ModuleFederationPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

/**
 * Modules that should be exposed by this container. When provided, property name is used as public name, otherwise public name is automatically inferred from request.
 */
export type Exposes = (ExposesItem | ExposesObject)[] | ExposesObject;
/**
 * Module that should be exposed by this container.
 */
export type ExposesItem = string;
/**
 * Modules that should be exposed by this container.
 */
export type ExposesItems = ExposesItem[];
/**
 * Add a container for define/require functions in the AMD module.
 */
export type AmdContainer = string;
/**
 * Add a comment in the UMD wrapper.
 */
export type AuxiliaryComment = string | LibraryCustomUmdCommentObject;
/**
 * Specify which export should be exposed as library.
 */
export type LibraryExport = string[] | string;
/**
 * The name of the library (some types allow unnamed libraries too).
 */
export type LibraryName = string[] | string | LibraryCustomUmdObject;
/**
 * Type of library (types included by default are 'var', 'module', 'assign', 'assign-properties', 'this', 'window', 'self', 'global', 'commonjs', 'commonjs2', 'commonjs-module', 'commonjs-static', 'amd', 'amd-require', 'umd', 'umd2', 'jsonp', 'system', but others might be added by plugins).
 */
export type LibraryType =
	| (
			| "var"
			| "module"
			| "assign"
			| "assign-properties"
			| "this"
			| "window"
			| "self"
			| "global"
			| "commonjs"
			| "commonjs2"
			| "commonjs-module"
			| "commonjs-static"
			| "amd"
			| "amd-require"
			| "umd"
			| "umd2"
			| "jsonp"
			| "system"
	  )
	| string;
/**
 * If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.
 */
export type UmdNamedDefine = boolean;
/**
 * Specifies the default type of externals ('amd*', 'umd*', 'system' and 'jsonp' depend on output.libraryTarget set to the same value).
 */
export type ExternalsType =
	| "var"
	| "module"
	| "assign"
	| "this"
	| "window"
	| "self"
	| "global"
	| "commonjs"
	| "commonjs2"
	| "commonjs-module"
	| "commonjs-static"
	| "amd"
	| "amd-require"
	| "umd"
	| "umd2"
	| "jsonp"
	| "system"
	| "promise"
	| "import"
	| "script"
	| "node-commonjs";
/**
 * Container locations and request scopes from which modules should be resolved and loaded at runtime. When provided, property name is used as request scope, otherwise request scope is automatically inferred from container location.
 */
export type Remotes = (RemotesItem | RemotesObject)[] | RemotesObject;
/**
 * Container location from which modules should be resolved and loaded at runtime.
 */
export type RemotesItem = string;
/**
 * Container locations from which modules should be resolved and loaded at runtime.
 */
export type RemotesItems = RemotesItem[];
/**
 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
 */
export type EntryRuntime = false | string;
/**
 * Modules that should be shared in the share scope. When provided, property names are used to match requested modules in this compilation.
 */
export type Shared = (SharedItem | SharedObject)[] | SharedObject;
/**
 * A module that should be shared in the share scope.
 */
export type SharedItem = string;

export interface ModuleFederationPluginOptions {
	/**
	 * Modules that should be exposed by this container. When provided, property name is used as public name, otherwise public name is automatically inferred from request.
	 */
	exposes?: Exposes;
	/**
	 * The filename of the container as relative path inside the `output.path` directory.
	 */
	filename?: string;
	/**
	 * Options for library.
	 */
	library?: LibraryOptions;
	/**
	 * The name of the container.
	 */
	name?: string;
	/**
	 * The external type of the remote containers.
	 */
	remoteType?: ExternalsType;
	/**
	 * Container locations and request scopes from which modules should be resolved and loaded at runtime. When provided, property name is used as request scope, otherwise request scope is automatically inferred from container location.
	 */
	remotes?: Remotes;
	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: EntryRuntime;
	/**
	 * Share scope name used for all shared modules (defaults to 'default').
	 */
	shareScope?: string;
	/**
	 * Modules that should be shared in the share scope. When provided, property names are used to match requested modules in this compilation.
	 */
	shared?: Shared;
}
/**
 * Modules that should be exposed by this container. Property names are used as public paths.
 */
export interface ExposesObject {
	/**
	 * Modules that should be exposed by this container.
	 */
	[k: string]: ExposesConfig | ExposesItem | ExposesItems;
}
/**
 * Advanced configuration for modules that should be exposed by this container.
 */
export interface ExposesConfig {
	/**
	 * Request to a module that should be exposed by this container.
	 */
	import: ExposesItem | ExposesItems;
	/**
	 * Custom chunk name for the exposed module.
	 */
	name?: string;
}
/**
 * Options for library.
 */
export interface LibraryOptions {
	/**
	 * Add a container for define/require functions in the AMD module.
	 */
	amdContainer?: AmdContainer;
	/**
	 * Add a comment in the UMD wrapper.
	 */
	auxiliaryComment?: AuxiliaryComment;
	/**
	 * Specify which export should be exposed as library.
	 */
	export?: LibraryExport;
	/**
	 * The name of the library (some types allow unnamed libraries too).
	 */
	name?: LibraryName;
	/**
	 * Type of library (types included by default are 'var', 'module', 'assign', 'assign-properties', 'this', 'window', 'self', 'global', 'commonjs', 'commonjs2', 'commonjs-module', 'commonjs-static', 'amd', 'amd-require', 'umd', 'umd2', 'jsonp', 'system', but others might be added by plugins).
	 */
	type: LibraryType;
	/**
	 * If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.
	 */
	umdNamedDefine?: UmdNamedDefine;
}
/**
 * Set explicit comments for `commonjs`, `commonjs2`, `amd`, and `root`.
 */
export interface LibraryCustomUmdCommentObject {
	/**
	 * Set comment for `amd` section in UMD.
	 */
	amd?: string;
	/**
	 * Set comment for `commonjs` (exports) section in UMD.
	 */
	commonjs?: string;
	/**
	 * Set comment for `commonjs2` (module.exports) section in UMD.
	 */
	commonjs2?: string;
	/**
	 * Set comment for `root` (global variable) section in UMD.
	 */
	root?: string;
}
/**
 * Description object for all UMD variants of the library name.
 */
export interface LibraryCustomUmdObject {
	/**
	 * Name of the exposed AMD library in the UMD.
	 */
	amd?: string;
	/**
	 * Name of the exposed commonjs export in the UMD.
	 */
	commonjs?: string;
	/**
	 * Name of the property exposed globally by a UMD library.
	 */
	root?: string[] | string;
}
/**
 * Container locations from which modules should be resolved and loaded at runtime. Property names are used as request scopes.
 */
export interface RemotesObject {
	/**
	 * Container locations from which modules should be resolved and loaded at runtime.
	 */
	[k: string]: RemotesConfig | RemotesItem | RemotesItems;
}
/**
 * Advanced configuration for container locations from which modules should be resolved and loaded at runtime.
 */
export interface RemotesConfig {
	/**
	 * Container locations from which modules should be resolved and loaded at runtime.
	 */
	external: RemotesItem | RemotesItems;
	/**
	 * The name of the share scope shared with this remote.
	 */
	shareScope?: string;
}
/**
 * Modules that should be shared in the share scope. Property names are used to match requested modules in this compilation. Relative requests are resolved, module requests are matched unresolved, absolute paths will match resolved requests. A trailing slash will match all requests with this prefix. In this case shareKey must also have a trailing slash.
 */
export interface SharedObject {
	/**
	 * Modules that should be shared in the share scope.
	 */
	[k: string]: SharedConfig | SharedItem;
}
/**
 * Advanced configuration for modules that should be shared in the share scope.
 */
export interface SharedConfig {
	/**
	 * Include the provided and fallback module directly instead behind an async request. This allows to use this shared module in initial load too. All possible shared modules need to be eager too.
	 */
	eager?: boolean;
	/**
	 * Provided module that should be provided to share scope. Also acts as fallback module if no shared module is found in share scope or version isn't valid. Defaults to the property name.
	 */
	import?: false | SharedItem;
	/**
	 * Package name to determine required version from description file. This is only needed when package name can't be automatically determined from request.
	 */
	packageName?: string;
	/**
	 * Version requirement from module in share scope.
	 */
	requiredVersion?: false | string;
	/**
	 * Module is looked up under this key from the share scope.
	 */
	shareKey?: string;
	/**
	 * Share scope name.
	 */
	shareScope?: string;
	/**
	 * Allow only a single version of the shared module in share scope (disabled by default).
	 */
	singleton?: boolean;
	/**
	 * Do not accept shared module if version is not valid (defaults to yes, if local fallback module is available and shared module is not a singleton, otherwise no, has no effect if there is no required version specified).
	 */
	strictVersion?: boolean;
	/**
	 * Version of the provided module. Will replace lower matching versions, but not higher.
	 */
	version?: false | string;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/debug/ProfilingPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export interface ProfilingPluginOptions {
	/**
	 * Path to the output file e.g. `path.resolve(__dirname, 'profiling/events.json')`. Defaults to `events.json`.
	 */
	outputPath?: string;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/ids/OccurrenceChunkIdsPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export interface OccurrenceChunkIdsPluginOptions {
	/**
	 * Prioritise initial size over total size.
	 */
	prioritiseInitial?: boolean;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/ids/OccurrenceModuleIdsPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export interface OccurrenceModuleIdsPluginOptions {
	/**
	 * Prioritise initial size over total size.
	 */
	prioritiseInitial?: boolean;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/optimize/AggressiveSplittingPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export interface AggressiveSplittingPluginOptions {
	/**
	 * Extra cost for each chunk (Default: 9.8kiB).
	 */
	chunkOverhead?: number;
	/**
	 * Extra cost multiplicator for entry chunks (Default: 10).
	 */
	entryChunkMultiplicator?: number;
	/**
	 * Byte, max size of per file (Default: 50kiB).
	 */
	maxSize?: number;
	/**
	 * Byte, split point. (Default: 30kiB).
	 */
	minSize?: number;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/optimize/LimitChunkCountPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export interface LimitChunkCountPluginOptions {
	/**
	 * Constant overhead for a chunk.
	 */
	chunkOverhead?: number;
	/**
	 * Multiplicator for initial chunks.
	 */
	entryChunkMultiplicator?: number;
	/**
	 * Limit the maximum number of chunks using a value greater greater than or equal to 1.
	 */
	maxChunks: number;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/optimize/MinChunkSizePlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export interface MinChunkSizePluginOptions {
	/**
	 * Constant overhead for a chunk.
	 */
	chunkOverhead?: number;
	/**
	 * Multiplicator for initial chunks.
	 */
	entryChunkMultiplicator?: number;
	/**
	 * Minimum number of characters.
	 */
	minChunkSize: number;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/schemes/HttpUriPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

export type HttpUriPluginOptions = HttpUriOptions;
/**
 * List of allowed URIs (resp. the beginning of them).
 */
export type HttpUriOptionsAllowedUris = (
	| RegExp
	| string
	| ((uri: string) => boolean)
)[];

/**
 * Options for building http resources.
 */
export interface HttpUriOptions {
	/**
	 * List of allowed URIs (resp. the beginning of them).
	 */
	allowedUris: HttpUriOptionsAllowedUris;
	/**
	 * Location where resource content is stored for lockfile entries. It's also possible to disable storing by passing false.
	 */
	cacheLocation?: false | string;
	/**
	 * When set, anything that would lead to a modification of the lockfile or any resource content, will result in an error.
	 */
	frozen?: boolean;
	/**
	 * Location of the lockfile.
	 */
	lockfileLocation?: string;
	/**
	 * Proxy configuration, which can be used to specify a proxy server to use for HTTP requests.
	 */
	proxy?: string;
	/**
	 * When set, resources of existing lockfile entries will be fetched and entries will be upgraded when resource content has changed.
	 */
	upgrade?: boolean;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/sharing/ConsumeSharedPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

/**
 * Modules that should be consumed from share scope. When provided, property names are used to match requested modules in this compilation.
 */
export type Consumes = (ConsumesItem | ConsumesObject)[] | ConsumesObject;
/**
 * A module that should be consumed from share scope.
 */
export type ConsumesItem = string;

/**
 * Options for consuming shared modules.
 */
export interface ConsumeSharedPluginOptions {
	/**
	 * Modules that should be consumed from share scope. When provided, property names are used to match requested modules in this compilation.
	 */
	consumes: Consumes;
	/**
	 * Share scope name used for all consumed modules (defaults to 'default').
	 */
	shareScope?: string;
}
/**
 * Modules that should be consumed from share scope. Property names are used to match requested modules in this compilation. Relative requests are resolved, module requests are matched unresolved, absolute paths will match resolved requests. A trailing slash will match all requests with this prefix. In this case shareKey must also have a trailing slash.
 */
export interface ConsumesObject {
	/**
	 * Modules that should be consumed from share scope.
	 */
	[k: string]: ConsumesConfig | ConsumesItem;
}
/**
 * Advanced configuration for modules that should be consumed from share scope.
 */
export interface ConsumesConfig {
	/**
	 * Include the fallback module directly instead behind an async request. This allows to use fallback module in initial load too. All possible shared modules need to be eager too.
	 */
	eager?: boolean;
	/**
	 * Fallback module if no shared module is found in share scope. Defaults to the property name.
	 */
	import?: false | ConsumesItem;
	/**
	 * Package name to determine required version from description file. This is only needed when package name can't be automatically determined from request.
	 */
	packageName?: string;
	/**
	 * Version requirement from module in share scope.
	 */
	requiredVersion?: false | string;
	/**
	 * Module is looked up under this key from the share scope.
	 */
	shareKey?: string;
	/**
	 * Share scope name.
	 */
	shareScope?: string;
	/**
	 * Allow only a single version of the shared module in share scope (disabled by default).
	 */
	singleton?: boolean;
	/**
	 * Do not accept shared module if version is not valid (defaults to yes, if local fallback module is available and shared module is not a singleton, otherwise no, has no effect if there is no required version specified).
	 */
	strictVersion?: boolean;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/sharing/ProvideSharedPlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

/**
 * Modules that should be provided as shared modules to the share scope. When provided, property name is used to match modules, otherwise this is automatically inferred from share key.
 */
export type Provides = (ProvidesItem | ProvidesObject)[] | ProvidesObject;
/**
 * Request to a module that should be provided as shared module to the share scope (will be resolved when relative).
 */
export type ProvidesItem = string;

export interface ProvideSharedPluginOptions {
	/**
	 * Modules that should be provided as shared modules to the share scope. When provided, property name is used to match modules, otherwise this is automatically inferred from share key.
	 */
	provides: Provides;
	/**
	 * Share scope name used for all provided modules (defaults to 'default').
	 */
	shareScope?: string;
}
/**
 * Modules that should be provided as shared modules to the share scope. Property names are used as share keys.
 */
export interface ProvidesObject {
	/**
	 * Modules that should be provided as shared modules to the share scope.
	 */
	[k: string]: ProvidesConfig | ProvidesItem;
}
/**
 * Advanced configuration for modules that should be provided as shared modules to the share scope.
 */
export interface ProvidesConfig {
	/**
	 * Include the provided module directly instead behind an async request. This allows to use this shared module in initial load too. All possible shared modules need to be eager too.
	 */
	eager?: boolean;
	/**
	 * Key in the share scope under which the shared modules should be stored.
	 */
	shareKey?: string;
	/**
	 * Share scope name.
	 */
	shareScope?: string;
	/**
	 * Version of the provided module. Will replace lower matching versions, but not higher.
	 */
	version?: false | string;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/declarations/plugins/sharing/SharePlugin.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

/**
 * Modules that should be shared in the share scope. When provided, property names are used to match requested modules in this compilation.
 */
export type Shared = (SharedItem | SharedObject)[] | SharedObject;
/**
 * A module that should be shared in the share scope.
 */
export type SharedItem = string;

/**
 * Options for shared modules.
 */
export interface SharePluginOptions {
	/**
	 * Share scope name used for all shared modules (defaults to 'default').
	 */
	shareScope?: string;
	/**
	 * Modules that should be shared in the share scope. When provided, property names are used to match requested modules in this compilation.
	 */
	shared: Shared;
}
/**
 * Modules that should be shared in the share scope. Property names are used to match requested modules in this compilation. Relative requests are resolved, module requests are matched unresolved, absolute paths will match resolved requests. A trailing slash will match all requests with this prefix. In this case shareKey must also have a trailing slash.
 */
export interface SharedObject {
	/**
	 * Modules that should be shared in the share scope.
	 */
	[k: string]: SharedConfig | SharedItem;
}
/**
 * Advanced configuration for modules that should be shared in the share scope.
 */
export interface SharedConfig {
	/**
	 * Include the provided and fallback module directly instead behind an async request. This allows to use this shared module in initial load too. All possible shared modules need to be eager too.
	 */
	eager?: boolean;
	/**
	 * Provided module that should be provided to share scope. Also acts as fallback module if no shared module is found in share scope or version isn't valid. Defaults to the property name.
	 */
	import?: false | SharedItem;
	/**
	 * Package name to determine required version from description file. This is only needed when package name can't be automatically determined from request.
	 */
	packageName?: string;
	/**
	 * Version requirement from module in share scope.
	 */
	requiredVersion?: false | string;
	/**
	 * Module is looked up under this key from the share scope.
	 */
	shareKey?: string;
	/**
	 * Share scope name.
	 */
	shareScope?: string;
	/**
	 * Allow only a single version of the shared module in share scope (disabled by default).
	 */
	singleton?: boolean;
	/**
	 * Do not accept shared module if version is not valid (defaults to yes, if local fallback module is available and shared module is not a singleton, otherwise no, has no effect if there is no required version specified).
	 */
	strictVersion?: boolean;
	/**
	 * Version of the provided module. Will replace lower matching versions, but not higher.
	 */
	version?: false | string;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/hot/dev-server.d.ts
export {};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/hot/emitter.d.ts
declare const _exports: EventEmitter;
export = _exports;
import EventEmitter = require("events");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/hot/lazy-compilation-node.d.ts
export function keepAlive(options: {
    data: string;
    onError: (err: Error) => void;
    active: boolean;
    module: NodeModule;
}): () => void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/hot/lazy-compilation-web.d.ts
export function keepAlive(options: {
    data: string;
    onError: (err: Error) => void;
    active: boolean;
    module: NodeModule;
}): () => void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/hot/log-apply-result.d.ts
declare function _exports(updatedModules: (string | number)[], renewedModules: (string | number)[] | null): void;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/hot/log.d.ts
declare function _exports(level: LogLevel, msg: string | Error): void;
declare namespace _exports {
    function group(level: LogLevel, msg?: string): void;
    function groupCollapsed(level: LogLevel, msg?: string): void;
    function groupEnd(level: LogLevel, msg?: string): void;
    function setLogLevel(level: LogLevel): void;
    function formatError(err: Error): string;
    export { LogLevel };
}
export = _exports;
export type LogLevel = "info" | "warning" | "error";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/hot/only-dev-server.d.ts
export {};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/hot/poll.d.ts
export {};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/hot/signal.d.ts
export {};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/APIPlugin.d.ts
export = APIPlugin;
/**
 * @typedef {Object} APIPluginOptions
 * @property {boolean} [module] the output filename
 */
declare class APIPlugin {
    /**
     * @param {APIPluginOptions} [options] options
     */
    constructor(options?: APIPluginOptions);
    options: APIPluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace APIPlugin {
    export { Compiler, JavascriptParser, APIPluginOptions };
}
type APIPluginOptions = {
    /**
     * the output filename
     */
    module?: boolean;
};
type Compiler = import("./Compiler");
type JavascriptParser = import("./javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/AbstractMethodError.d.ts
export = AbstractMethodError;
/**
 * Error for abstract method
 * @example
 * class FooClass {
 *     abstractMethod() {
 *         throw new AbstractMethodError(); // error message: Abstract method FooClass.abstractMethod. Must be overridden.
 *     }
 * }
 *
 */
declare class AbstractMethodError extends WebpackError {
    constructor();
}
import WebpackError = require("webpack/lib/WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/AsyncDependenciesBlock.d.ts
export = AsyncDependenciesBlock;
/** @typedef {import("./ChunkGraph")} ChunkGraph */
/** @typedef {import("./ChunkGroup")} ChunkGroup */
/** @typedef {import("./ChunkGroup").ChunkGroupOptions} ChunkGroupOptions */
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("./Dependency").UpdateHashContext} UpdateHashContext */
/** @typedef {import("./Entrypoint").EntryOptions} EntryOptions */
/** @typedef {import("./Module")} Module */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("./util/Hash")} Hash */
declare class AsyncDependenciesBlock extends DependenciesBlock {
    /**
     * @param {(ChunkGroupOptions & { entryOptions?: EntryOptions }) | null} groupOptions options for the group
     * @param {(DependencyLocation | null)=} loc the line of code
     * @param {(string | null)=} request the request
     */
    constructor(groupOptions: (ChunkGroupOptions & {
        entryOptions?: EntryOptions;
    }) | null, loc?: (DependencyLocation | null) | undefined, request?: (string | null) | undefined);
    groupOptions: import("webpack/lib/ChunkGroup").RawChunkGroupOptions & {
        name?: string;
    } & {
        entryOptions?: EntryOptions;
    };
    loc: import("webpack/lib/Dependency").DependencyLocation;
    request: string;
    _stringifiedGroupOptions: string;
    /**
     * @param {string | undefined} value The new chunk name
     * @returns {void}
     */
    set chunkName(arg: string);
    /**
     * @returns {string | undefined} The name of the chunk
     */
    get chunkName(): string;
    set module(arg: any);
    get module(): any;
}
declare namespace AsyncDependenciesBlock {
    export { ChunkGraph, ChunkGroup, ChunkGroupOptions, DependencyLocation, UpdateHashContext, EntryOptions, Module, ObjectDeserializerContext, ObjectSerializerContext, Hash };
}
import DependenciesBlock = require("webpack/lib/DependenciesBlock");
type EntryOptions = import("./Entrypoint").EntryOptions;
type ChunkGroupOptions = import("./ChunkGroup").ChunkGroupOptions;
type DependencyLocation = import("./Dependency").DependencyLocation;
type ChunkGraph = import("./ChunkGraph");
type ChunkGroup = import("./ChunkGroup");
type UpdateHashContext = import("./Dependency").UpdateHashContext;
type Module = import("./Module");
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("./util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/AsyncDependencyToInitialChunkError.d.ts
export = AsyncDependencyToInitialChunkError;
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("./Module")} Module */
declare class AsyncDependencyToInitialChunkError extends WebpackError {
    /**
     * Creates an instance of AsyncDependencyToInitialChunkError.
     * @param {string} chunkName Name of Chunk
     * @param {Module} module module tied to dependency
     * @param {DependencyLocation} loc location of dependency
     */
    constructor(chunkName: string, module: Module, loc: DependencyLocation);
}
declare namespace AsyncDependencyToInitialChunkError {
    export { DependencyLocation, Module };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("./Module");
type DependencyLocation = import("./Dependency").DependencyLocation;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/AutomaticPrefetchPlugin.d.ts
export = AutomaticPrefetchPlugin;
/** @typedef {import("./Compiler")} Compiler */
declare class AutomaticPrefetchPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace AutomaticPrefetchPlugin {
    export { Compiler };
}
type Compiler = import("./Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/BannerPlugin.d.ts
export = BannerPlugin;
declare class BannerPlugin {
    /**
     * @param {BannerPluginArgument} options options object
     */
    constructor(options: any);
    options: any;
    banner: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace BannerPlugin {
    export { BannerFunction, BannerPluginArgument, BannerPluginOptions, Compiler };
}
type Compiler = import("./Compiler");
type BannerFunction = any;
type BannerPluginArgument = any;
type BannerPluginOptions = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Cache.d.ts
export = Cache;
declare class Cache {
    hooks: {
        /** @type {AsyncSeriesBailHook<[string, Etag | null, GotHandler[]], any>} */
        get: AsyncSeriesBailHook<[string, Etag | null, GotHandler[]], any>;
        /** @type {AsyncParallelHook<[string, Etag | null, any]>} */
        store: AsyncParallelHook<[string, Etag | null, any]>;
        /** @type {AsyncParallelHook<[Iterable<string>]>} */
        storeBuildDependencies: AsyncParallelHook<[Iterable<string>]>;
        /** @type {SyncHook<[]>} */
        beginIdle: SyncHook<[]>;
        /** @type {AsyncParallelHook<[]>} */
        endIdle: AsyncParallelHook<[]>;
        /** @type {AsyncParallelHook<[]>} */
        shutdown: AsyncParallelHook<[]>;
    };
    /**
     * @template T
     * @param {string} identifier the cache identifier
     * @param {Etag | null} etag the etag
     * @param {CallbackCache<T>} callback signals when the value is retrieved
     * @returns {void}
     */
    get<T>(identifier: string, etag: Etag | null, callback: CallbackCache<T>): void;
    /**
     * @template T
     * @param {string} identifier the cache identifier
     * @param {Etag | null} etag the etag
     * @param {T} data the value to store
     * @param {CallbackCache<void>} callback signals when the value is stored
     * @returns {void}
     */
    store<T_1>(identifier: string, etag: Etag | null, data: T_1, callback: CallbackCache<void>): void;
    /**
     * After this method has succeeded the cache can only be restored when build dependencies are
     * @param {Iterable<string>} dependencies list of all build dependencies
     * @param {CallbackCache<void>} callback signals when the dependencies are stored
     * @returns {void}
     */
    storeBuildDependencies(dependencies: Iterable<string>, callback: CallbackCache<void>): void;
    /**
     * @returns {void}
     */
    beginIdle(): void;
    /**
     * @param {CallbackCache<void>} callback signals when the call finishes
     * @returns {void}
     */
    endIdle(callback: CallbackCache<void>): void;
    /**
     * @param {CallbackCache<void>} callback signals when the call finishes
     * @returns {void}
     */
    shutdown(callback: CallbackCache<void>): void;
}
declare namespace Cache {
    export { STAGE_MEMORY, STAGE_DEFAULT, STAGE_DISK, STAGE_NETWORK, WebpackError, Etag, CallbackCache, GotHandler };
}
import { AsyncSeriesBailHook } from "tapable";
type Etag = {
    toString: () => string;
};
type GotHandler = (result: any, callback: (arg0: Error | undefined) => void) => void;
import { AsyncParallelHook } from "tapable";
import { SyncHook } from "tapable";
type CallbackCache<T> = (err?: (WebpackError | null) | undefined, result?: T | undefined) => void;
declare var STAGE_MEMORY: number;
declare var STAGE_DEFAULT: number;
declare var STAGE_DISK: number;
declare var STAGE_NETWORK: number;
type WebpackError = import("./WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/CacheFacade.d.ts
export = CacheFacade;
declare class CacheFacade {
    /**
     * @param {Cache} cache the root cache
     * @param {string} name the child cache name
     * @param {string | HashConstructor} hashFunction the hash function to use
     */
    constructor(cache: Cache, name: string, hashFunction: string | HashConstructor);
    _cache: import("webpack/lib/Cache");
    _name: string;
    _hashFunction: string | typeof import("webpack/lib/util/Hash");
    /**
     * @param {string} name the child cache name#
     * @returns {CacheFacade} child cache
     */
    getChildCache(name: string): CacheFacade;
    /**
     * @param {string} identifier the cache identifier
     * @param {Etag | null} etag the etag
     * @returns {ItemCacheFacade} item cache
     */
    getItemCache(identifier: string, etag: Etag | null): ItemCacheFacade;
    /**
     * @param {HashableObject} obj an hashable object
     * @returns {Etag} an etag that is lazy hashed
     */
    getLazyHashedEtag(obj: HashableObject): Etag;
    /**
     * @param {Etag} a an etag
     * @param {Etag} b another etag
     * @returns {Etag} an etag that represents both
     */
    mergeEtags(a: Etag, b: Etag): Etag;
    /**
     * @template T
     * @param {string} identifier the cache identifier
     * @param {Etag | null} etag the etag
     * @param {CallbackCache<T>} callback signals when the value is retrieved
     * @returns {void}
     */
    get<T>(identifier: string, etag: Etag | null, callback: CallbackCache<T>): void;
    /**
     * @template T
     * @param {string} identifier the cache identifier
     * @param {Etag | null} etag the etag
     * @returns {Promise<T>} promise with the data
     */
    getPromise<T_1>(identifier: string, etag: Etag | null): Promise<T_1>;
    /**
     * @template T
     * @param {string} identifier the cache identifier
     * @param {Etag | null} etag the etag
     * @param {T} data the value to store
     * @param {CallbackCache<void>} callback signals when the value is stored
     * @returns {void}
     */
    store<T_2>(identifier: string, etag: Etag | null, data: T_2, callback: CallbackCache<void>): void;
    /**
     * @template T
     * @param {string} identifier the cache identifier
     * @param {Etag | null} etag the etag
     * @param {T} data the value to store
     * @returns {Promise<void>} promise signals when the value is stored
     */
    storePromise<T_3>(identifier: string, etag: Etag | null, data: T_3): Promise<void>;
    /**
     * @template T
     * @param {string} identifier the cache identifier
     * @param {Etag | null} etag the etag
     * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached
     * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved
     * @returns {void}
     */
    provide<T_4>(identifier: string, etag: Etag | null, computer: (arg0: CallbackNormalErrorCache<T_4>) => void, callback: CallbackNormalErrorCache<T_4>): void;
    /**
     * @template T
     * @param {string} identifier the cache identifier
     * @param {Etag | null} etag the etag
     * @param {function(): Promise<T> | T} computer function to compute the value if not cached
     * @returns {Promise<T>} promise with the data
     */
    providePromise<T_5>(identifier: string, etag: Etag | null, computer: () => T_5 | Promise<T_5>): Promise<T_5>;
}
declare namespace CacheFacade {
    export { ItemCacheFacade, MultiItemCache, Cache, Etag, WebpackError, HashableObject, HashConstructor, CallbackCache, CallbackNormalErrorCache };
}
type Etag = import("./Cache").Etag;
declare class ItemCacheFacade {
    /**
     * @param {Cache} cache the root cache
     * @param {string} name the child cache item name
     * @param {Etag | null} etag the etag
     */
    constructor(cache: Cache, name: string, etag: Etag | null);
    _cache: import("webpack/lib/Cache");
    _name: string;
    _etag: import("webpack/lib/Cache").Etag;
    /**
     * @template T
     * @param {CallbackCache<T>} callback signals when the value is retrieved
     * @returns {void}
     */
    get<T>(callback: CallbackCache<T>): void;
    /**
     * @template T
     * @returns {Promise<T>} promise with the data
     */
    getPromise<T_1>(): Promise<T_1>;
    /**
     * @template T
     * @param {T} data the value to store
     * @param {CallbackCache<void>} callback signals when the value is stored
     * @returns {void}
     */
    store<T_2>(data: T_2, callback: CallbackCache<void>): void;
    /**
     * @template T
     * @param {T} data the value to store
     * @returns {Promise<void>} promise signals when the value is stored
     */
    storePromise<T_3>(data: T_3): Promise<void>;
    /**
     * @template T
     * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached
     * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved
     * @returns {void}
     */
    provide<T_4>(computer: (arg0: CallbackNormalErrorCache<T_4>) => void, callback: CallbackNormalErrorCache<T_4>): void;
    /**
     * @template T
     * @param {function(): Promise<T> | T} computer function to compute the value if not cached
     * @returns {Promise<T>} promise with the data
     */
    providePromise<T_5>(computer: () => T_5 | Promise<T_5>): Promise<T_5>;
}
type HashableObject = import("./cache/getLazyHashedEtag").HashableObject;
type CallbackCache<T> = (err?: (WebpackError | null) | undefined, result?: T | undefined) => void;
type CallbackNormalErrorCache<T> = (err?: (Error | null) | undefined, result?: T | undefined) => void;
type Cache = import("./Cache");
type HashConstructor = typeof import("./util/Hash");
/** @typedef {import("./Cache")} Cache */
/** @typedef {import("./Cache").Etag} Etag */
/** @typedef {import("./WebpackError")} WebpackError */
/** @typedef {import("./cache/getLazyHashedEtag").HashableObject} HashableObject */
/** @typedef {typeof import("./util/Hash")} HashConstructor */
/**
 * @template T
 * @callback CallbackCache
 * @param {(WebpackError | null)=} err
 * @param {T=} result
 * @returns {void}
 */
/**
 * @template T
 * @callback CallbackNormalErrorCache
 * @param {(Error | null)=} err
 * @param {T=} result
 * @returns {void}
 */
declare class MultiItemCache {
    /**
     * @param {ItemCacheFacade[]} items item caches
     */
    constructor(items: ItemCacheFacade[]);
    _items: ItemCacheFacade[];
    /**
     * @template T
     * @param {CallbackCache<T>} callback signals when the value is retrieved
     * @returns {void}
     */
    get<T>(callback: CallbackCache<T>): void;
    /**
     * @template T
     * @returns {Promise<T>} promise with the data
     */
    getPromise<T_1>(): Promise<T_1>;
    /**
     * @template T
     * @param {T} data the value to store
     * @param {CallbackCache<void>} callback signals when the value is stored
     * @returns {void}
     */
    store<T_2>(data: T_2, callback: CallbackCache<void>): void;
    /**
     * @template T
     * @param {T} data the value to store
     * @returns {Promise<void>} promise signals when the value is stored
     */
    storePromise<T_3>(data: T_3): Promise<void>;
}
type WebpackError = import("./WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/CaseSensitiveModulesWarning.d.ts
export = CaseSensitiveModulesWarning;
declare class CaseSensitiveModulesWarning extends WebpackError {
    /**
     * Creates an instance of CaseSensitiveModulesWarning.
     * @param {Iterable<Module>} modules modules that were detected
     * @param {ModuleGraph} moduleGraph the module graph
     */
    constructor(modules: Iterable<Module>, moduleGraph: ModuleGraph);
}
declare namespace CaseSensitiveModulesWarning {
    export { Module, ModuleGraph };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("./Module");
type ModuleGraph = import("./ModuleGraph");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Chunk.d.ts
export = Chunk;
/**
 * A Chunk is a unit of encapsulation for Modules.
 * Chunks are "rendered" into bundles that get emitted when the build completes.
 */
declare class Chunk {
    /**
     * @param {string=} name of chunk being created, is optional (for subclasses)
     * @param {boolean} backCompat enable backward-compatibility
     */
    constructor(name?: string | undefined, backCompat?: boolean);
    /** @type {ChunkId | null} */
    id: ChunkId | null;
    /** @type {ChunkId[] | null} */
    ids: ChunkId[] | null;
    /** @type {number} */
    debugId: number;
    /** @type {string | undefined} */
    name: string | undefined;
    /** @type {SortableSet<string>} */
    idNameHints: SortableSet<string>;
    /** @type {boolean} */
    preventIntegration: boolean;
    /** @type {(string | function(PathData, AssetInfo=): string) | undefined} */
    filenameTemplate: (string | ((arg0: PathData, arg1: AssetInfo | undefined) => string)) | undefined;
    /** @type {(string | function(PathData, AssetInfo=): string) | undefined} */
    cssFilenameTemplate: (string | ((arg0: PathData, arg1: AssetInfo | undefined) => string)) | undefined;
    /** @private @type {SortableSet<ChunkGroup>} */
    private _groups;
    /** @type {RuntimeSpec} */
    runtime: RuntimeSpec;
    /** @type {Set<string>} */
    files: Set<string>;
    /** @type {Set<string>} */
    auxiliaryFiles: Set<string>;
    /** @type {boolean} */
    rendered: boolean;
    /** @type {string=} */
    hash: string | undefined;
    /** @type {Record<string, string>} */
    contentHash: Record<string, string>;
    /** @type {string=} */
    renderedHash: string | undefined;
    /** @type {string=} */
    chunkReason: string | undefined;
    /** @type {boolean} */
    extraAsync: boolean;
    get entryModule(): import("webpack/lib/Module");
    /**
     * @returns {boolean} true, if the chunk contains an entry module
     */
    hasEntryModule(): boolean;
    /**
     * @param {Module} module the module
     * @returns {boolean} true, if the chunk could be added
     */
    addModule(module: Module): boolean;
    /**
     * @param {Module} module the module
     * @returns {void}
     */
    removeModule(module: Module): void;
    /**
     * @returns {number} the number of module which are contained in this chunk
     */
    getNumberOfModules(): number;
    get modulesIterable(): Iterable<import("webpack/lib/Module")>;
    /**
     * @param {Chunk} otherChunk the chunk to compare with
     * @returns {-1|0|1} the comparison result
     */
    compareTo(otherChunk: Chunk): -1 | 0 | 1;
    /**
     * @param {Module} module the module
     * @returns {boolean} true, if the chunk contains the module
     */
    containsModule(module: Module): boolean;
    /**
     * @returns {Module[]} the modules for this chunk
     */
    getModules(): Module[];
    /**
     * @returns {void}
     */
    remove(): void;
    /**
     * @param {Module} module the module
     * @param {Chunk} otherChunk the target chunk
     * @returns {void}
     */
    moveModule(module: Module, otherChunk: Chunk): void;
    /**
     * @param {Chunk} otherChunk the other chunk
     * @returns {boolean} true, if the specified chunk has been integrated
     */
    integrate(otherChunk: Chunk): boolean;
    /**
     * @param {Chunk} otherChunk the other chunk
     * @returns {boolean} true, if chunks could be integrated
     */
    canBeIntegrated(otherChunk: Chunk): boolean;
    /**
     * @returns {boolean} true, if this chunk contains no module
     */
    isEmpty(): boolean;
    /**
     * @returns {number} total size of all modules in this chunk
     */
    modulesSize(): number;
    /**
     * @param {ChunkSizeOptions} options options object
     * @returns {number} total size of this chunk
     */
    size(options?: ChunkSizeOptions): number;
    /**
     * @param {Chunk} otherChunk the other chunk
     * @param {ChunkSizeOptions} options options object
     * @returns {number} total size of the chunk or false if the chunk can't be integrated
     */
    integratedSize(otherChunk: Chunk, options: ChunkSizeOptions): number;
    /**
     * @param {ModuleFilterPredicate} filterFn function used to filter modules
     * @returns {ChunkModuleMaps} module map information
     */
    getChunkModuleMaps(filterFn: ModuleFilterPredicate): ChunkModuleMaps;
    /**
     * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules
     * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks
     * @returns {boolean} return true if module exists in graph
     */
    hasModuleInGraph(filterFn: ModuleFilterPredicate, filterChunkFn?: ChunkFilterPredicate | undefined): boolean;
    /**
     * @deprecated
     * @param {boolean} realHash whether the full hash or the rendered hash is to be used
     * @returns {ChunkMaps} the chunk map information
     */
    getChunkMaps(realHash: boolean): ChunkMaps;
    /**
     * @returns {boolean} whether or not the Chunk will have a runtime
     */
    hasRuntime(): boolean;
    /**
     * @returns {boolean} whether or not this chunk can be an initial chunk
     */
    canBeInitial(): boolean;
    /**
     * @returns {boolean} whether this chunk can only be an initial chunk
     */
    isOnlyInitial(): boolean;
    /**
     * @returns {EntryOptions | undefined} the entry options for this chunk
     */
    getEntryOptions(): EntryOptions | undefined;
    /**
     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added
     * @returns {void}
     */
    addGroup(chunkGroup: ChunkGroup): void;
    /**
     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from
     * @returns {void}
     */
    removeGroup(chunkGroup: ChunkGroup): void;
    /**
     * @param {ChunkGroup} chunkGroup the chunkGroup to check
     * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup
     */
    isInGroup(chunkGroup: ChunkGroup): boolean;
    /**
     * @returns {number} the amount of groups that the said chunk is in
     */
    getNumberOfGroups(): number;
    /**
     * @returns {SortableSet<ChunkGroup>} the chunkGroups that the said chunk is referenced in
     */
    get groupsIterable(): SortableSet<import("webpack/lib/ChunkGroup")>;
    /**
     * @returns {void}
     */
    disconnectFromGroups(): void;
    /**
     * @param {Chunk} newChunk the new chunk that will be split out of
     * @returns {void}
     */
    split(newChunk: Chunk): void;
    /**
     * @param {Hash} hash hash (will be modified)
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @returns {void}
     */
    updateHash(hash: Hash, chunkGraph: ChunkGraph): void;
    /**
     * @returns {Set<Chunk>} a set of all the async chunks
     */
    getAllAsyncChunks(): Set<Chunk>;
    /**
     * @returns {Set<Chunk>} a set of all the initial chunks (including itself)
     */
    getAllInitialChunks(): Set<Chunk>;
    /**
     * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)
     */
    getAllReferencedChunks(): Set<Chunk>;
    /**
     * @returns {Set<Entrypoint>} a set of all the referenced entrypoints
     */
    getAllReferencedAsyncEntrypoints(): Set<Entrypoint>;
    /**
     * @returns {boolean} true, if the chunk references async chunks
     */
    hasAsyncChunks(): boolean;
    /**
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @param {ChunkFilterPredicate=} filterFn function used to filter chunks
     * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)
     */
    getChildIdsByOrders(chunkGraph: ChunkGraph, filterFn?: ChunkFilterPredicate | undefined): Record<string, (string | number)[]>;
    /**
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @param {string} type option name
     * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[] | undefined} referenced chunks for a specific type
     */
    getChildrenOfTypeInOrder(chunkGraph: ChunkGraph, type: string): {
        onChunks: Chunk[];
        chunks: Set<Chunk>;
    }[] | undefined;
    /**
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)
     * @param {ChunkFilterPredicate=} filterFn function used to filter chunks
     * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id
     */
    getChildIdsByOrdersMap(chunkGraph: ChunkGraph, includeDirectChildren?: boolean | undefined, filterFn?: ChunkFilterPredicate | undefined): Record<string | number, Record<string, (string | number)[]>>;
}
declare namespace Chunk {
    export { Source, ChunkFilterPredicate, ChunkSizeOptions, ModuleFilterPredicate, ChunkGroup, ChunkGroupOptions, Compilation, AssetInfo, PathData, EntryOptions, Module, ModuleGraph, Hash, RuntimeSpec, ChunkId, WithId, ChunkMaps, ChunkModuleMaps };
}
type ChunkId = number | string;
import SortableSet = require("webpack/lib/util/SortableSet");
type PathData = import("./Compilation").PathData;
type AssetInfo = import("./Compilation").AssetInfo;
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
type Module = import("./Module");
type ChunkSizeOptions = import("./ChunkGraph").ChunkSizeOptions;
type ModuleFilterPredicate = import("./ChunkGraph").ModuleFilterPredicate;
type ChunkModuleMaps = {
    id: Record<string | number, (string | number)[]>;
    hash: Record<string | number, string>;
};
type ChunkFilterPredicate = import("./ChunkGraph").ChunkFilterPredicate;
type ChunkMaps = {
    hash: Record<string | number, string>;
    contentHash: Record<string | number, Record<string, string>>;
    name: Record<string | number, string>;
};
type EntryOptions = import("./Entrypoint").EntryOptions;
type ChunkGroup = import("./ChunkGroup");
type Hash = import("./util/Hash");
import ChunkGraph = require("webpack/lib/ChunkGraph");
import Entrypoint = require("webpack/lib/Entrypoint");
type Source = import("webpack-sources").Source;
type ChunkGroupOptions = import("./ChunkGroup").ChunkGroupOptions;
type Compilation = import("./Compilation");
type ModuleGraph = import("./ModuleGraph");
/**
 * an object who has an id property *
 */
type WithId = {
    /**
     * the id of the object
     */
    id: string | number;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ChunkGraph.d.ts
export = ChunkGraph;
declare class ChunkGraph {
    /**
     * @param {Module} module the module
     * @param {string} deprecateMessage message for the deprecation message
     * @param {string} deprecationCode code for the deprecation
     * @returns {ChunkGraph} the chunk graph
     */
    static getChunkGraphForModule(module: Module, deprecateMessage: string, deprecationCode: string): ChunkGraph;
    /**
     * @param {Module} module the module
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @returns {void}
     */
    static setChunkGraphForModule(module: Module, chunkGraph: ChunkGraph): void;
    /**
     * @param {Module} module the module
     * @returns {void}
     */
    static clearChunkGraphForModule(module: Module): void;
    /**
     * @param {Chunk} chunk the chunk
     * @param {string} deprecateMessage message for the deprecation message
     * @param {string} deprecationCode code for the deprecation
     * @returns {ChunkGraph} the chunk graph
     */
    static getChunkGraphForChunk(chunk: Chunk, deprecateMessage: string, deprecationCode: string): ChunkGraph;
    /**
     * @param {Chunk} chunk the chunk
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @returns {void}
     */
    static setChunkGraphForChunk(chunk: Chunk, chunkGraph: ChunkGraph): void;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {void}
     */
    static clearChunkGraphForChunk(chunk: Chunk): void;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {string | Hash} hashFunction the hash function to use
     */
    constructor(moduleGraph: ModuleGraph, hashFunction?: string | Hash);
    /** @private @type {WeakMap<Module, ChunkGraphModule>} */
    private _modules;
    /** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */
    private _chunks;
    /** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */
    private _blockChunkGroups;
    /** @private @type {Map<string, string | number>} */
    private _runtimeIds;
    /** @type {ModuleGraph} */
    moduleGraph: ModuleGraph;
    _hashFunction: string | typeof import("webpack/lib/util/Hash");
    /**
     * @param {SortableSet<Module>} set the sortable Set to get the roots of
     * @returns {Module[]} the graph roots
     */
    _getGraphRoots(set: SortableSet<Module>): Module[];
    /**
     * @private
     * @param {Module} module the module
     * @returns {ChunkGraphModule} internal module
     */
    private _getChunkGraphModule;
    /**
     * @private
     * @param {Chunk} chunk the chunk
     * @returns {ChunkGraphChunk} internal chunk
     */
    private _getChunkGraphChunk;
    /**
     * @param {Chunk} chunk the new chunk
     * @param {Module} module the module
     * @returns {void}
     */
    connectChunkAndModule(chunk: Chunk, module: Module): void;
    /**
     * @param {Chunk} chunk the chunk
     * @param {Module} module the module
     * @returns {void}
     */
    disconnectChunkAndModule(chunk: Chunk, module: Module): void;
    /**
     * @param {Chunk} chunk the chunk which will be disconnected
     * @returns {void}
     */
    disconnectChunk(chunk: Chunk): void;
    /**
     * @param {Chunk} chunk the chunk
     * @param {Iterable<Module>} modules the modules
     * @returns {void}
     */
    attachModules(chunk: Chunk, modules: Iterable<Module>): void;
    /**
     * @param {Chunk} chunk the chunk
     * @param {Iterable<RuntimeModule>} modules the runtime modules
     * @returns {void}
     */
    attachRuntimeModules(chunk: Chunk, modules: Iterable<RuntimeModule>): void;
    /**
     * @param {Chunk} chunk the chunk
     * @param {Iterable<RuntimeModule>} modules the modules that require a full hash
     * @returns {void}
     */
    attachFullHashModules(chunk: Chunk, modules: Iterable<RuntimeModule>): void;
    /**
     * @param {Chunk} chunk the chunk
     * @param {Iterable<RuntimeModule>} modules the modules that require a full hash
     * @returns {void}
     */
    attachDependentHashModules(chunk: Chunk, modules: Iterable<RuntimeModule>): void;
    /**
     * @param {Module} oldModule the replaced module
     * @param {Module} newModule the replacing module
     * @returns {void}
     */
    replaceModule(oldModule: Module, newModule: Module): void;
    /**
     * @param {Module} module the checked module
     * @param {Chunk} chunk the checked chunk
     * @returns {boolean} true, if the chunk contains the module
     */
    isModuleInChunk(module: Module, chunk: Chunk): boolean;
    /**
     * @param {Module} module the checked module
     * @param {ChunkGroup} chunkGroup the checked chunk group
     * @returns {boolean} true, if the chunk contains the module
     */
    isModuleInChunkGroup(module: Module, chunkGroup: ChunkGroup): boolean;
    /**
     * @param {Module} module the checked module
     * @returns {boolean} true, if the module is entry of any chunk
     */
    isEntryModule(module: Module): boolean;
    /**
     * @param {Module} module the module
     * @returns {Iterable<Chunk>} iterable of chunks (do not modify)
     */
    getModuleChunksIterable(module: Module): Iterable<Chunk>;
    /**
     * @param {Module} module the module
     * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function
     * @returns {Iterable<Chunk>} iterable of chunks (do not modify)
     */
    getOrderedModuleChunksIterable(module: Module, sortFn: (arg0: Chunk, arg1: Chunk) => -1 | 0 | 1): Iterable<Chunk>;
    /**
     * @param {Module} module the module
     * @returns {Chunk[]} array of chunks (cached, do not modify)
     */
    getModuleChunks(module: Module): Chunk[];
    /**
     * @param {Module} module the module
     * @returns {number} the number of chunk which contain the module
     */
    getNumberOfModuleChunks(module: Module): number;
    /**
     * @param {Module} module the module
     * @returns {RuntimeSpecSet} runtimes
     */
    getModuleRuntimes(module: Module): RuntimeSpecSet;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {number} the number of modules which are contained in this chunk
     */
    getNumberOfChunkModules(chunk: Chunk): number;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {number} the number of full hash modules which are contained in this chunk
     */
    getNumberOfChunkFullHashModules(chunk: Chunk): number;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {Iterable<Module>} return the modules for this chunk
     */
    getChunkModulesIterable(chunk: Chunk): Iterable<Module>;
    /**
     * @param {Chunk} chunk the chunk
     * @param {string} sourceType source type
     * @returns {Iterable<Module> | undefined} return the modules for this chunk
     */
    getChunkModulesIterableBySourceType(chunk: Chunk, sourceType: string): Iterable<Module> | undefined;
    /**
     * @param {Chunk} chunk chunk
     * @param {Module} module chunk module
     * @param {Set<string>} sourceTypes source types
     */
    setChunkModuleSourceTypes(chunk: Chunk, module: Module, sourceTypes: Set<string>): void;
    /**
     * @param {Chunk} chunk chunk
     * @param {Module} module chunk module
     * @returns {Set<string>} source types
     */
    getChunkModuleSourceTypes(chunk: Chunk, module: Module): Set<string>;
    /**
     * @param {Module} module module
     * @returns {Set<string>} source types
     */
    getModuleSourceTypes(module: Module): Set<string>;
    /**
     * @param {Module} module module
     * @returns {Set<string> | undefined} source types
     */
    _getOverwrittenModuleSourceTypes(module: Module): Set<string> | undefined;
    /**
     * @param {Chunk} chunk the chunk
     * @param {function(Module, Module): -1|0|1} comparator comparator function
     * @returns {Iterable<Module>} return the modules for this chunk
     */
    getOrderedChunkModulesIterable(chunk: Chunk, comparator: (arg0: Module, arg1: Module) => -1 | 0 | 1): Iterable<Module>;
    /**
     * @param {Chunk} chunk the chunk
     * @param {string} sourceType source type
     * @param {function(Module, Module): -1|0|1} comparator comparator function
     * @returns {Iterable<Module> | undefined} return the modules for this chunk
     */
    getOrderedChunkModulesIterableBySourceType(chunk: Chunk, sourceType: string, comparator: (arg0: Module, arg1: Module) => -1 | 0 | 1): Iterable<Module> | undefined;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {Module[]} return the modules for this chunk (cached, do not modify)
     */
    getChunkModules(chunk: Chunk): Module[];
    /**
     * @param {Chunk} chunk the chunk
     * @param {function(Module, Module): -1|0|1} comparator comparator function
     * @returns {Module[]} return the modules for this chunk (cached, do not modify)
     */
    getOrderedChunkModules(chunk: Chunk, comparator: (arg0: Module, arg1: Module) => -1 | 0 | 1): Module[];
    /**
     * @param {Chunk} chunk the chunk
     * @param {ModuleFilterPredicate} filterFn function used to filter modules
     * @param {boolean} includeAllChunks all chunks or only async chunks
     * @returns {Record<string|number, (string|number)[]>} chunk to module ids object
     */
    getChunkModuleIdMap(chunk: Chunk, filterFn: ModuleFilterPredicate, includeAllChunks?: boolean): Record<string | number, (string | number)[]>;
    /**
     * @param {Chunk} chunk the chunk
     * @param {ModuleFilterPredicate} filterFn function used to filter modules
     * @param {number} hashLength length of the hash
     * @param {boolean} includeAllChunks all chunks or only async chunks
     * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object
     */
    getChunkModuleRenderedHashMap(chunk: Chunk, filterFn: ModuleFilterPredicate, hashLength?: number, includeAllChunks?: boolean): Record<string | number, Record<string | number, string>>;
    /**
     * @param {Chunk} chunk the chunk
     * @param {ChunkFilterPredicate} filterFn function used to filter chunks
     * @returns {Record<string|number, boolean>} chunk map
     */
    getChunkConditionMap(chunk: Chunk, filterFn: ChunkFilterPredicate): Record<string | number, boolean>;
    /**
     * @param {Chunk} chunk the chunk
     * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules
     * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks
     * @returns {boolean} return true if module exists in graph
     */
    hasModuleInGraph(chunk: Chunk, filterFn: ModuleFilterPredicate, filterChunkFn?: ChunkFilterPredicate | undefined): boolean;
    /**
     * @param {Chunk} chunkA first chunk
     * @param {Chunk} chunkB second chunk
     * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order
     */
    compareChunks(chunkA: Chunk, chunkB: Chunk): -1 | 0 | 1;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {number} total size of all modules in the chunk
     */
    getChunkModulesSize(chunk: Chunk): number;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {Record<string, number>} total sizes of all modules in the chunk by source type
     */
    getChunkModulesSizes(chunk: Chunk): Record<string, number>;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {Module[]} root modules of the chunks (ordered by identifier)
     */
    getChunkRootModules(chunk: Chunk): Module[];
    /**
     * @param {Chunk} chunk the chunk
     * @param {ChunkSizeOptions} options options object
     * @returns {number} total size of the chunk
     */
    getChunkSize(chunk: Chunk, options?: ChunkSizeOptions): number;
    /**
     * @param {Chunk} chunkA chunk
     * @param {Chunk} chunkB chunk
     * @param {ChunkSizeOptions} options options object
     * @returns {number} total size of the chunk or false if chunks can't be integrated
     */
    getIntegratedChunksSize(chunkA: Chunk, chunkB: Chunk, options?: ChunkSizeOptions): number;
    /**
     * @param {Chunk} chunkA chunk
     * @param {Chunk} chunkB chunk
     * @returns {boolean} true, if chunks could be integrated
     */
    canChunksBeIntegrated(chunkA: Chunk, chunkB: Chunk): boolean;
    /**
     * @param {Chunk} chunkA the target chunk
     * @param {Chunk} chunkB the chunk to integrate
     * @returns {void}
     */
    integrateChunks(chunkA: Chunk, chunkB: Chunk): void;
    /**
     * @param {Chunk} chunk the chunk to upgrade
     * @returns {void}
     */
    upgradeDependentToFullHashModules(chunk: Chunk): void;
    /**
     * @param {Module} module the checked module
     * @param {Chunk} chunk the checked chunk
     * @returns {boolean} true, if the chunk contains the module as entry
     */
    isEntryModuleInChunk(module: Module, chunk: Chunk): boolean;
    /**
     * @param {Chunk} chunk the new chunk
     * @param {Module} module the entry module
     * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed
     * @returns {void}
     */
    connectChunkAndEntryModule(chunk: Chunk, module: Module, entrypoint?: Entrypoint | undefined): void;
    /**
     * @param {Chunk} chunk the new chunk
     * @param {RuntimeModule} module the runtime module
     * @returns {void}
     */
    connectChunkAndRuntimeModule(chunk: Chunk, module: RuntimeModule): void;
    /**
     * @param {Chunk} chunk the new chunk
     * @param {RuntimeModule} module the module that require a full hash
     * @returns {void}
     */
    addFullHashModuleToChunk(chunk: Chunk, module: RuntimeModule): void;
    /**
     * @param {Chunk} chunk the new chunk
     * @param {RuntimeModule} module the module that require a full hash
     * @returns {void}
     */
    addDependentHashModuleToChunk(chunk: Chunk, module: RuntimeModule): void;
    /**
     * @param {Chunk} chunk the new chunk
     * @param {Module} module the entry module
     * @returns {void}
     */
    disconnectChunkAndEntryModule(chunk: Chunk, module: Module): void;
    /**
     * @param {Chunk} chunk the new chunk
     * @param {RuntimeModule} module the runtime module
     * @returns {void}
     */
    disconnectChunkAndRuntimeModule(chunk: Chunk, module: RuntimeModule): void;
    /**
     * @param {Module} module the entry module, it will no longer be entry
     * @returns {void}
     */
    disconnectEntryModule(module: Module): void;
    /**
     * @param {Chunk} chunk the chunk, for which all entries will be removed
     * @returns {void}
     */
    disconnectEntries(chunk: Chunk): void;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {number} the amount of entry modules in chunk
     */
    getNumberOfEntryModules(chunk: Chunk): number;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {number} the amount of entry modules in chunk
     */
    getNumberOfRuntimeModules(chunk: Chunk): number;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {Iterable<Module>} iterable of modules (do not modify)
     */
    getChunkEntryModulesIterable(chunk: Chunk): Iterable<Module>;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {Iterable<Chunk>} iterable of chunks
     */
    getChunkEntryDependentChunksIterable(chunk: Chunk): Iterable<Chunk>;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {boolean} true, when it has dependent chunks
     */
    hasChunkEntryDependentChunks(chunk: Chunk): boolean;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)
     */
    getChunkRuntimeModulesIterable(chunk: Chunk): Iterable<RuntimeModule>;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {RuntimeModule[]} array of modules in order of execution
     */
    getChunkRuntimeModulesInOrder(chunk: Chunk): RuntimeModule[];
    /**
     * @param {Chunk} chunk the chunk
     * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)
     */
    getChunkFullHashModulesIterable(chunk: Chunk): Iterable<RuntimeModule> | undefined;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)
     */
    getChunkFullHashModulesSet(chunk: Chunk): ReadonlySet<RuntimeModule> | undefined;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)
     */
    getChunkDependentHashModulesIterable(chunk: Chunk): Iterable<RuntimeModule> | undefined;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)
     */
    getChunkEntryModulesWithChunkGroupIterable(chunk: Chunk): Iterable<EntryModuleWithChunkGroup>;
    /**
     * @param {AsyncDependenciesBlock} depBlock the async block
     * @returns {ChunkGroup} the chunk group
     */
    getBlockChunkGroup(depBlock: AsyncDependenciesBlock): ChunkGroup;
    /**
     * @param {AsyncDependenciesBlock} depBlock the async block
     * @param {ChunkGroup} chunkGroup the chunk group
     * @returns {void}
     */
    connectBlockAndChunkGroup(depBlock: AsyncDependenciesBlock, chunkGroup: ChunkGroup): void;
    /**
     * @param {ChunkGroup} chunkGroup the chunk group
     * @returns {void}
     */
    disconnectChunkGroup(chunkGroup: ChunkGroup): void;
    /**
     * @param {Module} module the module
     * @returns {string | number} the id of the module
     */
    getModuleId(module: Module): string | number;
    /**
     * @param {Module} module the module
     * @param {string | number} id the id of the module
     * @returns {void}
     */
    setModuleId(module: Module, id: string | number): void;
    /**
     * @param {string} runtime runtime
     * @returns {string | number} the id of the runtime
     */
    getRuntimeId(runtime: string): string | number;
    /**
     * @param {string} runtime runtime
     * @param {string | number} id the id of the runtime
     * @returns {void}
     */
    setRuntimeId(runtime: string, id: string | number): void;
    /**
     * @template T
     * @param {Module} module the module
     * @param {RuntimeSpecMap<T>} hashes hashes data
     * @param {RuntimeSpec} runtime the runtime
     * @returns {T} hash
     */
    _getModuleHashInfo<T>(module: Module, hashes: RuntimeSpecMap<T>, runtime: RuntimeSpec): T;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime the runtime
     * @returns {boolean} true, if the module has hashes for this runtime
     */
    hasModuleHashes(module: Module, runtime: RuntimeSpec): boolean;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime the runtime
     * @returns {string} hash
     */
    getModuleHash(module: Module, runtime: RuntimeSpec): string;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime the runtime
     * @returns {string} hash
     */
    getRenderedModuleHash(module: Module, runtime: RuntimeSpec): string;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime the runtime
     * @param {string} hash the full hash
     * @param {string} renderedHash the shortened hash for rendering
     * @returns {void}
     */
    setModuleHashes(module: Module, runtime: RuntimeSpec, hash: string, renderedHash: string): void;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime the runtime
     * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)
     * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified
     * @returns {void}
     */
    addModuleRuntimeRequirements(module: Module, runtime: RuntimeSpec, items: Set<string>, transferOwnership?: boolean): void;
    /**
     * @param {Chunk} chunk the chunk
     * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)
     * @returns {void}
     */
    addChunkRuntimeRequirements(chunk: Chunk, items: Set<string>): void;
    /**
     * @param {Chunk} chunk the chunk
     * @param {Iterable<string>} items runtime requirements to be added
     * @returns {void}
     */
    addTreeRuntimeRequirements(chunk: Chunk, items: Iterable<string>): void;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime the runtime
     * @returns {ReadonlySet<string>} runtime requirements
     */
    getModuleRuntimeRequirements(module: Module, runtime: RuntimeSpec): ReadonlySet<string>;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {ReadonlySet<string>} runtime requirements
     */
    getChunkRuntimeRequirements(chunk: Chunk): ReadonlySet<string>;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime the runtime
     * @param {boolean} withConnections include connections
     * @returns {string} hash
     */
    getModuleGraphHash(module: Module, runtime: RuntimeSpec, withConnections?: boolean): string;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime the runtime
     * @param {boolean} withConnections include connections
     * @returns {bigint} hash
     */
    getModuleGraphHashBigInt(module: Module, runtime: RuntimeSpec, withConnections?: boolean): bigint;
    /**
     * @param {ChunkGraphModule} cgm the ChunkGraphModule
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime the runtime
     * @returns {bigint} hash as big int
     */
    _getModuleGraphHashBigInt(cgm: ChunkGraphModule, module: Module, runtime: RuntimeSpec): bigint;
    /**
     * @param {ChunkGraphModule} cgm the ChunkGraphModule
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime the runtime
     * @returns {string} hash
     */
    _getModuleGraphHashWithConnections(cgm: ChunkGraphModule, module: Module, runtime: RuntimeSpec): string;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {ReadonlySet<string>} runtime requirements
     */
    getTreeRuntimeRequirements(chunk: Chunk): ReadonlySet<string>;
}
declare namespace ChunkGraph {
    export { AsyncDependenciesBlock, Chunk, ChunkGroup, Module, ModuleGraph, RuntimeModule, Hash, RuntimeSpec, ChunkFilterPredicate, ModuleFilterPredicate, EntryModuleWithChunkGroup, ChunkSizeOptions, SetToArrayFunction };
}
type ModuleGraph = import("./ModuleGraph");
import SortableSet = require("webpack/lib/util/SortableSet");
type Module = import("./Module");
type Chunk = import("./Chunk");
type RuntimeModule = import("./RuntimeModule");
type ChunkGroup = import("./ChunkGroup");
import { RuntimeSpecSet } from "webpack/lib/util/runtime";
type ModuleFilterPredicate = (m: Module) => boolean;
type ChunkFilterPredicate = (c: Chunk, chunkGraph: ChunkGraph) => boolean;
type ChunkSizeOptions = {
    /**
     * constant overhead for a chunk
     */
    chunkOverhead?: number | undefined;
    /**
     * multiplicator for initial chunks
     */
    entryChunkMultiplicator?: number | undefined;
};
import Entrypoint = require("webpack/lib/Entrypoint");
type EntryModuleWithChunkGroup = [Module, Entrypoint | undefined];
type AsyncDependenciesBlock = import("./AsyncDependenciesBlock");
import { RuntimeSpecMap } from "webpack/lib/util/runtime";
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
declare class ChunkGraphModule {
    /** @type {SortableSet<Chunk>} */
    chunks: SortableSet<Chunk>;
    /** @type {Set<Chunk> | undefined} */
    entryInChunks: Set<Chunk> | undefined;
    /** @type {Set<Chunk> | undefined} */
    runtimeInChunks: Set<Chunk> | undefined;
    /** @type {RuntimeSpecMap<ModuleHashInfo> | undefined} */
    hashes: RuntimeSpecMap<ModuleHashInfo> | undefined;
    /** @type {string | number} */
    id: string | number;
    /** @type {RuntimeSpecMap<Set<string>> | undefined} */
    runtimeRequirements: RuntimeSpecMap<Set<string>> | undefined;
    /** @type {RuntimeSpecMap<string>} */
    graphHashes: RuntimeSpecMap<string>;
    /** @type {RuntimeSpecMap<string>} */
    graphHashesWithConnections: RuntimeSpecMap<string>;
}
type Hash = typeof import("./util/Hash");
/**
 * <T>
 */
type SetToArrayFunction<T> = (set: SortableSet<T>) => T[];
/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */
/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */
/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */
/**
 * @typedef {Object} ChunkSizeOptions
 * @property {number=} chunkOverhead constant overhead for a chunk
 * @property {number=} entryChunkMultiplicator multiplicator for initial chunks
 */
declare class ModuleHashInfo {
    constructor(hash: any, renderedHash: any);
    hash: any;
    renderedHash: any;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ChunkGroup.d.ts
export = ChunkGroup;
declare class ChunkGroup {
    /**
     * Creates an instance of ChunkGroup.
     * @param {string|ChunkGroupOptions=} options chunk group options passed to chunkGroup
     */
    constructor(options?: (string | ChunkGroupOptions) | undefined);
    /** @type {number} */
    groupDebugId: number;
    options: ChunkGroupOptions;
    /** @type {SortableSet<ChunkGroup>} */
    _children: SortableSet<ChunkGroup>;
    /** @type {SortableSet<ChunkGroup>} */
    _parents: SortableSet<ChunkGroup>;
    /** @type {SortableSet<ChunkGroup>} */
    _asyncEntrypoints: SortableSet<ChunkGroup>;
    _blocks: SortableSet<any>;
    /** @type {Chunk[]} */
    chunks: Chunk[];
    /** @type {OriginRecord[]} */
    origins: OriginRecord[];
    /** Indices in top-down order */
    /** @private @type {Map<Module, number>} */
    private _modulePreOrderIndices;
    /** Indices in bottom-up order */
    /** @private @type {Map<Module, number>} */
    private _modulePostOrderIndices;
    /** @type {number | undefined} */
    index: number | undefined;
    /**
     * when a new chunk is added to a chunkGroup, addingOptions will occur.
     * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions
     * @returns {void}
     */
    addOptions(options: ChunkGroupOptions): void;
    /**
     * sets a new name for current ChunkGroup
     * @param {string | undefined} value the new name for ChunkGroup
     * @returns {void}
     */
    set name(arg: string);
    /**
     * returns the name of current ChunkGroup
     * @returns {string | undefined} returns the ChunkGroup name
     */
    get name(): string;
    /**
     * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's
     * @returns {string} a unique concatenation of chunk debugId's
     */
    get debugId(): string;
    /**
     * get a unique id for ChunkGroup, made up of its member Chunk id's
     * @returns {string} a unique concatenation of chunk ids
     */
    get id(): string;
    /**
     * Performs an unshift of a specific chunk
     * @param {Chunk} chunk chunk being unshifted
     * @returns {boolean} returns true if attempted chunk shift is accepted
     */
    unshiftChunk(chunk: Chunk): boolean;
    /**
     * inserts a chunk before another existing chunk in group
     * @param {Chunk} chunk Chunk being inserted
     * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point
     * @returns {boolean} return true if insertion was successful
     */
    insertChunk(chunk: Chunk, before: Chunk): boolean;
    /**
     * add a chunk into ChunkGroup. Is pushed on or prepended
     * @param {Chunk} chunk chunk being pushed into ChunkGroupS
     * @returns {boolean} returns true if chunk addition was successful.
     */
    pushChunk(chunk: Chunk): boolean;
    /**
     * @param {Chunk} oldChunk chunk to be replaced
     * @param {Chunk} newChunk New chunk that will be replaced with
     * @returns {boolean} returns true if the replacement was successful
     */
    replaceChunk(oldChunk: Chunk, newChunk: Chunk): boolean;
    /**
     * @param {Chunk} chunk chunk to remove
     * @returns {boolean} returns true if chunk was removed
     */
    removeChunk(chunk: Chunk): boolean;
    /**
     * @returns {boolean} true, when this chunk group will be loaded on initial page load
     */
    isInitial(): boolean;
    /**
     * @param {ChunkGroup} group chunk group to add
     * @returns {boolean} returns true if chunk group was added
     */
    addChild(group: ChunkGroup): boolean;
    /**
     * @returns {ChunkGroup[]} returns the children of this group
     */
    getChildren(): ChunkGroup[];
    getNumberOfChildren(): number;
    get childrenIterable(): SortableSet<ChunkGroup>;
    /**
     * @param {ChunkGroup} group the chunk group to remove
     * @returns {boolean} returns true if the chunk group was removed
     */
    removeChild(group: ChunkGroup): boolean;
    /**
     * @param {ChunkGroup} parentChunk the parent group to be added into
     * @returns {boolean} returns true if this chunk group was added to the parent group
     */
    addParent(parentChunk: ChunkGroup): boolean;
    /**
     * @returns {ChunkGroup[]} returns the parents of this group
     */
    getParents(): ChunkGroup[];
    getNumberOfParents(): number;
    /**
     * @param {ChunkGroup} parent the parent group
     * @returns {boolean} returns true if the parent group contains this group
     */
    hasParent(parent: ChunkGroup): boolean;
    get parentsIterable(): SortableSet<ChunkGroup>;
    /**
     * @param {ChunkGroup} chunkGroup the parent group
     * @returns {boolean} returns true if this group has been removed from the parent
     */
    removeParent(chunkGroup: ChunkGroup): boolean;
    /**
     * @param {Entrypoint} entrypoint entrypoint to add
     * @returns {boolean} returns true if entrypoint was added
     */
    addAsyncEntrypoint(entrypoint: Entrypoint): boolean;
    get asyncEntrypointsIterable(): SortableSet<ChunkGroup>;
    /**
     * @returns {Array<AsyncDependenciesBlock>} an array containing the blocks
     */
    getBlocks(): Array<AsyncDependenciesBlock>;
    getNumberOfBlocks(): number;
    /**
     * @param {AsyncDependenciesBlock} block block
     * @returns {boolean} true, if block exists
     */
    hasBlock(block: AsyncDependenciesBlock): boolean;
    /**
     * @returns {Iterable<AsyncDependenciesBlock>} blocks
     */
    get blocksIterable(): Iterable<import("webpack/lib/AsyncDependenciesBlock")>;
    /**
     * @param {AsyncDependenciesBlock} block a block
     * @returns {boolean} false, if block was already added
     */
    addBlock(block: AsyncDependenciesBlock): boolean;
    /**
     * @param {Module} module origin module
     * @param {DependencyLocation} loc location of the reference in the origin module
     * @param {string} request request name of the reference
     * @returns {void}
     */
    addOrigin(module: Module, loc: DependencyLocation, request: string): void;
    /**
     * @returns {string[]} the files contained this chunk group
     */
    getFiles(): string[];
    /**
     * @returns {void}
     */
    remove(): void;
    sortItems(): void;
    /**
     * Sorting predicate which allows current ChunkGroup to be compared against another.
     * Sorting values are based off of number of chunks in ChunkGroup.
     *
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @param {ChunkGroup} otherGroup the chunkGroup to compare this against
     * @returns {-1|0|1} sort position for comparison
     */
    compareTo(chunkGraph: ChunkGraph, otherGroup: ChunkGroup): -1 | 0 | 1;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @returns {Record<string, ChunkGroup[]>} mapping from children type to ordered list of ChunkGroups
     */
    getChildrenByOrders(moduleGraph: ModuleGraph, chunkGraph: ChunkGraph): Record<string, ChunkGroup[]>;
    /**
     * Sets the top-down index of a module in this ChunkGroup
     * @param {Module} module module for which the index should be set
     * @param {number} index the index of the module
     * @returns {void}
     */
    setModulePreOrderIndex(module: Module, index: number): void;
    /**
     * Gets the top-down index of a module in this ChunkGroup
     * @param {Module} module the module
     * @returns {number | undefined} index
     */
    getModulePreOrderIndex(module: Module): number | undefined;
    /**
     * Sets the bottom-up index of a module in this ChunkGroup
     * @param {Module} module module for which the index should be set
     * @param {number} index the index of the module
     * @returns {void}
     */
    setModulePostOrderIndex(module: Module, index: number): void;
    /**
     * Gets the bottom-up index of a module in this ChunkGroup
     * @param {Module} module the module
     * @returns {number | undefined} index
     */
    getModulePostOrderIndex(module: Module): number | undefined;
    checkConstraints(): void;
    getModuleIndex: (module: Module) => number | undefined;
    getModuleIndex2: (module: Module) => number | undefined;
}
declare namespace ChunkGroup {
    export { AsyncDependenciesBlock, Chunk, ChunkGraph, DependencyLocation, Entrypoint, Module, ModuleGraph, HasId, OriginRecord, RawChunkGroupOptions, ChunkGroupOptions };
}
type ChunkGroupOptions = RawChunkGroupOptions & {
    name?: string;
};
import SortableSet = require("webpack/lib/util/SortableSet");
type Chunk = import("./Chunk");
type OriginRecord = {
    module: Module;
    loc: DependencyLocation;
    request: string;
};
type Entrypoint = import("./Entrypoint");
type AsyncDependenciesBlock = import("./AsyncDependenciesBlock");
type Module = import("./Module");
type DependencyLocation = import("./Dependency").DependencyLocation;
type ChunkGraph = import("./ChunkGraph");
type ModuleGraph = import("./ModuleGraph");
type HasId = {
    id: number;
};
type RawChunkGroupOptions = {
    preloadOrder?: number | undefined;
    prefetchOrder?: number | undefined;
    fetchPriority?: ("low" | "high" | "auto") | undefined;
};
declare namespace module {
    namespace exports {
        export { AsyncDependenciesBlock, Chunk, ChunkGraph, DependencyLocation, Entrypoint, Module, ModuleGraph, HasId, OriginRecord, RawChunkGroupOptions, ChunkGroupOptions };
    }
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ChunkRenderError.d.ts
export = ChunkRenderError;
/** @typedef {import("./Chunk")} Chunk */
declare class ChunkRenderError extends WebpackError {
    /**
     * Create a new ChunkRenderError
     * @param {Chunk} chunk A chunk
     * @param {string} file Related file
     * @param {Error} error Original error
     */
    constructor(chunk: Chunk, file: string, error: Error);
    error: Error;
}
declare namespace ChunkRenderError {
    export { Chunk };
}
import WebpackError = require("webpack/lib/WebpackError");
type Chunk = import("./Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ChunkTemplate.d.ts
export = ChunkTemplate;
declare class ChunkTemplate {
    /**
     * @param {OutputOptions} outputOptions output options
     * @param {Compilation} compilation the compilation
     */
    constructor(outputOptions: any, compilation: Compilation);
    _outputOptions: any;
    hooks: Readonly<{
        renderManifest: {
            tap: (options: any, fn: any) => void;
        };
        modules: {
            tap: (options: any, fn: any) => void;
        };
        render: {
            tap: (options: any, fn: any) => void;
        };
        renderWithEntry: {
            tap: (options: any, fn: any) => void;
        };
        hash: {
            tap: (options: any, fn: any) => void;
        };
        hashForChunk: {
            tap: (options: any, fn: any) => void;
        };
    }>;
    get outputOptions(): any;
}
declare namespace ChunkTemplate {
    export { OutputOptions, Compilation };
}
type Compilation = import("./Compilation");
type OutputOptions = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/CleanPlugin.d.ts
export = CleanPlugin;
declare class CleanPlugin {
    /**
     * @param {Compilation} compilation the compilation
     * @returns {CleanPluginCompilationHooks} the attached hooks
     */
    static getCompilationHooks(compilation: Compilation): CleanPluginCompilationHooks;
    /** @param {CleanOptions} options options */
    constructor(options?: any);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace CleanPlugin {
    export { CleanOptions, Compiler, Logger, OutputFileSystem, StatsCallback, IgnoreItem, Assets, AddToIgnoreCallback, CleanPluginCompilationHooks };
}
type Compiler = import("./Compiler");
import Compilation = require("webpack/lib/Compilation");
type CleanPluginCompilationHooks = {
    /**
     * when returning true the file/directory will be kept during cleaning, returning false will clean it and ignore the following plugins and config
     */
    keep: SyncBailHook<[string], boolean>;
};
type CleanOptions = any;
type Logger = import("./logging/Logger").Logger;
type OutputFileSystem = import("./util/fs").OutputFileSystem;
type StatsCallback = import("./util/fs").StatsCallback;
type IgnoreItem = ((arg0: string) => boolean) | RegExp;
type Assets = Map<string, number>;
type AddToIgnoreCallback = (arg0: IgnoreItem) => void;
import { SyncBailHook } from "tapable";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/CodeGenerationError.d.ts
export = CodeGenerationError;
/** @typedef {import("./Module")} Module */
declare class CodeGenerationError extends WebpackError {
    /**
     * Create a new CodeGenerationError
     * @param {Module} module related module
     * @param {Error} error Original error
     */
    constructor(module: Module, error: Error);
    error: Error;
}
declare namespace CodeGenerationError {
    export { Module };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("./Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/CodeGenerationResults.d.ts
export = CodeGenerationResults;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("./Module")} Module */
/** @typedef {import("./Module").CodeGenerationResult} CodeGenerationResult */
/** @typedef {typeof import("./util/Hash")} Hash */
/** @typedef {import("./util/runtime").RuntimeSpec} RuntimeSpec */
declare class CodeGenerationResults {
    /**
     * @param {string | Hash} hashFunction the hash function to use
     */
    constructor(hashFunction?: string | Hash);
    /** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>} */
    map: Map<Module, RuntimeSpecMap<CodeGenerationResult>>;
    _hashFunction: string | typeof import("webpack/lib/util/Hash");
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime runtime(s)
     * @returns {CodeGenerationResult} the CodeGenerationResult
     */
    get(module: Module, runtime: RuntimeSpec): CodeGenerationResult;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime runtime(s)
     * @returns {boolean} true, when we have data for this
     */
    has(module: Module, runtime: RuntimeSpec): boolean;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime runtime(s)
     * @param {string} sourceType the source type
     * @returns {Source} a source
     */
    getSource(module: Module, runtime: RuntimeSpec, sourceType: string): Source;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime runtime(s)
     * @returns {ReadonlySet<string>} runtime requirements
     */
    getRuntimeRequirements(module: Module, runtime: RuntimeSpec): ReadonlySet<string>;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime runtime(s)
     * @param {string} key data key
     * @returns {any} data generated by code generation
     */
    getData(module: Module, runtime: RuntimeSpec, key: string): any;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime runtime(s)
     * @returns {any} hash of the code generation
     */
    getHash(module: Module, runtime: RuntimeSpec): any;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime runtime(s)
     * @param {CodeGenerationResult} result result from module
     * @returns {void}
     */
    add(module: Module, runtime: RuntimeSpec, result: CodeGenerationResult): void;
}
declare namespace CodeGenerationResults {
    export { Source, Module, CodeGenerationResult, Hash, RuntimeSpec };
}
type Module = import("./Module");
import { RuntimeSpecMap } from "webpack/lib/util/runtime";
type CodeGenerationResult = import("./Module").CodeGenerationResult;
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
type Source = import("webpack-sources").Source;
type Hash = typeof import("./util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/CommentCompilationWarning.d.ts
export = CommentCompilationWarning;
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
declare class CommentCompilationWarning extends WebpackError {
    /**
     *
     * @param {string} message warning message
     * @param {DependencyLocation} loc affected lines of code
     */
    constructor(message: string, loc: DependencyLocation);
}
declare namespace CommentCompilationWarning {
    export { DependencyLocation };
}
import WebpackError = require("webpack/lib/WebpackError");
type DependencyLocation = import("./Dependency").DependencyLocation;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/CompatibilityPlugin.d.ts
export = CompatibilityPlugin;
declare class CompatibilityPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace CompatibilityPlugin {
    export { CallExpression, Compiler, DependencyLocation, JavascriptParser, Range };
}
type Compiler = import("./Compiler");
type CallExpression = import("estree").CallExpression;
type DependencyLocation = import("./Dependency").DependencyLocation;
type JavascriptParser = import("./javascript/JavascriptParser");
type Range = import("./javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Compilation.d.ts
export = Compilation;
declare class Compilation {
    /**
     * Creates an instance of Compilation.
     * @param {Compiler} compiler the compiler which created the compilation
     * @param {CompilationParams} params the compilation parameters
     */
    constructor(compiler: Compiler, params: CompilationParams);
    _backCompat: boolean;
    hooks: Readonly<{
        /** @type {SyncHook<[Module]>} */
        buildModule: SyncHook<[Module]>;
        /** @type {SyncHook<[Module]>} */
        rebuildModule: SyncHook<[Module]>;
        /** @type {SyncHook<[Module, WebpackError]>} */
        failedModule: SyncHook<[Module, WebpackError]>;
        /** @type {SyncHook<[Module]>} */
        succeedModule: SyncHook<[Module]>;
        /** @type {SyncHook<[Module]>} */
        stillValidModule: SyncHook<[Module]>;
        /** @type {SyncHook<[Dependency, EntryOptions]>} */
        addEntry: SyncHook<[Dependency, EntryOptions]>;
        /** @type {SyncHook<[Dependency, EntryOptions, Error]>} */
        failedEntry: SyncHook<[Dependency, EntryOptions, Error]>;
        /** @type {SyncHook<[Dependency, EntryOptions, Module]>} */
        succeedEntry: SyncHook<[Dependency, EntryOptions, Module]>;
        /** @type {SyncWaterfallHook<[(string[] | ReferencedExport)[], Dependency, RuntimeSpec]>} */
        dependencyReferencedExports: SyncWaterfallHook<[(string[] | ReferencedExport)[], Dependency, RuntimeSpec]>;
        /** @type {SyncHook<[ExecuteModuleArgument, ExecuteModuleContext]>} */
        executeModule: SyncHook<[ExecuteModuleArgument, ExecuteModuleContext]>;
        /** @type {AsyncParallelHook<[ExecuteModuleArgument, ExecuteModuleContext]>} */
        prepareModuleExecution: AsyncParallelHook<[ExecuteModuleArgument, ExecuteModuleContext]>;
        /** @type {AsyncSeriesHook<[Iterable<Module>]>} */
        finishModules: AsyncSeriesHook<[Iterable<Module>]>;
        /** @type {AsyncSeriesHook<[Module]>} */
        finishRebuildingModule: AsyncSeriesHook<[Module]>;
        /** @type {SyncHook<[]>} */
        unseal: SyncHook<[]>;
        /** @type {SyncHook<[]>} */
        seal: SyncHook<[]>;
        /** @type {SyncHook<[]>} */
        beforeChunks: SyncHook<[]>;
        /**
         * The `afterChunks` hook is called directly after the chunks and module graph have
         * been created and before the chunks and modules have been optimized. This hook is useful to
         * inspect, analyze, and/or modify the chunk graph.
         * @type {SyncHook<[Iterable<Chunk>]>}
         */
        afterChunks: SyncHook<[Iterable<Chunk>]>;
        /** @type {SyncBailHook<[Iterable<Module>]>} */
        optimizeDependencies: SyncBailHook<[Iterable<Module>], any, import("tapable").UnsetAdditionalOptions>;
        /** @type {SyncHook<[Iterable<Module>]>} */
        afterOptimizeDependencies: SyncHook<[Iterable<Module>]>;
        /** @type {SyncHook<[]>} */
        optimize: SyncHook<[]>;
        /** @type {SyncBailHook<[Iterable<Module>]>} */
        optimizeModules: SyncBailHook<[Iterable<Module>], any, import("tapable").UnsetAdditionalOptions>;
        /** @type {SyncHook<[Iterable<Module>]>} */
        afterOptimizeModules: SyncHook<[Iterable<Module>]>;
        /** @type {SyncBailHook<[Iterable<Chunk>, ChunkGroup[]]>} */
        optimizeChunks: SyncBailHook<[Iterable<Chunk>, ChunkGroup[]], any, import("tapable").UnsetAdditionalOptions>;
        /** @type {SyncHook<[Iterable<Chunk>, ChunkGroup[]]>} */
        afterOptimizeChunks: SyncHook<[Iterable<Chunk>, ChunkGroup[]]>;
        /** @type {AsyncSeriesHook<[Iterable<Chunk>, Iterable<Module>]>} */
        optimizeTree: AsyncSeriesHook<[Iterable<Chunk>, Iterable<Module>]>;
        /** @type {SyncHook<[Iterable<Chunk>, Iterable<Module>]>} */
        afterOptimizeTree: SyncHook<[Iterable<Chunk>, Iterable<Module>]>;
        /** @type {AsyncSeriesBailHook<[Iterable<Chunk>, Iterable<Module>]>} */
        optimizeChunkModules: AsyncSeriesBailHook<[Iterable<Chunk>, Iterable<Module>], any, import("tapable").UnsetAdditionalOptions>;
        /** @type {SyncHook<[Iterable<Chunk>, Iterable<Module>]>} */
        afterOptimizeChunkModules: SyncHook<[Iterable<Chunk>, Iterable<Module>]>;
        /** @type {SyncBailHook<[], boolean | undefined>} */
        shouldRecord: SyncBailHook<[], boolean | undefined>;
        /** @type {SyncHook<[Chunk, Set<string>, RuntimeRequirementsContext]>} */
        additionalChunkRuntimeRequirements: SyncHook<[Chunk, Set<string>, RuntimeRequirementsContext]>;
        /** @type {HookMap<SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext]>>} */
        runtimeRequirementInChunk: HookMap<SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {SyncHook<[Module, Set<string>, RuntimeRequirementsContext]>} */
        additionalModuleRuntimeRequirements: SyncHook<[Module, Set<string>, RuntimeRequirementsContext]>;
        /** @type {HookMap<SyncBailHook<[Module, Set<string>, RuntimeRequirementsContext]>>} */
        runtimeRequirementInModule: HookMap<SyncBailHook<[Module, Set<string>, RuntimeRequirementsContext], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {SyncHook<[Chunk, Set<string>, RuntimeRequirementsContext]>} */
        additionalTreeRuntimeRequirements: SyncHook<[Chunk, Set<string>, RuntimeRequirementsContext]>;
        /** @type {HookMap<SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext]>>} */
        runtimeRequirementInTree: HookMap<SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {SyncHook<[RuntimeModule, Chunk]>} */
        runtimeModule: SyncHook<[RuntimeModule, Chunk]>;
        /** @type {SyncHook<[Iterable<Module>, any]>} */
        reviveModules: SyncHook<[Iterable<Module>, any]>;
        /** @type {SyncHook<[Iterable<Module>]>} */
        beforeModuleIds: SyncHook<[Iterable<Module>]>;
        /** @type {SyncHook<[Iterable<Module>]>} */
        moduleIds: SyncHook<[Iterable<Module>]>;
        /** @type {SyncHook<[Iterable<Module>]>} */
        optimizeModuleIds: SyncHook<[Iterable<Module>]>;
        /** @type {SyncHook<[Iterable<Module>]>} */
        afterOptimizeModuleIds: SyncHook<[Iterable<Module>]>;
        /** @type {SyncHook<[Iterable<Chunk>, any]>} */
        reviveChunks: SyncHook<[Iterable<Chunk>, any]>;
        /** @type {SyncHook<[Iterable<Chunk>]>} */
        beforeChunkIds: SyncHook<[Iterable<Chunk>]>;
        /** @type {SyncHook<[Iterable<Chunk>]>} */
        chunkIds: SyncHook<[Iterable<Chunk>]>;
        /** @type {SyncHook<[Iterable<Chunk>]>} */
        optimizeChunkIds: SyncHook<[Iterable<Chunk>]>;
        /** @type {SyncHook<[Iterable<Chunk>]>} */
        afterOptimizeChunkIds: SyncHook<[Iterable<Chunk>]>;
        /** @type {SyncHook<[Iterable<Module>, any]>} */
        recordModules: SyncHook<[Iterable<Module>, any]>;
        /** @type {SyncHook<[Iterable<Chunk>, any]>} */
        recordChunks: SyncHook<[Iterable<Chunk>, any]>;
        /** @type {SyncHook<[Iterable<Module>]>} */
        optimizeCodeGeneration: SyncHook<[Iterable<Module>]>;
        /** @type {SyncHook<[]>} */
        beforeModuleHash: SyncHook<[]>;
        /** @type {SyncHook<[]>} */
        afterModuleHash: SyncHook<[]>;
        /** @type {SyncHook<[]>} */
        beforeCodeGeneration: SyncHook<[]>;
        /** @type {SyncHook<[]>} */
        afterCodeGeneration: SyncHook<[]>;
        /** @type {SyncHook<[]>} */
        beforeRuntimeRequirements: SyncHook<[]>;
        /** @type {SyncHook<[]>} */
        afterRuntimeRequirements: SyncHook<[]>;
        /** @type {SyncHook<[]>} */
        beforeHash: SyncHook<[]>;
        /** @type {SyncHook<[Chunk]>} */
        contentHash: SyncHook<[Chunk]>;
        /** @type {SyncHook<[]>} */
        afterHash: SyncHook<[]>;
        /** @type {SyncHook<[any]>} */
        recordHash: SyncHook<[any]>;
        /** @type {SyncHook<[Compilation, any]>} */
        record: SyncHook<[Compilation, any]>;
        /** @type {SyncHook<[]>} */
        beforeModuleAssets: SyncHook<[]>;
        /** @type {SyncBailHook<[], boolean>} */
        shouldGenerateChunkAssets: SyncBailHook<[], boolean>;
        /** @type {SyncHook<[]>} */
        beforeChunkAssets: SyncHook<[]>;
        /** @deprecated */
        additionalChunkAssets: FakeHook<Pick<AsyncSeriesHook<[Set<Chunk>], import("tapable").UnsetAdditionalOptions>, "name" | "tap" | "tapAsync" | "tapPromise">>;
        /** @deprecated */
        additionalAssets: FakeHook<Pick<AsyncSeriesHook<[], import("tapable").UnsetAdditionalOptions>, "name" | "tap" | "tapAsync" | "tapPromise">>;
        /** @deprecated */
        optimizeChunkAssets: FakeHook<Pick<AsyncSeriesHook<[Set<Chunk>], import("tapable").UnsetAdditionalOptions>, "name" | "tap" | "tapAsync" | "tapPromise">>;
        /** @deprecated */
        afterOptimizeChunkAssets: FakeHook<Pick<AsyncSeriesHook<[Set<Chunk>], import("tapable").UnsetAdditionalOptions>, "name" | "tap" | "tapAsync" | "tapPromise">>;
        /** @deprecated */
        optimizeAssets: AsyncSeriesHook<[CompilationAssets], {
            additionalAssets?: true | Function;
        }>;
        /** @deprecated */
        afterOptimizeAssets: SyncHook<[CompilationAssets], void, import("tapable").UnsetAdditionalOptions>;
        processAssets: AsyncSeriesHook<[CompilationAssets], {
            additionalAssets?: true | Function;
        }>;
        afterProcessAssets: SyncHook<[CompilationAssets], void, import("tapable").UnsetAdditionalOptions>;
        /** @type {AsyncSeriesHook<[CompilationAssets]>} */
        processAdditionalAssets: AsyncSeriesHook<[CompilationAssets]>;
        /** @type {SyncBailHook<[], boolean>} */
        needAdditionalSeal: SyncBailHook<[], boolean>;
        /** @type {AsyncSeriesHook<[]>} */
        afterSeal: AsyncSeriesHook<[]>;
        /** @type {SyncWaterfallHook<[RenderManifestEntry[], RenderManifestOptions]>} */
        renderManifest: SyncWaterfallHook<[RenderManifestEntry[], RenderManifestOptions]>;
        /** @type {SyncHook<[Hash]>} */
        fullHash: SyncHook<[Hash]>;
        /** @type {SyncHook<[Chunk, Hash, ChunkHashContext]>} */
        chunkHash: SyncHook<[Chunk, Hash, ChunkHashContext]>;
        /** @type {SyncHook<[Module, string]>} */
        moduleAsset: SyncHook<[Module, string]>;
        /** @type {SyncHook<[Chunk, string]>} */
        chunkAsset: SyncHook<[Chunk, string]>;
        /** @type {SyncWaterfallHook<[string, object, AssetInfo]>} */
        assetPath: SyncWaterfallHook<[string, object, AssetInfo]>;
        /** @type {SyncBailHook<[], boolean>} */
        needAdditionalPass: SyncBailHook<[], boolean>;
        /** @type {SyncHook<[Compiler, string, number]>} */
        childCompiler: SyncHook<[Compiler, string, number]>;
        /** @type {SyncBailHook<[string, LogEntry], true>} */
        log: SyncBailHook<[string, LogEntry], true>;
        /** @type {SyncWaterfallHook<[WebpackError[]]>} */
        processWarnings: SyncWaterfallHook<[WebpackError[]]>;
        /** @type {SyncWaterfallHook<[WebpackError[]]>} */
        processErrors: SyncWaterfallHook<[WebpackError[]]>;
        /** @type {HookMap<SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>>} */
        statsPreset: HookMap<SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>>;
        /** @type {SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>} */
        statsNormalize: SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>;
        /** @type {SyncHook<[StatsFactory, NormalizedStatsOptions]>} */
        statsFactory: SyncHook<[StatsFactory, NormalizedStatsOptions]>;
        /** @type {SyncHook<[StatsPrinter, NormalizedStatsOptions]>} */
        statsPrinter: SyncHook<[StatsPrinter, NormalizedStatsOptions]>;
        readonly normalModuleLoader: SyncHook<[any, import("webpack/lib/NormalModule")], void, import("tapable").UnsetAdditionalOptions>;
    }>;
    /** @type {string=} */
    name: string | undefined;
    startTime: any;
    endTime: any;
    /** @type {Compiler} */
    compiler: Compiler;
    resolverFactory: import("webpack/lib/ResolverFactory");
    inputFileSystem: import("webpack/lib/util/fs").InputFileSystem;
    fileSystemInfo: FileSystemInfo;
    /** @type {Map<string, string | Set<string>>} */
    valueCacheVersions: Map<string, string | Set<string>>;
    requestShortener: import("webpack/lib/RequestShortener");
    compilerPath: string;
    logger: Logger;
    options: any;
    outputOptions: any;
    /** @type {boolean} */
    bail: boolean;
    /** @type {boolean} */
    profile: boolean;
    params: import("webpack/lib/Compiler").CompilationParams;
    mainTemplate: MainTemplate;
    chunkTemplate: ChunkTemplate;
    runtimeTemplate: RuntimeTemplate;
    /** @type {{javascript: ModuleTemplate}} */
    moduleTemplates: {
        javascript: ModuleTemplate;
    };
    /** @type {Map<Module, WeakTupleMap<any, any>> | undefined} */
    moduleMemCaches: Map<Module, WeakTupleMap<any, any>> | undefined;
    /** @type {Map<Module, WeakTupleMap<any, any>> | undefined} */
    moduleMemCaches2: Map<Module, WeakTupleMap<any, any>> | undefined;
    moduleGraph: ModuleGraph;
    /** @type {ChunkGraph} */
    chunkGraph: ChunkGraph;
    /** @type {CodeGenerationResults} */
    codeGenerationResults: CodeGenerationResults;
    /** @type {AsyncQueue<Module, Module, Module>} */
    processDependenciesQueue: AsyncQueue<Module, Module, Module>;
    /** @type {AsyncQueue<Module, string, Module>} */
    addModuleQueue: AsyncQueue<Module, string, Module>;
    /** @type {AsyncQueue<FactorizeModuleOptions, string, Module | ModuleFactoryResult>} */
    factorizeQueue: AsyncQueue<FactorizeModuleOptions, string, Module | ModuleFactoryResult>;
    /** @type {AsyncQueue<Module, Module, Module>} */
    buildQueue: AsyncQueue<Module, Module, Module>;
    /** @type {AsyncQueue<Module, Module, Module>} */
    rebuildQueue: AsyncQueue<Module, Module, Module>;
    /**
     * Modules in value are building during the build of Module in key.
     * Means value blocking key from finishing.
     * Needed to detect build cycles.
     * @type {WeakMap<Module, Set<Module>>}
     */
    creatingModuleDuringBuild: WeakMap<Module, Set<Module>>;
    /** @type {Map<string, EntryData>} */
    entries: Map<string, EntryData>;
    /** @type {EntryData} */
    globalEntry: EntryData;
    /** @type {Map<string, Entrypoint>} */
    entrypoints: Map<string, Entrypoint>;
    /** @type {Entrypoint[]} */
    asyncEntrypoints: Entrypoint[];
    /** @type {Set<Chunk>} */
    chunks: Set<Chunk>;
    /** @type {ChunkGroup[]} */
    chunkGroups: ChunkGroup[];
    /** @type {Map<string, ChunkGroup>} */
    namedChunkGroups: Map<string, ChunkGroup>;
    /** @type {Map<string, Chunk>} */
    namedChunks: Map<string, Chunk>;
    /** @type {Set<Module>} */
    modules: Set<Module>;
    /** @private @type {Map<string, Module>} */
    private _modules;
    records: any;
    /** @type {string[]} */
    additionalChunkAssets: string[];
    /** @type {CompilationAssets} */
    assets: CompilationAssets;
    /** @type {Map<string, AssetInfo>} */
    assetsInfo: Map<string, AssetInfo>;
    /** @type {Map<string, Map<string, Set<string>>>} */
    _assetsRelatedIn: Map<string, Map<string, Set<string>>>;
    /** @type {WebpackError[]} */
    errors: WebpackError[];
    /** @type {WebpackError[]} */
    warnings: WebpackError[];
    /** @type {Compilation[]} */
    children: Compilation[];
    /** @type {Map<string, LogEntry[]>} */
    logging: Map<string, LogEntry[]>;
    /** @type {Map<DepConstructor, ModuleFactory>} */
    dependencyFactories: Map<DepConstructor, ModuleFactory>;
    /** @type {DependencyTemplates} */
    dependencyTemplates: DependencyTemplates;
    childrenCounters: {};
    /** @type {Set<number|string>} */
    usedChunkIds: Set<number | string>;
    /** @type {Set<number>} */
    usedModuleIds: Set<number>;
    /** @type {boolean} */
    needAdditionalPass: boolean;
    /** @type {Set<Module & { restoreFromUnsafeCache: Function }>} */
    _restoredUnsafeCacheModuleEntries: Set<Module & {
        restoreFromUnsafeCache: Function;
    }>;
    /** @type {Map<string, Module & { restoreFromUnsafeCache: Function }>} */
    _restoredUnsafeCacheEntries: Map<string, Module & {
        restoreFromUnsafeCache: Function;
    }>;
    /** @type {WeakSet<Module>} */
    builtModules: WeakSet<Module>;
    /** @type {WeakSet<Module>} */
    codeGeneratedModules: WeakSet<Module>;
    /** @type {WeakSet<Module>} */
    buildTimeExecutedModules: WeakSet<Module>;
    /** @private @type {Map<Module, Callback[]>} */
    private _rebuildingModules;
    /** @type {Set<string>} */
    emittedAssets: Set<string>;
    /** @type {Set<string>} */
    comparedForEmitAssets: Set<string>;
    /** @type {LazySet<string>} */
    fileDependencies: LazySet<string>;
    /** @type {LazySet<string>} */
    contextDependencies: LazySet<string>;
    /** @type {LazySet<string>} */
    missingDependencies: LazySet<string>;
    /** @type {LazySet<string>} */
    buildDependencies: LazySet<string>;
    compilationDependencies: {
        add: (item: any) => LazySet<string>;
    };
    _modulesCache: import("webpack/lib/CacheFacade");
    _assetsCache: import("webpack/lib/CacheFacade");
    _codeGenerationCache: import("webpack/lib/CacheFacade");
    _unsafeCache: boolean;
    _unsafeCachePredicate: any;
    getStats(): Stats;
    /**
     * @param {StatsOptions | string} optionsOrPreset stats option value
     * @param {CreateStatsOptionsContext} context context
     * @returns {NormalizedStatsOptions} normalized options
     */
    createStatsOptions(optionsOrPreset: StatsOptions | string, context?: CreateStatsOptionsContext): NormalizedStatsOptions;
    createStatsFactory(options: any): StatsFactory;
    createStatsPrinter(options: any): StatsPrinter;
    /**
     * @param {string} name cache name
     * @returns {CacheFacade} the cache facade instance
     */
    getCache(name: string): CacheFacade;
    /**
     * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name
     * @returns {Logger} a logger with that name
     */
    getLogger(name: string | (() => string)): Logger;
    /**
     * @param {Module} module module to be added that was created
     * @param {ModuleCallback} callback returns the module in the compilation,
     * it could be the passed one (if new), or an already existing in the compilation
     * @returns {void}
     */
    addModule(module: Module, callback: ModuleCallback): void;
    /**
     * @param {Module} module module to be added that was created
     * @param {ModuleCallback} callback returns the module in the compilation,
     * it could be the passed one (if new), or an already existing in the compilation
     * @returns {void}
     */
    _addModule(module: Module, callback: ModuleCallback): void;
    /**
     * Fetches a module from a compilation by its identifier
     * @param {Module} module the module provided
     * @returns {Module} the module requested
     */
    getModule(module: Module): Module;
    /**
     * Attempts to search for a module by its identifier
     * @param {string} identifier identifier (usually path) for module
     * @returns {Module|undefined} attempt to search for module and return it, else undefined
     */
    findModule(identifier: string): Module | undefined;
    /**
     * Schedules a build of the module object
     *
     * @param {Module} module module to be built
     * @param {ModuleCallback} callback the callback
     * @returns {void}
     */
    buildModule(module: Module, callback: ModuleCallback): void;
    /**
     * Builds the module object
     *
     * @param {Module} module module to be built
     * @param {ModuleCallback} callback the callback
     * @returns {void}
     */
    _buildModule(module: Module, callback: ModuleCallback): void;
    /**
     * @param {Module} module to be processed for deps
     * @param {ModuleCallback} callback callback to be triggered
     * @returns {void}
     */
    processModuleDependencies(module: Module, callback: ModuleCallback): void;
    /**
     * @param {Module} module to be processed for deps
     * @returns {void}
     */
    processModuleDependenciesNonRecursive(module: Module): void;
    /**
     * @param {Module} module to be processed for deps
     * @param {ModuleCallback} callback callback to be triggered
     * @returns {void}
     */
    _processModuleDependencies(module: Module, callback: ModuleCallback): void;
    _handleNewModuleFromUnsafeCache(originModule: any, dependency: any, module: any, callback: any): void;
    _handleExistingModuleFromUnsafeCache(originModule: any, dependency: any, module: any): void;
    /**
     * @typedef {Object} HandleModuleCreationOptions
     * @property {ModuleFactory} factory
     * @property {Dependency[]} dependencies
     * @property {Module | null} originModule
     * @property {Partial<ModuleFactoryCreateDataContextInfo>=} contextInfo
     * @property {string=} context
     * @property {boolean=} recursive recurse into dependencies of the created module
     * @property {boolean=} connectOrigin connect the resolved module with the origin module
     */
    /**
     * @param {HandleModuleCreationOptions} options options object
     * @param {ModuleCallback} callback callback
     * @returns {void}
     */
    handleModuleCreation({ factory, dependencies, originModule, contextInfo, context, recursive, connectOrigin }: {
        factory: ModuleFactory;
        dependencies: Dependency[];
        originModule: Module | null;
        contextInfo?: Partial<ModuleFactoryCreateDataContextInfo> | undefined;
        context?: string | undefined;
        /**
         * recurse into dependencies of the created module
         */
        recursive?: boolean | undefined;
        /**
         * connect the resolved module with the origin module
         */
        connectOrigin?: boolean | undefined;
    }, callback: ModuleCallback): void;
    _handleModuleBuildAndDependencies(originModule: any, module: any, recursive: any, callback: any): any;
    /**
     * @param {FactorizeModuleOptions} options options object
     * @param {ModuleOrFactoryResultCallback} callback callback
     * @returns {void}
     */
    _factorizeModule({ currentProfile, factory, dependencies, originModule, factoryResult, contextInfo, context }: FactorizeModuleOptions, callback: ModuleOrFactoryResultCallback): void;
    /**
     * @param {string} context context string path
     * @param {Dependency} dependency dependency used to create Module chain
     * @param {ModuleCallback} callback callback for when module chain is complete
     * @returns {void} will throw if dependency instance is not a valid Dependency
     */
    addModuleChain(context: string, dependency: Dependency, callback: ModuleCallback): void;
    /**
     * @param {Object} options options
     * @param {string} options.context context string path
     * @param {Dependency} options.dependency dependency used to create Module chain
     * @param {Partial<ModuleFactoryCreateDataContextInfo>=} options.contextInfo additional context info for the root module
     * @param {ModuleCallback} callback callback for when module chain is complete
     * @returns {void} will throw if dependency instance is not a valid Dependency
     */
    addModuleTree({ context, dependency, contextInfo }: {
        context: string;
        dependency: Dependency;
        contextInfo?: Partial<ModuleFactoryCreateDataContextInfo> | undefined;
    }, callback: ModuleCallback): void;
    /**
     * @param {string} context context path for entry
     * @param {Dependency} entry entry dependency that should be followed
     * @param {string | EntryOptions} optionsOrName options or deprecated name of entry
     * @param {ModuleCallback} callback callback function
     * @returns {void} returns
     */
    addEntry(context: string, entry: Dependency, optionsOrName: string | EntryOptions, callback: ModuleCallback): void;
    /**
     * @param {string} context context path for entry
     * @param {Dependency} dependency dependency that should be followed
     * @param {EntryOptions} options options
     * @param {ModuleCallback} callback callback function
     * @returns {void} returns
     */
    addInclude(context: string, dependency: Dependency, options: EntryOptions, callback: ModuleCallback): void;
    /**
     * @param {string} context context path for entry
     * @param {Dependency} entry entry dependency that should be followed
     * @param {"dependencies" | "includeDependencies"} target type of entry
     * @param {EntryOptions} options options
     * @param {ModuleCallback} callback callback function
     * @returns {void} returns
     */
    _addEntryItem(context: string, entry: Dependency, target: "dependencies" | "includeDependencies", options: EntryOptions, callback: ModuleCallback): void;
    /**
     * @param {Module} module module to be rebuilt
     * @param {ModuleCallback} callback callback when module finishes rebuilding
     * @returns {void}
     */
    rebuildModule(module: Module, callback: ModuleCallback): void;
    /**
     * @param {Module} module module to be rebuilt
     * @param {ModuleCallback} callback callback when module finishes rebuilding
     * @returns {void}
     */
    _rebuildModule(module: Module, callback: ModuleCallback): void;
    _computeAffectedModules(modules: any): void;
    _computeAffectedModulesWithChunkGraph(): void;
    finish(callback: any): void;
    unseal(): void;
    /**
     * @param {Callback} callback signals when the call finishes
     * @returns {void}
     */
    seal(callback: Callback): void;
    /**
     * @param {Module} module module to report from
     * @param {DependenciesBlock[]} blocks blocks to report from
     * @returns {boolean} true, when it has warnings or errors
     */
    reportDependencyErrorsAndWarnings(module: Module, blocks: DependenciesBlock[]): boolean;
    codeGeneration(callback: any): void;
    _runCodeGenerationJobs(jobs: any, callback: any): any;
    /**
     * @param {Module} module module
     * @param {RuntimeSpec} runtime runtime
     * @param {RuntimeSpec[]} runtimes runtimes
     * @param {string} hash hash
     * @param {DependencyTemplates} dependencyTemplates dependencyTemplates
     * @param {ChunkGraph} chunkGraph chunkGraph
     * @param {ModuleGraph} moduleGraph moduleGraph
     * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate
     * @param {WebpackError[]} errors errors
     * @param {CodeGenerationResults} results results
     * @param {function((WebpackError | null)=, boolean=): void} callback callback
     */
    _codeGenerationModule(module: Module, runtime: RuntimeSpec, runtimes: RuntimeSpec[], hash: string, dependencyTemplates: DependencyTemplates, chunkGraph: ChunkGraph, moduleGraph: ModuleGraph, runtimeTemplate: RuntimeTemplate, errors: WebpackError[], results: CodeGenerationResults, callback: (arg0: (WebpackError | null) | undefined, arg1: boolean | undefined) => void): void;
    _getChunkGraphEntries(): Set<Chunk>;
    /**
     * @param {Object} options options
     * @param {ChunkGraph=} options.chunkGraph the chunk graph
     * @param {Iterable<Module>=} options.modules modules
     * @param {Iterable<Chunk>=} options.chunks chunks
     * @param {CodeGenerationResults=} options.codeGenerationResults codeGenerationResults
     * @param {Iterable<Chunk>=} options.chunkGraphEntries chunkGraphEntries
     * @returns {void}
     */
    processRuntimeRequirements({ chunkGraph, modules, chunks, codeGenerationResults, chunkGraphEntries }?: {
        chunkGraph?: ChunkGraph | undefined;
        modules?: Iterable<Module> | undefined;
        chunks?: Iterable<Chunk> | undefined;
        codeGenerationResults?: CodeGenerationResults | undefined;
        chunkGraphEntries?: Iterable<Chunk> | undefined;
    }): void;
    /**
     * @param {Chunk} chunk target chunk
     * @param {RuntimeModule} module runtime module
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @returns {void}
     */
    addRuntimeModule(chunk: Chunk, module: RuntimeModule, chunkGraph?: ChunkGraph): void;
    /**
     * If `module` is passed, `loc` and `request` must also be passed.
     * @param {string | ChunkGroupOptions} groupOptions options for the chunk group
     * @param {Module=} module the module the references the chunk group
     * @param {DependencyLocation=} loc the location from with the chunk group is referenced (inside of module)
     * @param {string=} request the request from which the the chunk group is referenced
     * @returns {ChunkGroup} the new or existing chunk group
     */
    addChunkInGroup(groupOptions: string | ChunkGroupOptions, module?: Module | undefined, loc?: DependencyLocation | undefined, request?: string | undefined): ChunkGroup;
    /**
     * @param {EntryOptions} options options for the entrypoint
     * @param {Module} module the module the references the chunk group
     * @param {DependencyLocation} loc the location from with the chunk group is referenced (inside of module)
     * @param {string} request the request from which the the chunk group is referenced
     * @returns {Entrypoint} the new or existing entrypoint
     */
    addAsyncEntrypoint(options: EntryOptions, module: Module, loc: DependencyLocation, request: string): Entrypoint;
    /**
     * This method first looks to see if a name is provided for a new chunk,
     * and first looks to see if any named chunks already exist and reuse that chunk instead.
     *
     * @param {string=} name optional chunk name to be provided
     * @returns {Chunk} create a chunk (invoked during seal event)
     */
    addChunk(name?: string | undefined): Chunk;
    /**
     * @deprecated
     * @param {Module} module module to assign depth
     * @returns {void}
     */
    assignDepth(module: Module): void;
    /**
     * @param {Set<Module>} modules module to assign depth
     * @returns {void}
     */
    assignDepths(modules: Set<Module>): void;
    /**
     * @param {Dependency} dependency the dependency
     * @param {RuntimeSpec} runtime the runtime
     * @returns {(string[] | ReferencedExport)[]} referenced exports
     */
    getDependencyReferencedExports(dependency: Dependency, runtime: RuntimeSpec): (string[] | ReferencedExport)[];
    /**
     *
     * @param {Module} module module relationship for removal
     * @param {DependenciesBlockLike} block //TODO: good description
     * @returns {void}
     */
    removeReasonsOfDependencyBlock(module: Module, block: DependenciesBlockLike): void;
    /**
     * @param {Module} module module to patch tie
     * @param {Chunk} chunk chunk to patch tie
     * @returns {void}
     */
    patchChunksAfterReasonRemoval(module: Module, chunk: Chunk): void;
    /**
     *
     * @param {DependenciesBlock} block block tie for Chunk
     * @param {Chunk} chunk chunk to remove from dep
     * @returns {void}
     */
    removeChunkFromDependencies(block: DependenciesBlock, chunk: Chunk): void;
    assignRuntimeIds(): void;
    sortItemsWithChunkIds(): void;
    summarizeDependencies(): void;
    createModuleHashes(): void;
    _createModuleHash(module: any, chunkGraph: any, runtime: any, hashFunction: any, runtimeTemplate: any, hashDigest: any, hashDigestLength: any, errors: any): string;
    createHash(): {
        module: Module;
        hash: string;
        runtime: RuntimeSpec;
        runtimes: RuntimeSpec[];
    }[];
    fullHash: string;
    hash: string;
    /**
     * @param {string} file file name
     * @param {Source} source asset source
     * @param {AssetInfo} assetInfo extra asset information
     * @returns {void}
     */
    emitAsset(file: string, source: Source, assetInfo?: AssetInfo): void;
    _setAssetInfo(file: any, newInfo: any, oldInfo?: AssetInfo): void;
    /**
     * @param {string} file file name
     * @param {Source | function(Source): Source} newSourceOrFunction new asset source or function converting old to new
     * @param {AssetInfo | function(AssetInfo | undefined): AssetInfo} assetInfoUpdateOrFunction new asset info or function converting old to new
     */
    updateAsset(file: string, newSourceOrFunction: Source | ((arg0: Source) => Source), assetInfoUpdateOrFunction?: AssetInfo | ((arg0: AssetInfo | undefined) => AssetInfo)): void;
    renameAsset(file: any, newFile: any): void;
    /**
     * @param {string} file file name
     */
    deleteAsset(file: string): void;
    getAssets(): Readonly<Asset>[];
    /**
     * @param {string} name the name of the asset
     * @returns {Readonly<Asset> | undefined} the asset or undefined when not found
     */
    getAsset(name: string): Readonly<Asset> | undefined;
    clearAssets(): void;
    createModuleAssets(): void;
    /**
     * @param {RenderManifestOptions} options options object
     * @returns {RenderManifestEntry[]} manifest entries
     */
    getRenderManifest(options: RenderManifestOptions): RenderManifestEntry[];
    /**
     * @param {Callback} callback signals when the call finishes
     * @returns {void}
     */
    createChunkAssets(callback: Callback): void;
    /**
     * @param {string | function(PathData, AssetInfo=): string} filename used to get asset path with hash
     * @param {PathData} data context data
     * @returns {string} interpolated path
     */
    getPath(filename: string | ((arg0: PathData, arg1: AssetInfo | undefined) => string), data?: PathData): string;
    /**
     * @param {string | function(PathData, AssetInfo=): string} filename used to get asset path with hash
     * @param {PathData} data context data
     * @returns {{ path: string, info: AssetInfo }} interpolated path and asset info
     */
    getPathWithInfo(filename: string | ((arg0: PathData, arg1: AssetInfo | undefined) => string), data?: PathData): {
        path: string;
        info: AssetInfo;
    };
    /**
     * @param {string | function(PathData, AssetInfo=): string} filename used to get asset path with hash
     * @param {PathData} data context data
     * @returns {string} interpolated path
     */
    getAssetPath(filename: string | ((arg0: PathData, arg1: AssetInfo | undefined) => string), data: PathData): string;
    /**
     * @param {string | function(PathData, AssetInfo=): string} filename used to get asset path with hash
     * @param {PathData} data context data
     * @returns {{ path: string, info: AssetInfo }} interpolated path and asset info
     */
    getAssetPathWithInfo(filename: string | ((arg0: PathData, arg1: AssetInfo | undefined) => string), data: PathData): {
        path: string;
        info: AssetInfo;
    };
    getWarnings(): WebpackError[];
    getErrors(): WebpackError[];
    /**
     * This function allows you to run another instance of webpack inside of webpack however as
     * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins
     * from parent (or top level compiler) and creates a child Compilation
     *
     * @param {string} name name of the child compiler
     * @param {OutputOptions=} outputOptions // Need to convert config schema to types for this
     * @param {Array<WebpackPluginInstance | WebpackPluginFunction>=} plugins webpack plugins that will be applied
     * @returns {Compiler} creates a child Compiler instance
     */
    createChildCompiler(name: string, outputOptions?: any, plugins?: Array<WebpackPluginInstance | WebpackPluginFunction> | undefined): Compiler;
    /**
     * @param {Module} module the module
     * @param {ExecuteModuleOptions} options options
     * @param {ExecuteModuleCallback} callback callback
     */
    executeModule(module: Module, options: ExecuteModuleOptions, callback: ExecuteModuleCallback): void;
    checkConstraints(): void;
    /**
     * @typedef {Object} FactorizeModuleOptions
     * @property {ModuleProfile} currentProfile
     * @property {ModuleFactory} factory
     * @property {Dependency[]} dependencies
     * @property {boolean=} factoryResult return full ModuleFactoryResult instead of only module
     * @property {Module | null} originModule
     * @property {Partial<ModuleFactoryCreateDataContextInfo>=} contextInfo
     * @property {string=} context
     */
    /**
     * @param {FactorizeModuleOptions} options options object
     * @param {ModuleCallback | ModuleFactoryResultCallback} callback callback
     * @returns {void}
     */
    factorizeModule: {
        (options: FactorizeModuleOptions & {
            factoryResult?: false;
        }, callback: ModuleCallback): void;
        (options: FactorizeModuleOptions & {
            factoryResult: true;
        }, callback: ModuleFactoryResultCallback): void;
    };
}
declare namespace Compilation {
    export { PROCESS_ASSETS_STAGE_ADDITIONAL, PROCESS_ASSETS_STAGE_PRE_PROCESS, PROCESS_ASSETS_STAGE_DERIVED, PROCESS_ASSETS_STAGE_ADDITIONS, PROCESS_ASSETS_STAGE_OPTIMIZE, PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT, PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY, PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE, PROCESS_ASSETS_STAGE_DEV_TOOLING, PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE, PROCESS_ASSETS_STAGE_SUMMARIZE, PROCESS_ASSETS_STAGE_OPTIMIZE_HASH, PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER, PROCESS_ASSETS_STAGE_ANALYSE, PROCESS_ASSETS_STAGE_REPORT, AsArray, Source, EntryDescription, OutputOptions, StatsOptions, WebpackPluginFunction, WebpackPluginInstance, AsyncDependenciesBlock, Cache, CacheFacade, ChunkGroupOptions, Compiler, CompilationParams, DependenciesBlock, DependencyLocation, ReferencedExport, DependencyTemplate, EntryOptions, CodeGenerationResult, ModuleFactory, ModuleFactoryCreateDataContextInfo, ModuleFactoryResult, RequestShortener, RuntimeModule, RenderManifestEntry, RenderManifestOptions, StatsAsset, StatsError, StatsModule, Hash, FakeHook, RuntimeSpec, Callback, ModuleCallback, ModuleFactoryResultCallback, ModuleOrFactoryResultCallback, ExecuteModuleCallback, DepBlockVarDependenciesCallback, DepConstructor, CompilationAssets, AvailableModulesChunkGroupMapping, DependenciesBlockLike, ChunkPathData, ChunkHashContext, RuntimeRequirementsContext, ExecuteModuleOptions, ExecuteModuleResult, ExecuteModuleArgument, ExecuteModuleContext, EntryData, LogEntry, KnownAssetInfo, AssetInfo, Asset, ModulePathData, PathData, KnownNormalizedStatsOptions, NormalizedStatsOptions, KnownCreateStatsOptionsContext, CreateStatsOptionsContext, FactorizeModuleOptions };
}
import { SyncHook } from "tapable";
import Module = require("webpack/lib/Module");
import WebpackError = require("webpack/lib/WebpackError");
import Dependency = require("webpack/lib/Dependency");
type EntryOptions = import("./Entrypoint").EntryOptions;
import { SyncWaterfallHook } from "tapable";
type ReferencedExport = import("./Dependency").ReferencedExport;
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
type ExecuteModuleArgument = {
    module: Module;
    moduleObject?: {
        id: string;
        exports: any;
        loaded: boolean;
    };
    preparedInfo: any;
    codeGenerationResult: CodeGenerationResult;
};
type ExecuteModuleContext = {
    assets: Map<string, {
        source: Source;
        info: AssetInfo;
    }>;
    chunk: Chunk;
    chunkGraph: ChunkGraph;
    __webpack_require__?: ((arg0: string) => any) | undefined;
};
import { AsyncParallelHook } from "tapable";
import { AsyncSeriesHook } from "tapable";
import Chunk = require("webpack/lib/Chunk");
import { SyncBailHook } from "tapable";
import ChunkGroup = require("webpack/lib/ChunkGroup");
import { AsyncSeriesBailHook } from "tapable";
type RuntimeRequirementsContext = {
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
    /**
     * the code generation results
     */
    codeGenerationResults: CodeGenerationResults;
};
import { HookMap } from "tapable";
type RuntimeModule = import("./RuntimeModule");
/**
 * <T>
 */
type FakeHook<T> = import("./util/deprecation").FakeHook<T>;
type CompilationAssets = Record<string, Source>;
type RenderManifestEntry = import("./Template").RenderManifestEntry;
type RenderManifestOptions = import("./Template").RenderManifestOptions;
type Hash = import("./util/Hash");
type ChunkHashContext = {
    /**
     * results of code generation
     */
    codeGenerationResults: CodeGenerationResults;
    /**
     * the runtime template
     */
    runtimeTemplate: RuntimeTemplate;
    /**
     * the module graph
     */
    moduleGraph: ModuleGraph;
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
};
type AssetInfo = KnownAssetInfo & Record<string, any>;
type Compiler = import("./Compiler");
type LogEntry = {
    type: string;
    args: any[];
    time: number;
    trace?: string[] | undefined;
};
type NormalizedStatsOptions = KnownNormalizedStatsOptions & Omit<StatsOptions, keyof KnownNormalizedStatsOptions> & Record<string, any>;
type CreateStatsOptionsContext = KnownCreateStatsOptionsContext & Record<string, any>;
import StatsFactory = require("webpack/lib/stats/StatsFactory");
import StatsPrinter = require("webpack/lib/stats/StatsPrinter");
import FileSystemInfo = require("webpack/lib/FileSystemInfo");
import { Logger } from "webpack/lib/logging/Logger";
import MainTemplate = require("webpack/lib/MainTemplate");
import ChunkTemplate = require("webpack/lib/ChunkTemplate");
import RuntimeTemplate = require("webpack/lib/RuntimeTemplate");
import ModuleTemplate = require("webpack/lib/ModuleTemplate");
import WeakTupleMap = require("webpack/lib/util/WeakTupleMap");
import ModuleGraph = require("webpack/lib/ModuleGraph");
import ChunkGraph = require("webpack/lib/ChunkGraph");
import CodeGenerationResults = require("webpack/lib/CodeGenerationResults");
import AsyncQueue = require("webpack/lib/util/AsyncQueue");
type FactorizeModuleOptions = {
    currentProfile: ModuleProfile;
    factory: ModuleFactory;
    dependencies: Dependency[];
    /**
     * return full ModuleFactoryResult instead of only module
     */
    factoryResult?: boolean | undefined;
    originModule: Module | null;
    contextInfo?: Partial<ModuleFactoryCreateDataContextInfo> | undefined;
    context?: string | undefined;
};
type ModuleFactoryResult = import("./ModuleFactory").ModuleFactoryResult;
type EntryData = {
    /**
     * dependencies of the entrypoint that should be evaluated at startup
     */
    dependencies: Dependency[];
    /**
     * dependencies of the entrypoint that should be included but not evaluated
     */
    includeDependencies: Dependency[];
    /**
     * options of the entrypoint
     */
    options: EntryOptions;
};
import Entrypoint = require("webpack/lib/Entrypoint");
type DepConstructor = new (...args: any[]) => Dependency;
type ModuleFactory = import("./ModuleFactory");
import DependencyTemplates = require("webpack/lib/DependencyTemplates");
import LazySet = require("webpack/lib/util/LazySet");
import Stats = require("webpack/lib/Stats");
type StatsOptions = any;
type CacheFacade = import("./CacheFacade");
type ModuleCallback = (err?: (WebpackError | null) | undefined, result?: Module | undefined) => void;
type ModuleFactoryCreateDataContextInfo = import("./ModuleFactory").ModuleFactoryCreateDataContextInfo;
type ModuleOrFactoryResultCallback = (err?: (WebpackError | null) | undefined, result?: (Module | ModuleFactoryResult) | undefined) => void;
type Callback = (err?: (WebpackError | null) | undefined) => void;
type DependenciesBlock = import("./DependenciesBlock");
type ChunkGroupOptions = import("./ChunkGroup").ChunkGroupOptions;
type DependencyLocation = import("./Dependency").DependencyLocation;
type DependenciesBlockLike = {
    dependencies: Dependency[];
    blocks: AsyncDependenciesBlock[];
};
type Source = import("webpack-sources").Source;
type Asset = {
    /**
     * the filename of the asset
     */
    name: string;
    /**
     * source of the asset
     */
    source: Source;
    /**
     * info about the asset
     */
    info: AssetInfo;
};
type PathData = {
    chunkGraph?: ChunkGraph | undefined;
    hash?: string | undefined;
    hashWithLength?: ((arg0: number) => string) | undefined;
    chunk?: (Chunk | ChunkPathData) | undefined;
    module?: (Module | ModulePathData) | undefined;
    runtime?: RuntimeSpec | undefined;
    filename?: string | undefined;
    basename?: string | undefined;
    query?: string | undefined;
    contentHashType?: string | undefined;
    contentHash?: string | undefined;
    contentHashWithLength?: ((arg0: number) => string) | undefined;
    noChunkHash?: boolean | undefined;
    url?: string | undefined;
};
type WebpackPluginInstance = any;
type WebpackPluginFunction = any;
type ExecuteModuleOptions = {
    entryOptions?: EntryOptions | undefined;
};
type ExecuteModuleCallback = (err?: (WebpackError | null) | undefined, result?: ExecuteModuleResult | undefined) => void;
type ModuleFactoryResultCallback = (err?: (WebpackError | null) | undefined, result?: ModuleFactoryResult | undefined) => void;
type CompilationParams = import("./Compiler").CompilationParams;
declare var PROCESS_ASSETS_STAGE_ADDITIONAL: number;
declare var PROCESS_ASSETS_STAGE_PRE_PROCESS: number;
declare var PROCESS_ASSETS_STAGE_DERIVED: number;
declare var PROCESS_ASSETS_STAGE_ADDITIONS: number;
declare var PROCESS_ASSETS_STAGE_OPTIMIZE: number;
declare var PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT: number;
declare var PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY: number;
declare var PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE: number;
declare var PROCESS_ASSETS_STAGE_DEV_TOOLING: number;
declare var PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE: number;
declare var PROCESS_ASSETS_STAGE_SUMMARIZE: number;
declare var PROCESS_ASSETS_STAGE_OPTIMIZE_HASH: number;
declare var PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER: number;
declare var PROCESS_ASSETS_STAGE_ANALYSE: number;
declare var PROCESS_ASSETS_STAGE_REPORT: number;
/**
 * <T>
 */
type AsArray<T> = import("tapable").AsArray<T>;
type EntryDescription = any;
type OutputOptions = any;
type AsyncDependenciesBlock = import("./AsyncDependenciesBlock");
type Cache = import("./Cache");
type DependencyTemplate = import("./DependencyTemplate");
type CodeGenerationResult = import("./Module").CodeGenerationResult;
type RequestShortener = import("./RequestShortener");
type StatsAsset = import("./stats/DefaultStatsFactoryPlugin").StatsAsset;
type StatsError = import("./stats/DefaultStatsFactoryPlugin").StatsError;
type StatsModule = import("./stats/DefaultStatsFactoryPlugin").StatsModule;
type DepBlockVarDependenciesCallback = (dependency: Dependency) => any;
type AvailableModulesChunkGroupMapping = {
    chunkGroup: ChunkGroup;
    availableModules: Set<Module>;
    needCopy: boolean;
};
type ChunkPathData = {
    id: string | number;
    name?: string | undefined;
    hash: string;
    hashWithLength?: ((arg0: number) => string) | undefined;
    contentHash?: (Record<string, string>) | undefined;
    contentHashWithLength?: Record<string, (length: number) => string>;
};
type ExecuteModuleResult = {
    exports: any;
    cacheable: boolean;
    assets: Map<string, {
        source: Source;
        info: AssetInfo;
    }>;
    fileDependencies: LazySet<string>;
    contextDependencies: LazySet<string>;
    missingDependencies: LazySet<string>;
    buildDependencies: LazySet<string>;
};
type KnownAssetInfo = {
    /**
     * true, if the asset can be long term cached forever (contains a hash)
     */
    immutable?: boolean | undefined;
    /**
     * whether the asset is minimized
     */
    minimized?: boolean | undefined;
    /**
     * the value(s) of the full hash used for this asset
     */
    fullhash?: (string | string[]) | undefined;
    /**
     * the value(s) of the chunk hash used for this asset
     */
    chunkhash?: (string | string[]) | undefined;
    /**
     * the value(s) of the module hash used for this asset
     */
    modulehash?: (string | string[]) | undefined;
    /**
     * the value(s) of the content hash used for this asset
     */
    contenthash?: (string | string[]) | undefined;
    /**
     * when asset was created from a source file (potentially transformed), the original filename relative to compilation context
     */
    sourceFilename?: string | undefined;
    /**
     * size in bytes, only set after asset has been emitted
     */
    size?: number | undefined;
    /**
     * true, when asset is only used for development and doesn't count towards user-facing assets
     */
    development?: boolean | undefined;
    /**
     * true, when asset ships data for updating an existing application (HMR)
     */
    hotModuleReplacement?: boolean | undefined;
    /**
     * true, when asset is javascript and an ESM
     */
    javascriptModule?: boolean | undefined;
    /**
     * object of pointers to other assets, keyed by type of relation (only points from parent to child)
     */
    related?: Record<string, string | string[]> | undefined;
};
type ModulePathData = {
    id: string | number;
    hash: string;
    hashWithLength?: ((arg0: number) => string) | undefined;
};
type KnownNormalizedStatsOptions = {
    context: string;
    requestShortener: RequestShortener;
    chunksSort: string;
    modulesSort: string;
    chunkModulesSort: string;
    nestedModulesSort: string;
    assetsSort: string;
    ids: boolean;
    cachedAssets: boolean;
    groupAssetsByEmitStatus: boolean;
    groupAssetsByPath: boolean;
    groupAssetsByExtension: boolean;
    assetsSpace: number;
    excludeAssets: ((value: string, asset: StatsAsset) => boolean)[];
    excludeModules: ((name: string, module: StatsModule, type: "module" | "chunk" | "root-of-chunk" | "nested") => boolean)[];
    warningsFilter: ((warning: StatsError, textValue: string) => boolean)[];
    cachedModules: boolean;
    orphanModules: boolean;
    dependentModules: boolean;
    runtimeModules: boolean;
    groupModulesByCacheStatus: boolean;
    groupModulesByLayer: boolean;
    groupModulesByAttributes: boolean;
    groupModulesByPath: boolean;
    groupModulesByExtension: boolean;
    groupModulesByType: boolean;
    entrypoints: boolean | "auto";
    chunkGroups: boolean;
    chunkGroupAuxiliary: boolean;
    chunkGroupChildren: boolean;
    chunkGroupMaxAssets: number;
    modulesSpace: number;
    chunkModulesSpace: number;
    nestedModulesSpace: number;
    logging: false | "none" | "error" | "warn" | "info" | "log" | "verbose";
    loggingDebug: ((value: string) => boolean)[];
    loggingTrace: boolean;
    _env: any;
};
type KnownCreateStatsOptionsContext = {
    forToString?: boolean | undefined;
};
import ModuleProfile = require("webpack/lib/ModuleProfile");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Compiler.d.ts
export = Compiler;
declare class Compiler {
    /**
     * @param {string} context the compilation path
     * @param {WebpackOptions} options options
     */
    constructor(context: string, options?: any);
    hooks: Readonly<{
        /** @type {SyncHook<[]>} */
        initialize: SyncHook<[]>;
        /** @type {SyncBailHook<[Compilation], boolean | undefined>} */
        shouldEmit: SyncBailHook<[Compilation], boolean | undefined>;
        /** @type {AsyncSeriesHook<[Stats]>} */
        done: AsyncSeriesHook<[Stats]>;
        /** @type {SyncHook<[Stats]>} */
        afterDone: SyncHook<[Stats]>;
        /** @type {AsyncSeriesHook<[]>} */
        additionalPass: AsyncSeriesHook<[]>;
        /** @type {AsyncSeriesHook<[Compiler]>} */
        beforeRun: AsyncSeriesHook<[Compiler]>;
        /** @type {AsyncSeriesHook<[Compiler]>} */
        run: AsyncSeriesHook<[Compiler]>;
        /** @type {AsyncSeriesHook<[Compilation]>} */
        emit: AsyncSeriesHook<[Compilation]>;
        /** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>} */
        assetEmitted: AsyncSeriesHook<[string, AssetEmittedInfo]>;
        /** @type {AsyncSeriesHook<[Compilation]>} */
        afterEmit: AsyncSeriesHook<[Compilation]>;
        /** @type {SyncHook<[Compilation, CompilationParams]>} */
        thisCompilation: SyncHook<[Compilation, CompilationParams]>;
        /** @type {SyncHook<[Compilation, CompilationParams]>} */
        compilation: SyncHook<[Compilation, CompilationParams]>;
        /** @type {SyncHook<[NormalModuleFactory]>} */
        normalModuleFactory: SyncHook<[NormalModuleFactory]>;
        /** @type {SyncHook<[ContextModuleFactory]>}  */
        contextModuleFactory: SyncHook<[ContextModuleFactory]>;
        /** @type {AsyncSeriesHook<[CompilationParams]>} */
        beforeCompile: AsyncSeriesHook<[CompilationParams]>;
        /** @type {SyncHook<[CompilationParams]>} */
        compile: SyncHook<[CompilationParams]>;
        /** @type {AsyncParallelHook<[Compilation]>} */
        make: AsyncParallelHook<[Compilation]>;
        /** @type {AsyncParallelHook<[Compilation]>} */
        finishMake: AsyncParallelHook<[Compilation]>;
        /** @type {AsyncSeriesHook<[Compilation]>} */
        afterCompile: AsyncSeriesHook<[Compilation]>;
        /** @type {AsyncSeriesHook<[]>} */
        readRecords: AsyncSeriesHook<[]>;
        /** @type {AsyncSeriesHook<[]>} */
        emitRecords: AsyncSeriesHook<[]>;
        /** @type {AsyncSeriesHook<[Compiler]>} */
        watchRun: AsyncSeriesHook<[Compiler]>;
        /** @type {SyncHook<[Error]>} */
        failed: SyncHook<[Error]>;
        /** @type {SyncHook<[string | null, number]>} */
        invalid: SyncHook<[string | null, number]>;
        /** @type {SyncHook<[]>} */
        watchClose: SyncHook<[]>;
        /** @type {AsyncSeriesHook<[]>} */
        shutdown: AsyncSeriesHook<[]>;
        /** @type {SyncBailHook<[string, string, any[]], true>} */
        infrastructureLog: SyncBailHook<[string, string, any[]], true>;
        /** @type {SyncHook<[]>} */
        environment: SyncHook<[]>;
        /** @type {SyncHook<[]>} */
        afterEnvironment: SyncHook<[]>;
        /** @type {SyncHook<[Compiler]>} */
        afterPlugins: SyncHook<[Compiler]>;
        /** @type {SyncHook<[Compiler]>} */
        afterResolvers: SyncHook<[Compiler]>;
        /** @type {SyncBailHook<[string, Entry], boolean>} */
        entryOption: SyncBailHook<[string, Entry], boolean>;
    }>;
    webpack: import("webpack/lib/webpack").WebpackFunctionSingle & import("webpack/lib/webpack").WebpackFunctionMulti & {
        readonly webpack: import("webpack/lib/webpack").WebpackFunctionSingle & import("webpack/lib/webpack").WebpackFunctionMulti;
        readonly validate: (options: any) => void;
        readonly validateSchema: (schema: import("webpack/node_modules/schema-utils/declarations/validate").Schema, options: object | object[], validationConfiguration?: import("webpack/node_modules/schema-utils/declarations/validate").ValidationErrorConfiguration) => void;
        readonly version: string;
        readonly cli: typeof import("webpack/lib/cli");
        readonly AutomaticPrefetchPlugin: typeof import("webpack/lib/AutomaticPrefetchPlugin");
        readonly AsyncDependenciesBlock: typeof import("webpack/lib/AsyncDependenciesBlock");
        readonly BannerPlugin: typeof import("webpack/lib/BannerPlugin");
        readonly Cache: typeof Cache;
        readonly Chunk: typeof import("webpack/lib/Chunk");
        readonly ChunkGraph: typeof ChunkGraph;
        readonly CleanPlugin: typeof import("webpack/lib/CleanPlugin");
        readonly Compilation: typeof Compilation;
        readonly Compiler: typeof Compiler;
        readonly ConcatenationScope: typeof import("webpack/lib/ConcatenationScope");
        readonly ContextExclusionPlugin: typeof import("webpack/lib/ContextExclusionPlugin");
        readonly ContextReplacementPlugin: typeof import("webpack/lib/ContextReplacementPlugin");
        readonly DefinePlugin: typeof import("webpack/lib/DefinePlugin");
        readonly DelegatedPlugin: typeof import("webpack/lib/DelegatedPlugin");
        readonly Dependency: typeof import("webpack/lib/Dependency");
        readonly DllPlugin: typeof import("webpack/lib/DllPlugin");
        readonly DllReferencePlugin: typeof import("webpack/lib/DllReferencePlugin");
        readonly DynamicEntryPlugin: typeof import("webpack/lib/DynamicEntryPlugin");
        readonly EntryOptionPlugin: typeof import("webpack/lib/EntryOptionPlugin");
        readonly EntryPlugin: typeof import("webpack/lib/EntryPlugin");
        readonly EnvironmentPlugin: typeof import("webpack/lib/EnvironmentPlugin");
        readonly EvalDevToolModulePlugin: typeof import("webpack/lib/EvalDevToolModulePlugin");
        readonly EvalSourceMapDevToolPlugin: typeof import("webpack/lib/EvalSourceMapDevToolPlugin");
        readonly ExternalModule: typeof import("webpack/lib/ExternalModule");
        readonly ExternalsPlugin: typeof import("webpack/lib/ExternalsPlugin");
        readonly Generator: typeof import("webpack/lib/Generator");
        readonly HotUpdateChunk: typeof import("webpack/lib/HotUpdateChunk");
        readonly HotModuleReplacementPlugin: typeof import("webpack/lib/HotModuleReplacementPlugin");
        readonly IgnorePlugin: typeof import("webpack/lib/IgnorePlugin");
        readonly JavascriptModulesPlugin: typeof import("webpack/lib/javascript/JavascriptModulesPlugin");
        readonly LibManifestPlugin: typeof import("webpack/lib/LibManifestPlugin");
        readonly LibraryTemplatePlugin: typeof import("webpack/lib/LibraryTemplatePlugin");
        readonly LoaderOptionsPlugin: typeof import("webpack/lib/LoaderOptionsPlugin");
        readonly LoaderTargetPlugin: typeof import("webpack/lib/LoaderTargetPlugin");
        readonly Module: typeof import("webpack/lib/Module");
        readonly ModuleFilenameHelpers: typeof import("webpack/lib/ModuleFilenameHelpers");
        readonly ModuleGraph: typeof ModuleGraph;
        readonly ModuleGraphConnection: typeof ModuleGraph.ModuleGraphConnection;
        readonly NoEmitOnErrorsPlugin: typeof import("webpack/lib/NoEmitOnErrorsPlugin");
        readonly NormalModule: typeof import("webpack/lib/NormalModule");
        readonly NormalModuleReplacementPlugin: typeof import("webpack/lib/NormalModuleReplacementPlugin");
        readonly MultiCompiler: typeof import("webpack/lib/MultiCompiler");
        readonly Parser: typeof import("webpack/lib/Parser");
        readonly PrefetchPlugin: typeof import("webpack/lib/PrefetchPlugin");
        readonly ProgressPlugin: typeof import("webpack/lib/ProgressPlugin");
        readonly ProvidePlugin: typeof import("webpack/lib/ProvidePlugin");
        readonly RuntimeGlobals: typeof import("webpack/lib/RuntimeGlobals");
        readonly RuntimeModule: typeof import("webpack/lib/RuntimeModule");
        readonly SingleEntryPlugin: typeof import("webpack/lib/EntryPlugin");
        readonly SourceMapDevToolPlugin: typeof import("webpack/lib/SourceMapDevToolPlugin");
        readonly Stats: typeof Stats;
        readonly Template: typeof import("webpack/lib/Template");
        readonly UsageState: Readonly<{
            Unused: 0;
            OnlyPropertiesUsed: 1;
            NoInfo: 2;
            Unknown: 3;
            Used: 4;
        }>;
        readonly WatchIgnorePlugin: typeof import("webpack/lib/WatchIgnorePlugin");
        readonly WebpackError: typeof WebpackError;
        readonly WebpackOptionsApply: typeof import("webpack/lib/WebpackOptionsApply");
        readonly WebpackOptionsDefaulter: typeof import("webpack/lib/WebpackOptionsDefaulter");
        readonly WebpackOptionsValidationError: typeof import("webpack/node_modules/schema-utils/declarations/ValidationError").default;
        readonly ValidationError: typeof import("webpack/node_modules/schema-utils/declarations/ValidationError").default;
        cache: {
            readonly MemoryCachePlugin: typeof import("webpack/lib/cache/MemoryCachePlugin");
        };
        config: {
            readonly getNormalizedWebpackOptions: (config: any) => any;
            readonly applyWebpackOptionsDefaults: (options: any) => void;
        };
        dependencies: {
            readonly ModuleDependency: typeof import("webpack/lib/dependencies/ModuleDependency");
            readonly HarmonyImportDependency: typeof import("webpack/lib/dependencies/HarmonyImportDependency");
            readonly ConstDependency: typeof import("webpack/lib/dependencies/ConstDependency");
            readonly NullDependency: typeof import("webpack/lib/dependencies/NullDependency");
        };
        ids: {
            readonly ChunkModuleIdRangePlugin: typeof import("webpack/lib/ids/ChunkModuleIdRangePlugin");
            readonly NaturalModuleIdsPlugin: typeof import("webpack/lib/ids/NaturalModuleIdsPlugin");
            readonly OccurrenceModuleIdsPlugin: typeof import("webpack/lib/ids/OccurrenceModuleIdsPlugin");
            readonly NamedModuleIdsPlugin: typeof import("webpack/lib/ids/NamedModuleIdsPlugin");
            readonly DeterministicChunkIdsPlugin: typeof import("webpack/lib/ids/DeterministicChunkIdsPlugin");
            readonly DeterministicModuleIdsPlugin: typeof import("webpack/lib/ids/DeterministicModuleIdsPlugin");
            readonly NamedChunkIdsPlugin: typeof import("webpack/lib/ids/NamedChunkIdsPlugin");
            readonly OccurrenceChunkIdsPlugin: typeof import("webpack/lib/ids/OccurrenceChunkIdsPlugin");
            readonly HashedModuleIdsPlugin: typeof import("webpack/lib/ids/HashedModuleIdsPlugin");
        };
        javascript: {
            readonly EnableChunkLoadingPlugin: typeof import("webpack/lib/javascript/EnableChunkLoadingPlugin");
            readonly JavascriptModulesPlugin: typeof import("webpack/lib/javascript/JavascriptModulesPlugin");
            readonly JavascriptParser: typeof import("webpack/lib/javascript/JavascriptParser");
        };
        optimize: {
            readonly AggressiveMergingPlugin: typeof import("webpack/lib/optimize/AggressiveMergingPlugin");
            readonly AggressiveSplittingPlugin: typeof import("webpack/lib/optimize/AggressiveSplittingPlugin");
            readonly InnerGraph: typeof import("webpack/lib/optimize/InnerGraph");
            readonly LimitChunkCountPlugin: typeof import("webpack/lib/optimize/LimitChunkCountPlugin");
            readonly MinChunkSizePlugin: typeof import("webpack/lib/optimize/MinChunkSizePlugin");
            readonly ModuleConcatenationPlugin: typeof import("webpack/lib/optimize/ModuleConcatenationPlugin");
            readonly RealContentHashPlugin: typeof import("webpack/lib/optimize/RealContentHashPlugin");
            readonly RuntimeChunkPlugin: typeof import("webpack/lib/optimize/RuntimeChunkPlugin");
            readonly SideEffectsFlagPlugin: typeof import("webpack/lib/optimize/SideEffectsFlagPlugin");
            readonly SplitChunksPlugin: typeof import("webpack/lib/optimize/SplitChunksPlugin");
        };
        runtime: {
            readonly GetChunkFilenameRuntimeModule: typeof import("webpack/lib/runtime/GetChunkFilenameRuntimeModule");
            readonly LoadScriptRuntimeModule: typeof import("webpack/lib/runtime/LoadScriptRuntimeModule");
        };
        prefetch: {
            readonly ChunkPrefetchPreloadPlugin: typeof import("webpack/lib/prefetch/ChunkPrefetchPreloadPlugin");
        };
        web: {
            readonly FetchCompileAsyncWasmPlugin: typeof import("webpack/lib/web/FetchCompileAsyncWasmPlugin");
            readonly FetchCompileWasmPlugin: typeof import("webpack/lib/web/FetchCompileWasmPlugin");
            readonly JsonpChunkLoadingRuntimeModule: typeof import("webpack/lib/web/JsonpChunkLoadingRuntimeModule");
            readonly JsonpTemplatePlugin: typeof import("webpack/lib/web/JsonpTemplatePlugin");
        };
        webworker: {
            readonly WebWorkerTemplatePlugin: typeof import("webpack/lib/webworker/WebWorkerTemplatePlugin");
        };
        node: {
            readonly NodeEnvironmentPlugin: typeof import("webpack/lib/node/NodeEnvironmentPlugin");
            readonly NodeSourcePlugin: typeof import("webpack/lib/node/NodeSourcePlugin");
            readonly NodeTargetPlugin: typeof import("webpack/lib/node/NodeTargetPlugin");
            readonly NodeTemplatePlugin: typeof import("webpack/lib/node/NodeTemplatePlugin");
            readonly ReadFileCompileWasmPlugin: typeof import("webpack/lib/node/ReadFileCompileWasmPlugin");
        };
        electron: {
            readonly ElectronTargetPlugin: typeof import("webpack/lib/electron/ElectronTargetPlugin");
        };
        wasm: {
            readonly AsyncWebAssemblyModulesPlugin: typeof import("webpack/lib/wasm-async/AsyncWebAssemblyModulesPlugin");
            readonly EnableWasmLoadingPlugin: typeof import("webpack/lib/wasm/EnableWasmLoadingPlugin");
        };
        library: {
            readonly AbstractLibraryPlugin: typeof import("webpack/lib/library/AbstractLibraryPlugin");
            readonly EnableLibraryPlugin: typeof import("webpack/lib/library/EnableLibraryPlugin");
        };
        container: {
            readonly ContainerPlugin: typeof import("webpack/lib/container/ContainerPlugin");
            readonly ContainerReferencePlugin: typeof import("webpack/lib/container/ContainerReferencePlugin");
            readonly ModuleFederationPlugin: typeof import("webpack/lib/container/ModuleFederationPlugin");
            readonly scope: <T>(scope: string, options: import("webpack/lib/container/options").ContainerOptionsFormat<T>) => Record<string, string | string[] | T>;
        };
        sharing: {
            readonly ConsumeSharedPlugin: typeof import("webpack/lib/sharing/ConsumeSharedPlugin");
            readonly ProvideSharedPlugin: typeof import("webpack/lib/sharing/ProvideSharedPlugin");
            readonly SharePlugin: typeof import("webpack/lib/sharing/SharePlugin");
            readonly scope: <T>(scope: string, options: import("webpack/lib/container/options").ContainerOptionsFormat<T>) => Record<string, string | string[] | T>;
        };
        debug: {
            readonly ProfilingPlugin: typeof import("webpack/lib/debug/ProfilingPlugin");
        };
        util: {
            readonly createHash: (algorithm: string | typeof import("webpack/lib/util/Hash")) => import("webpack/lib/util/Hash");
            readonly comparators: typeof import("webpack/lib/util/comparators");
            readonly runtime: typeof import("webpack/lib/util/runtime");
            readonly serialization: {
                readonly register: typeof import("webpack/lib/serialization/ObjectMiddleware").register;
                readonly registerLoader: typeof import("webpack/lib/serialization/ObjectMiddleware").registerLoader;
                readonly registerNotSerializable: typeof import("webpack/lib/serialization/ObjectMiddleware").registerNotSerializable;
                readonly NOT_SERIALIZABLE: {};
                readonly MEASURE_START_OPERATION: unique symbol;
                readonly MEASURE_END_OPERATION: unique symbol;
                readonly buffersSerializer: import("webpack/lib/serialization/Serializer");
                createFileSerializer: (fs: import("webpack/lib/util/fs").IntermediateFileSystem, hashFunction: string | typeof import("webpack/lib/util/Hash")) => import("webpack/lib/serialization/Serializer");
            };
            readonly cleverMerge: <T_1, O>(first: T_1, second: O) => T_1 | O | (T_1 & O);
            readonly LazySet: typeof import("webpack/lib/util/LazySet");
        };
        readonly sources: typeof import("webpack-sources");
        experiments: {
            schemes: {
                readonly HttpUriPlugin: typeof import("webpack/lib/schemes/HttpUriPlugin");
            };
            ids: {
                readonly SyncModuleIdsPlugin: typeof import("webpack/lib/ids/SyncModuleIdsPlugin");
            };
        };
    };
    /** @type {string=} */
    name: string | undefined;
    /** @type {Compilation=} */
    parentCompilation: Compilation | undefined;
    /** @type {Compiler} */
    root: Compiler;
    /** @type {string} */
    outputPath: string;
    /** @type {Watching | undefined} */
    watching: Watching | undefined;
    /** @type {OutputFileSystem} */
    outputFileSystem: OutputFileSystem;
    /** @type {IntermediateFileSystem} */
    intermediateFileSystem: IntermediateFileSystem;
    /** @type {InputFileSystem} */
    inputFileSystem: InputFileSystem;
    /** @type {WatchFileSystem} */
    watchFileSystem: WatchFileSystem;
    /** @type {string|null} */
    recordsInputPath: string | null;
    /** @type {string|null} */
    recordsOutputPath: string | null;
    records: {};
    /** @type {Set<string | RegExp>} */
    managedPaths: Set<string | RegExp>;
    /** @type {Set<string | RegExp>} */
    immutablePaths: Set<string | RegExp>;
    /** @type {ReadonlySet<string> | undefined} */
    modifiedFiles: ReadonlySet<string> | undefined;
    /** @type {ReadonlySet<string> | undefined} */
    removedFiles: ReadonlySet<string> | undefined;
    /** @type {ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null> | undefined} */
    fileTimestamps: ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null> | undefined;
    /** @type {ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null> | undefined} */
    contextTimestamps: ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null> | undefined;
    /** @type {number | undefined} */
    fsStartTime: number | undefined;
    /** @type {ResolverFactory} */
    resolverFactory: ResolverFactory;
    infrastructureLogger: any;
    options: any;
    context: string;
    requestShortener: RequestShortener;
    cache: Cache;
    /** @type {Map<Module, { buildInfo: object, references: WeakMap<Dependency, Module>, memCache: WeakTupleMap }> | undefined} */
    moduleMemCaches: Map<Module, {
        buildInfo: object;
        references: WeakMap<Dependency, Module>;
        memCache: import("webpack/lib/util/WeakTupleMap")<any, any>;
    }> | undefined;
    compilerPath: string;
    /** @type {boolean} */
    running: boolean;
    /** @type {boolean} */
    idle: boolean;
    /** @type {boolean} */
    watchMode: boolean;
    _backCompat: boolean;
    /** @type {Compilation} */
    _lastCompilation: Compilation;
    /** @type {NormalModuleFactory} */
    _lastNormalModuleFactory: NormalModuleFactory;
    /** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */
    private _assetEmittingSourceCache;
    /** @private @type {Map<string, number>} */
    private _assetEmittingWrittenFiles;
    /** @private @type {Set<string>} */
    private _assetEmittingPreviousFiles;
    /**
     * @param {string} name cache name
     * @returns {CacheFacade} the cache facade instance
     */
    getCache(name: string): CacheFacade;
    /**
     * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name
     * @returns {Logger} a logger with that name
     */
    getInfrastructureLogger(name: string | (() => string)): Logger;
    _cleanupLastCompilation(): void;
    _cleanupLastNormalModuleFactory(): void;
    /**
     * @param {WatchOptions} watchOptions the watcher's options
     * @param {Callback<Stats>} handler signals when the call finishes
     * @returns {Watching} a compiler watcher
     */
    watch(watchOptions: any, handler: Callback<Stats>): Watching;
    /**
     * @param {Callback<Stats>} callback signals when the call finishes
     * @returns {void}
     */
    run(callback: Callback<Stats>): void;
    /**
     * @param {RunAsChildCallback} callback signals when the call finishes
     * @returns {void}
     */
    runAsChild(callback: RunAsChildCallback): void;
    purgeInputFileSystem(): void;
    /**
     * @param {Compilation} compilation the compilation
     * @param {Callback<void>} callback signals when the assets are emitted
     * @returns {void}
     */
    emitAssets(compilation: Compilation, callback: Callback<void>): void;
    /**
     * @param {Callback<void>} callback signals when the call finishes
     * @returns {void}
     */
    emitRecords(callback: Callback<void>): void;
    /**
     * @param {Callback<void>} callback signals when the call finishes
     * @returns {void}
     */
    _emitRecords(callback: Callback<void>): void;
    /**
     * @param {Callback<void>} callback signals when the call finishes
     * @returns {void}
     */
    readRecords(callback: Callback<void>): void;
    /**
     * @param {Callback<void>} callback signals when the call finishes
     * @returns {void}
     */
    _readRecords(callback: Callback<void>): void;
    /**
     * @param {Compilation} compilation the compilation
     * @param {string} compilerName the compiler's name
     * @param {number} compilerIndex the compiler's index
     * @param {OutputOptions=} outputOptions the output options
     * @param {WebpackPluginInstance[]=} plugins the plugins to apply
     * @returns {Compiler} a child compiler
     */
    createChildCompiler(compilation: Compilation, compilerName: string, compilerIndex: number, outputOptions?: any, plugins?: WebpackPluginInstance[] | undefined): Compiler;
    isChild(): boolean;
    createCompilation(params: any): Compilation;
    /**
     * @param {CompilationParams} params the compilation parameters
     * @returns {Compilation} the created compilation
     */
    newCompilation(params: CompilationParams): Compilation;
    createNormalModuleFactory(): NormalModuleFactory;
    createContextModuleFactory(): ContextModuleFactory;
    newCompilationParams(): {
        normalModuleFactory: NormalModuleFactory;
        contextModuleFactory: ContextModuleFactory;
    };
    /**
     * @param {Callback<Compilation>} callback signals when the compilation finishes
     * @returns {void}
     */
    compile(callback: Callback<Compilation>): void;
    /**
     * @param {Callback<void>} callback signals when the compiler closes
     * @returns {void}
     */
    close(callback: Callback<void>): void;
}
declare namespace Compiler {
    export { Source, Entry, OutputOptions, WatchOptions, WebpackOptions, WebpackPluginInstance, Chunk, Dependency, FileSystemInfoEntry, Module, WeakTupleMap, InputFileSystem, IntermediateFileSystem, OutputFileSystem, WatchFileSystem, CompilationParams, Callback, RunAsChildCallback, AssetEmittedInfo };
}
import { SyncHook } from "tapable";
import { SyncBailHook } from "tapable";
import Compilation = require("webpack/lib/Compilation");
import { AsyncSeriesHook } from "tapable";
import Stats = require("webpack/lib/Stats");
type AssetEmittedInfo = {
    content: Buffer;
    source: Source;
    compilation: Compilation;
    outputPath: string;
    targetPath: string;
};
type CompilationParams = {
    normalModuleFactory: NormalModuleFactory;
    contextModuleFactory: ContextModuleFactory;
};
import NormalModuleFactory = require("webpack/lib/NormalModuleFactory");
import ContextModuleFactory = require("webpack/lib/ContextModuleFactory");
import { AsyncParallelHook } from "tapable";
type Entry = any;
import Cache = require("webpack/lib/Cache");
import ChunkGraph = require("webpack/lib/ChunkGraph");
import ModuleGraph = require("webpack/lib/ModuleGraph");
import WebpackError = require("webpack/lib/WebpackError");
import Watching = require("webpack/lib/Watching");
type OutputFileSystem = import("./util/fs").OutputFileSystem;
type IntermediateFileSystem = import("./util/fs").IntermediateFileSystem;
type InputFileSystem = import("./util/fs").InputFileSystem;
type WatchFileSystem = import("./util/fs").WatchFileSystem;
type FileSystemInfoEntry = import("./FileSystemInfo").FileSystemInfoEntry;
import ResolverFactory = require("webpack/lib/ResolverFactory");
import RequestShortener = require("webpack/lib/RequestShortener");
type Module = import("./Module");
type Dependency = import("./Dependency");
import CacheFacade = require("webpack/lib/CacheFacade");
import { Logger } from "webpack/lib/logging/Logger";
type Callback<T> = (err?: (Error | null) | undefined, result?: T | undefined) => any;
type RunAsChildCallback = (err?: (Error | null) | undefined, entries?: Chunk[] | undefined, compilation?: Compilation | undefined) => any;
type WebpackPluginInstance = any;
type Source = import("webpack-sources").Source;
type OutputOptions = any;
type WatchOptions = any;
type WebpackOptions = any;
type Chunk = import("./Chunk");
type WeakTupleMap = import("webpack/lib/util/WeakTupleMap")<any, any>;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ConcatenationScope.d.ts
export = ConcatenationScope;
/**
 * @typedef {Object} ExternalModuleInfo
 * @property {number} index
 * @property {Module} module
 */
/**
 * @typedef {Object} ConcatenatedModuleInfo
 * @property {number} index
 * @property {Module} module
 * @property {Map<string, string>} exportMap mapping from export name to symbol
 * @property {Map<string, string>} rawExportMap mapping from export name to symbol
 * @property {string=} namespaceExportSymbol
 */
/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo} ModuleInfo */
/**
 * @typedef {Object} ModuleReferenceOptions
 * @property {string[]} ids the properties/exports of the module
 * @property {boolean} call true, when this referenced export is called
 * @property {boolean} directImport true, when this referenced export is directly imported (not via property access)
 * @property {boolean | undefined} asiSafe if the position is ASI safe or unknown
 */
declare class ConcatenationScope {
    /**
     * @param {string} name the identifier
     * @returns {boolean} true, when it's an module reference
     */
    static isModuleReference(name: string): boolean;
    /**
     * @param {string} name the identifier
     * @returns {ModuleReferenceOptions & { index: number } | null} parsed options and index
     */
    static matchModuleReference(name: string): ModuleReferenceOptions & {
        index: number;
    };
    /**
     * @param {ModuleInfo[] | Map<Module, ModuleInfo>} modulesMap all module info by module
     * @param {ConcatenatedModuleInfo} currentModule the current module info
     */
    constructor(modulesMap: ModuleInfo[] | Map<Module, ModuleInfo>, currentModule: ConcatenatedModuleInfo);
    _currentModule: ConcatenatedModuleInfo;
    _modulesMap: Map<import("webpack/lib/Module"), ModuleInfo>;
    /**
     * @param {Module} module the referenced module
     * @returns {boolean} true, when it's in the scope
     */
    isModuleInScope(module: Module): boolean;
    /**
     *
     * @param {string} exportName name of the export
     * @param {string} symbol identifier of the export in source code
     */
    registerExport(exportName: string, symbol: string): void;
    /**
     *
     * @param {string} exportName name of the export
     * @param {string} expression expression to be used
     */
    registerRawExport(exportName: string, expression: string): void;
    /**
     * @param {string} symbol identifier of the export in source code
     */
    registerNamespaceExport(symbol: string): void;
    /**
     *
     * @param {Module} module the referenced module
     * @param {Partial<ModuleReferenceOptions>} options options
     * @returns {string} the reference as identifier
     */
    createModuleReference(module: Module, { ids, call, directImport, asiSafe }: Partial<ModuleReferenceOptions>): string;
}
declare namespace ConcatenationScope {
    export { DEFAULT_EXPORT, NAMESPACE_OBJECT_EXPORT, Module, ExternalModuleInfo, ConcatenatedModuleInfo, ModuleInfo, ModuleReferenceOptions };
}
type ConcatenatedModuleInfo = {
    index: number;
    module: Module;
    /**
     * mapping from export name to symbol
     */
    exportMap: Map<string, string>;
    /**
     * mapping from export name to symbol
     */
    rawExportMap: Map<string, string>;
    namespaceExportSymbol?: string | undefined;
};
type ModuleInfo = ConcatenatedModuleInfo | ExternalModuleInfo;
type Module = import("./Module");
type ModuleReferenceOptions = {
    /**
     * the properties/exports of the module
     */
    ids: string[];
    /**
     * true, when this referenced export is called
     */
    call: boolean;
    /**
     * true, when this referenced export is directly imported (not via property access)
     */
    directImport: boolean;
    /**
     * if the position is ASI safe or unknown
     */
    asiSafe: boolean | undefined;
};
declare const DEFAULT_EXPORT: "__WEBPACK_DEFAULT_EXPORT__";
declare const NAMESPACE_OBJECT_EXPORT: "__WEBPACK_NAMESPACE_OBJECT__";
type ExternalModuleInfo = {
    index: number;
    module: Module;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ConcurrentCompilationError.d.ts
export = ConcurrentCompilationError;
declare class ConcurrentCompilationError extends WebpackError {
    constructor();
}
import WebpackError = require("webpack/lib/WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ConditionalInitFragment.d.ts
export = ConditionalInitFragment;
/**
 * @typedef {GenerateContext} Context
 * @extends {InitFragment<Context>}
 */
declare class ConditionalInitFragment extends InitFragment<import("webpack/lib/Generator").GenerateContext> {
    /**
     * @param {string|Source} content the source code that will be included as initialization code
     * @param {number} stage category of initialization code (contribute to order)
     * @param {number} position position in the category (contribute to order)
     * @param {string | undefined} key unique key to avoid emitting the same initialization code twice
     * @param {RuntimeSpec | boolean} runtimeCondition in which runtime this fragment should be executed
     * @param {string|Source=} endContent the source code that will be included at the end of the module
     */
    constructor(content: string | Source, stage: number, position: number, key: string | undefined, runtimeCondition?: RuntimeSpec | boolean, endContent?: (string | Source) | undefined);
    runtimeCondition: boolean | import("webpack/lib/util/runtime").RuntimeSpec;
    /**
     * @param {ConditionalInitFragment} other fragment to merge with
     * @returns {ConditionalInitFragment} merged fragment
     */
    merge(other: ConditionalInitFragment): ConditionalInitFragment;
}
declare namespace ConditionalInitFragment {
    export { Source, GenerateContext, RuntimeSpec, Context };
}
import InitFragment = require("webpack/lib/InitFragment");
type Source = import("webpack-sources").Source;
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
type GenerateContext = import("./Generator").GenerateContext;
type Context = GenerateContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ConstPlugin.d.ts
export = ConstPlugin;
declare class ConstPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ConstPlugin {
    export { AssignmentProperty, Expression, Identifier, Pattern, SourceLocation, Statement, Super, Compiler, BasicEvaluatedExpression, JavascriptParser, Range };
}
type Compiler = import("./Compiler");
type AssignmentProperty = import("estree").AssignmentProperty;
type Expression = import("estree").Expression;
type Identifier = import("estree").Identifier;
type Pattern = import("estree").Pattern;
type SourceLocation = import("estree").SourceLocation;
type Statement = import("estree").Statement;
type Super = import("estree").Super;
type BasicEvaluatedExpression = import("./javascript/BasicEvaluatedExpression");
type JavascriptParser = import("./javascript/JavascriptParser");
type Range = import("./javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ContextExclusionPlugin.d.ts
export = ContextExclusionPlugin;
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./ContextModuleFactory")} ContextModuleFactory */
declare class ContextExclusionPlugin {
    /**
     * @param {RegExp} negativeMatcher Matcher regular expression
     */
    constructor(negativeMatcher: RegExp);
    negativeMatcher: RegExp;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ContextExclusionPlugin {
    export { Compiler, ContextModuleFactory };
}
type Compiler = import("./Compiler");
type ContextModuleFactory = import("./ContextModuleFactory");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ContextModule.d.ts
export = ContextModule;
declare class ContextModule extends Module {
    /**
     * @param {ResolveDependencies} resolveDependencies function to get dependencies in this context
     * @param {ContextModuleOptions} options options object
     */
    constructor(resolveDependencies: ResolveDependencies, options: ContextModuleOptions);
    /** @type {ContextModuleOptions} */
    options: ContextModuleOptions;
    resolveDependencies: ResolveDependencies;
    _identifier: string;
    _forceBuild: boolean;
    _prettyRegExp(regexString: any, stripSlash?: boolean): string;
    _createIdentifier(): string;
    /**
     * @param {ContextElementDependency[]} dependencies all dependencies
     * @param {ChunkGraph} chunkGraph chunk graph
     * @returns {TODO} TODO
     */
    getUserRequestMap(dependencies: ContextElementDependency[], chunkGraph: ChunkGraph): TODO;
    /**
     * @param {ContextElementDependency[]} dependencies all dependencies
     * @param {ChunkGraph} chunkGraph chunk graph
     * @returns {TODO} TODO
     */
    getFakeMap(dependencies: ContextElementDependency[], chunkGraph: ChunkGraph): TODO;
    getFakeMapInitStatement(fakeMap: any): string;
    getReturn(type: any, asyncModule: any): string;
    getReturnModuleObjectSource(fakeMap: any, asyncModule: any, fakeMapDataExpression?: string): string;
    /**
     * @param {TODO} dependencies TODO
     * @param {TODO} id TODO
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @returns {string} source code
     */
    getSyncSource(dependencies: TODO, id: TODO, chunkGraph: ChunkGraph): string;
    /**
     * @param {TODO} dependencies TODO
     * @param {TODO} id TODO
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @returns {string} source code
     */
    getWeakSyncSource(dependencies: TODO, id: TODO, chunkGraph: ChunkGraph): string;
    /**
     * @param {TODO} dependencies TODO
     * @param {TODO} id TODO
     * @param {Object} context context
     * @param {ChunkGraph} context.chunkGraph the chunk graph
     * @param {RuntimeTemplate} context.runtimeTemplate the chunk graph
     * @returns {string} source code
     */
    getAsyncWeakSource(dependencies: TODO, id: TODO, { chunkGraph, runtimeTemplate }: {
        chunkGraph: ChunkGraph;
        runtimeTemplate: RuntimeTemplate;
    }): string;
    /**
     * @param {TODO} dependencies TODO
     * @param {TODO} id TODO
     * @param {Object} context context
     * @param {ChunkGraph} context.chunkGraph the chunk graph
     * @param {RuntimeTemplate} context.runtimeTemplate the chunk graph
     * @returns {string} source code
     */
    getEagerSource(dependencies: TODO, id: TODO, { chunkGraph, runtimeTemplate }: {
        chunkGraph: ChunkGraph;
        runtimeTemplate: RuntimeTemplate;
    }): string;
    /**
     * @param {TODO} block TODO
     * @param {TODO} dependencies TODO
     * @param {TODO} id TODO
     * @param {Object} options options object
     * @param {RuntimeTemplate} options.runtimeTemplate the runtime template
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @returns {string} source code
     */
    getLazyOnceSource(block: TODO, dependencies: TODO, id: TODO, { runtimeTemplate, chunkGraph }: {
        runtimeTemplate: RuntimeTemplate;
        chunkGraph: ChunkGraph;
    }): string;
    /**
     * @param {TODO} blocks TODO
     * @param {TODO} id TODO
     * @param {Object} context context
     * @param {ChunkGraph} context.chunkGraph the chunk graph
     * @param {RuntimeTemplate} context.runtimeTemplate the chunk graph
     * @returns {string} source code
     */
    getLazySource(blocks: TODO, id: TODO, { chunkGraph, runtimeTemplate }: {
        chunkGraph: ChunkGraph;
        runtimeTemplate: RuntimeTemplate;
    }): string;
    getSourceForEmptyContext(id: any, runtimeTemplate: any): string;
    getSourceForEmptyAsyncContext(id: any, runtimeTemplate: any): string;
    /**
     * @param {string} asyncMode module mode
     * @param {CodeGenerationContext} context context info
     * @returns {string} the source code
     */
    getSourceString(asyncMode: string, { runtimeTemplate, chunkGraph }: CodeGenerationContext): string;
    /**
     * @param {string} sourceString source content
     * @param {Compilation=} compilation the compilation
     * @returns {Source} generated source
     */
    getSource(sourceString: string, compilation?: Compilation | undefined): Source;
}
declare namespace ContextModule {
    export { Source, WebpackOptions, ChunkGraph, RawChunkGroupOptions, Compilation, DependencyTemplates, BuildMeta, CodeGenerationContext, CodeGenerationResult, LibIdentOptions, NeedBuildContext, ModuleGraph, RequestShortener, ResolverWithOptions, RuntimeTemplate, ContextElementDependency, ObjectDeserializerContext, ObjectSerializerContext, LazySet, InputFileSystem, ContextMode, ContextOptions, ContextModuleOptionsExtras, ContextModuleOptions, ResolveDependenciesCallback, ResolveDependencies };
}
import Module = require("webpack/lib/Module");
type ContextModuleOptions = ContextOptions & ContextModuleOptionsExtras;
type ResolveDependencies = (fs: InputFileSystem, options: ContextModuleOptions, callback: ResolveDependenciesCallback) => any;
type ContextElementDependency = import("./dependencies/ContextElementDependency");
type ChunkGraph = import("./ChunkGraph");
type RuntimeTemplate = import("./RuntimeTemplate");
type CodeGenerationContext = import("./Module").CodeGenerationContext;
type Compilation = import("./Compilation");
type Source = import("webpack-sources").Source;
type WebpackOptions = any;
type RawChunkGroupOptions = import("./ChunkGroup").RawChunkGroupOptions;
type DependencyTemplates = import("./DependencyTemplates");
type BuildMeta = import("./Module").BuildMeta;
type CodeGenerationResult = import("./Module").CodeGenerationResult;
type LibIdentOptions = import("./Module").LibIdentOptions;
type NeedBuildContext = import("./Module").NeedBuildContext;
type ModuleGraph = import("./ModuleGraph");
type RequestShortener = import("./RequestShortener");
type ResolverWithOptions = import("./ResolverFactory").ResolverWithOptions;
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
/**
 * <T>
 */
type LazySet<T> = import("./util/LazySet")<T>;
type InputFileSystem = import("./util/fs").InputFileSystem;
/**
 * Context mode
 */
type ContextMode = "sync" | "eager" | "weak" | "async-weak" | "lazy" | "lazy-once";
type ContextOptions = {
    mode: ContextMode;
    recursive: boolean;
    regExp: RegExp;
    namespaceObject?: ("strict" | boolean) | undefined;
    addon?: string | undefined;
    chunkName?: string | undefined;
    include?: RegExp | undefined;
    exclude?: RegExp | undefined;
    groupOptions?: RawChunkGroupOptions | undefined;
    typePrefix?: string | undefined;
    category?: string | undefined;
    /**
     * exports referenced from modules (won't be mangled)
     */
    referencedExports?: (string[][] | null) | undefined;
    layer?: string | undefined;
};
type ContextModuleOptionsExtras = {
    resource: false | string | string[];
    resourceQuery?: string | undefined;
    resourceFragment?: string | undefined;
    resolveOptions: TODO;
};
type ResolveDependenciesCallback = (err?: (Error | null) | undefined, dependencies?: ContextElementDependency[] | undefined) => any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ContextModuleFactory.d.ts
export = ContextModuleFactory;
declare class ContextModuleFactory extends ModuleFactory {
    /**
     * @param {ResolverFactory} resolverFactory resolverFactory
     */
    constructor(resolverFactory: ResolverFactory);
    hooks: Readonly<{
        /** @type {AsyncSeriesWaterfallHook<[TODO]>} */
        beforeResolve: AsyncSeriesWaterfallHook<[TODO]>;
        /** @type {AsyncSeriesWaterfallHook<[TODO]>} */
        afterResolve: AsyncSeriesWaterfallHook<[TODO]>;
        /** @type {SyncWaterfallHook<[string[]]>} */
        contextModuleFiles: SyncWaterfallHook<[string[]]>;
        /** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, "tap" | "tapAsync" | "tapPromise" | "name">>} */
        alternatives: FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, "tap" | "tapAsync" | "tapPromise" | "name">>;
        alternativeRequests: AsyncSeriesWaterfallHook<[TODO[], ContextModule.ContextModuleOptions], import("tapable").UnsetAdditionalOptions>;
    }>;
    resolverFactory: import("webpack/lib/ResolverFactory");
    /**
     * @param {InputFileSystem} fs file system
     * @param {ContextModuleOptions} options options
     * @param {ResolveDependenciesCallback} callback callback function
     * @returns {void}
     */
    resolveDependencies(fs: InputFileSystem, options: ContextModuleOptions, callback: ResolveDependenciesCallback): void;
}
declare namespace ContextModuleFactory {
    export { ContextModuleOptions, ResolveDependenciesCallback, Module, ModuleFactoryCreateData, ModuleFactoryResult, ResolverFactory, ContextDependency, FakeHook, InputFileSystem };
}
import ModuleFactory = require("webpack/lib/ModuleFactory");
import { AsyncSeriesWaterfallHook } from "tapable";
import { SyncWaterfallHook } from "tapable";
/**
 * <T>
 */
type FakeHook<T> = import("./util/deprecation").FakeHook<T>;
import ContextModule = require("webpack/lib/ContextModule");
type InputFileSystem = import("./util/fs").InputFileSystem;
type ContextModuleOptions = import("./ContextModule").ContextModuleOptions;
type ResolveDependenciesCallback = import("./ContextModule").ResolveDependenciesCallback;
type ResolverFactory = import("./ResolverFactory");
type Module = import("./Module");
type ModuleFactoryCreateData = import("./ModuleFactory").ModuleFactoryCreateData;
type ModuleFactoryResult = import("./ModuleFactory").ModuleFactoryResult;
type ContextDependency = import("./dependencies/ContextDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ContextReplacementPlugin.d.ts
export = ContextReplacementPlugin;
/** @typedef {import("./Compiler")} Compiler */
declare class ContextReplacementPlugin {
    /**
     * @param {RegExp} resourceRegExp A regular expression that determines which files will be selected
     * @param {TODO=} newContentResource A new resource to replace the match
     * @param {TODO=} newContentRecursive If true, all subdirectories are searched for matches
     * @param {TODO=} newContentRegExp A regular expression that determines which files will be selected
     */
    constructor(resourceRegExp: RegExp, newContentResource?: TODO, newContentRecursive?: TODO, newContentRegExp?: TODO);
    resourceRegExp: RegExp;
    newContentCallback: any;
    newContentResource: any;
    newContentCreateContextMap: any;
    newContentRecursive: any;
    newContentRegExp: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ContextReplacementPlugin {
    export { Compiler };
}
type Compiler = import("./Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/CssModule.d.ts
export = CssModule;
/** @typedef {import("./Module")} Module */
/** @typedef {import("./NormalModule").NormalModuleCreateData} NormalModuleCreateData */
/** @typedef {import("./RequestShortener")} RequestShortener */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {string|undefined} CssLayer */
/** @typedef {string|undefined} Supports */
/** @typedef {string|undefined} Media */
/** @typedef {[CssLayer?, Supports?, Media?]} InheritanceItem */
/** @typedef {Array<InheritanceItem>} Inheritance */
/** @typedef {NormalModuleCreateData & { cssLayer: CssLayer|null, supports: Supports|null, media: Media|null, inheritance: Inheritance|null }} CSSModuleCreateData */
declare class CssModule extends NormalModule {
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {CssModule} the deserialized object
     */
    static deserialize(context: ObjectDeserializerContext): CssModule;
    /**
     * @param {CSSModuleCreateData} options options object
     */
    constructor(options: CSSModuleCreateData);
    cssLayer: string;
    supports: string;
    media: string;
    inheritance: Inheritance;
}
declare namespace CssModule {
    export { Module, NormalModuleCreateData, RequestShortener, ObjectDeserializerContext, ObjectSerializerContext, CssLayer, Supports, Media, InheritanceItem, Inheritance, CSSModuleCreateData };
}
import NormalModule = require("webpack/lib/NormalModule");
type Inheritance = Array<[string?, string?, string?]>;
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type CSSModuleCreateData = NormalModuleCreateData & {
    cssLayer: CssLayer | null;
    supports: Supports | null;
    media: Media | null;
    inheritance: InheritanceItem[] | null;
};
type Module = import("./Module");
type NormalModuleCreateData = import("./NormalModule").NormalModuleCreateData;
type RequestShortener = import("./RequestShortener");
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type CssLayer = string | undefined;
type Supports = string | undefined;
type Media = string | undefined;
type InheritanceItem = [CssLayer?, Supports?, Media?];

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DefinePlugin.d.ts
export = DefinePlugin;
declare class DefinePlugin {
    /**
     * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function
     * @param {true | string[] | RuntimeValueOptions=} options options
     * @returns {RuntimeValue} runtime value
     */
    static runtimeValue(fn: (arg0: {
        module: NormalModule;
        key: string;
        readonly version: string | undefined;
    }) => CodeValuePrimitive, options?: (true | string[] | RuntimeValueOptions) | undefined): RuntimeValue;
    /**
     * Create a new define plugin
     * @param {Record<string, CodeValue>} definitions A map of global object definitions
     */
    constructor(definitions: Record<string, CodeValue>);
    definitions: Record<string, RecursiveArrayOrRecord<CodeValuePrimitive | RuntimeValue>>;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DefinePlugin {
    export { Expression, Compiler, NormalModule, RuntimeTemplate, JavascriptParser, Logger, CodeValuePrimitive, CodeValue, RuntimeValueOptions };
}
type CodeValuePrimitive = null | undefined | RegExp | Function | string | number | boolean | bigint | undefined;
/** @typedef {import("estree").Expression} Expression */
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./NormalModule")} NormalModule */
/** @typedef {import("./RuntimeTemplate")} RuntimeTemplate */
/** @typedef {import("./javascript/JavascriptParser")} JavascriptParser */
/** @typedef {import("./logging/Logger").Logger} Logger */
/** @typedef {null|undefined|RegExp|Function|string|number|boolean|bigint|undefined} CodeValuePrimitive */
/** @typedef {RecursiveArrayOrRecord<CodeValuePrimitive|RuntimeValue>} CodeValue */
/**
 * @typedef {Object} RuntimeValueOptions
 * @property {string[]=} fileDependencies
 * @property {string[]=} contextDependencies
 * @property {string[]=} missingDependencies
 * @property {string[]=} buildDependencies
 * @property {string|function(): string=} version
 */
declare class RuntimeValue {
    /**
     * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function
     * @param {true | string[] | RuntimeValueOptions=} options options
     */
    constructor(fn: (arg0: {
        module: NormalModule;
        key: string;
        readonly version: string | undefined;
    }) => CodeValuePrimitive, options?: (true | string[] | RuntimeValueOptions) | undefined);
    fn: (arg0: {
        module: NormalModule;
        key: string;
        readonly version: string | undefined;
    }) => CodeValuePrimitive;
    options: true | RuntimeValueOptions;
    get fileDependencies(): true | string[];
    /**
     * @param {JavascriptParser} parser the parser
     * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions
     * @param {string} key the defined key
     * @returns {CodeValuePrimitive} code
     */
    exec(parser: JavascriptParser, valueCacheVersions: Map<string, string | Set<string>>, key: string): CodeValuePrimitive;
    getCacheVersion(): string;
}
type Compiler = import("./Compiler");
declare namespace module {
    namespace exports {
        export { Expression, Compiler, NormalModule, RuntimeTemplate, JavascriptParser, Logger, CodeValuePrimitive, CodeValue, RuntimeValueOptions };
    }
}
type NormalModule = import("./NormalModule");
type RuntimeValueOptions = {
    fileDependencies?: string[] | undefined;
    contextDependencies?: string[] | undefined;
    missingDependencies?: string[] | undefined;
    buildDependencies?: string[] | undefined;
    version?: (string | (() => string)) | undefined;
};
type CodeValue = RecursiveArrayOrRecord<CodeValuePrimitive | RuntimeValue>;
type Expression = import("estree").Expression;
type RuntimeTemplate = import("./RuntimeTemplate");
type JavascriptParser = import("./javascript/JavascriptParser");
type Logger = import("./logging/Logger").Logger;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DelegatedModule.d.ts
export = DelegatedModule;
declare class DelegatedModule extends Module {
    /**
     * @param {ObjectDeserializerContext} context context\
     * @returns {DelegatedModule} DelegatedModule
     */
    static deserialize(context: ObjectDeserializerContext): DelegatedModule;
    /**
     * @param {string} sourceRequest source request
     * @param {TODO} data data
     * @param {"require" | "object"} type type
     * @param {string} userRequest user request
     * @param {string | Module} originalRequest original request
     */
    constructor(sourceRequest: string, data: TODO, type: "require" | "object", userRequest: string, originalRequest: string | Module);
    sourceRequest: string;
    request: any;
    delegationType: "object" | "require";
    userRequest: string;
    originalRequest: string | Module;
    /** @type {ManifestModuleData | undefined} */
    delegateData: ManifestModuleData | undefined;
    delegatedSourceDependency: DelegatedSourceDependency;
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context: UpdateHashContext): void;
}
declare namespace DelegatedModule {
    export { Source, WebpackOptions, ChunkGraph, Compilation, UpdateHashContext, DependencyTemplates, ManifestModuleData, CodeGenerationContext, CodeGenerationResult, LibIdentOptions, NeedBuildContext, SourceContext, RequestShortener, ResolverWithOptions, RuntimeTemplate, WebpackError, ModuleDependency, ObjectDeserializerContext, ObjectSerializerContext, Hash, InputFileSystem };
}
import Module = require("webpack/lib/Module");
type ManifestModuleData = import("./LibManifestPlugin").ManifestModuleData;
import DelegatedSourceDependency = require("webpack/lib/dependencies/DelegatedSourceDependency");
type Hash = import("./util/Hash");
type UpdateHashContext = import("./Dependency").UpdateHashContext;
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type Source = import("webpack-sources").Source;
type WebpackOptions = any;
type ChunkGraph = import("./ChunkGraph");
type Compilation = import("./Compilation");
type DependencyTemplates = import("./DependencyTemplates");
type CodeGenerationContext = import("./Module").CodeGenerationContext;
type CodeGenerationResult = import("./Module").CodeGenerationResult;
type LibIdentOptions = import("./Module").LibIdentOptions;
type NeedBuildContext = import("./Module").NeedBuildContext;
type SourceContext = import("./Module").SourceContext;
type RequestShortener = import("./RequestShortener");
type ResolverWithOptions = import("./ResolverFactory").ResolverWithOptions;
type RuntimeTemplate = import("./RuntimeTemplate");
type WebpackError = import("./WebpackError");
type ModuleDependency = import("./dependencies/ModuleDependency");
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type InputFileSystem = import("./util/fs").InputFileSystem;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DelegatedModuleFactoryPlugin.d.ts
export = DelegatedModuleFactoryPlugin;
/** @typedef {import("./NormalModuleFactory")} NormalModuleFactory */
declare class DelegatedModuleFactoryPlugin {
    constructor(options: any);
    options: any;
    /**
     * @param {NormalModuleFactory} normalModuleFactory the normal module factory
     * @returns {void}
     */
    apply(normalModuleFactory: NormalModuleFactory): void;
}
declare namespace DelegatedModuleFactoryPlugin {
    export { NormalModuleFactory };
}
type NormalModuleFactory = import("./NormalModuleFactory");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DelegatedPlugin.d.ts
export = DelegatedPlugin;
/** @typedef {import("./Compiler")} Compiler */
declare class DelegatedPlugin {
    constructor(options: any);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DelegatedPlugin {
    export { Compiler };
}
type Compiler = import("./Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DependenciesBlock.d.ts
export = DependenciesBlock;
/** @typedef {import("./AsyncDependenciesBlock")} AsyncDependenciesBlock */
/** @typedef {import("./ChunkGraph")} ChunkGraph */
/** @typedef {import("./ChunkGroup")} ChunkGroup */
/** @typedef {import("./Dependency")} Dependency */
/** @typedef {import("./Dependency").UpdateHashContext} UpdateHashContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("./util/Hash")} Hash */
/** @typedef {(d: Dependency) => boolean} DependencyFilterFunction */
/**
 * DependenciesBlock is the base class for all Module classes in webpack. It describes a
 * "block" of dependencies which are pointers to other DependenciesBlock instances. For example
 * when a Module has a CommonJs require statement, the DependencyBlock for the CommonJs module
 * would be added as a dependency to the Module. DependenciesBlock is inherited by two types of classes:
 * Module subclasses and AsyncDependenciesBlock subclasses. The only difference between the two is that
 * AsyncDependenciesBlock subclasses are used for code-splitting (async boundary) and Module subclasses are not.
 */
declare class DependenciesBlock {
    /** @type {Dependency[]} */
    dependencies: Dependency[];
    /** @type {AsyncDependenciesBlock[]} */
    blocks: AsyncDependenciesBlock[];
    /** @type {DependenciesBlock | undefined} */
    parent: DependenciesBlock | undefined;
    getRootBlock(): DependenciesBlock;
    /**
     * Adds a DependencyBlock to DependencyBlock relationship.
     * This is used for when a Module has a AsyncDependencyBlock tie (for code-splitting)
     *
     * @param {AsyncDependenciesBlock} block block being added
     * @returns {void}
     */
    addBlock(block: AsyncDependenciesBlock): void;
    /**
     * @param {Dependency} dependency dependency being tied to block.
     * This is an "edge" pointing to another "node" on module graph.
     * @returns {void}
     */
    addDependency(dependency: Dependency): void;
    /**
     * @param {Dependency} dependency dependency being removed
     * @returns {void}
     */
    removeDependency(dependency: Dependency): void;
    /**
     * Removes all dependencies and blocks
     * @returns {void}
     */
    clearDependenciesAndBlocks(): void;
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context: UpdateHashContext): void;
    /**
     * @param {ObjectSerializerContext} context context
     */
    serialize({ write }: ObjectSerializerContext): void;
    /**
     * @param {ObjectDeserializerContext} context context
     */
    deserialize({ read }: ObjectDeserializerContext): void;
}
declare namespace DependenciesBlock {
    export { AsyncDependenciesBlock, ChunkGraph, ChunkGroup, Dependency, UpdateHashContext, ObjectDeserializerContext, ObjectSerializerContext, Hash, DependencyFilterFunction };
}
type Dependency = import("./Dependency");
type AsyncDependenciesBlock = import("./AsyncDependenciesBlock");
type Hash = import("./util/Hash");
type UpdateHashContext = import("./Dependency").UpdateHashContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ChunkGraph = import("./ChunkGraph");
type ChunkGroup = import("./ChunkGroup");
type DependencyFilterFunction = (d: Dependency) => boolean;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Dependency.d.ts
export = Dependency;
declare class Dependency {
    /** @type {Module | undefined} */
    _parentModule: Module | undefined;
    /** @type {DependenciesBlock | undefined} */
    _parentDependenciesBlock: DependenciesBlock | undefined;
    /** @type {number} */
    _parentDependenciesBlockIndex: number;
    /** @type {boolean} */
    weak: boolean;
    /** @type {boolean} */
    optional: boolean;
    _locSL: number;
    _locSC: number;
    _locEL: number;
    _locEC: number;
    _locI: any;
    _locN: any;
    _loc: DependencyLocation | (SyntheticDependencyLocation & RealDependencyLocation);
    /**
     * @returns {string} a display name for the type of dependency
     */
    get type(): string;
    /**
     * @returns {string} a dependency category, typical categories are "commonjs", "amd", "esm"
     */
    get category(): string;
    set loc(arg: DependencyLocation);
    /**
     * @returns {DependencyLocation} location
     */
    get loc(): DependencyLocation;
    /**
     * @param {number} startLine start line
     * @param {number} startColumn start column
     * @param {number} endLine end line
     * @param {number} endColumn end column
     */
    setLoc(startLine: number, startColumn: number, endLine: number, endColumn: number): void;
    /**
     * @returns {string | undefined} a request context
     */
    getContext(): string | undefined;
    /**
     * @returns {string | null} an identifier to merge equal requests
     */
    getResourceIdentifier(): string | null;
    /**
     * @returns {boolean | TRANSITIVE} true, when changes to the referenced module could affect the referencing module; TRANSITIVE, when changes to the referenced module could affect referencing modules of the referencing module
     */
    couldAffectReferencingModule(): boolean | typeof TRANSITIVE;
    /**
     * Returns the referenced module and export
     * @deprecated
     * @param {ModuleGraph} moduleGraph module graph
     * @returns {never} throws error
     */
    getReference(moduleGraph: ModuleGraph): never;
    /**
     * Returns list of exports referenced by this dependency
     * @param {ModuleGraph} moduleGraph module graph
     * @param {RuntimeSpec} runtime the runtime for which the module is analysed
     * @returns {(string[] | ReferencedExport)[]} referenced exports
     */
    getReferencedExports(moduleGraph: ModuleGraph, runtime: RuntimeSpec): (string[] | ReferencedExport)[];
    /**
     * @param {ModuleGraph} moduleGraph module graph
     * @returns {null | false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState} function to determine if the connection is active
     */
    getCondition(moduleGraph: ModuleGraph): null | false | ((arg0: ModuleGraphConnection, arg1: RuntimeSpec) => ConnectionState);
    /**
     * Returns the exported names
     * @param {ModuleGraph} moduleGraph module graph
     * @returns {ExportsSpec | undefined} export names
     */
    getExports(moduleGraph: ModuleGraph): ExportsSpec | undefined;
    /**
     * Returns warnings
     * @param {ModuleGraph} moduleGraph module graph
     * @returns {WebpackError[] | null | undefined} warnings
     */
    getWarnings(moduleGraph: ModuleGraph): WebpackError[] | null | undefined;
    /**
     * Returns errors
     * @param {ModuleGraph} moduleGraph module graph
     * @returns {WebpackError[] | null | undefined} errors
     */
    getErrors(moduleGraph: ModuleGraph): WebpackError[] | null | undefined;
    /**
     * Update the hash
     * @param {Hash} hash hash to be updated
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context: UpdateHashContext): void;
    /**
     * implement this method to allow the occurrence order plugin to count correctly
     * @returns {number} count how often the id is used in this dependency
     */
    getNumberOfIdOccurrences(): number;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @returns {ConnectionState} how this dependency connects the module to referencing modules
     */
    getModuleEvaluationSideEffectsState(moduleGraph: ModuleGraph): ConnectionState;
    /**
     * @param {string} context context directory
     * @returns {Module | null} a module
     */
    createIgnoredModule(context: string): Module | null;
    /**
     * @param {ObjectSerializerContext} context context
     */
    serialize({ write }: ObjectSerializerContext): void;
    /**
     * @param {ObjectDeserializerContext} context context
     */
    deserialize({ read }: ObjectDeserializerContext): void;
    set module(arg: any);
    get module(): any;
    get disconnect(): any;
}
declare namespace Dependency {
    export { NO_EXPORTS_REFERENCED, EXPORTS_OBJECT_REFERENCED, TRANSITIVE, Source, ChunkGraph, DependenciesBlock, DependencyTemplates, Module, ModuleGraph, ModuleGraphConnection, ConnectionState, RuntimeTemplate, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeSpec, UpdateHashContext, SourcePosition, RealDependencyLocation, SyntheticDependencyLocation, DependencyLocation, ExportSpec, ExportsSpec, ReferencedExport };
}
type Module = import("./Module");
type DependenciesBlock = import("./DependenciesBlock");
type DependencyLocation = SyntheticDependencyLocation | RealDependencyLocation;
type SyntheticDependencyLocation = {
    name: string;
    index?: number | undefined;
};
type RealDependencyLocation = {
    start: SourcePosition;
    end?: SourcePosition | undefined;
    index?: number | undefined;
};
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("./ChunkGraph")} ChunkGraph */
/** @typedef {import("./DependenciesBlock")} DependenciesBlock */
/** @typedef {import("./DependencyTemplates")} DependencyTemplates */
/** @typedef {import("./Module")} Module */
/** @typedef {import("./ModuleGraph")} ModuleGraph */
/** @typedef {import("./ModuleGraphConnection")} ModuleGraphConnection */
/** @typedef {import("./ModuleGraphConnection").ConnectionState} ConnectionState */
/** @typedef {import("./RuntimeTemplate")} RuntimeTemplate */
/** @typedef {import("./WebpackError")} WebpackError */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("./util/Hash")} Hash */
/** @typedef {import("./util/runtime").RuntimeSpec} RuntimeSpec */
/**
 * @typedef {Object} UpdateHashContext
 * @property {ChunkGraph} chunkGraph
 * @property {RuntimeSpec} runtime
 * @property {RuntimeTemplate=} runtimeTemplate
 */
/**
 * @typedef {Object} SourcePosition
 * @property {number} line
 * @property {number=} column
 */
/**
 * @typedef {Object} RealDependencyLocation
 * @property {SourcePosition} start
 * @property {SourcePosition=} end
 * @property {number=} index
 */
/**
 * @typedef {Object} SyntheticDependencyLocation
 * @property {string} name
 * @property {number=} index
 */
/** @typedef {SyntheticDependencyLocation|RealDependencyLocation} DependencyLocation */
/**
 * @typedef {Object} ExportSpec
 * @property {string} name the name of the export
 * @property {boolean=} canMangle can the export be renamed (defaults to true)
 * @property {boolean=} terminalBinding is the export a terminal binding that should be checked for export star conflicts
 * @property {(string | ExportSpec)[]=} exports nested exports
 * @property {ModuleGraphConnection=} from when reexported: from which module
 * @property {string[] | null=} export when reexported: from which export
 * @property {number=} priority when reexported: with which priority
 * @property {boolean=} hidden export is not visible, because another export blends over it
 */
/**
 * @typedef {Object} ExportsSpec
 * @property {(string | ExportSpec)[] | true | null} exports exported names, true for unknown exports or null for no exports
 * @property {Set<string>=} excludeExports when exports = true, list of unaffected exports
 * @property {Set<string>=} hideExports list of maybe prior exposed, but now hidden exports
 * @property {ModuleGraphConnection=} from when reexported: from which module
 * @property {number=} priority when reexported: with which priority
 * @property {boolean=} canMangle can the export be renamed (defaults to true)
 * @property {boolean=} terminalBinding are the exports terminal bindings that should be checked for export star conflicts
 * @property {Module[]=} dependencies module on which the result depends on
 */
/**
 * @typedef {Object} ReferencedExport
 * @property {string[]} name name of the referenced export
 * @property {boolean=} canMangle when false, referenced export can not be mangled, defaults to true
 */
declare const TRANSITIVE: unique symbol;
type ModuleGraph = import("./ModuleGraph");
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
type ReferencedExport = {
    /**
     * name of the referenced export
     */
    name: string[];
    /**
     * when false, referenced export can not be mangled, defaults to true
     */
    canMangle?: boolean | undefined;
};
type ModuleGraphConnection = import("./ModuleGraphConnection");
type ConnectionState = import("./ModuleGraphConnection").ConnectionState;
type ExportsSpec = {
    /**
     * exported names, true for unknown exports or null for no exports
     */
    exports: (string | ExportSpec)[] | true | null;
    /**
     * when exports = true, list of unaffected exports
     */
    excludeExports?: Set<string> | undefined;
    /**
     * list of maybe prior exposed, but now hidden exports
     */
    hideExports?: Set<string> | undefined;
    /**
     * when reexported: from which module
     */
    from?: ModuleGraphConnection | undefined;
    /**
     * when reexported: with which priority
     */
    priority?: number | undefined;
    /**
     * can the export be renamed (defaults to true)
     */
    canMangle?: boolean | undefined;
    /**
     * are the exports terminal bindings that should be checked for export star conflicts
     */
    terminalBinding?: boolean | undefined;
    /**
     * module on which the result depends on
     */
    dependencies?: Module[] | undefined;
};
type WebpackError = import("./WebpackError");
type Hash = import("./util/Hash");
type UpdateHashContext = {
    chunkGraph: ChunkGraph;
    runtime: RuntimeSpec;
    runtimeTemplate?: RuntimeTemplate | undefined;
};
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
declare var NO_EXPORTS_REFERENCED: string[][];
declare var EXPORTS_OBJECT_REFERENCED: string[][];
type Source = import("webpack-sources").Source;
type ChunkGraph = import("./ChunkGraph");
type DependencyTemplates = import("./DependencyTemplates");
type RuntimeTemplate = import("./RuntimeTemplate");
type SourcePosition = {
    line: number;
    column?: number | undefined;
};
type ExportSpec = {
    /**
     * the name of the export
     */
    name: string;
    /**
     * can the export be renamed (defaults to true)
     */
    canMangle?: boolean | undefined;
    /**
     * is the export a terminal binding that should be checked for export star conflicts
     */
    terminalBinding?: boolean | undefined;
    /**
     * nested exports
     */
    exports?: (string | ExportSpec)[] | undefined;
    /**
     * when reexported: from which module
     */
    from?: ModuleGraphConnection | undefined;
    /**
     * when reexported: from which export
     */
    export?: (string[] | null) | undefined;
    /**
     * when reexported: with which priority
     */
    priority?: number | undefined;
    /**
     * export is not visible, because another export blends over it
     */
    hidden?: boolean | undefined;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DependencyTemplate.d.ts
export = DependencyTemplate;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("./ChunkGraph")} ChunkGraph */
/** @typedef {import("./CodeGenerationResults")} CodeGenerationResults */
/** @typedef {import("./ConcatenationScope")} ConcatenationScope */
/** @typedef {import("./Dependency")} Dependency */
/** @typedef {import("./Dependency").RuntimeSpec} RuntimeSpec */
/** @typedef {import("./DependencyTemplates")} DependencyTemplates */
/** @typedef {import("./Generator").GenerateContext} GenerateContext */
/** @template T @typedef {import("./InitFragment")<T>} InitFragment */
/** @typedef {import("./Module")} Module */
/** @typedef {import("./ModuleGraph")} ModuleGraph */
/** @typedef {import("./RuntimeTemplate")} RuntimeTemplate */
/**
 * @typedef {Object} DependencyTemplateContext
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {Set<string>} runtimeRequirements the requirements for runtime
 * @property {Module} module current module
 * @property {RuntimeSpec} runtime current runtimes, for which code is generated
 * @property {InitFragment<GenerateContext>[]} initFragments mutable array of init fragments for the current module
 * @property {ConcatenationScope=} concatenationScope when in a concatenated module, information about other concatenated modules
 * @property {CodeGenerationResults} codeGenerationResults the code generation results
 */
/**
 * @typedef {Object} CssDependencyTemplateContextExtras
 * @property {Map<string, string>} cssExports the css exports
 */
/** @typedef {DependencyTemplateContext & CssDependencyTemplateContextExtras} CssDependencyTemplateContext */
declare class DependencyTemplate {
    /**
     * @abstract
     * @param {Dependency} dependency the dependency for which the template should be applied
     * @param {ReplaceSource} source the current replace source which can be modified
     * @param {DependencyTemplateContext} templateContext the context object
     * @returns {void}
     */
    apply(dependency: Dependency, source: ReplaceSource, templateContext: DependencyTemplateContext): void;
}
declare namespace DependencyTemplate {
    export { ReplaceSource, ChunkGraph, CodeGenerationResults, ConcatenationScope, Dependency, RuntimeSpec, DependencyTemplates, GenerateContext, InitFragment, Module, ModuleGraph, RuntimeTemplate, DependencyTemplateContext, CssDependencyTemplateContextExtras, CssDependencyTemplateContext };
}
type Dependency = import("./Dependency");
type ReplaceSource = import("webpack-sources").ReplaceSource;
type DependencyTemplateContext = {
    /**
     * the runtime template
     */
    runtimeTemplate: RuntimeTemplate;
    /**
     * the dependency templates
     */
    dependencyTemplates: DependencyTemplates;
    /**
     * the module graph
     */
    moduleGraph: ModuleGraph;
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
    /**
     * the requirements for runtime
     */
    runtimeRequirements: Set<string>;
    /**
     * current module
     */
    module: Module;
    /**
     * current runtimes, for which code is generated
     */
    runtime: RuntimeSpec;
    /**
     * mutable array of init fragments for the current module
     */
    initFragments: InitFragment<GenerateContext>[];
    /**
     * when in a concatenated module, information about other concatenated modules
     */
    concatenationScope?: ConcatenationScope | undefined;
    /**
     * the code generation results
     */
    codeGenerationResults: CodeGenerationResults;
};
type ChunkGraph = import("./ChunkGraph");
type CodeGenerationResults = import("./CodeGenerationResults");
type ConcatenationScope = import("./ConcatenationScope");
type RuntimeSpec = import("./Dependency").RuntimeSpec;
type DependencyTemplates = import("./DependencyTemplates");
type GenerateContext = import("./Generator").GenerateContext;
type InitFragment<T> = import("./InitFragment")<T>;
type Module = import("./Module");
type ModuleGraph = import("./ModuleGraph");
type RuntimeTemplate = import("./RuntimeTemplate");
type CssDependencyTemplateContextExtras = {
    /**
     * the css exports
     */
    cssExports: Map<string, string>;
};
type CssDependencyTemplateContext = DependencyTemplateContext & CssDependencyTemplateContextExtras;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DependencyTemplates.d.ts
export = DependencyTemplates;
/** @typedef {import("./Dependency")} Dependency */
/** @typedef {import("./DependencyTemplate")} DependencyTemplate */
/** @typedef {typeof import("./util/Hash")} Hash */
/** @typedef {new (...args: any[]) => Dependency} DependencyConstructor */
declare class DependencyTemplates {
    /**
     * @param {string | Hash} hashFunction the hash function to use
     */
    constructor(hashFunction?: string | Hash);
    /** @type {Map<Function, DependencyTemplate>} */
    _map: Map<Function, DependencyTemplate>;
    /** @type {string} */
    _hash: string;
    _hashFunction: string | typeof import("webpack/lib/util/Hash");
    /**
     * @param {DependencyConstructor} dependency Constructor of Dependency
     * @returns {DependencyTemplate | undefined} template for this dependency
     */
    get(dependency: DependencyConstructor): DependencyTemplate | undefined;
    /**
     * @param {DependencyConstructor} dependency Constructor of Dependency
     * @param {DependencyTemplate} dependencyTemplate template for this dependency
     * @returns {void}
     */
    set(dependency: DependencyConstructor, dependencyTemplate: DependencyTemplate): void;
    /**
     * @param {string} part additional hash contributor
     * @returns {void}
     */
    updateHash(part: string): void;
    getHash(): string;
    clone(): DependencyTemplates;
}
declare namespace DependencyTemplates {
    export { Dependency, DependencyTemplate, Hash, DependencyConstructor };
}
type DependencyTemplate = import("./DependencyTemplate");
type DependencyConstructor = new (...args: any[]) => Dependency;
type Hash = typeof import("./util/Hash");
type Dependency = import("./Dependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DllEntryPlugin.d.ts
export = DllEntryPlugin;
/** @typedef {import("./Compiler")} Compiler */
declare class DllEntryPlugin {
    /**
     * @param {string} context context
     * @param {string[]} entries entry names
     * @param {TODO} options options
     */
    constructor(context: string, entries: string[], options: TODO);
    context: string;
    entries: string[];
    options: TODO;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DllEntryPlugin {
    export { Compiler };
}
type Compiler = import("./Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DllModule.d.ts
export = DllModule;
declare class DllModule extends Module {
    /**
     * @param {string} context context path
     * @param {Dependency[]} dependencies dependencies
     * @param {string} name name
     */
    constructor(context: string, dependencies: Dependency[], name: string);
    name: string;
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context: UpdateHashContext): void;
}
declare namespace DllModule {
    export { Source, WebpackOptions, ChunkGraph, Compilation, Dependency, UpdateHashContext, DependencyTemplates, CodeGenerationContext, CodeGenerationResult, NeedBuildContext, SourceContext, RequestShortener, ResolverWithOptions, RuntimeTemplate, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, Hash, InputFileSystem };
}
import Module = require("webpack/lib/Module");
type Hash = import("./util/Hash");
type UpdateHashContext = import("./Dependency").UpdateHashContext;
type Dependency = import("./Dependency");
type Source = import("webpack-sources").Source;
type WebpackOptions = any;
type ChunkGraph = import("./ChunkGraph");
type Compilation = import("./Compilation");
type DependencyTemplates = import("./DependencyTemplates");
type CodeGenerationContext = import("./Module").CodeGenerationContext;
type CodeGenerationResult = import("./Module").CodeGenerationResult;
type NeedBuildContext = import("./Module").NeedBuildContext;
type SourceContext = import("./Module").SourceContext;
type RequestShortener = import("./RequestShortener");
type ResolverWithOptions = import("./ResolverFactory").ResolverWithOptions;
type RuntimeTemplate = import("./RuntimeTemplate");
type WebpackError = import("./WebpackError");
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type InputFileSystem = import("./util/fs").InputFileSystem;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DllModuleFactory.d.ts
export = DllModuleFactory;
/** @typedef {import("./ModuleFactory").ModuleFactoryCreateData} ModuleFactoryCreateData */
/** @typedef {import("./ModuleFactory").ModuleFactoryResult} ModuleFactoryResult */
/** @typedef {import("./dependencies/DllEntryDependency")} DllEntryDependency */
declare class DllModuleFactory extends ModuleFactory {
    hooks: Readonly<{}>;
}
declare namespace DllModuleFactory {
    export { ModuleFactoryCreateData, ModuleFactoryResult, DllEntryDependency };
}
import ModuleFactory = require("webpack/lib/ModuleFactory");
type ModuleFactoryCreateData = import("./ModuleFactory").ModuleFactoryCreateData;
type ModuleFactoryResult = import("./ModuleFactory").ModuleFactoryResult;
type DllEntryDependency = import("./dependencies/DllEntryDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DllPlugin.d.ts
export = DllPlugin;
declare class DllPlugin {
    /**
     * @param {DllPluginOptions} options options object
     */
    constructor(options: any);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DllPlugin {
    export { DllPluginOptions, Compiler };
}
type Compiler = import("./Compiler");
type DllPluginOptions = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DllReferencePlugin.d.ts
export = DllReferencePlugin;
declare class DllReferencePlugin {
    /**
     * @param {DllReferencePluginOptions} options options object
     */
    constructor(options: any);
    options: any;
    /** @type {WeakMap<Object, {path: string, data: DllReferencePluginOptionsManifest?, error: Error?}>} */
    _compilationData: WeakMap<any, {
        path: string;
        data: DllReferencePluginOptionsManifest | null;
        error: Error | null;
    }>;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DllReferencePlugin {
    export { Externals, DllReferencePluginOptions, DllReferencePluginOptionsManifest, Compiler };
}
type DllReferencePluginOptionsManifest = any;
type Compiler = import("./Compiler");
type Externals = any;
type DllReferencePluginOptions = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/DynamicEntryPlugin.d.ts
export = DynamicEntryPlugin;
/** @typedef {import("../declarations/WebpackOptions").EntryDynamicNormalized} EntryDynamic */
/** @typedef {import("../declarations/WebpackOptions").EntryItem} EntryItem */
/** @typedef {import("../declarations/WebpackOptions").EntryStaticNormalized} EntryStatic */
/** @typedef {import("./Compiler")} Compiler */
declare class DynamicEntryPlugin {
    /**
     * @param {string} context the context path
     * @param {EntryDynamic} entry the entry value
     */
    constructor(context: string, entry: any);
    context: string;
    entry: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DynamicEntryPlugin {
    export { EntryDynamic, EntryItem, EntryStatic, Compiler };
}
type Compiler = import("./Compiler");
type EntryDynamic = any;
type EntryItem = any;
type EntryStatic = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/EntryOptionPlugin.d.ts
export = EntryOptionPlugin;
/** @typedef {import("../declarations/WebpackOptions").EntryDescriptionNormalized} EntryDescription */
/** @typedef {import("../declarations/WebpackOptions").EntryNormalized} Entry */
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./Entrypoint").EntryOptions} EntryOptions */
declare class EntryOptionPlugin {
    /**
     * @param {Compiler} compiler the compiler
     * @param {string} context context directory
     * @param {Entry} entry request
     * @returns {void}
     */
    static applyEntryOption(compiler: Compiler, context: string, entry: any): void;
    /**
     * @param {Compiler} compiler the compiler
     * @param {string} name entry name
     * @param {EntryDescription} desc entry description
     * @returns {EntryOptions} options for the entry
     */
    static entryDescriptionToOptions(compiler: Compiler, name: string, desc: any): EntryOptions;
    /**
     * @param {Compiler} compiler the compiler instance one is tapping into
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace EntryOptionPlugin {
    export { EntryDescription, Entry, Compiler, EntryOptions };
}
type Compiler = import("./Compiler");
type EntryOptions = import("./Entrypoint").EntryOptions;
type EntryDescription = any;
type Entry = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/EntryPlugin.d.ts
export = EntryPlugin;
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./Entrypoint").EntryOptions} EntryOptions */
declare class EntryPlugin {
    /**
     * @param {string} entry entry request
     * @param {EntryOptions | string} options entry options (passing string is deprecated)
     * @returns {EntryDependency} the dependency
     */
    static createDependency(entry: string, options: EntryOptions | string): EntryDependency;
    /**
     * An entry plugin which will handle
     * creation of the EntryDependency
     *
     * @param {string} context context path
     * @param {string} entry entry path
     * @param {EntryOptions | string=} options entry options (passing a string is deprecated)
     */
    constructor(context: string, entry: string, options?: (EntryOptions | string) | undefined);
    context: string;
    entry: string;
    options: string | import("webpack/lib/Entrypoint").EntryOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace EntryPlugin {
    export { Compiler, EntryOptions };
}
type Compiler = import("./Compiler");
type EntryOptions = import("./Entrypoint").EntryOptions;
import EntryDependency = require("webpack/lib/dependencies/EntryDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Entrypoint.d.ts
export = Entrypoint;
/** @typedef {import("../declarations/WebpackOptions").EntryDescriptionNormalized} EntryDescription */
/** @typedef {import("./Chunk")} Chunk */
/** @typedef {{ name?: string } & Omit<EntryDescription, "import">} EntryOptions */
/**
 * Entrypoint serves as an encapsulation primitive for chunks that are
 * a part of a single ChunkGroup. They represent all bundles that need to be loaded for a
 * single instance of a page. Multi-page application architectures will typically yield multiple Entrypoint objects
 * inside of the compilation, whereas a Single Page App may only contain one with many lazy-loaded chunks.
 */
declare class Entrypoint extends ChunkGroup {
    /**
     * Creates an instance of Entrypoint.
     * @param {EntryOptions | string} entryOptions the options for the entrypoint (or name)
     * @param {boolean=} initial false, when the entrypoint is not initial loaded
     */
    constructor(entryOptions: EntryOptions | string, initial?: boolean | undefined);
    options: EntryOptions;
    /** @type {Chunk=} */
    _runtimeChunk: Chunk | undefined;
    /** @type {Chunk=} */
    _entrypointChunk: Chunk | undefined;
    /** @type {boolean} */
    _initial: boolean;
    /**
     * Sets the runtimeChunk for an entrypoint.
     * @param {Chunk} chunk the chunk being set as the runtime chunk.
     * @returns {void}
     */
    setRuntimeChunk(chunk: Chunk): void;
    /**
     * Fetches the chunk reference containing the webpack bootstrap code
     * @returns {Chunk | null} returns the runtime chunk or null if there is none
     */
    getRuntimeChunk(): Chunk | null;
    /**
     * Sets the chunk with the entrypoint modules for an entrypoint.
     * @param {Chunk} chunk the chunk being set as the entrypoint chunk.
     * @returns {void}
     */
    setEntrypointChunk(chunk: Chunk): void;
    /**
     * Returns the chunk which contains the entrypoint modules
     * (or at least the execution of them)
     * @returns {Chunk} chunk
     */
    getEntrypointChunk(): Chunk;
}
declare namespace Entrypoint {
    export { EntryDescription, Chunk, EntryOptions };
}
import ChunkGroup = require("webpack/lib/ChunkGroup");
type EntryOptions = {
    name?: string;
} & Omit<EntryDescription, "import">;
type Chunk = import("./Chunk");
type EntryDescription = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/EnvironmentPlugin.d.ts
export = EnvironmentPlugin;
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./DefinePlugin").CodeValue} CodeValue */
declare class EnvironmentPlugin {
    constructor(...keys: any[]);
    keys: any[];
    defaultValues: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace EnvironmentPlugin {
    export { Compiler, CodeValue };
}
type Compiler = import("./Compiler");
type CodeValue = import("./DefinePlugin").CodeValue;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ErrorHelpers.d.ts
/**
 * @param {string} stack stack trace
 * @param {string} flag flag to cut off
 * @returns {string} stack trace without the specified flag included
 */
export function cutOffByFlag(stack: string, flag: string): string;
/**
 * @param {string} stack stack trace
 * @returns {string} stack trace without the loader execution flag included
 */
export function cutOffLoaderExecution(stack: string): string;
/**
 * @param {string} stack stack trace
 * @returns {string} stack trace without the webpack options flag included
 */
export function cutOffWebpackOptions(stack: string): string;
/**
 * @param {string} stack stack trace
 * @param {string} message error message
 * @returns {string} stack trace without the message included
 */
export function cutOffMultilineMessage(stack: string, message: string): string;
/**
 * @param {string} stack stack trace
 * @param {string} message error message
 * @returns {string} stack trace without the message included
 */
export function cutOffMessage(stack: string, message: string): string;
/**
 * @param {string} stack stack trace
 * @param {string} message error message
 * @returns {string} stack trace without the loader execution flag and message included
 */
export function cleanUp(stack: string, message: string): string;
/**
 * @param {string} stack stack trace
 * @param {string} message error message
 * @returns {string} stack trace without the webpack options flag and message included
 */
export function cleanUpWebpackOptions(stack: string, message: string): string;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/EvalDevToolModulePlugin.d.ts
export = EvalDevToolModulePlugin;
declare class EvalDevToolModulePlugin {
    constructor(options: any);
    namespace: any;
    sourceUrlComment: any;
    moduleFilenameTemplate: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace EvalDevToolModulePlugin {
    export { Source, Compiler };
}
type Compiler = import("./Compiler");
type Source = import("webpack-sources").Source;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/EvalSourceMapDevToolPlugin.d.ts
export = EvalSourceMapDevToolPlugin;
declare class EvalSourceMapDevToolPlugin {
    /**
     * @param {SourceMapDevToolPluginOptions|string} inputOptions Options object
     */
    constructor(inputOptions: SourceMapDevToolPluginOptions | string);
    sourceMapComment: any;
    moduleFilenameTemplate: any;
    namespace: any;
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace EvalSourceMapDevToolPlugin {
    export { Source, DevToolOptions, SourceMapDevToolPluginOptions, Compiler, SourceMap };
}
type Compiler = import("./Compiler");
type SourceMapDevToolPluginOptions = any;
type Source = import("webpack-sources").Source;
type DevToolOptions = any;
type SourceMap = import("./NormalModule").SourceMap;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ExportsInfo.d.ts
export = ExportsInfo;
declare class ExportsInfo {
    /** @type {Map<string, ExportInfo>} */
    _exports: Map<string, ExportInfo>;
    _otherExportsInfo: ExportInfo;
    _sideEffectsOnlyInfo: ExportInfo;
    _exportsAreOrdered: boolean;
    /** @type {ExportsInfo=} */
    _redirectTo: ExportsInfo | undefined;
    /**
     * @returns {Iterable<ExportInfo>} all owned exports in any order
     */
    get ownedExports(): Iterable<ExportInfo>;
    /**
     * @returns {Iterable<ExportInfo>} all owned exports in order
     */
    get orderedOwnedExports(): Iterable<ExportInfo>;
    /**
     * @returns {Iterable<ExportInfo>} all exports in any order
     */
    get exports(): Iterable<ExportInfo>;
    /**
     * @returns {Iterable<ExportInfo>} all exports in order
     */
    get orderedExports(): Iterable<ExportInfo>;
    /**
     * @returns {ExportInfo} the export info of unlisted exports
     */
    get otherExportsInfo(): ExportInfo;
    _sortExportsMap(exports: any): void;
    _sortExports(): void;
    setRedirectNamedTo(exportsInfo: any): boolean;
    setHasProvideInfo(): void;
    setHasUseInfo(): void;
    /**
     * @param {string} name export name
     * @returns {ExportInfo} export info for this name
     */
    getOwnExportInfo(name: string): ExportInfo;
    /**
     * @param {string} name export name
     * @returns {ExportInfo} export info for this name
     */
    getExportInfo(name: string): ExportInfo;
    /**
     * @param {string} name export name
     * @returns {ExportInfo} export info for this name
     */
    getReadOnlyExportInfo(name: string): ExportInfo;
    /**
     * @param {string[]} name export name
     * @returns {ExportInfo | undefined} export info for this name
     */
    getReadOnlyExportInfoRecursive(name: string[]): ExportInfo | undefined;
    /**
     * @param {string[]=} name the export name
     * @returns {ExportsInfo | undefined} the nested exports info
     */
    getNestedExportsInfo(name?: string[] | undefined): ExportsInfo | undefined;
    /**
     * @param {boolean=} canMangle true, if exports can still be mangled (defaults to false)
     * @param {Set<string>=} excludeExports list of unaffected exports
     * @param {any=} targetKey use this as key for the target
     * @param {ModuleGraphConnection=} targetModule set this module as target
     * @param {number=} priority priority
     * @returns {boolean} true, if this call changed something
     */
    setUnknownExportsProvided(canMangle?: boolean | undefined, excludeExports?: Set<string> | undefined, targetKey?: any | undefined, targetModule?: ModuleGraphConnection | undefined, priority?: number | undefined): boolean;
    /**
     * @param {RuntimeSpec} runtime the runtime
     * @returns {boolean} true, when something changed
     */
    setUsedInUnknownWay(runtime: RuntimeSpec): boolean;
    /**
     * @param {RuntimeSpec} runtime the runtime
     * @returns {boolean} true, when something changed
     */
    setUsedWithoutInfo(runtime: RuntimeSpec): boolean;
    /**
     * @param {RuntimeSpec} runtime the runtime
     * @returns {boolean} true, when something changed
     */
    setAllKnownExportsUsed(runtime: RuntimeSpec): boolean;
    /**
     * @param {RuntimeSpec} runtime the runtime
     * @returns {boolean} true, when something changed
     */
    setUsedForSideEffectsOnly(runtime: RuntimeSpec): boolean;
    /**
     * @param {RuntimeSpec} runtime the runtime
     * @returns {boolean} true, when the module exports are used in any way
     */
    isUsed(runtime: RuntimeSpec): boolean;
    /**
     * @param {RuntimeSpec} runtime the runtime
     * @returns {boolean} true, when the module is used in any way
     */
    isModuleUsed(runtime: RuntimeSpec): boolean;
    /**
     * @param {RuntimeSpec} runtime the runtime
     * @returns {SortableSet<string> | boolean | null} set of used exports, or true (when namespace object is used), or false (when unused), or null (when unknown)
     */
    getUsedExports(runtime: RuntimeSpec): SortableSet<string> | boolean | null;
    /**
     * @returns {null | true | string[]} list of exports when known
     */
    getProvidedExports(): null | true | string[];
    /**
     * @param {RuntimeSpec} runtime the runtime
     * @returns {ExportInfo[]} exports that are relevant (not unused and potential provided)
     */
    getRelevantExports(runtime: RuntimeSpec): ExportInfo[];
    /**
     * @param {string | string[]} name the name of the export
     * @returns {boolean | undefined | null} if the export is provided
     */
    isExportProvided(name: string | string[]): boolean | undefined | null;
    /**
     * @param {RuntimeSpec} runtime runtime
     * @returns {string} key representing the usage
     */
    getUsageKey(runtime: RuntimeSpec): string;
    /**
     * @param {RuntimeSpec} runtimeA first runtime
     * @param {RuntimeSpec} runtimeB second runtime
     * @returns {boolean} true, when equally used
     */
    isEquallyUsed(runtimeA: RuntimeSpec, runtimeB: RuntimeSpec): boolean;
    /**
     * @param {string | string[]} name export name
     * @param {RuntimeSpec} runtime check usage for this runtime only
     * @returns {UsageStateType} usage status
     */
    getUsed(name: string | string[], runtime: RuntimeSpec): UsageStateType;
    /**
     * @param {string | string[]} name the export name
     * @param {RuntimeSpec} runtime check usage for this runtime only
     * @returns {string | string[] | false} the used name
     */
    getUsedName(name: string | string[], runtime: RuntimeSpec): string | string[] | false;
    /**
     * @param {Hash} hash the hash
     * @param {RuntimeSpec} runtime the runtime
     * @returns {void}
     */
    updateHash(hash: Hash, runtime: RuntimeSpec): void;
    /**
     * @param {Hash} hash the hash
     * @param {RuntimeSpec} runtime the runtime
     * @param {Set<ExportsInfo>} alreadyVisitedExportsInfo for circular references
     * @returns {void}
     */
    _updateHash(hash: Hash, runtime: RuntimeSpec, alreadyVisitedExportsInfo: Set<ExportsInfo>): void;
    getRestoreProvidedData(): RestoreProvidedData;
    /**
     * @param {{ otherProvided: any, otherCanMangleProvide: any, otherTerminalBinding: any, exports: any }} data data
     */
    restoreProvided({ otherProvided, otherCanMangleProvide, otherTerminalBinding, exports }: {
        otherProvided: any;
        otherCanMangleProvide: any;
        otherTerminalBinding: any;
        exports: any;
    }): void;
}
declare namespace ExportsInfo {
    export { ExportInfo, UsageState, RuntimeSpec, Module, ModuleGraph, ModuleGraphConnection, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeUsageStateType, UsageStateType };
}
declare class ExportInfo {
    /**
     * @param {string} name the original name of the export
     * @param {ExportInfo=} initFrom init values from this ExportInfo
     */
    constructor(name: string, initFrom?: ExportInfo | undefined);
    /** @type {string} */
    name: string;
    /** @private @type {string | null} */
    private _usedName;
    /** @private @type {UsageStateType} */
    private _globalUsed;
    /** @private @type {Map<string, RuntimeUsageStateType>} */
    private _usedInRuntime;
    /** @private @type {boolean} */
    private _hasUseInRuntimeInfo;
    /**
     * true: it is provided
     * false: it is not provided
     * null: only the runtime knows if it is provided
     * undefined: it was not determined if it is provided
     * @type {boolean | null | undefined}
     */
    provided: boolean | null | undefined;
    /**
     * is the export a terminal binding that should be checked for export star conflicts
     * @type {boolean}
     */
    terminalBinding: boolean;
    /**
     * true: it can be mangled
     * false: is can not be mangled
     * undefined: it was not determined if it can be mangled
     * @type {boolean | undefined}
     */
    canMangleProvide: boolean | undefined;
    /**
     * true: it can be mangled
     * false: is can not be mangled
     * undefined: it was not determined if it can be mangled
     * @type {boolean | undefined}
     */
    canMangleUse: boolean | undefined;
    /** @type {boolean} */
    exportsInfoOwned: boolean;
    /** @type {ExportsInfo=} */
    exportsInfo: ExportsInfo | undefined;
    /** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */
    _target: Map<any, {
        connection: ModuleGraphConnection | null;
        export: string[];
        priority: number;
    }> | undefined;
    /** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */
    _maxTarget: Map<any, {
        connection: ModuleGraphConnection | null;
        export: string[];
        priority: number;
    }> | undefined;
    /**
     * @private
     * @param {*} v v
     */
    private set used(arg);
    /** @private */
    private get used();
    /**
     * @private
     * @param {*} v v
     */
    private set usedName(arg);
    /** @private */
    private get usedName();
    get canMangle(): boolean;
    /**
     * @param {RuntimeSpec} runtime only apply to this runtime
     * @returns {boolean} true, when something changed
     */
    setUsedInUnknownWay(runtime: RuntimeSpec): boolean;
    /**
     * @param {RuntimeSpec} runtime only apply to this runtime
     * @returns {boolean} true, when something changed
     */
    setUsedWithoutInfo(runtime: RuntimeSpec): boolean;
    setHasUseInfo(): void;
    /**
     * @param {function(UsageStateType): boolean} condition compare with old value
     * @param {UsageStateType} newValue set when condition is true
     * @param {RuntimeSpec} runtime only apply to this runtime
     * @returns {boolean} true when something has changed
     */
    setUsedConditionally(condition: (arg0: UsageStateType) => boolean, newValue: UsageStateType, runtime: RuntimeSpec): boolean;
    /**
     * @param {UsageStateType} newValue new value of the used state
     * @param {RuntimeSpec} runtime only apply to this runtime
     * @returns {boolean} true when something has changed
     */
    setUsed(newValue: UsageStateType, runtime: RuntimeSpec): boolean;
    /**
     * @param {any} key the key
     * @returns {boolean} true, if something has changed
     */
    unsetTarget(key: any): boolean;
    /**
     * @param {any} key the key
     * @param {ModuleGraphConnection} connection the target module if a single one
     * @param {string[]=} exportName the exported name
     * @param {number=} priority priority
     * @returns {boolean} true, if something has changed
     */
    setTarget(key: any, connection: ModuleGraphConnection, exportName?: string[] | undefined, priority?: number | undefined): boolean;
    /**
     * @param {RuntimeSpec} runtime for this runtime
     * @returns {UsageStateType} usage state
     */
    getUsed(runtime: RuntimeSpec): UsageStateType;
    /**
     * get used name
     * @param {string | undefined} fallbackName fallback name for used exports with no name
     * @param {RuntimeSpec} runtime check usage for this runtime only
     * @returns {string | false} used name
     */
    getUsedName(fallbackName: string | undefined, runtime: RuntimeSpec): string | false;
    /**
     * @returns {boolean} true, when a mangled name of this export is set
     */
    hasUsedName(): boolean;
    /**
     * Sets the mangled name of this export
     * @param {string} name the new name
     * @returns {void}
     */
    setUsedName(name: string): void;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target
     * @returns {ExportInfo | ExportsInfo | undefined} the terminal binding export(s) info if known
     */
    getTerminalBinding(moduleGraph: ModuleGraph, resolveTargetFilter?: (arg0: {
        module: Module;
        export: string[] | undefined;
    }) => boolean): ExportInfo | ExportsInfo | undefined;
    isReexport(): boolean;
    _getMaxTarget(): Map<any, any>;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {function(Module): boolean} validTargetModuleFilter a valid target module
     * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid
     */
    findTarget(moduleGraph: ModuleGraph, validTargetModuleFilter: (arg0: Module) => boolean): {
        module: Module;
        export: string[] | undefined;
    } | undefined | false;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {function(Module): boolean} validTargetModuleFilter a valid target module
     * @param {Set<ExportInfo>} alreadyVisited set of already visited export info to avoid circular references
     * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid
     */
    _findTarget(moduleGraph: ModuleGraph, validTargetModuleFilter: (arg0: Module) => boolean, alreadyVisited: Set<ExportInfo>): {
        module: Module;
        export: string[] | undefined;
    } | undefined | false;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target
     * @returns {{ module: Module, export: string[] | undefined } | undefined} the target
     */
    getTarget(moduleGraph: ModuleGraph, resolveTargetFilter?: (arg0: {
        module: Module;
        export: string[] | undefined;
    }) => boolean): {
        module: Module;
        export: string[] | undefined;
    } | undefined;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {function({ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target
     * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references
     * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | undefined} the target
     */
    _getTarget(moduleGraph: ModuleGraph, resolveTargetFilter: (arg0: {
        module: Module;
        connection: ModuleGraphConnection;
        export: string[] | undefined;
    }) => boolean, alreadyVisited: Set<ExportInfo> | undefined): {
        module: Module;
        connection: ModuleGraphConnection;
        export: string[] | undefined;
    } | typeof CIRCULAR | undefined;
    /**
     * Move the target forward as long resolveTargetFilter is fulfilled
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target
     * @param {function({ module: Module, export: string[] | undefined }): ModuleGraphConnection=} updateOriginalConnection updates the original connection instead of using the target connection
     * @returns {{ module: Module, export: string[] | undefined } | undefined} the resolved target when moved
     */
    moveTarget(moduleGraph: ModuleGraph, resolveTargetFilter: (arg0: {
        module: Module;
        export: string[] | undefined;
    }) => boolean, updateOriginalConnection?: ((arg0: {
        module: Module;
        export: string[] | undefined;
    }) => ModuleGraphConnection) | undefined): {
        module: Module;
        export: string[] | undefined;
    } | undefined;
    createNestedExportsInfo(): ExportsInfo;
    getNestedExportsInfo(): ExportsInfo;
    hasInfo(baseInfo: any, runtime: any): boolean;
    updateHash(hash: any, runtime: any): void;
    _updateHash(hash: any, runtime: any, alreadyVisitedExportsInfo: any): void;
    getUsedInfo(): string;
    getProvidedInfo(): "no provided info" | "maybe provided (runtime-defined)" | "provided" | "not provided";
    getRenameInfo(): string;
}
type ModuleGraphConnection = import("./ModuleGraphConnection");
type RuntimeSpec = import("./Dependency").RuntimeSpec;
import SortableSet = require("webpack/lib/util/SortableSet");
type UsageStateType = typeof UsageState.Unused | RuntimeUsageStateType;
type Hash = import("./util/Hash");
declare class RestoreProvidedData {
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {RestoreProvidedData} RestoreProvidedData
     */
    static deserialize({ read }: ObjectDeserializerContext): RestoreProvidedData;
    constructor(exports: any, otherProvided: any, otherCanMangleProvide: any, otherTerminalBinding: any);
    exports: any;
    otherProvided: any;
    otherCanMangleProvide: any;
    otherTerminalBinding: any;
    /**
     * @param {ObjectSerializerContext} context context
     */
    serialize({ write }: ObjectSerializerContext): void;
}
/** @typedef {import("./Dependency").RuntimeSpec} RuntimeSpec */
/** @typedef {import("./Module")} Module */
/** @typedef {import("./ModuleGraph")} ModuleGraph */
/** @typedef {import("./ModuleGraphConnection")} ModuleGraphConnection */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("./util/Hash")} Hash */
/** @typedef {typeof UsageState.OnlyPropertiesUsed | typeof UsageState.NoInfo | typeof UsageState.Unknown | typeof UsageState.Used} RuntimeUsageStateType */
/** @typedef {typeof UsageState.Unused | RuntimeUsageStateType} UsageStateType */
declare const UsageState: Readonly<{
    Unused: 0;
    OnlyPropertiesUsed: 1;
    NoInfo: 2;
    Unknown: 3;
    Used: 4;
}>;
type Module = import("./Module");
type ModuleGraph = import("./ModuleGraph");
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type RuntimeUsageStateType = typeof UsageState.OnlyPropertiesUsed | typeof UsageState.NoInfo | typeof UsageState.Unknown | typeof UsageState.Used;
declare namespace module {
    namespace exports {
        export { ExportInfo, UsageState, RuntimeSpec, Module, ModuleGraph, ModuleGraphConnection, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeUsageStateType, UsageStateType };
    }
}
declare const CIRCULAR: unique symbol;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ExportsInfoApiPlugin.d.ts
export = ExportsInfoApiPlugin;
declare class ExportsInfoApiPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ExportsInfoApiPlugin {
    export { Compiler, DependencyLocation, JavascriptParser, Range };
}
type Compiler = import("./Compiler");
type DependencyLocation = import("./Dependency").DependencyLocation;
type JavascriptParser = import("./javascript/JavascriptParser");
type Range = import("./javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ExternalModule.d.ts
export = ExternalModule;
declare class ExternalModule extends Module {
    /**
     * @param {string | string[] | Record<string, string | string[]>} request request
     * @param {TODO} type type
     * @param {string} userRequest user request
     */
    constructor(request: string | string[] | Record<string, string | string[]>, type: TODO, userRequest: string);
    /** @type {string | string[] | Record<string, string | string[]>} */
    request: string | string[] | Record<string, string | string[]>;
    /** @type {string} */
    externalType: string;
    /** @type {string} */
    userRequest: string;
    restoreFromUnsafeCache(unsafeCacheData: any, normalModuleFactory: any): void;
    _getRequestAndExternalType(): {
        request: string | string[];
        externalType: string;
    };
    _getSourceData(request: any, externalType: any, runtimeTemplate: any, moduleGraph: any, chunkGraph: any, runtime: any): SourceData;
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context: UpdateHashContext): void;
}
declare namespace ExternalModule {
    export { Source, WebpackOptions, Chunk, ChunkGraph, Compilation, UpdateHashContext, DependencyTemplates, ExportsInfo, CodeGenerationContext, CodeGenerationResult, ConcatenationBailoutReasonContext, LibIdentOptions, NeedBuildContext, NormalModuleFactory, RequestShortener, ResolverWithOptions, RuntimeTemplate, WebpackError, ChunkRenderContext, ObjectDeserializerContext, ObjectSerializerContext, Hash, HashConstructor, InputFileSystem, RuntimeSpec, SourceData };
}
import Module = require("webpack/lib/Module");
type SourceData = {
    iife?: boolean | undefined;
    init?: string | undefined;
    expression: string;
    chunkInitFragments?: InitFragment<ChunkRenderContext>[] | undefined;
    runtimeRequirements?: ReadonlySet<string> | undefined;
};
type Hash = import("./util/Hash");
type UpdateHashContext = import("./Dependency").UpdateHashContext;
type Source = import("webpack-sources").Source;
type WebpackOptions = any;
type Chunk = import("./Chunk");
type ChunkGraph = import("./ChunkGraph");
type Compilation = import("./Compilation");
type DependencyTemplates = import("./DependencyTemplates");
type ExportsInfo = import("./ExportsInfo");
type CodeGenerationContext = import("./Module").CodeGenerationContext;
type CodeGenerationResult = import("./Module").CodeGenerationResult;
type ConcatenationBailoutReasonContext = import("./Module").ConcatenationBailoutReasonContext;
type LibIdentOptions = import("./Module").LibIdentOptions;
type NeedBuildContext = import("./Module").NeedBuildContext;
type NormalModuleFactory = import("./NormalModuleFactory");
type RequestShortener = import("./RequestShortener");
type ResolverWithOptions = import("./ResolverFactory").ResolverWithOptions;
type RuntimeTemplate = import("./RuntimeTemplate");
type WebpackError = import("./WebpackError");
type ChunkRenderContext = import("./javascript/JavascriptModulesPlugin").ChunkRenderContext;
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type HashConstructor = typeof import("./util/Hash");
type InputFileSystem = import("./util/fs").InputFileSystem;
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
import InitFragment = require("webpack/lib/InitFragment");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ExternalModuleFactoryPlugin.d.ts
export = ExternalModuleFactoryPlugin;
declare class ExternalModuleFactoryPlugin {
    /**
     * @param {string | undefined} type default external type
     * @param {Externals} externals externals config
     */
    constructor(type: string | undefined, externals: any);
    type: string;
    externals: any;
    /**
     * @param {NormalModuleFactory} normalModuleFactory the normal module factory
     * @returns {void}
     */
    apply(normalModuleFactory: NormalModuleFactory): void;
}
declare namespace ExternalModuleFactoryPlugin {
    export { Externals, NormalModuleFactory };
}
type NormalModuleFactory = import("./NormalModuleFactory");
type Externals = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ExternalsPlugin.d.ts
export = ExternalsPlugin;
/** @typedef {import("../declarations/WebpackOptions").Externals} Externals */
/** @typedef {import("./Compiler")} Compiler */
declare class ExternalsPlugin {
    /**
     * @param {string | undefined} type default external type
     * @param {Externals} externals externals config
     */
    constructor(type: string | undefined, externals: any);
    type: string;
    externals: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ExternalsPlugin {
    export { Externals, Compiler };
}
type Compiler = import("./Compiler");
type Externals = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/FileSystemInfo.d.ts
export = FileSystemInfo;
/**
 * Used to access information about the filesystem in a cached way
 */
declare class FileSystemInfo {
    /**
     * @param {InputFileSystem} fs file system
     * @param {Object} options options
     * @param {Iterable<string | RegExp>=} options.managedPaths paths that are only managed by a package manager
     * @param {Iterable<string | RegExp>=} options.immutablePaths paths that are immutable
     * @param {Logger=} options.logger logger used to log invalid snapshots
     * @param {string | Hash=} options.hashFunction the hash function to use
     */
    constructor(fs: InputFileSystem, { managedPaths, immutablePaths, logger, hashFunction }?: {
        managedPaths?: Iterable<string | RegExp> | undefined;
        immutablePaths?: Iterable<string | RegExp> | undefined;
        logger?: Logger | undefined;
        hashFunction?: (string | Hash) | undefined;
    });
    fs: import("webpack/lib/util/fs").InputFileSystem;
    logger: import("webpack/lib/logging/Logger").Logger;
    _remainingLogs: number;
    _loggedPaths: Set<any>;
    _hashFunction: string | typeof import("webpack/lib/util/Hash");
    /** @type {WeakMap<Snapshot, boolean | (function(WebpackError=, boolean=): void)[]>} */
    _snapshotCache: WeakMap<Snapshot, boolean | ((arg0: WebpackError | undefined, arg1: boolean | undefined) => void)[]>;
    _fileTimestampsOptimization: SnapshotOptimization<FileSystemInfoEntry>;
    _fileHashesOptimization: SnapshotOptimization<string>;
    _fileTshsOptimization: SnapshotOptimization<string | TimestampAndHash>;
    _contextTimestampsOptimization: SnapshotOptimization<ResolvedContextFileSystemInfoEntry>;
    _contextHashesOptimization: SnapshotOptimization<string>;
    _contextTshsOptimization: SnapshotOptimization<ResolvedContextTimestampAndHash>;
    _missingExistenceOptimization: SnapshotOptimization<boolean>;
    _managedItemInfoOptimization: SnapshotOptimization<string>;
    _managedFilesOptimization: SnapshotOptimization<any>;
    _managedContextsOptimization: SnapshotOptimization<any>;
    _managedMissingOptimization: SnapshotOptimization<any>;
    /** @type {StackedCacheMap<string, FileSystemInfoEntry | "ignore" | null>} */
    _fileTimestamps: StackedCacheMap<string, FileSystemInfoEntry | "ignore" | null>;
    /** @type {Map<string, string>} */
    _fileHashes: Map<string, string>;
    /** @type {Map<string, TimestampAndHash | string>} */
    _fileTshs: Map<string, TimestampAndHash | string>;
    /** @type {StackedCacheMap<string, ContextFileSystemInfoEntry | "ignore" | null>} */
    _contextTimestamps: StackedCacheMap<string, ContextFileSystemInfoEntry | "ignore" | null>;
    /** @type {Map<string, ContextHash>} */
    _contextHashes: Map<string, ContextHash>;
    /** @type {Map<string, ContextTimestampAndHash>} */
    _contextTshs: Map<string, ContextTimestampAndHash>;
    /** @type {Map<string, string>} */
    _managedItems: Map<string, string>;
    /** @type {AsyncQueue<string, string, FileSystemInfoEntry | null>} */
    fileTimestampQueue: AsyncQueue<string, string, FileSystemInfoEntry | null>;
    /** @type {AsyncQueue<string, string, string | null>} */
    fileHashQueue: AsyncQueue<string, string, string | null>;
    /** @type {AsyncQueue<string, string, ContextFileSystemInfoEntry | null>} */
    contextTimestampQueue: AsyncQueue<string, string, ContextFileSystemInfoEntry | null>;
    /** @type {AsyncQueue<string, string, ContextHash | null>} */
    contextHashQueue: AsyncQueue<string, string, ContextHash | null>;
    /** @type {AsyncQueue<string, string, ContextTimestampAndHash | null>} */
    contextTshQueue: AsyncQueue<string, string, ContextTimestampAndHash | null>;
    /** @type {AsyncQueue<string, string, string | null>} */
    managedItemQueue: AsyncQueue<string, string, string | null>;
    /** @type {AsyncQueue<string, string, Set<string>>} */
    managedItemDirectoryQueue: AsyncQueue<string, string, Set<string>>;
    managedPaths: (string | RegExp)[];
    managedPathsWithSlash: string[];
    managedPathsRegExps: RegExp[];
    immutablePaths: (string | RegExp)[];
    immutablePathsWithSlash: string[];
    immutablePathsRegExps: RegExp[];
    _cachedDeprecatedFileTimestamps: Map<any, any>;
    _cachedDeprecatedContextTimestamps: Map<any, any>;
    _warnAboutExperimentalEsmTracking: boolean;
    _statCreatedSnapshots: number;
    _statTestedSnapshotsCached: number;
    _statTestedSnapshotsNotCached: number;
    _statTestedChildrenCached: number;
    _statTestedChildrenNotCached: number;
    _statTestedEntries: number;
    logStatistics(): void;
    /**
     * @param {string} path path
     * @param {string} reason reason
     * @param {any[]} args arguments
     */
    _log(path: string, reason: string, ...args: any[]): void;
    clear(): void;
    /**
     * @param {ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null>} map timestamps
     * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it
     * @returns {void}
     */
    addFileTimestamps(map: ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null>, immutable?: boolean | undefined): void;
    /**
     * @param {ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null>} map timestamps
     * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it
     * @returns {void}
     */
    addContextTimestamps(map: ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null>, immutable?: boolean | undefined): void;
    /**
     * @param {string} path file path
     * @param {function((WebpackError | null)=, (FileSystemInfoEntry | "ignore" | null)=): void} callback callback function
     * @returns {void}
     */
    getFileTimestamp(path: string, callback: (arg0: (WebpackError | null) | undefined, arg1: (FileSystemInfoEntry | "ignore" | null) | undefined) => void): void;
    /**
     * @param {string} path context path
     * @param {function((WebpackError | null)=, (ResolvedContextFileSystemInfoEntry | "ignore" | null)=): void} callback callback function
     * @returns {void}
     */
    getContextTimestamp(path: string, callback: (arg0: (WebpackError | null) | undefined, arg1: (ResolvedContextFileSystemInfoEntry | "ignore" | null) | undefined) => void): void;
    /**
     * @param {string} path context path
     * @param {function((WebpackError | null)=, (ContextFileSystemInfoEntry | "ignore" | null)=): void} callback callback function
     * @returns {void}
     */
    _getUnresolvedContextTimestamp(path: string, callback: (arg0: (WebpackError | null) | undefined, arg1: (ContextFileSystemInfoEntry | "ignore" | null) | undefined) => void): void;
    /**
     * @param {string} path file path
     * @param {function((WebpackError | null)=, (string | null)=): void} callback callback function
     * @returns {void}
     */
    getFileHash(path: string, callback: (arg0: (WebpackError | null) | undefined, arg1: (string | null) | undefined) => void): void;
    /**
     * @param {string} path context path
     * @param {function((WebpackError | null)=, string=): void} callback callback function
     * @returns {void}
     */
    getContextHash(path: string, callback: (arg0: (WebpackError | null) | undefined, arg1: string | undefined) => void): void;
    /**
     * @param {string} path context path
     * @param {function((WebpackError | null)=, (ContextHash | null)=): void} callback callback function
     * @returns {void}
     */
    _getUnresolvedContextHash(path: string, callback: (arg0: (WebpackError | null) | undefined, arg1: (ContextHash | null) | undefined) => void): void;
    /**
     * @param {string} path context path
     * @param {function((WebpackError | null)=, ResolvedContextTimestampAndHash=): void} callback callback function
     * @returns {void}
     */
    getContextTsh(path: string, callback: (arg0: (WebpackError | null) | undefined, arg1: ResolvedContextTimestampAndHash | undefined) => void): void;
    /**
     * @param {string} path context path
     * @param {function((WebpackError | null)=, (ContextTimestampAndHash | null)=): void} callback callback function
     * @returns {void}
     */
    _getUnresolvedContextTsh(path: string, callback: (arg0: (WebpackError | null) | undefined, arg1: (ContextTimestampAndHash | null) | undefined) => void): void;
    _createBuildDependenciesResolvers(): {
        resolveContext: import("enhanced-resolve").ResolveFunctionAsync;
        resolveEsm: import("enhanced-resolve").ResolveFunctionAsync;
        resolveCjs: import("enhanced-resolve").ResolveFunctionAsync;
        resolveCjsAsChild: import("enhanced-resolve").ResolveFunctionAsync;
    };
    /**
     * @param {string} context context directory
     * @param {Iterable<string>} deps dependencies
     * @param {function((Error | null)=, ResolveBuildDependenciesResult=): void} callback callback function
     * @returns {void}
     */
    resolveBuildDependencies(context: string, deps: Iterable<string>, callback: (arg0: (Error | null) | undefined, arg1: ResolveBuildDependenciesResult | undefined) => void): void;
    /**
     * @param {Map<string, string | false>} resolveResults results from resolving
     * @param {function((Error | null)=, boolean=): void} callback callback with true when resolveResults resolve the same way
     * @returns {void}
     */
    checkResolveResultsValid(resolveResults: Map<string, string | false>, callback: (arg0: (Error | null) | undefined, arg1: boolean | undefined) => void): void;
    /**
     *
     * @param {number | null | undefined} startTime when processing the files has started
     * @param {Iterable<string>} files all files
     * @param {Iterable<string>} directories all directories
     * @param {Iterable<string>} missing all missing files or directories
     * @param {SnapshotOptions | null | undefined} options options object (for future extensions)
     * @param {function((WebpackError | null)=, (Snapshot | null)=): void} callback callback function
     * @returns {void}
     */
    createSnapshot(startTime: number | null | undefined, files: Iterable<string>, directories: Iterable<string>, missing: Iterable<string>, options: SnapshotOptions | null | undefined, callback: (arg0: (WebpackError | null) | undefined, arg1: (Snapshot | null) | undefined) => void): void;
    /**
     * @param {Snapshot} snapshot1 a snapshot
     * @param {Snapshot} snapshot2 a snapshot
     * @returns {Snapshot} merged snapshot
     */
    mergeSnapshots(snapshot1: Snapshot, snapshot2: Snapshot): Snapshot;
    /**
     * @param {Snapshot} snapshot the snapshot made
     * @param {function((WebpackError | null)=, boolean=): void} callback callback function
     * @returns {void}
     */
    checkSnapshotValid(snapshot: Snapshot, callback: (arg0: (WebpackError | null) | undefined, arg1: boolean | undefined) => void): void;
    /**
     * @param {Snapshot} snapshot the snapshot made
     * @param {function((WebpackError | null)=, boolean=): void} callback callback function
     * @returns {void}
     */
    _checkSnapshotValidNoCache(snapshot: Snapshot, callback: (arg0: (WebpackError | null) | undefined, arg1: boolean | undefined) => void): void;
    _readFileTimestamp(path: any, callback: any): void;
    _readFileHash(path: any, callback: any): void;
    _getFileTimestampAndHash(path: any, callback: any): void;
    /**
     * @template T
     * @template ItemType
     * @param {Object} options options
     * @param {string} options.path path
     * @param {function(string): ItemType} options.fromImmutablePath called when context item is an immutable path
     * @param {function(string): ItemType} options.fromManagedItem called when context item is a managed path
     * @param {function(string, string, function(Error=, ItemType=): void): void} options.fromSymlink called when context item is a symlink
     * @param {function(string, IStats, function(Error=, ItemType=): void): void} options.fromFile called when context item is a file
     * @param {function(string, IStats, function(Error=, ItemType=): void): void} options.fromDirectory called when context item is a directory
     * @param {function(string[], ItemType[]): T} options.reduce called from all context items
     * @param {function((Error | null)=, (T | null)=): void} callback callback
     */
    _readContext<T, ItemType>({ path, fromImmutablePath, fromManagedItem, fromSymlink, fromFile, fromDirectory, reduce }: {
        path: string;
        fromImmutablePath: (arg0: string) => ItemType;
        fromManagedItem: (arg0: string) => ItemType;
        fromSymlink: (arg0: string, arg1: string, arg2: (arg0?: Error | undefined, arg1?: ItemType) => void) => void;
        fromFile: (arg0: string, arg1: IStats, arg2: (arg0?: Error | undefined, arg1?: ItemType) => void) => void;
        fromDirectory: (arg0: string, arg1: IStats, arg2: (arg0?: Error | undefined, arg1?: ItemType) => void) => void;
        reduce: (arg0: string[], arg1: ItemType[]) => T;
    }, callback: (arg0?: (Error | null) | undefined, arg1?: T) => void): void;
    _readContextTimestamp(path: any, callback: any): void;
    /**
     * @param {ContextFileSystemInfoEntry} entry entry
     * @param {function((Error | null)=, ResolvedContextFileSystemInfoEntry=): void} callback callback
     * @returns {void}
     */
    _resolveContextTimestamp(entry: ContextFileSystemInfoEntry, callback: (arg0: (Error | null) | undefined, arg1: ResolvedContextFileSystemInfoEntry | undefined) => void): void;
    _readContextHash(path: any, callback: any): void;
    /**
     * @param {ContextHash} entry context hash
     * @param {function((Error | null)=, string=): void} callback callback
     * @returns {void}
     */
    _resolveContextHash(entry: ContextHash, callback: (arg0: (Error | null) | undefined, arg1: string | undefined) => void): void;
    _readContextTimestampAndHash(path: any, callback: any): void;
    /**
     * @param {ContextTimestampAndHash} entry entry
     * @param {function((Error | null)=, ResolvedContextTimestampAndHash=): void} callback callback
     * @returns {void}
     */
    _resolveContextTsh(entry: ContextTimestampAndHash, callback: (arg0: (Error | null) | undefined, arg1: ResolvedContextTimestampAndHash | undefined) => void): void;
    _getManagedItemDirectoryInfo(path: any, callback: any): void;
    _getManagedItemInfo(path: any, callback: any): void;
    getDeprecatedFileTimestamps(): Map<any, any>;
    getDeprecatedContextTimestamps(): Map<any, any>;
}
declare namespace FileSystemInfo {
    export { Snapshot, WebpackError, Logger, ObjectDeserializerContext, ObjectSerializerContext, Hash, IStats, InputFileSystem, FileSystemInfoEntry, ResolvedContextFileSystemInfoEntry, ContextFileSystemInfoEntry, TimestampAndHash, ResolvedContextTimestampAndHash, ContextTimestampAndHash, ContextHash, SnapshotOptimizationEntry, ResolveBuildDependenciesResult, SnapshotOptions };
}
declare class Snapshot {
    _flags: number;
    /** @type {Iterable<string> | undefined} */
    _cachedFileIterable: Iterable<string> | undefined;
    /** @type {Iterable<string> | undefined} */
    _cachedContextIterable: Iterable<string> | undefined;
    /** @type {Iterable<string> | undefined} */
    _cachedMissingIterable: Iterable<string> | undefined;
    /** @type {number | undefined} */
    startTime: number | undefined;
    /** @type {Map<string, FileSystemInfoEntry | null> | undefined} */
    fileTimestamps: Map<string, FileSystemInfoEntry | null> | undefined;
    /** @type {Map<string, string | null> | undefined} */
    fileHashes: Map<string, string | null> | undefined;
    /** @type {Map<string, TimestampAndHash | string | null> | undefined} */
    fileTshs: Map<string, TimestampAndHash | string | null> | undefined;
    /** @type {Map<string, ResolvedContextFileSystemInfoEntry | null> | undefined} */
    contextTimestamps: Map<string, ResolvedContextFileSystemInfoEntry | null> | undefined;
    /** @type {Map<string, string | null> | undefined} */
    contextHashes: Map<string, string | null> | undefined;
    /** @type {Map<string, ResolvedContextTimestampAndHash | null> | undefined} */
    contextTshs: Map<string, ResolvedContextTimestampAndHash | null> | undefined;
    /** @type {Map<string, boolean> | undefined} */
    missingExistence: Map<string, boolean> | undefined;
    /** @type {Map<string, string> | undefined} */
    managedItemInfo: Map<string, string> | undefined;
    /** @type {Set<string> | undefined} */
    managedFiles: Set<string> | undefined;
    /** @type {Set<string> | undefined} */
    managedContexts: Set<string> | undefined;
    /** @type {Set<string> | undefined} */
    managedMissing: Set<string> | undefined;
    /** @type {Set<Snapshot> | undefined} */
    children: Set<Snapshot> | undefined;
    hasStartTime(): boolean;
    setStartTime(value: any): void;
    setMergedStartTime(value: any, snapshot: any): void;
    hasFileTimestamps(): boolean;
    setFileTimestamps(value: any): void;
    hasFileHashes(): boolean;
    setFileHashes(value: any): void;
    hasFileTshs(): boolean;
    setFileTshs(value: any): void;
    hasContextTimestamps(): boolean;
    setContextTimestamps(value: any): void;
    hasContextHashes(): boolean;
    setContextHashes(value: any): void;
    hasContextTshs(): boolean;
    setContextTshs(value: any): void;
    hasMissingExistence(): boolean;
    setMissingExistence(value: any): void;
    hasManagedItemInfo(): boolean;
    setManagedItemInfo(value: any): void;
    hasManagedFiles(): boolean;
    setManagedFiles(value: any): void;
    hasManagedContexts(): boolean;
    setManagedContexts(value: any): void;
    hasManagedMissing(): boolean;
    setManagedMissing(value: any): void;
    hasChildren(): boolean;
    setChildren(value: any): void;
    addChild(child: any): void;
    /**
     * @param {ObjectSerializerContext} context context
     */
    serialize({ write }: ObjectSerializerContext): void;
    /**
     * @param {ObjectDeserializerContext} context context
     */
    deserialize({ read }: ObjectDeserializerContext): void;
    /**
     * @param {function(Snapshot): (ReadonlyMap<string, any> | ReadonlySet<string>)[]} getMaps first
     * @returns {Iterable<string>} iterable
     */
    _createIterable(getMaps: (arg0: Snapshot) => (ReadonlyMap<string, any> | ReadonlySet<string>)[]): Iterable<string>;
    /**
     * @returns {Iterable<string>} iterable
     */
    getFileIterable(): Iterable<string>;
    /**
     * @returns {Iterable<string>} iterable
     */
    getContextIterable(): Iterable<string>;
    /**
     * @returns {Iterable<string>} iterable
     */
    getMissingIterable(): Iterable<string>;
}
type WebpackError = import("./WebpackError");
type FileSystemInfoEntry = {
    safeTime: number;
    timestamp?: number | undefined;
};
/**
 * @template T
 */
declare class SnapshotOptimization<T> {
    /**
     * @param {function(Snapshot): boolean} has has value
     * @param {function(Snapshot): Map<string, T> | Set<string>} get get value
     * @param {function(Snapshot, Map<string, T> | Set<string>): void} set set value
     * @param {boolean=} useStartTime use the start time of snapshots
     * @param {boolean=} isSet value is an Set instead of a Map
     */
    constructor(has: (arg0: Snapshot) => boolean, get: (arg0: Snapshot) => Map<string, T> | Set<string>, set: (arg0: Snapshot, arg1: Map<string, T> | Set<string>) => void, useStartTime?: boolean | undefined, isSet?: boolean | undefined);
    _has: (arg0: Snapshot) => boolean;
    _get: (arg0: Snapshot) => Map<string, T> | Set<string>;
    _set: (arg0: Snapshot, arg1: Map<string, T> | Set<string>) => void;
    _useStartTime: boolean;
    _isSet: boolean;
    /** @type {Map<string, SnapshotOptimizationEntry>} */
    _map: Map<string, SnapshotOptimizationEntry>;
    _statItemsShared: number;
    _statItemsUnshared: number;
    _statSharedSnapshots: number;
    _statReusedSharedSnapshots: number;
    getStatisticMessage(): string;
    clear(): void;
    /**
     * @param {Snapshot} newSnapshot snapshot
     * @param {Set<string>} capturedFiles files to snapshot/share
     * @returns {void}
     */
    optimize(newSnapshot: Snapshot, capturedFiles: Set<string>): void;
}
type TimestampAndHash = {
    safeTime: number;
    timestamp?: number | undefined;
    hash: string;
};
type ResolvedContextFileSystemInfoEntry = {
    safeTime: number;
    timestampHash?: string | undefined;
};
type ResolvedContextTimestampAndHash = {
    safeTime: number;
    timestampHash?: string | undefined;
    hash: string;
};
import StackedCacheMap = require("webpack/lib/util/StackedCacheMap");
type ContextFileSystemInfoEntry = {
    safeTime: number;
    timestampHash?: string | undefined;
    resolved?: ResolvedContextFileSystemInfoEntry | undefined;
    symlinks?: Set<string> | undefined;
};
type ContextHash = {
    hash: string;
    resolved?: string | undefined;
    symlinks?: Set<string> | undefined;
};
type ContextTimestampAndHash = {
    safeTime: number;
    timestampHash?: string | undefined;
    hash: string;
    resolved?: ResolvedContextTimestampAndHash | undefined;
    symlinks?: Set<string> | undefined;
};
import AsyncQueue = require("webpack/lib/util/AsyncQueue");
type ResolveBuildDependenciesResult = {
    /**
     * list of files
     */
    files: Set<string>;
    /**
     * list of directories
     */
    directories: Set<string>;
    /**
     * list of missing entries
     */
    missing: Set<string>;
    /**
     * stored resolve results
     */
    resolveResults: Map<string, string | false>;
    /**
     * dependencies of the resolving
     */
    resolveDependencies: {
        files: Set<string>;
        directories: Set<string>;
        missing: Set<string>;
    };
};
type SnapshotOptions = {
    /**
     * should use hash to snapshot
     */
    hash?: boolean | undefined;
    /**
     * should use timestamp to snapshot
     */
    timestamp?: boolean | undefined;
};
type IStats = import("./util/fs").IStats;
type InputFileSystem = import("./util/fs").InputFileSystem;
type Logger = import("./logging/Logger").Logger;
type Hash = typeof import("./util/Hash");
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type SnapshotOptimizationEntry = {
    snapshot: Snapshot;
    shared: number;
    snapshotContent: Set<string> | undefined;
    children: Set<SnapshotOptimizationEntry> | undefined;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/FlagAllModulesAsUsedPlugin.d.ts
export = FlagAllModulesAsUsedPlugin;
declare class FlagAllModulesAsUsedPlugin {
    /**
     * @param {string} explanation explanation
     */
    constructor(explanation: string);
    explanation: string;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace FlagAllModulesAsUsedPlugin {
    export { Compiler, FactoryMeta, RuntimeSpec };
}
type Compiler = import("./Compiler");
type FactoryMeta = import("./Module").FactoryMeta;
type RuntimeSpec = import("./util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/FlagDependencyExportsPlugin.d.ts
export = FlagDependencyExportsPlugin;
declare class FlagDependencyExportsPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace FlagDependencyExportsPlugin {
    export { Compiler, DependenciesBlock, Dependency, ExportSpec, ExportsSpec, ExportsInfo, Module };
}
type Compiler = import("./Compiler");
type DependenciesBlock = import("./DependenciesBlock");
type Dependency = import("./Dependency");
type ExportSpec = import("./Dependency").ExportSpec;
type ExportsSpec = import("./Dependency").ExportsSpec;
type ExportsInfo = import("./ExportsInfo");
type Module = import("./Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/FlagDependencyUsagePlugin.d.ts
export = FlagDependencyUsagePlugin;
declare class FlagDependencyUsagePlugin {
    /**
     * @param {boolean} global do a global analysis instead of per runtime
     */
    constructor(global: boolean);
    global: boolean;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace FlagDependencyUsagePlugin {
    export { Chunk, ChunkGroup, Compiler, DependenciesBlock, ReferencedExport, ExportsInfo, Module, RuntimeSpec };
}
type Compiler = import("./Compiler");
type Chunk = import("./Chunk");
type ChunkGroup = import("./ChunkGroup");
type DependenciesBlock = import("./DependenciesBlock");
type ReferencedExport = import("./Dependency").ReferencedExport;
type ExportsInfo = import("./ExportsInfo");
type Module = import("./Module");
type RuntimeSpec = import("./util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/FlagEntryExportAsUsedPlugin.d.ts
export = FlagEntryExportAsUsedPlugin;
declare class FlagEntryExportAsUsedPlugin {
    /**
     * @param {boolean} nsObjectUsed true, if the ns object is used
     * @param {string} explanation explanation for the reason
     */
    constructor(nsObjectUsed: boolean, explanation: string);
    nsObjectUsed: boolean;
    explanation: string;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace FlagEntryExportAsUsedPlugin {
    export { Compiler };
}
type Compiler = import("./Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Generator.d.ts
export = Generator;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("./ChunkGraph")} ChunkGraph */
/** @typedef {import("./CodeGenerationResults")} CodeGenerationResults */
/** @typedef {import("./Compilation")} Compilation */
/** @typedef {import("./ConcatenationScope")} ConcatenationScope */
/** @typedef {import("./DependencyTemplate")} DependencyTemplate */
/** @typedef {import("./DependencyTemplates")} DependencyTemplates */
/** @typedef {import("./Module").ConcatenationBailoutReasonContext} ConcatenationBailoutReasonContext */
/** @typedef {import("./ModuleGraph")} ModuleGraph */
/** @typedef {import("./NormalModule")} NormalModule */
/** @typedef {import("./RuntimeTemplate")} RuntimeTemplate */
/** @typedef {import("./util/Hash")} Hash */
/** @typedef {import("./util/runtime").RuntimeSpec} RuntimeSpec */
/**
 * @typedef {Object} GenerateContext
 * @property {DependencyTemplates} dependencyTemplates mapping from dependencies to templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {Set<string>} runtimeRequirements the requirements for runtime
 * @property {RuntimeSpec} runtime the runtime
 * @property {ConcatenationScope=} concatenationScope when in concatenated module, information about other concatenated modules
 * @property {CodeGenerationResults=} codeGenerationResults code generation results of other modules (need to have a codeGenerationDependency to use that)
 * @property {string} type which kind of code should be generated
 * @property {function(): Map<string, any>=} getData get access to the code generation data
 */
/**
 * @typedef {Object} UpdateHashContext
 * @property {NormalModule} module the module
 * @property {ChunkGraph} chunkGraph
 * @property {RuntimeSpec} runtime
 * @property {RuntimeTemplate=} runtimeTemplate
 */
/**
 *
 */
declare class Generator {
    /**
     * @param {Record<string, Generator>} map map of types
     * @returns {ByTypeGenerator} generator by type
     */
    static byType(map: Record<string, Generator>): ByTypeGenerator;
    /**
     * @abstract
     * @param {NormalModule} module fresh module
     * @returns {Set<string>} available types (do not mutate)
     */
    getTypes(module: NormalModule): Set<string>;
    /**
     * @abstract
     * @param {NormalModule} module the module
     * @param {string=} type source type
     * @returns {number} estimate size of the module
     */
    getSize(module: NormalModule, type?: string | undefined): number;
    /**
     * @abstract
     * @param {NormalModule} module module for which the code should be generated
     * @param {GenerateContext} generateContext context for generate
     * @returns {Source} generated code
     */
    generate(module: NormalModule, { dependencyTemplates, runtimeTemplate, moduleGraph, type }: GenerateContext): Source;
    /**
     * @param {NormalModule} module module for which the bailout reason should be determined
     * @param {ConcatenationBailoutReasonContext} context context
     * @returns {string | undefined} reason why this module can't be concatenated, undefined when it can be concatenated
     */
    getConcatenationBailoutReason(module: NormalModule, context: ConcatenationBailoutReasonContext): string | undefined;
    /**
     * @param {Hash} hash hash that will be modified
     * @param {UpdateHashContext} updateHashContext context for updating hash
     */
    updateHash(hash: Hash, { module, runtime }: UpdateHashContext): void;
}
declare namespace Generator {
    export { Source, ChunkGraph, CodeGenerationResults, Compilation, ConcatenationScope, DependencyTemplate, DependencyTemplates, ConcatenationBailoutReasonContext, ModuleGraph, NormalModule, RuntimeTemplate, Hash, RuntimeSpec, GenerateContext, UpdateHashContext };
}
type NormalModule = import("./NormalModule");
type GenerateContext = {
    /**
     * mapping from dependencies to templates
     */
    dependencyTemplates: DependencyTemplates;
    /**
     * the runtime template
     */
    runtimeTemplate: RuntimeTemplate;
    /**
     * the module graph
     */
    moduleGraph: ModuleGraph;
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
    /**
     * the requirements for runtime
     */
    runtimeRequirements: Set<string>;
    /**
     * the runtime
     */
    runtime: RuntimeSpec;
    /**
     * when in concatenated module, information about other concatenated modules
     */
    concatenationScope?: ConcatenationScope | undefined;
    /**
     * code generation results of other modules (need to have a codeGenerationDependency to use that)
     */
    codeGenerationResults?: CodeGenerationResults | undefined;
    /**
     * which kind of code should be generated
     */
    type: string;
    /**
     * get access to the code generation data
     */
    getData?: (() => Map<string, any>) | undefined;
};
type Source = import("webpack-sources").Source;
type ConcatenationBailoutReasonContext = import("./Module").ConcatenationBailoutReasonContext;
type Hash = import("./util/Hash");
type UpdateHashContext = {
    /**
     * the module
     */
    module: NormalModule;
    chunkGraph: ChunkGraph;
    runtime: RuntimeSpec;
    runtimeTemplate?: RuntimeTemplate | undefined;
};
declare class ByTypeGenerator extends Generator {
    /**
     * @param {Record<string, Generator>} map map of types
     */
    constructor(map: Record<string, Generator>);
    map: Record<string, Generator>;
    _types: Set<string>;
}
type ChunkGraph = import("./ChunkGraph");
type CodeGenerationResults = import("./CodeGenerationResults");
type Compilation = import("./Compilation");
type ConcatenationScope = import("./ConcatenationScope");
type DependencyTemplate = import("./DependencyTemplate");
type DependencyTemplates = import("./DependencyTemplates");
type ModuleGraph = import("./ModuleGraph");
type RuntimeTemplate = import("./RuntimeTemplate");
type RuntimeSpec = import("./util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/GraphHelpers.d.ts
export type AsyncDependenciesBlock = import("./AsyncDependenciesBlock");
export type Chunk = import("./Chunk");
export type ChunkGroup = import("./ChunkGroup");
export type DependenciesBlock = import("./DependenciesBlock");
export type Module = import("./Module");
/** @typedef {import("./AsyncDependenciesBlock")} AsyncDependenciesBlock */
/** @typedef {import("./Chunk")} Chunk */
/** @typedef {import("./ChunkGroup")} ChunkGroup */
/** @typedef {import("./DependenciesBlock")} DependenciesBlock */
/** @typedef {import("./Module")} Module */
/**
 * @param {ChunkGroup} chunkGroup the ChunkGroup to connect
 * @param {Chunk} chunk chunk to tie to ChunkGroup
 * @returns {void}
 */
export function connectChunkGroupAndChunk(chunkGroup: ChunkGroup, chunk: Chunk): void;
/**
 * @param {ChunkGroup} parent parent ChunkGroup to connect
 * @param {ChunkGroup} child child ChunkGroup to connect
 * @returns {void}
 */
export function connectChunkGroupParentAndChild(parent: ChunkGroup, child: ChunkGroup): void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/HarmonyLinkingError.d.ts
export = HarmonyLinkingError;
declare class HarmonyLinkingError extends WebpackError {
    /** @param {string} message Error message */
    constructor(message: string);
}
import WebpackError = require("webpack/lib/WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/HookWebpackError.d.ts
export = HookWebpackError;
/** @typedef {import("./Module")} Module */
/**
 * @template T
 * @callback Callback
 * @param {Error=} err
 * @param {T=} stats
 * @returns {void}
 */
declare class HookWebpackError extends WebpackError {
    /**
     * Creates an instance of HookWebpackError.
     * @param {Error} error inner error
     * @param {string} hook name of hook
     */
    constructor(error: Error, hook: string);
    hook: string;
    error: Error;
}
declare namespace HookWebpackError {
    export { makeWebpackError, makeWebpackErrorCallback, tryRunOrWebpackError, Module, Callback };
}
import WebpackError = require("webpack/lib/WebpackError");
/**
 * @param {Error} error an error
 * @param {string} hook name of the hook
 * @returns {WebpackError} a webpack error
 */
declare function makeWebpackError(error: Error, hook: string): WebpackError;
/**
 * @template T
 * @param {function((WebpackError | null)=, T=): void} callback webpack error callback
 * @param {string} hook name of hook
 * @returns {Callback<T>} generic callback
 */
declare function makeWebpackErrorCallback<T>(callback: (arg0?: (WebpackError | null) | undefined, arg1?: T) => void, hook: string): Callback<T>;
/**
 * @template T
 * @param {function(): T} fn function which will be wrapping in try catch
 * @param {string} hook name of hook
 * @returns {T} the result
 */
declare function tryRunOrWebpackError<T>(fn: () => T, hook: string): T;
type Module = import("./Module");
type Callback<T> = (err?: Error | undefined, stats?: T | undefined) => void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/HotModuleReplacementPlugin.d.ts
export = HotModuleReplacementPlugin;
declare class HotModuleReplacementPlugin {
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {HMRJavascriptParserHooks} the attached hooks
     */
    static getParserHooks(parser: JavascriptParser): HMRJavascriptParserHooks;
    constructor(options: any);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace HotModuleReplacementPlugin {
    export { Chunk, AssetInfo, Compiler, Module, RuntimeModule, RuntimeSpec, HMRJavascriptParserHooks };
}
type Compiler = import("./Compiler");
import JavascriptParser = require("webpack/lib/javascript/JavascriptParser");
type HMRJavascriptParserHooks = {
    hotAcceptCallback: SyncBailHook<[TODO, string[]], void>;
    hotAcceptWithoutCallback: SyncBailHook<[TODO, string[]], void>;
};
type Chunk = import("./Chunk");
type AssetInfo = import("./Compilation").AssetInfo;
type Module = import("./Module");
type RuntimeModule = import("./RuntimeModule");
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
import { SyncBailHook } from "tapable";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/HotUpdateChunk.d.ts
export = HotUpdateChunk;
/** @typedef {import("./ChunkGraph")} ChunkGraph */
/** @typedef {import("./util/Hash")} Hash */
declare class HotUpdateChunk extends Chunk {
    constructor();
}
declare namespace HotUpdateChunk {
    export { ChunkGraph, Hash };
}
import Chunk = require("webpack/lib/Chunk");
type ChunkGraph = import("./ChunkGraph");
type Hash = import("./util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/IgnoreErrorModuleFactory.d.ts
export = IgnoreErrorModuleFactory;
/** @typedef {import("./ModuleFactory").ModuleFactoryCreateData} ModuleFactoryCreateData */
/** @typedef {import("./ModuleFactory").ModuleFactoryResult} ModuleFactoryResult */
/** @typedef {import("./NormalModuleFactory")} NormalModuleFactory */
/**
 * Ignores error when module is unresolved
 */
declare class IgnoreErrorModuleFactory extends ModuleFactory {
    /**
     * @param {NormalModuleFactory} normalModuleFactory normalModuleFactory instance
     */
    constructor(normalModuleFactory: NormalModuleFactory);
    normalModuleFactory: import("webpack/lib/NormalModuleFactory");
}
declare namespace IgnoreErrorModuleFactory {
    export { ModuleFactoryCreateData, ModuleFactoryResult, NormalModuleFactory };
}
import ModuleFactory = require("webpack/lib/ModuleFactory");
type NormalModuleFactory = import("./NormalModuleFactory");
type ModuleFactoryCreateData = import("./ModuleFactory").ModuleFactoryCreateData;
type ModuleFactoryResult = import("./ModuleFactory").ModuleFactoryResult;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/IgnorePlugin.d.ts
export = IgnorePlugin;
declare class IgnorePlugin {
    /**
     * @param {IgnorePluginOptions} options IgnorePlugin options
     */
    constructor(options: any);
    options: any;
    /**
     * Note that if "contextRegExp" is given, both the "resourceRegExp"
     * and "contextRegExp" have to match.
     *
     * @param {ResolveData} resolveData resolve data
     * @returns {false|undefined} returns false when the request should be ignored, otherwise undefined
     */
    checkIgnore(resolveData: ResolveData): false | undefined;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace IgnorePlugin {
    export { IgnorePluginOptions, Compiler, ResolveData };
}
type ResolveData = import("./NormalModuleFactory").ResolveData;
type Compiler = import("./Compiler");
type IgnorePluginOptions = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/IgnoreWarningsPlugin.d.ts
export = IgnoreWarningsPlugin;
/** @typedef {import("../declarations/WebpackOptions").IgnoreWarningsNormalized} IgnoreWarningsNormalized */
/** @typedef {import("./Compiler")} Compiler */
declare class IgnoreWarningsPlugin {
    /**
     * @param {IgnoreWarningsNormalized} ignoreWarnings conditions to ignore warnings
     */
    constructor(ignoreWarnings: any);
    _ignoreWarnings: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace IgnoreWarningsPlugin {
    export { IgnoreWarningsNormalized, Compiler };
}
type Compiler = import("./Compiler");
type IgnoreWarningsNormalized = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/InitFragment.d.ts
export = InitFragment;
/**
 * @template Context
 */
declare class InitFragment<Context> {
    /**
     * @template Context
     * @template T
     * @param {Source} source sources
     * @param {InitFragment<T>[]} initFragments init fragments
     * @param {Context} context context
     * @returns {Source} source
     */
    static addToSource<Context_1, T>(source: Source, initFragments: InitFragment<T>[], context: Context_1): Source;
    /**
     * @param {string|Source} content the source code that will be included as initialization code
     * @param {number} stage category of initialization code (contribute to order)
     * @param {number} position position in the category (contribute to order)
     * @param {string=} key unique key to avoid emitting the same initialization code twice
     * @param {string|Source=} endContent the source code that will be included at the end of the module
     */
    constructor(content: string | Source, stage: number, position: number, key?: string | undefined, endContent?: (string | Source) | undefined);
    content: string | import("webpack-sources/lib/Source");
    stage: number;
    position: number;
    key: string;
    endContent: string | import("webpack-sources/lib/Source");
    /**
     * @param {Context} context context
     * @returns {string|Source} the source code that will be included as initialization code
     */
    getContent(context: Context): string | Source;
    /**
     * @param {Context} context context
     * @returns {string|Source=} the source code that will be included at the end of the module
     */
    getEndContent(context: Context): (string | Source) | undefined;
    /**
     * @param {ObjectSerializerContext} context context
     */
    serialize(context: ObjectSerializerContext): void;
    /**
     * @param {ObjectDeserializerContext} context context
     */
    deserialize(context: ObjectDeserializerContext): void;
    merge: any;
}
declare namespace InitFragment {
    export { STAGE_CONSTANTS, STAGE_ASYNC_BOUNDARY, STAGE_HARMONY_EXPORTS, STAGE_HARMONY_IMPORTS, STAGE_PROVIDES, STAGE_ASYNC_DEPENDENCIES, STAGE_ASYNC_HARMONY_IMPORTS, Source, GenerateContext, ObjectDeserializerContext, ObjectSerializerContext };
}
type Source = import("webpack-sources").Source;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
declare var STAGE_CONSTANTS: number;
declare var STAGE_ASYNC_BOUNDARY: number;
declare var STAGE_HARMONY_EXPORTS: number;
declare var STAGE_HARMONY_IMPORTS: number;
declare var STAGE_PROVIDES: number;
declare var STAGE_ASYNC_DEPENDENCIES: number;
declare var STAGE_ASYNC_HARMONY_IMPORTS: number;
type GenerateContext = import("./Generator").GenerateContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/InvalidDependenciesModuleWarning.d.ts
export = InvalidDependenciesModuleWarning;
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("./Module")} Module */
declare class InvalidDependenciesModuleWarning extends WebpackError {
    /**
     * @param {Module} module module tied to dependency
     * @param {Iterable<string>} deps invalid dependencies
     */
    constructor(module: Module, deps: Iterable<string>);
}
declare namespace InvalidDependenciesModuleWarning {
    export { DependencyLocation, Module };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("./Module");
type DependencyLocation = import("./Dependency").DependencyLocation;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/JavascriptMetaInfoPlugin.d.ts
export = JavascriptMetaInfoPlugin;
declare class JavascriptMetaInfoPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace JavascriptMetaInfoPlugin {
    export { Compiler, BuildInfo, JavascriptParser };
}
type Compiler = import("./Compiler");
type BuildInfo = import("./Module").BuildInfo;
type JavascriptParser = import("./javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/LibManifestPlugin.d.ts
export = LibManifestPlugin;
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./Module").BuildMeta} BuildMeta */
/**
 * @typedef {Object} ManifestModuleData
 * @property {string | number} id
 * @property {BuildMeta} buildMeta
 * @property {boolean | string[] | undefined} exports
 */
/**
 * @typedef {Object} LibManifestPluginOptions
 * @property {string=} context Context of requests in the manifest file (defaults to the webpack context).
 * @property {boolean=} entryOnly If true, only entry points will be exposed (default: true).
 * @property {boolean=} format If true, manifest json file (output) will be formatted.
 * @property {string=} name Name of the exposed dll function (external name, use value of 'output.library').
 * @property {string} path Absolute path to the manifest json file (output).
 * @property {string=} type Type of the dll bundle (external type, use value of 'output.libraryTarget').
 */
declare class LibManifestPlugin {
    /**
     * @param {LibManifestPluginOptions} options the options
     */
    constructor(options: LibManifestPluginOptions);
    options: LibManifestPluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace LibManifestPlugin {
    export { Compiler, BuildMeta, ManifestModuleData, LibManifestPluginOptions };
}
type LibManifestPluginOptions = {
    /**
     * Context of requests in the manifest file (defaults to the webpack context).
     */
    context?: string | undefined;
    /**
     * If true, only entry points will be exposed (default: true).
     */
    entryOnly?: boolean | undefined;
    /**
     * If true, manifest json file (output) will be formatted.
     */
    format?: boolean | undefined;
    /**
     * Name of the exposed dll function (external name, use value of 'output.library').
     */
    name?: string | undefined;
    /**
     * Absolute path to the manifest json file (output).
     */
    path: string;
    /**
     * Type of the dll bundle (external type, use value of 'output.libraryTarget').
     */
    type?: string | undefined;
};
type Compiler = import("./Compiler");
type BuildMeta = import("./Module").BuildMeta;
type ManifestModuleData = {
    id: string | number;
    buildMeta: BuildMeta;
    exports: boolean | string[] | undefined;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/LibraryTemplatePlugin.d.ts
export = LibraryTemplatePlugin;
/** @typedef {import("../declarations/WebpackOptions").AuxiliaryComment} AuxiliaryComment */
/** @typedef {import("../declarations/WebpackOptions").LibraryExport} LibraryExport */
/** @typedef {import("../declarations/WebpackOptions").LibraryName} LibraryName */
/** @typedef {import("../declarations/WebpackOptions").LibraryType} LibraryType */
/** @typedef {import("../declarations/WebpackOptions").UmdNamedDefine} UmdNamedDefine */
/** @typedef {import("./Compiler")} Compiler */
declare class LibraryTemplatePlugin {
    /**
     * @param {LibraryName} name name of library
     * @param {LibraryType} target type of library
     * @param {UmdNamedDefine} umdNamedDefine setting this to true will name the UMD module
     * @param {AuxiliaryComment} auxiliaryComment comment in the UMD wrapper
     * @param {LibraryExport} exportProperty which export should be exposed as library
     */
    constructor(name: any, target: any, umdNamedDefine: any, auxiliaryComment: any, exportProperty: any);
    library: {
        type: any;
        name: any;
        umdNamedDefine: any;
        auxiliaryComment: any;
        export: any;
    };
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace LibraryTemplatePlugin {
    export { AuxiliaryComment, LibraryExport, LibraryName, LibraryType, UmdNamedDefine, Compiler };
}
type Compiler = import("./Compiler");
type AuxiliaryComment = any;
type LibraryExport = any;
type LibraryName = any;
type LibraryType = any;
type UmdNamedDefine = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/LoaderOptionsPlugin.d.ts
export = LoaderOptionsPlugin;
declare class LoaderOptionsPlugin {
    /**
     * @param {LoaderOptionsPluginOptions & MatchObject} options options object
     */
    constructor(options?: LoaderOptionsPluginOptions & MatchObject);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace LoaderOptionsPlugin {
    export { LoaderOptionsPluginOptions, Compiler, MatchObject };
}
type Compiler = import("./Compiler");
type LoaderOptionsPluginOptions = any;
type MatchObject = import("./ModuleFilenameHelpers").MatchObject;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/LoaderTargetPlugin.d.ts
export = LoaderTargetPlugin;
/** @typedef {import("./Compiler")} Compiler */
declare class LoaderTargetPlugin {
    /**
     * @param {string} target the target
     */
    constructor(target: string);
    target: string;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace LoaderTargetPlugin {
    export { Compiler };
}
type Compiler = import("./Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/MainTemplate.d.ts
export = MainTemplate;
declare class MainTemplate {
    /**
     *
     * @param {OutputOptions} outputOptions output options for the MainTemplate
     * @param {Compilation} compilation the compilation
     */
    constructor(outputOptions: any, compilation: Compilation);
    /** @type {OutputOptions} */
    _outputOptions: any;
    hooks: Readonly<{
        renderManifest: {
            tap: (options: any, fn: any) => void;
        };
        modules: {
            tap: () => never;
        };
        moduleObj: {
            tap: () => never;
        };
        require: {
            tap: (options: any, fn: any) => void;
        };
        beforeStartup: {
            tap: () => never;
        };
        startup: {
            tap: () => never;
        };
        afterStartup: {
            tap: () => never;
        };
        render: {
            tap: (options: any, fn: any) => void;
        };
        renderWithEntry: {
            tap: (options: any, fn: any) => void;
        };
        assetPath: {
            tap: (options: any, fn: any) => void;
            call: (filename: any, options: any) => string;
        };
        hash: {
            tap: (options: any, fn: any) => void;
        };
        hashForChunk: {
            tap: (options: any, fn: any) => void;
        };
        globalHashPaths: {
            tap: () => void;
        };
        globalHash: {
            tap: () => void;
        };
        hotBootstrap: {
            tap: () => never;
        };
        /** @type {SyncWaterfallHook<[string, Chunk, string, ModuleTemplate, DependencyTemplates]>} */
        bootstrap: SyncWaterfallHook<[string, Chunk, string, ModuleTemplate, DependencyTemplates]>;
        /** @type {SyncWaterfallHook<[string, Chunk, string]>} */
        localVars: SyncWaterfallHook<[string, Chunk, string]>;
        /** @type {SyncWaterfallHook<[string, Chunk, string]>} */
        requireExtensions: SyncWaterfallHook<[string, Chunk, string]>;
        /** @type {SyncWaterfallHook<[string, Chunk, string, string]>} */
        requireEnsure: SyncWaterfallHook<[string, Chunk, string, string]>;
        readonly jsonpScript: SyncWaterfallHook<[string, import("webpack/lib/Chunk")], import("tapable").UnsetAdditionalOptions>;
        readonly linkPrefetch: SyncWaterfallHook<[string, import("webpack/lib/Chunk")], import("tapable").UnsetAdditionalOptions>;
        readonly linkPreload: SyncWaterfallHook<[string, import("webpack/lib/Chunk")], import("tapable").UnsetAdditionalOptions>;
    }>;
    renderCurrentHashCode: (hash: string, length?: number | undefined) => string;
    getPublicPath: (options: object) => string;
    getAssetPath: (path: any, options: any) => string;
    getAssetPathWithInfo: (path: any, options: any) => {
        path: string;
        info: import("webpack/lib/Compilation").AssetInfo;
    };
    get requireFn(): "__webpack_require__";
    get outputOptions(): any;
}
declare namespace MainTemplate {
    export { ConcatSource, Source, OutputOptions, ModuleTemplate, Chunk, Compilation, AssetInfo, Module, Hash, DependencyTemplates, RenderContext, RuntimeTemplate, ModuleGraph, ChunkGraph, RenderManifestOptions, RenderManifestEntry };
}
import { SyncWaterfallHook } from "tapable";
type Chunk = import("./Chunk");
type ModuleTemplate = import("./ModuleTemplate");
/**
 * }
 */
type DependencyTemplates = import("./DependencyTemplates");
type Compilation = import("./Compilation");
type ConcatSource = import("webpack-sources").ConcatSource;
type Source = import("webpack-sources").Source;
type OutputOptions = any;
type AssetInfo = import("./Compilation").AssetInfo;
/**
 * }
 */
type Module = import("./Module");
/**
 * }
 */
type Hash = import("./util/Hash");
/**
 * }
 */
type RenderContext = import("./javascript/JavascriptModulesPlugin").RenderContext;
/**
 * }
 */
type RuntimeTemplate = import("./RuntimeTemplate");
/**
 * }
 */
type ModuleGraph = import("./ModuleGraph");
/**
 * }
 */
type ChunkGraph = import("./ChunkGraph");
/**
 * }
 */
type RenderManifestOptions = import("./Template").RenderManifestOptions;
/**
 * }
 */
type RenderManifestEntry = import("./Template").RenderManifestEntry;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Module.d.ts
export = Module;
/** @typedef {(requestShortener: RequestShortener) => string} OptimizationBailoutFunction */
declare class Module extends DependenciesBlock {
    /**
     * @param {ModuleTypes | ""} type the module type, when deserializing the type is not known and is an empty string
     * @param {(string | null)=} context an optional context
     * @param {(string | null)=} layer an optional layer in which the module is
     */
    constructor(type: ModuleTypes | "", context?: (string | null) | undefined, layer?: (string | null) | undefined);
    /** @type {ModuleTypes} */
    type: ModuleTypes;
    /** @type {string | null} */
    context: string | null;
    /** @type {string | null} */
    layer: string | null;
    /** @type {boolean} */
    needId: boolean;
    /** @type {number} */
    debugId: number;
    /** @type {ResolveOptions | undefined} */
    resolveOptions: ResolveOptions | undefined;
    /** @type {FactoryMeta | undefined} */
    factoryMeta: FactoryMeta | undefined;
    /** @type {boolean} */
    useSourceMap: boolean;
    /** @type {boolean} */
    useSimpleSourceMap: boolean;
    /** @type {WebpackError[] | undefined} */
    _warnings: WebpackError[] | undefined;
    /** @type {WebpackError[] | undefined} */
    _errors: WebpackError[] | undefined;
    /** @type {BuildMeta | undefined} */
    buildMeta: BuildMeta | undefined;
    /** @type {BuildInfo | undefined} */
    buildInfo: BuildInfo | undefined;
    /** @type {Dependency[] | undefined} */
    presentationalDependencies: Dependency[] | undefined;
    /** @type {Dependency[] | undefined} */
    codeGenerationDependencies: Dependency[] | undefined;
    set id(arg: string | number);
    get id(): string | number;
    /**
     * @returns {string} the hash of the module
     */
    get hash(): string;
    /**
     * @returns {string} the shortened hash of the module
     */
    get renderedHash(): string;
    set profile(arg: import("webpack/lib/ModuleProfile"));
    get profile(): import("webpack/lib/ModuleProfile");
    set index(arg: number);
    get index(): number;
    set index2(arg: number);
    get index2(): number;
    set depth(arg: number);
    get depth(): number;
    set issuer(arg: Module);
    get issuer(): Module;
    get usedExports(): boolean | import("webpack/lib/util/SortableSet")<string>;
    /**
     * @deprecated
     * @returns {(string | OptimizationBailoutFunction)[]} list
     */
    get optimizationBailout(): (string | OptimizationBailoutFunction)[];
    get optional(): boolean;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {boolean} true, when the module was added
     */
    addChunk(chunk: Chunk): boolean;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {void}
     */
    removeChunk(chunk: Chunk): void;
    /**
     * @param {Chunk} chunk the chunk
     * @returns {boolean} true, when the module is in the chunk
     */
    isInChunk(chunk: Chunk): boolean;
    isEntryModule(): boolean;
    getChunks(): import("webpack/lib/Chunk")[];
    getNumberOfChunks(): number;
    get chunksIterable(): Iterable<import("webpack/lib/Chunk")>;
    /**
     * @param {string} exportName a name of an export
     * @returns {boolean | null} true, if the export is provided why the module.
     * null, if it's unknown.
     * false, if it's not provided.
     */
    isProvided(exportName: string): boolean | null;
    /**
     * @returns {string} name of the exports argument
     */
    get exportsArgument(): string;
    /**
     * @returns {string} name of the module argument
     */
    get moduleArgument(): string;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {boolean | undefined} strict the importing module is strict
     * @returns {"namespace" | "default-only" | "default-with-named" | "dynamic"} export type
     * "namespace": Exports is already a namespace object. namespace = exports.
     * "dynamic": Check at runtime if __esModule is set. When set: namespace = { ...exports, default: exports }. When not set: namespace = { default: exports }.
     * "default-only": Provide a namespace object with only default export. namespace = { default: exports }
     * "default-with-named": Provide a namespace object with named and default export. namespace = { ...exports, default: exports }
     */
    getExportsType(moduleGraph: ModuleGraph, strict: boolean | undefined): "namespace" | "default-only" | "default-with-named" | "dynamic";
    /**
     * @param {Dependency} presentationalDependency dependency being tied to module.
     * This is a Dependency without edge in the module graph. It's only for presentation.
     * @returns {void}
     */
    addPresentationalDependency(presentationalDependency: Dependency): void;
    /**
     * @param {Dependency} codeGenerationDependency dependency being tied to module.
     * This is a Dependency where the code generation result of the referenced module is needed during code generation.
     * The Dependency should also be added to normal dependencies via addDependency.
     * @returns {void}
     */
    addCodeGenerationDependency(codeGenerationDependency: Dependency): void;
    /**
     * @param {WebpackError} warning the warning
     * @returns {void}
     */
    addWarning(warning: WebpackError): void;
    /**
     * @returns {Iterable<WebpackError> | undefined} list of warnings if any
     */
    getWarnings(): Iterable<WebpackError> | undefined;
    /**
     * @returns {number} number of warnings
     */
    getNumberOfWarnings(): number;
    /**
     * @param {WebpackError} error the error
     * @returns {void}
     */
    addError(error: WebpackError): void;
    /**
     * @returns {Iterable<WebpackError> | undefined} list of errors if any
     */
    getErrors(): Iterable<WebpackError> | undefined;
    /**
     * @returns {number} number of errors
     */
    getNumberOfErrors(): number;
    /**
     * removes all warnings and errors
     * @returns {void}
     */
    clearWarningsAndErrors(): void;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @returns {boolean} true, if the module is optional
     */
    isOptional(moduleGraph: ModuleGraph): boolean;
    /**
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @param {Chunk} chunk a chunk
     * @param {Chunk=} ignoreChunk chunk to be ignored
     * @returns {boolean} true, if the module is accessible from "chunk" when ignoring "ignoreChunk"
     */
    isAccessibleInChunk(chunkGraph: ChunkGraph, chunk: Chunk, ignoreChunk?: Chunk | undefined): boolean;
    /**
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @param {ChunkGroup} chunkGroup a chunk group
     * @param {Chunk=} ignoreChunk chunk to be ignored
     * @returns {boolean} true, if the module is accessible from "chunkGroup" when ignoring "ignoreChunk"
     */
    isAccessibleInChunkGroup(chunkGraph: ChunkGraph, chunkGroup: ChunkGroup, ignoreChunk?: Chunk | undefined): boolean;
    /**
     * @param {Chunk} chunk a chunk
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @returns {boolean} true, if the module has any reason why "chunk" should be included
     */
    hasReasonForChunk(chunk: Chunk, moduleGraph: ModuleGraph, chunkGraph: ChunkGraph): boolean;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {RuntimeSpec} runtime the runtime
     * @returns {boolean} true if at least one other module depends on this module
     */
    hasReasons(moduleGraph: ModuleGraph, runtime: RuntimeSpec): boolean;
    /**
     * @param {NeedBuildContext} context context info
     * @param {function((WebpackError | null)=, boolean=): void} callback callback function, returns true, if the module needs a rebuild
     * @returns {void}
     */
    needBuild(context: NeedBuildContext, callback: (arg0: (WebpackError | null) | undefined, arg1: boolean | undefined) => void): void;
    /**
     * @deprecated Use needBuild instead
     * @param {Map<string, number|null>} fileTimestamps timestamps of files
     * @param {Map<string, number|null>} contextTimestamps timestamps of directories
     * @returns {boolean} true, if the module needs a rebuild
     */
    needRebuild(fileTimestamps: Map<string, number | null>, contextTimestamps: Map<string, number | null>): boolean;
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context?: UpdateHashContext): void;
    /**
     * @returns {void}
     */
    invalidateBuild(): void;
    /**
     * @abstract
     * @returns {string} a unique identifier of the module
     */
    identifier(): string;
    /**
     * @abstract
     * @param {RequestShortener} requestShortener the request shortener
     * @returns {string} a user readable identifier of the module
     */
    readableIdentifier(requestShortener: RequestShortener): string;
    /**
     * @abstract
     * @param {WebpackOptions} options webpack options
     * @param {Compilation} compilation the compilation
     * @param {ResolverWithOptions} resolver the resolver
     * @param {InputFileSystem} fs the file system
     * @param {function(WebpackError=): void} callback callback function
     * @returns {void}
     */
    build(options: any, compilation: Compilation, resolver: ResolverWithOptions, fs: InputFileSystem, callback: (arg0: WebpackError | undefined) => void): void;
    /**
     * @abstract
     * @returns {Set<string>} types available (do not mutate)
     */
    getSourceTypes(): Set<string>;
    /**
     * @abstract
     * @deprecated Use codeGeneration() instead
     * @param {DependencyTemplates} dependencyTemplates the dependency templates
     * @param {RuntimeTemplate} runtimeTemplate the runtime template
     * @param {string=} type the type of source that should be generated
     * @returns {Source} generated source
     */
    source(dependencyTemplates: DependencyTemplates, runtimeTemplate: RuntimeTemplate, type?: string | undefined): Source;
    /**
     * @abstract
     * @param {string=} type the source type for which the size should be estimated
     * @returns {number} the estimated size of the module (must be non-zero)
     */
    size(type?: string | undefined): number;
    /**
     * @param {LibIdentOptions} options options
     * @returns {string | null} an identifier for library inclusion
     */
    libIdent(options: LibIdentOptions): string | null;
    /**
     * @returns {string | null} absolute path which should be used for condition matching (usually the resource path)
     */
    nameForCondition(): string | null;
    /**
     * @param {ConcatenationBailoutReasonContext} context context
     * @returns {string | undefined} reason why this module can't be concatenated, undefined when it can be concatenated
     */
    getConcatenationBailoutReason(context: ConcatenationBailoutReasonContext): string | undefined;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @returns {ConnectionState} how this module should be connected to referencing modules when consumed for side-effects only
     */
    getSideEffectsConnectionState(moduleGraph: ModuleGraph): ConnectionState;
    /**
     * @param {CodeGenerationContext} context context for code generation
     * @returns {CodeGenerationResult} result
     */
    codeGeneration(context: CodeGenerationContext): CodeGenerationResult;
    /**
     * @param {Chunk} chunk the chunk which condition should be checked
     * @param {Compilation} compilation the compilation
     * @returns {boolean} true, if the chunk is ok for the module
     */
    chunkCondition(chunk: Chunk, compilation: Compilation): boolean;
    hasChunkCondition(): boolean;
    /**
     * Assuming this module is in the cache. Update the (cached) module with
     * the fresh module from the factory. Usually updates internal references
     * and properties.
     * @param {Module} module fresh module
     * @returns {void}
     */
    updateCacheModule(module: Module): void;
    /**
     * Module should be unsafe cached. Get data that's needed for that.
     * This data will be passed to restoreFromUnsafeCache later.
     * @returns {object} cached data
     */
    getUnsafeCacheData(): object;
    /**
     * restore unsafe cache data
     * @param {object} unsafeCacheData data from getUnsafeCacheData
     * @param {NormalModuleFactory} normalModuleFactory the normal module factory handling the unsafe caching
     */
    _restoreFromUnsafeCache(unsafeCacheData: object, normalModuleFactory: NormalModuleFactory): void;
    /**
     * Assuming this module is in the cache. Remove internal references to allow freeing some memory.
     */
    cleanupForCache(): void;
    /**
     * @returns {Source | null} the original source for the module before webpack transformation
     */
    originalSource(): Source | null;
    /**
     * @param {LazySet<string>} fileDependencies set where file dependencies are added to
     * @param {LazySet<string>} contextDependencies set where context dependencies are added to
     * @param {LazySet<string>} missingDependencies set where missing dependencies are added to
     * @param {LazySet<string>} buildDependencies set where build dependencies are added to
     */
    addCacheDependencies(fileDependencies: LazySet<string>, contextDependencies: LazySet<string>, missingDependencies: LazySet<string>, buildDependencies: LazySet<string>): void;
    get hasEqualsChunks(): any;
    get isUsed(): any;
    get errors(): any;
    get warnings(): any;
    set used(arg: any);
    get used(): any;
}
declare namespace Module {
    export { Source, ResolveOptions, WebpackOptions, Chunk, ChunkGroup, CodeGenerationResults, Compilation, ConcatenationScope, Dependency, UpdateHashContext, DependencyTemplates, UsageStateType, FileSystemInfo, ConnectionState, ModuleTypes, NormalModuleFactory, RequestShortener, ResolverWithOptions, RuntimeTemplate, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, Hash, LazySet, SortableSet, InputFileSystem, RuntimeSpec, SourceContext, CodeGenerationContext, ConcatenationBailoutReasonContext, CodeGenerationResult, LibIdentOptions, KnownBuildMeta, NeedBuildContext, BuildMeta, BuildInfo, FactoryMeta, OptimizationBailoutFunction };
}
import DependenciesBlock = require("webpack/lib/DependenciesBlock");
type ModuleTypes = import("./ModuleTypeConstants").ModuleTypes;
type ResolveOptions = any;
type FactoryMeta = {
    sideEffectFree?: boolean | undefined;
};
type WebpackError = import("./WebpackError");
type BuildMeta = KnownBuildMeta & Record<string, any>;
type BuildInfo = Record<string, any>;
type Dependency = import("./Dependency");
type OptimizationBailoutFunction = (requestShortener: RequestShortener) => string;
type Chunk = import("./Chunk");
import ModuleGraph = require("webpack/lib/ModuleGraph");
import ChunkGraph = require("webpack/lib/ChunkGraph");
type ChunkGroup = import("./ChunkGroup");
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
type NeedBuildContext = {
    compilation: Compilation;
    fileSystemInfo: FileSystemInfo;
    valueCacheVersions: Map<string, string | Set<string>>;
};
type Hash = import("./util/Hash");
type UpdateHashContext = import("./Dependency").UpdateHashContext;
type RequestShortener = import("./RequestShortener");
type Compilation = import("./Compilation");
type ResolverWithOptions = import("./ResolverFactory").ResolverWithOptions;
type InputFileSystem = import("./util/fs").InputFileSystem;
type DependencyTemplates = import("./DependencyTemplates");
type RuntimeTemplate = import("./RuntimeTemplate");
type Source = import("webpack-sources").Source;
type LibIdentOptions = {
    /**
     * absolute context path to which lib ident is relative to
     */
    context: string;
    /**
     * object for caching
     */
    associatedObjectForCache?: any | undefined;
};
type ConcatenationBailoutReasonContext = {
    /**
     * the module graph
     */
    moduleGraph: ModuleGraph;
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
};
type ConnectionState = import("./ModuleGraphConnection").ConnectionState;
type CodeGenerationContext = {
    /**
     * the dependency templates
     */
    dependencyTemplates: DependencyTemplates;
    /**
     * the runtime template
     */
    runtimeTemplate: RuntimeTemplate;
    /**
     * the module graph
     */
    moduleGraph: ModuleGraph;
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
    /**
     * the runtimes code should be generated for
     */
    runtime: RuntimeSpec;
    /**
     * when in concatenated module, information about other concatenated modules
     */
    concatenationScope?: ConcatenationScope | undefined;
    /**
     * code generation results of other modules (need to have a codeGenerationDependency to use that)
     */
    codeGenerationResults: CodeGenerationResults;
    /**
     * the compilation
     */
    compilation?: Compilation | undefined;
    /**
     * source types
     */
    sourceTypes?: ReadonlySet<string> | undefined;
};
type CodeGenerationResult = {
    /**
     * the resulting sources for all source types
     */
    sources: Map<string, Source>;
    /**
     * the resulting data for all source types
     */
    data?: Map<string, any> | undefined;
    /**
     * the runtime requirements
     */
    runtimeRequirements: ReadonlySet<string>;
    /**
     * a hash of the code generation result (will be automatically calculated from sources and runtimeRequirements if not provided)
     */
    hash?: string | undefined;
};
type NormalModuleFactory = import("./NormalModuleFactory");
/**
 * <T>
 */
type LazySet<T> = import("./util/LazySet")<T>;
type WebpackOptions = any;
type CodeGenerationResults = import("./CodeGenerationResults");
type ConcatenationScope = import("./ConcatenationScope");
type UsageStateType = import("./ExportsInfo").UsageStateType;
type FileSystemInfo = import("./FileSystemInfo");
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
/**
 * <T>
 */
type SortableSet<T> = import("./util/SortableSet")<T>;
type SourceContext = {
    /**
     * the dependency templates
     */
    dependencyTemplates: DependencyTemplates;
    /**
     * the runtime template
     */
    runtimeTemplate: RuntimeTemplate;
    /**
     * the module graph
     */
    moduleGraph: ModuleGraph;
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
    /**
     * the runtimes code should be generated for
     */
    runtime: RuntimeSpec;
    /**
     * the type of source that should be generated
     */
    type?: string | undefined;
};
type KnownBuildMeta = {
    moduleArgument?: string | undefined;
    exportsArgument?: string | undefined;
    strict?: boolean | undefined;
    moduleConcatenationBailout?: string | undefined;
    exportsType?: ("default" | "namespace" | "flagged" | "dynamic") | undefined;
    defaultObject?: (false | "redirect" | "redirect-warn") | undefined;
    strictHarmonyModule?: boolean | undefined;
    async?: boolean | undefined;
    sideEffectFree?: boolean | undefined;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleBuildError.d.ts
export = ModuleBuildError;
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class ModuleBuildError extends WebpackError {
    /**
     * @param {string | Error&any} err error thrown
     * @param {{from?: string|null}} info additional info
     */
    constructor(err: string | (Error & any), { from }?: {
        from?: string | null;
    });
    error: any;
}
declare namespace ModuleBuildError {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
import WebpackError = require("webpack/lib/WebpackError");
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleDependencyError.d.ts
export = ModuleDependencyError;
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("./Module")} Module */
declare class ModuleDependencyError extends WebpackError {
    /**
     * Creates an instance of ModuleDependencyError.
     * @param {Module} module module tied to dependency
     * @param {Error} err error thrown
     * @param {DependencyLocation} loc location of dependency
     */
    constructor(module: Module, err: Error, loc: DependencyLocation);
    /** error is not (de)serialized, so it might be undefined after deserialization */
    error: Error;
    stack: string;
}
declare namespace ModuleDependencyError {
    export { DependencyLocation, Module };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("./Module");
type DependencyLocation = import("./Dependency").DependencyLocation;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleDependencyWarning.d.ts
export = ModuleDependencyWarning;
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("./Module")} Module */
declare class ModuleDependencyWarning extends WebpackError {
    /**
     * @param {Module} module module tied to dependency
     * @param {Error} err error thrown
     * @param {DependencyLocation} loc location of dependency
     */
    constructor(module: Module, err: Error, loc: DependencyLocation);
    /** error is not (de)serialized, so it might be undefined after deserialization */
    error: Error;
    stack: string;
}
declare namespace ModuleDependencyWarning {
    export { DependencyLocation, Module };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("./Module");
type DependencyLocation = import("./Dependency").DependencyLocation;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleError.d.ts
export = ModuleError;
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class ModuleError extends WebpackError {
    /**
     * @param {Error} err error thrown
     * @param {{from?: string|null}} info additional info
     */
    constructor(err: Error, { from }?: {
        from?: string | null;
    });
    error: Error;
}
declare namespace ModuleError {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
import WebpackError = require("webpack/lib/WebpackError");
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleFactory.d.ts
export = ModuleFactory;
/** @typedef {import("../declarations/WebpackOptions").ResolveOptions} ResolveOptions */
/** @typedef {import("./Dependency")} Dependency */
/** @typedef {import("./Module")} Module */
/**
 * @typedef {Object} ModuleFactoryResult
 * @property {Module=} module the created module or unset if no module was created
 * @property {Set<string>=} fileDependencies
 * @property {Set<string>=} contextDependencies
 * @property {Set<string>=} missingDependencies
 * @property {boolean=} cacheable allow to use the unsafe cache
 */
/**
 * @typedef {Object} ModuleFactoryCreateDataContextInfo
 * @property {string} issuer
 * @property {string | null=} issuerLayer
 * @property {string} compiler
 */
/**
 * @typedef {Object} ModuleFactoryCreateData
 * @property {ModuleFactoryCreateDataContextInfo} contextInfo
 * @property {ResolveOptions=} resolveOptions
 * @property {string} context
 * @property {Dependency[]} dependencies
 */
declare class ModuleFactory {
    /**
     * @abstract
     * @param {ModuleFactoryCreateData} data data object
     * @param {function((Error | null)=, ModuleFactoryResult=): void} callback callback
     * @returns {void}
     */
    create(data: ModuleFactoryCreateData, callback: (arg0: (Error | null) | undefined, arg1: ModuleFactoryResult | undefined) => void): void;
}
declare namespace ModuleFactory {
    export { ResolveOptions, Dependency, Module, ModuleFactoryResult, ModuleFactoryCreateDataContextInfo, ModuleFactoryCreateData };
}
type ModuleFactoryCreateData = {
    contextInfo: ModuleFactoryCreateDataContextInfo;
    resolveOptions?: any;
    context: string;
    dependencies: Dependency[];
};
type ModuleFactoryResult = {
    /**
     * the created module or unset if no module was created
     */
    module?: Module | undefined;
    fileDependencies?: Set<string> | undefined;
    contextDependencies?: Set<string> | undefined;
    missingDependencies?: Set<string> | undefined;
    /**
     * allow to use the unsafe cache
     */
    cacheable?: boolean | undefined;
};
type ResolveOptions = any;
type Dependency = import("./Dependency");
type Module = import("./Module");
type ModuleFactoryCreateDataContextInfo = {
    issuer: string;
    issuerLayer?: (string | null) | undefined;
    compiler: string;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleFilenameHelpers.d.ts
export const ALL_LOADERS_RESOURCE: string;
export const REGEXP_ALL_LOADERS_RESOURCE: RegExp;
export const LOADERS_RESOURCE: string;
export const REGEXP_LOADERS_RESOURCE: RegExp;
export const RESOURCE: string;
export const REGEXP_RESOURCE: RegExp;
export const ABSOLUTE_RESOURCE_PATH: string;
export const REGEXP_ABSOLUTE_RESOURCE_PATH: RegExp;
export const RESOURCE_PATH: string;
export const REGEXP_RESOURCE_PATH: RegExp;
export const ALL_LOADERS: string;
export const REGEXP_ALL_LOADERS: RegExp;
export const LOADERS: string;
export const REGEXP_LOADERS: RegExp;
export const QUERY: string;
export const REGEXP_QUERY: RegExp;
export const ID: string;
export const REGEXP_ID: RegExp;
export const HASH: string;
export const REGEXP_HASH: RegExp;
export const NAMESPACE: string;
export const REGEXP_NAMESPACE: RegExp;
/**
 *
 * @param {Module | string} module the module
 * @param {TODO} options options
 * @param {Object} contextInfo context info
 * @param {RequestShortener} contextInfo.requestShortener requestShortener
 * @param {ChunkGraph} contextInfo.chunkGraph chunk graph
 * @param {string | Hash} contextInfo.hashFunction the hash function to use
 * @returns {string} the filename
 */
export function createFilename(module: Module | string, options: TODO, { requestShortener, chunkGraph, hashFunction }: {
    requestShortener: RequestShortener;
    chunkGraph: ChunkGraph;
    hashFunction: string | Hash;
}): string;
/**
 * Replaces duplicate items in an array with new values generated by a callback function.
 * The callback function is called with the duplicate item, the index of the duplicate item, and the number of times the item has been replaced.
 * The callback function should return the new value for the duplicate item.
 *
 * @template T
 * @param {T[]} array the array with duplicates to be replaced
 * @param {(duplicateItem: T, duplicateItemIndex: number, numberOfTimesReplaced: number) => T} fn callback function to generate new values for the duplicate items
 * @param {(firstElement:T, nextElement:T) => -1 | 0 | 1} [comparator] optional comparator function to sort the duplicate items
 * @returns {T[]} the array with duplicates replaced
 *
 * @example
 * ```js
 * const array = ["a", "b", "c", "a", "b", "a"];
 * const result = ModuleFilenameHelpers.replaceDuplicates(array, (item, index, count) => `${item}-${count}`);
 * // result: ["a-1", "b-1", "c", "a-2", "b-2", "a-3"]
 * ```
 */
export function replaceDuplicates<T>(array: T[], fn: (duplicateItem: T, duplicateItemIndex: number, numberOfTimesReplaced: number) => T, comparator?: (firstElement: T, nextElement: T) => -1 | 0 | 1): T[];
/**
 * Tests if a string matches a RegExp or an array of RegExp.
 *
 * @param {string} str string to test
 * @param {Matcher} test value which will be used to match against the string
 * @returns {boolean} true, when the RegExp matches
 *
 * @example
 * ```js
 * ModuleFilenameHelpers.matchPart("foo.js", "foo"); // true
 * ModuleFilenameHelpers.matchPart("foo.js", "foo.js"); // true
 * ModuleFilenameHelpers.matchPart("foo.js", "foo."); // false
 * ModuleFilenameHelpers.matchPart("foo.js", "foo*"); // false
 * ModuleFilenameHelpers.matchPart("foo.js", "foo.*"); // true
 * ModuleFilenameHelpers.matchPart("foo.js", /^foo/); // true
 * ModuleFilenameHelpers.matchPart("foo.js", [/^foo/, "bar"]); // true
 * ModuleFilenameHelpers.matchPart("foo.js", [/^foo/, "bar"]); // true
 * ModuleFilenameHelpers.matchPart("foo.js", [/^foo/, /^bar/]); // true
 * ModuleFilenameHelpers.matchPart("foo.js", [/^baz/, /^bar/]); // false
 * ```
 */
export function matchPart(str: string, test: Matcher): boolean;
/**
 * Tests if a string matches a match object. The match object can have the following properties:
 * - `test`: a RegExp or an array of RegExp
 * - `include`: a RegExp or an array of RegExp
 * - `exclude`: a RegExp or an array of RegExp
 *
 * The `test` property is tested first, then `include` and then `exclude`.
 *
 * @param {MatchObject} obj a match object to test against the string
 * @param {string} str string to test against the matching object
 * @returns {boolean} true, when the object matches
 * @example
 * ```js
 * ModuleFilenameHelpers.matchObject({ test: "foo.js" }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ test: /^foo/ }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ test: [/^foo/, "bar"] }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ test: [/^foo/, "bar"] }, "baz.js"); // false
 * ModuleFilenameHelpers.matchObject({ include: "foo.js" }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ include: "foo.js" }, "bar.js"); // false
 * ModuleFilenameHelpers.matchObject({ include: /^foo/ }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ include: [/^foo/, "bar"] }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ include: [/^foo/, "bar"] }, "baz.js"); // false
 * ModuleFilenameHelpers.matchObject({ exclude: "foo.js" }, "foo.js"); // false
 * ModuleFilenameHelpers.matchObject({ exclude: [/^foo/, "bar"] }, "foo.js"); // false
 * ```
 */
export function matchObject(obj: MatchObject, str: string): boolean;
export type ChunkGraph = import("./ChunkGraph");
export type Module = import("./Module");
export type RequestShortener = import("./RequestShortener");
export type Hash = typeof import("./util/Hash");
export type Matcher = string | RegExp | (string | RegExp)[];
export type MatchObject = {
    test?: Matcher;
    include?: Matcher;
    exclude?: Matcher;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleGraph.d.ts
export = ModuleGraph;
declare class ModuleGraph {
    /**
     * @param {Module} module the module
     * @param {string} deprecateMessage message for the deprecation message
     * @param {string} deprecationCode code for the deprecation
     * @returns {ModuleGraph} the module graph
     */
    static getModuleGraphForModule(module: Module, deprecateMessage: string, deprecationCode: string): ModuleGraph;
    /**
     * @param {Module} module the module
     * @param {ModuleGraph} moduleGraph the module graph
     * @returns {void}
     */
    static setModuleGraphForModule(module: Module, moduleGraph: ModuleGraph): void;
    /**
     * @param {Module} module the module
     * @returns {void}
     */
    static clearModuleGraphForModule(module: Module): void;
    /** @type {WeakMap<Dependency, ModuleGraphConnection | null>} */
    _dependencyMap: WeakMap<Dependency, ModuleGraphConnection | null>;
    /** @type {Map<Module, ModuleGraphModule>} */
    _moduleMap: Map<Module, ModuleGraphModule>;
    /** @type {WeakMap<any, Object>} */
    _metaMap: WeakMap<any, any>;
    /** @type {WeakTupleMap<any[], any> | undefined} */
    _cache: WeakTupleMap<any[], any> | undefined;
    /** @type {Map<Module, WeakTupleMap<any, any>>} */
    _moduleMemCaches: Map<Module, WeakTupleMap<any, any>>;
    /** @type {string | undefined} */
    _cacheStage: string | undefined;
    /**
     * @param {Module} module the module
     * @returns {ModuleGraphModule} the internal module
     */
    _getModuleGraphModule(module: Module): ModuleGraphModule;
    /**
     * @param {Dependency} dependency the dependency
     * @param {DependenciesBlock} block parent block
     * @param {Module} module parent module
     * @param {number=} indexInBlock position in block
     * @returns {void}
     */
    setParents(dependency: Dependency, block: DependenciesBlock, module: Module, indexInBlock?: number | undefined): void;
    /**
     * @param {Dependency} dependency the dependency
     * @returns {Module} parent module
     */
    getParentModule(dependency: Dependency): Module;
    /**
     * @param {Dependency} dependency the dependency
     * @returns {DependenciesBlock} parent block
     */
    getParentBlock(dependency: Dependency): DependenciesBlock;
    /**
     * @param {Dependency} dependency the dependency
     * @returns {number} index
     */
    getParentBlockIndex(dependency: Dependency): number;
    /**
     * @param {Module} originModule the referencing module
     * @param {Dependency} dependency the referencing dependency
     * @param {Module} module the referenced module
     * @returns {void}
     */
    setResolvedModule(originModule: Module, dependency: Dependency, module: Module): void;
    /**
     * @param {Dependency} dependency the referencing dependency
     * @param {Module} module the referenced module
     * @returns {void}
     */
    updateModule(dependency: Dependency, module: Module): void;
    /**
     * @param {Dependency} dependency the referencing dependency
     * @returns {void}
     */
    removeConnection(dependency: Dependency): void;
    /**
     * @param {Dependency} dependency the referencing dependency
     * @param {string} explanation an explanation
     * @returns {void}
     */
    addExplanation(dependency: Dependency, explanation: string): void;
    /**
     * @param {Module} sourceModule the source module
     * @param {Module} targetModule the target module
     * @returns {void}
     */
    cloneModuleAttributes(sourceModule: Module, targetModule: Module): void;
    /**
     * @param {Module} module the module
     * @returns {void}
     */
    removeModuleAttributes(module: Module): void;
    /**
     * @returns {void}
     */
    removeAllModuleAttributes(): void;
    /**
     * @param {Module} oldModule the old referencing module
     * @param {Module} newModule the new referencing module
     * @param {function(ModuleGraphConnection): boolean} filterConnection filter predicate for replacement
     * @returns {void}
     */
    moveModuleConnections(oldModule: Module, newModule: Module, filterConnection: (arg0: ModuleGraphConnection) => boolean): void;
    /**
     * @param {Module} oldModule the old referencing module
     * @param {Module} newModule the new referencing module
     * @param {function(ModuleGraphConnection): boolean} filterConnection filter predicate for replacement
     * @returns {void}
     */
    copyOutgoingModuleConnections(oldModule: Module, newModule: Module, filterConnection: (arg0: ModuleGraphConnection) => boolean): void;
    /**
     * @param {Module} module the referenced module
     * @param {string} explanation an explanation why it's referenced
     * @returns {void}
     */
    addExtraReason(module: Module, explanation: string): void;
    /**
     * @param {Dependency} dependency the dependency to look for a referenced module
     * @returns {Module | null} the referenced module
     */
    getResolvedModule(dependency: Dependency): Module | null;
    /**
     * @param {Dependency} dependency the dependency to look for a referenced module
     * @returns {ModuleGraphConnection | undefined} the connection
     */
    getConnection(dependency: Dependency): ModuleGraphConnection | undefined;
    /**
     * @param {Dependency} dependency the dependency to look for a referenced module
     * @returns {Module | null} the referenced module
     */
    getModule(dependency: Dependency): Module | null;
    /**
     * @param {Dependency} dependency the dependency to look for a referencing module
     * @returns {Module | null} the referencing module
     */
    getOrigin(dependency: Dependency): Module | null;
    /**
     * @param {Dependency} dependency the dependency to look for a referencing module
     * @returns {Module | null} the original referencing module
     */
    getResolvedOrigin(dependency: Dependency): Module | null;
    /**
     * @param {Module} module the module
     * @returns {Iterable<ModuleGraphConnection>} reasons why a module is included
     */
    getIncomingConnections(module: Module): Iterable<ModuleGraphConnection>;
    /**
     * @param {Module} module the module
     * @returns {Iterable<ModuleGraphConnection>} list of outgoing connections
     */
    getOutgoingConnections(module: Module): Iterable<ModuleGraphConnection>;
    /**
     * @param {Module} module the module
     * @returns {readonly Map<Module | undefined, readonly ModuleGraphConnection[]>} reasons why a module is included, in a map by source module
     */
    getIncomingConnectionsByOriginModule(module: Module): readonly Map<Module | undefined, readonly ModuleGraphConnection[]>;
    /**
     * @param {Module} module the module
     * @returns {readonly Map<Module | undefined, readonly ModuleGraphConnection[]> | undefined} connections to modules, in a map by module
     */
    getOutgoingConnectionsByModule(module: Module): readonly Map<Module | undefined, readonly ModuleGraphConnection[]> | undefined;
    /**
     * @param {Module} module the module
     * @returns {ModuleProfile | null} the module profile
     */
    getProfile(module: Module): ModuleProfile | null;
    /**
     * @param {Module} module the module
     * @param {ModuleProfile | null} profile the module profile
     * @returns {void}
     */
    setProfile(module: Module, profile: ModuleProfile | null): void;
    /**
     * @param {Module} module the module
     * @returns {Module | null} the issuer module
     */
    getIssuer(module: Module): Module | null;
    /**
     * @param {Module} module the module
     * @param {Module | null} issuer the issuer module
     * @returns {void}
     */
    setIssuer(module: Module, issuer: Module | null): void;
    /**
     * @param {Module} module the module
     * @param {Module | null} issuer the issuer module
     * @returns {void}
     */
    setIssuerIfUnset(module: Module, issuer: Module | null): void;
    /**
     * @param {Module} module the module
     * @returns {(string | OptimizationBailoutFunction)[]} optimization bailouts
     */
    getOptimizationBailout(module: Module): (string | OptimizationBailoutFunction)[];
    /**
     * @param {Module} module the module
     * @returns {true | string[] | null} the provided exports
     */
    getProvidedExports(module: Module): true | string[] | null;
    /**
     * @param {Module} module the module
     * @param {string | string[]} exportName a name of an export
     * @returns {boolean | null} true, if the export is provided by the module.
     * null, if it's unknown.
     * false, if it's not provided.
     */
    isExportProvided(module: Module, exportName: string | string[]): boolean | null;
    /**
     * @param {Module} module the module
     * @returns {ExportsInfo} info about the exports
     */
    getExportsInfo(module: Module): ExportsInfo;
    /**
     * @param {Module} module the module
     * @param {string} exportName the export
     * @returns {ExportInfo} info about the export
     */
    getExportInfo(module: Module, exportName: string): ExportInfo;
    /**
     * @param {Module} module the module
     * @param {string} exportName the export
     * @returns {ExportInfo} info about the export (do not modify)
     */
    getReadOnlyExportInfo(module: Module, exportName: string): ExportInfo;
    /**
     * @param {Module} module the module
     * @param {RuntimeSpec} runtime the runtime
     * @returns {false | true | SortableSet<string> | null} the used exports
     * false: module is not used at all.
     * true: the module namespace/object export is used.
     * SortableSet<string>: these export names are used.
     * empty SortableSet<string>: module is used but no export.
     * null: unknown, worst case should be assumed.
     */
    getUsedExports(module: Module, runtime: RuntimeSpec): false | true | SortableSet<string> | null;
    /**
     * @param {Module} module the module
     * @returns {number | null} the index of the module
     */
    getPreOrderIndex(module: Module): number | null;
    /**
     * @param {Module} module the module
     * @returns {number | null} the index of the module
     */
    getPostOrderIndex(module: Module): number | null;
    /**
     * @param {Module} module the module
     * @param {number} index the index of the module
     * @returns {void}
     */
    setPreOrderIndex(module: Module, index: number): void;
    /**
     * @param {Module} module the module
     * @param {number} index the index of the module
     * @returns {boolean} true, if the index was set
     */
    setPreOrderIndexIfUnset(module: Module, index: number): boolean;
    /**
     * @param {Module} module the module
     * @param {number} index the index of the module
     * @returns {void}
     */
    setPostOrderIndex(module: Module, index: number): void;
    /**
     * @param {Module} module the module
     * @param {number} index the index of the module
     * @returns {boolean} true, if the index was set
     */
    setPostOrderIndexIfUnset(module: Module, index: number): boolean;
    /**
     * @param {Module} module the module
     * @returns {number | null} the depth of the module
     */
    getDepth(module: Module): number | null;
    /**
     * @param {Module} module the module
     * @param {number} depth the depth of the module
     * @returns {void}
     */
    setDepth(module: Module, depth: number): void;
    /**
     * @param {Module} module the module
     * @param {number} depth the depth of the module
     * @returns {boolean} true, if the depth was set
     */
    setDepthIfLower(module: Module, depth: number): boolean;
    /**
     * @param {Module} module the module
     * @returns {boolean} true, if the module is async
     */
    isAsync(module: Module): boolean;
    /**
     * @param {Module} module the module
     * @returns {void}
     */
    setAsync(module: Module): void;
    /**
     * @param {any} thing any thing
     * @returns {Object} metadata
     */
    getMeta(thing: any): any;
    /**
     * @param {any} thing any thing
     * @returns {Object | undefined} metadata
     */
    getMetaIfExisting(thing: any): any | undefined;
    /**
     * @param {string=} cacheStage a persistent stage name for caching
     */
    freeze(cacheStage?: string | undefined): void;
    unfreeze(): void;
    /**
     * @template {any[]} T
     * @template V
     * @param {(moduleGraph: ModuleGraph, ...args: T) => V} fn computer
     * @param {T} args arguments
     * @returns {V} computed value or cached
     */
    cached<T extends any[], V>(fn: (moduleGraph: ModuleGraph, ...args: T) => V, ...args: T): V;
    /**
     * @param {Map<Module, WeakTupleMap<any, any>>} moduleMemCaches mem caches for modules for better caching
     */
    setModuleMemCaches(moduleMemCaches: Map<Module, WeakTupleMap<any, any>>): void;
    /**
     * @param {Dependency} dependency dependency
     * @param {...any} args arguments, last argument is a function called with moduleGraph, dependency, ...args
     * @returns {any} computed value or cached
     */
    dependencyCacheProvide(dependency: Dependency, ...args: any[]): any;
}
declare namespace ModuleGraph {
    export { ModuleGraphConnection, DependenciesBlock, Dependency, ExportInfo, Module, ModuleProfile, RequestShortener, RuntimeSpec, OptimizationBailoutFunction };
}
type Dependency = import("./Dependency");
import ModuleGraphConnection = require("webpack/lib/ModuleGraphConnection");
type Module = import("./Module");
declare class ModuleGraphModule {
    /** @type {SortableSet<ModuleGraphConnection>} */
    incomingConnections: SortableSet<ModuleGraphConnection>;
    /** @type {SortableSet<ModuleGraphConnection> | undefined} */
    outgoingConnections: SortableSet<ModuleGraphConnection> | undefined;
    /** @type {Module | null} */
    issuer: Module | null;
    /** @type {(string | OptimizationBailoutFunction)[]} */
    optimizationBailout: (string | OptimizationBailoutFunction)[];
    /** @type {ExportsInfo} */
    exports: ExportsInfo;
    /** @type {number | null} */
    preOrderIndex: number | null;
    /** @type {number | null} */
    postOrderIndex: number | null;
    /** @type {number | null} */
    depth: number | null;
    /** @type {ModuleProfile | undefined | null} */
    profile: ModuleProfile | undefined | null;
    /** @type {boolean} */
    async: boolean;
    /** @type {ModuleGraphConnection[]} */
    _unassignedConnections: ModuleGraphConnection[];
}
import WeakTupleMap = require("webpack/lib/util/WeakTupleMap");
type DependenciesBlock = import("./DependenciesBlock");
type ModuleProfile = import("./ModuleProfile");
type OptimizationBailoutFunction = (requestShortener: RequestShortener) => string;
import ExportsInfo = require("webpack/lib/ExportsInfo");
type ExportInfo = import("./ExportsInfo").ExportInfo;
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
import SortableSet = require("webpack/lib/util/SortableSet");
type RequestShortener = import("./RequestShortener");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleGraphConnection.d.ts
export = ModuleGraphConnection;
declare class ModuleGraphConnection {
    /**
     * @param {Module|null} originModule the referencing module
     * @param {Dependency|null} dependency the referencing dependency
     * @param {Module} module the referenced module
     * @param {string=} explanation some extra detail
     * @param {boolean=} weak the reference is weak
     * @param {false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState=} condition condition for the connection
     */
    constructor(originModule: Module | null, dependency: Dependency | null, module: Module, explanation?: string | undefined, weak?: boolean | undefined, condition?: (false | ((arg0: ModuleGraphConnection, arg1: RuntimeSpec) => ConnectionState)) | undefined);
    originModule: import("webpack/lib/Module");
    resolvedOriginModule: import("webpack/lib/Module");
    dependency: import("webpack/lib/Dependency");
    resolvedModule: import("webpack/lib/Module");
    module: import("webpack/lib/Module");
    weak: boolean;
    conditional: boolean;
    _active: boolean;
    /** @type {(function(ModuleGraphConnection, RuntimeSpec): ConnectionState) | undefined} */
    condition: ((arg0: ModuleGraphConnection, arg1: RuntimeSpec) => ConnectionState) | undefined;
    /** @type {Set<string> | undefined} */
    explanations: Set<string> | undefined;
    clone(): ModuleGraphConnection;
    /**
     * @param {function(ModuleGraphConnection, RuntimeSpec): ConnectionState} condition condition for the connection
     * @returns {void}
     */
    addCondition(condition: (arg0: ModuleGraphConnection, arg1: RuntimeSpec) => ConnectionState): void;
    /**
     * @param {string} explanation the explanation to add
     * @returns {void}
     */
    addExplanation(explanation: string): void;
    get explanation(): string;
    set active(arg: void);
    get active(): void;
    /**
     * @param {RuntimeSpec} runtime the runtime
     * @returns {boolean} true, if the connection is active
     */
    isActive(runtime: RuntimeSpec): boolean;
    /**
     * @param {RuntimeSpec} runtime the runtime
     * @returns {boolean} true, if the connection is active
     */
    isTargetActive(runtime: RuntimeSpec): boolean;
    /**
     * @param {RuntimeSpec} runtime the runtime
     * @returns {ConnectionState} true: fully active, false: inactive, TRANSITIVE: direct module inactive, but transitive connection maybe active
     */
    getActiveState(runtime: RuntimeSpec): ConnectionState;
    /**
     * @param {boolean} value active or not
     * @returns {void}
     */
    setActive(value: boolean): void;
}
declare namespace ModuleGraphConnection {
    export { addConnectionStates, TRANSITIVE_ONLY, CIRCULAR_CONNECTION, Dependency, Module, RuntimeSpec, ConnectionState };
}
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
type ConnectionState = boolean | typeof TRANSITIVE_ONLY | typeof CIRCULAR_CONNECTION;
type Module = import("./Module");
type Dependency = import("./Dependency");
/** @typedef {boolean | typeof TRANSITIVE_ONLY | typeof CIRCULAR_CONNECTION} ConnectionState */
/**
 * @param {ConnectionState} a first
 * @param {ConnectionState} b second
 * @returns {ConnectionState} merged
 */
declare function addConnectionStates(a: ConnectionState, b: ConnectionState): ConnectionState;
type TRANSITIVE_ONLY = typeof TRANSITIVE_ONLY;
declare const TRANSITIVE_ONLY: typeof TRANSITIVE_ONLY;
type CIRCULAR_CONNECTION = typeof CIRCULAR_CONNECTION;
declare const CIRCULAR_CONNECTION: typeof CIRCULAR_CONNECTION;
/** @typedef {import("./Dependency")} Dependency */
/** @typedef {import("./Module")} Module */
/** @typedef {import("./util/runtime").RuntimeSpec} RuntimeSpec */
/**
 * Module itself is not connected, but transitive modules are connected transitively.
 */
declare const TRANSITIVE_ONLY: unique symbol;
/**
 * While determining the active state, this flag is used to signal a circular connection.
 */
declare const CIRCULAR_CONNECTION: unique symbol;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleHashingError.d.ts
export = ModuleHashingError;
/** @typedef {import("./Module")} Module */
declare class ModuleHashingError extends WebpackError {
    /**
     * Create a new ModuleHashingError
     * @param {Module} module related module
     * @param {Error} error Original error
     */
    constructor(module: Module, error: Error);
    error: Error;
}
declare namespace ModuleHashingError {
    export { Module };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("./Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleInfoHeaderPlugin.d.ts
export = ModuleInfoHeaderPlugin;
declare class ModuleInfoHeaderPlugin {
    /**
     * @param {boolean=} verbose add more information like exports, runtime requirements and bailouts
     */
    constructor(verbose?: boolean | undefined);
    _verbose: boolean;
    /**
     * @param {Compiler} compiler the compiler
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ModuleInfoHeaderPlugin {
    export { Source, Compiler, ExportsInfo, ExportInfo, Module, BuildMeta, ModuleGraph, ModuleTemplate, RequestShortener };
}
type Compiler = import("./Compiler");
type Source = import("webpack-sources").Source;
type ExportsInfo = import("./ExportsInfo");
type ExportInfo = import("./ExportsInfo").ExportInfo;
type Module = import("./Module");
type BuildMeta = import("./Module").BuildMeta;
type ModuleGraph = import("./ModuleGraph");
type ModuleTemplate = import("./ModuleTemplate");
type RequestShortener = import("./RequestShortener");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleNotFoundError.d.ts
export = ModuleNotFoundError;
declare class ModuleNotFoundError extends WebpackError {
    /**
     * @param {Module | null} module module tied to dependency
     * @param {Error&any} err error thrown
     * @param {DependencyLocation} loc location of dependency
     */
    constructor(module: Module | null, err: Error & any, loc: DependencyLocation);
    details: any;
    error: any;
}
declare namespace ModuleNotFoundError {
    export { DependencyLocation, Module };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("./Module");
type DependencyLocation = import("./Dependency").DependencyLocation;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleParseError.d.ts
export = ModuleParseError;
declare class ModuleParseError extends WebpackError {
    /**
     * @param {string | Buffer} source source code
     * @param {Error&any} err the parse error
     * @param {string[]} loaders the loaders used
     * @param {string} type module type
     */
    constructor(source: string | Buffer, err: Error & any, loaders: string[], type: string);
    loc: {
        start: any;
    };
    error: any;
}
declare namespace ModuleParseError {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
import WebpackError = require("webpack/lib/WebpackError");
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleProfile.d.ts
export = ModuleProfile;
declare class ModuleProfile {
    startTime: number;
    factoryStartTime: number;
    factoryEndTime: number;
    factory: number;
    factoryParallelismFactor: number;
    restoringStartTime: number;
    restoringEndTime: number;
    restoring: number;
    restoringParallelismFactor: number;
    integrationStartTime: number;
    integrationEndTime: number;
    integration: number;
    integrationParallelismFactor: number;
    buildingStartTime: number;
    buildingEndTime: number;
    building: number;
    buildingParallelismFactor: number;
    storingStartTime: number;
    storingEndTime: number;
    storing: number;
    storingParallelismFactor: number;
    /** @type {{ start: number, end: number }[] | undefined } */
    additionalFactoryTimes: {
        start: number;
        end: number;
    }[] | undefined;
    additionalFactories: number;
    additionalFactoriesParallelismFactor: number;
    /** @deprecated */
    additionalIntegration: number;
    markFactoryStart(): void;
    markFactoryEnd(): void;
    markRestoringStart(): void;
    markRestoringEnd(): void;
    markIntegrationStart(): void;
    markIntegrationEnd(): void;
    markBuildingStart(): void;
    markBuildingEnd(): void;
    markStoringStart(): void;
    markStoringEnd(): void;
    /**
     * Merge this profile into another one
     * @param {ModuleProfile} realProfile the profile to merge into
     * @returns {void}
     */
    mergeInto(realProfile: ModuleProfile): void;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleRestoreError.d.ts
export = ModuleRestoreError;
/** @typedef {import("./Module")} Module */
declare class ModuleRestoreError extends WebpackError {
    /**
     * @param {Module} module module tied to dependency
     * @param {string | Error} err error thrown
     */
    constructor(module: Module, err: string | Error);
    error: string | Error;
}
declare namespace ModuleRestoreError {
    export { Module };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("./Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleStoreError.d.ts
export = ModuleStoreError;
/** @typedef {import("./Module")} Module */
declare class ModuleStoreError extends WebpackError {
    /**
     * @param {Module} module module tied to dependency
     * @param {string | Error} err error thrown
     */
    constructor(module: Module, err: string | Error);
    error: string | Error;
}
declare namespace ModuleStoreError {
    export { Module };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("./Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleTemplate.d.ts
export = ModuleTemplate;
declare class ModuleTemplate {
    /**
     * @param {RuntimeTemplate} runtimeTemplate the runtime template
     * @param {Compilation} compilation the compilation
     */
    constructor(runtimeTemplate: RuntimeTemplate, compilation: Compilation);
    _runtimeTemplate: import("webpack/lib/RuntimeTemplate");
    type: string;
    hooks: Readonly<{
        content: {
            tap: (options: any, fn: any) => void;
        };
        module: {
            tap: (options: any, fn: any) => void;
        };
        render: {
            tap: (options: any, fn: any) => void;
        };
        package: {
            tap: (options: any, fn: any) => void;
        };
        hash: {
            tap: (options: any, fn: any) => void;
        };
    }>;
    get runtimeTemplate(): TODO;
}
declare namespace ModuleTemplate {
    export { Source, Chunk, ChunkGraph, Compilation, DependencyTemplates, Module, ModuleGraph, RuntimeTemplate, Hash };
}
type RuntimeTemplate = import("./RuntimeTemplate");
type Compilation = import("./Compilation");
type Source = import("webpack-sources").Source;
type Chunk = import("./Chunk");
type ChunkGraph = import("./ChunkGraph");
type DependencyTemplates = import("./DependencyTemplates");
type Module = import("./Module");
type ModuleGraph = import("./ModuleGraph");
type Hash = import("./util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleTypeConstants.d.ts
export type JavaScriptModuleTypes = "javascript/auto" | "javascript/dynamic" | "javascript/esm";
export type JSONModuleType = "json";
export type WebAssemblyModuleTypes = "webassembly/async" | "webassembly/sync";
export type CSSModuleTypes = "css" | "css/global" | "css/module";
export type AssetModuleTypes = "asset" | "asset/inline" | "asset/resource" | "asset/source" | "asset/raw-data-url";
export type WebpackModuleTypes = "runtime" | "fallback-module" | "remote-module" | "provide-module" | "consume-shared-module" | "lazy-compilation-proxy";
export type UnknownModuleTypes = string;
export type ModuleTypes = JavaScriptModuleTypes | JSONModuleType | WebAssemblyModuleTypes | CSSModuleTypes | AssetModuleTypes | WebpackModuleTypes | UnknownModuleTypes;
/**
 * @type {Readonly<"asset">}
 * This is the module type used for automatically choosing between `asset/inline`, `asset/resource` based on asset size limit (8096).
 */
export const ASSET_MODULE_TYPE: Readonly<"asset">;
/**
 * @type {Readonly<"asset/raw-data-url">}
 * TODO: Document what this asset type is for. See css-loader tests for its usage.
 */
export const ASSET_MODULE_TYPE_RAW_DATA_URL: Readonly<"asset/raw-data-url">;
/**
 * @type {Readonly<"asset/source">}
 * This is the module type used for assets that are imported as source code. This is the equivalent of `raw-loader`.
 */
export const ASSET_MODULE_TYPE_SOURCE: Readonly<"asset/source">;
/**
 * @type {Readonly<"asset/resource">}
 * This is the module type used for assets that are copied to the output directory. This is the equivalent of `file-loader`.
 */
export const ASSET_MODULE_TYPE_RESOURCE: Readonly<"asset/resource">;
/**
 * @type {Readonly<"asset/inline">}
 * This is the module type used for assets that are inlined as a data URI. This is the equivalent of `url-loader`.
 */
export const ASSET_MODULE_TYPE_INLINE: Readonly<"asset/inline">;
/**
 * @type {Readonly<"javascript/auto">}
 */
export const JAVASCRIPT_MODULE_TYPE_AUTO: Readonly<"javascript/auto">;
/**
 * @type {Readonly<"javascript/dynamic">}
 */
export const JAVASCRIPT_MODULE_TYPE_DYNAMIC: Readonly<"javascript/dynamic">;
/**
 * @type {Readonly<"javascript/esm">}
 * This is the module type used for _strict_ ES Module syntax. This means that all legacy formats
 * that webpack supports (CommonJS, AMD, SystemJS) are not supported.
 */
export const JAVASCRIPT_MODULE_TYPE_ESM: Readonly<"javascript/esm">;
/**
 * @type {Readonly<"json">}
 * This is the module type used for JSON files. JSON files are always parsed as ES Module.
 */
export const JSON_MODULE_TYPE: Readonly<"json">;
/**
 * @type {Readonly<"webassembly/async">}
 * This is the module type used for WebAssembly modules. In webpack 5 they are always treated as async modules.
 *
 */
export const WEBASSEMBLY_MODULE_TYPE_ASYNC: Readonly<"webassembly/async">;
/**
 * @type {Readonly<"webassembly/sync">}
 * This is the module type used for WebAssembly modules. In webpack 4 they are always treated as sync modules.
 * There is a legacy option to support this usage in webpack 5 and up.
 */
export const WEBASSEMBLY_MODULE_TYPE_SYNC: Readonly<"webassembly/sync">;
/**
 * @type {Readonly<"css">}
 * This is the module type used for CSS files.
 */
export const CSS_MODULE_TYPE: Readonly<"css">;
/**
 * @type {Readonly<"css/global">}
 * This is the module type used for CSS modules files where you need to use `:local` in selector list to hash classes.
 */
export const CSS_MODULE_TYPE_GLOBAL: Readonly<"css/global">;
/**
 * @type {Readonly<"css/module">}
 * This is the module type used for CSS modules files, by default all classes are hashed.
 */
export const CSS_MODULE_TYPE_MODULE: Readonly<"css/module">;
/**
 * @type {Readonly<"css/auto">}
 * This is the module type used for CSS files, the module will be parsed as CSS modules if it's filename contains `.module.` or `.modules.`.
 */
export const CSS_MODULE_TYPE_AUTO: Readonly<"css/auto">;
/**
 * @type {Readonly<"runtime">}
 * This is the module type used for the webpack runtime abstractions.
 */
export const WEBPACK_MODULE_TYPE_RUNTIME: Readonly<"runtime">;
/**
 * @type {Readonly<"fallback-module">}
 * This is the module type used for the ModuleFederation feature's FallbackModule class.
 * TODO: Document this better.
 */
export const WEBPACK_MODULE_TYPE_FALLBACK: Readonly<"fallback-module">;
/**
 * @type {Readonly<"remote-module">}
 * This is the module type used for the ModuleFederation feature's RemoteModule class.
 * TODO: Document this better.
 */
export const WEBPACK_MODULE_TYPE_REMOTE: Readonly<"remote-module">;
/**
 * @type {Readonly<"provide-module">}
 * This is the module type used for the ModuleFederation feature's ProvideModule class.
 * TODO: Document this better.
 */
export const WEBPACK_MODULE_TYPE_PROVIDE: Readonly<"provide-module">;
/**
 * @type {Readonly<"consume-shared-module">}
 * This is the module type used for the ModuleFederation feature's ConsumeSharedModule class.
 */
export const WEBPACK_MODULE_TYPE_CONSUME_SHARED_MODULE: Readonly<"consume-shared-module">;
/**
 * @type {Readonly<"lazy-compilation-proxy">}
 * Module type used for `experiments.lazyCompilation` feature. See `LazyCompilationPlugin` for more information.
 */
export const WEBPACK_MODULE_TYPE_LAZY_COMPILATION_PROXY: Readonly<"lazy-compilation-proxy">;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ModuleWarning.d.ts
export = ModuleWarning;
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class ModuleWarning extends WebpackError {
    /**
     * @param {Error} warning error thrown
     * @param {{from?: string|null}} info additional info
     */
    constructor(warning: Error, { from }?: {
        from?: string | null;
    });
    warning: Error;
}
declare namespace ModuleWarning {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
import WebpackError = require("webpack/lib/WebpackError");
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/MultiCompiler.d.ts
export = MultiCompiler;
declare class MultiCompiler {
    /**
     * @param {Compiler[] | Record<string, Compiler>} compilers child compilers
     * @param {MultiCompilerOptions} options options
     */
    constructor(compilers: Compiler[] | Record<string, Compiler>, options: MultiCompilerOptions);
    hooks: Readonly<{
        /** @type {SyncHook<[MultiStats]>} */
        done: SyncHook<[MultiStats]>;
        /** @type {MultiHook<SyncHook<[string | null, number]>>} */
        invalid: MultiHook<SyncHook<[string | null, number]>>;
        /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */
        run: MultiHook<AsyncSeriesHook<[Compiler]>>;
        /** @type {SyncHook<[]>} */
        watchClose: SyncHook<[]>;
        /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */
        watchRun: MultiHook<AsyncSeriesHook<[Compiler]>>;
        /** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */
        infrastructureLog: MultiHook<SyncBailHook<[string, string, any[]], true>>;
    }>;
    compilers: import("webpack/lib/Compiler")[];
    /** @type {MultiCompilerOptions} */
    _options: MultiCompilerOptions;
    /** @type {WeakMap<Compiler, string[]>} */
    dependencies: WeakMap<Compiler, string[]>;
    running: boolean;
    get options(): any[] & MultiCompilerOptions;
    get outputPath(): string;
    /**
     * @param {InputFileSystem} value the new input file system
     */
    set inputFileSystem(arg: import("webpack/lib/util/fs").InputFileSystem);
    get inputFileSystem(): import("webpack/lib/util/fs").InputFileSystem;
    /**
     * @param {OutputFileSystem} value the new output file system
     */
    set outputFileSystem(arg: import("webpack/lib/util/fs").OutputFileSystem);
    get outputFileSystem(): import("webpack/lib/util/fs").OutputFileSystem;
    /**
     * @param {WatchFileSystem} value the new watch file system
     */
    set watchFileSystem(arg: import("webpack/lib/util/fs").WatchFileSystem);
    get watchFileSystem(): import("webpack/lib/util/fs").WatchFileSystem;
    /**
     * @param {IntermediateFileSystem} value the new intermediate file system
     */
    set intermediateFileSystem(arg: import("webpack/lib/util/fs").IntermediateFileSystem);
    get intermediateFileSystem(): import("webpack/lib/util/fs").IntermediateFileSystem;
    getInfrastructureLogger(name: any): import("webpack/lib/logging/Logger").Logger;
    /**
     * @param {Compiler} compiler the child compiler
     * @param {string[]} dependencies its dependencies
     * @returns {void}
     */
    setDependencies(compiler: Compiler, dependencies: string[]): void;
    /**
     * @param {Callback<MultiStats>} callback signals when the validation is complete
     * @returns {boolean} true if the dependencies are valid
     */
    validateDependencies(callback: Callback<MultiStats>): boolean;
    /**
     * @deprecated This method should have been private
     * @param {Compiler[]} compilers the child compilers
     * @param {RunWithDependenciesHandler} fn a handler to run for each compiler
     * @param {Callback<MultiStats>} callback the compiler's handler
     * @returns {void}
     */
    runWithDependencies(compilers: Compiler[], fn: RunWithDependenciesHandler, callback: Callback<MultiStats>): void;
    /**
     * @template SetupResult
     * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler
     * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler
     * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers
     * @returns {SetupResult[]} result of setup
     */
    _runGraph<SetupResult>(setup: (arg0: Compiler, arg1: number, arg2: Callback<Stats>, arg3: () => boolean, arg4: () => void, arg5: () => void) => SetupResult, run: (arg0: Compiler, arg1: SetupResult, arg2: Callback<Stats>) => void, callback: Callback<MultiStats>): SetupResult[];
    /**
     * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options
     * @param {Callback<MultiStats>} handler signals when the call finishes
     * @returns {MultiWatching} a compiler watcher
     */
    watch(watchOptions: WatchOptions | WatchOptions[], handler: Callback<MultiStats>): MultiWatching;
    /**
     * @param {Callback<MultiStats>} callback signals when the call finishes
     * @returns {void}
     */
    run(callback: Callback<MultiStats>): void;
    purgeInputFileSystem(): void;
    /**
     * @param {Callback<void>} callback signals when the compiler closes
     * @returns {void}
     */
    close(callback: Callback<void>): void;
}
declare namespace MultiCompiler {
    export { AsyncSeriesHook, SyncBailHook, WatchOptions, Compiler, Stats, Watching, InputFileSystem, IntermediateFileSystem, OutputFileSystem, WatchFileSystem, Callback, RunWithDependenciesHandler, MultiCompilerOptions };
}
import { SyncHook } from "tapable";
import MultiStats = require("webpack/lib/MultiStats");
import { MultiHook } from "tapable";
/**
 * <T>
 */
type AsyncSeriesHook<T> = import("tapable").AsyncSeriesHook<T>;
type Compiler = import("./Compiler");
/**
 * <T, R>
 */
type SyncBailHook<T, R> = import("tapable").SyncBailHook<T, R>;
type MultiCompilerOptions = {
    /**
     * how many Compilers are allows to run at the same time in parallel
     */
    parallelism?: number | undefined;
};
type Callback<T> = (err?: (Error | null) | undefined, result?: T | undefined) => any;
type RunWithDependenciesHandler = (compiler: Compiler, callback: Callback<MultiStats>) => any;
type Stats = import("./Stats");
type WatchOptions = any;
import MultiWatching = require("webpack/lib/MultiWatching");
type Watching = import("./Watching");
type InputFileSystem = import("./util/fs").InputFileSystem;
type IntermediateFileSystem = import("./util/fs").IntermediateFileSystem;
type OutputFileSystem = import("./util/fs").OutputFileSystem;
type WatchFileSystem = import("./util/fs").WatchFileSystem;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/MultiStats.d.ts
export = MultiStats;
declare class MultiStats {
    /**
     * @param {Stats[]} stats the child stats
     */
    constructor(stats: Stats[]);
    stats: import("webpack/lib/Stats")[];
    get hash(): string;
    /**
     * @returns {boolean} true if a child compilation encountered an error
     */
    hasErrors(): boolean;
    /**
     * @returns {boolean} true if a child compilation had a warning
     */
    hasWarnings(): boolean;
    _createChildOptions(options: any, context: any): {
        version: boolean;
        hash: boolean;
        errorsCount: boolean;
        warningsCount: boolean;
        errors: boolean;
        warnings: boolean;
        children: import("webpack/lib/Compilation").NormalizedStatsOptions[];
    };
    /**
     * @param {any} options stats options
     * @returns {StatsCompilation} json output
     */
    toJson(options: any): StatsCompilation;
    toString(options: any): string;
}
declare namespace MultiStats {
    export { StatsOptions, Stats, KnownStatsCompilation, StatsCompilation };
}
type StatsCompilation = import("./stats/DefaultStatsFactoryPlugin").StatsCompilation;
type Stats = import("./Stats");
type StatsOptions = any;
type KnownStatsCompilation = import("./stats/DefaultStatsFactoryPlugin").KnownStatsCompilation;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/MultiWatching.d.ts
export = MultiWatching;
/** @typedef {import("./MultiCompiler")} MultiCompiler */
/** @typedef {import("./Watching")} Watching */
/**
 * @template T
 * @callback Callback
 * @param {(Error | null)=} err
 * @param {T=} result
 */
declare class MultiWatching {
    /**
     * @param {Watching[]} watchings child compilers' watchers
     * @param {MultiCompiler} compiler the compiler
     */
    constructor(watchings: Watching[], compiler: MultiCompiler);
    watchings: import("webpack/lib/Watching")[];
    compiler: import("webpack/lib/MultiCompiler");
    /**
     * @param {Callback<void>=} callback signals when the build has completed again
     * @returns {void}
     */
    invalidate(callback?: Callback<void> | undefined): void;
    suspend(): void;
    resume(): void;
    /**
     * @param {Callback<void>} callback signals when the watcher is closed
     * @returns {void}
     */
    close(callback: Callback<void>): void;
}
declare namespace MultiWatching {
    export { MultiCompiler, Watching, Callback };
}
type Callback<T> = (err?: (Error | null) | undefined, result?: T | undefined) => any;
type Watching = import("./Watching");
type MultiCompiler = import("./MultiCompiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/NoEmitOnErrorsPlugin.d.ts
export = NoEmitOnErrorsPlugin;
/** @typedef {import("./Compiler")} Compiler */
declare class NoEmitOnErrorsPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace NoEmitOnErrorsPlugin {
    export { Compiler };
}
type Compiler = import("./Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/NoModeWarning.d.ts
export = NoModeWarning;
declare class NoModeWarning extends WebpackError {
    constructor();
}
import WebpackError = require("webpack/lib/WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/NodeStuffInWebError.d.ts
export = NodeStuffInWebError;
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
declare class NodeStuffInWebError extends WebpackError {
    /**
     * @param {DependencyLocation} loc loc
     * @param {string} expression expression
     * @param {string} description description
     */
    constructor(loc: DependencyLocation, expression: string, description: string);
}
declare namespace NodeStuffInWebError {
    export { DependencyLocation };
}
import WebpackError = require("webpack/lib/WebpackError");
type DependencyLocation = import("./Dependency").DependencyLocation;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/NodeStuffPlugin.d.ts
export = NodeStuffPlugin;
declare class NodeStuffPlugin {
    /**
     * @param {NodeOptions} options options
     */
    constructor(options: any);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace NodeStuffPlugin {
    export { ReplaceSource, JavascriptParserOptions, NodeOptions, Compiler, Dependency, DependencyLocation, DependencyTemplates, NormalModule, RuntimeTemplate, JavascriptParser, Range };
}
type Compiler = import("./Compiler");
type ReplaceSource = import("webpack-sources").ReplaceSource;
type JavascriptParserOptions = any;
type NodeOptions = any;
type Dependency = import("./Dependency");
type DependencyLocation = import("./Dependency").DependencyLocation;
type DependencyTemplates = import("./DependencyTemplates");
type NormalModule = import("./NormalModule");
type RuntimeTemplate = import("./RuntimeTemplate");
type JavascriptParser = import("./javascript/JavascriptParser");
type Range = import("./javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/NormalModule.d.ts
export = NormalModule;
declare class NormalModule extends Module {
    /**
     * @param {Compilation} compilation the compilation
     * @returns {NormalModuleCompilationHooks} the attached hooks
     */
    static getCompilationHooks(compilation: Compilation): NormalModuleCompilationHooks;
    static deserialize(context: any): NormalModule;
    /**
     * @param {NormalModuleCreateData} options options object
     */
    constructor({ layer, type, request, userRequest, rawRequest, loaders, resource, resourceResolveData, context, matchResource, parser, parserOptions, generator, generatorOptions, resolveOptions }: NormalModuleCreateData);
    /** @type {string} */
    request: string;
    /** @type {string} */
    userRequest: string;
    /** @type {string} */
    rawRequest: string;
    /** @type {boolean} */
    binary: boolean;
    /** @type {Parser} */
    parser: Parser;
    parserOptions: Record<string, any>;
    /** @type {Generator} */
    generator: Generator;
    generatorOptions: Record<string, any>;
    /** @type {string} */
    resource: string;
    resourceResolveData: Record<string, any>;
    /** @type {string | undefined} */
    matchResource: string | undefined;
    /** @type {LoaderItem[]} */
    loaders: LoaderItem[];
    /** @type {(WebpackError | null)=} */
    error: (WebpackError | null) | undefined;
    /** @private @type {Source=} */
    private _source;
    /** @private @type {Map<string, number> | undefined} **/
    private _sourceSizes;
    /** @private @type {Set<string>} */
    private _sourceTypes;
    _lastSuccessfulBuildMeta: {};
    _forceBuild: boolean;
    _isEvaluatingSideEffects: boolean;
    /** @type {WeakSet<ModuleGraph> | undefined} */
    _addedSideEffectsBailout: WeakSet<ModuleGraph> | undefined;
    /** @type {Map<string, any>} */
    _codeGeneratorData: Map<string, any>;
    restoreFromUnsafeCache(unsafeCacheData: any, normalModuleFactory: any): void;
    /**
     * @param {string} context the compilation context
     * @param {string} name the asset name
     * @param {string} content the content
     * @param {string | TODO} sourceMap an optional source map
     * @param {Object=} associatedObjectForCache object for caching
     * @returns {Source} the created source
     */
    createSourceForAsset(context: string, name: string, content: string, sourceMap: string | TODO, associatedObjectForCache?: any | undefined): Source;
    /**
     * @param {ResolverWithOptions} resolver a resolver
     * @param {WebpackOptions} options webpack options
     * @param {Compilation} compilation the compilation
     * @param {InputFileSystem} fs file system from reading
     * @param {NormalModuleCompilationHooks} hooks the hooks
     * @returns {NormalModuleLoaderContext} loader context
     */
    _createLoaderContext(resolver: ResolverWithOptions, options: any, compilation: Compilation, fs: InputFileSystem, hooks: NormalModuleCompilationHooks): any;
    getCurrentLoader(loaderContext: any, index?: any): LoaderItem;
    /**
     * @param {string} context the compilation context
     * @param {string | Buffer} content the content
     * @param {string | TODO} sourceMap an optional source map
     * @param {Object=} associatedObjectForCache object for caching
     * @returns {Source} the created source
     */
    createSource(context: string, content: string | Buffer, sourceMap: string | TODO, associatedObjectForCache?: any | undefined): Source;
    /**
     * @param {WebpackOptions} options webpack options
     * @param {Compilation} compilation the compilation
     * @param {ResolverWithOptions} resolver the resolver
     * @param {InputFileSystem} fs the file system
     * @param {NormalModuleCompilationHooks} hooks the hooks
     * @param {function((WebpackError | null)=): void} callback callback function
     * @returns {void}
     */
    _doBuild(options: any, compilation: Compilation, resolver: ResolverWithOptions, fs: InputFileSystem, hooks: NormalModuleCompilationHooks, callback: (arg0: (WebpackError | null) | undefined) => void): void;
    _ast: any;
    /**
     * @param {WebpackError} error the error
     * @returns {void}
     */
    markModuleAsErrored(error: WebpackError): void;
    applyNoParseRule(rule: any, content: any): any;
    shouldPreventParsing(noParseRule: any, request: any): any;
    _initBuildHash(compilation: any): void;
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context: UpdateHashContext): void;
}
declare namespace NormalModule {
    export { Source, NormalModuleLoaderContext, Mode, ResolveOptions, WebpackOptions, ChunkGraph, Compiler, UpdateHashContext, DependencyTemplates, Generator, CodeGenerationContext, CodeGenerationResult, ConcatenationBailoutReasonContext, LibIdentOptions, NeedBuildContext, ModuleGraph, ConnectionState, JavaScriptModuleTypes, NormalModuleFactory, Parser, RequestShortener, ResolverWithOptions, RuntimeTemplate, WebpackLogger, ObjectDeserializerContext, ObjectSerializerContext, Hash, InputFileSystem, RuntimeSpec, SourceMap, LoaderItem, NormalModuleCompilationHooks, NormalModuleCreateData };
}
import Module = require("webpack/lib/Module");
type Parser = import("./Parser");
type Generator = import("./Generator");
type LoaderItem = {
    loader: string;
    options: any;
    ident: string | null;
    type: string | null;
};
import WebpackError = require("webpack/lib/WebpackError");
type ModuleGraph = import("./ModuleGraph");
type Source = import("webpack-sources").Source;
type ResolverWithOptions = import("./ResolverFactory").ResolverWithOptions;
import Compilation = require("webpack/lib/Compilation");
type InputFileSystem = import("./util/fs").InputFileSystem;
type NormalModuleCompilationHooks = {
    loader: SyncHook<[object, NormalModule]>;
    beforeLoaders: SyncHook<[LoaderItem[], NormalModule, object]>;
    beforeParse: SyncHook<[NormalModule]>;
    beforeSnapshot: SyncHook<[NormalModule]>;
    readResourceForScheme: HookMap<AsyncSeriesBailHook<[string, NormalModule], string | Buffer>>;
    readResource: HookMap<AsyncSeriesBailHook<[object], string | Buffer>>;
    needBuild: AsyncSeriesBailHook<[NormalModule, NeedBuildContext], boolean>;
};
type Hash = import("./util/Hash");
type UpdateHashContext = import("./Dependency").UpdateHashContext;
type NormalModuleCreateData = {
    /**
     * an optional layer in which the module is
     */
    layer?: string | undefined;
    /**
     * module type. When deserializing, this is set to an empty string "".
     */
    type: JavaScriptModuleTypes | "";
    /**
     * request string
     */
    request: string;
    /**
     * request intended by user (without loaders from config)
     */
    userRequest: string;
    /**
     * request without resolving
     */
    rawRequest: string;
    /**
     * list of loaders
     */
    loaders: LoaderItem[];
    /**
     * path + query of the real resource
     */
    resource: string;
    /**
     * resource resolve data
     */
    resourceResolveData?: Record<string, any> | undefined;
    /**
     * context directory for resolving
     */
    context: string;
    /**
     * path + query of the matched resource (virtual)
     */
    matchResource?: string | undefined;
    /**
     * the parser used
     */
    parser: Parser;
    /**
     * the options of the parser used
     */
    parserOptions?: Record<string, any> | undefined;
    /**
     * the generator used
     */
    generator: Generator;
    /**
     * the options of the generator used
     */
    generatorOptions?: Record<string, any> | undefined;
    /**
     * options used for resolving requests from this module
     */
    resolveOptions?: any;
};
type NormalModuleLoaderContext = any;
type Mode = any;
type ResolveOptions = any;
type WebpackOptions = any;
type ChunkGraph = import("./ChunkGraph");
type Compiler = import("./Compiler");
type DependencyTemplates = import("./DependencyTemplates");
type CodeGenerationContext = import("./Module").CodeGenerationContext;
type CodeGenerationResult = import("./Module").CodeGenerationResult;
type ConcatenationBailoutReasonContext = import("./Module").ConcatenationBailoutReasonContext;
type LibIdentOptions = import("./Module").LibIdentOptions;
type NeedBuildContext = import("./Module").NeedBuildContext;
type ConnectionState = import("./ModuleGraphConnection").ConnectionState;
type JavaScriptModuleTypes = import("./ModuleTypeConstants").JavaScriptModuleTypes;
type NormalModuleFactory = import("./NormalModuleFactory");
type RequestShortener = import("./RequestShortener");
type RuntimeTemplate = import("./RuntimeTemplate");
type WebpackLogger = import("./logging/Logger").Logger;
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
type SourceMap = {
    version: number;
    sources: string[];
    mappings: string;
    file?: string | undefined;
    sourceRoot?: string | undefined;
    sourcesContent?: string[] | undefined;
    names?: string[] | undefined;
};
import { SyncHook } from "tapable";
import { HookMap } from "tapable";
import { AsyncSeriesBailHook } from "tapable";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/NormalModuleFactory.d.ts
export = NormalModuleFactory;
declare class NormalModuleFactory extends ModuleFactory {
    /**
     * @param {Object} param params
     * @param {string=} param.context context
     * @param {InputFileSystem} param.fs file system
     * @param {ResolverFactory} param.resolverFactory resolverFactory
     * @param {ModuleOptions} param.options options
     * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
     * @param {boolean=} param.layers enable layers
     */
    constructor({ context, fs, resolverFactory, options, associatedObjectForCache, layers }: {
        context?: string | undefined;
        fs: InputFileSystem;
        resolverFactory: ResolverFactory;
        options: ModuleOptions;
        associatedObjectForCache?: any | undefined;
        layers?: boolean | undefined;
    });
    hooks: Readonly<{
        /** @type {AsyncSeriesBailHook<[ResolveData], Module | false | void>} */
        resolve: AsyncSeriesBailHook<[ResolveData], Module | false | void>;
        /** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
        resolveForScheme: HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>;
        /** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
        resolveInScheme: HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>;
        /** @type {AsyncSeriesBailHook<[ResolveData], Module>} */
        factorize: AsyncSeriesBailHook<[ResolveData], Module>;
        /** @type {AsyncSeriesBailHook<[ResolveData], false | void>} */
        beforeResolve: AsyncSeriesBailHook<[ResolveData], false | void>;
        /** @type {AsyncSeriesBailHook<[ResolveData], false | void>} */
        afterResolve: AsyncSeriesBailHook<[ResolveData], false | void>;
        /** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], Module | void>} */
        createModule: AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], Module | void>;
        /** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], Module>} */
        module: SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], Module>;
        createParser: HookMap<SyncBailHook<any, any, import("tapable").UnsetAdditionalOptions>>;
        parser: HookMap<SyncHook<any, void, import("tapable").UnsetAdditionalOptions>>;
        createGenerator: HookMap<SyncBailHook<any, any, import("tapable").UnsetAdditionalOptions>>;
        generator: HookMap<SyncHook<any, void, import("tapable").UnsetAdditionalOptions>>;
        createModuleClass: HookMap<SyncBailHook<any, any, import("tapable").UnsetAdditionalOptions>>;
    }>;
    resolverFactory: import("webpack/lib/ResolverFactory");
    ruleSet: RuleSetCompiler.RuleSet;
    context: string;
    fs: import("webpack/lib/util/fs").InputFileSystem;
    _globalParserOptions: any;
    _globalGeneratorOptions: any;
    /** @type {Map<string, WeakMap<Object, TODO>>} */
    parserCache: Map<string, WeakMap<any, TODO>>;
    /** @type {Map<string, WeakMap<Object, Generator>>} */
    generatorCache: Map<string, WeakMap<any, Generator>>;
    /** @type {Set<Module>} */
    _restoredUnsafeCacheEntries: Set<Module>;
    _parseResourceWithoutFragment: (str: any) => any;
    cleanupForCache(): void;
    resolveResource(contextInfo: any, context: any, unresolvedResource: any, resolver: any, resolveContext: any, callback: any): void;
    _resolveResourceErrorHints(error: any, contextInfo: any, context: any, unresolvedResource: any, resolver: any, resolveContext: any, callback: any): void;
    resolveRequestArray(contextInfo: any, context: any, array: any, resolver: any, resolveContext: any, callback: any): any;
    getParser(type: any, parserOptions?: {}): TODO;
    /**
     * @param {string} type type
     * @param {{[k: string]: any}} parserOptions parser options
     * @returns {Parser} parser
     */
    createParser(type: string, parserOptions?: {
        [k: string]: any;
    }): Parser;
    getGenerator(type: any, generatorOptions?: {}): import("webpack/lib/Generator");
    createGenerator(type: any, generatorOptions?: {}): any;
    getResolver(type: any, resolveOptions: any): import("webpack/lib/ResolverFactory").ResolverWithOptions;
}
declare namespace NormalModuleFactory {
    export { ModuleOptions, RuleSetRule, Generator, ModuleFactoryCreateData, ModuleFactoryResult, NormalModuleCreateData, Parser, ResolverFactory, ModuleDependency, InputFileSystem, ModuleSettings, CreateData, ResolveData, ResourceData, ResourceDataWithData, ParsedLoaderRequest };
}
import ModuleFactory = require("webpack/lib/ModuleFactory");
import { AsyncSeriesBailHook } from "tapable";
type ResolveData = {
    contextInfo: ModuleFactoryCreateData["contextInfo"];
    resolveOptions: any;
    context: string;
    request: string;
    assertions: Record<string, any> | undefined;
    dependencies: ModuleDependency[];
    dependencyType: string;
    createData: CreateData;
    fileDependencies: LazySet<string>;
    missingDependencies: LazySet<string>;
    contextDependencies: LazySet<string>;
    /**
     * allow to use the unsafe cache
     */
    cacheable: boolean;
};
import Module = require("webpack/lib/Module");
import { HookMap } from "tapable";
type ResourceDataWithData = ResourceData & {
    data: Record<string, any>;
};
import { SyncWaterfallHook } from "tapable";
import { SyncBailHook } from "tapable";
import { SyncHook } from "tapable";
import RuleSetCompiler = require("webpack/lib/rules/RuleSetCompiler");
type Generator = import("./Generator");
type Parser = import("./Parser");
type InputFileSystem = import("./util/fs").InputFileSystem;
type ResolverFactory = import("./ResolverFactory");
type ModuleOptions = any;
type RuleSetRule = any;
type ModuleFactoryCreateData = import("./ModuleFactory").ModuleFactoryCreateData;
type ModuleFactoryResult = import("./ModuleFactory").ModuleFactoryResult;
type NormalModuleCreateData = import("./NormalModule").NormalModuleCreateData;
type ModuleDependency = import("./dependencies/ModuleDependency");
type ModuleSettings = Pick<RuleSetRule, 'type' | 'sideEffects' | 'parser' | 'generator' | 'resolve' | 'layer'>;
type CreateData = Partial<NormalModuleCreateData & {
    settings: ModuleSettings;
}>;
type ResourceData = {
    resource: string;
    path: string;
    query: string;
    fragment: string;
    context?: string | undefined;
};
type ParsedLoaderRequest = {
    /**
     * loader
     */
    loader: string;
    /**
     * options
     */
    options: string | undefined;
};
import LazySet = require("webpack/lib/util/LazySet");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/NormalModuleReplacementPlugin.d.ts
export = NormalModuleReplacementPlugin;
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {function(import("./NormalModuleFactory").ResolveData): void} ModuleReplacer */
declare class NormalModuleReplacementPlugin {
    /**
     * Create an instance of the plugin
     * @param {RegExp} resourceRegExp the resource matcher
     * @param {string|ModuleReplacer} newResource the resource replacement
     */
    constructor(resourceRegExp: RegExp, newResource: string | ModuleReplacer);
    resourceRegExp: RegExp;
    newResource: string | ModuleReplacer;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace NormalModuleReplacementPlugin {
    export { Compiler, ModuleReplacer };
}
type ModuleReplacer = (arg0: import("./NormalModuleFactory").ResolveData) => void;
type Compiler = import("./Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/NullFactory.d.ts
export = NullFactory;
/** @typedef {import("./ModuleFactory").ModuleFactoryCreateData} ModuleFactoryCreateData */
/** @typedef {import("./ModuleFactory").ModuleFactoryResult} ModuleFactoryResult */
declare class NullFactory extends ModuleFactory {
    /**
     * @param {ModuleFactoryCreateData} data data object
     * @param {function((Error | null)=, ModuleFactoryResult=): void} callback callback
     * @returns {void}
     */
    create(data: ModuleFactoryCreateData, callback: (arg0: (Error | null) | undefined, arg1: ModuleFactoryResult | undefined) => void): void;
}
declare namespace NullFactory {
    export { ModuleFactoryCreateData, ModuleFactoryResult };
}
import ModuleFactory = require("./ModuleFactory");
type ModuleFactoryCreateData = import("./ModuleFactory").ModuleFactoryCreateData;
type ModuleFactoryResult = import("./ModuleFactory").ModuleFactoryResult;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/OptimizationStages.d.ts
export const STAGE_BASIC: -10;
export const STAGE_DEFAULT: 0;
export const STAGE_ADVANCED: 10;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/OptionsApply.d.ts
export = OptionsApply;
declare class OptionsApply {
    process(options: any, compiler: any): void;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Parser.d.ts
export = Parser;
/** @typedef {import("./Compilation")} Compilation */
/** @typedef {import("./NormalModule")} NormalModule */
/** @typedef {Record<string, any>} PreparsedAst */
/**
 * @typedef {Object} ParserStateBase
 * @property {string | Buffer} source
 * @property {NormalModule} current
 * @property {NormalModule} module
 * @property {Compilation} compilation
 * @property {{[k: string]: any}} options
 */
/** @typedef {Record<string, any> & ParserStateBase} ParserState */
declare class Parser {
    /**
     * @abstract
     * @param {string | Buffer | PreparsedAst} source the source to parse
     * @param {ParserState} state the parser state
     * @returns {ParserState} the parser state
     */
    parse(source: string | Buffer | PreparsedAst, state: ParserState): ParserState;
}
declare namespace Parser {
    export { Compilation, NormalModule, PreparsedAst, ParserStateBase, ParserState };
}
type PreparsedAst = Record<string, any>;
type ParserState = Record<string, any> & ParserStateBase;
type Compilation = import("./Compilation");
type NormalModule = import("./NormalModule");
type ParserStateBase = {
    source: string | Buffer;
    current: NormalModule;
    module: NormalModule;
    compilation: Compilation;
    options: {
        [k: string]: any;
    };
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/PrefetchPlugin.d.ts
export = PrefetchPlugin;
/** @typedef {import("./Compiler")} Compiler */
declare class PrefetchPlugin {
    /**
     * @param {string} context context or request if context is not set
     * @param {string} [request] request
     */
    constructor(context: string, request?: string);
    context: string;
    request: string;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace PrefetchPlugin {
    export { Compiler };
}
type Compiler = import("./Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ProgressPlugin.d.ts
export = ProgressPlugin;
declare class ProgressPlugin {
    /**
     * @param {Compiler} compiler the current compiler
     * @returns {ReportProgress | undefined} a progress reporter, if any
     */
    static getReporter(compiler: Compiler): ReportProgress | undefined;
    /**
     * @param {ProgressPluginArgument} options options
     */
    constructor(options?: any);
    profile: any;
    handler: any;
    modulesCount: any;
    dependenciesCount: any;
    showEntries: any;
    showModules: any;
    showDependencies: any;
    showActiveModules: any;
    percentBy: any;
    /**
     * @param {Compiler | MultiCompiler} compiler webpack compiler
     * @returns {void}
     */
    apply(compiler: Compiler | MultiCompiler): void;
    /**
     * @param {MultiCompiler} compiler webpack multi-compiler
     * @param {HandlerFunction} handler function that executes for every progress step
     * @returns {void}
     */
    _applyOnMultiCompiler(compiler: MultiCompiler, handler: any): void;
    /**
     * @param {Compiler} compiler webpack compiler
     * @param {HandlerFunction} handler function that executes for every progress step
     * @returns {void}
     */
    _applyOnCompiler(compiler: Compiler, handler: any): void;
}
declare namespace ProgressPlugin {
    export { defaultOptions, createDefaultHandler, Tap, HandlerFunction, ProgressPluginArgument, ProgressPluginOptions, Dependency, EntryOptions, Module, Logger, CountsData, ReportProgress };
}
import Compiler = require("webpack/lib/Compiler");
import MultiCompiler = require("webpack/lib/MultiCompiler");
type ReportProgress = (p: number, ...args: string[]) => void;
declare namespace defaultOptions {
    let profile: boolean;
    let modulesCount: number;
    let dependenciesCount: number;
    let modules: boolean;
    let dependencies: boolean;
    let activeModules: boolean;
    let entries: boolean;
}
/**
 * @param {boolean | null | undefined} profile need profile
 * @param {Logger} logger logger
 * @returns {defaultHandler} default handler
 */
declare function createDefaultHandler(profile: boolean | null | undefined, logger: Logger): (percentage: number, msg: string, ...args: string[]) => void;
type Tap = import("tapable").Tap;
type HandlerFunction = any;
type ProgressPluginArgument = any;
type ProgressPluginOptions = any;
type Dependency = import("./Dependency");
type EntryOptions = import("./Entrypoint").EntryOptions;
type Module = import("./Module");
type Logger = import("./logging/Logger").Logger;
type CountsData = {
    /**
     * modules count
     */
    modulesCount: number;
    /**
     * dependencies count
     */
    dependenciesCount: number;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ProvidePlugin.d.ts
export = ProvidePlugin;
declare class ProvidePlugin {
    /**
     * @param {Record<string, string | string[]>} definitions the provided identifiers
     */
    constructor(definitions: Record<string, string | string[]>);
    definitions: Record<string, string | string[]>;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ProvidePlugin {
    export { JavascriptParserOptions, Compiler, DependencyLocation, JavascriptParser, Range };
}
type Compiler = import("./Compiler");
type JavascriptParserOptions = any;
type DependencyLocation = import("./Dependency").DependencyLocation;
type JavascriptParser = import("./javascript/JavascriptParser");
type Range = import("./javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/RawModule.d.ts
export = RawModule;
declare class RawModule extends Module {
    /**
     * @param {string} source source code
     * @param {string} identifier unique identifier
     * @param {string=} readableIdentifier readable identifier
     * @param {ReadonlySet<string>=} runtimeRequirements runtime requirements needed for the source code
     */
    constructor(source: string, identifier: string, readableIdentifier?: string | undefined, runtimeRequirements?: ReadonlySet<string> | undefined);
    sourceStr: string;
    identifierStr: string;
    readableIdentifierStr: string;
    runtimeRequirements: ReadonlySet<string>;
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context: UpdateHashContext): void;
}
declare namespace RawModule {
    export { Source, WebpackOptions, ChunkGraph, Compilation, UpdateHashContext, DependencyTemplates, CodeGenerationContext, CodeGenerationResult, NeedBuildContext, RequestShortener, ResolverWithOptions, RuntimeTemplate, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, Hash, InputFileSystem };
}
import Module = require("webpack/lib/Module");
type Hash = import("./util/Hash");
type UpdateHashContext = import("./Dependency").UpdateHashContext;
type Source = import("webpack-sources").Source;
type WebpackOptions = any;
type ChunkGraph = import("./ChunkGraph");
type Compilation = import("./Compilation");
type DependencyTemplates = import("./DependencyTemplates");
type CodeGenerationContext = import("./Module").CodeGenerationContext;
type CodeGenerationResult = import("./Module").CodeGenerationResult;
type NeedBuildContext = import("./Module").NeedBuildContext;
type RequestShortener = import("./RequestShortener");
type ResolverWithOptions = import("./ResolverFactory").ResolverWithOptions;
type RuntimeTemplate = import("./RuntimeTemplate");
type WebpackError = import("./WebpackError");
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type InputFileSystem = import("./util/fs").InputFileSystem;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/RecordIdsPlugin.d.ts
export = RecordIdsPlugin;
/** @typedef {import("./Chunk")} Chunk */
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./Module")} Module */
/**
 * @typedef {Object} RecordsChunks
 * @property {Record<string, number>=} byName
 * @property {Record<string, number>=} bySource
 * @property {number[]=} usedIds
 */
/**
 * @typedef {Object} RecordsModules
 * @property {Record<string, number>=} byIdentifier
 * @property {Record<string, number>=} bySource
 * @property {number[]=} usedIds
 */
/**
 * @typedef {Object} Records
 * @property {RecordsChunks=} chunks
 * @property {RecordsModules=} modules
 */
declare class RecordIdsPlugin {
    /**
     * @param {Object} options Options object
     * @param {boolean=} options.portableIds true, when ids need to be portable
     */
    constructor(options: {
        portableIds?: boolean | undefined;
    });
    options: {
        portableIds?: boolean | undefined;
    };
    /**
     * @param {Compiler} compiler the Compiler
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace RecordIdsPlugin {
    export { Chunk, Compiler, Module, RecordsChunks, RecordsModules, Records };
}
type Compiler = import("./Compiler");
type Chunk = import("./Chunk");
type Module = import("./Module");
type RecordsChunks = {
    byName?: Record<string, number> | undefined;
    bySource?: Record<string, number> | undefined;
    usedIds?: number[] | undefined;
};
type RecordsModules = {
    byIdentifier?: Record<string, number> | undefined;
    bySource?: Record<string, number> | undefined;
    usedIds?: number[] | undefined;
};
type Records = {
    chunks?: RecordsChunks | undefined;
    modules?: RecordsModules | undefined;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/RequestShortener.d.ts
export = RequestShortener;
declare class RequestShortener {
    /**
     * @param {string} dir the directory
     * @param {object=} associatedObjectForCache an object to which the cache will be attached
     */
    constructor(dir: string, associatedObjectForCache?: object | undefined);
    contextify: (arg0: string) => string;
    /**
     * @param {string | undefined | null} request the request to shorten
     * @returns {string | undefined | null} the shortened request
     */
    shorten(request: string | undefined | null): string | undefined | null;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/RequireJsStuffPlugin.d.ts
export = RequireJsStuffPlugin;
declare class RequireJsStuffPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace RequireJsStuffPlugin {
    export { JavascriptParserOptions, Compiler, JavascriptParser };
}
type Compiler = import("./Compiler");
type JavascriptParserOptions = any;
type JavascriptParser = import("./javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ResolverFactory.d.ts
export = ResolverFactory;
declare class ResolverFactory {
    hooks: Readonly<{
        /** @type {HookMap<SyncWaterfallHook<[ResolveOptionsWithDependencyType]>>} */
        resolveOptions: HookMap<SyncWaterfallHook<[ResolveOptionsWithDependencyType]>>;
        /** @type {HookMap<SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>>} */
        resolver: HookMap<SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>>;
    }>;
    /** @type {Map<string, ResolverCache>} */
    cache: Map<string, ResolverCache>;
    /**
     * @param {string} type type of resolver
     * @param {ResolveOptionsWithDependencyType=} resolveOptions options
     * @returns {ResolverWithOptions} the resolver
     */
    get(type: string, resolveOptions?: ResolveOptionsWithDependencyType | undefined): ResolverWithOptions;
    /**
     * @param {string} type type of resolver
     * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType options
     * @returns {ResolverWithOptions} the resolver
     */
    _create(type: string, resolveOptionsWithDepType: ResolveOptionsWithDependencyType): ResolverWithOptions;
}
declare namespace ResolverFactory {
    export { ResolveOptions, Resolver, WebpackResolveOptions, ResolvePluginInstance, ResolveOptionsWithDependencyType, WithOptions, ResolverWithOptions, ResolverCache };
}
import { HookMap } from "tapable";
import { SyncWaterfallHook } from "tapable";
type ResolveOptionsWithDependencyType = WebpackResolveOptions & {
    dependencyType?: string;
    resolveToContext?: boolean;
};
import { SyncHook } from "tapable";
type Resolver = import("enhanced-resolve").Resolver;
type ResolveOptions = import("enhanced-resolve").ResolveOptions;
type ResolverCache = {
    direct: WeakMap<any, ResolverWithOptions>;
    stringified: Map<string, ResolverWithOptions>;
};
type ResolverWithOptions = Resolver & WithOptions;
type WebpackResolveOptions = any;
type ResolvePluginInstance = any;
type WithOptions = {
    /**
     * create a resolver with additional/different options
     */
    withOptions: (arg0: Partial<ResolveOptionsWithDependencyType>) => ResolverWithOptions;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/RuntimeGlobals.d.ts
export const require: "__webpack_require__";
export const requireScope: "__webpack_require__.*";
export const exports: "__webpack_exports__";
export const thisAsExports: "top-level-this-exports";
export const returnExportsFromRuntime: "return-exports-from-runtime";
export const module: "module";
export const moduleId: "module.id";
export const moduleLoaded: "module.loaded";
export const publicPath: "__webpack_require__.p";
export const entryModuleId: "__webpack_require__.s";
export const moduleCache: "__webpack_require__.c";
export const moduleFactories: "__webpack_require__.m";
export const moduleFactoriesAddOnly: "__webpack_require__.m (add only)";
export const ensureChunk: "__webpack_require__.e";
export const ensureChunkHandlers: "__webpack_require__.f";
export const ensureChunkIncludeEntries: "__webpack_require__.f (include entries)";
export const prefetchChunk: "__webpack_require__.E";
export const prefetchChunkHandlers: "__webpack_require__.F";
export const preloadChunk: "__webpack_require__.G";
export const preloadChunkHandlers: "__webpack_require__.H";
export const definePropertyGetters: "__webpack_require__.d";
export const makeNamespaceObject: "__webpack_require__.r";
export const createFakeNamespaceObject: "__webpack_require__.t";
export const compatGetDefaultExport: "__webpack_require__.n";
export const harmonyModuleDecorator: "__webpack_require__.hmd";
export const nodeModuleDecorator: "__webpack_require__.nmd";
export const getFullHash: "__webpack_require__.h";
export const wasmInstances: "__webpack_require__.w";
export const instantiateWasm: "__webpack_require__.v";
export const uncaughtErrorHandler: "__webpack_require__.oe";
export const scriptNonce: "__webpack_require__.nc";
export const loadScript: "__webpack_require__.l";
export const createScript: "__webpack_require__.ts";
export const createScriptUrl: "__webpack_require__.tu";
export const getTrustedTypesPolicy: "__webpack_require__.tt";
export const hasFetchPriority: "has fetch priority";
export const chunkName: "__webpack_require__.cn";
export const runtimeId: "__webpack_require__.j";
export const getChunkScriptFilename: "__webpack_require__.u";
export const getChunkCssFilename: "__webpack_require__.k";
export const hasCssModules: "has css modules";
export const getChunkUpdateScriptFilename: "__webpack_require__.hu";
export const getChunkUpdateCssFilename: "__webpack_require__.hk";
export const startup: "__webpack_require__.x";
export const startupNoDefault: "__webpack_require__.x (no default handler)";
export const startupOnlyAfter: "__webpack_require__.x (only after)";
export const startupOnlyBefore: "__webpack_require__.x (only before)";
export const chunkCallback: "webpackChunk";
export const startupEntrypoint: "__webpack_require__.X";
export const onChunksLoaded: "__webpack_require__.O";
export const externalInstallChunk: "__webpack_require__.C";
export const interceptModuleExecution: "__webpack_require__.i";
export const global: "__webpack_require__.g";
export const shareScopeMap: "__webpack_require__.S";
export const initializeSharing: "__webpack_require__.I";
export const currentRemoteGetScope: "__webpack_require__.R";
export const getUpdateManifestFilename: "__webpack_require__.hmrF";
export const hmrDownloadManifest: "__webpack_require__.hmrM";
export const hmrDownloadUpdateHandlers: "__webpack_require__.hmrC";
export const hmrModuleData: "__webpack_require__.hmrD";
export const hmrInvalidateModuleHandlers: "__webpack_require__.hmrI";
export const hmrRuntimeStatePrefix: "__webpack_require__.hmrS";
export const amdDefine: "__webpack_require__.amdD";
export const amdOptions: "__webpack_require__.amdO";
export const system: "__webpack_require__.System";
export const hasOwnProperty: "__webpack_require__.o";
export const systemContext: "__webpack_require__.y";
export const baseURI: "__webpack_require__.b";
export const relativeUrl: "__webpack_require__.U";
export const asyncModule: "__webpack_require__.a";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/RuntimeModule.d.ts
export = RuntimeModule;
declare class RuntimeModule extends Module {
    /**
     * @param {string} name a readable name
     * @param {number=} stage an optional stage
     */
    constructor(name: string, stage?: number | undefined);
    name: string;
    stage: number;
    buildMeta: {};
    buildInfo: {};
    /** @type {Compilation | undefined} */
    compilation: Compilation | undefined;
    /** @type {Chunk | undefined} */
    chunk: Chunk | undefined;
    /** @type {ChunkGraph | undefined} */
    chunkGraph: ChunkGraph | undefined;
    fullHash: boolean;
    dependentHash: boolean;
    /** @type {string | undefined} */
    _cachedGeneratedCode: string | undefined;
    /**
     * @param {Compilation} compilation the compilation
     * @param {Chunk} chunk the chunk
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @returns {void}
     */
    attach(compilation: Compilation, chunk: Chunk, chunkGraph?: ChunkGraph): void;
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context: UpdateHashContext): void;
    /**
     * @abstract
     * @returns {string | null} runtime code
     */
    generate(): string | null;
    /**
     * @returns {string | null} runtime code
     */
    getGeneratedCode(): string | null;
    /**
     * @returns {boolean} true, if the runtime module should get it's own scope
     */
    shouldIsolate(): boolean;
}
declare namespace RuntimeModule {
    export { STAGE_NORMAL, STAGE_BASIC, STAGE_ATTACH, STAGE_TRIGGER, Source, WebpackOptions, Chunk, ChunkGraph, Compilation, UpdateHashContext, CodeGenerationContext, CodeGenerationResult, NeedBuildContext, RequestShortener, ResolverWithOptions, WebpackError, Hash, InputFileSystem };
}
import Module = require("webpack/lib/Module");
type Compilation = import("./Compilation");
type Chunk = import("./Chunk");
type ChunkGraph = import("./ChunkGraph");
type Hash = import("./util/Hash");
type UpdateHashContext = import("./Dependency").UpdateHashContext;
declare var STAGE_NORMAL: number;
declare var STAGE_BASIC: number;
declare var STAGE_ATTACH: number;
declare var STAGE_TRIGGER: number;
type Source = import("webpack-sources").Source;
type WebpackOptions = any;
type CodeGenerationContext = import("./Module").CodeGenerationContext;
type CodeGenerationResult = import("./Module").CodeGenerationResult;
type NeedBuildContext = import("./Module").NeedBuildContext;
type RequestShortener = import("./RequestShortener");
type ResolverWithOptions = import("./ResolverFactory").ResolverWithOptions;
type WebpackError = import("./WebpackError");
type InputFileSystem = import("./util/fs").InputFileSystem;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/RuntimePlugin.d.ts
export = RuntimePlugin;
declare class RuntimePlugin {
    /**
     * @param {Compiler} compiler the Compiler
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace RuntimePlugin {
    export { Chunk, Compiler, Module };
}
type Compiler = import("./Compiler");
type Chunk = import("./Chunk");
type Module = import("./Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/RuntimeTemplate.d.ts
export = RuntimeTemplate;
declare class RuntimeTemplate {
    /**
     * @param {Compilation} compilation the compilation
     * @param {OutputOptions} outputOptions the compilation output options
     * @param {RequestShortener} requestShortener the request shortener
     */
    constructor(compilation: Compilation, outputOptions: any, requestShortener: RequestShortener);
    compilation: import("webpack/lib/Compilation");
    outputOptions: any;
    requestShortener: import("webpack/lib/RequestShortener");
    globalObject: string;
    contentHashReplacement: string;
    isIIFE(): any;
    isModule(): any;
    supportsConst(): any;
    supportsArrowFunction(): any;
    supportsOptionalChaining(): any;
    supportsForOf(): any;
    supportsDestructuring(): any;
    supportsBigIntLiteral(): any;
    supportsDynamicImport(): any;
    supportsEcmaScriptModuleSyntax(): any;
    supportTemplateLiteral(): any;
    returningFunction(returnValue: any, args?: string): string;
    basicFunction(args: any, body: any): string;
    /**
     * @param {Array<string|{expr: string}>} args args
     * @returns {string} result expression
     */
    concatenation(...args: Array<string | {
        expr: string;
    }>): string;
    /**
     * @param {Array<string|{expr: string}>} args args (len >= 2)
     * @returns {string} result expression
     * @private
     */
    private _es5Concatenation;
    expressionFunction(expression: any, args?: string): string;
    emptyFunction(): "x => {}" | "function() {}";
    destructureArray(items: any, value: any): string;
    destructureObject(items: any, value: any): string;
    iife(args: any, body: any): string;
    forEach(variable: any, array: any, body: any): string;
    /**
     * Add a comment
     * @param {object} options Information content of the comment
     * @param {string=} options.request request string used originally
     * @param {string=} options.chunkName name of the chunk referenced
     * @param {string=} options.chunkReason reason information of the chunk
     * @param {string=} options.message additional message
     * @param {string=} options.exportName name of the export
     * @returns {string} comment
     */
    comment({ request, chunkName, chunkReason, message, exportName }: {
        request?: string | undefined;
        chunkName?: string | undefined;
        chunkReason?: string | undefined;
        message?: string | undefined;
        exportName?: string | undefined;
    }): string;
    /**
     * @param {object} options generation options
     * @param {string=} options.request request string used originally
     * @returns {string} generated error block
     */
    throwMissingModuleErrorBlock({ request }: {
        request?: string | undefined;
    }): string;
    /**
     * @param {object} options generation options
     * @param {string=} options.request request string used originally
     * @returns {string} generated error function
     */
    throwMissingModuleErrorFunction({ request }: {
        request?: string | undefined;
    }): string;
    /**
     * @param {object} options generation options
     * @param {string=} options.request request string used originally
     * @returns {string} generated error IIFE
     */
    missingModule({ request }: {
        request?: string | undefined;
    }): string;
    /**
     * @param {object} options generation options
     * @param {string=} options.request request string used originally
     * @returns {string} generated error statement
     */
    missingModuleStatement({ request }: {
        request?: string | undefined;
    }): string;
    /**
     * @param {object} options generation options
     * @param {string=} options.request request string used originally
     * @returns {string} generated error code
     */
    missingModulePromise({ request }: {
        request?: string | undefined;
    }): string;
    /**
     * @param {Object} options options object
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @param {Module} options.module the module
     * @param {string} options.request the request that should be printed as comment
     * @param {string=} options.idExpr expression to use as id expression
     * @param {"expression" | "promise" | "statements"} options.type which kind of code should be returned
     * @returns {string} the code
     */
    weakError({ module, chunkGraph, request, idExpr, type }: {
        chunkGraph: ChunkGraph;
        module: Module;
        request: string;
        idExpr?: string | undefined;
        type: "expression" | "promise" | "statements";
    }): string;
    /**
     * @param {Object} options options object
     * @param {Module} options.module the module
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @param {string} options.request the request that should be printed as comment
     * @param {boolean=} options.weak if the dependency is weak (will create a nice error message)
     * @returns {string} the expression
     */
    moduleId({ module, chunkGraph, request, weak }: {
        module: Module;
        chunkGraph: ChunkGraph;
        request: string;
        weak?: boolean | undefined;
    }): string;
    /**
     * @param {Object} options options object
     * @param {Module | null} options.module the module
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @param {string} options.request the request that should be printed as comment
     * @param {boolean=} options.weak if the dependency is weak (will create a nice error message)
     * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
     * @returns {string} the expression
     */
    moduleRaw({ module, chunkGraph, request, weak, runtimeRequirements }: {
        module: Module | null;
        chunkGraph: ChunkGraph;
        request: string;
        weak?: boolean | undefined;
        runtimeRequirements: Set<string>;
    }): string;
    /**
     * @param {Object} options options object
     * @param {Module | null} options.module the module
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @param {string} options.request the request that should be printed as comment
     * @param {boolean=} options.weak if the dependency is weak (will create a nice error message)
     * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
     * @returns {string} the expression
     */
    moduleExports({ module, chunkGraph, request, weak, runtimeRequirements }: {
        module: Module | null;
        chunkGraph: ChunkGraph;
        request: string;
        weak?: boolean | undefined;
        runtimeRequirements: Set<string>;
    }): string;
    /**
     * @param {Object} options options object
     * @param {Module} options.module the module
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @param {string} options.request the request that should be printed as comment
     * @param {boolean=} options.strict if the current module is in strict esm mode
     * @param {boolean=} options.weak if the dependency is weak (will create a nice error message)
     * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
     * @returns {string} the expression
     */
    moduleNamespace({ module, chunkGraph, request, strict, weak, runtimeRequirements }: {
        module: Module;
        chunkGraph: ChunkGraph;
        request: string;
        strict?: boolean | undefined;
        weak?: boolean | undefined;
        runtimeRequirements: Set<string>;
    }): string;
    /**
     * @param {Object} options options object
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @param {AsyncDependenciesBlock=} options.block the current dependencies block
     * @param {Module} options.module the module
     * @param {string} options.request the request that should be printed as comment
     * @param {string} options.message a message for the comment
     * @param {boolean=} options.strict if the current module is in strict esm mode
     * @param {boolean=} options.weak if the dependency is weak (will create a nice error message)
     * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
     * @returns {string} the promise expression
     */
    moduleNamespacePromise({ chunkGraph, block, module, request, message, strict, weak, runtimeRequirements }: {
        chunkGraph: ChunkGraph;
        block?: AsyncDependenciesBlock | undefined;
        module: Module;
        request: string;
        message: string;
        strict?: boolean | undefined;
        weak?: boolean | undefined;
        runtimeRequirements: Set<string>;
    }): string;
    /**
     * @param {Object} options options object
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @param {RuntimeSpec=} options.runtime runtime for which this code will be generated
     * @param {RuntimeSpec | boolean=} options.runtimeCondition only execute the statement in some runtimes
     * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
     * @returns {string} expression
     */
    runtimeConditionExpression({ chunkGraph, runtimeCondition, runtime, runtimeRequirements }: {
        chunkGraph: ChunkGraph;
        runtime?: RuntimeSpec | undefined;
        runtimeCondition?: (RuntimeSpec | boolean) | undefined;
        runtimeRequirements: Set<string>;
    }): string;
    /**
     *
     * @param {Object} options options object
     * @param {boolean=} options.update whether a new variable should be created or the existing one updated
     * @param {Module} options.module the module
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @param {string} options.request the request that should be printed as comment
     * @param {string} options.importVar name of the import variable
     * @param {Module} options.originModule module in which the statement is emitted
     * @param {boolean=} options.weak true, if this is a weak dependency
     * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
     * @returns {[string, string]} the import statement and the compat statement
     */
    importStatement({ update, module, chunkGraph, request, importVar, originModule, weak, runtimeRequirements }: {
        update?: boolean | undefined;
        module: Module;
        chunkGraph: ChunkGraph;
        request: string;
        importVar: string;
        originModule: Module;
        weak?: boolean | undefined;
        runtimeRequirements: Set<string>;
    }): [string, string];
    /**
     * @param {Object} options options
     * @param {ModuleGraph} options.moduleGraph the module graph
     * @param {Module} options.module the module
     * @param {string} options.request the request
     * @param {string | string[]} options.exportName the export name
     * @param {Module} options.originModule the origin module
     * @param {boolean|undefined} options.asiSafe true, if location is safe for ASI, a bracket can be emitted
     * @param {boolean} options.isCall true, if expression will be called
     * @param {boolean | null} options.callContext when false, call context will not be preserved
     * @param {boolean} options.defaultInterop when true and accessing the default exports, interop code will be generated
     * @param {string} options.importVar the identifier name of the import variable
     * @param {InitFragment<TODO>[]} options.initFragments init fragments will be added here
     * @param {RuntimeSpec} options.runtime runtime for which this code will be generated
     * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
     * @returns {string} expression
     */
    exportFromImport({ moduleGraph, module, request, exportName, originModule, asiSafe, isCall, callContext, defaultInterop, importVar, initFragments, runtime, runtimeRequirements }: {
        moduleGraph: ModuleGraph;
        module: Module;
        request: string;
        exportName: string | string[];
        originModule: Module;
        asiSafe: boolean | undefined;
        isCall: boolean;
        callContext: boolean | null;
        defaultInterop: boolean;
        importVar: string;
        initFragments: InitFragment<TODO>[];
        runtime: RuntimeSpec;
        runtimeRequirements: Set<string>;
    }): string;
    /**
     * @param {Object} options options
     * @param {AsyncDependenciesBlock} options.block the async block
     * @param {string} options.message the message
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
     * @returns {string} expression
     */
    blockPromise({ block, message, chunkGraph, runtimeRequirements }: {
        block: AsyncDependenciesBlock;
        message: string;
        chunkGraph: ChunkGraph;
        runtimeRequirements: Set<string>;
    }): string;
    /**
     * @param {Object} options options
     * @param {AsyncDependenciesBlock} options.block the async block
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
     * @param {string=} options.request request string used originally
     * @returns {string} expression
     */
    asyncModuleFactory({ block, chunkGraph, runtimeRequirements, request }: {
        block: AsyncDependenciesBlock;
        chunkGraph: ChunkGraph;
        runtimeRequirements: Set<string>;
        request?: string | undefined;
    }): string;
    /**
     * @param {Object} options options
     * @param {Dependency} options.dependency the dependency
     * @param {ChunkGraph} options.chunkGraph the chunk graph
     * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
     * @param {string=} options.request request string used originally
     * @returns {string} expression
     */
    syncModuleFactory({ dependency, chunkGraph, runtimeRequirements, request }: {
        dependency: Dependency;
        chunkGraph: ChunkGraph;
        runtimeRequirements: Set<string>;
        request?: string | undefined;
    }): string;
    /**
     * @param {Object} options options
     * @param {string} options.exportsArgument the name of the exports object
     * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
     * @returns {string} statement
     */
    defineEsModuleFlagStatement({ exportsArgument, runtimeRequirements }: {
        exportsArgument: string;
        runtimeRequirements: Set<string>;
    }): string;
    /**
     * @param {Object} options options object
     * @param {Module} options.module the module
     * @param {string} options.publicPath the public path
     * @param {RuntimeSpec=} options.runtime runtime
     * @param {CodeGenerationResults} options.codeGenerationResults the code generation results
     * @returns {string} the url of the asset
     */
    assetUrl({ publicPath, runtime, module, codeGenerationResults }: {
        module: Module;
        publicPath: string;
        runtime?: RuntimeSpec | undefined;
        codeGenerationResults: CodeGenerationResults;
    }): string;
}
declare namespace RuntimeTemplate {
    export { OutputOptions, AsyncDependenciesBlock, ChunkGraph, CodeGenerationResults, Compilation, Dependency, Module, ModuleGraph, RequestShortener, RuntimeSpec };
}
type ChunkGraph = import("./ChunkGraph");
type Module = import("./Module");
type AsyncDependenciesBlock = import("./AsyncDependenciesBlock");
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
type ModuleGraph = import("./ModuleGraph");
import InitFragment = require("webpack/lib/InitFragment");
type Dependency = import("./Dependency");
type CodeGenerationResults = import("./CodeGenerationResults");
type Compilation = import("./Compilation");
type RequestShortener = import("./RequestShortener");
type OutputOptions = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/SelfModuleFactory.d.ts
export = SelfModuleFactory;
/** @typedef {import("./ModuleFactory").ModuleFactoryCreateData} ModuleFactoryCreateData */
/** @typedef {import("./ModuleFactory").ModuleFactoryResult} ModuleFactoryResult */
/** @typedef {import("./ModuleGraph")} ModuleGraph */
declare class SelfModuleFactory {
    /**
     * @param {ModuleGraph} moduleGraph module graph
     */
    constructor(moduleGraph: ModuleGraph);
    moduleGraph: import("webpack/lib/ModuleGraph");
    /**
     * @param {ModuleFactoryCreateData} data data object
     * @param {function((Error | null)=, ModuleFactoryResult=): void} callback callback
     * @returns {void}
     */
    create(data: ModuleFactoryCreateData, callback: (arg0: (Error | null) | undefined, arg1: ModuleFactoryResult | undefined) => void): void;
}
declare namespace SelfModuleFactory {
    export { ModuleFactoryCreateData, ModuleFactoryResult, ModuleGraph };
}
type ModuleFactoryCreateData = import("./ModuleFactory").ModuleFactoryCreateData;
type ModuleFactoryResult = import("./ModuleFactory").ModuleFactoryResult;
type ModuleGraph = import("./ModuleGraph");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/SingleEntryPlugin.d.ts
declare const _exports: typeof import("./EntryPlugin");
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/SizeFormatHelpers.d.ts
export function formatSize(size: number): string;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/SourceMapDevToolModuleOptionsPlugin.d.ts
export = SourceMapDevToolModuleOptionsPlugin;
/** @typedef {import("../declarations/plugins/SourceMapDevToolPlugin").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */
/** @typedef {import("./Compilation")} Compilation */
declare class SourceMapDevToolModuleOptionsPlugin {
    /**
     * @param {SourceMapDevToolPluginOptions} options options
     */
    constructor(options: any);
    options: any;
    /**
     * @param {Compilation} compilation the compiler instance
     * @returns {void}
     */
    apply(compilation: Compilation): void;
}
declare namespace SourceMapDevToolModuleOptionsPlugin {
    export { SourceMapDevToolPluginOptions, Compilation };
}
type Compilation = import("./Compilation");
type SourceMapDevToolPluginOptions = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/SourceMapDevToolPlugin.d.ts
export = SourceMapDevToolPlugin;
declare class SourceMapDevToolPlugin {
    /**
     * @param {SourceMapDevToolPluginOptions} [options] options object
     * @throws {Error} throws error, if got more than 1 arguments
     */
    constructor(options?: any);
    /** @type {string | false} */
    sourceMapFilename: string | false;
    /** @type {string | false | (function(PathData, AssetInfo=): string)}} */
    sourceMappingURLComment: string | false | ((arg0: PathData, arg1: AssetInfo | undefined) => string);
    /** @type {string | Function} */
    moduleFilenameTemplate: string | Function;
    /** @type {string | Function} */
    fallbackModuleFilenameTemplate: string | Function;
    /** @type {string} */
    namespace: string;
    /** @type {SourceMapDevToolPluginOptions} */
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace SourceMapDevToolPlugin {
    export { MapOptions, Source, SourceMapDevToolPluginOptions, Etag, ItemCacheFacade, Chunk, Asset, AssetInfo, PathData, Compiler, Module, SourceMap, Hash, SourceMapTask };
}
type PathData = import("./Compilation").PathData;
type AssetInfo = import("./Compilation").AssetInfo;
type Compiler = import("./Compiler");
type MapOptions = import("webpack-sources").MapOptions;
type Source = import("webpack-sources").Source;
type SourceMapDevToolPluginOptions = any;
type Etag = import("./Cache").Etag;
type ItemCacheFacade = import("./CacheFacade").ItemCacheFacade;
type Chunk = import("./Chunk");
type Asset = import("./Compilation").Asset;
type Module = import("./Module");
type SourceMap = import("./NormalModule").SourceMap;
type Hash = import("./util/Hash");
type SourceMapTask = {
    asset: Source;
    assetInfo: AssetInfo;
    modules: (string | Module)[];
    source: string;
    file: string;
    sourceMap: SourceMap;
    /**
     * cache item
     */
    cacheItem: ItemCacheFacade;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Stats.d.ts
export = Stats;
/** @typedef {import("../declarations/WebpackOptions").StatsOptions} StatsOptions */
/** @typedef {import("./Compilation")} Compilation */
/** @typedef {import("./stats/DefaultStatsFactoryPlugin").StatsCompilation} StatsCompilation */
declare class Stats {
    /**
     * @param {Compilation} compilation webpack compilation
     */
    constructor(compilation: Compilation);
    compilation: import("webpack/lib/Compilation");
    get hash(): string;
    get startTime(): any;
    get endTime(): any;
    /**
     * @returns {boolean} true if the compilation had a warning
     */
    hasWarnings(): boolean;
    /**
     * @returns {boolean} true if the compilation encountered an error
     */
    hasErrors(): boolean;
    /**
     * @param {(string|StatsOptions)=} options stats options
     * @returns {StatsCompilation} json output
     */
    toJson(options?: (string | StatsOptions) | undefined): StatsCompilation;
    toString(options: any): string;
}
declare namespace Stats {
    export { StatsOptions, Compilation, StatsCompilation };
}
type StatsOptions = any;
type StatsCompilation = import("./stats/DefaultStatsFactoryPlugin").StatsCompilation;
type Compilation = import("./Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Template.d.ts
export = Template;
/**
 * @typedef {Object} RenderManifestOptions
 * @property {Chunk} chunk the chunk used to render
 * @property {string} hash
 * @property {string} fullHash
 * @property {OutputOptions} outputOptions
 * @property {CodeGenerationResults} codeGenerationResults
 * @property {{javascript: ModuleTemplate}} moduleTemplates
 * @property {DependencyTemplates} dependencyTemplates
 * @property {RuntimeTemplate} runtimeTemplate
 * @property {ModuleGraph} moduleGraph
 * @property {ChunkGraph} chunkGraph
 */
/** @typedef {RenderManifestEntryTemplated | RenderManifestEntryStatic} RenderManifestEntry */
/**
 * @typedef {Object} RenderManifestEntryTemplated
 * @property {function(): Source} render
 * @property {string | function(PathData, AssetInfo=): string} filenameTemplate
 * @property {PathData=} pathOptions
 * @property {AssetInfo=} info
 * @property {string} identifier
 * @property {string=} hash
 * @property {boolean=} auxiliary
 */
/**
 * @typedef {Object} RenderManifestEntryStatic
 * @property {function(): Source} render
 * @property {string} filename
 * @property {AssetInfo} info
 * @property {string} identifier
 * @property {string=} hash
 * @property {boolean=} auxiliary
 */
/**
 * @typedef {Object} HasId
 * @property {number | string} id
 */
/**
 * @typedef {function(Module, number): boolean} ModuleFilterPredicate
 */
declare class Template {
    /**
     *
     * @param {Function} fn a runtime function (.runtime.js) "template"
     * @returns {string} the updated and normalized function string
     */
    static getFunctionContent(fn: Function): string;
    /**
     * @param {string} str the string converted to identifier
     * @returns {string} created identifier
     */
    static toIdentifier(str: string): string;
    /**
     *
     * @param {string} str string to be converted to commented in bundle code
     * @returns {string} returns a commented version of string
     */
    static toComment(str: string): string;
    /**
     *
     * @param {string} str string to be converted to "normal comment"
     * @returns {string} returns a commented version of string
     */
    static toNormalComment(str: string): string;
    /**
     * @param {string} str string path to be normalized
     * @returns {string} normalized bundle-safe path
     */
    static toPath(str: string): string;
    /**
     * @param {number} n number to convert to ident
     * @returns {string} returns single character ident
     */
    static numberToIdentifier(n: number): string;
    /**
     * @param {number} n number to convert to ident
     * @returns {string} returns single character ident
     */
    static numberToIdentifierContinuation(n: number): string;
    /**
     *
     * @param {string | string[]} s string to convert to identity
     * @returns {string} converted identity
     */
    static indent(s: string | string[]): string;
    /**
     *
     * @param {string|string[]} s string to create prefix for
     * @param {string} prefix prefix to compose
     * @returns {string} returns new prefix string
     */
    static prefix(s: string | string[], prefix: string): string;
    /**
     *
     * @param {string|string[]} str string or string collection
     * @returns {string} returns a single string from array
     */
    static asString(str: string | string[]): string;
    /**
     * @typedef {Object} WithId
     * @property {string|number} id
     */
    /**
     * @param {WithId[]} modules a collection of modules to get array bounds for
     * @returns {[number, number] | false} returns the upper and lower array bounds
     * or false if not every module has a number based id
     */
    static getModulesArrayBounds(modules: {
        id: string | number;
    }[]): [number, number] | false;
    /**
     * @param {ChunkRenderContext} renderContext render context
     * @param {Module[]} modules modules to render (should be ordered by identifier)
     * @param {function(Module): Source} renderModule function to render a module
     * @param {string=} prefix applying prefix strings
     * @returns {Source | null} rendered chunk modules in a Source object or null if no modules
     */
    static renderChunkModules(renderContext: ChunkRenderContext, modules: Module[], renderModule: (arg0: Module) => Source, prefix?: string | undefined): Source | null;
    /**
     * @param {RuntimeModule[]} runtimeModules array of runtime modules in order
     * @param {RenderContext & { codeGenerationResults?: CodeGenerationResults }} renderContext render context
     * @returns {Source} rendered runtime modules in a Source object
     */
    static renderRuntimeModules(runtimeModules: RuntimeModule[], renderContext: RenderContext & {
        codeGenerationResults?: CodeGenerationResults;
    }): Source;
    /**
     * @param {RuntimeModule[]} runtimeModules array of runtime modules in order
     * @param {RenderContext} renderContext render context
     * @returns {Source} rendered chunk runtime modules in a Source object
     */
    static renderChunkRuntimeModules(runtimeModules: RuntimeModule[], renderContext: RenderContext): Source;
}
declare namespace Template {
    export { NUMBER_OF_IDENTIFIER_START_CHARS, NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS, Source, OutputOptions, Chunk, ChunkGraph, CodeGenerationResults, AssetInfo, PathData, DependencyTemplates, Module, ModuleGraph, ModuleTemplate, RuntimeModule, RuntimeTemplate, ChunkRenderContext, RenderContext, RenderManifestOptions, RenderManifestEntry, RenderManifestEntryTemplated, RenderManifestEntryStatic, HasId, ModuleFilterPredicate };
}
type ChunkRenderContext = import("./javascript/JavascriptModulesPlugin").ChunkRenderContext;
type Module = import("./Module");
type Source = import("webpack-sources").Source;
type RuntimeModule = import("./RuntimeModule");
type RenderContext = import("./javascript/JavascriptModulesPlugin").RenderContext;
type CodeGenerationResults = import("./CodeGenerationResults");
declare const NUMBER_OF_IDENTIFIER_START_CHARS: number;
declare const NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS: number;
type OutputOptions = any;
type Chunk = import("./Chunk");
type ChunkGraph = import("./ChunkGraph");
type AssetInfo = import("./Compilation").AssetInfo;
type PathData = import("./Compilation").PathData;
type DependencyTemplates = import("./DependencyTemplates");
type ModuleGraph = import("./ModuleGraph");
type ModuleTemplate = import("./ModuleTemplate");
type RuntimeTemplate = import("./RuntimeTemplate");
type RenderManifestOptions = {
    /**
     * the chunk used to render
     */
    chunk: Chunk;
    hash: string;
    fullHash: string;
    outputOptions: any;
    codeGenerationResults: CodeGenerationResults;
    moduleTemplates: {
        javascript: ModuleTemplate;
    };
    dependencyTemplates: DependencyTemplates;
    runtimeTemplate: RuntimeTemplate;
    moduleGraph: ModuleGraph;
    chunkGraph: ChunkGraph;
};
type RenderManifestEntry = RenderManifestEntryTemplated | RenderManifestEntryStatic;
type RenderManifestEntryTemplated = {
    render: () => Source;
    filenameTemplate: string | ((arg0: PathData, arg1: AssetInfo | undefined) => string);
    pathOptions?: PathData | undefined;
    info?: AssetInfo | undefined;
    identifier: string;
    hash?: string | undefined;
    auxiliary?: boolean | undefined;
};
type RenderManifestEntryStatic = {
    render: () => Source;
    filename: string;
    info: AssetInfo;
    identifier: string;
    hash?: string | undefined;
    auxiliary?: boolean | undefined;
};
type HasId = {
    id: number | string;
};
type ModuleFilterPredicate = (arg0: Module, arg1: number) => boolean;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/TemplatedPathPlugin.d.ts
export = TemplatedPathPlugin;
declare class TemplatedPathPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace TemplatedPathPlugin {
    export { AssetInfo, PathData, Compiler };
}
type Compiler = import("./Compiler");
type AssetInfo = import("./Compilation").AssetInfo;
type PathData = import("./Compilation").PathData;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/UnhandledSchemeError.d.ts
export = UnhandledSchemeError;
declare class UnhandledSchemeError extends WebpackError {
    /**
     * @param {string} scheme scheme
     * @param {string} resource resource
     */
    constructor(scheme: string, resource: string);
}
import WebpackError = require("webpack/lib/WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/UnsupportedFeatureWarning.d.ts
export = UnsupportedFeatureWarning;
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
declare class UnsupportedFeatureWarning extends WebpackError {
    /**
     * @param {string} message description of warning
     * @param {DependencyLocation} loc location start and end positions of the module
     */
    constructor(message: string, loc: DependencyLocation);
}
declare namespace UnsupportedFeatureWarning {
    export { DependencyLocation };
}
import WebpackError = require("webpack/lib/WebpackError");
type DependencyLocation = import("./Dependency").DependencyLocation;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/UseStrictPlugin.d.ts
export = UseStrictPlugin;
declare class UseStrictPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace UseStrictPlugin {
    export { Compiler, DependencyLocation, BuildInfo, JavascriptParser, Range };
}
type Compiler = import("./Compiler");
type DependencyLocation = import("./Dependency").DependencyLocation;
type BuildInfo = import("./Module").BuildInfo;
type JavascriptParser = import("./javascript/JavascriptParser");
type Range = import("./javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/WarnCaseSensitiveModulesPlugin.d.ts
export = WarnCaseSensitiveModulesPlugin;
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./Module")} Module */
/** @typedef {import("./NormalModule")} NormalModule */
declare class WarnCaseSensitiveModulesPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace WarnCaseSensitiveModulesPlugin {
    export { Compiler, Module, NormalModule };
}
type Compiler = import("./Compiler");
type Module = import("./Module");
type NormalModule = import("./NormalModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/WarnDeprecatedOptionPlugin.d.ts
export = WarnDeprecatedOptionPlugin;
/** @typedef {import("./Compiler")} Compiler */
declare class WarnDeprecatedOptionPlugin {
    /**
     * Create an instance of the plugin
     * @param {string} option the target option
     * @param {string | number} value the deprecated option value
     * @param {string} suggestion the suggestion replacement
     */
    constructor(option: string, value: string | number, suggestion: string);
    option: string;
    value: string | number;
    suggestion: string;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace WarnDeprecatedOptionPlugin {
    export { Compiler };
}
type Compiler = import("./Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/WarnNoModeSetPlugin.d.ts
export = WarnNoModeSetPlugin;
/** @typedef {import("./Compiler")} Compiler */
declare class WarnNoModeSetPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace WarnNoModeSetPlugin {
    export { Compiler };
}
type Compiler = import("./Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/WatchIgnorePlugin.d.ts
export = WatchIgnorePlugin;
declare class WatchIgnorePlugin {
    /**
     * @param {WatchIgnorePluginOptions} options options
     */
    constructor(options: any);
    paths: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace WatchIgnorePlugin {
    export { WatchIgnorePluginOptions, Compiler, WatchFileSystem };
}
type Compiler = import("./Compiler");
type WatchIgnorePluginOptions = any;
type WatchFileSystem = import("./util/fs").WatchFileSystem;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/Watching.d.ts
export = Watching;
/** @typedef {import("../declarations/WebpackOptions").WatchOptions} WatchOptions */
/** @typedef {import("./Compilation")} Compilation */
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./FileSystemInfo").FileSystemInfoEntry} FileSystemInfoEntry */
/** @typedef {import("./WebpackError")} WebpackError */
/** @typedef {import("./logging/Logger").Logger} Logger */
/**
 * @template T
 * @callback Callback
 * @param {(Error | null)=} err
 * @param {T=} result
 */
declare class Watching {
    /**
     * @param {Compiler} compiler the compiler
     * @param {WatchOptions} watchOptions options
     * @param {Callback<Stats>} handler completion handler
     */
    constructor(compiler: Compiler, watchOptions: any, handler: Callback<Stats>);
    startTime: number;
    invalid: boolean;
    handler: Callback<Stats>;
    /** @type {Callback<void>[]} */
    callbacks: Callback<void>[];
    /** @type {Callback<void>[] | undefined} */
    _closeCallbacks: Callback<void>[] | undefined;
    closed: boolean;
    suspended: boolean;
    blocked: boolean;
    _isBlocked: () => boolean;
    _onChange: () => void;
    _onInvalid: () => void;
    watchOptions: any;
    compiler: import("webpack/lib/Compiler");
    running: boolean;
    _initial: boolean;
    _invalidReported: boolean;
    _needRecords: boolean;
    watcher: import("webpack/lib/util/fs").Watcher;
    pausedWatcher: import("webpack/lib/util/fs").Watcher;
    /** @type {Set<string> | undefined} */
    _collectedChangedFiles: Set<string> | undefined;
    /** @type {Set<string> | undefined} */
    _collectedRemovedFiles: Set<string> | undefined;
    /**
     * @param {(Error | null)=} err an optional error
     * @param {Compilation=} compilation the compilation
     * @returns {void}
     */
    _done(err?: (Error | null) | undefined, compilation?: Compilation | undefined): void;
    /**
     * @param {ReadonlySet<string>=} changedFiles changed files
     * @param {ReadonlySet<string>=} removedFiles removed files
     */
    _mergeWithCollected(changedFiles?: ReadonlySet<string> | undefined, removedFiles?: ReadonlySet<string> | undefined): void;
    /**
     * @param {ReadonlyMap<string, FileSystemInfoEntry | "ignore">=} fileTimeInfoEntries info for files
     * @param {ReadonlyMap<string, FileSystemInfoEntry | "ignore">=} contextTimeInfoEntries info for directories
     * @param {ReadonlySet<string>=} changedFiles changed files
     * @param {ReadonlySet<string>=} removedFiles removed files
     * @returns {void}
     */
    _go(fileTimeInfoEntries?: ReadonlyMap<string, FileSystemInfoEntry | "ignore"> | undefined, contextTimeInfoEntries?: ReadonlyMap<string, FileSystemInfoEntry | "ignore"> | undefined, changedFiles?: ReadonlySet<string> | undefined, removedFiles?: ReadonlySet<string> | undefined): void;
    lastWatcherStartTime: number;
    /**
     * @param {Compilation} compilation the compilation
     * @returns {Stats} the compilation stats
     */
    _getStats(compilation: Compilation): Stats;
    /**
     * @param {Iterable<string>} files watched files
     * @param {Iterable<string>} dirs watched directories
     * @param {Iterable<string>} missing watched existence entries
     * @returns {void}
     */
    watch(files: Iterable<string>, dirs: Iterable<string>, missing: Iterable<string>): void;
    /**
     * @param {Callback<void>=} callback signals when the build has completed again
     * @returns {void}
     */
    invalidate(callback?: Callback<void> | undefined): void;
    /**
     * @param {ReadonlyMap<string, FileSystemInfoEntry | "ignore">=} fileTimeInfoEntries info for files
     * @param {ReadonlyMap<string, FileSystemInfoEntry | "ignore">=} contextTimeInfoEntries info for directories
     * @param {ReadonlySet<string>=} changedFiles changed files
     * @param {ReadonlySet<string>=} removedFiles removed files
     * @returns {void}
     */
    _invalidate(fileTimeInfoEntries?: ReadonlyMap<string, FileSystemInfoEntry | "ignore"> | undefined, contextTimeInfoEntries?: ReadonlyMap<string, FileSystemInfoEntry | "ignore"> | undefined, changedFiles?: ReadonlySet<string> | undefined, removedFiles?: ReadonlySet<string> | undefined): void;
    suspend(): void;
    resume(): void;
    /**
     * @param {Callback<void>} callback signals when the watcher is closed
     * @returns {void}
     */
    close(callback: Callback<void>): void;
}
declare namespace Watching {
    export { WatchOptions, Compilation, Compiler, FileSystemInfoEntry, WebpackError, Logger, Callback };
}
import Stats = require("webpack/lib/Stats");
type Callback<T> = (err?: (Error | null) | undefined, result?: T | undefined) => any;
type Compilation = import("./Compilation");
type FileSystemInfoEntry = import("./FileSystemInfo").FileSystemInfoEntry;
type Compiler = import("./Compiler");
type WatchOptions = any;
type WebpackError = import("./WebpackError");
type Logger = import("./logging/Logger").Logger;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/WebpackError.d.ts
export = WebpackError;
/** @typedef {import("./Chunk")} Chunk */
/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("./Module")} Module */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class WebpackError extends Error {
    /** @type {string | undefined} */
    details: string | undefined;
    /** @type {Module | undefined | null} */
    module: Module | undefined | null;
    /** @type {DependencyLocation | undefined} */
    loc: DependencyLocation | undefined;
    /** @type {boolean | undefined} */
    hideStack: boolean | undefined;
    /** @type {Chunk | undefined} */
    chunk: Chunk | undefined;
    /** @type {string | undefined} */
    file: string | undefined;
    /**
     * @param {ObjectSerializerContext} context context
     */
    serialize({ write }: ObjectSerializerContext): void;
    /**
     * @param {ObjectDeserializerContext} context context
     */
    deserialize({ read }: ObjectDeserializerContext): void;
}
declare namespace WebpackError {
    export { Chunk, DependencyLocation, Module, ObjectDeserializerContext, ObjectSerializerContext };
}
type Module = import("./Module");
type DependencyLocation = import("./Dependency").DependencyLocation;
type Chunk = import("./Chunk");
type ObjectSerializerContext = import("./serialization/ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./serialization/ObjectMiddleware").ObjectDeserializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/WebpackIsIncludedPlugin.d.ts
export = WebpackIsIncludedPlugin;
declare class WebpackIsIncludedPlugin {
    /**
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace WebpackIsIncludedPlugin {
    export { Resolver, Compiler, DependencyLocation, Module, JavascriptParser, Range };
}
type Compiler = import("./Compiler");
type Resolver = import("enhanced-resolve").Resolver;
type DependencyLocation = import("./Dependency").DependencyLocation;
type Module = import("./Module");
type JavascriptParser = import("./javascript/JavascriptParser");
type Range = import("./javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/WebpackOptionsApply.d.ts
export = WebpackOptionsApply;
/** @typedef {import("../declarations/WebpackOptions").WebpackOptionsNormalized} WebpackOptions */
/** @typedef {import("./Compiler")} Compiler */
declare class WebpackOptionsApply extends OptionsApply {
    /**
     * @param {WebpackOptions} options options object
     * @param {Compiler} compiler compiler object
     * @returns {WebpackOptions} options object
     */
    process(options: any, compiler: Compiler): any;
}
declare namespace WebpackOptionsApply {
    export { WebpackOptions, Compiler };
}
import OptionsApply = require("webpack/lib/OptionsApply");
type Compiler = import("./Compiler");
type WebpackOptions = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/WebpackOptionsDefaulter.d.ts
export = WebpackOptionsDefaulter;
/** @typedef {import("./config/normalization").WebpackOptions} WebpackOptions */
/** @typedef {import("./config/normalization").WebpackOptionsNormalized} WebpackOptionsNormalized */
declare class WebpackOptionsDefaulter {
    /**
     * @param {WebpackOptions} options webpack options
     * @returns {WebpackOptionsNormalized} normalized webpack options
     */
    process(options: any): any;
}
declare namespace WebpackOptionsDefaulter {
    export { WebpackOptions, WebpackOptionsNormalized };
}
type WebpackOptions = import("./config/normalization").WebpackOptions;
type WebpackOptionsNormalized = import("./config/normalization").WebpackOptionsNormalized;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/asset/AssetGenerator.d.ts
export = AssetGenerator;
declare class AssetGenerator extends Generator {
    /**
     * @param {AssetGeneratorOptions["dataUrl"]=} dataUrlOptions the options for the data url
     * @param {string=} filename override for output.assetModuleFilename
     * @param {RawPublicPath=} publicPath override for output.assetModulePublicPath
     * @param {AssetModuleOutputPath=} outputPath the output path for the emitted file which is not included in the runtime import
     * @param {boolean=} emit generate output asset
     */
    constructor(dataUrlOptions?: any, filename?: string | undefined, publicPath?: any, outputPath?: any, emit?: boolean | undefined);
    dataUrlOptions: any;
    filename: string;
    publicPath: any;
    outputPath: any;
    emit: boolean;
    /**
     * @param {NormalModule} module module
     * @param {RuntimeTemplate} runtimeTemplate runtime template
     * @returns {string} source file name
     */
    getSourceFileName(module: NormalModule, runtimeTemplate: RuntimeTemplate): string;
    /**
     * @param {NormalModule} module module
     * @returns {string} mime type
     */
    getMimeType(module: NormalModule): string;
}
declare namespace AssetGenerator {
    export { Source, AssetGeneratorOptions, AssetModuleOutputPath, RawPublicPath, Compilation, Compiler, GenerateContext, UpdateHashContext, Module, ConcatenationBailoutReasonContext, NormalModule, RuntimeTemplate, Hash };
}
import Generator = require("webpack/lib/Generator");
type NormalModule = import("../NormalModule");
type RuntimeTemplate = import("../RuntimeTemplate");
type Source = import("webpack-sources").Source;
type AssetGeneratorOptions = any;
type AssetModuleOutputPath = any;
type RawPublicPath = any;
type Compilation = import("../Compilation");
type Compiler = import("../Compiler");
type GenerateContext = import("../Generator").GenerateContext;
type UpdateHashContext = import("../Generator").UpdateHashContext;
type Module = import("../Module");
type ConcatenationBailoutReasonContext = import("../Module").ConcatenationBailoutReasonContext;
type Hash = import("../util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/asset/AssetModulesPlugin.d.ts
export = AssetModulesPlugin;
declare class AssetModulesPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace AssetModulesPlugin {
    export { Source, Chunk, Compiler, Module };
}
type Compiler = import("../Compiler");
type Source = import("webpack-sources").Source;
type Chunk = import("../Chunk");
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/asset/AssetParser.d.ts
export = AssetParser;
/** @typedef {import("../../declarations/WebpackOptions").AssetParserDataUrlOptions} AssetParserDataUrlOptions */
/** @typedef {import("../../declarations/WebpackOptions").AssetParserOptions} AssetParserOptions */
/** @typedef {import("../Module").BuildInfo} BuildInfo */
/** @typedef {import("../Module").BuildMeta} BuildMeta */
/** @typedef {import("../Parser").ParserState} ParserState */
/** @typedef {import("../Parser").PreparsedAst} PreparsedAst */
declare class AssetParser extends Parser {
    /**
     * @param {AssetParserOptions["dataUrlCondition"] | boolean} dataUrlCondition condition for inlining as DataUrl
     */
    constructor(dataUrlCondition: AssetParserOptions["dataUrlCondition"] | boolean);
    dataUrlCondition: any;
}
declare namespace AssetParser {
    export { AssetParserDataUrlOptions, AssetParserOptions, BuildInfo, BuildMeta, ParserState, PreparsedAst };
}
import Parser = require("webpack/lib/Parser");
type AssetParserOptions = any;
type AssetParserDataUrlOptions = any;
type BuildInfo = import("../Module").BuildInfo;
type BuildMeta = import("../Module").BuildMeta;
type ParserState = import("../Parser").ParserState;
type PreparsedAst = import("../Parser").PreparsedAst;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/asset/AssetSourceGenerator.d.ts
export = AssetSourceGenerator;
declare class AssetSourceGenerator extends Generator {
}
declare namespace AssetSourceGenerator {
    export { Source, GenerateContext, ConcatenationBailoutReasonContext, NormalModule };
}
import Generator = require("webpack/lib/Generator");
type Source = import("webpack-sources").Source;
type GenerateContext = import("../Generator").GenerateContext;
type ConcatenationBailoutReasonContext = import("../Module").ConcatenationBailoutReasonContext;
type NormalModule = import("../NormalModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/asset/AssetSourceParser.d.ts
export = AssetSourceParser;
/** @typedef {import("../Module").BuildInfo} BuildInfo */
/** @typedef {import("../Module").BuildMeta} BuildMeta */
/** @typedef {import("../Parser").ParserState} ParserState */
/** @typedef {import("../Parser").PreparsedAst} PreparsedAst */
declare class AssetSourceParser extends Parser {
}
declare namespace AssetSourceParser {
    export { BuildInfo, BuildMeta, ParserState, PreparsedAst };
}
import Parser = require("webpack/lib/Parser");
type BuildInfo = import("../Module").BuildInfo;
type BuildMeta = import("../Module").BuildMeta;
type ParserState = import("../Parser").ParserState;
type PreparsedAst = import("../Parser").PreparsedAst;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/asset/RawDataUrlModule.d.ts
export = RawDataUrlModule;
declare class RawDataUrlModule extends Module {
    /**
     * @param {string} url raw url
     * @param {string} identifier unique identifier
     * @param {string=} readableIdentifier readable identifier
     */
    constructor(url: string, identifier: string, readableIdentifier?: string | undefined);
    url: string;
    urlBuffer: Buffer;
    identifierStr: string;
    readableIdentifierStr: string;
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context: UpdateHashContext): void;
}
declare namespace RawDataUrlModule {
    export { WebpackOptions, Compilation, UpdateHashContext, CodeGenerationContext, CodeGenerationResult, NeedBuildContext, RequestShortener, ResolverWithOptions, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, Hash, InputFileSystem };
}
import Module = require("webpack/lib/Module");
type Hash = import("../util/Hash");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type WebpackOptions = any;
type Compilation = import("../Compilation");
type CodeGenerationContext = import("../Module").CodeGenerationContext;
type CodeGenerationResult = import("../Module").CodeGenerationResult;
type NeedBuildContext = import("../Module").NeedBuildContext;
type RequestShortener = import("../RequestShortener");
type ResolverWithOptions = import("../ResolverFactory").ResolverWithOptions;
type WebpackError = import("../WebpackError");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type InputFileSystem = import("../util/fs").InputFileSystem;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/async-modules/AwaitDependenciesInitFragment.d.ts
export = AwaitDependenciesInitFragment;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../Generator").GenerateContext} GenerateContext */
/**
 * @typedef {GenerateContext} Context
 */
declare class AwaitDependenciesInitFragment extends InitFragment<any> {
    /**
     * @param {Set<string>} promises the promises that should be awaited
     */
    constructor(promises: Set<string>);
    promises: Set<string>;
    /**
     * @param {AwaitDependenciesInitFragment} other other AwaitDependenciesInitFragment
     * @returns {AwaitDependenciesInitFragment} AwaitDependenciesInitFragment
     */
    merge(other: AwaitDependenciesInitFragment): AwaitDependenciesInitFragment;
    /**
     * @param {Context} context context
     * @returns {string|Source} the source code that will be included as initialization code
     */
    getContent({ runtimeRequirements }: Context): string | Source;
}
declare namespace AwaitDependenciesInitFragment {
    export { Source, GenerateContext, Context };
}
import InitFragment = require("webpack/lib/InitFragment");
type Context = GenerateContext;
type Source = import("webpack-sources").Source;
type GenerateContext = import("../Generator").GenerateContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/async-modules/InferAsyncModulesPlugin.d.ts
export = InferAsyncModulesPlugin;
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
declare class InferAsyncModulesPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace InferAsyncModulesPlugin {
    export { Compiler, Module };
}
type Compiler = import("../Compiler");
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/buildChunkGraph.d.ts
export = buildChunkGraph;
/**
 * This method creates the Chunk graph from the Module graph
 * @param {Compilation} compilation the compilation
 * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules
 * @returns {void}
 */
declare function buildChunkGraph(compilation: Compilation, inputEntrypointsAndModules: Map<Entrypoint, Module[]>): void;
declare namespace buildChunkGraph {
    export { AsyncDependenciesBlock, Chunk, ChunkGroup, Compilation, DependenciesBlock, Dependency, DependencyLocation, Entrypoint, Module, ModuleGraph, ConnectionState, Logger, RuntimeSpec, QueueItem, ModuleSetPlus, ChunkGroupInfo, BlockChunkGroupConnection };
}
type Compilation = import("./Compilation");
type Entrypoint = import("./Entrypoint");
type Module = import("./Module");
type AsyncDependenciesBlock = import("./AsyncDependenciesBlock");
type Chunk = import("./Chunk");
type ChunkGroup = import("./ChunkGroup");
type DependenciesBlock = import("./DependenciesBlock");
type Dependency = import("./Dependency");
type DependencyLocation = import("./Dependency").DependencyLocation;
type ModuleGraph = import("./ModuleGraph");
type ConnectionState = import("./ModuleGraphConnection").ConnectionState;
type Logger = import("./logging/Logger").Logger;
type RuntimeSpec = import("./util/runtime").RuntimeSpec;
type QueueItem = {
    action: number;
    block: DependenciesBlock;
    module: Module;
    chunk: Chunk;
    chunkGroup: ChunkGroup;
    chunkGroupInfo: ChunkGroupInfo;
};
type ModuleSetPlus = Set<Module> & {
    plus: Set<Module>;
};
type ChunkGroupInfo = {
    /**
     * the chunk group
     */
    chunkGroup: ChunkGroup;
    /**
     * the runtimes
     */
    runtime: RuntimeSpec;
    /**
     * current minimal set of modules available at this point
     */
    minAvailableModules: ModuleSetPlus | undefined;
    /**
     * true, if minAvailableModules is owned and can be modified
     */
    minAvailableModulesOwned: boolean | undefined;
    /**
     * enqueued updates to the minimal set of available modules
     */
    availableModulesToBeMerged: ModuleSetPlus[];
    /**
     * modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)
     */
    skippedItems?: Set<Module> | undefined;
    /**
     * referenced modules that where skipped because they were not active in this runtime
     */
    skippedModuleConnections?: Set<[Module, ConnectionState]> | undefined;
    /**
     * set of modules available including modules from this chunk group
     */
    resultingAvailableModules: ModuleSetPlus | undefined;
    /**
     * set of children chunk groups, that will be revisited when availableModules shrink
     */
    children: Set<ChunkGroupInfo> | undefined;
    /**
     * set of chunk groups that are the source for minAvailableModules
     */
    availableSources: Set<ChunkGroupInfo> | undefined;
    /**
     * set of chunk groups which depend on the this chunk group as availableSource
     */
    availableChildren: Set<ChunkGroupInfo> | undefined;
    /**
     * next pre order index
     */
    preOrderIndex: number;
    /**
     * next post order index
     */
    postOrderIndex: number;
    /**
     * has a chunk loading mechanism
     */
    chunkLoading: boolean;
    /**
     * create async chunks
     */
    asyncChunks: boolean;
};
type BlockChunkGroupConnection = {
    /**
     * origin chunk group
     */
    originChunkGroupInfo: ChunkGroupInfo;
    /**
     * referenced chunk group
     */
    chunkGroup: ChunkGroup;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/cache/AddBuildDependenciesPlugin.d.ts
export = AddBuildDependenciesPlugin;
/** @typedef {import("../Compiler")} Compiler */
declare class AddBuildDependenciesPlugin {
    /**
     * @param {Iterable<string>} buildDependencies list of build dependencies
     */
    constructor(buildDependencies: Iterable<string>);
    buildDependencies: Set<string>;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace AddBuildDependenciesPlugin {
    export { Compiler };
}
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/cache/AddManagedPathsPlugin.d.ts
export = AddManagedPathsPlugin;
/** @typedef {import("../Compiler")} Compiler */
declare class AddManagedPathsPlugin {
    /**
     * @param {Iterable<string | RegExp>} managedPaths list of managed paths
     * @param {Iterable<string | RegExp>} immutablePaths list of immutable paths
     */
    constructor(managedPaths: Iterable<string | RegExp>, immutablePaths: Iterable<string | RegExp>);
    managedPaths: Set<string | RegExp>;
    immutablePaths: Set<string | RegExp>;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace AddManagedPathsPlugin {
    export { Compiler };
}
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/cache/IdleFileCachePlugin.d.ts
export = IdleFileCachePlugin;
declare class IdleFileCachePlugin {
    /**
     * @param {TODO} strategy cache strategy
     * @param {number} idleTimeout timeout
     * @param {number} idleTimeoutForInitialStore initial timeout
     * @param {number} idleTimeoutAfterLargeChanges timeout after changes
     */
    constructor(strategy: TODO, idleTimeout: number, idleTimeoutForInitialStore: number, idleTimeoutAfterLargeChanges: number);
    strategy: TODO;
    idleTimeout: number;
    idleTimeoutForInitialStore: number;
    idleTimeoutAfterLargeChanges: number;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace IdleFileCachePlugin {
    export { Compiler };
}
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/cache/MemoryCachePlugin.d.ts
export = MemoryCachePlugin;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../Cache").Etag} Etag */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
declare class MemoryCachePlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace MemoryCachePlugin {
    export { Source, Etag, Compiler, Module };
}
type Compiler = import("../Compiler");
type Source = import("webpack-sources").Source;
type Etag = import("../Cache").Etag;
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/cache/MemoryWithGcCachePlugin.d.ts
export = MemoryWithGcCachePlugin;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../Cache").Etag} Etag */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
declare class MemoryWithGcCachePlugin {
    constructor({ maxGenerations }: {
        maxGenerations: any;
    });
    _maxGenerations: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace MemoryWithGcCachePlugin {
    export { Source, Etag, Compiler, Module };
}
type Compiler = import("../Compiler");
type Source = import("webpack-sources").Source;
type Etag = import("../Cache").Etag;
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/cache/PackFileCacheStrategy.d.ts
export = PackFileCacheStrategy;
declare class PackFileCacheStrategy {
    /**
     * @param {Object} options options
     * @param {Compiler} options.compiler the compiler
     * @param {IntermediateFileSystem} options.fs the filesystem
     * @param {string} options.context the context directory
     * @param {string} options.cacheLocation the location of the cache data
     * @param {string} options.version version identifier
     * @param {Logger} options.logger a logger
     * @param {SnapshotOptions} options.snapshot options regarding snapshotting
     * @param {number} options.maxAge max age of cache items
     * @param {boolean | undefined} options.profile track and log detailed timing information for individual cache items
     * @param {boolean | undefined} options.allowCollectingMemory allow to collect unused memory created during deserialization
     * @param {false | "gzip" | "brotli" | undefined} options.compression compression used
     * @param {boolean | undefined} options.readonly disable storing cache into filesystem
     */
    constructor({ compiler, fs, context, cacheLocation, version, logger, snapshot, maxAge, profile, allowCollectingMemory, compression, readonly }: {
        compiler: Compiler;
        fs: IntermediateFileSystem;
        context: string;
        cacheLocation: string;
        version: string;
        logger: Logger;
        snapshot: SnapshotOptions;
        maxAge: number;
        profile: boolean | undefined;
        allowCollectingMemory: boolean | undefined;
        compression: false | "gzip" | "brotli" | undefined;
        readonly: boolean | undefined;
    });
    fileSerializer: import("webpack/lib/serialization/Serializer");
    fileSystemInfo: FileSystemInfo;
    compiler: import("webpack/lib/Compiler");
    context: string;
    cacheLocation: string;
    version: string;
    logger: import("webpack/lib/logging/Logger").Logger;
    maxAge: number;
    profile: boolean;
    readonly: boolean;
    allowCollectingMemory: boolean;
    compression: false | "gzip" | "brotli";
    _extension: string;
    snapshot: any;
    /** @type {Set<string>} */
    buildDependencies: Set<string>;
    /** @type {LazySet<string>} */
    newBuildDependencies: LazySet<string>;
    /** @type {Snapshot | undefined} */
    resolveBuildDependenciesSnapshot: Snapshot | undefined;
    /** @type {ResolveResults | undefined} */
    resolveResults: ResolveResults | undefined;
    /** @type {Snapshot | undefined} */
    buildSnapshot: Snapshot | undefined;
    /** @type {Promise<Pack> | undefined} */
    packPromise: Promise<Pack> | undefined;
    storePromise: Promise<void>;
    /**
     * @returns {Promise<Pack>} pack
     */
    _getPack(): Promise<Pack>;
    /**
     * @returns {Promise<Pack>} the pack
     */
    _openPack(): Promise<Pack>;
    /**
     * @param {string} identifier unique name for the resource
     * @param {Etag | null} etag etag of the resource
     * @param {any} data cached content
     * @returns {Promise<void>} promise
     */
    store(identifier: string, etag: Etag | null, data: any): Promise<void>;
    /**
     * @param {string} identifier unique name for the resource
     * @param {Etag | null} etag etag of the resource
     * @returns {Promise<any>} promise to the cached content
     */
    restore(identifier: string, etag: Etag | null): Promise<any>;
    /**
     * @param {LazySet<string>} dependencies dependencies to store
     */
    storeBuildDependencies(dependencies: LazySet<string>): void;
    afterAllStored(): Promise<any>;
    clear(): void;
}
declare namespace PackFileCacheStrategy {
    export { SnapshotOptions, Etag, Compiler, ResolveBuildDependenciesResult, Snapshot, Logger, ObjectDeserializerContext, ObjectSerializerContext, IntermediateFileSystem, ResolveResults };
}
import FileSystemInfo = require("webpack/lib/FileSystemInfo");
import LazySet = require("webpack/lib/util/LazySet");
type Snapshot = import("../FileSystemInfo").Snapshot;
type ResolveResults = Map<string, string | false>;
declare class Pack {
    constructor(logger: any, maxAge: any);
    /** @type {Map<string, PackItemInfo>} */
    itemInfo: Map<string, PackItemInfo>;
    /** @type {(string | undefined)[]} */
    requests: (string | undefined)[];
    requestsTimeout: any;
    /** @type {Map<string, PackItemInfo>} */
    freshContent: Map<string, PackItemInfo>;
    /** @type {(undefined | PackContent)[]} */
    content: (undefined | PackContent)[];
    invalid: boolean;
    logger: any;
    maxAge: any;
    /**
     * @param {string} identifier identifier
     */
    _addRequest(identifier: string): void;
    stopCapturingRequests(): void;
    /**
     * @param {string} identifier unique name for the resource
     * @param {string | null} etag etag of the resource
     * @returns {any} cached content
     */
    get(identifier: string, etag: string | null): any;
    /**
     * @param {string} identifier unique name for the resource
     * @param {string | null} etag etag of the resource
     * @param {any} data cached content
     * @returns {void}
     */
    set(identifier: string, etag: string | null, data: any): void;
    getContentStats(): {
        count: number;
        size: number;
    };
    /**
     * @returns {number} new location of data entries
     */
    _findLocation(): number;
    _gcAndUpdateLocation(items: any, usedItems: any, newLoc: any): void;
    _persistFreshContent(): void;
    /**
     * Merges small content files to a single content file
     */
    _optimizeSmallContent(): void;
    /**
     * Split large content files with used and unused items
     * into two parts to separate used from unused items
     */
    _optimizeUnusedContent(): void;
    /**
     * Find the content with the oldest item and run GC on that.
     * Only runs for one content to avoid large invalidation.
     */
    _gcOldestContent(): void;
    serialize({ write, writeSeparate }: {
        write: any;
        writeSeparate: any;
    }): void;
    deserialize({ read, logger }: {
        read: any;
        logger: any;
    }): void;
}
type Etag = import("../Cache").Etag;
type Compiler = import("../Compiler");
type IntermediateFileSystem = import("../util/fs").IntermediateFileSystem;
type Logger = import("../logging/Logger").Logger;
type SnapshotOptions = any;
type ResolveBuildDependenciesResult = import("../FileSystemInfo").ResolveBuildDependenciesResult;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
declare class PackItemInfo {
    /**
     * @param {string} identifier identifier of item
     * @param {string | null} etag etag of item
     * @param {any} value fresh value of item
     */
    constructor(identifier: string, etag: string | null, value: any);
    identifier: string;
    etag: string;
    location: number;
    lastAccess: number;
    freshValue: any;
}
declare class PackContent {
    /**
     * @param {Set<string>} items keys
     * @param {Set<string>} usedItems used keys
     * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content
     * @param {Logger=} logger logger for logging
     * @param {string=} lazyName name of dataOrFn for logging
     */
    constructor(items: Set<string>, usedItems: Set<string>, dataOrFn: PackContentItems | (() => Promise<PackContentItems>), logger?: Logger | undefined, lazyName?: string | undefined);
    items: Set<string>;
    /** @type {function(): Promise<PackContentItems> | PackContentItems} */
    lazy: () => Promise<PackContentItems> | PackContentItems;
    /** @type {Map<string, any>} */
    content: Map<string, any>;
    outdated: boolean;
    used: Set<string>;
    logger: import("webpack/lib/logging/Logger").Logger;
    lazyName: string;
    get(identifier: any): any;
    /**
     * @param {string} reason explanation why unpack is necessary
     * @returns {void | Promise<void>} maybe a promise if lazy
     */
    unpack(reason: string): void | Promise<void>;
    /**
     * @returns {number} size of the content or -1 if not known
     */
    getSize(): number;
    /**
     * @param {string} identifier identifier
     */
    delete(identifier: string): void;
    /**
     * @template T
     * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function
     * @returns {void}
     */
    writeLazy<T>(write: (arg0: any) => () => Promise<PackContentItems> | PackContentItems): void;
}
declare class PackContentItems {
    /**
     * @param {Map<string, any>} map items
     */
    constructor(map: Map<string, any>);
    map: Map<string, any>;
    serialize({ write, snapshot, rollback, logger, profile }: {
        write: any;
        snapshot: any;
        rollback: any;
        logger: any;
        profile: any;
    }): void;
    deserialize({ read, logger, profile }: {
        read: any;
        logger: any;
        profile: any;
    }): void;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/cache/ResolverCachePlugin.d.ts
export = ResolverCachePlugin;
declare class ResolverCachePlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ResolverCachePlugin {
    export { Resolver, ItemCacheFacade, Compiler, FileSystemInfo, Snapshot };
}
type Compiler = import("../Compiler");
type Resolver = any;
type ItemCacheFacade = import("../CacheFacade").ItemCacheFacade;
type FileSystemInfo = import("../FileSystemInfo");
type Snapshot = import("../FileSystemInfo").Snapshot;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/cache/getLazyHashedEtag.d.ts
export = getter;
/**
 * @param {HashableObject} obj object with updateHash method
 * @param {string | HashConstructor} hashFunction the hash function to use
 * @returns {LazyHashedEtag} etag
 */
declare function getter(obj: HashableObject, hashFunction?: string | HashConstructor): LazyHashedEtag;
declare namespace getter {
    export { Hash, HashConstructor, HashableObject };
}
type HashableObject = {
    updateHash: (arg0: Hash) => void;
};
type HashConstructor = typeof import("../util/Hash");
/** @typedef {import("../util/Hash")} Hash */
/** @typedef {typeof import("../util/Hash")} HashConstructor */
/**
 * @typedef {Object} HashableObject
 * @property {function(Hash): void} updateHash
 */
declare class LazyHashedEtag {
    /**
     * @param {HashableObject} obj object with updateHash method
     * @param {string | HashConstructor} hashFunction the hash function to use
     */
    constructor(obj: HashableObject, hashFunction?: string | HashConstructor);
    _obj: HashableObject;
    _hash: string;
    _hashFunction: string | typeof import("webpack/lib/util/Hash");
    /**
     * @returns {string} hash of object
     */
    toString(): string;
}
type Hash = import("../util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/cache/mergeEtags.d.ts
export = mergeEtags;
/**
 * @param {Etag} a first
 * @param {Etag} b second
 * @returns {Etag} result
 */
declare function mergeEtags(a: Etag, b: Etag): Etag;
declare namespace mergeEtags {
    export { Etag };
}
type Etag = import("../Cache").Etag;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/cli.d.ts
export type PathItem = {
    /**
     * the part of the schema
     */
    schema: any;
    /**
     * the path in the config
     */
    path: string;
};
export type ProblemType = "unknown-argument" | "unexpected-non-array-in-path" | "unexpected-non-object-in-path" | "multiple-values-unexpected" | "invalid-value";
export type Problem = {
    type: ProblemType;
    path: string;
    argument: string;
    value?: any | undefined;
    index?: number | undefined;
    expected?: string | undefined;
};
export type LocalProblem = {
    type: ProblemType;
    path: string;
    expected?: string | undefined;
};
export type ArgumentConfig = {
    description: string;
    negatedDescription?: string;
    path: string;
    multiple: boolean;
    type: "enum" | "string" | "path" | "number" | "boolean" | "RegExp" | "reset";
    values?: any[] | undefined;
};
export type Argument = {
    description: string;
    simpleType: "string" | "number" | "boolean";
    multiple: boolean;
    configs: ArgumentConfig[];
};
/**
 * @typedef {Object} PathItem
 * @property {any} schema the part of the schema
 * @property {string} path the path in the config
 */
/** @typedef {"unknown-argument" | "unexpected-non-array-in-path" | "unexpected-non-object-in-path" | "multiple-values-unexpected" | "invalid-value"} ProblemType */
/**
 * @typedef {Object} Problem
 * @property {ProblemType} type
 * @property {string} path
 * @property {string} argument
 * @property {any=} value
 * @property {number=} index
 * @property {string=} expected
 */
/**
 * @typedef {Object} LocalProblem
 * @property {ProblemType} type
 * @property {string} path
 * @property {string=} expected
 */
/**
 * @typedef {Object} ArgumentConfig
 * @property {string} description
 * @property {string} [negatedDescription]
 * @property {string} path
 * @property {boolean} multiple
 * @property {"enum"|"string"|"path"|"number"|"boolean"|"RegExp"|"reset"} type
 * @property {any[]=} values
 */
/**
 * @typedef {Object} Argument
 * @property {string} description
 * @property {"string"|"number"|"boolean"} simpleType
 * @property {boolean} multiple
 * @property {ArgumentConfig[]} configs
 */
/**
 * @param {any=} schema a json schema to create arguments for (by default webpack schema is used)
 * @returns {Record<string, Argument>} object of arguments
 */
export function getArguments(schema?: any | undefined): Record<string, Argument>;
/**
 * @param {Record<string, Argument>} args object of arguments
 * @param {any} config configuration
 * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>} values object with values
 * @returns {Problem[] | null} problems or null for success
 */
export function processArguments(args: Record<string, Argument>, config: any, values: Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>): Problem[] | null;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/config/browserslistTargetHandler.d.ts
export type ApiTargetProperties = import("./target").ApiTargetProperties;
export type EcmaTargetProperties = import("./target").EcmaTargetProperties;
export type PlatformTargetProperties = import("./target").PlatformTargetProperties;
export type BrowserslistHandlerConfig = {
    configPath?: string | undefined;
    env?: string | undefined;
    query?: string | undefined;
};
/**
 * @param {string[]} browsers supported browsers list
 * @returns {EcmaTargetProperties & PlatformTargetProperties & ApiTargetProperties} target properties
 */
export function resolve(browsers: string[]): EcmaTargetProperties & PlatformTargetProperties & ApiTargetProperties;
/**
 * @param {string | null | undefined} input input string
 * @param {string} context the context directory
 * @returns {string[] | undefined} selected browsers
 */
export function load(input: string | null | undefined, context: string): string[] | undefined;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/config/defaults.d.ts
export type CacheOptions = any;
export type Context = any;
export type CssExperimentOptions = any;
export type EntryDescription = any;
export type Entry = any;
export type EntryStaticNormalized = any;
export type Environment = any;
export type Experiments = any;
export type ExperimentsNormalized = any;
export type ExternalsPresets = any;
export type ExternalsType = any;
export type FileCacheOptions = any;
export type InfrastructureLogging = any;
export type JavascriptParserOptions = any;
export type Library = any;
export type LibraryName = any;
export type LibraryOptions = any;
export type LibraryType = any;
export type Loader = any;
export type Mode = any;
export type ModuleOptions = any;
export type WebpackNode = any;
export type Optimization = any;
export type OptimizationSplitChunksOptions = any;
export type Output = any;
export type ParserOptionsByModuleTypeKnown = any;
export type Performance = any;
export type ResolveOptions = any;
export type RuleSetRules = any;
export type SnapshotOptions = any;
export type Target = any;
export type WebpackOptions = any;
export type Compiler = import("../Compiler");
export type Module = import("../Module");
export type TargetProperties = import("./target").TargetProperties;
/**
 * @param {WebpackOptions} options options to be modified
 * @returns {void}
 */
export function applyWebpackOptionsBaseDefaults(options: any): void;
/**
 * @param {WebpackOptions} options options to be modified
 * @returns {void}
 */
export function applyWebpackOptionsDefaults(options: any): void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/config/normalization.d.ts
export type CacheOptions = any;
export type EntryDescriptionNormalized = any;
export type EntryStatic = any;
export type EntryStaticNormalized = any;
export type Externals = any;
export type LibraryName = any;
export type LibraryOptions = any;
export type ModuleOptionsNormalized = any;
export type OptimizationRuntimeChunk = any;
export type OptimizationRuntimeChunkNormalized = any;
export type OutputNormalized = any;
export type Plugins = any;
export type WebpackOptions = any;
export type WebpackOptionsNormalized = any;
export type Entrypoint = import("../Entrypoint");
/**
 * @param {WebpackOptions} config input config
 * @returns {WebpackOptionsNormalized} normalized options
 */
export function getNormalizedWebpackOptions(config: any): any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/config/target.d.ts
export type PlatformTargetProperties = {
    /**
     * web platform, importing of http(s) and std: is available
     */
    web: boolean | null;
    /**
     * browser platform, running in a normal web browser
     */
    browser: boolean | null;
    /**
     * (Web)Worker platform, running in a web/shared/service worker
     */
    webworker: boolean | null;
    /**
     * node platform, require of node built-in modules is available
     */
    node: boolean | null;
    /**
     * nwjs platform, require of legacy nw.gui is available
     */
    nwjs: boolean | null;
    /**
     * electron platform, require of some electron built-in modules is available
     */
    electron: boolean | null;
};
export type ElectronContextTargetProperties = {
    /**
     * in main context
     */
    electronMain: boolean | null;
    /**
     * in preload context
     */
    electronPreload: boolean | null;
    /**
     * in renderer context with node integration
     */
    electronRenderer: boolean | null;
};
export type ApiTargetProperties = {
    /**
     * has require function available
     */
    require: boolean | null;
    /**
     * has node.js built-in modules available
     */
    nodeBuiltins: boolean | null;
    /**
     * has document available (allows script tags)
     */
    document: boolean | null;
    /**
     * has importScripts available
     */
    importScripts: boolean | null;
    /**
     * has importScripts available when creating a worker
     */
    importScriptsInWorker: boolean | null;
    /**
     * has fetch function available for WebAssembly
     */
    fetchWasm: boolean | null;
    /**
     * has global variable available
     */
    global: boolean | null;
};
export type EcmaTargetProperties = {
    /**
     * has globalThis variable available
     */
    globalThis: boolean | null;
    /**
     * big int literal syntax is available
     */
    bigIntLiteral: boolean | null;
    /**
     * const and let variable declarations are available
     */
    const: boolean | null;
    /**
     * arrow functions are available
     */
    arrowFunction: boolean | null;
    /**
     * for of iteration is available
     */
    forOf: boolean | null;
    /**
     * destructuring is available
     */
    destructuring: boolean | null;
    /**
     * async import() is available
     */
    dynamicImport: boolean | null;
    /**
     * async import() is available when creating a worker
     */
    dynamicImportInWorker: boolean | null;
    /**
     * ESM syntax is available (when in module)
     */
    module: boolean | null;
    /**
     * optional chaining is available
     */
    optionalChaining: boolean | null;
    /**
     * template literal is available
     */
    templateLiteral: boolean | null;
};
/**
 * <T>
 */
export type Never<T> = { [P in keyof T]?: never; };
/**
 * <A, B>
 */
export type Mix<A, B> = (A & Never<B>) | (Never<A> & B) | (A & B);
export type TargetProperties = Mix<Mix<PlatformTargetProperties, ElectronContextTargetProperties>, Mix<ApiTargetProperties, EcmaTargetProperties>>;
/**
 * @param {string} context the context directory
 * @returns {string} default target
 */
export function getDefaultTarget(context: string): string;
/**
 * @param {string} target the target
 * @param {string} context the context directory
 * @returns {TargetProperties} target properties
 */
export function getTargetProperties(target: string, context: string): TargetProperties;
/**
 * @param {string[]} targets the targets
 * @param {string} context the context directory
 * @returns {TargetProperties} target properties
 */
export function getTargetsProperties(targets: string[], context: string): TargetProperties;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/ContainerEntryDependency.d.ts
export = ContainerEntryDependency;
/** @typedef {import("./ContainerEntryModule").ExposeOptions} ExposeOptions */
declare class ContainerEntryDependency extends Dependency {
    /**
     * @param {string} name entry name
     * @param {[string, ExposeOptions][]} exposes list of exposed modules
     * @param {string} shareScope name of the share scope
     */
    constructor(name: string, exposes: [string, ExposeOptions][], shareScope: string);
    name: string;
    exposes: [string, import("webpack/lib/container/ContainerEntryModule").ExposeOptions][];
    shareScope: string;
}
declare namespace ContainerEntryDependency {
    export { ExposeOptions };
}
import Dependency = require("webpack/lib/Dependency");
type ExposeOptions = import("./ContainerEntryModule").ExposeOptions;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/ContainerEntryModule.d.ts
export = ContainerEntryModule;
declare class ContainerEntryModule extends Module {
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {ContainerEntryModule} deserialized container entry module
     */
    static deserialize(context: ObjectDeserializerContext): ContainerEntryModule;
    /**
     * @param {string} name container entry name
     * @param {[string, ExposeOptions][]} exposes list of exposed modules
     * @param {string} shareScope name of the share scope
     */
    constructor(name: string, exposes: [string, ExposeOptions][], shareScope: string);
    _name: string;
    _exposes: [string, ExposeOptions][];
    _shareScope: string;
}
declare namespace ContainerEntryModule {
    export { WebpackOptions, ChunkGraph, ChunkGroup, Compilation, CodeGenerationContext, CodeGenerationResult, LibIdentOptions, NeedBuildContext, RequestShortener, ResolverWithOptions, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, Hash, InputFileSystem, ContainerEntryDependency, ExposeOptions };
}
import Module = require("webpack/lib/Module");
type ExposeOptions = {
    /**
     * requests to exposed modules (last one is exported)
     */
    import: string[];
    /**
     * custom chunk name for the exposed module
     */
    name: string;
};
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type WebpackOptions = any;
type ChunkGraph = import("../ChunkGraph");
type ChunkGroup = import("../ChunkGroup");
type Compilation = import("../Compilation");
type CodeGenerationContext = import("../Module").CodeGenerationContext;
type CodeGenerationResult = import("../Module").CodeGenerationResult;
type LibIdentOptions = import("../Module").LibIdentOptions;
type NeedBuildContext = import("../Module").NeedBuildContext;
type RequestShortener = import("../RequestShortener");
type ResolverWithOptions = import("../ResolverFactory").ResolverWithOptions;
type WebpackError = import("../WebpackError");
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type InputFileSystem = import("../util/fs").InputFileSystem;
type ContainerEntryDependency = import("./ContainerEntryDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/ContainerEntryModuleFactory.d.ts
export = ContainerEntryModuleFactory;
declare class ContainerEntryModuleFactory extends ModuleFactory {
}
declare namespace ContainerEntryModuleFactory {
    export { ModuleFactoryCreateData, ModuleFactoryResult, ContainerEntryDependency };
}
import ModuleFactory = require("webpack/lib/ModuleFactory");
type ModuleFactoryCreateData = import("../ModuleFactory").ModuleFactoryCreateData;
type ModuleFactoryResult = import("../ModuleFactory").ModuleFactoryResult;
type ContainerEntryDependency = import("./ContainerEntryDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/ContainerExposedDependency.d.ts
export = ContainerExposedDependency;
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class ContainerExposedDependency extends ModuleDependency {
    /**
     * @param {string} exposedName public name
     * @param {string} request request to module
     */
    constructor(exposedName: string, request: string);
    exposedName: string;
}
declare namespace ContainerExposedDependency {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/ContainerPlugin.d.ts
export = ContainerPlugin;
declare class ContainerPlugin {
    /**
     * @param {ContainerPluginOptions} options options
     */
    constructor(options: ContainerPluginOptions);
    _options: {
        name: string;
        shareScope: string;
        library: import("../../declarations/plugins/container/ContainerPlugin").LibraryOptions;
        runtime: import("../../declarations/plugins/container/ContainerPlugin").EntryRuntime;
        filename: string;
        exposes: [string, {
            import: string[];
            name: any;
        }][];
    };
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ContainerPlugin {
    export { ContainerPluginOptions, Compiler };
}
type Compiler = import("../Compiler");
type ContainerPluginOptions = import("../../declarations/plugins/container/ContainerPlugin").ContainerPluginOptions;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/ContainerReferencePlugin.d.ts
export = ContainerReferencePlugin;
declare class ContainerReferencePlugin {
    /**
     * @param {ContainerReferencePluginOptions} options options
     */
    constructor(options: ContainerReferencePluginOptions);
    _remoteType: import("../../declarations/plugins/container/ContainerReferencePlugin").ExternalsType;
    _remotes: [string, {
        external: string[];
        shareScope: string;
    }][];
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ContainerReferencePlugin {
    export { ContainerReferencePluginOptions, RemotesConfig, Compiler };
}
type Compiler = import("../Compiler");
type ContainerReferencePluginOptions = import("../../declarations/plugins/container/ContainerReferencePlugin").ContainerReferencePluginOptions;
type RemotesConfig = import("../../declarations/plugins/container/ContainerReferencePlugin").RemotesConfig;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/FallbackDependency.d.ts
export = FallbackDependency;
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class FallbackDependency extends Dependency {
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {FallbackDependency} deserialize fallback dependency
     */
    static deserialize(context: ObjectDeserializerContext): FallbackDependency;
    /**
     * @param {string[]} requests requests
     */
    constructor(requests: string[]);
    requests: string[];
}
declare namespace FallbackDependency {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
import Dependency = require("webpack/lib/Dependency");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/FallbackItemDependency.d.ts
export = FallbackItemDependency;
declare class FallbackItemDependency extends ModuleDependency {
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/FallbackModule.d.ts
export = FallbackModule;
declare class FallbackModule extends Module {
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {FallbackModule} deserialized fallback module
     */
    static deserialize(context: ObjectDeserializerContext): FallbackModule;
    /**
     * @param {string[]} requests list of requests to choose one
     */
    constructor(requests: string[]);
    requests: string[];
    _identifier: string;
}
declare namespace FallbackModule {
    export { WebpackOptions, Chunk, ChunkGraph, ChunkGroup, Compilation, CodeGenerationContext, CodeGenerationResult, LibIdentOptions, NeedBuildContext, RequestShortener, ResolverWithOptions, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, Hash, InputFileSystem };
}
import Module = require("webpack/lib/Module");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type WebpackOptions = any;
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type ChunkGroup = import("../ChunkGroup");
type Compilation = import("../Compilation");
type CodeGenerationContext = import("../Module").CodeGenerationContext;
type CodeGenerationResult = import("../Module").CodeGenerationResult;
type LibIdentOptions = import("../Module").LibIdentOptions;
type NeedBuildContext = import("../Module").NeedBuildContext;
type RequestShortener = import("../RequestShortener");
type ResolverWithOptions = import("../ResolverFactory").ResolverWithOptions;
type WebpackError = import("../WebpackError");
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type InputFileSystem = import("../util/fs").InputFileSystem;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/FallbackModuleFactory.d.ts
export = FallbackModuleFactory;
declare class FallbackModuleFactory extends ModuleFactory {
}
declare namespace FallbackModuleFactory {
    export { ModuleFactoryCreateData, ModuleFactoryResult, FallbackDependency };
}
import ModuleFactory = require("webpack/lib/ModuleFactory");
type ModuleFactoryCreateData = import("../ModuleFactory").ModuleFactoryCreateData;
type ModuleFactoryResult = import("../ModuleFactory").ModuleFactoryResult;
type FallbackDependency = import("./FallbackDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/ModuleFederationPlugin.d.ts
export = ModuleFederationPlugin;
declare class ModuleFederationPlugin {
    /**
     * @param {ModuleFederationPluginOptions} options options
     */
    constructor(options: any);
    _options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ModuleFederationPlugin {
    export { ExternalsType, ModuleFederationPluginOptions, Shared, Compiler };
}
type Compiler = import("../Compiler");
type ExternalsType = any;
type ModuleFederationPluginOptions = any;
type Shared = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/RemoteModule.d.ts
export = RemoteModule;
declare class RemoteModule extends Module {
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {RemoteModule} deserialized module
     */
    static deserialize(context: ObjectDeserializerContext): RemoteModule;
    /**
     * @param {string} request request string
     * @param {string[]} externalRequests list of external requests to containers
     * @param {string} internalRequest name of exposed module in container
     * @param {string} shareScope the used share scope name
     */
    constructor(request: string, externalRequests: string[], internalRequest: string, shareScope: string);
    request: string;
    externalRequests: string[];
    internalRequest: string;
    shareScope: string;
    _identifier: string;
    /**
     * @param {NeedBuildContext} context context info
     * @param {function((WebpackError | null)=, boolean=): void} callback callback function, returns true, if the module needs a rebuild
     * @returns {void}
     */
    needBuild(context: NeedBuildContext, callback: (arg0: (WebpackError | null) | undefined, arg1: boolean | undefined) => void): void;
    /**
     * @param {WebpackOptions} options webpack options
     * @param {Compilation} compilation the compilation
     * @param {ResolverWithOptions} resolver the resolver
     * @param {InputFileSystem} fs the file system
     * @param {function(WebpackError=): void} callback callback function
     * @returns {void}webpack
     */
    build(options: WebpackOptions, compilation: Compilation, resolver: ResolverWithOptions, fs: InputFileSystem, callback: (arg0: WebpackError | undefined) => void): void;
}
declare namespace RemoteModule {
    export { WebpackOptionsohunkGraph, ChunkGroup, Compilation, CodeGenerationContext, CodeGenerationResult, LibIdentOptions, NeedBuildContext, RequestShortener, ResolverWithOptions, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, Hash, InputFileSystem };
}
import Module = require("../Module");
type NeedBuildContext = import("../Module").NeedBuildContext;
type WebpackError = import("../WebpackError");
type WebpackOptions = import("../../declarations/WebpackOptions").WebpackOptionsNormalized;
type Compilation = import("../Compilation");
type ResolverWithOptions = import("../ResolverFactory").ResolverWithOptions;
type InputFileSystem = import("../util/fs").InputFileSystem;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ChunkGraph = import("../ChunkGraph");
type ChunkGroup = import("../ChunkGroup");
type CodeGenerationContext = import("../Module").CodeGenerationContext;
type CodeGenerationResult = import("../Module").CodeGenerationResult;
type LibIdentOptions = import("../Module").LibIdentOptions;
type RequestShortener = import("../RequestShortener");
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/RemoteRuntimeModule.d.ts
export = RemoteRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("./RemoteModule")} RemoteModule */
declare class RemoteRuntimeModule extends RuntimeModule {
    constructor();
}
declare namespace RemoteRuntimeModule {
    export { Chunk, RemoteModule };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Chunk = import("../Chunk");
type RemoteModule = import("./RemoteModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/RemoteToExternalDependency.d.ts
export = RemoteToExternalDependency;
declare class RemoteToExternalDependency extends ModuleDependency {
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/container/options.d.ts
export type ContainerOptionsFormat<T> = (string | Record<string, string | string[] | T>)[] | Record<string, string | string[] | T>;
/**
 * @template T
 * @template R
 * @param {ContainerOptionsFormat<T>} options options passed by the user
 * @param {function(string | string[], string) : R} normalizeSimple normalize a simple item
 * @param {function(T, string) : R} normalizeOptions normalize a complex item
 * @returns {[string, R][]} parsed options
 */
export function parseOptions<T, R>(options: ContainerOptionsFormat<T>, normalizeSimple: (arg0: string | string[], arg1: string) => R, normalizeOptions: (arg0: T, arg1: string) => R): [string, R][];
/**
 * @template T
 * @param {string} scope scope name
 * @param {ContainerOptionsFormat<T>} options options passed by the user
 * @returns {Record<string, string | string[] | T>} options to spread or pass
 */
export function scope<T>(scope: string, options: ContainerOptionsFormat<T>): Record<string, string | string[] | T>;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/css/CssExportsGenerator.d.ts
export = CssExportsGenerator;
declare class CssExportsGenerator extends Generator {
}
declare namespace CssExportsGenerator {
    export { Source, Dependency, GenerateContext, UpdateHashContext, ConcatenationBailoutReasonContext, NormalModule, Hash, InitFragment };
}
import Generator = require("webpack/lib/Generator");
type Source = import("webpack-sources").Source;
type Dependency = import("../Dependency");
type GenerateContext = import("../Generator").GenerateContext;
type UpdateHashContext = import("../Generator").UpdateHashContext;
type ConcatenationBailoutReasonContext = import("../Module").ConcatenationBailoutReasonContext;
type NormalModule = import("../NormalModule");
type Hash = import("../util/Hash");
type InitFragment<T> = import("../InitFragment")<T>;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/css/CssGenerator.d.ts
export = CssGenerator;
declare class CssGenerator extends Generator {
}
declare namespace CssGenerator {
    export { Source, Dependency, GenerateContext, UpdateHashContext, NormalModule, Hash };
}
import Generator = require("webpack/lib/Generator");
type Source = import("webpack-sources").Source;
type Dependency = import("../Dependency");
type GenerateContext = import("../Generator").GenerateContext;
type UpdateHashContext = import("../Generator").UpdateHashContext;
type NormalModule = import("../NormalModule");
type Hash = import("../util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/css/CssLoadingRuntimeModule.d.ts
export = CssLoadingRuntimeModule;
declare class CssLoadingRuntimeModule extends RuntimeModule {
    /**
     * @param {Compilation} compilation the compilation
     * @returns {JsonpCompilationPluginHooks} hooks
     */
    static getCompilationHooks(compilation: Compilation): JsonpCompilationPluginHooks;
    /**
     * @param {Set<string>} runtimeRequirements runtime requirements
     */
    constructor(runtimeRequirements: Set<string>);
    _runtimeRequirements: Set<string>;
}
declare namespace CssLoadingRuntimeModule {
    export { Chunk, ChunkGraph, RuntimeRequirementsContext, JsonpCompilationPluginHooks };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
import Compilation = require("webpack/lib/Compilation");
type JsonpCompilationPluginHooks = {
    createStylesheet: SyncWaterfallHook<[string, Chunk]>;
};
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type RuntimeRequirementsContext = import("../Compilation").RuntimeRequirementsContext;
import { SyncWaterfallHook } from "tapable";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/css/CssModulesPlugin.d.ts
export = CssModulesPlugin;
declare class CssModulesPlugin {
    /**
     * @param {Chunk} chunk chunk
     * @param {OutputOptions} outputOptions output options
     * @returns {Chunk["cssFilenameTemplate"] | OutputOptions["cssFilename"] | OutputOptions["cssChunkFilename"]} used filename template
     */
    static getChunkFilenameTemplate(chunk: Chunk, outputOptions: any): Chunk["cssFilenameTemplate"] | OutputOptions["cssFilename"] | OutputOptions["cssChunkFilename"];
    /**
     * @param {Chunk} chunk chunk
     * @param {ChunkGraph} chunkGraph chunk graph
     * @returns {boolean} true, when the chunk has css
     */
    static chunkHasCss(chunk: Chunk, chunkGraph: ChunkGraph): boolean;
    /**
     * @param {CssExperimentOptions} options options
     */
    constructor({ exportsOnly }: any);
    _exportsOnly: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
    /**
     * @param {Chunk} chunk chunk
     * @param {Iterable<Module>} modules unordered modules
     * @param {Compilation} compilation compilation
     * @returns {Module[]} ordered modules
     */
    getModulesInOrder(chunk: Chunk, modules: Iterable<Module>, compilation: Compilation): Module[];
    /**
     * @param {Chunk} chunk chunk
     * @param {ChunkGraph} chunkGraph chunk graph
     * @param {Compilation} compilation compilation
     * @returns {Module[]} ordered css modules
     */
    getOrderedChunkCssModules(chunk: Chunk, chunkGraph: ChunkGraph, compilation: Compilation): Module[];
    /**
     * @param {Object} options options
     * @param {string | undefined} options.uniqueName unique name
     * @param {Chunk} options.chunk chunk
     * @param {ChunkGraph} options.chunkGraph chunk graph
     * @param {CodeGenerationResults} options.codeGenerationResults code generation results
     * @param {CssModule[]} options.modules ordered css modules
     * @returns {Source} generated source
     */
    renderChunk({ uniqueName, chunk, chunkGraph, codeGenerationResults, modules }: {
        uniqueName: string | undefined;
        chunk: Chunk;
        chunkGraph: ChunkGraph;
        codeGenerationResults: CodeGenerationResults;
        modules: CssModule[];
    }): Source;
}
declare namespace CssModulesPlugin {
    export { Source, CssExperimentOptions, OutputOptions, Chunk, ChunkGraph, CodeGenerationResults, Compilation, Compiler, Module, Memoize };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");
type Module = import("../Module");
type Compilation = import("../Compilation");
type ChunkGraph = import("../ChunkGraph");
type CodeGenerationResults = import("../CodeGenerationResults");
import CssModule = require("webpack/lib/CssModule");
type Source = import("webpack-sources").Source;
type OutputOptions = any;
type CssExperimentOptions = any;
type Memoize = <T>(fn: memoize.FunctionReturning<T>) => memoize.FunctionReturning<T>;
import memoize = require("webpack/lib/util/memoize");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/css/CssParser.d.ts
export = CssParser;
declare class CssParser extends Parser {
    constructor({ allowModeSwitch, defaultMode }?: {
        allowModeSwitch?: boolean;
        defaultMode?: string;
    });
    allowModeSwitch: boolean;
    defaultMode: string;
    /**
     * @param {ParserState} state parser state
     * @param {string} message warning message
     * @param {LocConverter} locConverter location converter
     * @param {number} start start offset
     * @param {number} end end offset
     */
    _emitWarning(state: ParserState, message: string, locConverter: LocConverter, start: number, end: number): void;
}
declare namespace CssParser {
    export { ParserState, PreparsedAst, Range };
}
import Parser = require("webpack/lib/Parser");
type ParserState = import("../Parser").ParserState;
declare class LocConverter {
    /**
     * @param {string} input input
     */
    constructor(input: string);
    _input: string;
    line: number;
    column: number;
    pos: number;
    /**
     * @param {number} pos position
     * @returns {LocConverter} location converter
     */
    get(pos: number): LocConverter;
}
type PreparsedAst = import("../Parser").PreparsedAst;
type Range = [number, number];

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/css/walkCssTokens.d.ts
declare function _exports(input: string, callbacks: CssTokenCallbacks): void;
declare namespace _exports {
    export { isIdentStartCodePoint };
    export function eatComments(input: string, pos: number): number;
    export function eatWhitespace(input: string, pos: number): number;
    export function eatWhitespaceAndComments(input: string, pos: number): number;
    export function eatWhiteLine(input: string, pos: number): number;
    export { CssTokenCallbacks, CharHandler };
}
export = _exports;
export type CssTokenCallbacks = {
    isSelector?: ((arg0: string, arg1: number) => boolean) | undefined;
    url?: ((arg0: string, arg1: number, arg2: number, arg3: number, arg4: number) => number) | undefined;
    string?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    leftParenthesis?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    rightParenthesis?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    pseudoFunction?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    function?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    pseudoClass?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    atKeyword?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    class?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    identifier?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    id?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    leftCurlyBracket?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    rightCurlyBracket?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    semicolon?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
    comma?: ((arg0: string, arg1: number, arg2: number) => number) | undefined;
};
export type CharHandler = (arg0: string, arg1: number, arg2: CssTokenCallbacks) => number;
/**
 * ident-start code point
 *
 * A letter, a non-ASCII code point, or U+005F LOW LINE (_).
 *
 * @param {number} cc char code
 * @returns {boolean} true, if cc is a start code point of an identifier
 */
declare function isIdentStartCodePoint(cc: number): boolean;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/debug/ProfilingPlugin.d.ts
export = ProfilingPlugin;
declare class ProfilingPlugin {
    /**
     * @param {ProfilingPluginOptions=} options options object
     */
    constructor(options?: any);
    outputPath: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ProfilingPlugin {
    export { Profiler, ProfilingPluginOptions, Compiler, IntermediateFileSystem, Trace, PluginFunction };
}
type Compiler = import("../Compiler");
declare class Profiler {
    constructor(inspector: any);
    session: any;
    inspector: any;
    _startTime: number;
    hasSession(): boolean;
    startProfiling(): Promise<void> | Promise<[any, any, any]>;
    /**
     * @param {string} method method name
     * @param {object} [params] params
     * @returns {Promise<TODO>} Promise for the result
     */
    sendCommand(method: string, params?: object): Promise<TODO>;
    destroy(): Promise<void>;
    stopProfiling(): Promise<{
        profile: TODO;
    }>;
}
type ProfilingPluginOptions = any;
type IntermediateFileSystem = import("../util/fs").IntermediateFileSystem;
/**
 * an object that wraps Tracer and Profiler with a counter
 */
type Trace = {
    /**
     * instance of Tracer
     */
    trace: Tracer;
    /**
     * Counter
     */
    counter: number;
    /**
     * instance of Profiler
     */
    profiler: Profiler;
    /**
     * the end function
     */
    end: Function;
};
type PluginFunction = (...args: TODO[]) => void | Promise<TODO>;
import { Tracer } from "chrome-trace-event";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/AMDDefineDependency.d.ts
export = AMDDefineDependency;
declare class AMDDefineDependency extends NullDependency {
    /**
     * @param {Range} range range
     * @param {Range} arrayRange array range
     * @param {Range} functionRange function range
     * @param {Range} objectRange object range
     * @param {boolean} namedModule true, when define is called with a name
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range, arrayRange: import("webpack/lib/javascript/JavascriptParser").Range, functionRange: import("webpack/lib/javascript/JavascriptParser").Range, objectRange: import("webpack/lib/javascript/JavascriptParser").Range, namedModule: boolean);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    arrayRange: import("webpack/lib/javascript/JavascriptParser").Range;
    functionRange: import("webpack/lib/javascript/JavascriptParser").Range;
    objectRange: import("webpack/lib/javascript/JavascriptParser").Range;
    namedModule: boolean;
    localModule: any;
}
declare namespace AMDDefineDependency {
    export { AMDDefineDependencyTemplate as Template, ReplaceSource, Dependency, DependencyTemplateContext, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const AMDDefineDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class AMDDefineDependencyTemplate extends AMDDefineDependencyTemplate_base {
    /**
     * @param {AMDDefineDependency} dependency dependency
     * @returns {string} variable name
     */
    localModuleVar(dependency: AMDDefineDependency): string;
    /**
     * @param {AMDDefineDependency} dependency dependency
     * @returns {string} branch
     */
    branch(dependency: AMDDefineDependency): string;
    /**
     * @param {AMDDefineDependency} dependency dependency
     * @param {ReplaceSource} source source
     * @param {string} definition definition
     * @param {string} text text
     */
    replace(dependency: AMDDefineDependency, source: ReplaceSource, definition: string, text: string): void;
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/AMDDefineDependencyParserPlugin.d.ts
export = AMDDefineDependencyParserPlugin;
declare class AMDDefineDependencyParserPlugin {
    constructor(options: any);
    options: any;
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {void}
     */
    apply(parser: JavascriptParser): void;
    processArray(parser: any, expr: any, param: any, identifiers: any, namedModule: any): boolean;
    processItem(parser: any, expr: any, param: any, namedModule: any): boolean;
    processContext(parser: any, expr: any, param: any): boolean;
    processCallDefine(parser: any, expr: any): boolean;
    newDefineDependency(range: any, arrayRange: any, functionRange: any, objectRange: any, namedModule: any): AMDDefineDependency;
    newRequireArrayDependency(depsArray: any, range: any): AMDRequireArrayDependency;
    newRequireItemDependency(request: any, range: any): AMDRequireItemDependency;
}
declare namespace AMDDefineDependencyParserPlugin {
    export { CallExpression, JavascriptParser };
}
type JavascriptParser = import("../javascript/JavascriptParser");
import AMDDefineDependency = require("webpack/lib/dependencies/AMDDefineDependency");
import AMDRequireArrayDependency = require("webpack/lib/dependencies/AMDRequireArrayDependency");
import AMDRequireItemDependency = require("webpack/lib/dependencies/AMDRequireItemDependency");
type CallExpression = import("estree").CallExpression;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/AMDPlugin.d.ts
export = AMDPlugin;
declare class AMDPlugin {
    /**
     * @param {Record<string, any>} amdOptions the AMD options
     */
    constructor(amdOptions: Record<string, any>);
    amdOptions: Record<string, any>;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace AMDPlugin {
    export { JavascriptParserOptions, ModuleOptions, Compiler, Parser };
}
type Compiler = import("../Compiler");
type JavascriptParserOptions = any;
type ModuleOptions = any;
type Parser = import("../javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/AMDRequireArrayDependency.d.ts
export = AMDRequireArrayDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class AMDRequireArrayDependency extends NullDependency {
    /**
     * @param {TODO} depsArray deps array
     * @param {Range} range range
     */
    constructor(depsArray: TODO, range: import("webpack/lib/javascript/JavascriptParser").Range);
    depsArray: TODO;
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace AMDRequireArrayDependency {
    export { AMDRequireArrayDependencyTemplate as Template, ReplaceSource, Dependency, DependencyTemplateContext, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare class AMDRequireArrayDependencyTemplate extends DependencyTemplate {
    getContent(dep: any, templateContext: any): string;
    contentForDependency(dep: any, { runtimeTemplate, moduleGraph, chunkGraph, runtimeRequirements }: {
        runtimeTemplate: any;
        moduleGraph: any;
        chunkGraph: any;
        runtimeRequirements: any;
    }): any;
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
import DependencyTemplate = require("webpack/lib/DependencyTemplate");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/AMDRequireContextDependency.d.ts
export = AMDRequireContextDependency;
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class AMDRequireContextDependency extends ContextDependency {
    /**
     * @param {TODO} options options
     * @param {Range} range range
     * @param {Range} valueRange value range
     */
    constructor(options: TODO, range: import("webpack/lib/javascript/JavascriptParser").Range, valueRange: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    valueRange: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace AMDRequireContextDependency {
    export { Template, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import ContextDependency = require("webpack/lib/dependencies/ContextDependency");
declare var Template: typeof import("webpack/lib/dependencies/ContextDependencyTemplateAsRequireCall");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/AMDRequireDependenciesBlock.d.ts
export = AMDRequireDependenciesBlock;
/** @typedef {import("../Dependency").DependencyLocation} DependencyLocation */
declare class AMDRequireDependenciesBlock extends AsyncDependenciesBlock {
    /**
     * @param {DependencyLocation} loc location info
     * @param {string=} request request
     */
    constructor(loc: DependencyLocation, request?: string | undefined);
}
declare namespace AMDRequireDependenciesBlock {
    export { DependencyLocation };
}
import AsyncDependenciesBlock = require("webpack/lib/AsyncDependenciesBlock");
type DependencyLocation = import("../Dependency").DependencyLocation;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/AMDRequireDependenciesBlockParserPlugin.d.ts
export = AMDRequireDependenciesBlockParserPlugin;
/** @typedef {import("../javascript/JavascriptParser")} JavascriptParser */
declare class AMDRequireDependenciesBlockParserPlugin {
    constructor(options: any);
    options: any;
    processFunctionArgument(parser: any, expression: any): boolean;
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {void}
     */
    apply(parser: JavascriptParser): void;
    processArray(parser: any, expr: any, param: any): boolean;
    processItem(parser: any, expr: any, param: any): boolean;
    processContext(parser: any, expr: any, param: any): boolean;
    processArrayForRequestString(param: any): any;
    processItemForRequestString(param: any): any;
    processCallRequire(parser: any, expr: any): boolean;
    newRequireDependenciesBlock(loc: any, request: any): AMDRequireDependenciesBlock;
    newRequireDependency(outerRange: any, arrayRange: any, functionRange: any, errorCallbackRange: any): AMDRequireDependency;
    newRequireItemDependency(request: any, range: any): AMDRequireItemDependency;
    newRequireArrayDependency(depsArray: any, range: any): AMDRequireArrayDependency;
}
declare namespace AMDRequireDependenciesBlockParserPlugin {
    export { JavascriptParser };
}
type JavascriptParser = import("../javascript/JavascriptParser");
import AMDRequireDependenciesBlock = require("webpack/lib/dependencies/AMDRequireDependenciesBlock");
import AMDRequireDependency = require("webpack/lib/dependencies/AMDRequireDependency");
import AMDRequireItemDependency = require("webpack/lib/dependencies/AMDRequireItemDependency");
import AMDRequireArrayDependency = require("webpack/lib/dependencies/AMDRequireArrayDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/AMDRequireDependency.d.ts
export = AMDRequireDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../AsyncDependenciesBlock")} AsyncDependenciesBlock */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class AMDRequireDependency extends NullDependency {
    /**
     * @param {Range} outerRange outer range
     * @param {Range} arrayRange array range
     * @param {Range} functionRange function range
     * @param {Range} errorCallbackRange error callback range
     */
    constructor(outerRange: import("webpack/lib/javascript/JavascriptParser").Range, arrayRange: import("webpack/lib/javascript/JavascriptParser").Range, functionRange: import("webpack/lib/javascript/JavascriptParser").Range, errorCallbackRange: import("webpack/lib/javascript/JavascriptParser").Range);
    outerRange: import("webpack/lib/javascript/JavascriptParser").Range;
    arrayRange: import("webpack/lib/javascript/JavascriptParser").Range;
    functionRange: import("webpack/lib/javascript/JavascriptParser").Range;
    errorCallbackRange: import("webpack/lib/javascript/JavascriptParser").Range;
    functionBindThis: boolean;
    errorCallbackBindThis: boolean;
}
declare namespace AMDRequireDependency {
    export { AMDRequireDependencyTemplate as Template, ReplaceSource, AsyncDependenciesBlock, Dependency, DependencyTemplateContext, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const AMDRequireDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class AMDRequireDependencyTemplate extends AMDRequireDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type AsyncDependenciesBlock = import("../AsyncDependenciesBlock");
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/AMDRequireItemDependency.d.ts
export = AMDRequireItemDependency;
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
declare class AMDRequireItemDependency extends ModuleDependency {
    /**
     * @param {string} request the request string
     * @param {Range} range location in source code
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace AMDRequireItemDependency {
    export { ModuleDependencyTemplateAsRequireId as Template, Range };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
import ModuleDependencyTemplateAsRequireId = require("webpack/lib/dependencies/ModuleDependencyTemplateAsRequireId");
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/AMDRuntimeModules.d.ts
export class AMDDefineRuntimeModule extends RuntimeModule {
    constructor();
}
export class AMDOptionsRuntimeModule extends RuntimeModule {
    /**
     * @param {Record<string, boolean | number | string>} options the AMD options
     */
    constructor(options: Record<string, boolean | number | string>);
    options: Record<string, string | number | boolean>;
}
import RuntimeModule = require("webpack/lib/RuntimeModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CachedConstDependency.d.ts
export = CachedConstDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").UpdateHashContext} UpdateHashContext */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../DependencyTemplates")} DependencyTemplates */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/Hash")} Hash */
declare class CachedConstDependency extends NullDependency {
    /**
     * @param {string} expression expression
     * @param {Range} range range
     * @param {string} identifier identifier
     */
    constructor(expression: string, range: import("webpack/lib/javascript/JavascriptParser").Range, identifier: string);
    expression: string;
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    identifier: string;
    _hashUpdate: string;
}
declare namespace CachedConstDependency {
    export { CachedConstDependencyTemplate as Template, ReplaceSource, ChunkGraph, Dependency, UpdateHashContext, DependencyTemplateContext, DependencyTemplates, ModuleGraph, RuntimeTemplate, Range, ObjectDeserializerContext, ObjectSerializerContext, Hash };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare class CachedConstDependencyTemplate extends DependencyTemplate {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type Dependency = import("../Dependency");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type DependencyTemplates = import("../DependencyTemplates");
type ModuleGraph = import("../ModuleGraph");
type RuntimeTemplate = import("../RuntimeTemplate");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
import DependencyTemplate = require("webpack/lib/DependencyTemplate");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CommonJsDependencyHelpers.d.ts
export function handleDependencyBase(depBase: CommonJSDependencyBaseKeywords, module: Module, runtimeRequirements: Set<string>): [string, string];
export type Module = import("../Module");
export type CommonJSDependencyBaseKeywords = "exports" | "module.exports" | "this" | "Object.defineProperty(exports)" | "Object.defineProperty(module.exports)" | "Object.defineProperty(this)";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CommonJsExportRequireDependency.d.ts
export = CommonJsExportRequireDependency;
declare class CommonJsExportRequireDependency extends ModuleDependency {
    /**
     * @param {Range} range range
     * @param {Range} valueRange value range
     * @param {CommonJSDependencyBaseKeywords} base base
     * @param {string[]} names names
     * @param {string} request request
     * @param {string[]} ids ids
     * @param {boolean} resultUsed true, when the result is used
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range, valueRange: import("webpack/lib/javascript/JavascriptParser").Range, base: CommonJSDependencyBaseKeywords, names: string[], request: string, ids: string[], resultUsed: boolean);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    valueRange: import("webpack/lib/javascript/JavascriptParser").Range;
    base: import("webpack/lib/dependencies/CommonJsDependencyHelpers").CommonJSDependencyBaseKeywords;
    names: string[];
    ids: string[];
    resultUsed: boolean;
    asiSafe: any;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @returns {string[]} the imported id
     */
    getIds(moduleGraph: ModuleGraph): string[];
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {string[]} ids the imported ids
     * @returns {void}
     */
    setIds(moduleGraph: ModuleGraph, ids: string[]): void;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {RuntimeSpec} runtime the runtime
     * @param {Module} importedModule the imported module (optional)
     * @returns {{exports?: Set<string>, checked?: Set<string>}} information
     */
    getStarReexports(moduleGraph: ModuleGraph, runtime: RuntimeSpec, importedModule?: Module): {
        exports?: Set<string>;
        checked?: Set<string>;
    };
}
declare namespace CommonJsExportRequireDependency {
    export { CommonJsExportRequireDependencyTemplate as Template, ReplaceSource, ExportsSpec, ReferencedExport, TRANSITIVE, DependencyTemplateContext, Module, ModuleGraph, Range, ObjectDeserializerContext, ObjectSerializerContext, RuntimeSpec, CommonJSDependencyBaseKeywords };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
type ModuleGraph = import("../ModuleGraph");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
type Module = import("../Module");
type CommonJSDependencyBaseKeywords = import("./CommonJsDependencyHelpers").CommonJSDependencyBaseKeywords;
declare const CommonJsExportRequireDependencyTemplate_base: typeof import("webpack/lib/DependencyTemplate");
declare class CommonJsExportRequireDependencyTemplate extends CommonJsExportRequireDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ExportsSpec = import("../Dependency").ExportsSpec;
type ReferencedExport = import("../Dependency").ReferencedExport;
type TRANSITIVE = unique symbol;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CommonJsExportsDependency.d.ts
export = CommonJsExportsDependency;
declare class CommonJsExportsDependency extends NullDependency {
    /**
     * @param {Range} range range
     * @param {Range} valueRange value range
     * @param {CommonJSDependencyBaseKeywords} base base
     * @param {string[]} names names
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range, valueRange: import("webpack/lib/javascript/JavascriptParser").Range, base: CommonJSDependencyBaseKeywords, names: string[]);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    valueRange: import("webpack/lib/javascript/JavascriptParser").Range;
    base: import("webpack/lib/dependencies/CommonJsDependencyHelpers").CommonJSDependencyBaseKeywords;
    names: string[];
}
declare namespace CommonJsExportsDependency {
    export { CommonJsExportsDependencyTemplate as Template, ReplaceSource, Dependency, ExportsSpec, DependencyTemplateContext, ModuleGraph, Range, ObjectDeserializerContext, ObjectSerializerContext, CommonJSDependencyBaseKeywords };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
type CommonJSDependencyBaseKeywords = import("./CommonJsDependencyHelpers").CommonJSDependencyBaseKeywords;
declare const CommonJsExportsDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class CommonJsExportsDependencyTemplate extends CommonJsExportsDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type ExportsSpec = import("../Dependency").ExportsSpec;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CommonJsExportsParserPlugin.d.ts
export = CommonJsExportsParserPlugin;
declare class CommonJsExportsParserPlugin {
    /**
     * @param {ModuleGraph} moduleGraph module graph
     */
    constructor(moduleGraph: ModuleGraph);
    moduleGraph: import("webpack/lib/ModuleGraph");
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {void}
     */
    apply(parser: JavascriptParser): void;
}
declare namespace CommonJsExportsParserPlugin {
    export { AssignmentExpression, CallExpression, Expression, Super, ModuleGraph, NormalModule, BasicEvaluatedExpression, JavascriptParser, CommonJSDependencyBaseKeywords };
}
type JavascriptParser = import("../javascript/JavascriptParser");
type ModuleGraph = import("../ModuleGraph");
type AssignmentExpression = import("estree").AssignmentExpression;
type CallExpression = import("estree").CallExpression;
type Expression = import("estree").Expression;
type Super = import("estree").Super;
type NormalModule = import("../NormalModule");
type BasicEvaluatedExpression = import("../javascript/BasicEvaluatedExpression");
type CommonJSDependencyBaseKeywords = import("./CommonJsDependencyHelpers").CommonJSDependencyBaseKeywords;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CommonJsFullRequireDependency.d.ts
export = CommonJsFullRequireDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class CommonJsFullRequireDependency extends ModuleDependency {
    /**
     * @param {string} request the request string
     * @param {Range} range location in source code
     * @param {string[]} names accessed properties on module
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range, names: string[]);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    names: string[];
    call: boolean;
    asiSafe: any;
}
declare namespace CommonJsFullRequireDependency {
    export { CommonJsFullRequireDependencyTemplate as Template, ReplaceSource, Dependency, ReferencedExport, DependencyTemplateContext, ModuleGraph, Range, ObjectDeserializerContext, ObjectSerializerContext, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
declare const CommonJsFullRequireDependencyTemplate_base: typeof import("webpack/lib/DependencyTemplate");
declare class CommonJsFullRequireDependencyTemplate extends CommonJsFullRequireDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type ReferencedExport = import("../Dependency").ReferencedExport;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CommonJsImportsParserPlugin.d.ts
export = CommonJsImportsParserPlugin;
declare class CommonJsImportsParserPlugin {
    /**
     * @param {JavascriptParserOptions} options parser options
     */
    constructor(options: any);
    options: any;
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {void}
     */
    apply(parser: JavascriptParser): void;
}
declare namespace CommonJsImportsParserPlugin {
    export { CallExpression, Expression, NewExpression, JavascriptParserOptions, DependencyLocation, JavascriptParser, ImportSource, Range };
}
type JavascriptParser = import("../javascript/JavascriptParser");
type CallExpression = import("estree").CallExpression;
type Expression = import("estree").Expression;
type NewExpression = import("estree").NewExpression;
type JavascriptParserOptions = any;
type DependencyLocation = import("../Dependency").DependencyLocation;
type ImportSource = import("../javascript/JavascriptParser").ImportSource;
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CommonJsPlugin.d.ts
export = CommonJsPlugin;
declare class CommonJsPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace CommonJsPlugin {
    export { JavascriptParserOptions, Compilation, Compiler, DependencyLocation, BuildInfo, Parser };
}
type Compiler = import("../Compiler");
type JavascriptParserOptions = any;
type Compilation = import("../Compilation");
type DependencyLocation = import("../Dependency").DependencyLocation;
type BuildInfo = import("../Module").BuildInfo;
type Parser = import("../javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CommonJsRequireContextDependency.d.ts
export = CommonJsRequireContextDependency;
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class CommonJsRequireContextDependency extends ContextDependency {
    /**
     * @param {TODO} options options for the context module
     * @param {Range} range location in source code
     * @param {Range | undefined} valueRange location of the require call
     * @param {boolean | string } inShorthand true or name
     * @param {string} context context
     */
    constructor(options: TODO, range: import("webpack/lib/javascript/JavascriptParser").Range, valueRange: import("webpack/lib/javascript/JavascriptParser").Range | undefined, inShorthand: boolean | string, context: string);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    valueRange: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace CommonJsRequireContextDependency {
    export { ContextDependencyTemplateAsRequireCall as Template, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import ContextDependency = require("webpack/lib/dependencies/ContextDependency");
import ContextDependencyTemplateAsRequireCall = require("webpack/lib/dependencies/ContextDependencyTemplateAsRequireCall");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CommonJsRequireDependency.d.ts
export = CommonJsRequireDependency;
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
declare class CommonJsRequireDependency extends ModuleDependency {
    /**
     * @param {string} request request
     * @param {Range=} range location in source code
     * @param {string=} context request context
     */
    constructor(request: string, range?: import("webpack/lib/javascript/JavascriptParser").Range | undefined, context?: string | undefined);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    _context: string;
}
declare namespace CommonJsRequireDependency {
    export { ModuleDependencyTemplateAsId as Template, Range };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
import ModuleDependencyTemplateAsId = require("webpack/lib/dependencies/ModuleDependencyTemplateAsId");
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CommonJsSelfReferenceDependency.d.ts
export = CommonJsSelfReferenceDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").ExportsSpec} ExportsSpec */
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
/** @typedef {import("./CommonJsDependencyHelpers").CommonJSDependencyBaseKeywords} CommonJSDependencyBaseKeywords */
declare class CommonJsSelfReferenceDependency extends NullDependency {
    /**
     * @param {Range} range range
     * @param {CommonJSDependencyBaseKeywords} base base
     * @param {string[]} names names
     * @param {boolean} call is a call
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range, base: CommonJSDependencyBaseKeywords, names: string[], call: boolean);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    base: import("webpack/lib/dependencies/CommonJsDependencyHelpers").CommonJSDependencyBaseKeywords;
    names: string[];
    call: boolean;
}
declare namespace CommonJsSelfReferenceDependency {
    export { CommonJsSelfReferenceDependencyTemplate as Template, ReplaceSource, Dependency, ExportsSpec, ReferencedExport, DependencyTemplateContext, ModuleGraph, Range, ObjectDeserializerContext, ObjectSerializerContext, RuntimeSpec, CommonJSDependencyBaseKeywords };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
type CommonJSDependencyBaseKeywords = import("./CommonJsDependencyHelpers").CommonJSDependencyBaseKeywords;
declare const CommonJsSelfReferenceDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class CommonJsSelfReferenceDependencyTemplate extends CommonJsSelfReferenceDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type ExportsSpec = import("../Dependency").ExportsSpec;
type ReferencedExport = import("../Dependency").ReferencedExport;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ConstDependency.d.ts
export = ConstDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").UpdateHashContext} UpdateHashContext */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../ModuleGraphConnection").ConnectionState} ConnectionState */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/Hash")} Hash */
declare class ConstDependency extends NullDependency {
    /**
     * @param {string} expression the expression
     * @param {number | Range} range the source range
     * @param {(string[] | null)=} runtimeRequirements runtime requirements
     */
    constructor(expression: string, range: number | import("webpack/lib/javascript/JavascriptParser").Range, runtimeRequirements?: (string[] | null) | undefined);
    expression: string;
    range: number | import("webpack/lib/javascript/JavascriptParser").Range;
    runtimeRequirements: Set<string>;
    _hashUpdate: string;
}
declare namespace ConstDependency {
    export { ConstDependencyTemplate as Template, ReplaceSource, ChunkGraph, Dependency, UpdateHashContext, DependencyTemplateContext, ModuleGraph, ConnectionState, Range, ObjectDeserializerContext, ObjectSerializerContext, Hash };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const ConstDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class ConstDependencyTemplate extends ConstDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type Dependency = import("../Dependency");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ContextDependency.d.ts
export = ContextDependency;
declare class ContextDependency extends Dependency {
    /**
     * @param {ContextDependencyOptions} options options for the context module
     * @param {string=} context request context
     */
    constructor(options: ContextDependencyOptions, context?: string | undefined);
    options: ContextDependencyOptions;
    userRequest: string;
    /** @type {false | undefined | string} */
    critical: false | undefined | string;
    hadGlobalOrStickyRegExp: boolean;
    request: any;
    range: any;
    valueRange: any;
    /** @type {boolean | string | undefined} */
    inShorthand: boolean | string | undefined;
    replaces: any;
    _requestContext: string;
    prepend: any;
}
declare namespace ContextDependency {
    export { DependencyTemplate as Template, ContextOptions, TRANSITIVE, ModuleGraph, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, ContextDependencyOptions };
}
import Dependency = require("webpack/lib/Dependency");
type ContextDependencyOptions = ContextOptions & {
    request: string;
};
import DependencyTemplate = require("webpack/lib/DependencyTemplate");
type ContextOptions = import("../ContextModule").ContextOptions;
type TRANSITIVE = unique symbol;
type ModuleGraph = import("../ModuleGraph");
type WebpackError = import("../WebpackError");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ContextDependencyHelpers.d.ts
export function create(Dep: ContextDependencyConstructor, range: import("webpack/lib/javascript/JavascriptParser").Range, param: BasicEvaluatedExpression, expr: EsTreeNode, options: Pick<JavascriptParserOptions, `${"expr" | "wrapped"}Context${"Critical" | "Recursive" | "RegExp"}` | "exprContextRequest">, contextOptions: PartialContextDependencyOptions, parser: JavascriptParser, ...depArgs: any[]): ContextDependency;
export type EsTreeNode = import("estree").Node;
export type JavascriptParserOptions = any;
export type ModuleOptions = any;
export type BasicEvaluatedExpression = import("../javascript/BasicEvaluatedExpression");
export type JavascriptParser = import("../javascript/JavascriptParser");
export type ContextDependency = import("./ContextDependency");
export type ContextDependencyOptions = import("./ContextDependency").ContextDependencyOptions;
export type PartialContextDependencyOptions = Partial<Omit<ContextDependencyOptions, "resource">>;
export type Range = import("../javascript/JavascriptParser").Range;
export type ContextDependencyConstructor = new (options: ContextDependencyOptions, range: import("webpack/lib/javascript/JavascriptParser").Range, valueRange: [number, number], ...args: any[]) => ContextDependency;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ContextDependencyTemplateAsId.d.ts
export = ContextDependencyTemplateAsId;
declare const ContextDependencyTemplateAsId_base: typeof import("webpack/lib/DependencyTemplate");
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
declare class ContextDependencyTemplateAsId extends ContextDependencyTemplateAsId_base {
}
declare namespace ContextDependencyTemplateAsId {
    export { ReplaceSource, Dependency, DependencyTemplateContext };
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ContextDependencyTemplateAsRequireCall.d.ts
export = ContextDependencyTemplateAsRequireCall;
declare const ContextDependencyTemplateAsRequireCall_base: typeof import("webpack/lib/DependencyTemplate");
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
declare class ContextDependencyTemplateAsRequireCall extends ContextDependencyTemplateAsRequireCall_base {
}
declare namespace ContextDependencyTemplateAsRequireCall {
    export { ReplaceSource, Dependency, DependencyTemplateContext };
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ContextElementDependency.d.ts
export = ContextElementDependency;
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class ContextElementDependency extends ModuleDependency {
    /**
     * @param {string} request request
     * @param {string|undefined} userRequest user request
     * @param {string} typePrefix type prefix
     * @param {string} category category
     * @param {string[][]=} referencedExports referenced exports
     * @param {string=} context context
     */
    constructor(request: string, userRequest: string | undefined, typePrefix: string, category: string, referencedExports?: string[][] | undefined, context?: string | undefined);
    referencedExports: string[][];
    _typePrefix: string;
    _category: string;
    _context: string;
}
declare namespace ContextElementDependency {
    export { ReferencedExport, ModuleGraph, ObjectDeserializerContext, ObjectSerializerContext, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
type ReferencedExport = import("../Dependency").ReferencedExport;
type ModuleGraph = import("../ModuleGraph");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CreateScriptUrlDependency.d.ts
export = CreateScriptUrlDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class CreateScriptUrlDependency extends NullDependency {
    /**
     * @param {Range} range range
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace CreateScriptUrlDependency {
    export { CreateScriptUrlDependencyTemplate as Template, ReplaceSource, Dependency, DependencyTemplateContext, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const CreateScriptUrlDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class CreateScriptUrlDependencyTemplate extends CreateScriptUrlDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CriticalDependencyWarning.d.ts
export = CriticalDependencyWarning;
declare class CriticalDependencyWarning extends WebpackError {
    /**
     * @param {string} message message
     */
    constructor(message: string);
}
import WebpackError = require("webpack/lib/WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CssExportDependency.d.ts
export = CssExportDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").ExportsSpec} ExportsSpec */
/** @typedef {import("../DependencyTemplate").CssDependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class CssExportDependency extends NullDependency {
    /**
     * @param {string} name name
     * @param {string} value value
     */
    constructor(name: string, value: string);
    name: string;
    value: string;
}
declare namespace CssExportDependency {
    export { CssExportDependencyTemplate as Template, ReplaceSource, Dependency, ExportsSpec, DependencyTemplateContext, ModuleGraph, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const CssExportDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class CssExportDependencyTemplate extends CssExportDependencyTemplate_base {
    /**
     * @param {Dependency} dependency the dependency for which the template should be applied
     * @param {ReplaceSource} source the current replace source which can be modified
     * @param {DependencyTemplateContext} templateContext the context object
     * @returns {void}
     */
    apply(dependency: Dependency, source: ReplaceSource, { cssExports }: DependencyTemplateContext): void;
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type ExportsSpec = import("../Dependency").ExportsSpec;
type DependencyTemplateContext = import("../DependencyTemplate").CssDependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CssImportDependency.d.ts
export = CssImportDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").UpdateHashContext} UpdateHashContext */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../ModuleGraphConnection")} ModuleGraphConnection */
/** @typedef {import("../ModuleGraphConnection").ConnectionState} ConnectionState */
/** @typedef {import("../css/CssParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/Hash")} Hash */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class CssImportDependency extends ModuleDependency {
    /**
     * Example of dependency:
     *
     * \@import url("landscape.css") layer(forms) screen and (orientation: landscape) screen and (orientation: landscape);
     *
     * @param {string} request request
     * @param {Range} range range of the argument
     * @param {string | undefined} layer layer
     * @param {string | undefined} supports list of supports conditions
     * @param {string | undefined} media list of media conditions
     */
    constructor(request: string, range: import("webpack/lib/css/CssParser").Range, layer: string | undefined, supports: string | undefined, media: string | undefined);
    range: import("webpack/lib/css/CssParser").Range;
    layer: string;
    supports: string;
    media: string;
}
declare namespace CssImportDependency {
    export { CssImportDependencyTemplate as Template, ReplaceSource, ChunkGraph, Dependency, UpdateHashContext, DependencyTemplateContext, Module, ModuleGraph, ModuleGraphConnection, ConnectionState, Range, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
declare const CssImportDependencyTemplate_base: typeof import("webpack/lib/DependencyTemplate");
declare class CssImportDependencyTemplate extends CssImportDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type Dependency = import("../Dependency");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Module = import("../Module");
type ModuleGraph = import("../ModuleGraph");
type ModuleGraphConnection = import("../ModuleGraphConnection");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type Range = import("../css/CssParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CssLocalIdentifierDependency.d.ts
export = CssLocalIdentifierDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").ExportsSpec} ExportsSpec */
/** @typedef {import("../DependencyTemplate").CssDependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../css/CssParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class CssLocalIdentifierDependency extends NullDependency {
    /**
     * @param {string} name name
     * @param {Range} range range
     * @param {string=} prefix prefix
     */
    constructor(name: string, range: import("webpack/lib/css/CssParser").Range, prefix?: string | undefined);
    name: string;
    range: import("webpack/lib/css/CssParser").Range;
    prefix: string;
}
declare namespace CssLocalIdentifierDependency {
    export { CssLocalIdentifierDependencyTemplate as Template, ReplaceSource, Dependency, ExportsSpec, DependencyTemplateContext, ModuleGraph, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const CssLocalIdentifierDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class CssLocalIdentifierDependencyTemplate extends CssLocalIdentifierDependencyTemplate_base {
    /**
     * @param {Dependency} dependency the dependency for which the template should be applied
     * @param {ReplaceSource} source the current replace source which can be modified
     * @param {DependencyTemplateContext} templateContext the context object
     * @returns {void}
     */
    apply(dependency: Dependency, source: ReplaceSource, { module, moduleGraph, chunkGraph, runtime, runtimeTemplate, cssExports }: DependencyTemplateContext): void;
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type ExportsSpec = import("../Dependency").ExportsSpec;
type DependencyTemplateContext = import("../DependencyTemplate").CssDependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type Range = import("../css/CssParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CssSelfLocalIdentifierDependency.d.ts
export = CssSelfLocalIdentifierDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency").ExportsSpec} ExportsSpec */
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../DependencyTemplate").CssDependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../css/CssParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class CssSelfLocalIdentifierDependency extends CssLocalIdentifierDependency {
    /**
     * @param {string} name name
     * @param {Range} range range
     * @param {string=} prefix prefix
     * @param {Set<string>=} declaredSet set of declared names (will only be active when in declared set)
     */
    constructor(name: string, range: import("webpack/lib/css/CssParser").Range, prefix?: string | undefined, declaredSet?: Set<string> | undefined);
    declaredSet: Set<string>;
}
declare namespace CssSelfLocalIdentifierDependency {
    export { CssSelfLocalIdentifierDependencyTemplate as Template, ReplaceSource, ExportsSpec, ReferencedExport, DependencyTemplateContext, ModuleGraph, Range, ObjectDeserializerContext, ObjectSerializerContext, RuntimeSpec };
}
import CssLocalIdentifierDependency = require("webpack/lib/dependencies/CssLocalIdentifierDependency");
declare const CssSelfLocalIdentifierDependencyTemplate_base: {
    new (): {
        apply(dependency: Dependency, source: import("webpack-sources/lib/ReplaceSource"), { module, moduleGraph, chunkGraph, runtime, runtimeTemplate, cssExports }: import("webpack/lib/DependencyTemplate").CssDependencyTemplateContext): void;
    };
};
declare class CssSelfLocalIdentifierDependencyTemplate extends CssSelfLocalIdentifierDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ExportsSpec = import("../Dependency").ExportsSpec;
type ReferencedExport = import("../Dependency").ReferencedExport;
type DependencyTemplateContext = import("../DependencyTemplate").CssDependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type Range = import("../css/CssParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
import Dependency = require("webpack/lib/Dependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/CssUrlDependency.d.ts
export = CssUrlDependency;
declare class CssUrlDependency extends ModuleDependency {
    /**
     * @param {string} request request
     * @param {Range} range range of the argument
     * @param {"string" | "url"} urlType dependency type e.g. url() or string
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range, urlType: "string" | "url");
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    urlType: "string" | "url";
}
declare namespace CssUrlDependency {
    export { CssUrlDependencyTemplate as Template, ReplaceSource, ChunkGraph, Dependency, UpdateHashContext, DependencyTemplateContext, Module, ModuleGraph, ModuleGraphConnection, ConnectionState, Range, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
declare const CssUrlDependencyTemplate_base: typeof import("webpack/lib/DependencyTemplate");
declare class CssUrlDependencyTemplate extends CssUrlDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type Dependency = import("../Dependency");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Module = import("../Module");
type ModuleGraph = import("../ModuleGraph");
type ModuleGraphConnection = import("../ModuleGraphConnection");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/DelegatedSourceDependency.d.ts
export = DelegatedSourceDependency;
declare class DelegatedSourceDependency extends ModuleDependency {
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/DllEntryDependency.d.ts
export = DllEntryDependency;
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("./EntryDependency")} EntryDependency */
declare class DllEntryDependency extends Dependency {
    /**
     * @param {EntryDependency[]} dependencies dependencies
     * @param {string} name name
     */
    constructor(dependencies: EntryDependency[], name: string);
    dependencies: import("webpack/lib/dependencies/EntryDependency")[];
    name: string;
}
declare namespace DllEntryDependency {
    export { ObjectDeserializerContext, ObjectSerializerContext, EntryDependency };
}
import Dependency = require("webpack/lib/Dependency");
type EntryDependency = import("./EntryDependency");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/DynamicExports.d.ts
export function bailout(parserState: ParserState): void;
export function enable(parserState: ParserState): void;
export function setFlagged(parserState: ParserState): void;
export function setDynamic(parserState: ParserState): void;
export function isEnabled(parserState: ParserState): boolean;
export type BuildMeta = import("../Module").BuildMeta;
export type ParserState = import("../Parser").ParserState;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/EntryDependency.d.ts
export = EntryDependency;
declare class EntryDependency extends ModuleDependency {
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ExportsInfoDependency.d.ts
export = ExportsInfoDependency;
declare class ExportsInfoDependency extends NullDependency {
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {ExportsInfoDependency} ExportsInfoDependency
     */
    static deserialize(context: ObjectDeserializerContext): ExportsInfoDependency;
    /**
     * @param {Range} range range
     * @param {TODO} exportName export name
     * @param {string | null} property property
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range, exportName: TODO, property: string | null);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    exportName: TODO;
    property: string;
}
declare namespace ExportsInfoDependency {
    export { ExportsInfoDependencyTemplate as Template, ReplaceSource, ChunkGraph, Dependency, UpdateHashContext, DependencyTemplateContext, Module, ModuleGraph, Range, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeSpec };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
declare const ExportsInfoDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class ExportsInfoDependencyTemplate extends ExportsInfoDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type Dependency = import("../Dependency");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Module = import("../Module");
type ModuleGraph = import("../ModuleGraph");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyAcceptDependency.d.ts
export = HarmonyAcceptDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("./HarmonyAcceptImportDependency")} HarmonyAcceptImportDependency */
declare class HarmonyAcceptDependency extends NullDependency {
    /**
     * @param {Range} range expression range
     * @param {HarmonyAcceptImportDependency[]} dependencies import dependencies
     * @param {boolean} hasCallback true, if the range wraps an existing callback
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range, dependencies: HarmonyAcceptImportDependency[], hasCallback: boolean);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    dependencies: import("webpack/lib/dependencies/HarmonyAcceptImportDependency")[];
    hasCallback: boolean;
}
declare namespace HarmonyAcceptDependency {
    export { HarmonyAcceptDependencyTemplate as Template, ReplaceSource, Dependency, DependencyTemplateContext, Range, ObjectDeserializerContext, ObjectSerializerContext, HarmonyAcceptImportDependency };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
type HarmonyAcceptImportDependency = import("./HarmonyAcceptImportDependency");
declare const HarmonyAcceptDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class HarmonyAcceptDependencyTemplate extends HarmonyAcceptDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyAcceptImportDependency.d.ts
export = HarmonyAcceptImportDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
declare class HarmonyAcceptImportDependency extends HarmonyImportDependency {
    /**
     * @param {string} request the request string
     */
    constructor(request: string);
}
declare namespace HarmonyAcceptImportDependency {
    export { Template, ReplaceSource, Dependency, DependencyTemplateContext };
}
import HarmonyImportDependency = require("webpack/lib/dependencies/HarmonyImportDependency");
declare var Template: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
    getImportEmittedRuntime(module: import("webpack/lib/Module"), referencedModule: import("webpack/lib/Module")): boolean | import("webpack/lib/util/runtime").RuntimeSpec;
};
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyCompatibilityDependency.d.ts
export = HarmonyCompatibilityDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../Module").BuildMeta} BuildMeta */
declare class HarmonyCompatibilityDependency extends NullDependency {
}
declare namespace HarmonyCompatibilityDependency {
    export { HarmonyExportDependencyTemplate as Template, ReplaceSource, Dependency, DependencyTemplateContext, Module, BuildMeta };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const HarmonyExportDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class HarmonyExportDependencyTemplate extends HarmonyExportDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Module = import("../Module");
type BuildMeta = import("../Module").BuildMeta;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyDetectionParserPlugin.d.ts
export = HarmonyDetectionParserPlugin;
declare class HarmonyDetectionParserPlugin {
    /**
     * @param {HarmonyModulesPluginOptions} options options
     */
    constructor(options: HarmonyModulesPluginOptions);
    topLevelAwait: boolean;
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {void}
     */
    apply(parser: JavascriptParser): void;
}
declare namespace HarmonyDetectionParserPlugin {
    export { BuildMeta, JavascriptParser, HarmonyModulesPluginOptions };
}
type JavascriptParser = import("../javascript/JavascriptParser");
type HarmonyModulesPluginOptions = import("./HarmonyModulesPlugin").HarmonyModulesPluginOptions;
type BuildMeta = import("../Module").BuildMeta;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyEvaluatedImportSpecifierDependency.d.ts
export = HarmonyEvaluatedImportSpecifierDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../Module").BuildMeta} BuildMeta */
/** @typedef {import("../ModuleGraphConnection")} ModuleGraphConnection */
/** @typedef {import("../javascript/JavascriptParser").Assertions} Assertions */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/**
 * Dependency for static evaluating import specifier. e.g.
 * @example
 * import a from "a";
 * "x" in a;
 * a.x !== undefined; // if x value statically analyzable
 */
declare class HarmonyEvaluatedImportSpecifierDependency extends HarmonyImportSpecifierDependency {
    /**
     * @param {string} request the request string
     * @param {number} sourceOrder source order
     * @param {TODO} ids ids
     * @param {TODO} name name
     * @param {Range} range location in source code
     * @param {Assertions} assertions assertions
     * @param {string} operator operator
     */
    constructor(request: string, sourceOrder: number, ids: TODO, name: TODO, range: import("webpack/lib/javascript/JavascriptParser").Range, assertions: Assertions, operator: string);
    operator: string;
}
declare namespace HarmonyEvaluatedImportSpecifierDependency {
    export { HarmonyEvaluatedImportSpecifierDependencyTemplate as Template, ReplaceSource, ChunkGraph, Dependency, DependencyTemplateContext, BuildMeta, ModuleGraphConnection, Assertions, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import HarmonyImportSpecifierDependency = require("webpack/lib/dependencies/HarmonyImportSpecifierDependency");
type Assertions = import("../javascript/JavascriptParser").Assertions;
declare const HarmonyEvaluatedImportSpecifierDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
        _trimIdsToThoseImported(ids: string[], moduleGraph: import("webpack/lib/ModuleGraph"), dependency: HarmonyImportSpecifierDependency): string[];
        _getCodeForIds(dep: HarmonyImportSpecifierDependency, source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext, ids: string[]): string;
    };
    getImportEmittedRuntime(module: import("webpack/lib/Module"), referencedModule: import("webpack/lib/Module")): boolean | import("webpack/lib/util/runtime").RuntimeSpec;
};
declare class HarmonyEvaluatedImportSpecifierDependencyTemplate extends HarmonyEvaluatedImportSpecifierDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type BuildMeta = import("../Module").BuildMeta;
type ModuleGraphConnection = import("../ModuleGraphConnection");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyExportDependencyParserPlugin.d.ts
export = HarmonyExportDependencyParserPlugin;
declare class HarmonyExportDependencyParserPlugin {
    /**
     * @param {import("../../declarations/WebpackOptions").JavascriptParserOptions} options options
     */
    constructor(options: any);
    exportPresenceMode: 0 | 2 | 1 | 3;
    apply(parser: any): void;
}
declare namespace HarmonyExportDependencyParserPlugin {
    export { JavascriptParser };
}
type JavascriptParser = import("../javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyExportExpressionDependency.d.ts
export = HarmonyExportExpressionDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").ExportsSpec} ExportsSpec */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../ModuleGraphConnection").ConnectionState} ConnectionState */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class HarmonyExportExpressionDependency extends NullDependency {
    /**
     * @param {Range} range range
     * @param {Range} rangeStatement range statement
     * @param {string} prefix prefix
     * @param {string | { range: Range, prefix: string, suffix: string }} [declarationId] declaration id
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range, rangeStatement: import("webpack/lib/javascript/JavascriptParser").Range, prefix: string, declarationId?: string | {
        range: import("webpack/lib/javascript/JavascriptParser").Range;
        prefix: string;
        suffix: string;
    });
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    rangeStatement: import("webpack/lib/javascript/JavascriptParser").Range;
    prefix: string;
    declarationId: string | {
        range: import("webpack/lib/javascript/JavascriptParser").Range;
        prefix: string;
        suffix: string;
    };
}
declare namespace HarmonyExportExpressionDependency {
    export { HarmonyExportDependencyTemplate as Template, ReplaceSource, Dependency, ExportsSpec, DependencyTemplateContext, ModuleGraph, ConnectionState, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const HarmonyExportDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class HarmonyExportDependencyTemplate extends HarmonyExportDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type ExportsSpec = import("../Dependency").ExportsSpec;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyExportHeaderDependency.d.ts
export = HarmonyExportHeaderDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class HarmonyExportHeaderDependency extends NullDependency {
    /**
     * @param {Range} range range
     * @param {Range} rangeStatement range statement
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range, rangeStatement: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    rangeStatement: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace HarmonyExportHeaderDependency {
    export { HarmonyExportDependencyTemplate as Template, ReplaceSource, Dependency, DependencyTemplateContext, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const HarmonyExportDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class HarmonyExportDependencyTemplate extends HarmonyExportDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency.d.ts
export = HarmonyExportImportedSpecifierDependency;
declare class HarmonyExportImportedSpecifierDependency extends HarmonyImportDependency {
    /**
     * @param {string} request the request string
     * @param {number} sourceOrder the order in the original source file
     * @param {string[]} ids the requested export name of the imported module
     * @param {string | null} name the export name of for this module
     * @param {Set<string>} activeExports other named exports in the module
     * @param {ReadonlyArray<HarmonyExportImportedSpecifierDependency> | Iterable<HarmonyExportImportedSpecifierDependency> | null} otherStarExports other star exports in the module before this import
     * @param {number} exportPresenceMode mode of checking export names
     * @param {HarmonyStarExportsList | null} allStarExports all star exports in the module
     * @param {Assertions=} assertions import assertions
     */
    constructor(request: string, sourceOrder: number, ids: string[], name: string | null, activeExports: Set<string>, otherStarExports: ReadonlyArray<HarmonyExportImportedSpecifierDependency> | Iterable<HarmonyExportImportedSpecifierDependency> | null, exportPresenceMode: number, allStarExports: HarmonyStarExportsList | null, assertions?: Assertions | undefined);
    ids: string[];
    name: string;
    activeExports: Set<string>;
    otherStarExports: readonly HarmonyExportImportedSpecifierDependency[] | Iterable<HarmonyExportImportedSpecifierDependency>;
    exportPresenceMode: number;
    allStarExports: HarmonyStarExportsList;
    get id(): void;
    getId(): void;
    setId(): void;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @returns {string[]} the imported id
     */
    getIds(moduleGraph: ModuleGraph): string[];
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {string[]} ids the imported ids
     * @returns {void}
     */
    setIds(moduleGraph: ModuleGraph, ids: string[]): void;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {RuntimeSpec} runtime the runtime
     * @returns {ExportMode} the export mode
     */
    getMode(moduleGraph: ModuleGraph, runtime: RuntimeSpec): ExportMode;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {RuntimeSpec} runtime the runtime
     * @param {ExportsInfo} exportsInfo exports info about the current module (optional)
     * @param {Module} importedModule the imported module (optional)
     * @returns {{exports?: Set<string>, checked?: Set<string>, ignoredExports: Set<string>, hidden?: Set<string>}} information
     */
    getStarReexports(moduleGraph: ModuleGraph, runtime: RuntimeSpec, exportsInfo?: ExportsInfo, importedModule?: Module): {
        exports?: Set<string>;
        checked?: Set<string>;
        ignoredExports: Set<string>;
        hidden?: Set<string>;
    };
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @returns {{ names: string[], namesSlice: number, dependencyIndices: number[], dependencyIndex: number } | undefined} exported names and their origin dependency
     */
    _discoverActiveExportsFromOtherStarExports(moduleGraph: ModuleGraph): {
        names: string[];
        namesSlice: number;
        dependencyIndices: number[];
        dependencyIndex: number;
    };
    /**
     * @param {ModuleGraph} moduleGraph module graph
     * @returns {number} effective mode
     */
    _getEffectiveExportPresenceLevel(moduleGraph: ModuleGraph): number;
    /**
     * @param {ModuleGraph} moduleGraph module graph
     * @returns {WebpackError[] | undefined} errors
     */
    _getErrors(moduleGraph: ModuleGraph): WebpackError[] | undefined;
}
declare namespace HarmonyExportImportedSpecifierDependency {
    export { HarmonyExportImportedSpecifierDependencyTemplate as Template, HarmonyStarExportsList, ReplaceSource, ChunkGraph, ExportsSpec, ReferencedExport, TRANSITIVE, UpdateHashContext, DependencyTemplateContext, ExportsInfo, ExportInfo, Module, ModuleGraph, ModuleGraphConnection, ConnectionState, RuntimeTemplate, WebpackError, Assertions, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeSpec, ExportModeType };
}
import HarmonyImportDependency = require("webpack/lib/dependencies/HarmonyImportDependency");
declare class HarmonyStarExportsList {
    /** @type {HarmonyExportImportedSpecifierDependency[]} */
    dependencies: HarmonyExportImportedSpecifierDependency[];
    /**
     * @param {HarmonyExportImportedSpecifierDependency} dep dependency
     * @returns {void}
     */
    push(dep: HarmonyExportImportedSpecifierDependency): void;
    slice(): HarmonyExportImportedSpecifierDependency[];
    /**
     * @param {ObjectSerializerContext} context context
     */
    serialize({ write, setCircularReference }: ObjectSerializerContext): void;
    /**
     * @param {ObjectDeserializerContext} context context
     */
    deserialize({ read, setCircularReference }: ObjectDeserializerContext): void;
}
type ModuleGraph = import("../ModuleGraph");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
declare class ExportMode {
    /**
     * @param {ExportModeType} type type of the mode
     */
    constructor(type: ExportModeType);
    /** @type {ExportModeType} */
    type: ExportModeType;
    /** @type {NormalReexportItem[] | null} */
    items: NormalReexportItem[] | null;
    /** @type {string|null} */
    name: string | null;
    /** @type {ExportInfo | null} */
    partialNamespaceExportInfo: ExportInfo | null;
    /** @type {Set<string> | null} */
    ignored: Set<string> | null;
    /** @type {Set<string> | null} */
    hidden: Set<string> | null;
    /** @type {string | null} */
    userRequest: string | null;
    /** @type {number} */
    fakeType: number;
}
type ExportsInfo = import("../ExportsInfo");
type Module = import("../Module");
type WebpackError = import("../WebpackError");
type Assertions = import("../javascript/JavascriptParser").Assertions;
declare const HarmonyExportImportedSpecifierDependencyTemplate_base: {
    new (): {
        apply(dependency: Dependency, source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
    getImportEmittedRuntime(module: import("webpack/lib/Module"), referencedModule: import("webpack/lib/Module")): boolean | import("webpack/lib/util/runtime").RuntimeSpec;
};
declare class HarmonyExportImportedSpecifierDependencyTemplate extends HarmonyExportImportedSpecifierDependencyTemplate_base {
    /**
     * @param {InitFragment[]} initFragments target array for init fragments
     * @param {HarmonyExportImportedSpecifierDependency} dep dependency
     * @param {ExportMode} mode the export mode
     * @param {Module} module the current module
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {RuntimeSpec} runtime the runtime
     * @param {RuntimeTemplate} runtimeTemplate the runtime template
     * @param {Set<string>} runtimeRequirements runtime requirements
     * @returns {void}
     */
    _addExportFragments(initFragments: InitFragment<any>[], dep: HarmonyExportImportedSpecifierDependency, mode: ExportMode, module: Module, moduleGraph: ModuleGraph, runtime: RuntimeSpec, runtimeTemplate: RuntimeTemplate, runtimeRequirements: Set<string>): void;
    getReexportFragment(module: any, comment: any, key: any, name: any, valueKey: any, runtimeRequirements: any): HarmonyExportInitFragment;
    getReexportFakeNamespaceObjectFragments(module: any, key: any, name: any, fakeType: any, runtimeRequirements: any): InitFragment<any>[];
    getConditionalReexportStatement(module: any, key: any, name: any, valueKey: any, runtimeRequirements: any): string;
    getReturnValue(name: any, valueKey: any): any;
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type ExportsSpec = import("../Dependency").ExportsSpec;
type ReferencedExport = import("../Dependency").ReferencedExport;
type TRANSITIVE = import("../Dependency").TRANSITIVE;
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ExportInfo = import("../ExportsInfo").ExportInfo;
type ModuleGraphConnection = import("../ModuleGraphConnection");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type RuntimeTemplate = import("../RuntimeTemplate");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type ExportModeType = "missing" | "unused" | "empty-star" | "reexport-dynamic-default" | "reexport-named-default" | "reexport-namespace-object" | "reexport-fake-namespace-object" | "reexport-undefined" | "normal-reexport" | "dynamic-reexport";
declare class NormalReexportItem {
    /**
     * @param {string} name export name
     * @param {string[]} ids reexported ids from other module
     * @param {ExportInfo} exportInfo export info from other module
     * @param {boolean} checked true, if it should be checked at runtime if this export exists
     * @param {boolean} hidden true, if it is hidden behind another active export in the same module
     */
    constructor(name: string, ids: string[], exportInfo: ExportInfo, checked: boolean, hidden: boolean);
    name: string;
    ids: string[];
    exportInfo: import("webpack/lib/ExportsInfo").ExportInfo;
    checked: boolean;
    hidden: boolean;
}
import Dependency = require("webpack/lib/Dependency");
import InitFragment = require("webpack/lib/InitFragment");
import HarmonyExportInitFragment = require("webpack/lib/dependencies/HarmonyExportInitFragment");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyExportInitFragment.d.ts
export = HarmonyExportInitFragment;
/**
 * @typedef {GenerateContext} Context
 */
declare class HarmonyExportInitFragment extends InitFragment<any> {
    /**
     * @param {string} exportsArgument the exports identifier
     * @param {Map<string, string>} exportMap mapping from used name to exposed variable name
     * @param {Set<string>} unusedExports list of unused export names
     */
    constructor(exportsArgument: string, exportMap?: Map<string, string>, unusedExports?: Set<string>);
    exportsArgument: string;
    exportMap: Map<string, string>;
    unusedExports: Set<string>;
    /**
     * @param {HarmonyExportInitFragment[]} fragments all fragments to merge
     * @returns {HarmonyExportInitFragment} merged fragment
     */
    mergeAll(fragments: HarmonyExportInitFragment[]): HarmonyExportInitFragment;
    merge(other: any): HarmonyExportInitFragment;
    /**
     * @param {Context} context context
     * @returns {string|Source} the source code that will be included as initialization code
     */
    getContent({ runtimeTemplate, runtimeRequirements }: Context): string | Source;
}
declare namespace HarmonyExportInitFragment {
    export { Source, GenerateContext, Context };
}
import InitFragment = require("webpack/lib/InitFragment");
type Context = GenerateContext;
type Source = import("webpack-sources").Source;
type GenerateContext = import("../Generator").GenerateContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyExportSpecifierDependency.d.ts
export = HarmonyExportSpecifierDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").ExportsSpec} ExportsSpec */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../ModuleGraphConnection").ConnectionState} ConnectionState */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class HarmonyExportSpecifierDependency extends NullDependency {
    /**
     * @param {TODO} id id
     * @param {TODO} name name
     */
    constructor(id: TODO, name: TODO);
    id: TODO;
    name: TODO;
}
declare namespace HarmonyExportSpecifierDependency {
    export { HarmonyExportSpecifierDependencyTemplate as Template, ReplaceSource, Dependency, ExportsSpec, DependencyTemplateContext, ModuleGraph, ConnectionState, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const HarmonyExportSpecifierDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class HarmonyExportSpecifierDependencyTemplate extends HarmonyExportSpecifierDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type ExportsSpec = import("../Dependency").ExportsSpec;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyExports.d.ts
export function enable(parserState: ParserState, isStrictHarmony: boolean): void;
export function isEnabled(parserState: ParserState): boolean;
export type BuildInfo = import("../Module").BuildInfo;
export type BuildMeta = import("../Module").BuildMeta;
export type ParserState = import("../Parser").ParserState;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyImportDependency.d.ts
export = HarmonyImportDependency;
declare class HarmonyImportDependency extends ModuleDependency {
    /**
     *
     * @param {string} request request string
     * @param {number} sourceOrder source order
     * @param {Assertions=} assertions import assertions
     */
    constructor(request: string, sourceOrder: number, assertions?: Assertions | undefined);
    sourceOrder: number;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @returns {string} name of the variable for the import
     */
    getImportVar(moduleGraph: ModuleGraph): string;
    /**
     * @param {boolean} update create new variables or update existing one
     * @param {DependencyTemplateContext} templateContext the template context
     * @returns {[string, string]} the import statement and the compat statement
     */
    getImportStatement(update: boolean, { runtimeTemplate, module, moduleGraph, chunkGraph, runtimeRequirements }: DependencyTemplateContext): [string, string];
    /**
     * @param {ModuleGraph} moduleGraph module graph
     * @param {string[]} ids imported ids
     * @param {string} additionalMessage extra info included in the error message
     * @returns {WebpackError[] | undefined} errors
     */
    getLinkingErrors(moduleGraph: ModuleGraph, ids: string[], additionalMessage: string): WebpackError[] | undefined;
}
declare namespace HarmonyImportDependency {
    export { HarmonyImportDependencyTemplate as Template, ExportPresenceModes, ReplaceSource, Source, ChunkGraph, ReferencedExport, UpdateHashContext, DependencyTemplateContext, Module, ModuleGraph, RuntimeTemplate, WebpackError, Assertions, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
type ModuleGraph = import("../ModuleGraph");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type WebpackError = import("../WebpackError");
type Assertions = import("../javascript/JavascriptParser").Assertions;
declare const HarmonyImportDependencyTemplate_base: typeof import("webpack/lib/DependencyTemplate");
declare class HarmonyImportDependencyTemplate extends HarmonyImportDependencyTemplate_base {
    /**
     *
     * @param {Module} module the module
     * @param {Module} referencedModule the referenced module
     * @returns {RuntimeSpec | boolean} runtimeCondition in which this import has been emitted
     */
    static getImportEmittedRuntime(module: Module, referencedModule: Module): RuntimeSpec | boolean;
}
declare namespace ExportPresenceModes {
    let NONE: 0;
    let WARN: 1;
    let AUTO: 2;
    let ERROR: 3;
    function fromUserOption(str: any): 0 | 2 | 1 | 3;
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Source = import("webpack-sources").Source;
type ChunkGraph = import("../ChunkGraph");
type ReferencedExport = import("../Dependency").ReferencedExport;
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type Module = import("../Module");
type RuntimeTemplate = import("../RuntimeTemplate");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyImportDependencyParserPlugin.d.ts
export = HarmonyImportDependencyParserPlugin;
declare class HarmonyImportDependencyParserPlugin {
    /**
     * @param {JavascriptParserOptions} options options
     */
    constructor(options: any);
    exportPresenceMode: 0 | 2 | 1 | 3;
    strictThisContextOnImports: any;
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {void}
     */
    apply(parser: JavascriptParser): void;
}
declare namespace HarmonyImportDependencyParserPlugin {
    export { harmonySpecifierTag, getAssertions, HarmonySettings, ExportAllDeclaration, ExportNamedDeclaration, Identifier, ImportDeclaration, ImportExpression, MemberExpression, JavascriptParserOptions, DependencyLocation, BasicEvaluatedExpression, JavascriptParser, Range, InnerGraph, TopLevelSymbol, HarmonyImportDependency };
}
type JavascriptParser = import("../javascript/JavascriptParser");
/** @typedef {import("estree").ExportAllDeclaration} ExportAllDeclaration */
/** @typedef {import("estree").ExportNamedDeclaration} ExportNamedDeclaration */
/** @typedef {import("estree").Identifier} Identifier */
/** @typedef {import("estree").ImportDeclaration} ImportDeclaration */
/** @typedef {import("estree").ImportExpression} ImportExpression */
/** @typedef {import("estree").MemberExpression} MemberExpression */
/** @typedef {import("../../declarations/WebpackOptions").JavascriptParserOptions} JavascriptParserOptions */
/** @typedef {import("../Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("../javascript/BasicEvaluatedExpression")} BasicEvaluatedExpression */
/** @typedef {import("../javascript/JavascriptParser")} JavascriptParser */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../optimize/InnerGraph").InnerGraph} InnerGraph */
/** @typedef {import("../optimize/InnerGraph").TopLevelSymbol} TopLevelSymbol */
/** @typedef {import("./HarmonyImportDependency")} HarmonyImportDependency */
declare const harmonySpecifierTag: unique symbol;
/**
 * @typedef {Object} HarmonySettings
 * @property {string[]} ids
 * @property {string} source
 * @property {number} sourceOrder
 * @property {string} name
 * @property {boolean} await
 * @property {Record<string, any> | undefined} assertions
 */
/**
 * @param {ImportDeclaration | ExportNamedDeclaration | ExportAllDeclaration | ImportExpression} node node with assertions
 * @returns {Record<string, any> | undefined} assertions
 */
declare function getAssertions(node: ImportDeclaration | ExportNamedDeclaration | ExportAllDeclaration | ImportExpression): Record<string, any> | undefined;
type HarmonySettings = {
    ids: string[];
    source: string;
    sourceOrder: number;
    name: string;
    await: boolean;
    assertions: Record<string, any> | undefined;
};
type ExportAllDeclaration = import("estree").ExportAllDeclaration;
type ExportNamedDeclaration = import("estree").ExportNamedDeclaration;
type Identifier = import("estree").Identifier;
type ImportDeclaration = import("estree").ImportDeclaration;
type ImportExpression = import("estree").ImportExpression;
type MemberExpression = import("estree").MemberExpression;
type JavascriptParserOptions = any;
type DependencyLocation = import("../Dependency").DependencyLocation;
type BasicEvaluatedExpression = import("../javascript/BasicEvaluatedExpression");
type Range = import("../javascript/JavascriptParser").Range;
type InnerGraph = import("../optimize/InnerGraph").InnerGraph;
type TopLevelSymbol = import("../optimize/InnerGraph").TopLevelSymbol;
type HarmonyImportDependency = import("./HarmonyImportDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyImportSideEffectDependency.d.ts
export = HarmonyImportSideEffectDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../ModuleGraphConnection")} ModuleGraphConnection */
/** @typedef {import("../ModuleGraphConnection").ConnectionState} ConnectionState */
/** @typedef {import("../javascript/JavascriptParser").Assertions} Assertions */
/** @typedef {import("../util/Hash")} Hash */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class HarmonyImportSideEffectDependency extends HarmonyImportDependency {
    /**
     * @param {TODO} request the request string
     * @param {number} sourceOrder source order
     * @param {Assertions=} assertions assertions
     */
    constructor(request: TODO, sourceOrder: number, assertions?: Assertions | undefined);
}
declare namespace HarmonyImportSideEffectDependency {
    export { HarmonyImportSideEffectDependencyTemplate as Template, ReplaceSource, Dependency, DependencyTemplateContext, Module, ModuleGraph, ModuleGraphConnection, ConnectionState, Assertions, Hash, RuntimeSpec };
}
import HarmonyImportDependency = require("webpack/lib/dependencies/HarmonyImportDependency");
type Assertions = import("../javascript/JavascriptParser").Assertions;
declare const HarmonyImportSideEffectDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
    getImportEmittedRuntime(module: import("webpack/lib/Module"), referencedModule: import("webpack/lib/Module")): boolean | import("webpack/lib/util/runtime").RuntimeSpec;
};
declare class HarmonyImportSideEffectDependencyTemplate extends HarmonyImportSideEffectDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Module = import("../Module");
type ModuleGraph = import("../ModuleGraph");
type ModuleGraphConnection = import("../ModuleGraphConnection");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type Hash = import("../util/Hash");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyImportSpecifierDependency.d.ts
export = HarmonyImportSpecifierDependency;
declare class HarmonyImportSpecifierDependency extends HarmonyImportDependency {
    /**
     * @param {TODO} request request
     * @param {number} sourceOrder source order
     * @param {string[]} ids ids
     * @param {string} name name
     * @param {Range} range range
     * @param {TODO} exportPresenceMode export presence mode
     * @param {Assertions=} assertions assertions
     * @param {Range[]=} idRanges ranges for members of ids; the two arrays are right-aligned
     */
    constructor(request: TODO, sourceOrder: number, ids: string[], name: string, range: import("webpack/lib/javascript/JavascriptParser").Range, exportPresenceMode: TODO, assertions?: Assertions | undefined, idRanges?: import("webpack/lib/javascript/JavascriptParser").Range[] | undefined);
    ids: string[];
    name: string;
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    idRanges: import("webpack/lib/javascript/JavascriptParser").Range[];
    exportPresenceMode: TODO;
    /** @type {boolean | undefined} */
    namespaceObjectAsContext: boolean | undefined;
    call: any;
    directImport: any;
    shorthand: any;
    asiSafe: any;
    /** @type {Set<string> | boolean | undefined} */
    usedByExports: Set<string> | boolean | undefined;
    /** @type {Set<string> | undefined} */
    referencedPropertiesInDestructuring: Set<string> | undefined;
    get id(): void;
    getId(): void;
    setId(): void;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @returns {string[]} the imported ids
     */
    getIds(moduleGraph: ModuleGraph): string[];
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {string[]} ids the imported ids
     * @returns {void}
     */
    setIds(moduleGraph: ModuleGraph, ids: string[]): void;
    /**
     * @param {string[]=} ids ids
     * @returns {(string[] | ReferencedExport)[]} referenced exports
     */
    _getReferencedExportsInDestructuring(ids?: string[] | undefined): (string[] | ReferencedExport)[];
    /**
     * @param {ModuleGraph} moduleGraph module graph
     * @returns {number} effective mode
     */
    _getEffectiveExportPresenceLevel(moduleGraph: ModuleGraph): number;
    /**
     * @param {ModuleGraph} moduleGraph module graph
     * @returns {WebpackError[] | undefined} errors
     */
    _getErrors(moduleGraph: ModuleGraph): WebpackError[] | undefined;
}
declare namespace HarmonyImportSpecifierDependency {
    export { HarmonyImportSpecifierDependencyTemplate as Template, ReplaceSource, ChunkGraph, ExportsSpec, ReferencedExport, UpdateHashContext, DependencyTemplateContext, Module, BuildMeta, ModuleGraph, ModuleGraphConnection, ConnectionState, WebpackError, Assertions, Range, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeSpec };
}
import HarmonyImportDependency = require("webpack/lib/dependencies/HarmonyImportDependency");
type ModuleGraph = import("../ModuleGraph");
type ReferencedExport = import("../Dependency").ReferencedExport;
type WebpackError = import("../WebpackError");
type Assertions = import("../javascript/JavascriptParser").Assertions;
declare const HarmonyImportSpecifierDependencyTemplate_base: {
    new (): {
        apply(dependency: Dependency, source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
    getImportEmittedRuntime(module: import("webpack/lib/Module"), referencedModule: import("webpack/lib/Module")): boolean | import("webpack/lib/util/runtime").RuntimeSpec;
};
declare class HarmonyImportSpecifierDependencyTemplate extends HarmonyImportSpecifierDependencyTemplate_base {
    /**
     * @summary Determine which IDs in the id chain are actually referring to namespaces or imports,
     * and which are deeper member accessors on the imported object.  Only the former should be re-rendered.
     * @param {string[]} ids ids
     * @param {ModuleGraph} moduleGraph moduleGraph
     * @param {HarmonyImportSpecifierDependency} dependency dependency
     * @returns {string[]} generated code
     */
    _trimIdsToThoseImported(ids: string[], moduleGraph: ModuleGraph, dependency: HarmonyImportSpecifierDependency): string[];
    /**
     * @param {HarmonyImportSpecifierDependency} dep dependency
     * @param {ReplaceSource} source source
     * @param {DependencyTemplateContext} templateContext context
     * @param {string[]} ids ids
     * @returns {string} generated code
     */
    _getCodeForIds(dep: HarmonyImportSpecifierDependency, source: ReplaceSource, templateContext: DependencyTemplateContext, ids: string[]): string;
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type ExportsSpec = import("../Dependency").ExportsSpec;
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Module = import("../Module");
type BuildMeta = import("../Module").BuildMeta;
type ModuleGraphConnection = import("../ModuleGraphConnection");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
import Dependency = require("webpack/lib/Dependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyModulesPlugin.d.ts
export = HarmonyModulesPlugin;
/** @typedef {{ topLevelAwait?: boolean }} HarmonyModulesPluginOptions */
declare class HarmonyModulesPlugin {
    /**
     * @param {HarmonyModulesPluginOptions} options options
     */
    constructor(options: HarmonyModulesPluginOptions);
    options: HarmonyModulesPluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace HarmonyModulesPlugin {
    export { JavascriptParserOptions, Compiler, Parser, HarmonyModulesPluginOptions };
}
type HarmonyModulesPluginOptions = {
    topLevelAwait?: boolean;
};
type Compiler = import("../Compiler");
type JavascriptParserOptions = any;
type Parser = import("../javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/HarmonyTopLevelThisParserPlugin.d.ts
export = HarmonyTopLevelThisParserPlugin;
/** @typedef {import("../Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("../javascript/JavascriptParser")} JavascriptParser */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
declare class HarmonyTopLevelThisParserPlugin {
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {void}
     */
    apply(parser: JavascriptParser): void;
}
declare namespace HarmonyTopLevelThisParserPlugin {
    export { DependencyLocation, JavascriptParser, Range };
}
type JavascriptParser = import("../javascript/JavascriptParser");
type DependencyLocation = import("../Dependency").DependencyLocation;
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportContextDependency.d.ts
export = ImportContextDependency;
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class ImportContextDependency extends ContextDependency {
    /**
     * @param {TODO} options options
     * @param {Range} range range
     * @param {Range} valueRange value range
     */
    constructor(options: TODO, range: import("webpack/lib/javascript/JavascriptParser").Range, valueRange: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    valueRange: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace ImportContextDependency {
    export { ContextDependencyTemplateAsRequireCall as Template, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import ContextDependency = require("webpack/lib/dependencies/ContextDependency");
import ContextDependencyTemplateAsRequireCall = require("webpack/lib/dependencies/ContextDependencyTemplateAsRequireCall");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportDependency.d.ts
export = ImportDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../AsyncDependenciesBlock")} AsyncDependenciesBlock */
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../Module").BuildMeta} BuildMeta */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class ImportDependency extends ModuleDependency {
    /**
     * @param {string} request the request
     * @param {Range} range expression range
     * @param {(string[][] | null)=} referencedExports list of referenced exports
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range, referencedExports?: (string[][] | null) | undefined);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    referencedExports: string[][];
}
declare namespace ImportDependency {
    export { ImportDependencyTemplate as Template, ReplaceSource, AsyncDependenciesBlock, ReferencedExport, DependencyTemplateContext, Module, BuildMeta, ModuleGraph, Range, ObjectDeserializerContext, ObjectSerializerContext, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
declare const ImportDependencyTemplate_base: typeof import("webpack/lib/DependencyTemplate");
declare class ImportDependencyTemplate extends ImportDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type AsyncDependenciesBlock = import("../AsyncDependenciesBlock");
type ReferencedExport = import("../Dependency").ReferencedExport;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Module = import("../Module");
type BuildMeta = import("../Module").BuildMeta;
type ModuleGraph = import("../ModuleGraph");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportEagerDependency.d.ts
export = ImportEagerDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../Module").BuildMeta} BuildMeta */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
declare class ImportEagerDependency extends ImportDependency {
}
declare namespace ImportEagerDependency {
    export { ImportEagerDependencyTemplate as Template, ReplaceSource, Dependency, ReferencedExport, DependencyTemplateContext, Module, BuildMeta, ModuleGraph, Range };
}
import ImportDependency = require("webpack/lib/dependencies/ImportDependency");
declare const ImportEagerDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), { runtimeTemplate, module, moduleGraph, chunkGraph, runtimeRequirements }: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class ImportEagerDependencyTemplate extends ImportEagerDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type ReferencedExport = import("../Dependency").ReferencedExport;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Module = import("../Module");
type BuildMeta = import("../Module").BuildMeta;
type ModuleGraph = import("../ModuleGraph");
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportMetaContextDependency.d.ts
export = ImportMetaContextDependency;
declare class ImportMetaContextDependency extends ContextDependency {
    constructor(options: any, range: any);
}
declare namespace ImportMetaContextDependency {
    export { ModuleDependencyTemplateAsRequireId as Template };
}
import ContextDependency = require("webpack/lib/dependencies/ContextDependency");
import ModuleDependencyTemplateAsRequireId = require("webpack/lib/dependencies/ModuleDependencyTemplateAsRequireId");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportMetaContextDependencyParserPlugin.d.ts
export = ImportMetaContextDependencyParserPlugin;
declare class ImportMetaContextDependencyParserPlugin {
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {void}
     */
    apply(parser: JavascriptParser): void;
}
declare namespace ImportMetaContextDependencyParserPlugin {
    export { Expression, ObjectExpression, Property, SourceLocation, JavascriptParser, ContextModuleOptions, RawChunkGroupOptions, ImportMetaContextOptions };
}
type JavascriptParser = import("../javascript/JavascriptParser");
type Expression = import("estree").Expression;
type ObjectExpression = import("estree").ObjectExpression;
type Property = import("estree").Property;
type SourceLocation = import("estree").SourceLocation;
type ContextModuleOptions = import("../ContextModule").ContextModuleOptions;
type RawChunkGroupOptions = import("../ChunkGroup").RawChunkGroupOptions;
type ImportMetaContextOptions = Pick<import("webpack/lib/ContextModule").ContextModuleOptions, "include" | "recursive" | "regExp" | "exclude" | "chunkName" | "mode"> & {
    groupOptions: RawChunkGroupOptions;
    exports?: ContextModuleOptions["referencedExports"];
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportMetaContextPlugin.d.ts
export = ImportMetaContextPlugin;
declare class ImportMetaContextPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ImportMetaContextPlugin {
    export { JavascriptParserOptions, ResolveOptions, Compiler, Parser };
}
type Compiler = import("../Compiler");
type JavascriptParserOptions = any;
type ResolveOptions = any;
type Parser = import("../javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportMetaHotAcceptDependency.d.ts
export = ImportMetaHotAcceptDependency;
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
declare class ImportMetaHotAcceptDependency extends ModuleDependency {
    /**
     * @param {string} request the request string
     * @param {Range} range location in source code
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace ImportMetaHotAcceptDependency {
    export { ModuleDependencyTemplateAsId as Template, Range };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
import ModuleDependencyTemplateAsId = require("webpack/lib/dependencies/ModuleDependencyTemplateAsId");
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportMetaHotDeclineDependency.d.ts
export = ImportMetaHotDeclineDependency;
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
declare class ImportMetaHotDeclineDependency extends ModuleDependency {
    /**
     * @param {string} request the request string
     * @param {Range} range location in source code
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace ImportMetaHotDeclineDependency {
    export { ModuleDependencyTemplateAsId as Template, Range };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
import ModuleDependencyTemplateAsId = require("webpack/lib/dependencies/ModuleDependencyTemplateAsId");
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportMetaPlugin.d.ts
export = ImportMetaPlugin;
declare class ImportMetaPlugin {
    /**
     * @param {Compiler} compiler compiler
     */
    apply(compiler: Compiler): void;
}
declare namespace ImportMetaPlugin {
    export { MemberExpression, JavascriptParserOptions, Compiler, DependencyLocation, NormalModule, Parser, Range };
}
type Compiler = import("../Compiler");
type MemberExpression = import("estree").MemberExpression;
type JavascriptParserOptions = any;
type DependencyLocation = import("../Dependency").DependencyLocation;
type NormalModule = import("../NormalModule");
type Parser = import("../javascript/JavascriptParser");
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportParserPlugin.d.ts
export = ImportParserPlugin;
/** @typedef {import("../../declarations/WebpackOptions").JavascriptParserOptions} JavascriptParserOptions */
/** @typedef {import("../ChunkGroup").RawChunkGroupOptions} RawChunkGroupOptions */
/** @typedef {import("../ContextModule").ContextMode} ContextMode */
/** @typedef {import("../Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("../Module").BuildMeta} BuildMeta */
/** @typedef {import("../javascript/JavascriptParser")} JavascriptParser */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
declare class ImportParserPlugin {
    /**
     * @param {JavascriptParserOptions} options options
     */
    constructor(options: any);
    options: any;
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {void}
     */
    apply(parser: JavascriptParser): void;
}
declare namespace ImportParserPlugin {
    export { JavascriptParserOptions, RawChunkGroupOptions, ContextMode, DependencyLocation, BuildMeta, JavascriptParser, Range };
}
type JavascriptParser = import("../javascript/JavascriptParser");
type JavascriptParserOptions = any;
type RawChunkGroupOptions = import("../ChunkGroup").RawChunkGroupOptions;
type ContextMode = import("../ContextModule").ContextMode;
type DependencyLocation = import("../Dependency").DependencyLocation;
type BuildMeta = import("../Module").BuildMeta;
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportPlugin.d.ts
export = ImportPlugin;
declare class ImportPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ImportPlugin {
    export { JavascriptParserOptions, Compiler, Parser };
}
type Compiler = import("../Compiler");
type JavascriptParserOptions = any;
type Parser = import("../javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ImportWeakDependency.d.ts
export = ImportWeakDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../Module").BuildMeta} BuildMeta */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
declare class ImportWeakDependency extends ImportDependency {
}
declare namespace ImportWeakDependency {
    export { ImportDependencyTemplate as Template, ReplaceSource, Dependency, ReferencedExport, DependencyTemplateContext, Module, BuildMeta, ModuleGraph, Range };
}
import ImportDependency = require("webpack/lib/dependencies/ImportDependency");
declare const ImportDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), { runtimeTemplate, module, moduleGraph, chunkGraph, runtimeRequirements }: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class ImportDependencyTemplate extends ImportDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type ReferencedExport = import("../Dependency").ReferencedExport;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Module = import("../Module");
type BuildMeta = import("../Module").BuildMeta;
type ModuleGraph = import("../ModuleGraph");
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/JsonExportsDependency.d.ts
export = JsonExportsDependency;
declare class JsonExportsDependency extends NullDependency {
    /**
     * @param {JsonData} data json data
     */
    constructor(data: JsonData);
    data: import("webpack/lib/json/JsonData");
}
declare namespace JsonExportsDependency {
    export { ChunkGraph, ExportSpec, ExportsSpec, UpdateHashContext, ModuleGraph, JsonData, ObjectDeserializerContext, ObjectSerializerContext, Hash };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
type JsonData = import("../json/JsonData");
type ChunkGraph = import("../ChunkGraph");
type ExportSpec = import("../Dependency").ExportSpec;
type ExportsSpec = import("../Dependency").ExportsSpec;
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type ModuleGraph = import("../ModuleGraph");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/LoaderDependency.d.ts
export = LoaderDependency;
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../ModuleGraphConnection")} ModuleGraphConnection */
/** @typedef {import("../ModuleGraphConnection").ConnectionState} ConnectionState */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class LoaderDependency extends ModuleDependency {
}
declare namespace LoaderDependency {
    export { ModuleGraph, ModuleGraphConnection, ConnectionState, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
type ModuleGraph = import("../ModuleGraph");
type ModuleGraphConnection = import("../ModuleGraphConnection");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/LoaderImportDependency.d.ts
export = LoaderImportDependency;
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../ModuleGraphConnection")} ModuleGraphConnection */
/** @typedef {import("../ModuleGraphConnection").ConnectionState} ConnectionState */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class LoaderImportDependency extends ModuleDependency {
}
declare namespace LoaderImportDependency {
    export { ModuleGraph, ModuleGraphConnection, ConnectionState, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
type ModuleGraph = import("../ModuleGraph");
type ModuleGraphConnection = import("../ModuleGraphConnection");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/LoaderPlugin.d.ts
export = LoaderPlugin;
/** @typedef {import("../Compilation").DepConstructor} DepConstructor */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
/**
 * @callback LoadModuleCallback
 * @param {(Error | null)=} err error object
 * @param {string | Buffer=} source source code
 * @param {object=} map source map
 * @param {Module=} module loaded module if successful
 */
/**
 * @callback ImportModuleCallback
 * @param {(Error | null)=} err error object
 * @param {any=} exports exports of the evaluated module
 */
/**
 * @typedef {Object} ImportModuleOptions
 * @property {string=} layer the target layer
 * @property {string=} publicPath the target public path
 * @property {string=} baseUri target base uri
 */
declare class LoaderPlugin {
    /**
     * @param {Object} options options
     */
    constructor(options?: any);
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace LoaderPlugin {
    export { DepConstructor, Compiler, Module, LoadModuleCallback, ImportModuleCallback, ImportModuleOptions };
}
type Compiler = import("../Compiler");
type DepConstructor = import("../Compilation").DepConstructor;
type Module = import("../Module");
type LoadModuleCallback = (err?: (Error | null) | undefined, source?: (string | Buffer) | undefined, map?: object | undefined, module?: Module | undefined) => any;
type ImportModuleCallback = (err?: (Error | null) | undefined, exports?: any | undefined) => any;
type ImportModuleOptions = {
    /**
     * the target layer
     */
    layer?: string | undefined;
    /**
     * the target public path
     */
    publicPath?: string | undefined;
    /**
     * target base uri
     */
    baseUri?: string | undefined;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/LocalModule.d.ts
export = LocalModule;
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class LocalModule {
    /**
     * @param {string} name name
     * @param {number} idx index
     */
    constructor(name: string, idx: number);
    name: string;
    idx: number;
    used: boolean;
    flagUsed(): void;
    /**
     * @returns {string} variable name
     */
    variableName(): string;
    /**
     * @param {ObjectSerializerContext} context context
     */
    serialize(context: ObjectSerializerContext): void;
    /**
     * @param {ObjectDeserializerContext} context context
     */
    deserialize(context: ObjectDeserializerContext): void;
}
declare namespace LocalModule {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/LocalModuleDependency.d.ts
export = LocalModuleDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("./LocalModule")} LocalModule */
declare class LocalModuleDependency extends NullDependency {
    /**
     * @param {LocalModule} localModule local module
     * @param {Range} range range
     * @param {boolean} callNew true, when the local module should be called with new
     */
    constructor(localModule: LocalModule, range: import("webpack/lib/javascript/JavascriptParser").Range, callNew: boolean);
    localModule: import("webpack/lib/dependencies/LocalModule");
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    callNew: boolean;
}
declare namespace LocalModuleDependency {
    export { LocalModuleDependencyTemplate as Template, ReplaceSource, Dependency, DependencyTemplateContext, Range, ObjectDeserializerContext, ObjectSerializerContext, LocalModule };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
type LocalModule = import("./LocalModule");
declare const LocalModuleDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class LocalModuleDependencyTemplate extends LocalModuleDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/LocalModulesHelpers.d.ts
export function addLocalModule(state: ParserState, name: string): LocalModule;
export function getLocalModule(state: ParserState, name: string, namedModule?: string): LocalModule | null;
export type ParserState = import("../javascript/JavascriptParser").ParserState;
import LocalModule = require("webpack/lib/dependencies/LocalModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ModuleDecoratorDependency.d.ts
export = ModuleDecoratorDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../Dependency").UpdateHashContext} UpdateHashContext */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../DependencyTemplates")} DependencyTemplates */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/Hash")} Hash */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class ModuleDecoratorDependency extends NullDependency {
    /**
     * @param {string} decorator the decorator requirement
     * @param {boolean} allowExportsAccess allow to access exports from module
     */
    constructor(decorator: string, allowExportsAccess: boolean);
    decorator: string;
    allowExportsAccess: boolean;
    _hashUpdate: string;
}
declare namespace ModuleDecoratorDependency {
    export { ModuleDecoratorDependencyTemplate as Template, ReplaceSource, ChunkGraph, ReferencedExport, UpdateHashContext, DependencyTemplateContext, DependencyTemplates, ModuleGraph, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeSpec };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const ModuleDecoratorDependencyTemplate_base: {
    new (): {
        apply(dependency: Dependency, source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class ModuleDecoratorDependencyTemplate extends ModuleDecoratorDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type ReferencedExport = import("../Dependency").ReferencedExport;
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type DependencyTemplates = import("../DependencyTemplates");
type ModuleGraph = import("../ModuleGraph");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
import Dependency = require("webpack/lib/Dependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ModuleDependency.d.ts
export = ModuleDependency;
declare class ModuleDependency extends Dependency {
    /**
     * @param {string} request request path which needs resolving
     */
    constructor(request: string);
    request: string;
    userRequest: string;
    range: any;
    /** @type {Record<string, any> | undefined} */
    assertions: Record<string, any> | undefined;
    _context: any;
}
declare namespace ModuleDependency {
    export { DependencyTemplate as Template, TRANSITIVE, Module, ObjectDeserializerContext, ObjectSerializerContext };
}
import Dependency = require("webpack/lib/Dependency");
import DependencyTemplate = require("webpack/lib/DependencyTemplate");
type TRANSITIVE = unique symbol;
type Module = import("../Module");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ModuleDependencyTemplateAsId.d.ts
export = ModuleDependencyTemplateAsId;
declare const ModuleDependencyTemplateAsId_base: typeof import("webpack/lib/DependencyTemplate");
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../Module")} Module */
declare class ModuleDependencyTemplateAsId extends ModuleDependencyTemplateAsId_base {
}
declare namespace ModuleDependencyTemplateAsId {
    export { ReplaceSource, Dependency, DependencyTemplateContext, Module };
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ModuleDependencyTemplateAsRequireId.d.ts
export = ModuleDependencyTemplateAsRequireId;
declare const ModuleDependencyTemplateAsRequireId_base: typeof import("webpack/lib/DependencyTemplate");
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
declare class ModuleDependencyTemplateAsRequireId extends ModuleDependencyTemplateAsRequireId_base {
}
declare namespace ModuleDependencyTemplateAsRequireId {
    export { ReplaceSource, Dependency, DependencyTemplateContext };
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ModuleHotAcceptDependency.d.ts
export = ModuleHotAcceptDependency;
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
declare class ModuleHotAcceptDependency extends ModuleDependency {
    /**
     * @param {string} request the request string
     * @param {Range} range location in source code
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace ModuleHotAcceptDependency {
    export { ModuleDependencyTemplateAsId as Template, Range };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
import ModuleDependencyTemplateAsId = require("webpack/lib/dependencies/ModuleDependencyTemplateAsId");
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ModuleHotDeclineDependency.d.ts
export = ModuleHotDeclineDependency;
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
declare class ModuleHotDeclineDependency extends ModuleDependency {
    /**
     * @param {string} request the request string
     * @param {Range} range location in source code
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace ModuleHotDeclineDependency {
    export { ModuleDependencyTemplateAsId as Template, Range };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
import ModuleDependencyTemplateAsId = require("webpack/lib/dependencies/ModuleDependencyTemplateAsId");
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/NullDependency.d.ts
export = NullDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency").TRANSITIVE} TRANSITIVE */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
declare class NullDependency extends Dependency {
}
declare namespace NullDependency {
    export { NullDependencyTemplate as Template, ReplaceSource, TRANSITIVE, DependencyTemplateContext };
}
import Dependency = require("webpack/lib/Dependency");
declare class NullDependencyTemplate extends DependencyTemplate {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type TRANSITIVE = unique symbol;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
import DependencyTemplate = require("webpack/lib/DependencyTemplate");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/PrefetchDependency.d.ts
export = PrefetchDependency;
declare class PrefetchDependency extends ModuleDependency {
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/ProvidedDependency.d.ts
export = ProvidedDependency;
declare class ProvidedDependency extends ModuleDependency {
    /**
     * @param {string} request request
     * @param {string} identifier identifier
     * @param {string[]} ids ids
     * @param {Range} range range
     */
    constructor(request: string, identifier: string, ids: string[], range: import("webpack/lib/javascript/JavascriptParser").Range);
    identifier: string;
    ids: string[];
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    _hashUpdate: string;
}
declare namespace ProvidedDependency {
    export { ProvidedDependencyTemplate as Template, ReplaceSource, ChunkGraph, ReferencedExport, UpdateHashContext, DependencyTemplateContext, DependencyTemplates, ModuleGraph, ModuleGraphConnection, RuntimeTemplate, Range, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
declare const ProvidedDependencyTemplate_base: typeof import("webpack/lib/DependencyTemplate");
declare class ProvidedDependencyTemplate extends ProvidedDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type ReferencedExport = import("../Dependency").ReferencedExport;
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type DependencyTemplates = import("../DependencyTemplates");
type ModuleGraph = import("../ModuleGraph");
type ModuleGraphConnection = import("../ModuleGraphConnection");
type RuntimeTemplate = import("../RuntimeTemplate");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/PureExpressionDependency.d.ts
export = PureExpressionDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").UpdateHashContext} UpdateHashContext */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../ModuleGraphConnection").ConnectionState} ConnectionState */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/Hash")} Hash */
declare class PureExpressionDependency extends NullDependency {
    /**
     * @param {Range} range the source range
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    /** @type {Set<string> | false} */
    usedByExports: Set<string> | false;
    _hashUpdate: string;
}
declare namespace PureExpressionDependency {
    export { PureExpressionDependencyTemplate as Template, ReplaceSource, ChunkGraph, Dependency, UpdateHashContext, DependencyTemplateContext, ModuleGraph, ConnectionState, Range, ObjectDeserializerContext, ObjectSerializerContext, Hash };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const PureExpressionDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class PureExpressionDependencyTemplate extends PureExpressionDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type Dependency = import("../Dependency");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireContextDependency.d.ts
export = RequireContextDependency;
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
declare class RequireContextDependency extends ContextDependency {
    /**
     * @param {TODO} options options
     * @param {Range} range range
     */
    constructor(options: TODO, range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace RequireContextDependency {
    export { ModuleDependencyTemplateAsRequireId as Template, Range };
}
import ContextDependency = require("webpack/lib/dependencies/ContextDependency");
import ModuleDependencyTemplateAsRequireId = require("webpack/lib/dependencies/ModuleDependencyTemplateAsRequireId");
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireContextDependencyParserPlugin.d.ts
export = RequireContextDependencyParserPlugin;
declare class RequireContextDependencyParserPlugin {
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {void}
     */
    apply(parser: JavascriptParser): void;
}
declare namespace RequireContextDependencyParserPlugin {
    export { DependencyLocation, JavascriptParser, Range };
}
type JavascriptParser = import("../javascript/JavascriptParser");
type DependencyLocation = import("../Dependency").DependencyLocation;
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireContextPlugin.d.ts
export = RequireContextPlugin;
declare class RequireContextPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace RequireContextPlugin {
    export { JavascriptParserOptions, ResolveOptions, Compiler, Parser };
}
type Compiler = import("../Compiler");
type JavascriptParserOptions = any;
type ResolveOptions = any;
type Parser = import("../javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireEnsureDependenciesBlock.d.ts
export = RequireEnsureDependenciesBlock;
/** @typedef {import("../ChunkGroup").ChunkGroupOptions} ChunkGroupOptions */
/** @typedef {import("../Dependency").DependencyLocation} DependencyLocation */
declare class RequireEnsureDependenciesBlock extends AsyncDependenciesBlock {
    /**
     * @param {ChunkGroupOptions & { entryOptions?: TODO }} chunkName chunk name
     * @param {DependencyLocation} loc location info
     */
    constructor(chunkName: ChunkGroupOptions & {
        entryOptions?: TODO;
    }, loc: DependencyLocation);
}
declare namespace RequireEnsureDependenciesBlock {
    export { ChunkGroupOptions, DependencyLocation };
}
import AsyncDependenciesBlock = require("webpack/lib/AsyncDependenciesBlock");
type ChunkGroupOptions = import("../ChunkGroup").ChunkGroupOptions;
type DependencyLocation = import("../Dependency").DependencyLocation;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireEnsureDependenciesBlockParserPlugin.d.ts
export = RequireEnsureDependenciesBlockParserPlugin;
declare class RequireEnsureDependenciesBlockParserPlugin {
    apply(parser: any): void;
}
declare namespace RequireEnsureDependenciesBlockParserPlugin {
    export { ChunkGroupOptions, JavascriptParser };
}
type ChunkGroupOptions = import("../ChunkGroup").ChunkGroupOptions;
type JavascriptParser = import("../javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireEnsureDependency.d.ts
export = RequireEnsureDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../AsyncDependenciesBlock")} AsyncDependenciesBlock */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class RequireEnsureDependency extends NullDependency {
    /**
     * @param {Range} range range
     * @param {Range} contentRange content range
     * @param {Range} errorHandlerRange error handler range
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range, contentRange: import("webpack/lib/javascript/JavascriptParser").Range, errorHandlerRange: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    contentRange: import("webpack/lib/javascript/JavascriptParser").Range;
    errorHandlerRange: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace RequireEnsureDependency {
    export { RequireEnsureDependencyTemplate as Template, ReplaceSource, AsyncDependenciesBlock, Dependency, DependencyTemplateContext, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const RequireEnsureDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class RequireEnsureDependencyTemplate extends RequireEnsureDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type AsyncDependenciesBlock = import("../AsyncDependenciesBlock");
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireEnsureItemDependency.d.ts
export = RequireEnsureItemDependency;
declare class RequireEnsureItemDependency extends ModuleDependency {
}
declare namespace RequireEnsureItemDependency {
    let Template: {
        new (): {
            apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
        };
    };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireEnsurePlugin.d.ts
export = RequireEnsurePlugin;
declare class RequireEnsurePlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace RequireEnsurePlugin {
    export { JavascriptParserOptions, Compiler, Parser };
}
type Compiler = import("../Compiler");
type JavascriptParserOptions = any;
type Parser = import("../javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireHeaderDependency.d.ts
export = RequireHeaderDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class RequireHeaderDependency extends NullDependency {
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {RequireHeaderDependency} RequireHeaderDependency
     */
    static deserialize(context: ObjectDeserializerContext): RequireHeaderDependency;
    /**
     * @param {Range} range range
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace RequireHeaderDependency {
    export { RequireHeaderDependencyTemplate as Template, ReplaceSource, Dependency, DependencyTemplateContext, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
declare const RequireHeaderDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class RequireHeaderDependencyTemplate extends RequireHeaderDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireIncludeDependency.d.ts
export = RequireIncludeDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class RequireIncludeDependency extends ModuleDependency {
    /**
     * @param {string} request the request string
     * @param {Range} range location in source code
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace RequireIncludeDependency {
    export { RequireIncludeDependencyTemplate as Template, ReplaceSource, ReferencedExport, DependencyTemplateContext, ModuleGraph, Range, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
declare const RequireIncludeDependencyTemplate_base: typeof import("webpack/lib/DependencyTemplate");
declare class RequireIncludeDependencyTemplate extends RequireIncludeDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ReferencedExport = import("../Dependency").ReferencedExport;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type Range = import("../javascript/JavascriptParser").Range;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireIncludeDependencyParserPlugin.d.ts
export = RequireIncludeDependencyParserPlugin;
declare class RequireIncludeDependencyParserPlugin {
    /**
     * @param {boolean} warn true: warn about deprecation, false: don't warn
     */
    constructor(warn: boolean);
    warn: boolean;
    /**
     * @param {JavascriptParser} parser the parser
     * @returns {void}
     */
    apply(parser: JavascriptParser): void;
}
declare namespace RequireIncludeDependencyParserPlugin {
    export { DependencyLocation, JavascriptParser, Range };
}
type JavascriptParser = import("../javascript/JavascriptParser");
type DependencyLocation = import("../Dependency").DependencyLocation;
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireIncludePlugin.d.ts
export = RequireIncludePlugin;
declare class RequireIncludePlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace RequireIncludePlugin {
    export { JavascriptParserOptions, Compiler, Parser };
}
type Compiler = import("../Compiler");
type JavascriptParserOptions = any;
type Parser = import("../javascript/JavascriptParser");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireResolveContextDependency.d.ts
export = RequireResolveContextDependency;
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("./ContextDependency").ContextDependencyOptions} ContextDependencyOptions */
declare class RequireResolveContextDependency extends ContextDependency {
    /**
     * @param {ContextDependencyOptions} options options
     * @param {Range} range range
     * @param {Range} valueRange value range
     * @param {TODO} context context
     */
    constructor(options: ContextDependencyOptions, range: import("webpack/lib/javascript/JavascriptParser").Range, valueRange: import("webpack/lib/javascript/JavascriptParser").Range, context: TODO);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    valueRange: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace RequireResolveContextDependency {
    export { ContextDependencyTemplateAsId as Template, Range, ObjectDeserializerContext, ObjectSerializerContext, ContextDependencyOptions };
}
import ContextDependency = require("webpack/lib/dependencies/ContextDependency");
type ContextDependencyOptions = import("./ContextDependency").ContextDependencyOptions;
import ContextDependencyTemplateAsId = require("webpack/lib/dependencies/ContextDependencyTemplateAsId");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireResolveDependency.d.ts
export = RequireResolveDependency;
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class RequireResolveDependency extends ModuleDependency {
    /**
     * @param {string} request the request string
     * @param {Range} range location in source code
     * @param {string} [context] context
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range, context?: string);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    _context: string;
}
declare namespace RequireResolveDependency {
    export { ModuleDependencyAsId as Template, ReferencedExport, ModuleGraph, Range, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
import ModuleDependencyAsId = require("webpack/lib/dependencies/ModuleDependencyTemplateAsId");
type ReferencedExport = import("../Dependency").ReferencedExport;
type ModuleGraph = import("../ModuleGraph");
type Range = import("../javascript/JavascriptParser").Range;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RequireResolveHeaderDependency.d.ts
export = RequireResolveHeaderDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class RequireResolveHeaderDependency extends NullDependency {
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {RequireResolveHeaderDependency} RequireResolveHeaderDependency
     */
    static deserialize(context: ObjectDeserializerContext): RequireResolveHeaderDependency;
    /**
     * @param {Range} range range
     */
    constructor(range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace RequireResolveHeaderDependency {
    export { RequireResolveHeaderDependencyTemplate as Template, ReplaceSource, Dependency, DependencyTemplateContext, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
declare const RequireResolveHeaderDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class RequireResolveHeaderDependencyTemplate extends RequireResolveHeaderDependencyTemplate_base {
    /**
     * @param {string} name name
     * @param {RequireResolveHeaderDependency} dep dependency
     * @param {ReplaceSource} source source
     */
    applyAsTemplateArgument(name: string, dep: RequireResolveHeaderDependency, source: ReplaceSource): void;
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/RuntimeRequirementsDependency.d.ts
export = RuntimeRequirementsDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Dependency").UpdateHashContext} UpdateHashContext */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/Hash")} Hash */
declare class RuntimeRequirementsDependency extends NullDependency {
    /**
     * @param {string[]} runtimeRequirements runtime requirements
     */
    constructor(runtimeRequirements: string[]);
    runtimeRequirements: Set<string>;
    _hashUpdate: string;
}
declare namespace RuntimeRequirementsDependency {
    export { RuntimeRequirementsDependencyTemplate as Template, ReplaceSource, ChunkGraph, Dependency, UpdateHashContext, DependencyTemplateContext, ModuleGraph, ObjectDeserializerContext, ObjectSerializerContext, Hash };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const RuntimeRequirementsDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class RuntimeRequirementsDependencyTemplate extends RuntimeRequirementsDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type Dependency = import("../Dependency");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/StaticExportsDependency.d.ts
export = StaticExportsDependency;
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Dependency").ExportSpec} ExportSpec */
/** @typedef {import("../Dependency").ExportsSpec} ExportsSpec */
/** @typedef {import("../Dependency").UpdateHashContext} UpdateHashContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/Hash")} Hash */
declare class StaticExportsDependency extends NullDependency {
    /**
     * @param {string[] | true} exports export names
     * @param {boolean} canMangle true, if mangling exports names is allowed
     */
    constructor(exports: string[] | true, canMangle: boolean);
    exports: true | string[];
    canMangle: boolean;
}
declare namespace StaticExportsDependency {
    export { ChunkGraph, ExportSpec, ExportsSpec, UpdateHashContext, ModuleGraph, ObjectDeserializerContext, ObjectSerializerContext, Hash };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
type ChunkGraph = import("../ChunkGraph");
type ExportSpec = import("../Dependency").ExportSpec;
type ExportsSpec = import("../Dependency").ExportsSpec;
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type ModuleGraph = import("../ModuleGraph");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/SystemPlugin.d.ts
export = SystemPlugin;
declare class SystemPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace SystemPlugin {
    export { SystemImportDeprecationWarning, JavascriptParserOptions, Compiler, DependencyLocation, Parser, Range };
}
type Compiler = import("../Compiler");
declare class SystemImportDeprecationWarning extends WebpackError {
    /**
     * @param {DependencyLocation} loc location
     */
    constructor(loc: DependencyLocation);
}
type JavascriptParserOptions = any;
type DependencyLocation = import("../Dependency").DependencyLocation;
type Parser = import("../javascript/JavascriptParser");
type Range = import("../javascript/JavascriptParser").Range;
import WebpackError = require("webpack/lib/WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/SystemRuntimeModule.d.ts
export = SystemRuntimeModule;
declare class SystemRuntimeModule extends RuntimeModule {
    constructor();
}
import RuntimeModule = require("webpack/lib/RuntimeModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/URLDependency.d.ts
export = URLDependency;
declare class URLDependency extends ModuleDependency {
    /**
     * @param {string} request request
     * @param {Range} range range of the arguments of new URL( |> ... <| )
     * @param {Range} outerRange range of the full |> new URL(...) <|
     * @param {boolean=} relative use relative urls instead of absolute with base uri
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range, outerRange: import("webpack/lib/javascript/JavascriptParser").Range, relative?: boolean | undefined);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    outerRange: import("webpack/lib/javascript/JavascriptParser").Range;
    relative: boolean;
    /** @type {Set<string> | boolean | undefined} */
    usedByExports: Set<string> | boolean | undefined;
}
declare namespace URLDependency {
    export { URLDependencyTemplate as Template, ReplaceSource, ChunkGraph, Dependency, UpdateHashContext, DependencyTemplateContext, Module, ModuleGraph, ModuleGraphConnection, ConnectionState, Range, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
declare const URLDependencyTemplate_base: typeof import("webpack/lib/DependencyTemplate");
declare class URLDependencyTemplate extends URLDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type ChunkGraph = import("../ChunkGraph");
type Dependency = import("../Dependency");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Module = import("../Module");
type ModuleGraph = import("../ModuleGraph");
type ModuleGraphConnection = import("../ModuleGraphConnection");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/URLPlugin.d.ts
export = URLPlugin;
declare class URLPlugin {
    /**
     * @param {Compiler} compiler compiler
     */
    apply(compiler: Compiler): void;
}
declare namespace URLPlugin {
    export { NewExpressionNode, JavascriptParserOptions, Compiler, DependencyLocation, NormalModule, JavascriptParser, Parser, Range };
}
type Compiler = import("../Compiler");
type NewExpressionNode = import("estree").NewExpression;
type JavascriptParserOptions = any;
type DependencyLocation = import("../Dependency").DependencyLocation;
type NormalModule = import("../NormalModule");
type JavascriptParser = import("../javascript/JavascriptParser");
type Parser = import("../javascript/JavascriptParser");
type Range = import("../javascript/JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/UnsupportedDependency.d.ts
export = UnsupportedDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class UnsupportedDependency extends NullDependency {
    /**
     * @param {string} request the request string
     * @param {Range} range location in source code
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range);
    request: string;
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace UnsupportedDependency {
    export { UnsupportedDependencyTemplate as Template, ReplaceSource, Dependency, DependencyTemplateContext, Range, ObjectDeserializerContext, ObjectSerializerContext };
}
import NullDependency = require("webpack/lib/dependencies/NullDependency");
declare const UnsupportedDependencyTemplate_base: {
    new (): {
        apply(dependency: import("webpack/lib/Dependency"), source: import("webpack-sources/lib/ReplaceSource"), templateContext: import("webpack/lib/DependencyTemplate").DependencyTemplateContext): void;
    };
};
declare class UnsupportedDependencyTemplate extends UnsupportedDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/WebAssemblyExportImportedDependency.d.ts
export = WebAssemblyExportImportedDependency;
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../Dependency").TRANSITIVE} TRANSITIVE */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class WebAssemblyExportImportedDependency extends ModuleDependency {
    /**
     * @param {string} exportName export name
     * @param {string} request request
     * @param {string} name name
     * @param {TODO} valueType value type
     */
    constructor(exportName: string, request: string, name: string, valueType: TODO);
    /** @type {string} */
    exportName: string;
    /** @type {string} */
    name: string;
    /** @type {string} */
    valueType: string;
}
declare namespace WebAssemblyExportImportedDependency {
    export { ReferencedExport, TRANSITIVE, ModuleGraph, ObjectDeserializerContext, ObjectSerializerContext, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
type ReferencedExport = import("../Dependency").ReferencedExport;
type TRANSITIVE = import("../Dependency").TRANSITIVE;
type ModuleGraph = import("../ModuleGraph");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/WebAssemblyImportDependency.d.ts
export = WebAssemblyImportDependency;
/** @typedef {import("@webassemblyjs/ast").ModuleImportDescription} ModuleImportDescription */
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../WebpackError")} WebpackError */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class WebAssemblyImportDependency extends ModuleDependency {
    /**
     * @param {string} request the request
     * @param {string} name the imported name
     * @param {ModuleImportDescription} description the WASM ast node
     * @param {false | string} onlyDirectImport if only direct imports are allowed
     */
    constructor(request: string, name: string, description: any, onlyDirectImport: false | string);
    /** @type {string} */
    name: string;
    /** @type {ModuleImportDescription} */
    description: any;
    /** @type {false | string} */
    onlyDirectImport: false | string;
}
declare namespace WebAssemblyImportDependency {
    export { ModuleImportDescription, ReferencedExport, ModuleGraph, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
type ModuleImportDescription = any;
type ReferencedExport = import("../Dependency").ReferencedExport;
type ModuleGraph = import("../ModuleGraph");
type WebpackError = import("../WebpackError");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/WebpackIsIncludedDependency.d.ts
export = WebpackIsIncludedDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class WebpackIsIncludedDependency extends ModuleDependency {
    /**
     * @param {string} request the request string
     * @param {Range} range location in source code
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range);
    range: import("webpack/lib/javascript/JavascriptParser").Range;
}
declare namespace WebpackIsIncludedDependency {
    export { WebpackIsIncludedDependencyTemplate as Template, ReplaceSource, Compilation, ReferencedExport, DependencyTemplateContext, ModuleGraph, Range, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
declare const WebpackIsIncludedDependencyTemplate_base: typeof import("webpack/lib/DependencyTemplate");
declare class WebpackIsIncludedDependencyTemplate extends WebpackIsIncludedDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type Compilation = import("../Compilation");
type ReferencedExport = import("../Dependency").ReferencedExport;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ModuleGraph = import("../ModuleGraph");
type Range = import("../javascript/JavascriptParser").Range;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/WorkerDependency.d.ts
export = WorkerDependency;
/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../AsyncDependenciesBlock")} AsyncDependenciesBlock */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Dependency").ReferencedExport} ReferencedExport */
/** @typedef {import("../Dependency").UpdateHashContext} UpdateHashContext */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import("../Entrypoint")} Entrypoint */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/Hash")} Hash */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
declare class WorkerDependency extends ModuleDependency {
    /**
     * @param {string} request request
     * @param {Range} range range
     * @param {Object} workerDependencyOptions options
     * @param {string} workerDependencyOptions.publicPath public path for the worker
     */
    constructor(request: string, range: import("webpack/lib/javascript/JavascriptParser").Range, workerDependencyOptions: {
        publicPath: string;
    });
    range: import("webpack/lib/javascript/JavascriptParser").Range;
    options: {
        publicPath: string;
    };
    /** Cache the hash */
    _hashUpdate: string;
}
declare namespace WorkerDependency {
    export { WorkerDependencyTemplate as Template, ReplaceSource, AsyncDependenciesBlock, ChunkGraph, ReferencedExport, UpdateHashContext, DependencyTemplateContext, Entrypoint, ModuleGraph, Range, ObjectDeserializerContext, ObjectSerializerContext, Hash, RuntimeSpec };
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");
declare const WorkerDependencyTemplate_base: typeof import("webpack/lib/DependencyTemplate");
declare class WorkerDependencyTemplate extends WorkerDependencyTemplate_base {
}
type ReplaceSource = import("webpack-sources").ReplaceSource;
type AsyncDependenciesBlock = import("../AsyncDependenciesBlock");
type ChunkGraph = import("../ChunkGraph");
type ReferencedExport = import("../Dependency").ReferencedExport;
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type Entrypoint = import("../Entrypoint");
type ModuleGraph = import("../ModuleGraph");
type Range = import("../javascript/JavascriptParser").Range;
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/WorkerPlugin.d.ts
export = WorkerPlugin;
declare class WorkerPlugin {
    /**
     * @param {ChunkLoading} chunkLoading chunk loading
     * @param {WasmLoading} wasmLoading wasm loading
     * @param {OutputModule} module output module
     * @param {WorkerPublicPath} workerPublicPath worker public path
     */
    constructor(chunkLoading: any, wasmLoading: any, module: any, workerPublicPath: any);
    _chunkLoading: any;
    _wasmLoading: any;
    _module: any;
    _workerPublicPath: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace WorkerPlugin {
    export { CallExpression, Expression, ObjectExpression, Pattern, Property, SpreadElement, ChunkLoading, JavascriptParserOptions, OutputModule, WasmLoading, WorkerPublicPath, Compiler, DependencyLocation, EntryOptions, NormalModule, ParserState, BasicEvaluatedExpression, JavascriptParser, Parser, Range, HarmonySettings };
}
type Compiler = import("../Compiler");
type CallExpression = import("estree").CallExpression;
type Expression = import("estree").Expression;
type ObjectExpression = import("estree").ObjectExpression;
type Pattern = import("estree").Pattern;
type Property = import("estree").Property;
type SpreadElement = import("estree").SpreadElement;
type ChunkLoading = any;
type JavascriptParserOptions = any;
type OutputModule = any;
type WasmLoading = any;
type WorkerPublicPath = any;
type DependencyLocation = import("../Dependency").DependencyLocation;
type EntryOptions = import("../Entrypoint").EntryOptions;
type NormalModule = import("../NormalModule");
type ParserState = import("../Parser").ParserState;
type BasicEvaluatedExpression = import("../javascript/BasicEvaluatedExpression");
type JavascriptParser = import("../javascript/JavascriptParser");
type Parser = import("../javascript/JavascriptParser");
type Range = import("../javascript/JavascriptParser").Range;
type HarmonySettings = import("./HarmonyImportDependencyParserPlugin").HarmonySettings;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/getFunctionExpression.d.ts
declare function _exports(expr: Expression): {
    fn: TODO;
    expressions: (Expression | SpreadElement)[];
    needThis: boolean | undefined;
};
export = _exports;
export type Expression = import("estree").Expression;
export type SpreadElement = import("estree").SpreadElement;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/dependencies/processExportInfo.d.ts
export = processExportInfo;
/** @typedef {import("../ExportsInfo").ExportInfo} ExportInfo */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
/**
 * @param {RuntimeSpec} runtime the runtime
 * @param {string[][]} referencedExports list of referenced exports, will be added to
 * @param {string[]} prefix export prefix
 * @param {ExportInfo=} exportInfo the export info
 * @param {boolean} defaultPointsToSelf when true, using default will reference itself
 * @param {Set<ExportInfo>} alreadyVisited already visited export info (to handle circular reexports)
 */
declare function processExportInfo(runtime: RuntimeSpec, referencedExports: string[][], prefix: string[], exportInfo?: ExportInfo | undefined, defaultPointsToSelf?: boolean, alreadyVisited?: Set<ExportInfo>): void;
declare namespace processExportInfo {
    export { ExportInfo, RuntimeSpec };
}
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
type ExportInfo = import("../ExportsInfo").ExportInfo;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/electron/ElectronTargetPlugin.d.ts
export = ElectronTargetPlugin;
/** @typedef {import("../Compiler")} Compiler */
declare class ElectronTargetPlugin {
    /**
     * @param {"main" | "preload" | "renderer"=} context in main, preload or renderer context?
     */
    constructor(context?: ("main" | "preload" | "renderer") | undefined);
    _context: "main" | "preload" | "renderer";
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ElectronTargetPlugin {
    export { Compiler };
}
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/errors/BuildCycleError.d.ts
export = BuildCycleError;
/** @typedef {import("../Module")} Module */
declare class BuildCycleError extends WebpackError {
    /**
     * Creates an instance of ModuleDependencyError.
     * @param {Module} module the module starting the cycle
     */
    constructor(module: Module);
}
declare namespace BuildCycleError {
    export { Module };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/esm/ExportWebpackRequireRuntimeModule.d.ts
export = ExportWebpackRequireRuntimeModule;
declare class ExportWebpackRequireRuntimeModule extends RuntimeModule {
    constructor();
}
import RuntimeModule = require("webpack/lib/RuntimeModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/esm/ModuleChunkFormatPlugin.d.ts
export = ModuleChunkFormatPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Entrypoint")} Entrypoint */
declare class ModuleChunkFormatPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ModuleChunkFormatPlugin {
    export { Chunk, Compiler, Entrypoint };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");
type Entrypoint = import("../Entrypoint");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/esm/ModuleChunkLoadingPlugin.d.ts
export = ModuleChunkLoadingPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
declare class ModuleChunkLoadingPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ModuleChunkLoadingPlugin {
    export { Chunk, Compiler };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/esm/ModuleChunkLoadingRuntimeModule.d.ts
export = ModuleChunkLoadingRuntimeModule;
declare class ModuleChunkLoadingRuntimeModule extends RuntimeModule {
    /**
     * @param {Compilation} compilation the compilation
     * @returns {JsonpCompilationPluginHooks} hooks
     */
    static getCompilationHooks(compilation: Compilation): JsonpCompilationPluginHooks;
    /**
     * @param {ReadonlySet<string>} runtimeRequirements runtime requirements
     */
    constructor(runtimeRequirements: ReadonlySet<string>);
    _runtimeRequirements: ReadonlySet<string>;
    /**
     * @private
     * @param {Chunk} chunk chunk
     * @param {string} rootOutputDir root output directory
     * @returns {string} generated code
     */
    private _generateBaseUri;
}
declare namespace ModuleChunkLoadingRuntimeModule {
    export { Chunk, ChunkGraph, JsonpCompilationPluginHooks };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
import Compilation = require("webpack/lib/Compilation");
type JsonpCompilationPluginHooks = {
    linkPreload: SyncWaterfallHook<[string, Chunk]>;
    linkPrefetch: SyncWaterfallHook<[string, Chunk]>;
};
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
import { SyncWaterfallHook } from "tapable";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/formatLocation.d.ts
export = formatLocation;
/**
 * @param {DependencyLocation} loc location
 * @returns {string} formatted location
 */
declare function formatLocation(loc: DependencyLocation): string;
declare namespace formatLocation {
    export { DependencyLocation, SourcePosition };
}
type DependencyLocation = import("./Dependency").DependencyLocation;
type SourcePosition = import("./Dependency").SourcePosition;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/hmr/HotModuleReplacement.runtime.d.ts
declare function _exports(): void;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/hmr/HotModuleReplacementRuntimeModule.d.ts
export = HotModuleReplacementRuntimeModule;
declare class HotModuleReplacementRuntimeModule extends RuntimeModule {
    constructor();
}
import RuntimeModule = require("webpack/lib/RuntimeModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/hmr/JavascriptHotModuleReplacement.runtime.d.ts
declare function _exports(): void;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/hmr/LazyCompilationPlugin.d.ts
export = LazyCompilationPlugin;
declare class LazyCompilationPlugin {
    /**
     * @param {Object} options options
     * @param {(function(Compiler, function(Error?, BackendApi?): void): void) | function(Compiler): Promise<BackendApi>} options.backend the backend
     * @param {boolean} options.entries true, when entries are lazy compiled
     * @param {boolean} options.imports true, when import() modules are lazy compiled
     * @param {RegExp | string | (function(Module): boolean)} options.test additional filter for lazy compiled entrypoint modules
     */
    constructor({ backend, entries, imports, test }: {
        backend: ((arg0: Compiler, arg1: (arg0: Error | null, arg1: BackendApi | null) => void) => void) | ((arg0: Compiler) => Promise<BackendApi>);
        entries: boolean;
        imports: boolean;
        test: RegExp | string | ((arg0: Module) => boolean);
    });
    backend: ((arg0: Compiler, arg1: (arg0: Error | null, arg1: BackendApi | null) => void) => void) | ((arg0: Compiler) => Promise<BackendApi>);
    entries: boolean;
    imports: boolean;
    test: string | RegExp | ((arg0: Module) => boolean);
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace LazyCompilationPlugin {
    export { WebpackOptions, Compilation, Compiler, UpdateHashContext, BuildMeta, CodeGenerationContext, CodeGenerationResult, LibIdentOptions, NeedBuildContext, ModuleFactoryCreateData, ModuleFactoryResult, RequestShortener, ResolverWithOptions, WebpackError, HarmonyImportDependency, Hash, InputFileSystem, BackendApi };
}
type Compiler = import("../Compiler");
type BackendApi = {
    dispose: (arg0: Error | undefined) => void;
    module: (arg0: Module) => {
        client: string;
        data: string;
        active: boolean;
    };
};
import Module = require("webpack/lib/Module");
type WebpackOptions = any;
type Compilation = import("../Compilation");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type BuildMeta = import("../Module").BuildMeta;
type CodeGenerationContext = import("../Module").CodeGenerationContext;
type CodeGenerationResult = import("../Module").CodeGenerationResult;
type LibIdentOptions = import("../Module").LibIdentOptions;
type NeedBuildContext = import("../Module").NeedBuildContext;
type ModuleFactoryCreateData = import("../ModuleFactory").ModuleFactoryCreateData;
type ModuleFactoryResult = import("../ModuleFactory").ModuleFactoryResult;
type RequestShortener = import("../RequestShortener");
type ResolverWithOptions = import("../ResolverFactory").ResolverWithOptions;
type WebpackError = import("../WebpackError");
type HarmonyImportDependency = import("../dependencies/HarmonyImportDependency");
type Hash = import("../util/Hash");
type InputFileSystem = import("../util/fs").InputFileSystem;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/hmr/lazyCompilationBackend.d.ts
declare function _exports(options: Omit<LazyCompilationDefaultBackendOptions, "client"> & {
    client: NonNullable<LazyCompilationDefaultBackendOptions["client"]>;
}): BackendHandler;
export = _exports;
export type HttpServerOptions = import("http").ServerOptions;
export type HttpsServerOptions = import("https").ServerOptions;
export type LazyCompilationDefaultBackendOptions = any;
export type Compiler = import("../Compiler");
export type BackendHandler = (compiler: Compiler, callback: (arg0: (Error | null) | undefined, arg1: any | undefined) => void) => void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/ChunkModuleIdRangePlugin.d.ts
export = ChunkModuleIdRangePlugin;
/** @typedef {import("../Compiler")} Compiler */
/**
 * @typedef {Object} ChunkModuleIdRangePluginOptions
 * @property {string} name the chunk name
 * @property {("index" | "index2" | "preOrderIndex" | "postOrderIndex")=} order order
 * @property {number=} start start id
 * @property {number=} end end id
 */
declare class ChunkModuleIdRangePlugin {
    /**
     * @param {ChunkModuleIdRangePluginOptions} options options object
     */
    constructor(options: ChunkModuleIdRangePluginOptions);
    options: ChunkModuleIdRangePluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ChunkModuleIdRangePlugin {
    export { Compiler, ChunkModuleIdRangePluginOptions };
}
type ChunkModuleIdRangePluginOptions = {
    /**
     * the chunk name
     */
    name: string;
    /**
     * order
     */
    order?: ("index" | "index2" | "preOrderIndex" | "postOrderIndex") | undefined;
    /**
     * start id
     */
    start?: number | undefined;
    /**
     * end id
     */
    end?: number | undefined;
};
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/DeterministicChunkIdsPlugin.d.ts
export = DeterministicChunkIdsPlugin;
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
/**
 * @typedef {Object} DeterministicChunkIdsPluginOptions
 * @property {string=} context context for ids
 * @property {number=} maxLength maximum length of ids
 */
declare class DeterministicChunkIdsPlugin {
    /**
     * @param {DeterministicChunkIdsPluginOptions} [options] options
     */
    constructor(options?: DeterministicChunkIdsPluginOptions);
    options: DeterministicChunkIdsPluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DeterministicChunkIdsPlugin {
    export { Compiler, Module, DeterministicChunkIdsPluginOptions };
}
type DeterministicChunkIdsPluginOptions = {
    /**
     * context for ids
     */
    context?: string | undefined;
    /**
     * maximum length of ids
     */
    maxLength?: number | undefined;
};
type Compiler = import("../Compiler");
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/DeterministicModuleIdsPlugin.d.ts
export = DeterministicModuleIdsPlugin;
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
/**
 * @typedef {Object} DeterministicModuleIdsPluginOptions
 * @property {string=} context context relative to which module identifiers are computed
 * @property {function(Module): boolean=} test selector function for modules
 * @property {number=} maxLength maximum id length in digits (used as starting point)
 * @property {number=} salt hash salt for ids
 * @property {boolean=} fixedLength do not increase the maxLength to find an optimal id space size
 * @property {boolean=} failOnConflict throw an error when id conflicts occur (instead of rehashing)
 */
declare class DeterministicModuleIdsPlugin {
    /**
     * @param {DeterministicModuleIdsPluginOptions} [options] options
     */
    constructor(options?: DeterministicModuleIdsPluginOptions);
    options: DeterministicModuleIdsPluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DeterministicModuleIdsPlugin {
    export { Compiler, Module, DeterministicModuleIdsPluginOptions };
}
type DeterministicModuleIdsPluginOptions = {
    /**
     * context relative to which module identifiers are computed
     */
    context?: string | undefined;
    /**
     * selector function for modules
     */
    test?: ((arg0: Module) => boolean) | undefined;
    /**
     * maximum id length in digits (used as starting point)
     */
    maxLength?: number | undefined;
    /**
     * hash salt for ids
     */
    salt?: number | undefined;
    /**
     * do not increase the maxLength to find an optimal id space size
     */
    fixedLength?: boolean | undefined;
    /**
     * throw an error when id conflicts occur (instead of rehashing)
     */
    failOnConflict?: boolean | undefined;
};
type Compiler = import("../Compiler");
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/HashedModuleIdsPlugin.d.ts
export = HashedModuleIdsPlugin;
declare class HashedModuleIdsPlugin {
    /**
     * @param {HashedModuleIdsPluginOptions=} options options object
     */
    constructor(options?: any);
    /** @type {HashedModuleIdsPluginOptions} */
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace HashedModuleIdsPlugin {
    export { HashedModuleIdsPluginOptions, Compiler };
}
type Compiler = import("../Compiler");
type HashedModuleIdsPluginOptions = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/IdHelpers.d.ts
export type Chunk = import("../Chunk");
export type ChunkGraph = import("../ChunkGraph");
export type Compilation = import("../Compilation");
export type Module = import("../Module");
export type Hash = typeof import("../util/Hash");
/**
 * @param {string} request the request
 * @returns {string} id representation
 */
export function requestToId(request: string): string;
/**
 * @param {Module} module the module
 * @param {string} context context directory
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} short module name
 */
export function getShortModuleName(module: Module, context: string, associatedObjectForCache?: any | undefined): string;
/**
 * @param {string} shortName the short name
 * @param {Module} module the module
 * @param {string} context context directory
 * @param {string | Hash} hashFunction hash function to use
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} long module name
 */
export function getLongModuleName(shortName: string, module: Module, context: string, hashFunction: string | Hash, associatedObjectForCache?: any | undefined): string;
/**
 * @param {Module} module the module
 * @param {string} context context directory
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} full module name
 */
export function getFullModuleName(module: Module, context: string, associatedObjectForCache?: any | undefined): string;
/**
 * @param {Chunk} chunk the chunk
 * @param {ChunkGraph} chunkGraph the chunk graph
 * @param {string} context context directory
 * @param {string} delimiter delimiter for names
 * @param {string | Hash} hashFunction hash function to use
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} short chunk name
 */
export function getShortChunkName(chunk: Chunk, chunkGraph: ChunkGraph, context: string, delimiter: string, hashFunction: string | Hash, associatedObjectForCache?: any | undefined): string;
/**
 * @param {Chunk} chunk the chunk
 * @param {ChunkGraph} chunkGraph the chunk graph
 * @param {string} context context directory
 * @param {string} delimiter delimiter for names
 * @param {string | Hash} hashFunction hash function to use
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} short chunk name
 */
export function getLongChunkName(chunk: Chunk, chunkGraph: ChunkGraph, context: string, delimiter: string, hashFunction: string | Hash, associatedObjectForCache?: any | undefined): string;
/**
 * @param {Chunk} chunk the chunk
 * @param {ChunkGraph} chunkGraph the chunk graph
 * @param {string} context context directory
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} full chunk name
 */
export function getFullChunkName(chunk: Chunk, chunkGraph: ChunkGraph, context: string, associatedObjectForCache?: any | undefined): string;
/**
 * @param {Compilation} compilation the compilation
 * @param {function(Module): boolean=} filter filter modules
 * @returns {[Set<string>, Module[]]} used module ids as strings and modules without id matching the filter
 */
export function getUsedModuleIdsAndModules(compilation: Compilation, filter?: ((arg0: Module) => boolean) | undefined): [Set<string>, Module[]];
/**
 * @param {Compilation} compilation the compilation
 * @returns {Set<string>} used chunk ids as strings
 */
export function getUsedChunkIds(compilation: Compilation): Set<string>;
/**
 * @template T
 * @param {Iterable<T>} items list of items to be named
 * @param {function(T): string} getShortName get a short name for an item
 * @param {function(T, string): string} getLongName get a long name for an item
 * @param {function(T, T): -1|0|1} comparator order of items
 * @param {Set<string>} usedIds already used ids, will not be assigned
 * @param {function(T, string): void} assignName assign a name to an item
 * @returns {T[]} list of items without a name
 */
export function assignNames<T>(items: Iterable<T>, getShortName: (arg0: T) => string, getLongName: (arg0: T, arg1: string) => string, comparator: (arg0: T, arg1: T) => -1 | 0 | 1, usedIds: Set<string>, assignName: (arg0: T, arg1: string) => void): T[];
/**
 * @template T
 * @param {T[]} items list of items to be named
 * @param {function(T): string} getName get a name for an item
 * @param {function(T, T): -1|0|1} comparator order of items
 * @param {function(T, number): boolean} assignId assign an id to an item
 * @param {number[]} ranges usable ranges for ids
 * @param {number} expandFactor factor to create more ranges
 * @param {number} extraSpace extra space to allocate, i. e. when some ids are already used
 * @param {number} salt salting number to initialize hashing
 * @returns {void}
 */
export function assignDeterministicIds<T>(items: T[], getName: (arg0: T) => string, comparator: (arg0: T, arg1: T) => -1 | 0 | 1, assignId: (arg0: T, arg1: number) => boolean, ranges?: number[], expandFactor?: number, extraSpace?: number, salt?: number): void;
/**
 * @param {Set<string>} usedIds used ids
 * @param {Iterable<Module>} modules the modules
 * @param {Compilation} compilation the compilation
 * @returns {void}
 */
export function assignAscendingModuleIds(usedIds: Set<string>, modules: Iterable<Module>, compilation: Compilation): void;
/**
 * @param {Iterable<Chunk>} chunks the chunks
 * @param {Compilation} compilation the compilation
 * @returns {void}
 */
export function assignAscendingChunkIds(chunks: Iterable<Chunk>, compilation: Compilation): void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/NamedChunkIdsPlugin.d.ts
export = NamedChunkIdsPlugin;
/** @typedef {import("../../declarations/WebpackOptions").OutputNormalized} Output */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
/**
 * @typedef {Object} NamedChunkIdsPluginOptions
 * @property {string} [context] context
 * @property {string} [delimiter] delimiter
 */
declare class NamedChunkIdsPlugin {
    /**
     * @param {NamedChunkIdsPluginOptions=} options options
     */
    constructor(options?: NamedChunkIdsPluginOptions | undefined);
    delimiter: string;
    context: string;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace NamedChunkIdsPlugin {
    export { Output, Chunk, Compiler, Module, NamedChunkIdsPluginOptions };
}
type Compiler = import("../Compiler");
type NamedChunkIdsPluginOptions = {
    /**
     * context
     */
    context?: string;
    /**
     * delimiter
     */
    delimiter?: string;
};
type Output = any;
type Chunk = import("../Chunk");
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/NamedModuleIdsPlugin.d.ts
export = NamedModuleIdsPlugin;
/** @typedef {import("../../declarations/WebpackOptions").OutputNormalized} Output */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
/**
 * @typedef {Object} NamedModuleIdsPluginOptions
 * @property {string} [context] context
 */
declare class NamedModuleIdsPlugin {
    /**
     * @param {NamedModuleIdsPluginOptions} [options] options
     */
    constructor(options?: NamedModuleIdsPluginOptions);
    options: NamedModuleIdsPluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace NamedModuleIdsPlugin {
    export { Output, Compiler, Module, NamedModuleIdsPluginOptions };
}
type NamedModuleIdsPluginOptions = {
    /**
     * context
     */
    context?: string;
};
type Compiler = import("../Compiler");
type Output = any;
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/NaturalChunkIdsPlugin.d.ts
export = NaturalChunkIdsPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
declare class NaturalChunkIdsPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace NaturalChunkIdsPlugin {
    export { Chunk, Compiler, Module };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/NaturalModuleIdsPlugin.d.ts
export = NaturalModuleIdsPlugin;
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
declare class NaturalModuleIdsPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace NaturalModuleIdsPlugin {
    export { Compiler, Module };
}
type Compiler = import("../Compiler");
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/OccurrenceChunkIdsPlugin.d.ts
export = OccurrenceChunkIdsPlugin;
declare class OccurrenceChunkIdsPlugin {
    /**
     * @param {OccurrenceChunkIdsPluginOptions=} options options object
     */
    constructor(options?: any);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace OccurrenceChunkIdsPlugin {
    export { OccurrenceChunkIdsPluginOptions, Chunk, Compiler, Module };
}
type Compiler = import("../Compiler");
type OccurrenceChunkIdsPluginOptions = any;
type Chunk = import("../Chunk");
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/OccurrenceModuleIdsPlugin.d.ts
export = OccurrenceModuleIdsPlugin;
declare class OccurrenceModuleIdsPlugin {
    /**
     * @param {OccurrenceModuleIdsPluginOptions=} options options object
     */
    constructor(options?: any);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace OccurrenceModuleIdsPlugin {
    export { OccurrenceModuleIdsPluginOptions, Compiler, Module, ModuleGraphConnection };
}
type Compiler = import("../Compiler");
type OccurrenceModuleIdsPluginOptions = any;
type Module = import("../Module");
type ModuleGraphConnection = import("../ModuleGraphConnection");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/ids/SyncModuleIdsPlugin.d.ts
export = SyncModuleIdsPlugin;
declare class SyncModuleIdsPlugin {
    /**
     * @param {Object} options options
     * @param {string} options.path path to file
     * @param {string=} options.context context for module names
     * @param {function(Module): boolean} options.test selector for modules
     * @param {"read" | "create" | "merge" | "update"=} options.mode operation mode (defaults to merge)
     */
    constructor({ path, context, test, mode }: {
        path: string;
        context?: string | undefined;
        test: (arg0: Module) => boolean;
        mode?: ("read" | "create" | "merge" | "update") | undefined;
    });
    _path: string;
    _context: string;
    _test: (arg0: Module) => boolean;
    _read: boolean;
    _write: boolean;
    _prune: boolean;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace SyncModuleIdsPlugin {
    export { Compiler, Module };
}
type Module = import("../Module");
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/index.d.ts
declare const _exports: import("webpack/lib/webpack").WebpackFunctionSingle & import("webpack/lib/webpack").WebpackFunctionMulti & {
    readonly webpack: import("webpack/lib/webpack").WebpackFunctionSingle & import("webpack/lib/webpack").WebpackFunctionMulti;
    readonly validate: (options: any) => void;
    readonly validateSchema: (schema: import("webpack/node_modules/schema-utils/declarations/validate").Schema, options: object | object[], validationConfiguration?: import("webpack/node_modules/schema-utils/declarations/validate").ValidationErrorConfiguration) => void;
    readonly version: string;
    readonly cli: typeof import("webpack/lib/cli");
    readonly AutomaticPrefetchPlugin: typeof import("webpack/lib/AutomaticPrefetchPlugin");
    readonly AsyncDependenciesBlock: typeof import("webpack/lib/AsyncDependenciesBlock");
    readonly BannerPlugin: typeof import("webpack/lib/BannerPlugin");
    readonly Cache: typeof import("webpack/lib/Cache");
    readonly Chunk: typeof import("webpack/lib/Chunk");
    readonly ChunkGraph: typeof import("webpack/lib/ChunkGraph");
    readonly CleanPlugin: typeof import("webpack/lib/CleanPlugin");
    readonly Compilation: typeof import("webpack/lib/Compilation");
    readonly Compiler: typeof import("webpack/lib/Compiler");
    readonly ConcatenationScope: typeof import("webpack/lib/ConcatenationScope");
    readonly ContextExclusionPlugin: typeof import("webpack/lib/ContextExclusionPlugin");
    readonly ContextReplacementPlugin: typeof import("webpack/lib/ContextReplacementPlugin");
    readonly DefinePlugin: typeof import("webpack/lib/DefinePlugin");
    readonly DelegatedPlugin: typeof import("webpack/lib/DelegatedPlugin");
    readonly Dependency: typeof import("webpack/lib/Dependency");
    readonly DllPlugin: typeof import("webpack/lib/DllPlugin");
    readonly DllReferencePlugin: typeof import("webpack/lib/DllReferencePlugin");
    readonly DynamicEntryPlugin: typeof import("webpack/lib/DynamicEntryPlugin");
    readonly EntryOptionPlugin: typeof import("webpack/lib/EntryOptionPlugin");
    readonly EntryPlugin: typeof import("webpack/lib/EntryPlugin");
    readonly EnvironmentPlugin: typeof import("webpack/lib/EnvironmentPlugin");
    readonly EvalDevToolModulePlugin: typeof import("webpack/lib/EvalDevToolModulePlugin");
    readonly EvalSourceMapDevToolPlugin: typeof import("webpack/lib/EvalSourceMapDevToolPlugin");
    readonly ExternalModule: typeof import("webpack/lib/ExternalModule");
    readonly ExternalsPlugin: typeof import("webpack/lib/ExternalsPlugin");
    readonly Generator: typeof import("webpack/lib/Generator");
    readonly HotUpdateChunk: typeof import("webpack/lib/HotUpdateChunk");
    readonly HotModuleReplacementPlugin: typeof import("webpack/lib/HotModuleReplacementPlugin");
    readonly IgnorePlugin: typeof import("webpack/lib/IgnorePlugin");
    readonly JavascriptModulesPlugin: typeof import("webpack/lib/javascript/JavascriptModulesPlugin");
    readonly LibManifestPlugin: typeof import("webpack/lib/LibManifestPlugin");
    readonly LibraryTemplatePlugin: typeof import("webpack/lib/LibraryTemplatePlugin");
    readonly LoaderOptionsPlugin: typeof import("webpack/lib/LoaderOptionsPlugin");
    readonly LoaderTargetPlugin: typeof import("webpack/lib/LoaderTargetPlugin");
    readonly Module: typeof import("webpack/lib/Module");
    readonly ModuleFilenameHelpers: typeof import("webpack/lib/ModuleFilenameHelpers");
    readonly ModuleGraph: typeof import("webpack/lib/ModuleGraph");
    readonly ModuleGraphConnection: typeof import("webpack/lib/ModuleGraphConnection");
    readonly NoEmitOnErrorsPlugin: typeof import("webpack/lib/NoEmitOnErrorsPlugin");
    readonly NormalModule: typeof import("webpack/lib/NormalModule");
    readonly NormalModuleReplacementPlugin: typeof import("webpack/lib/NormalModuleReplacementPlugin");
    readonly MultiCompiler: typeof import("webpack/lib/MultiCompiler");
    readonly Parser: typeof import("webpack/lib/Parser");
    readonly PrefetchPlugin: typeof import("webpack/lib/PrefetchPlugin");
    readonly ProgressPlugin: typeof import("webpack/lib/ProgressPlugin");
    readonly ProvidePlugin: typeof import("webpack/lib/ProvidePlugin");
    readonly RuntimeGlobals: typeof import("webpack/lib/RuntimeGlobals");
    readonly RuntimeModule: typeof import("webpack/lib/RuntimeModule");
    readonly SingleEntryPlugin: typeof import("webpack/lib/EntryPlugin");
    readonly SourceMapDevToolPlugin: typeof import("webpack/lib/SourceMapDevToolPlugin");
    readonly Stats: typeof import("webpack/lib/Stats");
    readonly Template: typeof import("webpack/lib/Template");
    readonly UsageState: Readonly<{
        Unused: 0;
        OnlyPropertiesUsed: 1;
        NoInfo: 2;
        Unknown: 3;
        Used: 4;
    }>;
    readonly WatchIgnorePlugin: typeof import("webpack/lib/WatchIgnorePlugin");
    readonly WebpackError: typeof import("webpack/lib/WebpackError");
    readonly WebpackOptionsApply: typeof import("webpack/lib/WebpackOptionsApply");
    readonly WebpackOptionsDefaulter: typeof import("webpack/lib/WebpackOptionsDefaulter");
    readonly WebpackOptionsValidationError: typeof import("webpack/node_modules/schema-utils/declarations/ValidationError").default;
    readonly ValidationError: typeof import("webpack/node_modules/schema-utils/declarations/ValidationError").default;
    cache: {
        readonly MemoryCachePlugin: typeof import("webpack/lib/cache/MemoryCachePlugin");
    };
    config: {
        readonly getNormalizedWebpackOptions: (config: any) => any;
        readonly applyWebpackOptionsDefaults: (options: any) => void;
    };
    dependencies: {
        readonly ModuleDependency: typeof import("webpack/lib/dependencies/ModuleDependency");
        readonly HarmonyImportDependency: typeof import("webpack/lib/dependencies/HarmonyImportDependency");
        readonly ConstDependency: typeof import("webpack/lib/dependencies/ConstDependency");
        readonly NullDependency: typeof import("webpack/lib/dependencies/NullDependency");
    };
    ids: {
        readonly ChunkModuleIdRangePlugin: typeof import("webpack/lib/ids/ChunkModuleIdRangePlugin");
        readonly NaturalModuleIdsPlugin: typeof import("webpack/lib/ids/NaturalModuleIdsPlugin");
        readonly OccurrenceModuleIdsPlugin: typeof import("webpack/lib/ids/OccurrenceModuleIdsPlugin");
        readonly NamedModuleIdsPlugin: typeof import("webpack/lib/ids/NamedModuleIdsPlugin");
        readonly DeterministicChunkIdsPlugin: typeof import("webpack/lib/ids/DeterministicChunkIdsPlugin");
        readonly DeterministicModuleIdsPlugin: typeof import("webpack/lib/ids/DeterministicModuleIdsPlugin");
        readonly NamedChunkIdsPlugin: typeof import("webpack/lib/ids/NamedChunkIdsPlugin");
        readonly OccurrenceChunkIdsPlugin: typeof import("webpack/lib/ids/OccurrenceChunkIdsPlugin");
        readonly HashedModuleIdsPlugin: typeof import("webpack/lib/ids/HashedModuleIdsPlugin");
    };
    javascript: {
        readonly EnableChunkLoadingPlugin: typeof import("webpack/lib/javascript/EnableChunkLoadingPlugin");
        readonly JavascriptModulesPlugin: typeof import("webpack/lib/javascript/JavascriptModulesPlugin");
        readonly JavascriptParser: typeof import("webpack/lib/javascript/JavascriptParser");
    };
    optimize: {
        readonly AggressiveMergingPlugin: typeof import("webpack/lib/optimize/AggressiveMergingPlugin");
        readonly AggressiveSplittingPlugin: typeof import("webpack/lib/optimize/AggressiveSplittingPlugin");
        readonly InnerGraph: typeof import("webpack/lib/optimize/InnerGraph");
        readonly LimitChunkCountPlugin: typeof import("webpack/lib/optimize/LimitChunkCountPlugin");
        readonly MinChunkSizePlugin: typeof import("webpack/lib/optimize/MinChunkSizePlugin");
        readonly ModuleConcatenationPlugin: typeof import("webpack/lib/optimize/ModuleConcatenationPlugin");
        readonly RealContentHashPlugin: typeof import("webpack/lib/optimize/RealContentHashPlugin");
        readonly RuntimeChunkPlugin: typeof import("webpack/lib/optimize/RuntimeChunkPlugin");
        readonly SideEffectsFlagPlugin: typeof import("webpack/lib/optimize/SideEffectsFlagPlugin");
        readonly SplitChunksPlugin: typeof import("webpack/lib/optimize/SplitChunksPlugin");
    };
    runtime: {
        readonly GetChunkFilenameRuntimeModule: typeof import("webpack/lib/runtime/GetChunkFilenameRuntimeModule");
        readonly LoadScriptRuntimeModule: typeof import("webpack/lib/runtime/LoadScriptRuntimeModule");
    };
    prefetch: {
        readonly ChunkPrefetchPreloadPlugin: typeof import("webpack/lib/prefetch/ChunkPrefetchPreloadPlugin");
    };
    web: {
        readonly FetchCompileAsyncWasmPlugin: typeof import("webpack/lib/web/FetchCompileAsyncWasmPlugin");
        readonly FetchCompileWasmPlugin: typeof import("webpack/lib/web/FetchCompileWasmPlugin");
        readonly JsonpChunkLoadingRuntimeModule: typeof import("webpack/lib/web/JsonpChunkLoadingRuntimeModule");
        readonly JsonpTemplatePlugin: typeof import("webpack/lib/web/JsonpTemplatePlugin");
    };
    webworker: {
        readonly WebWorkerTemplatePlugin: typeof import("webpack/lib/webworker/WebWorkerTemplatePlugin");
    };
    node: {
        readonly NodeEnvironmentPlugin: typeof import("webpack/lib/node/NodeEnvironmentPlugin");
        readonly NodeSourcePlugin: typeof import("webpack/lib/node/NodeSourcePlugin");
        readonly NodeTargetPlugin: typeof import("webpack/lib/node/NodeTargetPlugin");
        readonly NodeTemplatePlugin: typeof import("webpack/lib/node/NodeTemplatePlugin");
        readonly ReadFileCompileWasmPlugin: typeof import("webpack/lib/node/ReadFileCompileWasmPlugin");
    };
    electron: {
        readonly ElectronTargetPlugin: typeof import("webpack/lib/electron/ElectronTargetPlugin");
    };
    wasm: {
        readonly AsyncWebAssemblyModulesPlugin: typeof import("webpack/lib/wasm-async/AsyncWebAssemblyModulesPlugin");
        readonly EnableWasmLoadingPlugin: typeof import("webpack/lib/wasm/EnableWasmLoadingPlugin");
    };
    library: {
        readonly AbstractLibraryPlugin: typeof import("webpack/lib/library/AbstractLibraryPlugin");
        readonly EnableLibraryPlugin: typeof import("webpack/lib/library/EnableLibraryPlugin");
    };
    container: {
        readonly ContainerPlugin: typeof import("webpack/lib/container/ContainerPlugin");
        readonly ContainerReferencePlugin: typeof import("webpack/lib/container/ContainerReferencePlugin");
        readonly ModuleFederationPlugin: typeof import("webpack/lib/container/ModuleFederationPlugin");
        readonly scope: <T>(scope: string, options: import("webpack/lib/container/options").ContainerOptionsFormat<T>) => Record<string, string | string[] | T>;
    };
    sharing: {
        readonly ConsumeSharedPlugin: typeof import("webpack/lib/sharing/ConsumeSharedPlugin");
        readonly ProvideSharedPlugin: typeof import("webpack/lib/sharing/ProvideSharedPlugin");
        readonly SharePlugin: typeof import("webpack/lib/sharing/SharePlugin");
        readonly scope: <T>(scope: string, options: import("webpack/lib/container/options").ContainerOptionsFormat<T>) => Record<string, string | string[] | T>;
    };
    debug: {
        readonly ProfilingPlugin: typeof import("webpack/lib/debug/ProfilingPlugin");
    };
    util: {
        readonly createHash: (algorithm: string | typeof import("webpack/lib/util/Hash")) => import("webpack/lib/util/Hash");
        readonly comparators: typeof import("webpack/lib/util/comparators");
        readonly runtime: typeof import("webpack/lib/util/runtime");
        readonly serialization: {
            readonly register: typeof import("webpack/lib/serialization/ObjectMiddleware").register;
            readonly registerLoader: typeof import("webpack/lib/serialization/ObjectMiddleware").registerLoader;
            readonly registerNotSerializable: typeof import("webpack/lib/serialization/ObjectMiddleware").registerNotSerializable;
            readonly NOT_SERIALIZABLE: {};
            readonly MEASURE_START_OPERATION: unique symbol; /** @typedef {import("./Compilation").Asset} Asset */
            readonly MEASURE_END_OPERATION: unique symbol;
            readonly buffersSerializer: import("webpack/lib/serialization/Serializer");
            createFileSerializer: (fs: import("webpack/lib/util/fs").IntermediateFileSystem, hashFunction: string | typeof import("webpack/lib/util/Hash")) => import("webpack/lib/serialization/Serializer");
        };
        readonly cleverMerge: <T_1, O>(first: T_1, second: O) => T_1 | O | (T_1 & O);
        readonly LazySet: typeof import("webpack/lib/util/LazySet");
    };
    readonly sources: typeof import("webpack-sources");
    experiments: {
        schemes: {
            readonly HttpUriPlugin: typeof import("webpack/lib/schemes/HttpUriPlugin");
        };
        ids: {
            readonly SyncModuleIdsPlugin: typeof import("webpack/lib/ids/SyncModuleIdsPlugin");
        };
    };
};
export = _exports;
export type Entry = any;
export type EntryNormalized = any;
export type EntryObject = any;
export type ExternalItemFunctionData = any;
export type ExternalItemObjectKnown = any;
export type ExternalItemObjectUnknown = any;
export type ExternalItemValue = any;
export type Externals = any;
export type FileCacheOptions = any;
export type LibraryOptions = any;
export type MemoryCacheOptions = any;
export type ModuleOptions = any;
export type ResolveOptions = any;
export type RuleSetCondition = any;
export type RuleSetConditionAbsolute = any;
export type RuleSetRule = any;
export type RuleSetUse = any;
export type RuleSetUseItem = any;
export type StatsOptions = any;
export type Configuration = any;
export type WebpackOptionsNormalized = any;
export type WebpackPluginFunction = any;
export type WebpackPluginInstance = any;
export type ChunkGroup = import("./ChunkGroup");
export type Asset = import("./Compilation").Asset;
export type AssetInfo = import("./Compilation").AssetInfo;
export type EntryOptions = import("./Compilation").EntryOptions;
export type PathData = import("./Compilation").PathData;
export type AssetEmittedInfo = import("./Compiler").AssetEmittedInfo;
export type MultiStats = import("./MultiStats");
export type ResolveData = import("./NormalModuleFactory").ResolveData;
export type ParserState = import("./Parser").ParserState;
export type ResolvePluginInstance = import("./ResolverFactory").ResolvePluginInstance;
export type Resolver = import("./ResolverFactory").Resolver;
export type Watching = import("./Watching");
export type Argument = import("./cli").Argument;
export type Problem = import("./cli").Problem;
export type StatsAsset = import("./stats/DefaultStatsFactoryPlugin").StatsAsset;
export type StatsChunk = import("./stats/DefaultStatsFactoryPlugin").StatsChunk;
export type StatsChunkGroup = import("./stats/DefaultStatsFactoryPlugin").StatsChunkGroup;
export type StatsChunkOrigin = import("./stats/DefaultStatsFactoryPlugin").StatsChunkOrigin;
export type StatsCompilation = import("./stats/DefaultStatsFactoryPlugin").StatsCompilation;
export type StatsError = import("./stats/DefaultStatsFactoryPlugin").StatsError;
export type StatsLogging = import("./stats/DefaultStatsFactoryPlugin").StatsLogging;
export type StatsLoggingEntry = import("./stats/DefaultStatsFactoryPlugin").StatsLoggingEntry;
export type StatsModule = import("./stats/DefaultStatsFactoryPlugin").StatsModule;
export type StatsModuleIssuer = import("./stats/DefaultStatsFactoryPlugin").StatsModuleIssuer;
export type StatsModuleReason = import("./stats/DefaultStatsFactoryPlugin").StatsModuleReason;
export type StatsModuleTraceDependency = import("./stats/DefaultStatsFactoryPlugin").StatsModuleTraceDependency;
export type StatsModuleTraceItem = import("./stats/DefaultStatsFactoryPlugin").StatsModuleTraceItem;
export type StatsProfile = import("./stats/DefaultStatsFactoryPlugin").StatsProfile;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/javascript/ArrayPushCallbackChunkFormatPlugin.d.ts
export = ArrayPushCallbackChunkFormatPlugin;
/** @typedef {import("../Compiler")} Compiler */
declare class ArrayPushCallbackChunkFormatPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ArrayPushCallbackChunkFormatPlugin {
    export { Compiler };
}
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/javascript/BasicEvaluatedExpression.d.ts
export = BasicEvaluatedExpression;
declare class BasicEvaluatedExpression {
    type: number;
    /** @type {[number, number] | undefined} */
    range: [number, number] | undefined;
    /** @type {boolean} */
    falsy: boolean;
    /** @type {boolean} */
    truthy: boolean;
    /** @type {boolean | undefined} */
    nullish: boolean | undefined;
    /** @type {boolean} */
    sideEffects: boolean;
    /** @type {boolean | undefined} */
    bool: boolean | undefined;
    /** @type {number | undefined} */
    number: number | undefined;
    /** @type {bigint | undefined} */
    bigint: bigint | undefined;
    /** @type {RegExp | undefined} */
    regExp: RegExp | undefined;
    /** @type {string | undefined} */
    string: string | undefined;
    /** @type {BasicEvaluatedExpression[] | undefined} */
    quasis: BasicEvaluatedExpression[] | undefined;
    /** @type {BasicEvaluatedExpression[] | undefined} */
    parts: BasicEvaluatedExpression[] | undefined;
    /** @type {any[] | undefined} */
    array: any[] | undefined;
    /** @type {BasicEvaluatedExpression[] | undefined} */
    items: BasicEvaluatedExpression[] | undefined;
    /** @type {BasicEvaluatedExpression[] | undefined} */
    options: BasicEvaluatedExpression[] | undefined;
    /** @type {BasicEvaluatedExpression | undefined | null} */
    prefix: BasicEvaluatedExpression | undefined | null;
    /** @type {BasicEvaluatedExpression | undefined | null} */
    postfix: BasicEvaluatedExpression | undefined | null;
    /** @type {BasicEvaluatedExpression[] | undefined} */
    wrappedInnerExpressions: BasicEvaluatedExpression[] | undefined;
    /** @type {string | VariableInfoInterface | undefined} */
    identifier: string | VariableInfoInterface | undefined;
    /** @type {string | VariableInfoInterface | undefined} */
    rootInfo: string | VariableInfoInterface | undefined;
    /** @type {(() => string[]) | undefined} */
    getMembers: (() => string[]) | undefined;
    /** @type {(() => boolean[]) | undefined} */
    getMembersOptionals: (() => boolean[]) | undefined;
    /** @type {(() => Range[]) | undefined} */
    getMemberRanges: (() => import("webpack/lib/javascript/JavascriptParser").Range[]) | undefined;
    /** @type {Node | undefined} */
    expression: Node | undefined;
    isUnknown(): boolean;
    isNull(): boolean;
    isUndefined(): boolean;
    isString(): boolean;
    isNumber(): boolean;
    isBigInt(): boolean;
    isBoolean(): boolean;
    isRegExp(): boolean;
    isConditional(): boolean;
    isArray(): boolean;
    isConstArray(): boolean;
    isIdentifier(): boolean;
    isWrapped(): boolean;
    isTemplateString(): boolean;
    /**
     * Is expression a primitive or an object type value?
     * @returns {boolean | undefined} true: primitive type, false: object type, undefined: unknown/runtime-defined
     */
    isPrimitiveType(): boolean | undefined;
    /**
     * Is expression a runtime or compile-time value?
     * @returns {boolean} true: compile time value, false: runtime value
     */
    isCompileTimeValue(): boolean;
    /**
     * Gets the compile-time value of the expression
     * @returns {any} the javascript value
     */
    asCompileTimeValue(): any;
    isTruthy(): boolean;
    isFalsy(): boolean;
    isNullish(): boolean;
    /**
     * Can this expression have side effects?
     * @returns {boolean} false: never has side effects
     */
    couldHaveSideEffects(): boolean;
    /**
     * Creates a boolean representation of this evaluated expression.
     * @returns {boolean | undefined} true: truthy, false: falsy, undefined: unknown
     */
    asBool(): boolean | undefined;
    /**
     * Creates a nullish coalescing representation of this evaluated expression.
     * @returns {boolean | undefined} true: nullish, false: not nullish, undefined: unknown
     */
    asNullish(): boolean | undefined;
    /**
     * Creates a string representation of this evaluated expression.
     * @returns {string | undefined} the string representation or undefined if not possible
     */
    asString(): string | undefined;
    /**
     * @param {string} string value
     * @returns {BasicEvaluatedExpression} basic evaluated expression
     */
    setString(string: string): BasicEvaluatedExpression;
    setUndefined(): this;
    setNull(): this;
    /**
     * Set's the value of this expression to a number
     * @param {number} number number to set
     * @returns {this} this
     */
    setNumber(number: number): this;
    /**
     * Set's the value of this expression to a BigInt
     * @param {bigint} bigint bigint to set
     * @returns {this} this
     */
    setBigInt(bigint: bigint): this;
    /**
     * Set's the value of this expression to a boolean
     * @param {boolean} bool boolean to set
     * @returns {this} this
     */
    setBoolean(bool: boolean): this;
    /**
     * Set's the value of this expression to a regular expression
     * @param {RegExp} regExp regular expression to set
     * @returns {this} this
     */
    setRegExp(regExp: RegExp): this;
    /**
     * Set's the value of this expression to a particular identifier and its members.
     *
     * @param {string | VariableInfoInterface} identifier identifier to set
     * @param {string | VariableInfoInterface} rootInfo root info
     * @param {() => string[]} getMembers members
     * @param {() => boolean[]=} getMembersOptionals optional members
     * @param {() => Range[]=} getMemberRanges ranges of progressively increasing sub-expressions
     * @returns {this} this
     */
    setIdentifier(identifier: string | VariableInfoInterface, rootInfo: string | VariableInfoInterface, getMembers: () => string[], getMembersOptionals?: (() => boolean[]) | undefined, getMemberRanges?: (() => import("webpack/lib/javascript/JavascriptParser").Range[]) | undefined): this;
    /**
     * Wraps an array of expressions with a prefix and postfix expression.
     *
     * @param {BasicEvaluatedExpression | null | undefined} prefix Expression to be added before the innerExpressions
     * @param {BasicEvaluatedExpression | null | undefined} postfix Expression to be added after the innerExpressions
     * @param {BasicEvaluatedExpression[]} innerExpressions Expressions to be wrapped
     * @returns {this} this
     */
    setWrapped(prefix: BasicEvaluatedExpression | null | undefined, postfix: BasicEvaluatedExpression | null | undefined, innerExpressions: BasicEvaluatedExpression[]): this;
    /**
     * Stores the options of a conditional expression.
     *
     * @param {BasicEvaluatedExpression[]} options optional (consequent/alternate) expressions to be set
     * @returns {this} this
     */
    setOptions(options: BasicEvaluatedExpression[]): this;
    /**
     * Adds options to a conditional expression.
     *
     * @param {BasicEvaluatedExpression[]} options optional (consequent/alternate) expressions to be added
     * @returns {this} this
     */
    addOptions(options: BasicEvaluatedExpression[]): this;
    /**
     * Set's the value of this expression to an array of expressions.
     *
     * @param {BasicEvaluatedExpression[]} items expressions to set
     * @returns {this} this
     */
    setItems(items: BasicEvaluatedExpression[]): this;
    /**
     * Set's the value of this expression to an array of strings.
     *
     * @param {string[]} array array to set
     * @returns {this} this
     */
    setArray(array: string[]): this;
    /**
     * Set's the value of this expression to a processed/unprocessed template string. Used
     * for evaluating TemplateLiteral expressions in the JavaScript Parser.
     *
     * @param {BasicEvaluatedExpression[]} quasis template string quasis
     * @param {BasicEvaluatedExpression[]} parts template string parts
     * @param {"cooked" | "raw"} kind template string kind
     * @returns {this} this
     */
    setTemplateString(quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[], kind: "cooked" | "raw"): this;
    templateStringKind: "raw" | "cooked";
    setTruthy(): this;
    setFalsy(): this;
    /**
     * Set's the value of the expression to nullish.
     *
     * @param {boolean} value true, if the expression is nullish
     * @returns {this} this
     */
    setNullish(value: boolean): this;
    /**
     * Set's the range for the expression.
     *
     * @param {[number, number]} range range to set
     * @returns {this} this
     */
    setRange(range: [number, number]): this;
    /**
     * Set whether or not the expression has side effects.
     *
     * @param {boolean} sideEffects true, if the expression has side effects
     * @returns {this} this
     */
    setSideEffects(sideEffects?: boolean): this;
    /**
     * Set the expression node for the expression.
     *
     * @param {Node | undefined} expression expression
     * @returns {this} this
     */
    setExpression(expression: Node | undefined): this;
}
declare namespace BasicEvaluatedExpression {
    export { isValidRegExpFlags, Node, Range, VariableInfoInterface };
}
type VariableInfoInterface = import("./JavascriptParser").VariableInfoInterface;
type Node = import("estree").Node;
/**
 * @param {string} flags regexp flags
 * @returns {boolean} is valid flags
 */
declare function isValidRegExpFlags(flags: string): boolean;
type Range = import("./JavascriptParser").Range;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/javascript/ChunkHelpers.d.ts
export type Chunk = import("../Chunk");
/** @typedef {import("../Chunk")} Chunk */
/**
 * @param {Entrypoint} entrypoint a chunk group
 * @param {Chunk=} excludedChunk1 current chunk which is excluded
 * @param {Chunk=} excludedChunk2 runtime chunk which is excluded
 * @returns {Set<Chunk>} chunks
 */
export function getAllChunks(entrypoint: Entrypoint, excludedChunk1?: Chunk | undefined, excludedChunk2?: Chunk | undefined): Set<Chunk>;
import Entrypoint = require("webpack/lib/Entrypoint");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/javascript/CommonJsChunkFormatPlugin.d.ts
export = CommonJsChunkFormatPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Entrypoint")} Entrypoint */
declare class CommonJsChunkFormatPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace CommonJsChunkFormatPlugin {
    export { Chunk, Compiler, Entrypoint };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");
type Entrypoint = import("../Entrypoint");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/javascript/EnableChunkLoadingPlugin.d.ts
export = EnableChunkLoadingPlugin;
declare class EnableChunkLoadingPlugin {
    /**
     * @param {Compiler} compiler the compiler instance
     * @param {ChunkLoadingType} type type of library
     * @returns {void}
     */
    static setEnabled(compiler: Compiler, type: any): void;
    /**
     * @param {Compiler} compiler the compiler instance
     * @param {ChunkLoadingType} type type of library
     * @returns {void}
     */
    static checkEnabled(compiler: Compiler, type: any): void;
    /**
     * @param {ChunkLoadingType} type library type that should be available
     */
    constructor(type: any);
    type: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace EnableChunkLoadingPlugin {
    export { ChunkLoadingType, Compiler };
}
type Compiler = import("../Compiler");
type ChunkLoadingType = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/javascript/JavascriptGenerator.d.ts
export = JavascriptGenerator;
declare class JavascriptGenerator extends Generator {
    /**
     * @param {Module} module the module to generate
     * @param {InitFragment[]} initFragments mutable list of init fragments
     * @param {ReplaceSource} source the current replace source which can be modified
     * @param {GenerateContext} generateContext the generateContext
     * @returns {void}
     */
    sourceModule(module: Module, initFragments: InitFragment<any>[], source: ReplaceSource, generateContext: GenerateContext): void;
    /**
     * @param {Module} module the module to generate
     * @param {DependenciesBlock} block the dependencies block which will be processed
     * @param {InitFragment[]} initFragments mutable list of init fragments
     * @param {ReplaceSource} source the current replace source which can be modified
     * @param {GenerateContext} generateContext the generateContext
     * @returns {void}
     */
    sourceBlock(module: Module, block: DependenciesBlock, initFragments: InitFragment<any>[], source: ReplaceSource, generateContext: GenerateContext): void;
    /**
     * @param {Module} module the current module
     * @param {Dependency} dependency the dependency to generate
     * @param {InitFragment[]} initFragments mutable list of init fragments
     * @param {ReplaceSource} source the current replace source which can be modified
     * @param {GenerateContext} generateContext the render context
     * @returns {void}
     */
    sourceDependency(module: Module, dependency: Dependency, initFragments: InitFragment<any>[], source: ReplaceSource, generateContext: GenerateContext): void;
}
declare namespace JavascriptGenerator {
    export { Source, DependenciesBlock, Dependency, DependencyTemplates, GenerateContext, Module, ConcatenationBailoutReasonContext, NormalModule, RuntimeTemplate };
}
import Generator = require("webpack/lib/Generator");
type Module = import("../Module");
import InitFragment = require("webpack/lib/InitFragment");
import { ReplaceSource } from "webpack-sources";
type GenerateContext = import("../Generator").GenerateContext;
type DependenciesBlock = import("../DependenciesBlock");
type Dependency = import("../Dependency");
type Source = import("webpack-sources").Source;
type DependencyTemplates = import("../DependencyTemplates");
type ConcatenationBailoutReasonContext = import("../Module").ConcatenationBailoutReasonContext;
type NormalModule = import("../NormalModule");
type RuntimeTemplate = import("../RuntimeTemplate");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/javascript/JavascriptModulesPlugin.d.ts
export = JavascriptModulesPlugin;
declare class JavascriptModulesPlugin {
    /**
     * @param {Compilation} compilation the compilation
     * @returns {CompilationHooks} the attached hooks
     */
    static getCompilationHooks(compilation: Compilation): CompilationHooks;
    static getChunkFilenameTemplate(chunk: any, outputOptions: any): any;
    constructor(options?: {});
    options: {};
    /** @type {WeakMap<Source, TODO>} */
    _moduleFactoryCache: WeakMap<Source, TODO>;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
    /**
     * @param {Module} module the rendered module
     * @param {ChunkRenderContext} renderContext options object
     * @param {CompilationHooks} hooks hooks
     * @param {boolean} factory true: renders as factory method, false: pure module content
     * @returns {Source} the newly generated source from rendering
     */
    renderModule(module: Module, renderContext: ChunkRenderContext, hooks: CompilationHooks, factory: boolean): Source;
    /**
     * @param {RenderContext} renderContext the render context
     * @param {CompilationHooks} hooks hooks
     * @returns {Source} the rendered source
     */
    renderChunk(renderContext: RenderContext, hooks: CompilationHooks): Source;
    /**
     * @param {MainRenderContext} renderContext options object
     * @param {CompilationHooks} hooks hooks
     * @param {Compilation} compilation the compilation
     * @returns {Source} the newly generated source from rendering
     */
    renderMain(renderContext: MainRenderContext, hooks: CompilationHooks, compilation: Compilation): Source;
    /**
     * @param {Hash} hash the hash to be updated
     * @param {RenderBootstrapContext} renderContext options object
     * @param {CompilationHooks} hooks hooks
     */
    updateHashWithBootstrap(hash: Hash, renderContext: RenderBootstrapContext, hooks: CompilationHooks): void;
    /**
     * @param {RenderBootstrapContext} renderContext options object
     * @param {CompilationHooks} hooks hooks
     * @returns {{ header: string[], beforeStartup: string[], startup: string[], afterStartup: string[], allowInlineStartup: boolean }} the generated source of the bootstrap code
     */
    renderBootstrap(renderContext: RenderBootstrapContext, hooks: CompilationHooks): {
        header: string[];
        beforeStartup: string[];
        startup: string[];
        afterStartup: string[];
        allowInlineStartup: boolean;
    };
    /**
     * @param {RenderBootstrapContext} renderContext options object
     * @param {CompilationHooks} hooks hooks
     * @returns {string} the generated source of the require function
     */
    renderRequire(renderContext: RenderBootstrapContext, hooks: CompilationHooks): string;
}
declare namespace JavascriptModulesPlugin {
    export { chunkHasJs, Source, Chunk, ChunkGraph, CodeGenerationResults, ChunkHashContext, Compiler, DependencyTemplates, Module, ModuleGraph, RuntimeTemplate, Hash, RenderContext, MainRenderContext, ChunkRenderContext, RenderBootstrapContext, StartupRenderContext, CompilationHooks };
}
type Source = import("webpack-sources").Source;
type Compiler = import("../Compiler");
type Module = import("../Module");
type ChunkRenderContext = {
    /**
     * the chunk
     */
    chunk: Chunk;
    /**
     * the dependency templates
     */
    dependencyTemplates: DependencyTemplates;
    /**
     * the runtime template
     */
    runtimeTemplate: RuntimeTemplate;
    /**
     * the module graph
     */
    moduleGraph: ModuleGraph;
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
    /**
     * results of code generation
     */
    codeGenerationResults: CodeGenerationResults;
    /**
     * init fragments for the chunk
     */
    chunkInitFragments: InitFragment<ChunkRenderContext>[];
    /**
     * rendering in strict context
     */
    strictMode: boolean;
};
type CompilationHooks = {
    renderModuleContent: SyncWaterfallHook<[Source, Module, ChunkRenderContext]>;
    renderModuleContainer: SyncWaterfallHook<[Source, Module, ChunkRenderContext]>;
    renderModulePackage: SyncWaterfallHook<[Source, Module, ChunkRenderContext]>;
    renderChunk: SyncWaterfallHook<[Source, RenderContext]>;
    renderMain: SyncWaterfallHook<[Source, RenderContext]>;
    renderContent: SyncWaterfallHook<[Source, RenderContext]>;
    render: SyncWaterfallHook<[Source, RenderContext]>;
    renderStartup: SyncWaterfallHook<[Source, Module, StartupRenderContext]>;
    renderRequire: SyncWaterfallHook<[string, RenderBootstrapContext]>;
    inlineInRuntimeBailout: SyncBailHook<[Module, RenderBootstrapContext], string>;
    embedInRuntimeBailout: SyncBailHook<[Module, RenderContext], string | void>;
    strictRuntimeBailout: SyncBailHook<[RenderContext], string | void>;
    chunkHash: SyncHook<[Chunk, Hash, ChunkHashContext]>;
    useSourceMap: SyncBailHook<[Chunk, RenderContext], boolean>;
};
type RenderContext = {
    /**
     * the chunk
     */
    chunk: Chunk;
    /**
     * the dependency templates
     */
    dependencyTemplates: DependencyTemplates;
    /**
     * the runtime template
     */
    runtimeTemplate: RuntimeTemplate;
    /**
     * the module graph
     */
    moduleGraph: ModuleGraph;
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
    /**
     * results of code generation
     */
    codeGenerationResults: CodeGenerationResults;
    /**
     * rendering in strict context
     */
    strictMode: boolean;
};
type MainRenderContext = {
    /**
     * the chunk
     */
    chunk: Chunk;
    /**
     * the dependency templates
     */
    dependencyTemplates: DependencyTemplates;
    /**
     * the runtime template
     */
    runtimeTemplate: RuntimeTemplate;
    /**
     * the module graph
     */
    moduleGraph: ModuleGraph;
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
    /**
     * results of code generation
     */
    codeGenerationResults: CodeGenerationResults;
    /**
     * hash to be used for render call
     */
    hash: string;
    /**
     * rendering in strict context
     */
    strictMode: boolean;
};
import Compilation = require("webpack/lib/Compilation");
type Hash = import("../util/Hash");
type RenderBootstrapContext = {
    /**
     * the chunk
     */
    chunk: Chunk;
    /**
     * results of code generation
     */
    codeGenerationResults: CodeGenerationResults;
    /**
     * the runtime template
     */
    runtimeTemplate: RuntimeTemplate;
    /**
     * the module graph
     */
    moduleGraph: ModuleGraph;
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
    /**
     * hash to be used for render call
     */
    hash: string;
};
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../CodeGenerationResults")} CodeGenerationResults */
/** @typedef {import("../Compilation").ChunkHashContext} ChunkHashContext */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../DependencyTemplates")} DependencyTemplates */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */
/** @typedef {import("../util/Hash")} Hash */
/**
 * @param {Chunk} chunk a chunk
 * @param {ChunkGraph} chunkGraph the chunk graph
 * @returns {boolean} true, when a JS file is needed for this chunk
 */
declare function chunkHasJs(chunk: Chunk, chunkGraph: ChunkGraph): boolean;
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type CodeGenerationResults = import("../CodeGenerationResults");
type ChunkHashContext = import("../Compilation").ChunkHashContext;
type DependencyTemplates = import("../DependencyTemplates");
type ModuleGraph = import("../ModuleGraph");
type RuntimeTemplate = import("../RuntimeTemplate");
type StartupRenderContext = RenderContext & {
    inlined: boolean;
};
import InitFragment = require("webpack/lib/InitFragment");
import { SyncWaterfallHook } from "tapable";
import { SyncBailHook } from "tapable";
import { SyncHook } from "tapable";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/javascript/JavascriptParser.d.ts
export = JavascriptParser;
declare class JavascriptParser extends Parser {
    /**
     * @param {string} code source code
     * @param {ParseOptions} options parsing options
     * @returns {Program} parsed ast
     */
    static _parse(code: string, options: ParseOptions): Program;
    /**
     * @param {"module" | "script" | "auto"} sourceType default source type
     */
    constructor(sourceType?: "module" | "script" | "auto");
    hooks: Readonly<{
        /** @type {HookMap<SyncBailHook<[UnaryExpression], BasicEvaluatedExpression | undefined | null>>} */
        evaluateTypeof: HookMap<SyncBailHook<[UnaryExpression], BasicEvaluatedExpression | undefined | null>>;
        /** @type {HookMap<SyncBailHook<[Expression], BasicEvaluatedExpression | undefined | null>>} */
        evaluate: HookMap<SyncBailHook<[Expression], BasicEvaluatedExpression | undefined | null>>;
        /** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression | MetaProperty], BasicEvaluatedExpression | undefined | null>>} */
        evaluateIdentifier: HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression | MetaProperty], BasicEvaluatedExpression | undefined | null>>;
        /** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression], BasicEvaluatedExpression | undefined | null>>} */
        evaluateDefinedIdentifier: HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression], BasicEvaluatedExpression | undefined | null>>;
        /** @type {HookMap<SyncBailHook<[NewExpression], BasicEvaluatedExpression | undefined | null>>} */
        evaluateNewExpression: HookMap<SyncBailHook<[NewExpression], BasicEvaluatedExpression | undefined | null>>;
        /** @type {HookMap<SyncBailHook<[CallExpression], BasicEvaluatedExpression | undefined | null>>} */
        evaluateCallExpression: HookMap<SyncBailHook<[CallExpression], BasicEvaluatedExpression | undefined | null>>;
        /** @type {HookMap<SyncBailHook<[CallExpression, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */
        evaluateCallExpressionMember: HookMap<SyncBailHook<[CallExpression, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>;
        /** @type {HookMap<SyncBailHook<[Expression | Declaration | PrivateIdentifier, number], boolean | void>>} */
        isPure: HookMap<SyncBailHook<[Expression | Declaration | PrivateIdentifier, number], boolean | void>>;
        /** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */
        preStatement: SyncBailHook<[Statement | ModuleDeclaration], boolean | void>;
        /** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */
        blockPreStatement: SyncBailHook<[Statement | ModuleDeclaration], boolean | void>;
        /** @type {SyncBailHook<[Statement | ModuleDeclaration], boolean | void>} */
        statement: SyncBailHook<[Statement | ModuleDeclaration], boolean | void>;
        /** @type {SyncBailHook<[IfStatement], boolean | void>} */
        statementIf: SyncBailHook<[IfStatement], boolean | void>;
        /** @type {SyncBailHook<[Expression, ClassExpression | ClassDeclaration], boolean | void>} */
        classExtendsExpression: SyncBailHook<[Expression, ClassExpression | ClassDeclaration], boolean | void>;
        /** @type {SyncBailHook<[MethodDefinition | PropertyDefinition | StaticBlock, ClassExpression | ClassDeclaration], boolean | void>} */
        classBodyElement: SyncBailHook<[MethodDefinition | PropertyDefinition | StaticBlock, ClassExpression | ClassDeclaration], boolean | void>;
        /** @type {SyncBailHook<[Expression, MethodDefinition | PropertyDefinition, ClassExpression | ClassDeclaration], boolean | void>} */
        classBodyValue: SyncBailHook<[Expression, MethodDefinition | PropertyDefinition, ClassExpression | ClassDeclaration], boolean | void>;
        /** @type {HookMap<SyncBailHook<[LabeledStatement], boolean | void>>} */
        label: HookMap<SyncBailHook<[LabeledStatement], boolean | void>>;
        /** @type {SyncBailHook<[ImportDeclaration, ImportSource], boolean | void>} */
        import: SyncBailHook<[ImportDeclaration, ImportSource], boolean | void>;
        /** @type {SyncBailHook<[ImportDeclaration, ImportSource, string, string], boolean | void>} */
        importSpecifier: SyncBailHook<[ImportDeclaration, ImportSource, string, string], boolean | void>;
        /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration], boolean | void>} */
        export: SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration], boolean | void>;
        /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource], boolean | void>} */
        exportImport: SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource], boolean | void>;
        /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, Declaration], boolean | void>} */
        exportDeclaration: SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, Declaration], boolean | void>;
        /** @type {SyncBailHook<[ExportDefaultDeclaration, Declaration], boolean | void>} */
        exportExpression: SyncBailHook<[ExportDefaultDeclaration, Declaration], boolean | void>;
        /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, string, string, number | undefined], boolean | void>} */
        exportSpecifier: SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, string, string, number | undefined], boolean | void>;
        /** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource, string, string, number | undefined], boolean | void>} */
        exportImportSpecifier: SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource, string, string, number | undefined], boolean | void>;
        /** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>} */
        preDeclarator: SyncBailHook<[VariableDeclarator, Statement], boolean | void>;
        /** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>} */
        declarator: SyncBailHook<[VariableDeclarator, Statement], boolean | void>;
        /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */
        varDeclaration: HookMap<SyncBailHook<[Declaration], boolean | void>>;
        /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */
        varDeclarationLet: HookMap<SyncBailHook<[Declaration], boolean | void>>;
        /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */
        varDeclarationConst: HookMap<SyncBailHook<[Declaration], boolean | void>>;
        /** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>} */
        varDeclarationVar: HookMap<SyncBailHook<[Declaration], boolean | void>>;
        /** @type {HookMap<SyncBailHook<[Identifier], boolean | void>>} */
        pattern: HookMap<SyncBailHook<[Identifier], boolean | void>>;
        /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */
        canRename: HookMap<SyncBailHook<[Expression], boolean | void>>;
        /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */
        rename: HookMap<SyncBailHook<[Expression], boolean | void>>;
        /** @type {HookMap<SyncBailHook<[AssignmentExpression], boolean | void>>} */
        assign: HookMap<SyncBailHook<[AssignmentExpression], boolean | void>>;
        /** @type {HookMap<SyncBailHook<[AssignmentExpression, string[]], boolean | void>>} */
        assignMemberChain: HookMap<SyncBailHook<[AssignmentExpression, string[]], boolean | void>>;
        /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */
        typeof: HookMap<SyncBailHook<[Expression], boolean | void>>;
        /** @type {SyncBailHook<[ImportExpression], boolean | void>} */
        importCall: SyncBailHook<[ImportExpression], boolean | void>;
        /** @type {SyncBailHook<[Expression], boolean | void>} */
        topLevelAwait: SyncBailHook<[Expression], boolean | void>;
        /** @type {HookMap<SyncBailHook<[CallExpression], boolean | void>>} */
        call: HookMap<SyncBailHook<[CallExpression], boolean | void>>;
        /** Something like "a.b()" */
        /** @type {HookMap<SyncBailHook<[CallExpression, string[], boolean[], Range[]], boolean | void>>} */
        callMemberChain: HookMap<SyncBailHook<[CallExpression, string[], boolean[], Range[]], boolean | void>>;
        /** Something like "a.b().c.d" */
        /** @type {HookMap<SyncBailHook<[Expression, string[], CallExpression, string[]], boolean | void>>} */
        memberChainOfCallMemberChain: HookMap<SyncBailHook<[Expression, string[], CallExpression, string[]], boolean | void>>;
        /** Something like "a.b().c.d()"" */
        /** @type {HookMap<SyncBailHook<[CallExpression, string[], CallExpression, string[]], boolean | void>>} */
        callMemberChainOfCallMemberChain: HookMap<SyncBailHook<[CallExpression, string[], CallExpression, string[]], boolean | void>>;
        /** @type {SyncBailHook<[ChainExpression], boolean | void>} */
        optionalChaining: SyncBailHook<[ChainExpression], boolean | void>;
        /** @type {HookMap<SyncBailHook<[NewExpression], boolean | void>>} */
        new: HookMap<SyncBailHook<[NewExpression], boolean | void>>;
        /** @type {SyncBailHook<[BinaryExpression], boolean | void>} */
        binaryExpression: SyncBailHook<[BinaryExpression], boolean | void>;
        /** @type {HookMap<SyncBailHook<[Expression], boolean | void>>} */
        expression: HookMap<SyncBailHook<[Expression], boolean | void>>;
        /** @type {HookMap<SyncBailHook<[MemberExpression, string[], boolean[], Range[]], boolean | void>>} */
        expressionMemberChain: HookMap<SyncBailHook<[MemberExpression, string[], boolean[], Range[]], boolean | void>>;
        /** @type {HookMap<SyncBailHook<[MemberExpression, string[]], boolean | void>>} */
        unhandledExpressionMemberChain: HookMap<SyncBailHook<[MemberExpression, string[]], boolean | void>>;
        /** @type {SyncBailHook<[ConditionalExpression], boolean | void>} */
        expressionConditionalOperator: SyncBailHook<[ConditionalExpression], boolean | void>;
        /** @type {SyncBailHook<[LogicalExpression], boolean | void>} */
        expressionLogicalOperator: SyncBailHook<[LogicalExpression], boolean | void>;
        /** @type {SyncBailHook<[Program, Comment[]], boolean | void>} */
        program: SyncBailHook<[Program, Comment[]], boolean | void>;
        /** @type {SyncBailHook<[Program, Comment[]], boolean | void>} */
        finish: SyncBailHook<[Program, Comment[]], boolean | void>;
    }>;
    sourceType: "auto" | "module" | "script";
    /** @type {ScopeInfo} */
    scope: ScopeInfo;
    /** @type {ParserState} */
    state: ParserState;
    comments: any;
    semicolons: any;
    /** @type {(Statement | ModuleDeclaration | Expression)[]} */
    statementPath: (Statement | ModuleDeclaration | Expression)[];
    /** @type {Statement | ModuleDeclaration | Expression | undefined} */
    prevStatement: Statement | ModuleDeclaration | Expression | undefined;
    /** @type {WeakMap<Expression, Set<string>>} */
    destructuringAssignmentProperties: WeakMap<Expression, Set<string>>;
    currentTagData: any;
    _initializeEvaluating(): void;
    /**
     * @param {Expression} node node
     * @returns {Set<string>|undefined} destructured identifiers
     */
    destructuringAssignmentPropertiesFor(node: Expression): Set<string> | undefined;
    /**
     * @param {Expression} expr expression
     * @returns {string | VariableInfoInterface | undefined} identifier
     */
    getRenameIdentifier(expr: Expression): string | VariableInfoInterface | undefined;
    /**
     * @param {ClassExpression | ClassDeclaration} classy a class node
     * @returns {void}
     */
    walkClass(classy: ClassExpression | ClassDeclaration): void;
    /**
     * Pre walking iterates the scope for variable declarations
     *
     * @param {(Statement | ModuleDeclaration)[]} statements statements
     */
    preWalkStatements(statements: (Statement | ModuleDeclaration)[]): void;
    /**
     * Block pre walking iterates the scope for block variable declarations
     *
     * @param {(Statement | ModuleDeclaration)[]} statements statements
     */
    blockPreWalkStatements(statements: (Statement | ModuleDeclaration)[]): void;
    /**
     * Walking iterates the statements and expressions and processes them
     *
     * @param {(Statement | ModuleDeclaration)[]} statements statements
     */
    walkStatements(statements: (Statement | ModuleDeclaration)[]): void;
    /**
     * Walking iterates the statements and expressions and processes them
     *
     * @param {Statement | ModuleDeclaration} statement statement
     */
    preWalkStatement(statement: Statement | ModuleDeclaration): void;
    /**
     * @param {Statement | ModuleDeclaration} statement statement
     */
    blockPreWalkStatement(statement: Statement | ModuleDeclaration): void;
    /**
     * @param {Statement | ModuleDeclaration} statement statement
     */
    walkStatement(statement: Statement | ModuleDeclaration): void;
    /**
     * Walks a statements that is nested within a parent statement
     * and can potentially be a non-block statement.
     * This enforces the nested statement to never be in ASI position.
     *
     * @param {Statement} statement the nested statement
     */
    walkNestedStatement(statement: Statement): void;
    /**
     * @param {BlockStatement} statement block statement
     */
    preWalkBlockStatement(statement: BlockStatement): void;
    /**
     * @param {BlockStatement} statement block statement
     */
    walkBlockStatement(statement: BlockStatement): void;
    /**
     * @param {ExpressionStatement} statement expression statement
     */
    walkExpressionStatement(statement: ExpressionStatement): void;
    /**
     * @param {IfStatement} statement if statement
     */
    preWalkIfStatement(statement: IfStatement): void;
    /**
     * @param {IfStatement} statement if statement
     */
    walkIfStatement(statement: IfStatement): void;
    /**
     * @param {LabeledStatement} statement with statement
     */
    preWalkLabeledStatement(statement: LabeledStatement): void;
    /**
     * @param {LabeledStatement} statement with statement
     */
    walkLabeledStatement(statement: LabeledStatement): void;
    /**
     * @param {WithStatement} statement with statement
     */
    preWalkWithStatement(statement: WithStatement): void;
    /**
     * @param {WithStatement} statement with statement
     */
    walkWithStatement(statement: WithStatement): void;
    /**
     * @param {SwitchStatement} statement switch statement
     */
    preWalkSwitchStatement(statement: SwitchStatement): void;
    /**
     * @param {SwitchStatement} statement switch statement
     */
    walkSwitchStatement(statement: SwitchStatement): void;
    /**
     * @param {ReturnStatement | ThrowStatement} statement return or throw statement
     */
    walkTerminatingStatement(statement: ReturnStatement | ThrowStatement): void;
    /**
     * @param {ReturnStatement} statement return statement
     */
    walkReturnStatement(statement: ReturnStatement): void;
    /**
     * @param {ThrowStatement} statement return statement
     */
    walkThrowStatement(statement: ThrowStatement): void;
    /**
     * @param {TryStatement} statement try statement
     */
    preWalkTryStatement(statement: TryStatement): void;
    /**
     * @param {TryStatement} statement try statement
     */
    walkTryStatement(statement: TryStatement): void;
    /**
     * @param {WhileStatement} statement while statement
     */
    preWalkWhileStatement(statement: WhileStatement): void;
    /**
     * @param {WhileStatement} statement while statement
     */
    walkWhileStatement(statement: WhileStatement): void;
    /**
     * @param {DoWhileStatement} statement do while statement
     */
    preWalkDoWhileStatement(statement: DoWhileStatement): void;
    /**
     * @param {DoWhileStatement} statement do while statement
     */
    walkDoWhileStatement(statement: DoWhileStatement): void;
    /**
     * @param {ForStatement} statement for statement
     */
    preWalkForStatement(statement: ForStatement): void;
    /**
     * @param {ForStatement} statement for statement
     */
    walkForStatement(statement: ForStatement): void;
    /**
     * @param {ForInStatement} statement for statement
     */
    preWalkForInStatement(statement: ForInStatement): void;
    /**
     * @param {ForInStatement} statement for statement
     */
    walkForInStatement(statement: ForInStatement): void;
    preWalkForOfStatement(statement: any): void;
    /**
     * @param {ForOfStatement} statement for statement
     */
    walkForOfStatement(statement: ForOfStatement): void;
    /**
     * @param {FunctionDeclaration} statement function declaration
     */
    preWalkFunctionDeclaration(statement: FunctionDeclaration): void;
    /**
     * @param {FunctionDeclaration} statement function declaration
     */
    walkFunctionDeclaration(statement: FunctionDeclaration): void;
    /**
     * @param {ExpressionStatement} statement expression statement
     */
    blockPreWalkExpressionStatement(statement: ExpressionStatement): void;
    /**
     * @param {AssignmentExpression} expression assignment expression
     */
    preWalkAssignmentExpression(expression: AssignmentExpression): void;
    blockPreWalkImportDeclaration(statement: any): void;
    enterDeclaration(declaration: any, onIdent: any): void;
    blockPreWalkExportNamedDeclaration(statement: any): void;
    /**
     * @param {ExportNamedDeclaration} statement the statement
     */
    walkExportNamedDeclaration(statement: ExportNamedDeclaration): void;
    blockPreWalkExportDefaultDeclaration(statement: any): void;
    walkExportDefaultDeclaration(statement: any): void;
    blockPreWalkExportAllDeclaration(statement: any): void;
    /**
     * @param {VariableDeclaration} statement variable declaration
     */
    preWalkVariableDeclaration(statement: VariableDeclaration): void;
    /**
     * @param {VariableDeclaration} statement variable declaration
     */
    blockPreWalkVariableDeclaration(statement: VariableDeclaration): void;
    /**
     * @param {VariableDeclaration} statement variable declaration
     * @param {TODO} hookMap map of hooks
     */
    _preWalkVariableDeclaration(statement: VariableDeclaration, hookMap: TODO): void;
    /**
     * @param {ObjectPattern} objectPattern object pattern
     * @returns {Set<string> | undefined} set of names or undefined if not all keys are identifiers
     */
    _preWalkObjectPattern(objectPattern: ObjectPattern): Set<string> | undefined;
    /**
     * @param {VariableDeclarator} declarator variable declarator
     */
    preWalkVariableDeclarator(declarator: VariableDeclarator): void;
    /**
     * @param {VariableDeclaration} statement variable declaration
     */
    walkVariableDeclaration(statement: VariableDeclaration): void;
    /**
     * @param {ClassDeclaration} statement class declaration
     */
    blockPreWalkClassDeclaration(statement: ClassDeclaration): void;
    /**
     * @param {ClassDeclaration} statement class declaration
     */
    walkClassDeclaration(statement: ClassDeclaration): void;
    /**
     * @param {SwitchCase[]} switchCases switch statement
     */
    preWalkSwitchCases(switchCases: SwitchCase[]): void;
    /**
     * @param {SwitchCase[]} switchCases switch statement
     */
    walkSwitchCases(switchCases: SwitchCase[]): void;
    /**
     * @param {CatchClause} catchClause catch clause
     */
    preWalkCatchClause(catchClause: CatchClause): void;
    /**
     * @param {CatchClause} catchClause catch clause
     */
    walkCatchClause(catchClause: CatchClause): void;
    /**
     * @param {Pattern} pattern pattern
     */
    walkPattern(pattern: Pattern): void;
    /**
     * @param {AssignmentPattern} pattern assignment pattern
     */
    walkAssignmentPattern(pattern: AssignmentPattern): void;
    walkObjectPattern(pattern: any): void;
    /**
     * @param {ArrayPattern} pattern array pattern
     */
    walkArrayPattern(pattern: ArrayPattern): void;
    /**
     * @param {RestElement} pattern rest element
     */
    walkRestElement(pattern: RestElement): void;
    /**
     * @param {(Expression | SpreadElement | null)[]} expressions expressions
     */
    walkExpressions(expressions: (Expression | SpreadElement | null)[]): void;
    /**
     * @param {TODO} expression expression
     */
    walkExpression(expression: TODO): void;
    /**
     * @param {AwaitExpression} expression await expression
     */
    walkAwaitExpression(expression: AwaitExpression): void;
    /**
     * @param {ArrayExpression} expression array expression
     */
    walkArrayExpression(expression: ArrayExpression): void;
    /**
     * @param {SpreadElement} expression spread element
     */
    walkSpreadElement(expression: SpreadElement): void;
    /**
     * @param {ObjectExpression} expression object expression
     */
    walkObjectExpression(expression: ObjectExpression): void;
    /**
     * @param {Property | SpreadElement} prop property or spread element
     */
    walkProperty(prop: Property | SpreadElement): void;
    /**
     * @param {FunctionExpression} expression arrow function expression
     */
    walkFunctionExpression(expression: FunctionExpression): void;
    /**
     * @param {ArrowFunctionExpression} expression arrow function expression
     */
    walkArrowFunctionExpression(expression: ArrowFunctionExpression): void;
    /**
     * @param {SequenceExpression} expression the sequence
     */
    walkSequenceExpression(expression: SequenceExpression): void;
    /**
     * @param {UpdateExpression} expression the update expression
     */
    walkUpdateExpression(expression: UpdateExpression): void;
    /**
     * @param {UnaryExpression} expression the unary expression
     */
    walkUnaryExpression(expression: UnaryExpression): void;
    /**
     * @param {LogicalExpression | BinaryExpression} expression the expression
     */
    walkLeftRightExpression(expression: LogicalExpression | BinaryExpression): void;
    /**
     * @param {BinaryExpression} expression the binary expression
     */
    walkBinaryExpression(expression: BinaryExpression): void;
    /**
     * @param {LogicalExpression} expression the logical expression
     */
    walkLogicalExpression(expression: LogicalExpression): void;
    /**
     * @param {AssignmentExpression} expression assignment expression
     */
    walkAssignmentExpression(expression: AssignmentExpression): void;
    /**
     * @param {ConditionalExpression} expression conditional expression
     */
    walkConditionalExpression(expression: ConditionalExpression): void;
    /**
     * @param {NewExpression} expression new expression
     */
    walkNewExpression(expression: NewExpression): void;
    /**
     * @param {YieldExpression} expression yield expression
     */
    walkYieldExpression(expression: YieldExpression): void;
    /**
     * @param {TemplateLiteral} expression template literal
     */
    walkTemplateLiteral(expression: TemplateLiteral): void;
    /**
     * @param {TaggedTemplateExpression} expression tagged template expression
     */
    walkTaggedTemplateExpression(expression: TaggedTemplateExpression): void;
    /**
     * @param {ClassExpression} expression the class expression
     */
    walkClassExpression(expression: ClassExpression): void;
    /**
     * @param {ChainExpression} expression expression
     */
    walkChainExpression(expression: ChainExpression): void;
    _walkIIFE(functionExpression: any, options: any, currentThis: any): void;
    /**
     * @param {ImportExpression} expression import expression
     */
    walkImportExpression(expression: ImportExpression): void;
    walkCallExpression(expression: any): void;
    /**
     * @param {MemberExpression} expression member expression
     */
    walkMemberExpression(expression: MemberExpression): void;
    walkMemberExpressionWithExpressionName(expression: any, name: any, rootInfo: any, members: any, onUnhandled: any): void;
    /**
     * @param {ThisExpression} expression this expression
     */
    walkThisExpression(expression: ThisExpression): void;
    /**
     * @param {Identifier} expression identifier
     */
    walkIdentifier(expression: Identifier): void;
    /**
     * @param {MetaProperty} metaProperty meta property
     */
    walkMetaProperty(metaProperty: MetaProperty): void;
    callHooksForExpression(hookMap: any, expr: any, ...args: any[]): any;
    /**
     * @template T
     * @template R
     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called
     * @param {MemberExpression} expr expression info
     * @param {(function(string, string | ScopeInfo | VariableInfo, function(): string[]): any) | undefined} fallback callback when variable in not handled by hooks
     * @param {(function(string): any) | undefined} defined callback when variable is defined
     * @param {AsArray<T>} args args for the hook
     * @returns {R | undefined} result of hook
     */
    callHooksForExpressionWithFallback<T, R>(hookMap: HookMap<SyncBailHook<T, R, import("tapable").UnsetAdditionalOptions>>, expr: MemberExpression, fallback: ((arg0: string, arg1: string | ScopeInfo | VariableInfo, arg2: () => string[]) => any) | undefined, defined: ((arg0: string) => any) | undefined, ...args: import("tapable").AsArray<T>): R;
    /**
     * @template T
     * @template R
     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called
     * @param {string} name key in map
     * @param {AsArray<T>} args args for the hook
     * @returns {R | undefined} result of hook
     */
    callHooksForName<T_1, R_1>(hookMap: HookMap<SyncBailHook<T_1, R_1, import("tapable").UnsetAdditionalOptions>>, name: string, ...args: import("tapable").AsArray<T_1>): R_1;
    /**
     * @template T
     * @template R
     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks that should be called
     * @param {ExportedVariableInfo} info variable info
     * @param  {AsArray<T>} args args for the hook
     * @returns {R | undefined} result of hook
     */
    callHooksForInfo<T_2, R_2>(hookMap: HookMap<SyncBailHook<T_2, R_2, import("tapable").UnsetAdditionalOptions>>, info: ExportedVariableInfo, ...args: import("tapable").AsArray<T_2>): R_2;
    /**
     * @template T
     * @template R
     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called
     * @param {ExportedVariableInfo} info variable info
     * @param {(function(string): any) | undefined} fallback callback when variable in not handled by hooks
     * @param {(function(): any) | undefined} defined callback when variable is defined
     * @param {AsArray<T>} args args for the hook
     * @returns {R | undefined} result of hook
     */
    callHooksForInfoWithFallback<T_3, R_3>(hookMap: HookMap<SyncBailHook<T_3, R_3, import("tapable").UnsetAdditionalOptions>>, info: ExportedVariableInfo, fallback: ((arg0: string) => any) | undefined, defined: (() => any) | undefined, ...args: import("tapable").AsArray<T_3>): R_3;
    /**
     * @template T
     * @template R
     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called
     * @param {string} name key in map
     * @param {(function(string): any) | undefined} fallback callback when variable in not handled by hooks
     * @param {(function(): any) | undefined} defined callback when variable is defined
     * @param {AsArray<T>} args args for the hook
     * @returns {R | undefined} result of hook
     */
    callHooksForNameWithFallback<T_4, R_4>(hookMap: HookMap<SyncBailHook<T_4, R_4, import("tapable").UnsetAdditionalOptions>>, name: string, fallback: ((arg0: string) => any) | undefined, defined: (() => any) | undefined, ...args: import("tapable").AsArray<T_4>): R_4;
    /**
     * @deprecated
     * @param {any} params scope params
     * @param {function(): void} fn inner function
     * @returns {void}
     */
    inScope(params: any, fn: () => void): void;
    /**
     * @param {boolean} hasThis true, when this is defined
     * @param {any} params scope params
     * @param {function(): void} fn inner function
     * @returns {void}
     */
    inClassScope(hasThis: boolean, params: any, fn: () => void): void;
    /**
     * @param {boolean} hasThis true, when this is defined
     * @param {any} params scope params
     * @param {function(): void} fn inner function
     * @returns {void}
     */
    inFunctionScope(hasThis: boolean, params: any, fn: () => void): void;
    /**
     * @param {function(): void} fn inner function
     * @returns {void}
     */
    inBlockScope(fn: () => void): void;
    /**
     * @param {Array<Directive | Statement | ModuleDeclaration>} statements statements
     */
    detectMode(statements: Array<Directive | Statement | ModuleDeclaration>): void;
    enterPatterns(patterns: any, onIdent: any): void;
    enterPattern(pattern: any, onIdent: any): void;
    /**
     * @param {Identifier} pattern identifier pattern
     * @param {TODO} onIdent callback
     */
    enterIdentifier(pattern: Identifier, onIdent: TODO): void;
    /**
     * @param {ObjectPattern} pattern object pattern
     * @param {TODO} onIdent callback
     */
    enterObjectPattern(pattern: ObjectPattern, onIdent: TODO): void;
    /**
     * @param {ArrayPattern} pattern object pattern
     * @param {TODO} onIdent callback
     */
    enterArrayPattern(pattern: ArrayPattern, onIdent: TODO): void;
    /**
     * @param {RestElement} pattern object pattern
     * @param {TODO} onIdent callback
     */
    enterRestElement(pattern: RestElement, onIdent: TODO): void;
    /**
     * @param {AssignmentPattern} pattern object pattern
     * @param {TODO} onIdent callback
     */
    enterAssignmentPattern(pattern: AssignmentPattern, onIdent: TODO): void;
    /**
     * @param {TODO} expression expression node
     * @returns {BasicEvaluatedExpression} evaluation result
     */
    evaluateExpression(expression: TODO): BasicEvaluatedExpression;
    /**
     * @param {Expression} expression expression
     * @returns {string} parsed string
     */
    parseString(expression: Expression): string;
    parseCalculatedString(expression: any): any;
    /**
     * @param {string} source source code
     * @returns {BasicEvaluatedExpression} evaluation result
     */
    evaluate(source: string): BasicEvaluatedExpression;
    /**
     * @param {Expression | Declaration | PrivateIdentifier | null | undefined} expr an expression
     * @param {number} commentsStartPos source position from which annotation comments are checked
     * @returns {boolean} true, when the expression is pure
     */
    isPure(expr: Expression | Declaration | PrivateIdentifier | null | undefined, commentsStartPos: number): boolean;
    /**
     * @param {Range} range range
     * @returns {TODO[]} comments in the range
     */
    getComments(range: Range): TODO[];
    /**
     * @param {number} pos source code position
     * @returns {boolean} true when a semicolon has been inserted before this position, false if not
     */
    isAsiPosition(pos: number): boolean;
    /**
     * @param {number} pos source code position
     * @returns {void}
     */
    unsetAsiPosition(pos: number): void;
    /**
     * @param {Expression} expr expression
     * @returns {boolean} true, when the expression is a statement level expression
     */
    isStatementLevelExpression(expr: Expression): boolean;
    getTagData(name: any, tag: any): any;
    tagVariable(name: any, tag: any, data: any): void;
    /**
     * @param {string} name variable name
     */
    defineVariable(name: string): void;
    /**
     * @param {string} name variable name
     */
    undefineVariable(name: string): void;
    /**
     * @param {string} name variable name
     * @returns {boolean} true, when variable is defined
     */
    isVariableDefined(name: string): boolean;
    /**
     * @param {string} name variable name
     * @returns {ExportedVariableInfo} info for this variable
     */
    getVariableInfo(name: string): ExportedVariableInfo;
    /**
     * @param {string} name variable name
     * @param {ExportedVariableInfo} variableInfo new info for this variable
     * @returns {void}
     */
    setVariable(name: string, variableInfo: ExportedVariableInfo): void;
    /**
     * @param {TagInfo} tagInfo tag info
     * @returns {VariableInfo} variable info
     */
    evaluatedVariable(tagInfo: TagInfo): VariableInfo;
    /**
     * @param {Range} range range of the comment
     * @returns {TODO} TODO
     */
    parseCommentOptions(range: Range): TODO;
    /**
     * @param {MemberExpression} expression a member expression
     * @returns {{ members: string[], object: Expression | Super, membersOptionals: boolean[], memberRanges: Range[] }} member names (reverse order) and remaining object
     */
    extractMemberExpressionChain(expression: MemberExpression): {
        members: string[];
        object: Expression | Super;
        membersOptionals: boolean[];
        memberRanges: Range[];
    };
    /**
     * @param {string} varName variable name
     * @returns {{name: string, info: VariableInfo | string} | undefined} name of the free variable and variable info for that
     */
    getFreeInfoFromVariable(varName: string): {
        name: string;
        info: VariableInfo | string;
    };
    /** @typedef {{ type: "call", call: CallExpression, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]}} CallExpressionInfo */
    /** @typedef {{ type: "expression", rootInfo: string | VariableInfo, name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]}} ExpressionExpressionInfo */
    /**
     * @param {MemberExpression} expression a member expression
     * @param {number} allowedTypes which types should be returned, presented in bit mask
     * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info
     */
    getMemberExpressionInfo(expression: MemberExpression, allowedTypes: number): {
        type: "call";
        call: CallExpression;
        calleeName: string;
        rootInfo: string | VariableInfo;
        getCalleeMembers: () => string[];
        name: string;
        getMembers: () => string[];
        getMembersOptionals: () => boolean[];
        getMemberRanges: () => Range[];
    } | {
        type: "expression";
        rootInfo: string | VariableInfo;
        name: string;
        getMembers: () => string[];
        getMembersOptionals: () => boolean[];
        getMemberRanges: () => Range[];
    };
    /**
     * @param {MemberExpression} expression an expression
     * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]} | undefined} name info
     */
    getNameForExpression(expression: MemberExpression): {
        name: string;
        rootInfo: ExportedVariableInfo;
        getMembers: () => string[];
    } | undefined;
}
declare namespace JavascriptParser {
    export { ALLOWED_MEMBER_TYPES_ALL, ALLOWED_MEMBER_TYPES_EXPRESSION, ALLOWED_MEMBER_TYPES_CALL_EXPRESSION, AcornOptions, AssignmentExpression, BinaryExpression, BlockStatement, SequenceExpression, CallExpression, BaseCallExpression, StaticBlock, ImportExpression, ClassDeclaration, ForStatement, SwitchStatement, ExportNamedDeclaration, ClassExpression, Comment, ConditionalExpression, Declaration, PrivateIdentifier, PropertyDefinition, Expression, Identifier, VariableDeclaration, IfStatement, LabeledStatement, Literal, LogicalExpression, ChainExpression, MemberExpression, YieldExpression, MetaProperty, Property, AssignmentPattern, ChainElement, Pattern, UpdateExpression, ObjectExpression, UnaryExpression, ArrayExpression, ArrayPattern, AwaitExpression, ThisExpression, RestElement, ObjectPattern, SwitchCase, CatchClause, VariableDeclarator, ForInStatement, ForOfStatement, ReturnStatement, WithStatement, ThrowStatement, MethodDefinition, ModuleDeclaration, NewExpression, SpreadElement, FunctionExpression, WhileStatement, ArrowFunctionExpression, ExpressionStatement, FunctionDeclaration, DoWhileStatement, TryStatement, AnyNode, Program, Directive, Statement, ImportDeclaration, ExportDefaultDeclaration, ExportAllDeclaration, Super, TaggedTemplateExpression, TemplateLiteral, Assertions, AsArray, ParserState, PreparsedAst, VariableInfoInterface, GetInfoResult, ExportedVariableInfo, ImportSource, ParseOptions, TagInfo, ScopeInfo, Range };
}
import Parser = require("webpack/lib/Parser");
import { HookMap } from "tapable";
import { SyncBailHook } from "tapable";
type UnaryExpression = import("estree").UnaryExpression;
import BasicEvaluatedExpression = require("webpack/lib/javascript/BasicEvaluatedExpression");
type Expression = import("estree").Expression;
type Identifier = import("estree").Identifier;
type ThisExpression = import("estree").ThisExpression;
type MemberExpression = import("estree").MemberExpression;
type MetaProperty = import("estree").MetaProperty;
type NewExpression = import("estree").NewExpression;
type CallExpression = import("estree").CallExpression;
type Declaration = import("estree").Declaration;
type PrivateIdentifier = import("estree").PrivateIdentifier;
type Statement = import("estree").Statement;
type ModuleDeclaration = import("estree").ModuleDeclaration;
type IfStatement = import("estree").IfStatement;
type ClassExpression = import("estree").ClassExpression;
type ClassDeclaration = import("estree").ClassDeclaration;
type MethodDefinition = import("estree").MethodDefinition;
type PropertyDefinition = import("estree").PropertyDefinition;
type StaticBlock = import("estree").StaticBlock;
type LabeledStatement = import("estree").LabeledStatement;
type ImportDeclaration = import("estree").ImportDeclaration;
type ImportSource = Literal | string | null | undefined;
type ExportNamedDeclaration = import("estree").ExportNamedDeclaration;
type ExportAllDeclaration = import("estree").ExportAllDeclaration;
type ExportDefaultDeclaration = import("estree").ExportDefaultDeclaration;
type VariableDeclarator = import("estree").VariableDeclarator;
type AssignmentExpression = import("estree").AssignmentExpression;
type ImportExpression = import("estree").ImportExpression;
type Range = [number, number];
type ChainExpression = import("estree").ChainExpression;
type BinaryExpression = import("estree").BinaryExpression;
type ConditionalExpression = import("estree").ConditionalExpression;
type LogicalExpression = import("estree").LogicalExpression;
type Program = import("estree").Program;
type Comment = import("estree").Comment;
type ScopeInfo = {
    definitions: StackedMap<string, VariableInfo | ScopeInfo>;
    topLevelScope: boolean | "arrow";
    inShorthand: boolean | string;
    inTaggedTemplateTag: boolean;
    inTry: boolean;
    isStrict: boolean;
    isAsmJs: boolean;
};
type ParserState = import("../Parser").ParserState;
type VariableInfoInterface = {
    declaredScope: ScopeInfo;
    freeName: string | true;
    tagInfo: TagInfo | undefined;
};
type BlockStatement = import("estree").BlockStatement;
type ExpressionStatement = import("estree").ExpressionStatement;
type WithStatement = import("estree").WithStatement;
type SwitchStatement = import("estree").SwitchStatement;
type ReturnStatement = import("estree").ReturnStatement;
type ThrowStatement = import("estree").ThrowStatement;
type TryStatement = import("estree").TryStatement;
type WhileStatement = import("estree").WhileStatement;
type DoWhileStatement = import("estree").DoWhileStatement;
type ForStatement = import("estree").ForStatement;
type ForInStatement = import("estree").ForInStatement;
type ForOfStatement = import("estree").ForOfStatement;
type FunctionDeclaration = import("estree").FunctionDeclaration;
type VariableDeclaration = import("estree").VariableDeclaration;
type ObjectPattern = import("estree").ObjectPattern;
type SwitchCase = import("estree").SwitchCase;
type CatchClause = import("estree").CatchClause;
type Pattern = import("estree").Pattern;
type AssignmentPattern = import("estree").AssignmentPattern;
type ArrayPattern = import("estree").ArrayPattern;
type RestElement = import("estree").RestElement;
type SpreadElement = import("estree").SpreadElement;
type AwaitExpression = import("estree").AwaitExpression;
type ArrayExpression = import("estree").ArrayExpression;
type ObjectExpression = import("estree").ObjectExpression;
type Property = import("estree").Property;
type FunctionExpression = import("estree").FunctionExpression;
type ArrowFunctionExpression = import("estree").ArrowFunctionExpression;
type SequenceExpression = import("estree").SequenceExpression;
type UpdateExpression = import("estree").UpdateExpression;
type YieldExpression = import("estree").YieldExpression;
type TemplateLiteral = import("estree").TemplateLiteral;
type TaggedTemplateExpression = import("estree").TaggedTemplateExpression;
declare class VariableInfo {
    /**
     * @param {ScopeInfo} declaredScope scope in which the variable is declared
     * @param {string | true | undefined} freeName which free name the variable aliases, or true when none
     * @param {TagInfo | undefined} tagInfo info about tags
     */
    constructor(declaredScope: ScopeInfo, freeName: string | true | undefined, tagInfo: TagInfo | undefined);
    declaredScope: ScopeInfo;
    freeName: string | true;
    tagInfo: TagInfo;
}
/**
 * <T>
 */
type AsArray<T> = import("tapable").AsArray<T>;
type ExportedVariableInfo = string | ScopeInfo | VariableInfo;
type Directive = import("estree").Directive;
type TagInfo = {
    tag: any;
    data: any;
    next: TagInfo | undefined;
};
type Super = import("estree").Super;
type ParseOptions = Omit<AcornOptions, "sourceType" | "ecmaVersion"> & {
    sourceType: "module" | "script" | "auto";
    ecmaVersion?: AcornOptions["ecmaVersion"];
};
declare const ALLOWED_MEMBER_TYPES_ALL: 3;
declare const ALLOWED_MEMBER_TYPES_EXPRESSION: 2;
declare const ALLOWED_MEMBER_TYPES_CALL_EXPRESSION: 1;
type AcornOptions = import("acorn").Options;
type BaseCallExpression = import("estree").BaseCallExpression;
type Literal = import("estree").Literal;
type ChainElement = import("estree").ChainElement;
type AnyNode = import("estree").Node;
type Assertions = Record<string, any>;
type PreparsedAst = import("../Parser").PreparsedAst;
type GetInfoResult = {
    name: string | VariableInfo;
    rootInfo: string | VariableInfo;
    getMembers: () => string[];
    getMembersOptionals: () => boolean[];
    getMemberRanges: () => [number, number][];
};
import StackedMap = require("webpack/lib/util/StackedMap");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/javascript/JavascriptParserHelpers.d.ts
export function toConstantDependency(parser: JavascriptParser, value: string, runtimeRequirements?: string[] | undefined): (arg0: Expression) => true;
export function evaluateToString(value: string): (arg0: Expression) => BasicEvaluatedExpression;
export function evaluateToNumber(value: number): (arg0: Expression) => BasicEvaluatedExpression;
export function evaluateToBoolean(value: boolean): (arg0: Expression) => BasicEvaluatedExpression;
export function evaluateToIdentifier(identifier: string, rootInfo: string, getMembers: () => string[], truthy?: (boolean | null) | undefined): (arg0: Expression) => BasicEvaluatedExpression;
export function expressionIsUnsupported(parser: JavascriptParser, message: string): (arg0: Expression) => boolean | undefined;
export function skipTraversal(): boolean;
export function approve(): boolean;
export type Expression = import("estree").Expression;
export type Node = import("estree").Node;
export type SourceLocation = import("estree").SourceLocation;
export type JavascriptParser = import("./JavascriptParser");
export type Range = import("./JavascriptParser").Range;
import BasicEvaluatedExpression = require("webpack/lib/javascript/BasicEvaluatedExpression");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/javascript/StartupHelpers.d.ts
export function generateEntryStartup(chunkGraph: ChunkGraph, runtimeTemplate: RuntimeTemplate, entries: import("webpack/lib/ChunkGraph").EntryModuleWithChunkGroup[], chunk: Chunk, passive: boolean): string;
export function updateHashForEntryStartup(hash: Hash, chunkGraph: ChunkGraph, entries: import("webpack/lib/ChunkGraph").EntryModuleWithChunkGroup[], chunk: Chunk): void;
export function getInitialChunkIds(chunk: Chunk, chunkGraph: ChunkGraph, filterFn: (arg0: Chunk, arg1: ChunkGraph) => boolean): Set<number | string>;
export type Hash = import("../util/Hash");
export type Chunk = import("../Chunk");
export type Compilation = import("../Compilation");
export type ChunkGraph = import("../ChunkGraph");
export type EntryModuleWithChunkGroup = import("../ChunkGraph").EntryModuleWithChunkGroup;
export type ChunkGroup = import("../ChunkGroup");
export type RuntimeTemplate = import("../RuntimeTemplate");
export type EntryItem = (string | number)[];

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/json/JsonData.d.ts
export = JsonData;
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import("../util/Hash")} Hash */
/** @typedef {import("./JsonModulesPlugin").RawJsonData} RawJsonData */
declare class JsonData {
    /**
     * @param {Buffer | RawJsonData} data JSON data
     */
    constructor(data: Buffer | RawJsonData);
    /** @type {Buffer | undefined} */
    _buffer: Buffer | undefined;
    /** @type {RawJsonData | undefined} */
    _data: RawJsonData | undefined;
    /**
     * @returns {RawJsonData|undefined} Raw JSON data
     */
    get(): RawJsonData | undefined;
    /**
     * @param {Hash} hash hash to be updated
     * @returns {void} the updated hash
     */
    updateHash(hash: Hash): void;
}
declare namespace JsonData {
    export { ObjectDeserializerContext, ObjectSerializerContext, Hash, RawJsonData };
}
type RawJsonData = import("./JsonModulesPlugin").RawJsonData;
type Hash = import("../util/Hash");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/json/JsonGenerator.d.ts
export = JsonGenerator;
declare class JsonGenerator extends Generator {
}
declare namespace JsonGenerator {
    export { Source, ExportsInfo, GenerateContext, ConcatenationBailoutReasonContext, NormalModule, RuntimeSpec, JsonData, RawJsonData };
}
import Generator = require("webpack/lib/Generator");
type Source = import("webpack-sources").Source;
type ExportsInfo = import("../ExportsInfo");
type GenerateContext = import("../Generator").GenerateContext;
type ConcatenationBailoutReasonContext = import("../Module").ConcatenationBailoutReasonContext;
type NormalModule = import("../NormalModule");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
type JsonData = import("./JsonData");
type RawJsonData = import("./JsonModulesPlugin").RawJsonData;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/json/JsonModulesPlugin.d.ts
export = JsonModulesPlugin;
/**
 * The JsonModulesPlugin is the entrypoint plugin for the json modules feature.
 * It adds the json module type to the compiler and registers the json parser and generator.
 */
declare class JsonModulesPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     *
     */
    apply(compiler: Compiler): void;
}
declare namespace JsonModulesPlugin {
    export { Compiler, RawJsonData };
}
type Compiler = import("../Compiler");
type RawJsonData = Record<string, any>;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/json/JsonParser.d.ts
export = JsonParser;
declare class JsonParser extends Parser {
    /**
     * @param {JsonModulesPluginParserOptions} options parser options
     */
    constructor(options: any);
    options: any;
}
declare namespace JsonParser {
    export { JsonModulesPluginParserOptions, BuildInfo, BuildMeta, ParserState, PreparsedAst, RawJsonData };
}
import Parser = require("webpack/lib/Parser");
type JsonModulesPluginParserOptions = any;
type BuildInfo = import("../Module").BuildInfo;
type BuildMeta = import("../Module").BuildMeta;
type ParserState = import("../Parser").ParserState;
type PreparsedAst = import("../Parser").PreparsedAst;
type RawJsonData = import("./JsonModulesPlugin").RawJsonData;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/library/AbstractLibraryPlugin.d.ts
export = AbstractLibraryPlugin;
/**
 * @template T
 * @typedef {Object} LibraryContext
 * @property {Compilation} compilation
 * @property {ChunkGraph} chunkGraph
 * @property {T} options
 */
/**
 * @template T
 */
declare class AbstractLibraryPlugin<T> {
    /**
     * @param {Object} options options
     * @param {string} options.pluginName name of the plugin
     * @param {LibraryType} options.type used library type
     */
    constructor({ pluginName, type }: {
        pluginName: string;
        type: LibraryType;
    });
    _pluginName: string;
    _type: any;
    _parseCache: WeakMap<object, any>;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
    /**
     * @param {LibraryOptions=} library normalized library option
     * @returns {T | false} preprocess as needed by overriding
     */
    _parseOptionsCached(library?: any): T | false;
    /**
     * @abstract
     * @param {LibraryOptions} library normalized library option
     * @returns {T | false} preprocess as needed by overriding
     */
    parseOptions(library: any): T | false;
    /**
     * @param {Module} module the exporting entry module
     * @param {string} entryName the name of the entrypoint
     * @param {LibraryContext<T>} libraryContext context
     * @returns {void}
     */
    finishEntryModule(module: Module, entryName: string, libraryContext: LibraryContext<T>): void;
    /**
     * @param {Module} module the exporting entry module
     * @param {RenderContext} renderContext render context
     * @param {LibraryContext<T>} libraryContext context
     * @returns {string | undefined} bailout reason
     */
    embedInRuntimeBailout(module: Module, renderContext: RenderContext, libraryContext: LibraryContext<T>): string | undefined;
    /**
     * @param {RenderContext} renderContext render context
     * @param {LibraryContext<T>} libraryContext context
     * @returns {string | undefined} bailout reason
     */
    strictRuntimeBailout(renderContext: RenderContext, libraryContext: LibraryContext<T>): string | undefined;
    /**
     * @param {Chunk} chunk the chunk
     * @param {Set<string>} set runtime requirements
     * @param {LibraryContext<T>} libraryContext context
     * @returns {void}
     */
    runtimeRequirements(chunk: Chunk, set: Set<string>, libraryContext: LibraryContext<T>): void;
    /**
     * @param {Source} source source
     * @param {RenderContext} renderContext render context
     * @param {LibraryContext<T>} libraryContext context
     * @returns {Source} source with library export
     */
    render(source: Source, renderContext: RenderContext, libraryContext: LibraryContext<T>): Source;
    /**
     * @param {Source} source source
     * @param {Module} module module
     * @param {StartupRenderContext} renderContext render context
     * @param {LibraryContext<T>} libraryContext context
     * @returns {Source} source with library export
     */
    renderStartup(source: Source, module: Module, renderContext: StartupRenderContext, libraryContext: LibraryContext<T>): Source;
    /**
     * @param {Chunk} chunk the chunk
     * @param {Hash} hash hash
     * @param {ChunkHashContext} chunkHashContext chunk hash context
     * @param {LibraryContext<T>} libraryContext context
     * @returns {void}
     */
    chunkHash(chunk: Chunk, hash: Hash, chunkHashContext: ChunkHashContext, libraryContext: LibraryContext<T>): void;
}
declare namespace AbstractLibraryPlugin {
    export { COMMON_LIBRARY_NAME_MESSAGE, Source, LibraryOptions, LibraryType, Chunk, ChunkGraph, Compilation, ChunkHashContext, Compiler, Module, RenderContext, StartupRenderContext, Hash, LibraryContext };
}
type Compiler = import("../Compiler");
type Module = import("../Module");
type LibraryContext<T> = {
    compilation: Compilation;
    chunkGraph: ChunkGraph;
    options: T;
};
type RenderContext = import("../javascript/JavascriptModulesPlugin").RenderContext;
type Chunk = import("../Chunk");
type Source = import("webpack-sources").Source;
type StartupRenderContext = import("../javascript/JavascriptModulesPlugin").StartupRenderContext;
type Hash = import("../util/Hash");
type ChunkHashContext = import("../Compilation").ChunkHashContext;
type LibraryType = any;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../../declarations/WebpackOptions").LibraryOptions} LibraryOptions */
/** @typedef {import("../../declarations/WebpackOptions").LibraryType} LibraryType */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../Compilation").ChunkHashContext} ChunkHashContext */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../javascript/JavascriptModulesPlugin").RenderContext} RenderContext */
/** @typedef {import("../javascript/JavascriptModulesPlugin").StartupRenderContext} StartupRenderContext */
/** @typedef {import("../util/Hash")} Hash */
declare const COMMON_LIBRARY_NAME_MESSAGE: "Common configuration options that specific library names are 'output.library[.name]', 'entry.xyz.library[.name]', 'ModuleFederationPlugin.name' and 'ModuleFederationPlugin.library[.name]'.";
type LibraryOptions = any;
type ChunkGraph = import("../ChunkGraph");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/library/AmdLibraryPlugin.d.ts
export = AmdLibraryPlugin;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../../declarations/WebpackOptions").LibraryOptions} LibraryOptions */
/** @typedef {import("../../declarations/WebpackOptions").LibraryType} LibraryType */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compilation").ChunkHashContext} ChunkHashContext */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../javascript/JavascriptModulesPlugin").RenderContext} RenderContext */
/** @typedef {import("../util/Hash")} Hash */
/** @template T @typedef {import("./AbstractLibraryPlugin").LibraryContext<T>} LibraryContext<T> */
/**
 * @typedef {Object} AmdLibraryPluginOptions
 * @property {LibraryType} type
 * @property {boolean=} requireAsWrapper
 */
/**
 * @typedef {Object} AmdLibraryPluginParsed
 * @property {string} name
 * @property {string} amdContainer
 */
/**
 * @typedef {AmdLibraryPluginParsed} T
 * @extends {AbstractLibraryPlugin<AmdLibraryPluginParsed>}
 */
declare class AmdLibraryPlugin extends AbstractLibraryPlugin<AmdLibraryPluginParsed> {
    /**
     * @param {AmdLibraryPluginOptions} options the plugin options
     */
    constructor(options: AmdLibraryPluginOptions);
    requireAsWrapper: boolean;
}
declare namespace AmdLibraryPlugin {
    export { Source, LibraryOptions, LibraryType, Chunk, ChunkHashContext, Compiler, RenderContext, Hash, LibraryContext, AmdLibraryPluginOptions, AmdLibraryPluginParsed, T };
}
type AmdLibraryPluginParsed = {
    name: string;
    amdContainer: string;
};
import AbstractLibraryPlugin = require("webpack/lib/library/AbstractLibraryPlugin");
type AmdLibraryPluginOptions = {
    type: any;
    requireAsWrapper?: boolean | undefined;
};
type Source = import("webpack-sources").Source;
type LibraryOptions = any;
type LibraryType = any;
type Chunk = import("../Chunk");
type ChunkHashContext = import("../Compilation").ChunkHashContext;
type Compiler = import("../Compiler");
type RenderContext = import("../javascript/JavascriptModulesPlugin").RenderContext;
type Hash = import("../util/Hash");
/**
 * <T>
 */
type LibraryContext<T_1> = import("./AbstractLibraryPlugin").LibraryContext<T>;
type T = AmdLibraryPluginParsed;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/library/AssignLibraryPlugin.d.ts
export = AssignLibraryPlugin;
/**
 * @typedef {Object} AssignLibraryPluginOptions
 * @property {LibraryType} type
 * @property {string[] | "global"} prefix name prefix
 * @property {string | false} declare declare name as variable
 * @property {"error"|"static"|"copy"|"assign"} unnamed behavior for unnamed library name
 * @property {"copy"|"assign"=} named behavior for named library name
 */
/**
 * @typedef {Object} AssignLibraryPluginParsed
 * @property {string | string[]} name
 * @property {string | string[] | undefined} export
 */
/**
 * @typedef {AssignLibraryPluginParsed} T
 * @extends {AbstractLibraryPlugin<AssignLibraryPluginParsed>}
 */
declare class AssignLibraryPlugin extends AbstractLibraryPlugin<AssignLibraryPluginParsed> {
    /**
     * @param {AssignLibraryPluginOptions} options the plugin options
     */
    constructor(options: AssignLibraryPluginOptions);
    prefix: string[] | "global";
    declare: string | false;
    unnamed: "error" | "copy" | "assign" | "static";
    named: "copy" | "assign";
    /**
     * @param {Compilation} compilation the compilation
     * @returns {string[]} the prefix
     */
    _getPrefix(compilation: Compilation): string[];
    /**
     * @param {AssignLibraryPluginParsed} options the library options
     * @param {Chunk} chunk the chunk
     * @param {Compilation} compilation the compilation
     * @returns {Array<string>} the resolved full name
     */
    _getResolvedFullName(options: AssignLibraryPluginParsed, chunk: Chunk, compilation: Compilation): Array<string>;
}
declare namespace AssignLibraryPlugin {
    export { Source, LibraryOptions, LibraryType, Chunk, Compilation, ChunkHashContext, Compiler, Module, RenderContext, StartupRenderContext, Hash, LibraryContext, AssignLibraryPluginOptions, AssignLibraryPluginParsed, T };
}
type AssignLibraryPluginParsed = {
    name: string | string[];
    export: string | string[] | undefined;
};
import AbstractLibraryPlugin = require("webpack/lib/library/AbstractLibraryPlugin");
type Compilation = import("../Compilation");
type Chunk = import("../Chunk");
type AssignLibraryPluginOptions = {
    type: any;
    /**
     * name prefix
     */
    prefix: string[] | "global";
    /**
     * declare name as variable
     */
    declare: string | false;
    /**
     * behavior for unnamed library name
     */
    unnamed: "error" | "static" | "copy" | "assign";
    /**
     * behavior for named library name
     */
    named?: ("copy" | "assign") | undefined;
};
type Source = import("webpack-sources").Source;
type LibraryOptions = any;
type LibraryType = any;
type ChunkHashContext = import("../Compilation").ChunkHashContext;
type Compiler = import("../Compiler");
type Module = import("../Module");
type RenderContext = import("../javascript/JavascriptModulesPlugin").RenderContext;
type StartupRenderContext = import("../javascript/JavascriptModulesPlugin").StartupRenderContext;
type Hash = import("../util/Hash");
/**
 * <T>
 */
type LibraryContext<T_1> = import("./AbstractLibraryPlugin").LibraryContext<T>;
type T = AssignLibraryPluginParsed;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/library/EnableLibraryPlugin.d.ts
export = EnableLibraryPlugin;
declare class EnableLibraryPlugin {
    /**
     * @param {Compiler} compiler the compiler instance
     * @param {LibraryType} type type of library
     * @returns {void}
     */
    static setEnabled(compiler: Compiler, type: any): void;
    /**
     * @param {Compiler} compiler the compiler instance
     * @param {LibraryType} type type of library
     * @returns {void}
     */
    static checkEnabled(compiler: Compiler, type: any): void;
    /**
     * @param {LibraryType} type library type that should be available
     */
    constructor(type: any);
    type: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace EnableLibraryPlugin {
    export { LibraryOptions, LibraryType, Compiler };
}
type Compiler = import("../Compiler");
type LibraryOptions = any;
type LibraryType = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/library/ExportPropertyLibraryPlugin.d.ts
export = ExportPropertyLibraryPlugin;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../../declarations/WebpackOptions").LibraryOptions} LibraryOptions */
/** @typedef {import("../../declarations/WebpackOptions").LibraryType} LibraryType */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../javascript/JavascriptModulesPlugin").StartupRenderContext} StartupRenderContext */
/** @template T @typedef {import("./AbstractLibraryPlugin").LibraryContext<T>} LibraryContext<T> */
/**
 * @typedef {Object} ExportPropertyLibraryPluginParsed
 * @property {string | string[]} export
 */
/**
 * @typedef {Object} ExportPropertyLibraryPluginOptions
 * @property {LibraryType} type
 * @property {boolean} nsObjectUsed the namespace object is used
 */
/**
 * @typedef {ExportPropertyLibraryPluginParsed} T
 * @extends {AbstractLibraryPlugin<ExportPropertyLibraryPluginParsed>}
 */
declare class ExportPropertyLibraryPlugin extends AbstractLibraryPlugin<ExportPropertyLibraryPluginParsed> {
    /**
     * @param {ExportPropertyLibraryPluginOptions} options options
     */
    constructor({ type, nsObjectUsed }: ExportPropertyLibraryPluginOptions);
    nsObjectUsed: boolean;
}
declare namespace ExportPropertyLibraryPlugin {
    export { Source, LibraryOptions, LibraryType, Chunk, Compiler, Module, StartupRenderContext, LibraryContext, ExportPropertyLibraryPluginParsed, ExportPropertyLibraryPluginOptions, T };
}
type ExportPropertyLibraryPluginParsed = {
    export: string | string[];
};
import AbstractLibraryPlugin = require("webpack/lib/library/AbstractLibraryPlugin");
type ExportPropertyLibraryPluginOptions = {
    type: any;
    /**
     * the namespace object is used
     */
    nsObjectUsed: boolean;
};
type Source = import("webpack-sources").Source;
type LibraryOptions = any;
type LibraryType = any;
type Chunk = import("../Chunk");
type Compiler = import("../Compiler");
type Module = import("../Module");
type StartupRenderContext = import("../javascript/JavascriptModulesPlugin").StartupRenderContext;
/**
 * <T>
 */
type LibraryContext<T_1> = import("./AbstractLibraryPlugin").LibraryContext<T>;
type T = ExportPropertyLibraryPluginParsed;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/library/JsonpLibraryPlugin.d.ts
export = JsonpLibraryPlugin;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../../declarations/WebpackOptions").LibraryOptions} LibraryOptions */
/** @typedef {import("../../declarations/WebpackOptions").LibraryType} LibraryType */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compilation").ChunkHashContext} ChunkHashContext */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../javascript/JavascriptModulesPlugin").RenderContext} RenderContext */
/** @typedef {import("../util/Hash")} Hash */
/** @template T @typedef {import("./AbstractLibraryPlugin").LibraryContext<T>} LibraryContext<T> */
/**
 * @typedef {Object} JsonpLibraryPluginOptions
 * @property {LibraryType} type
 */
/**
 * @typedef {Object} JsonpLibraryPluginParsed
 * @property {string} name
 */
/**
 * @typedef {JsonpLibraryPluginParsed} T
 * @extends {AbstractLibraryPlugin<JsonpLibraryPluginParsed>}
 */
declare class JsonpLibraryPlugin extends AbstractLibraryPlugin<JsonpLibraryPluginParsed> {
    /**
     * @param {JsonpLibraryPluginOptions} options the plugin options
     */
    constructor(options: JsonpLibraryPluginOptions);
}
declare namespace JsonpLibraryPlugin {
    export { Source, LibraryOptions, LibraryType, Chunk, ChunkHashContext, Compiler, RenderContext, Hash, LibraryContext, JsonpLibraryPluginOptions, JsonpLibraryPluginParsed, T };
}
type JsonpLibraryPluginParsed = {
    name: string;
};
import AbstractLibraryPlugin = require("webpack/lib/library/AbstractLibraryPlugin");
type JsonpLibraryPluginOptions = {
    type: any;
};
type Source = import("webpack-sources").Source;
type LibraryOptions = any;
type LibraryType = any;
type Chunk = import("../Chunk");
type ChunkHashContext = import("../Compilation").ChunkHashContext;
type Compiler = import("../Compiler");
type RenderContext = import("../javascript/JavascriptModulesPlugin").RenderContext;
type Hash = import("../util/Hash");
/**
 * <T>
 */
type LibraryContext<T_1> = import("./AbstractLibraryPlugin").LibraryContext<T>;
type T = JsonpLibraryPluginParsed;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/library/ModuleLibraryPlugin.d.ts
export = ModuleLibraryPlugin;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../../declarations/WebpackOptions").LibraryOptions} LibraryOptions */
/** @typedef {import("../../declarations/WebpackOptions").LibraryType} LibraryType */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compilation").ChunkHashContext} ChunkHashContext */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../javascript/JavascriptModulesPlugin").StartupRenderContext} StartupRenderContext */
/** @typedef {import("../util/Hash")} Hash */
/** @template T @typedef {import("./AbstractLibraryPlugin").LibraryContext<T>} LibraryContext<T> */
/**
 * @typedef {Object} ModuleLibraryPluginOptions
 * @property {LibraryType} type
 */
/**
 * @typedef {Object} ModuleLibraryPluginParsed
 * @property {string} name
 */
/**
 * @typedef {ModuleLibraryPluginParsed} T
 * @extends {AbstractLibraryPlugin<ModuleLibraryPluginParsed>}
 */
declare class ModuleLibraryPlugin extends AbstractLibraryPlugin<ModuleLibraryPluginParsed> {
    /**
     * @param {ModuleLibraryPluginOptions} options the plugin options
     */
    constructor(options: ModuleLibraryPluginOptions);
}
declare namespace ModuleLibraryPlugin {
    export { Source, LibraryOptions, LibraryType, Chunk, ChunkHashContext, Compiler, Module, StartupRenderContext, Hash, LibraryContext, ModuleLibraryPluginOptions, ModuleLibraryPluginParsed, T };
}
type ModuleLibraryPluginParsed = {
    name: string;
};
import AbstractLibraryPlugin = require("webpack/lib/library/AbstractLibraryPlugin");
type ModuleLibraryPluginOptions = {
    type: any;
};
type Source = import("webpack-sources").Source;
type LibraryOptions = any;
type LibraryType = any;
type Chunk = import("../Chunk");
type ChunkHashContext = import("../Compilation").ChunkHashContext;
type Compiler = import("../Compiler");
type Module = import("../Module");
type StartupRenderContext = import("../javascript/JavascriptModulesPlugin").StartupRenderContext;
type Hash = import("../util/Hash");
/**
 * <T>
 */
type LibraryContext<T_1> = import("./AbstractLibraryPlugin").LibraryContext<T>;
type T = ModuleLibraryPluginParsed;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/library/SystemLibraryPlugin.d.ts
export = SystemLibraryPlugin;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../../declarations/WebpackOptions").LibraryOptions} LibraryOptions */
/** @typedef {import("../../declarations/WebpackOptions").LibraryType} LibraryType */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compilation").ChunkHashContext} ChunkHashContext */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../javascript/JavascriptModulesPlugin").RenderContext} RenderContext */
/** @typedef {import("../util/Hash")} Hash */
/** @template T @typedef {import("./AbstractLibraryPlugin").LibraryContext<T>} LibraryContext<T> */
/**
 * @typedef {Object} SystemLibraryPluginOptions
 * @property {LibraryType} type
 */
/**
 * @typedef {Object} SystemLibraryPluginParsed
 * @property {string} name
 */
/**
 * @typedef {SystemLibraryPluginParsed} T
 * @extends {AbstractLibraryPlugin<SystemLibraryPluginParsed>}
 */
declare class SystemLibraryPlugin extends AbstractLibraryPlugin<SystemLibraryPluginParsed> {
    /**
     * @param {SystemLibraryPluginOptions} options the plugin options
     */
    constructor(options: SystemLibraryPluginOptions);
}
declare namespace SystemLibraryPlugin {
    export { Source, LibraryOptions, LibraryType, Chunk, ChunkHashContext, Compiler, RenderContext, Hash, LibraryContext, SystemLibraryPluginOptions, SystemLibraryPluginParsed, T };
}
type SystemLibraryPluginParsed = {
    name: string;
};
import AbstractLibraryPlugin = require("webpack/lib/library/AbstractLibraryPlugin");
type SystemLibraryPluginOptions = {
    type: any;
};
type Source = import("webpack-sources").Source;
type LibraryOptions = any;
type LibraryType = any;
type Chunk = import("../Chunk");
type ChunkHashContext = import("../Compilation").ChunkHashContext;
type Compiler = import("../Compiler");
type RenderContext = import("../javascript/JavascriptModulesPlugin").RenderContext;
type Hash = import("../util/Hash");
/**
 * <T>
 */
type LibraryContext<T_1> = import("./AbstractLibraryPlugin").LibraryContext<T>;
type T = SystemLibraryPluginParsed;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/library/UmdLibraryPlugin.d.ts
export = UmdLibraryPlugin;
/** @typedef {string | string[] | LibraryCustomUmdObject} UmdLibraryPluginName */
/**
 * @typedef {Object} UmdLibraryPluginOptions
 * @property {LibraryType} type
 * @property {boolean=} optionalAmdExternalAsGlobal
 */
/**
 * @typedef {Object} UmdLibraryPluginParsed
 * @property {string | string[]} name
 * @property {LibraryCustomUmdObject} names
 * @property {string | LibraryCustomUmdCommentObject} auxiliaryComment
 * @property {boolean} namedDefine
 */
/**
 * @typedef {UmdLibraryPluginParsed} T
 * @extends {AbstractLibraryPlugin<UmdLibraryPluginParsed>}
 */
declare class UmdLibraryPlugin extends AbstractLibraryPlugin<UmdLibraryPluginParsed> {
    /**
     * @param {UmdLibraryPluginOptions} options the plugin option
     */
    constructor(options: UmdLibraryPluginOptions);
    optionalAmdExternalAsGlobal: boolean;
}
declare namespace UmdLibraryPlugin {
    export { Source, LibraryCustomUmdCommentObject, LibraryCustomUmdObject, LibraryName, LibraryOptions, LibraryType, Compiler, RenderContext, Hash, LibraryContext, UmdLibraryPluginName, UmdLibraryPluginOptions, UmdLibraryPluginParsed, T };
}
type UmdLibraryPluginParsed = {
    name: string | string[];
    names: any;
    auxiliaryComment: string | LibraryCustomUmdCommentObject;
    namedDefine: boolean;
};
import AbstractLibraryPlugin = require("webpack/lib/library/AbstractLibraryPlugin");
type UmdLibraryPluginOptions = {
    type: any;
    optionalAmdExternalAsGlobal?: boolean | undefined;
};
type Source = import("webpack-sources").Source;
type LibraryCustomUmdCommentObject = any;
type LibraryCustomUmdObject = any;
type LibraryName = any;
type LibraryOptions = any;
type LibraryType = any;
type Compiler = import("../Compiler");
type RenderContext = import("../javascript/JavascriptModulesPlugin").RenderContext;
type Hash = import("../util/Hash");
/**
 * <T>
 */
type LibraryContext<T_1> = import("./AbstractLibraryPlugin").LibraryContext<T>;
type UmdLibraryPluginName = string | string[] | LibraryCustomUmdObject;
type T = UmdLibraryPluginParsed;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/logging/Logger.d.ts
export type LogTypeEnum = (typeof LogType)[keyof typeof LogType];
export const LogType: Readonly<{
    error: "error";
    warn: "warn";
    info: "info";
    log: "log";
    debug: "debug";
    trace: "trace";
    group: "group";
    groupCollapsed: "groupCollapsed";
    groupEnd: "groupEnd";
    profile: "profile";
    profileEnd: "profileEnd";
    time: "time";
    clear: "clear";
    status: "status";
}>;
declare class WebpackLogger {
    /**
     * @param {function(LogTypeEnum, any[]=): void} log log function
     * @param {function(string | function(): string): WebpackLogger} getChildLogger function to create child logger
     */
    constructor(log: (arg0: LogTypeEnum, arg1: any[] | undefined) => void, getChildLogger: (arg0: string | (() => string)) => WebpackLogger);
    getChildLogger: (arg0: string | (() => string)) => WebpackLogger;
    error(...args: any[]): void;
    warn(...args: any[]): void;
    info(...args: any[]): void;
    log(...args: any[]): void;
    debug(...args: any[]): void;
    assert(assertion: any, ...args: any[]): void;
    trace(): void;
    clear(): void;
    status(...args: any[]): void;
    group(...args: any[]): void;
    groupCollapsed(...args: any[]): void;
    groupEnd(...args: any[]): void;
    profile(label: any): void;
    profileEnd(label: any): void;
    time(label: any): void;
    timeLog(label: any): void;
    timeEnd(label: any): void;
    timeAggregate(label: any): void;
    timeAggregateEnd(label: any): void;
    [LOG_SYMBOL]: (arg0: LogTypeEnum, arg1?: any[] | undefined) => void;
    [TIMERS_SYMBOL]: any;
    [TIMERS_AGGREGATES_SYMBOL]: any;
}
/** @typedef {typeof LogType[keyof typeof LogType]} LogTypeEnum */
declare const LOG_SYMBOL: unique symbol;
declare const TIMERS_SYMBOL: unique symbol;
declare const TIMERS_AGGREGATES_SYMBOL: unique symbol;
export { WebpackLogger as Logger };

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/logging/createConsoleLogger.d.ts
declare function _exports({ level, debug, console }: LoggerOptions): (arg0: string, arg1: LogTypeEnum, arg2: any[]) => void;
export = _exports;
export type FilterItemTypes = any;
export type FilterTypes = any;
export type LogTypeEnum = import("./Logger").LogTypeEnum;
export type FilterFunction = (arg0: string) => boolean;
export type LoggerConsole = {
    clear: () => void;
    trace: () => void;
    info: (...args: any[]) => void;
    log: (...args: any[]) => void;
    warn: (...args: any[]) => void;
    error: (...args: any[]) => void;
    debug?: (...args: any[]) => void;
    group?: (...args: any[]) => void;
    groupCollapsed?: (...args: any[]) => void;
    groupEnd?: (...args: any[]) => void;
    status?: (...args: any[]) => void;
    profile?: (...args: any[]) => void;
    profileEnd?: (...args: any[]) => void;
    logTime?: (...args: any[]) => void;
};
export type LoggerOptions = {
    /**
     * loglevel
     */
    level: false | true | "none" | "error" | "warn" | "info" | "log" | "verbose";
    /**
     * filter for debug logging
     */
    debug: FilterTypes | boolean;
    /**
     * the console to log to
     */
    console: LoggerConsole;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/logging/runtime.d.ts
export function getLogger(name: string): Logger;
export function configureDefaultLogger(options: createConsoleLogger.LoggerOptions): void;
export namespace hooks {
    let log: SyncBailHook<any, any, import("tapable").UnsetAdditionalOptions>;
}
import { Logger } from "./Logger";
import createConsoleLogger = require("./createConsoleLogger");
import { SyncBailHook } from "tapable";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/logging/truncateArgs.d.ts
export = truncateArgs;
/**
 * @param {any[]} args items to be truncated
 * @param {number} maxLength maximum length of args including spaces between
 * @returns {string[]} truncated args
 */
declare function truncateArgs(args: any[], maxLength: number): string[];

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/node/CommonJsChunkLoadingPlugin.d.ts
export = CommonJsChunkLoadingPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {Object} CommonJsChunkLoadingPluginOptions
 * @property {boolean} [asyncChunkLoading] enable async chunk loading
 */
declare class CommonJsChunkLoadingPlugin {
    /**
     * @param {CommonJsChunkLoadingPluginOptions} [options] options
     */
    constructor(options?: CommonJsChunkLoadingPluginOptions);
    _asyncChunkLoading: boolean;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace CommonJsChunkLoadingPlugin {
    export { Chunk, Compiler, CommonJsChunkLoadingPluginOptions };
}
type Compiler = import("../Compiler");
type CommonJsChunkLoadingPluginOptions = {
    /**
     * enable async chunk loading
     */
    asyncChunkLoading?: boolean;
};
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/node/NodeEnvironmentPlugin.d.ts
export = NodeEnvironmentPlugin;
/** @typedef {import("../../declarations/WebpackOptions").InfrastructureLogging} InfrastructureLogging */
/** @typedef {import("../Compiler")} Compiler */
declare class NodeEnvironmentPlugin {
    /**
     * @param {Object} options options
     * @param {InfrastructureLogging} options.infrastructureLogging infrastructure logging options
     */
    constructor(options: {
        infrastructureLogging: InfrastructureLogging;
    });
    options: {
        infrastructureLogging: any;
    };
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace NodeEnvironmentPlugin {
    export { InfrastructureLogging, Compiler };
}
type Compiler = import("../Compiler");
type InfrastructureLogging = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/node/NodeSourcePlugin.d.ts
export = NodeSourcePlugin;
/** @typedef {import("../Compiler")} Compiler */
declare class NodeSourcePlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace NodeSourcePlugin {
    export { Compiler };
}
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/node/NodeTargetPlugin.d.ts
export = NodeTargetPlugin;
declare class NodeTargetPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace NodeTargetPlugin {
    export { Compiler };
}
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/node/NodeTemplatePlugin.d.ts
export = NodeTemplatePlugin;
/** @typedef {import("../Compiler")} Compiler */
/**
 * @typedef {Object} NodeTemplatePluginOptions
 * @property {boolean} [asyncChunkLoading] enable async chunk loading
 */
declare class NodeTemplatePlugin {
    /**
     * @param {NodeTemplatePluginOptions} [options] options object
     */
    constructor(options?: NodeTemplatePluginOptions);
    _options: NodeTemplatePluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace NodeTemplatePlugin {
    export { Compiler, NodeTemplatePluginOptions };
}
type NodeTemplatePluginOptions = {
    /**
     * enable async chunk loading
     */
    asyncChunkLoading?: boolean;
};
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/node/NodeWatchFileSystem.d.ts
export = NodeWatchFileSystem;
/** @typedef {import("../../declarations/WebpackOptions").WatchOptions} WatchOptions */
/** @typedef {import("../FileSystemInfo").FileSystemInfoEntry} FileSystemInfoEntry */
/** @typedef {import("../util/fs").WatchFileSystem} WatchFileSystem */
/** @typedef {import("../util/fs").WatchMethod} WatchMethod */
/** @typedef {import("../util/fs").Watcher} Watcher */
declare class NodeWatchFileSystem {
    constructor(inputFileSystem: any);
    inputFileSystem: any;
    watcherOptions: {
        aggregateTimeout: number;
    };
    watcher: any;
    /**
     * @param {Iterable<string>} files watched files
     * @param {Iterable<string>} directories watched directories
     * @param {Iterable<string>} missing watched exitance entries
     * @param {number} startTime timestamp of start time
     * @param {WatchOptions} options options object
     * @param {function((Error | null)=, Map<string, FileSystemInfoEntry>, Map<string, FileSystemInfoEntry>, Set<string>, Set<string>): void} callback aggregated callback
     * @param {function(string, number): void} callbackUndelayed callback when the first change was detected
     * @returns {Watcher} a watcher
     */
    watch(files: Iterable<string>, directories: Iterable<string>, missing: Iterable<string>, startTime: number, options: any, callback: (arg0: (Error | null) | undefined, arg1: Map<string, FileSystemInfoEntry>, arg2: Map<string, FileSystemInfoEntry>, arg3: Set<string>, arg4: Set<string>) => void, callbackUndelayed: (arg0: string, arg1: number) => void): Watcher;
}
declare namespace NodeWatchFileSystem {
    export { WatchOptions, FileSystemInfoEntry, WatchFileSystem, WatchMethod, Watcher };
}
type FileSystemInfoEntry = import("../FileSystemInfo").FileSystemInfoEntry;
type Watcher = import("../util/fs").Watcher;
type WatchOptions = any;
type WatchFileSystem = import("../util/fs").WatchFileSystem;
type WatchMethod = import("../util/fs").WatchMethod;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/node/ReadFileChunkLoadingRuntimeModule.d.ts
export = ReadFileChunkLoadingRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Compilation")} Compilation */
declare class ReadFileChunkLoadingRuntimeModule extends RuntimeModule {
    /**
     * @param {ReadonlySet<string>} runtimeRequirements runtime requirements
     */
    constructor(runtimeRequirements: ReadonlySet<string>);
    runtimeRequirements: ReadonlySet<string>;
    /**
     * @private
     * @param {Chunk} chunk chunk
     * @param {string} rootOutputDir root output directory
     * @returns {string} generated code
     */
    private _generateBaseUri;
}
declare namespace ReadFileChunkLoadingRuntimeModule {
    export { Chunk, ChunkGraph, Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/node/ReadFileCompileAsyncWasmPlugin.d.ts
export = ReadFileCompileAsyncWasmPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
declare class ReadFileCompileAsyncWasmPlugin {
    constructor({ type, import: useImport }?: {
        type?: string;
        import?: boolean;
    });
    _type: string;
    _import: boolean;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ReadFileCompileAsyncWasmPlugin {
    export { Chunk, Compiler };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/node/ReadFileCompileWasmPlugin.d.ts
export = ReadFileCompileWasmPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
/**
 * @typedef {Object} ReadFileCompileWasmPluginOptions
 * @property {boolean} [mangleImports] mangle imports
 */
declare class ReadFileCompileWasmPlugin {
    /**
     * @param {ReadFileCompileWasmPluginOptions} [options] options object
     */
    constructor(options?: ReadFileCompileWasmPluginOptions);
    options: ReadFileCompileWasmPluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ReadFileCompileWasmPlugin {
    export { Chunk, Compiler, ReadFileCompileWasmPluginOptions };
}
type ReadFileCompileWasmPluginOptions = {
    /**
     * mangle imports
     */
    mangleImports?: boolean;
};
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/node/RequireChunkLoadingRuntimeModule.d.ts
export = RequireChunkLoadingRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Compilation")} Compilation */
declare class RequireChunkLoadingRuntimeModule extends RuntimeModule {
    /**
     * @param {ReadonlySet<string>} runtimeRequirements runtime requirements
     */
    constructor(runtimeRequirements: ReadonlySet<string>);
    runtimeRequirements: ReadonlySet<string>;
    /**
     * @private
     * @param {Chunk} chunk chunk
     * @param {string} rootOutputDir root output directory
     * @returns {string} generated code
     */
    private _generateBaseUri;
}
declare namespace RequireChunkLoadingRuntimeModule {
    export { Chunk, ChunkGraph, Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/node/nodeConsole.d.ts
declare function _exports({ colors, appendOnly, stream }: {
    colors: any;
    appendOnly: any;
    stream: any;
}): {
    log: (...args: any[]) => void;
    debug: (...args: any[]) => void;
    trace: (...args: any[]) => void;
    info: (...args: any[]) => void;
    warn: (...args: any[]) => void;
    error: (...args: any[]) => void;
    logTime: (...args: any[]) => void;
    group: (...args: any[]) => void;
    groupCollapsed: (...args: any[]) => void;
    groupEnd: () => void;
    profile: (name: any) => void;
    profileEnd: (name: any) => void;
    clear: () => void;
    status: (...args: any[]) => void;
};
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/AggressiveMergingPlugin.d.ts
export = AggressiveMergingPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
/**
 * @typedef {Object} AggressiveMergingPluginOptions
 * @property {number=} minSizeReduce minimal size reduction to trigger merging
 */
declare class AggressiveMergingPlugin {
    /**
     * @param {AggressiveMergingPluginOptions=} [options] options object
     */
    constructor(options?: AggressiveMergingPluginOptions | undefined);
    options: AggressiveMergingPluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace AggressiveMergingPlugin {
    export { Chunk, Compiler, AggressiveMergingPluginOptions };
}
type AggressiveMergingPluginOptions = {
    /**
     * minimal size reduction to trigger merging
     */
    minSizeReduce?: number | undefined;
};
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.d.ts
export = AggressiveSplittingPlugin;
declare class AggressiveSplittingPlugin {
    /**
     * @param {Chunk} chunk the chunk to test
     * @returns {boolean} true if the chunk was recorded
     */
    static wasChunkRecorded(chunk: Chunk): boolean;
    /**
     * @param {AggressiveSplittingPluginOptions=} options options object
     */
    constructor(options?: any);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace AggressiveSplittingPlugin {
    export { AggressiveSplittingPluginOptions, Chunk, ChunkGraph, Compiler, Module };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");
type AggressiveSplittingPluginOptions = any;
type ChunkGraph = import("../ChunkGraph");
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/ConcatenatedModule.d.ts
export = ConcatenatedModule;
declare class ConcatenatedModule extends Module {
    /**
     * @param {Module} rootModule the root module of the concatenation
     * @param {Set<Module>} modules all modules in the concatenation (including the root module)
     * @param {RuntimeSpec} runtime the runtime
     * @param {Object=} associatedObjectForCache object for caching
     * @param {string | HashConstructor=} hashFunction hash function to use
     * @returns {ConcatenatedModule} the module
     */
    static create(rootModule: Module, modules: Set<Module>, runtime: RuntimeSpec, associatedObjectForCache?: any | undefined, hashFunction?: (string | HashConstructor) | undefined): ConcatenatedModule;
    /**
     * @param {Module} rootModule the root module of the concatenation
     * @param {Set<Module>} modules all modules in the concatenation (including the root module)
     * @param {Object=} associatedObjectForCache object for caching
     * @param {string | HashConstructor=} hashFunction hash function to use
     * @returns {string} the identifier
     */
    static _createIdentifier(rootModule: Module, modules: Set<Module>, associatedObjectForCache?: any | undefined, hashFunction?: (string | HashConstructor) | undefined): string;
    static deserialize(context: any): ConcatenatedModule;
    /**
     * @param {Object} options options
     * @param {string} options.identifier the identifier of the module
     * @param {Module=} options.rootModule the root module of the concatenation
     * @param {RuntimeSpec} options.runtime the selected runtime
     * @param {Set<Module>=} options.modules all concatenated modules
     */
    constructor({ identifier, rootModule, modules, runtime }: {
        identifier: string;
        rootModule?: Module | undefined;
        runtime: RuntimeSpec;
        modules?: Set<Module> | undefined;
    });
    /** @type {string} */
    _identifier: string;
    /** @type {Module} */
    rootModule: Module;
    /** @type {Set<Module>} */
    _modules: Set<Module>;
    _runtime: import("webpack/lib/util/runtime").RuntimeSpec;
    get modules(): Module[];
    /**
     * @private
     * @param {Module} rootModule the root of the concatenation
     * @param {Set<Module>} modulesSet a set of modules which should be concatenated
     * @param {RuntimeSpec} runtime for this runtime
     * @param {ModuleGraph} moduleGraph the module graph
     * @returns {ConcatenationEntry[]} concatenation list
     */
    private _createConcatenationList;
    /**
     * @param {Map<Module, ModuleInfo>} modulesMap modulesMap
     * @param {ModuleInfo} info info
     * @param {DependencyTemplates} dependencyTemplates dependencyTemplates
     * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate
     * @param {ModuleGraph} moduleGraph moduleGraph
     * @param {ChunkGraph} chunkGraph chunkGraph
     * @param {RuntimeSpec} runtime runtime
     * @param {CodeGenerationResults} codeGenerationResults codeGenerationResults
     */
    _analyseModule(modulesMap: Map<Module, ModuleInfo>, info: ModuleInfo, dependencyTemplates: DependencyTemplates, runtimeTemplate: RuntimeTemplate, moduleGraph: ModuleGraph, chunkGraph: ChunkGraph, runtime: RuntimeSpec, codeGenerationResults: CodeGenerationResults): void;
    /**
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {RuntimeSpec} runtime the runtime
     * @returns {[ModuleInfoOrReference[], Map<Module, ModuleInfo>]} module info items
     */
    _getModulesWithInfo(moduleGraph: ModuleGraph, runtime: RuntimeSpec): [ModuleInfoOrReference[], Map<Module, ModuleInfo>];
    findNewName(oldName: any, usedNamed1: any, usedNamed2: any, extraInfo: any): string;
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context: UpdateHashContext): void;
}
declare namespace ConcatenatedModule {
    export { Scope, Source, WebpackOptions, ChunkGraph, CodeGenerationResults, Compilation, Dependency, UpdateHashContext, DependencyTemplateContext, DependencyTemplates, ExportInfo, InitFragment, CodeGenerationContext, CodeGenerationResult, LibIdentOptions, ModuleGraph, ModuleGraphConnection, ConnectionState, RequestShortener, ResolverWithOptions, RuntimeTemplate, WebpackError, ChunkRenderContext, Hash, HashConstructor, InputFileSystem, RuntimeSpec, ReexportInfo, Binding, RawBinding, SymbolBinding, ModuleInfo, ModuleInfoOrReference, ConcatenatedModuleInfo, ExternalModuleInfo, ReferenceToModuleInfo, ConcatenationEntry };
}
import Module = require("webpack/lib/Module");
type ModuleInfo = ConcatenatedModuleInfo | ExternalModuleInfo;
type DependencyTemplates = import("../DependencyTemplates");
type RuntimeTemplate = import("../RuntimeTemplate");
type ModuleGraph = import("../ModuleGraph");
type ChunkGraph = import("../ChunkGraph");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
type CodeGenerationResults = import("../CodeGenerationResults");
type ModuleInfoOrReference = ConcatenatedModuleInfo | ExternalModuleInfo | ReferenceToModuleInfo;
type Hash = import("../util/Hash");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type HashConstructor = typeof import("../util/Hash");
type Scope = import("eslint-scope").Scope;
type Source = import("webpack-sources").Source;
type WebpackOptions = any;
type Compilation = import("../Compilation");
type Dependency = import("../Dependency");
type DependencyTemplateContext = import("../DependencyTemplate").DependencyTemplateContext;
type ExportInfo = import("../ExportsInfo").ExportInfo;
type InitFragment<T> = import("../InitFragment")<T>;
type CodeGenerationContext = import("../Module").CodeGenerationContext;
type CodeGenerationResult = import("../Module").CodeGenerationResult;
type LibIdentOptions = import("../Module").LibIdentOptions;
type ModuleGraphConnection = import("../ModuleGraphConnection");
type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
type RequestShortener = import("../RequestShortener");
type ResolverWithOptions = import("../ResolverFactory").ResolverWithOptions;
type WebpackError = import("../WebpackError");
type ChunkRenderContext = import("../javascript/JavascriptModulesPlugin").ChunkRenderContext;
type InputFileSystem = import("../util/fs").InputFileSystem;
type ReexportInfo = {
    module: Module;
    export: string[];
};
type Binding = RawBinding | SymbolBinding;
type RawBinding = {
    info: ModuleInfo;
    rawName: string;
    comment?: string | undefined;
    ids: string[];
    exportName: string[];
};
type SymbolBinding = {
    info: ConcatenatedModuleInfo;
    name: string;
    comment?: string | undefined;
    ids: string[];
    exportName: string[];
};
type ConcatenatedModuleInfo = {
    type: "concatenated";
    module: Module;
    index: number;
    ast: any;
    internalSource: Source;
    source: ReplaceSource;
    chunkInitFragments?: InitFragment<ChunkRenderContext>[] | undefined;
    runtimeRequirements: Iterable<string>;
    globalScope: Scope;
    moduleScope: Scope;
    internalNames: Map<string, string>;
    exportMap: Map<string, string>;
    rawExportMap: Map<string, string>;
    namespaceExportSymbol?: string | undefined;
    namespaceObjectName: string;
    interopNamespaceObjectUsed: boolean;
    interopNamespaceObjectName: string;
    interopNamespaceObject2Used: boolean;
    interopNamespaceObject2Name: string;
    interopDefaultAccessUsed: boolean;
    interopDefaultAccessName: string;
};
type ExternalModuleInfo = {
    type: "external";
    module: Module;
    runtimeCondition: RuntimeSpec | boolean;
    index: number;
    name: string;
    interopNamespaceObjectUsed: boolean;
    interopNamespaceObjectName: string;
    interopNamespaceObject2Used: boolean;
    interopNamespaceObject2Name: string;
    interopDefaultAccessUsed: boolean;
    interopDefaultAccessName: string;
};
type ReferenceToModuleInfo = {
    type: "reference";
    runtimeCondition: RuntimeSpec | boolean;
    target: ConcatenatedModuleInfo | ExternalModuleInfo;
};
type ConcatenationEntry = {
    type: "concatenated" | "external";
    module: Module;
    runtimeCondition: RuntimeSpec | boolean;
};
import { ReplaceSource } from "webpack-sources";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/EnsureChunkConditionsPlugin.d.ts
export = EnsureChunkConditionsPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGroup")} ChunkGroup */
/** @typedef {import("../Compiler")} Compiler */
declare class EnsureChunkConditionsPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace EnsureChunkConditionsPlugin {
    export { Chunk, ChunkGroup, Compiler };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");
type ChunkGroup = import("../ChunkGroup");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/FlagIncludedChunksPlugin.d.ts
export = FlagIncludedChunksPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Chunk").ChunkId} ChunkId */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
declare class FlagIncludedChunksPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace FlagIncludedChunksPlugin {
    export { Chunk, ChunkId, Compiler, Module };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");
type ChunkId = import("../Chunk").ChunkId;
type Module = import("../Module");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/InnerGraph.d.ts
export function bailout(parserState: ParserState): void;
export function enable(parserState: ParserState): void;
export function isEnabled(parserState: ParserState): boolean;
export function addUsage(state: ParserState, symbol: TopLevelSymbol | null, usage: string | TopLevelSymbol | true): void;
export function addVariableUsage(parser: JavascriptParser, name: string, usage: string | TopLevelSymbol | true): void;
export function inferDependencyUsage(state: ParserState): void;
export function onUsage(state: ParserState, onUsageCallback: UsageCallback): void;
export function setTopLevelSymbol(state: ParserState, symbol: TopLevelSymbol | undefined): void;
export function getTopLevelSymbol(state: ParserState): TopLevelSymbol | void;
export function tagTopLevelSymbol(parser: JavascriptParser, name: string): TopLevelSymbol | undefined;
export function isDependencyUsedByExports(dependency: Dependency, usedByExports: Set<string> | boolean, moduleGraph: ModuleGraph, runtime: RuntimeSpec): boolean;
export function getDependencyUsedByExportsCondition(dependency: Dependency, usedByExports: Set<string> | boolean | undefined, moduleGraph: ModuleGraph): null | false | ((arg0: ModuleGraphConnection, arg1: RuntimeSpec) => ConnectionState);
export type AnyNode = import("estree").Node;
export type Dependency = import("../Dependency");
export type ModuleGraph = import("../ModuleGraph");
export type ModuleGraphConnection = import("../ModuleGraphConnection");
export type ConnectionState = import("../ModuleGraphConnection").ConnectionState;
export type ParserState = import("../Parser").ParserState;
export type JavascriptParser = import("../javascript/JavascriptParser");
export type RuntimeSpec = import("../util/runtime").RuntimeSpec;
export type InnerGraph = Map<TopLevelSymbol | null, Set<string | TopLevelSymbol> | true | undefined>;
export type UsageCallback = (arg0: boolean | Set<string> | undefined) => void;
export type StateObject = {
    innerGraph: InnerGraph;
    currentTopLevelSymbol?: TopLevelSymbol | undefined;
    usageCallbackMap: Map<TopLevelSymbol, Set<UsageCallback>>;
};
export type State = false | StateObject;
export class TopLevelSymbol {
    /**
     * @param {string} name name of the variable
     */
    constructor(name: string);
    name: string;
}
export const topLevelSymbolTag: unique symbol;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/InnerGraphPlugin.d.ts
export = InnerGraphPlugin;
declare class InnerGraphPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace InnerGraphPlugin {
    export { ClassDeclarationNode, ClassExpressionNode, Node, VariableDeclaratorNode, JavascriptParserOptions, Compiler, Dependency, HarmonyImportSpecifierDependency, JavascriptParser, InnerGraph, TopLevelSymbol };
}
type Compiler = import("../Compiler");
type ClassDeclarationNode = import("estree").ClassDeclaration;
type ClassExpressionNode = import("estree").ClassExpression;
type Node = import("estree").Node;
type VariableDeclaratorNode = import("estree").VariableDeclarator;
type JavascriptParserOptions = any;
type Dependency = import("../Dependency");
type HarmonyImportSpecifierDependency = import("../dependencies/HarmonyImportSpecifierDependency");
type JavascriptParser = import("../javascript/JavascriptParser");
type InnerGraph = import("./InnerGraph").InnerGraph;
type TopLevelSymbol = import("./InnerGraph").TopLevelSymbol;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/LimitChunkCountPlugin.d.ts
export = LimitChunkCountPlugin;
declare class LimitChunkCountPlugin {
    /**
     * @param {LimitChunkCountPluginOptions=} options options object
     */
    constructor(options?: any);
    options: any;
    /**
     * @param {Compiler} compiler the webpack compiler
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace LimitChunkCountPlugin {
    export { LimitChunkCountPluginOptions, Chunk, Compiler, ChunkCombination };
}
type Compiler = import("../Compiler");
type LimitChunkCountPluginOptions = any;
type Chunk = import("../Chunk");
type ChunkCombination = {
    /**
     * this is set to true when combination was removed
     */
    deleted: boolean;
    sizeDiff: number;
    integratedSize: number;
    a: Chunk;
    b: Chunk;
    aIdx: number;
    bIdx: number;
    aSize: number;
    bSize: number;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/MangleExportsPlugin.d.ts
export = MangleExportsPlugin;
declare class MangleExportsPlugin {
    /**
     * @param {boolean} deterministic use deterministic names
     */
    constructor(deterministic: boolean);
    _deterministic: boolean;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace MangleExportsPlugin {
    export { Compiler, ExportsInfo, ExportInfo };
}
type Compiler = import("../Compiler");
type ExportsInfo = import("../ExportsInfo");
type ExportInfo = import("../ExportsInfo").ExportInfo;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/MergeDuplicateChunksPlugin.d.ts
export = MergeDuplicateChunksPlugin;
/** @typedef {import("../Compiler")} Compiler */
declare class MergeDuplicateChunksPlugin {
    /**
     * @param {Compiler} compiler the compiler
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace MergeDuplicateChunksPlugin {
    export { Compiler };
}
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/MinChunkSizePlugin.d.ts
export = MinChunkSizePlugin;
declare class MinChunkSizePlugin {
    /**
     * @param {MinChunkSizePluginOptions} options options object
     */
    constructor(options: any);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace MinChunkSizePlugin {
    export { MinChunkSizePluginOptions, Chunk, Compiler };
}
type Compiler = import("../Compiler");
type MinChunkSizePluginOptions = any;
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/MinMaxSizeWarning.d.ts
export = MinMaxSizeWarning;
declare class MinMaxSizeWarning extends WebpackError {
    /**
     * @param {string[] | undefined} keys keys
     * @param {number} minSize minimum size
     * @param {number} maxSize maximum size
     */
    constructor(keys: string[] | undefined, minSize: number, maxSize: number);
}
import WebpackError = require("webpack/lib/WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/ModuleConcatenationPlugin.d.ts
export = ModuleConcatenationPlugin;
declare class ModuleConcatenationPlugin {
    constructor(options: any);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
    /**
     * @param {Compilation} compilation the compilation
     * @param {Module} module the module to be added
     * @param {RuntimeSpec} runtime the runtime scope
     * @returns {Set<Module>} the imported modules
     */
    _getImports(compilation: Compilation, module: Module, runtime: RuntimeSpec): Set<Module>;
    /**
     * @param {Compilation} compilation webpack compilation
     * @param {ConcatConfiguration} config concat configuration (will be modified when added)
     * @param {Module} module the module to be added
     * @param {RuntimeSpec} runtime the runtime scope of the generated code
     * @param {RuntimeSpec} activeRuntime the runtime scope of the root module
     * @param {Set<Module>} possibleModules modules that are candidates
     * @param {Set<Module>} candidates list of potential candidates (will be added to)
     * @param {Map<Module, Module | function(RequestShortener): string>} failureCache cache for problematic modules to be more performant
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @param {boolean} avoidMutateOnFailure avoid mutating the config when adding fails
     * @param {Statistics} statistics gathering metrics
     * @returns {null | Module | function(RequestShortener): string} the problematic module
     */
    _tryToAdd(compilation: Compilation, config: ConcatConfiguration, module: Module, runtime: RuntimeSpec, activeRuntime: RuntimeSpec, possibleModules: Set<Module>, candidates: Set<Module>, failureCache: Map<Module, Module | ((arg0: RequestShortener) => string)>, chunkGraph: ChunkGraph, avoidMutateOnFailure: boolean, statistics: Statistics): null | Module | ((arg0: RequestShortener) => string);
}
declare namespace ModuleConcatenationPlugin {
    export { Compilation, Compiler, Module, RequestShortener, RuntimeSpec, Statistics };
}
type Compiler = import("../Compiler");
type Compilation = import("../Compilation");
type Module = import("../Module");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
declare class ConcatConfiguration {
    /**
     * @param {Module} rootModule the root module
     * @param {RuntimeSpec} runtime the runtime
     */
    constructor(rootModule: Module, runtime: RuntimeSpec);
    rootModule: import("webpack/lib/Module");
    runtime: import("webpack/lib/util/runtime").RuntimeSpec;
    /** @type {Set<Module>} */
    modules: Set<Module>;
    /** @type {Map<Module, Module | function(RequestShortener): string>} */
    warnings: Map<Module, Module | ((arg0: RequestShortener) => string)>;
    /**
     * @param {Module} module the module
     */
    add(module: Module): void;
    /**
     * @param {Module} module the module
     * @returns {boolean} true, when the module is in the module set
     */
    has(module: Module): boolean;
    isEmpty(): boolean;
    /**
     * @param {Module} module the module
     * @param {Module | function(RequestShortener): string} problem the problem
     */
    addWarning(module: Module, problem: Module | ((arg0: RequestShortener) => string)): void;
    /**
     * @returns {Map<Module, Module | function(RequestShortener): string>} warnings
     */
    getWarningsSorted(): Map<Module, Module | ((arg0: RequestShortener) => string)>;
    /**
     * @returns {Set<Module>} modules as set
     */
    getModules(): Set<Module>;
    snapshot(): number;
    rollback(snapshot: any): void;
}
type RequestShortener = import("../RequestShortener");
import ChunkGraph = require("webpack/lib/ChunkGraph");
type Statistics = {
    cached: number;
    alreadyInConfig: number;
    invalidModule: number;
    incorrectChunks: number;
    incorrectDependency: number;
    incorrectModuleDependency: number;
    incorrectChunksOfImporter: number;
    incorrectRuntimeCondition: number;
    importerFailed: number;
    added: number;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/RealContentHashPlugin.d.ts
export = RealContentHashPlugin;
declare class RealContentHashPlugin {
    /**
     * @param {Compilation} compilation the compilation
     * @returns {CompilationHooks} the attached hooks
     */
    static getCompilationHooks(compilation: Compilation): CompilationHooks;
    /**
     * @param {Object} options options object
     * @param {string | Hash} options.hashFunction the hash function to use
     * @param {string} options.hashDigest the hash digest to use
     */
    constructor({ hashFunction, hashDigest }: {
        hashFunction: string | Hash;
        hashDigest: string;
    });
    _hashFunction: string | typeof import("webpack/lib/util/Hash");
    _hashDigest: string;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace RealContentHashPlugin {
    export { Source, Etag, AssetInfo, Compiler, Hash, OwnHashes, ReferencedHashes, Hashes, AssetInfoForRealContentHash, CompilationHooks };
}
type Compiler = import("../Compiler");
import Compilation = require("webpack/lib/Compilation");
type CompilationHooks = {
    updateHash: SyncBailHook<[Buffer[], string], string>;
};
type Hash = typeof import("../util/Hash");
type Source = import("webpack-sources").Source;
type Etag = import("../Cache").Etag;
type AssetInfo = import("../Compilation").AssetInfo;
type OwnHashes = Set<string>;
type ReferencedHashes = Set<string>;
type Hashes = Set<string>;
type AssetInfoForRealContentHash = {
    name: string;
    info: AssetInfo;
    source: Source;
    newSource: RawSource | undefined;
    newSourceWithoutOwn: RawSource | undefined;
    content: string;
    ownHashes: OwnHashes | undefined;
    contentComputePromise: Promise<void> | undefined;
    contentComputeWithoutOwnPromise: Promise<void> | undefined;
    referencedHashes: ReferencedHashes | undefined;
    hashes: Hashes;
};
import { SyncBailHook } from "tapable";
import { RawSource } from "webpack-sources";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/RemoveEmptyChunksPlugin.d.ts
export = RemoveEmptyChunksPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
declare class RemoveEmptyChunksPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace RemoveEmptyChunksPlugin {
    export { Chunk, Compiler };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/RemoveParentModulesPlugin.d.ts
export = RemoveParentModulesPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGroup")} ChunkGroup */
/** @typedef {import("../Compiler")} Compiler */
declare class RemoveParentModulesPlugin {
    /**
     * @param {Compiler} compiler the compiler
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace RemoveParentModulesPlugin {
    export { Chunk, ChunkGroup, Compiler };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");
type ChunkGroup = import("../ChunkGroup");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/RuntimeChunkPlugin.d.ts
export = RuntimeChunkPlugin;
/** @typedef {import("../Compilation").EntryData} EntryData */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Entrypoint")} Entrypoint */
declare class RuntimeChunkPlugin {
    constructor(options: any);
    options: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace RuntimeChunkPlugin {
    export { EntryData, Compiler, Entrypoint };
}
type Compiler = import("../Compiler");
type EntryData = import("../Compilation").EntryData;
type Entrypoint = import("../Entrypoint");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.d.ts
export = SideEffectsFlagPlugin;
declare class SideEffectsFlagPlugin {
    /**
     * @param {string} moduleName the module name
     * @param {undefined | boolean | string | string[]} flagValue the flag value
     * @param {Map<string, RegExp>} cache cache for glob to regexp
     * @returns {boolean | undefined} true, when the module has side effects, undefined or false when not
     */
    static moduleHasSideEffects(moduleName: string, flagValue: undefined | boolean | string | string[], cache: Map<string, RegExp>): boolean | undefined;
    /**
     * @param {boolean} analyseSource analyse source code for side effects
     */
    constructor(analyseSource?: boolean);
    _analyseSource: boolean;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace SideEffectsFlagPlugin {
    export { ModuleDeclaration, Statement, Compiler, Dependency, Module, JavascriptParser, ExportInModule, ReexportInfo };
}
type Compiler = import("../Compiler");
type ModuleDeclaration = import("estree").ModuleDeclaration;
type Statement = import("estree").Statement;
type Dependency = import("../Dependency");
type Module = import("../Module");
type JavascriptParser = import("../javascript/JavascriptParser");
type ExportInModule = {
    /**
     * the module
     */
    module: Module;
    /**
     * the name of the export
     */
    exportName: string;
    /**
     * if the export is conditional
     */
    checked: boolean;
};
type ReexportInfo = {
    static: Map<string, ExportInModule[]>;
    dynamic: Map<Module, Set<string>>;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/optimize/SplitChunksPlugin.d.ts
export = SplitChunksPlugin;
declare class SplitChunksPlugin {
    /**
     * @param {OptimizationSplitChunksOptions=} options plugin options
     */
    constructor(options?: any);
    /** @type {SplitChunksOptions} */
    options: SplitChunksOptions;
    /** @type {WeakMap<CacheGroupSource, CacheGroup>} */
    _cacheGroupCache: WeakMap<CacheGroupSource, CacheGroup>;
    /**
     * @param {CacheGroupSource} cacheGroupSource source
     * @returns {CacheGroup} the cache group (cached)
     */
    _getCacheGroup(cacheGroupSource: CacheGroupSource): CacheGroup;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace SplitChunksPlugin {
    export { OptimizationSplitChunksCacheGroup, OptimizationSplitChunksGetCacheGroups, OptimizationSplitChunksOptions, OptimizationSplitChunksSizes, OutputOptions, ChunkGraph, ChunkGroup, AssetInfo, PathData, Compiler, Module, ModuleGraph, DeterministicGroupingGroupedItemsForModule, DeterministicGroupingOptionsForModule, SplitChunksSizes, ChunkFilterFunction, CombineSizeFunction, CacheGroupSource, CacheGroup, FallbackCacheGroup, CacheGroupsContext, GetCacheGroups, GetName, SplitChunksOptions, ChunksInfoItem };
}
type SplitChunksOptions = {
    chunksFilter: ChunkFilterFunction;
    defaultSizeTypes: string[];
    minSize: SplitChunksSizes;
    minSizeReduction: SplitChunksSizes;
    minRemainingSize: SplitChunksSizes;
    enforceSizeThreshold: SplitChunksSizes;
    maxInitialSize: SplitChunksSizes;
    maxAsyncSize: SplitChunksSizes;
    minChunks: number;
    maxAsyncRequests: number;
    maxInitialRequests: number;
    hidePathInfo: boolean;
    filename: string | ((arg0: PathData, arg1: AssetInfo | undefined) => string);
    automaticNameDelimiter: string;
    getCacheGroups: GetCacheGroups;
    getName: GetName;
    usedExports: boolean;
    fallbackCacheGroup: FallbackCacheGroup;
};
type CacheGroupSource = {
    key?: string | undefined;
    priority?: number | undefined;
    getName?: GetName | undefined;
    chunksFilter?: ChunkFilterFunction | undefined;
    enforce?: boolean | undefined;
    minSize: SplitChunksSizes;
    minSizeReduction: SplitChunksSizes;
    minRemainingSize: SplitChunksSizes;
    enforceSizeThreshold: SplitChunksSizes;
    maxAsyncSize: SplitChunksSizes;
    maxInitialSize: SplitChunksSizes;
    minChunks?: number | undefined;
    maxAsyncRequests?: number | undefined;
    maxInitialRequests?: number | undefined;
    filename?: (string | ((arg0: PathData, arg1: AssetInfo | undefined) => string)) | undefined;
    idHint?: string | undefined;
    automaticNameDelimiter?: string | undefined;
    reuseExistingChunk?: boolean | undefined;
    usedExports?: boolean | undefined;
};
type CacheGroup = {
    key: string;
    priority?: number | undefined;
    getName?: GetName | undefined;
    chunksFilter?: ChunkFilterFunction | undefined;
    minSize: SplitChunksSizes;
    minSizeReduction: SplitChunksSizes;
    minRemainingSize: SplitChunksSizes;
    enforceSizeThreshold: SplitChunksSizes;
    maxAsyncSize: SplitChunksSizes;
    maxInitialSize: SplitChunksSizes;
    minChunks?: number | undefined;
    maxAsyncRequests?: number | undefined;
    maxInitialRequests?: number | undefined;
    filename?: (string | ((arg0: PathData, arg1: AssetInfo | undefined) => string)) | undefined;
    idHint?: string | undefined;
    automaticNameDelimiter: string;
    reuseExistingChunk: boolean;
    usedExports: boolean;
    _validateSize: boolean;
    _validateRemainingSize: boolean;
    _minSizeForMaxSize: SplitChunksSizes;
    _conditionalEnforce: boolean;
};
type Compiler = import("../Compiler");
type OptimizationSplitChunksCacheGroup = any;
type OptimizationSplitChunksGetCacheGroups = any;
type OptimizationSplitChunksOptions = any;
type OptimizationSplitChunksSizes = any;
type OutputOptions = any;
type ChunkGraph = import("../ChunkGraph");
type ChunkGroup = import("../ChunkGroup");
type AssetInfo = import("../Compilation").AssetInfo;
type PathData = import("../Compilation").PathData;
type Module = import("../Module");
type ModuleGraph = import("../ModuleGraph");
type DeterministicGroupingGroupedItemsForModule = import("../util/deterministicGrouping").GroupedItems<Module>;
type DeterministicGroupingOptionsForModule = import("../util/deterministicGrouping").Options<Module>;
type SplitChunksSizes = Record<string, number>;
type ChunkFilterFunction = (chunk: Chunk) => boolean | undefined;
type CombineSizeFunction = (a: number, b: number) => number;
type FallbackCacheGroup = {
    chunksFilter: ChunkFilterFunction;
    minSize: SplitChunksSizes;
    maxAsyncSize: SplitChunksSizes;
    maxInitialSize: SplitChunksSizes;
    automaticNameDelimiter: string;
};
type CacheGroupsContext = {
    moduleGraph: ModuleGraph;
    chunkGraph: ChunkGraph;
};
type GetCacheGroups = (module: Module, context: CacheGroupsContext) => CacheGroupSource[];
type GetName = (module?: Module | undefined, chunks?: Chunk[] | undefined, key?: string | undefined) => string | undefined;
type ChunksInfoItem = {
    modules: SortableSet<Module>;
    cacheGroup: CacheGroup;
    cacheGroupIndex: number;
    name: string;
    sizes: Record<string, number>;
    chunks: Set<Chunk>;
    reuseableChunks: Set<Chunk>;
    chunksKeys: Set<bigint | Chunk>;
};
import Chunk = require("webpack/lib/Chunk");
import SortableSet = require("webpack/lib/util/SortableSet");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/performance/AssetsOverSizeLimitWarning.d.ts
export = AssetsOverSizeLimitWarning;
declare class AssetsOverSizeLimitWarning extends WebpackError {
    /**
     * @param {AssetDetails[]} assetsOverSizeLimit the assets
     * @param {number} assetLimit the size limit
     */
    constructor(assetsOverSizeLimit: AssetDetails[], assetLimit: number);
    assets: import("webpack/lib/performance/SizeLimitsPlugin").AssetDetails[];
}
declare namespace AssetsOverSizeLimitWarning {
    export { AssetDetails };
}
import WebpackError = require("webpack/lib/WebpackError");
type AssetDetails = import("./SizeLimitsPlugin").AssetDetails;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/performance/EntrypointsOverSizeLimitWarning.d.ts
export = EntrypointsOverSizeLimitWarning;
declare class EntrypointsOverSizeLimitWarning extends WebpackError {
    /**
     * @param {EntrypointDetails[]} entrypoints the entrypoints
     * @param {number} entrypointLimit the size limit
     */
    constructor(entrypoints: EntrypointDetails[], entrypointLimit: number);
    entrypoints: import("webpack/lib/performance/SizeLimitsPlugin").EntrypointDetails[];
}
declare namespace EntrypointsOverSizeLimitWarning {
    export { EntrypointDetails };
}
import WebpackError = require("webpack/lib/WebpackError");
type EntrypointDetails = import("./SizeLimitsPlugin").EntrypointDetails;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/performance/NoAsyncChunksWarning.d.ts
export = NoAsyncChunksWarning;
declare class NoAsyncChunksWarning extends WebpackError {
    constructor();
}
import WebpackError = require("webpack/lib/WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/performance/SizeLimitsPlugin.d.ts
export = SizeLimitsPlugin;
declare class SizeLimitsPlugin {
    /**
     * @param {ChunkGroup | Source} thing the resource to test
     * @returns {boolean} true if over the limit
     */
    static isOverSizeLimit(thing: ChunkGroup | Source): boolean;
    /**
     * @param {PerformanceOptions} options the plugin options
     */
    constructor(options: any);
    hints: any;
    maxAssetSize: any;
    maxEntrypointSize: any;
    assetFilter: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace SizeLimitsPlugin {
    export { Source, PerformanceOptions, ChunkGroup, Compiler, Entrypoint, WebpackError, AssetDetails, EntrypointDetails };
}
type Compiler = import("../Compiler");
type ChunkGroup = import("../ChunkGroup");
type Source = import("webpack-sources").Source;
type PerformanceOptions = any;
type Entrypoint = import("../Entrypoint");
type WebpackError = import("../WebpackError");
type AssetDetails = {
    name: string;
    size: number;
};
type EntrypointDetails = {
    name: string;
    size: number;
    files: string[];
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/prefetch/ChunkPrefetchFunctionRuntimeModule.d.ts
export = ChunkPrefetchFunctionRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */
declare class ChunkPrefetchFunctionRuntimeModule extends RuntimeModule {
    /**
     * @param {string} childType TODO
     * @param {string} runtimeFunction TODO
     * @param {string} runtimeHandlers TODO
     */
    constructor(childType: string, runtimeFunction: string, runtimeHandlers: string);
    childType: string;
    runtimeFunction: string;
    runtimeHandlers: string;
}
declare namespace ChunkPrefetchFunctionRuntimeModule {
    export { Compilation, RuntimeTemplate };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Compilation = import("../Compilation");
type RuntimeTemplate = import("../RuntimeTemplate");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/prefetch/ChunkPrefetchPreloadPlugin.d.ts
export = ChunkPrefetchPreloadPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGroup").RawChunkGroupOptions} RawChunkGroupOptions */
/** @typedef {import("../Compiler")} Compiler */
declare class ChunkPrefetchPreloadPlugin {
    /**
     * @param {Compiler} compiler the compiler
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ChunkPrefetchPreloadPlugin {
    export { Chunk, RawChunkGroupOptions, Compiler };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");
type RawChunkGroupOptions = import("../ChunkGroup").RawChunkGroupOptions;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/prefetch/ChunkPrefetchStartupRuntimeModule.d.ts
export = ChunkPrefetchStartupRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */
declare class ChunkPrefetchStartupRuntimeModule extends RuntimeModule {
    /**
     * @param {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} startupChunks chunk ids to trigger when chunks are loaded
     */
    constructor(startupChunks: {
        onChunks: Chunk[];
        chunks: Set<Chunk>;
    }[]);
    startupChunks: {
        onChunks: Chunk[];
        chunks: Set<Chunk>;
    }[];
}
declare namespace ChunkPrefetchStartupRuntimeModule {
    export { Chunk, Compilation, RuntimeTemplate };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Chunk = import("../Chunk");
type Compilation = import("../Compilation");
type RuntimeTemplate = import("../RuntimeTemplate");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/prefetch/ChunkPrefetchTriggerRuntimeModule.d.ts
export = ChunkPrefetchTriggerRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */
declare class ChunkPrefetchTriggerRuntimeModule extends RuntimeModule {
    /**
     * @param {Record<string|number, (string|number)[]>} chunkMap map from chunk to
     */
    constructor(chunkMap: Record<string | number, (string | number)[]>);
    chunkMap: Record<string | number, (string | number)[]>;
}
declare namespace ChunkPrefetchTriggerRuntimeModule {
    export { Compilation, RuntimeTemplate };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Compilation = import("../Compilation");
type RuntimeTemplate = import("../RuntimeTemplate");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/prefetch/ChunkPreloadTriggerRuntimeModule.d.ts
export = ChunkPreloadTriggerRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */
declare class ChunkPreloadTriggerRuntimeModule extends RuntimeModule {
    /**
     * @param {Record<string|number, (string|number)[]>} chunkMap map from chunk to chunks
     */
    constructor(chunkMap: Record<string | number, (string | number)[]>);
    chunkMap: Record<string | number, (string | number)[]>;
}
declare namespace ChunkPreloadTriggerRuntimeModule {
    export { Compilation, RuntimeTemplate };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Compilation = import("../Compilation");
type RuntimeTemplate = import("../RuntimeTemplate");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/rules/BasicEffectRulePlugin.d.ts
export = BasicEffectRulePlugin;
/** @typedef {import("./RuleSetCompiler")} RuleSetCompiler */
declare class BasicEffectRulePlugin {
    /**
     * @param {string} ruleProperty the rule property
     * @param {string=} effectType the effect type
     */
    constructor(ruleProperty: string, effectType?: string | undefined);
    ruleProperty: string;
    effectType: string;
    /**
     * @param {RuleSetCompiler} ruleSetCompiler the rule set compiler
     * @returns {void}
     */
    apply(ruleSetCompiler: RuleSetCompiler): void;
}
declare namespace BasicEffectRulePlugin {
    export { RuleSetCompiler };
}
type RuleSetCompiler = import("./RuleSetCompiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/rules/BasicMatcherRulePlugin.d.ts
export = BasicMatcherRulePlugin;
/** @typedef {import("./RuleSetCompiler")} RuleSetCompiler */
/** @typedef {import("./RuleSetCompiler").RuleCondition} RuleCondition */
declare class BasicMatcherRulePlugin {
    /**
     * @param {string} ruleProperty the rule property
     * @param {string=} dataProperty the data property
     * @param {boolean=} invert if true, inverts the condition
     */
    constructor(ruleProperty: string, dataProperty?: string | undefined, invert?: boolean | undefined);
    ruleProperty: string;
    dataProperty: string;
    invert: boolean;
    /**
     * @param {RuleSetCompiler} ruleSetCompiler the rule set compiler
     * @returns {void}
     */
    apply(ruleSetCompiler: RuleSetCompiler): void;
}
declare namespace BasicMatcherRulePlugin {
    export { RuleSetCompiler, RuleCondition };
}
type RuleSetCompiler = import("./RuleSetCompiler");
type RuleCondition = import("./RuleSetCompiler").RuleCondition;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/rules/ObjectMatcherRulePlugin.d.ts
export = ObjectMatcherRulePlugin;
/** @typedef {import("./RuleSetCompiler")} RuleSetCompiler */
/** @typedef {import("./RuleSetCompiler").RuleCondition} RuleCondition */
declare class ObjectMatcherRulePlugin {
    constructor(ruleProperty: any, dataProperty: any);
    ruleProperty: any;
    dataProperty: any;
    /**
     * @param {RuleSetCompiler} ruleSetCompiler the rule set compiler
     * @returns {void}
     */
    apply(ruleSetCompiler: RuleSetCompiler): void;
}
declare namespace ObjectMatcherRulePlugin {
    export { RuleSetCompiler, RuleCondition };
}
type RuleSetCompiler = import("./RuleSetCompiler");
type RuleCondition = import("./RuleSetCompiler").RuleCondition;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/rules/RuleSetCompiler.d.ts
export = RuleSetCompiler;
/**
 * @typedef {Object} RuleCondition
 * @property {string | string[]} property
 * @property {boolean} matchWhenEmpty
 * @property {function(string): boolean} fn
 */
/**
 * @typedef {Object} Condition
 * @property {boolean} matchWhenEmpty
 * @property {function(string): boolean} fn
 */
/**
 * @typedef {Object} CompiledRule
 * @property {RuleCondition[]} conditions
 * @property {(Effect|function(object): Effect[])[]} effects
 * @property {CompiledRule[]=} rules
 * @property {CompiledRule[]=} oneOf
 */
/**
 * @typedef {Object} Effect
 * @property {string} type
 * @property {any} value
 */
/**
 * @typedef {Object} RuleSet
 * @property {Map<string, any>} references map of references in the rule set (may grow over time)
 * @property {function(object): Effect[]} exec execute the rule set
 */
declare class RuleSetCompiler {
    constructor(plugins: any);
    hooks: Readonly<{
        /** @type {SyncHook<[string, object, Set<string>, CompiledRule, Map<string, any>]>} */
        rule: SyncHook<[string, object, Set<string>, CompiledRule, Map<string, any>]>;
    }>;
    /**
     * @param {object[]} ruleSet raw user provided rules
     * @returns {RuleSet} compiled RuleSet
     */
    compile(ruleSet: object[]): RuleSet;
    /**
     * @param {string} path current path
     * @param {object[]} rules the raw rules provided by user
     * @param {Map<string, any>} refs references
     * @returns {CompiledRule[]} rules
     */
    compileRules(path: string, rules: object[], refs: Map<string, any>): CompiledRule[];
    /**
     * @param {string} path current path
     * @param {object} rule the raw rule provided by user
     * @param {Map<string, any>} refs references
     * @returns {CompiledRule} normalized and compiled rule for processing
     */
    compileRule(path: string, rule: object, refs: Map<string, any>): CompiledRule;
    /**
     * @param {string} path current path
     * @param {any} condition user provided condition value
     * @returns {Condition} compiled condition
     */
    compileCondition(path: string, condition: any): Condition;
    /**
     * @param {Condition[]} conditions some conditions
     * @returns {Condition} merged condition
     */
    combineConditionsOr(conditions: Condition[]): Condition;
    /**
     * @param {Condition[]} conditions some conditions
     * @returns {Condition} merged condition
     */
    combineConditionsAnd(conditions: Condition[]): Condition;
    /**
     * @param {string} path current path
     * @param {any} value value at the error location
     * @param {string} message message explaining the problem
     * @returns {Error} an error object
     */
    error(path: string, value: any, message: string): Error;
}
declare namespace RuleSetCompiler {
    export { RuleCondition, Condition, CompiledRule, Effect, RuleSet };
}
import { SyncHook } from "tapable";
type CompiledRule = {
    conditions: RuleCondition[];
    effects: (Effect | ((arg0: object) => Effect[]))[];
    rules?: CompiledRule[] | undefined;
    oneOf?: CompiledRule[] | undefined;
};
type RuleSet = {
    /**
     * map of references in the rule set (may grow over time)
     */
    references: Map<string, any>;
    /**
     * execute the rule set
     */
    exec: (arg0: object) => Effect[];
};
type Condition = {
    matchWhenEmpty: boolean;
    fn: (arg0: string) => boolean;
};
type RuleCondition = {
    property: string | string[];
    matchWhenEmpty: boolean;
    fn: (arg0: string) => boolean;
};
type Effect = {
    type: string;
    value: any;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/rules/UseEffectRulePlugin.d.ts
export = UseEffectRulePlugin;
/** @typedef {import("./RuleSetCompiler")} RuleSetCompiler */
/** @typedef {import("./RuleSetCompiler").Effect} Effect */
declare class UseEffectRulePlugin {
    /**
     * @param {RuleSetCompiler} ruleSetCompiler the rule set compiler
     * @returns {void}
     */
    apply(ruleSetCompiler: RuleSetCompiler): void;
    useItemToEffects(path: any, item: any): void;
}
declare namespace UseEffectRulePlugin {
    export { RuleSetCompiler, Effect };
}
type RuleSetCompiler = import("./RuleSetCompiler");
type Effect = import("./RuleSetCompiler").Effect;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/AsyncModuleRuntimeModule.d.ts
export = AsyncModuleRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class AsyncModuleRuntimeModule extends HelperRuntimeModule {
    constructor();
}
declare namespace AsyncModuleRuntimeModule {
    export { Compilation };
}
import HelperRuntimeModule = require("webpack/lib/runtime/HelperRuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/AutoPublicPathRuntimeModule.d.ts
export = AutoPublicPathRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class AutoPublicPathRuntimeModule extends RuntimeModule {
    constructor();
}
declare namespace AutoPublicPathRuntimeModule {
    export { Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/BaseUriRuntimeModule.d.ts
export = BaseUriRuntimeModule;
/** @typedef {import("../../declarations/WebpackOptions").EntryDescriptionNormalized} EntryDescriptionNormalized */
/** @typedef {import("../Chunk")} Chunk */
declare class BaseUriRuntimeModule extends RuntimeModule {
    constructor();
}
declare namespace BaseUriRuntimeModule {
    export { EntryDescriptionNormalized, Chunk };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type EntryDescriptionNormalized = any;
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/ChunkNameRuntimeModule.d.ts
export = ChunkNameRuntimeModule;
declare class ChunkNameRuntimeModule extends RuntimeModule {
    /**
     * @param {string} chunkName the chunk's name
     */
    constructor(chunkName: string);
    chunkName: string;
}
import RuntimeModule = require("webpack/lib/RuntimeModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/CompatGetDefaultExportRuntimeModule.d.ts
export = CompatGetDefaultExportRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class CompatGetDefaultExportRuntimeModule extends HelperRuntimeModule {
    constructor();
}
declare namespace CompatGetDefaultExportRuntimeModule {
    export { Compilation };
}
import HelperRuntimeModule = require("webpack/lib/runtime/HelperRuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/CompatRuntimeModule.d.ts
export = CompatRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../MainTemplate")} MainTemplate */
declare class CompatRuntimeModule extends RuntimeModule {
    constructor();
}
declare namespace CompatRuntimeModule {
    export { Chunk, ChunkGraph, Compilation, MainTemplate };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type Compilation = import("../Compilation");
type MainTemplate = import("../MainTemplate");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/CreateFakeNamespaceObjectRuntimeModule.d.ts
export = CreateFakeNamespaceObjectRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class CreateFakeNamespaceObjectRuntimeModule extends HelperRuntimeModule {
    constructor();
}
declare namespace CreateFakeNamespaceObjectRuntimeModule {
    export { Compilation };
}
import HelperRuntimeModule = require("webpack/lib/runtime/HelperRuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/CreateScriptRuntimeModule.d.ts
export = CreateScriptRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class CreateScriptRuntimeModule extends HelperRuntimeModule {
    constructor();
}
declare namespace CreateScriptRuntimeModule {
    export { Compilation };
}
import HelperRuntimeModule = require("webpack/lib/runtime/HelperRuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/CreateScriptUrlRuntimeModule.d.ts
export = CreateScriptUrlRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class CreateScriptUrlRuntimeModule extends HelperRuntimeModule {
    constructor();
}
declare namespace CreateScriptUrlRuntimeModule {
    export { Compilation };
}
import HelperRuntimeModule = require("webpack/lib/runtime/HelperRuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/DefinePropertyGettersRuntimeModule.d.ts
export = DefinePropertyGettersRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class DefinePropertyGettersRuntimeModule extends HelperRuntimeModule {
    constructor();
}
declare namespace DefinePropertyGettersRuntimeModule {
    export { Compilation };
}
import HelperRuntimeModule = require("webpack/lib/runtime/HelperRuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/EnsureChunkRuntimeModule.d.ts
export = EnsureChunkRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class EnsureChunkRuntimeModule extends RuntimeModule {
    /**
     * @param {ReadonlySet<string>} runtimeRequirements runtime requirements
     */
    constructor(runtimeRequirements: ReadonlySet<string>);
    runtimeRequirements: ReadonlySet<string>;
}
declare namespace EnsureChunkRuntimeModule {
    export { Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/GetChunkFilenameRuntimeModule.d.ts
export = GetChunkFilenameRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../Compilation").AssetInfo} AssetInfo */
/** @typedef {import("../Compilation").PathData} PathData */
/** @typedef {function(PathData, AssetInfo=): string} FilenameFunction */
declare class GetChunkFilenameRuntimeModule extends RuntimeModule {
    /**
     * @param {string} contentType the contentType to use the content hash for
     * @param {string} name kind of filename
     * @param {string} global function name to be assigned
     * @param {function(Chunk): string | FilenameFunction} getFilenameForChunk functor to get the filename or function
     * @param {boolean} allChunks when false, only async chunks are included
     */
    constructor(contentType: string, name: string, global: string, getFilenameForChunk: (arg0: Chunk) => string | FilenameFunction, allChunks: boolean);
    contentType: string;
    global: string;
    getFilenameForChunk: (arg0: Chunk) => string | FilenameFunction;
    allChunks: boolean;
}
declare namespace GetChunkFilenameRuntimeModule {
    export { Chunk, ChunkGraph, Compilation, AssetInfo, PathData, FilenameFunction };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Chunk = import("../Chunk");
type FilenameFunction = (arg0: PathData, arg1: AssetInfo | undefined) => string;
type ChunkGraph = import("../ChunkGraph");
type Compilation = import("../Compilation");
type AssetInfo = import("../Compilation").AssetInfo;
type PathData = import("../Compilation").PathData;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/GetFullHashRuntimeModule.d.ts
export = GetFullHashRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class GetFullHashRuntimeModule extends RuntimeModule {
    constructor();
}
declare namespace GetFullHashRuntimeModule {
    export { Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/GetMainFilenameRuntimeModule.d.ts
export = GetMainFilenameRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compilation")} Compilation */
declare class GetMainFilenameRuntimeModule extends RuntimeModule {
    /**
     * @param {string} name readable name
     * @param {string} global global object binding
     * @param {string} filename main file name
     */
    constructor(name: string, global: string, filename: string);
    global: string;
    filename: string;
}
declare namespace GetMainFilenameRuntimeModule {
    export { Chunk, Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Chunk = import("../Chunk");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/GetTrustedTypesPolicyRuntimeModule.d.ts
export = GetTrustedTypesPolicyRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class GetTrustedTypesPolicyRuntimeModule extends HelperRuntimeModule {
    /**
     * @param {ReadonlySet<string>} runtimeRequirements runtime requirements
     */
    constructor(runtimeRequirements: ReadonlySet<string>);
    runtimeRequirements: ReadonlySet<string>;
}
declare namespace GetTrustedTypesPolicyRuntimeModule {
    export { Compilation };
}
import HelperRuntimeModule = require("webpack/lib/runtime/HelperRuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/GlobalRuntimeModule.d.ts
export = GlobalRuntimeModule;
declare class GlobalRuntimeModule extends RuntimeModule {
    constructor();
}
import RuntimeModule = require("webpack/lib/RuntimeModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/HasOwnPropertyRuntimeModule.d.ts
export = HasOwnPropertyRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class HasOwnPropertyRuntimeModule extends RuntimeModule {
    constructor();
}
declare namespace HasOwnPropertyRuntimeModule {
    export { Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/HelperRuntimeModule.d.ts
export = HelperRuntimeModule;
declare class HelperRuntimeModule extends RuntimeModule {
    /**
     * @param {string} name a readable name
     */
    constructor(name: string);
}
import RuntimeModule = require("webpack/lib/RuntimeModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/LoadScriptRuntimeModule.d.ts
export = LoadScriptRuntimeModule;
declare class LoadScriptRuntimeModule extends HelperRuntimeModule {
    /**
     * @param {Compilation} compilation the compilation
     * @returns {LoadScriptCompilationHooks} hooks
     */
    static getCompilationHooks(compilation: Compilation): LoadScriptCompilationHooks;
    /**
     * @param {boolean=} withCreateScriptUrl use create script url for trusted types
     * @param {boolean=} withFetchPriority use `fetchPriority` attribute
     */
    constructor(withCreateScriptUrl?: boolean | undefined, withFetchPriority?: boolean | undefined);
    _withCreateScriptUrl: boolean;
    _withFetchPriority: boolean;
}
declare namespace LoadScriptRuntimeModule {
    export { Chunk, Compiler, LoadScriptCompilationHooks };
}
import HelperRuntimeModule = require("webpack/lib/runtime/HelperRuntimeModule");
import Compilation = require("webpack/lib/Compilation");
type LoadScriptCompilationHooks = {
    createScript: SyncWaterfallHook<[string, Chunk]>;
};
type Chunk = import("../Chunk");
type Compiler = import("../Compiler");
import { SyncWaterfallHook } from "tapable";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/MakeNamespaceObjectRuntimeModule.d.ts
export = MakeNamespaceObjectRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class MakeNamespaceObjectRuntimeModule extends HelperRuntimeModule {
    constructor();
}
declare namespace MakeNamespaceObjectRuntimeModule {
    export { Compilation };
}
import HelperRuntimeModule = require("webpack/lib/runtime/HelperRuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/NonceRuntimeModule.d.ts
export = NonceRuntimeModule;
declare class NonceRuntimeModule extends RuntimeModule {
    constructor();
}
import RuntimeModule = require("webpack/lib/RuntimeModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/OnChunksLoadedRuntimeModule.d.ts
export = OnChunksLoadedRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class OnChunksLoadedRuntimeModule extends RuntimeModule {
    constructor();
}
declare namespace OnChunksLoadedRuntimeModule {
    export { Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/PublicPathRuntimeModule.d.ts
export = PublicPathRuntimeModule;
/** @typedef {import("../../declarations/WebpackOptions").OutputNormalized} OutputOptions */
/** @typedef {import("../Compilation")} Compilation */
declare class PublicPathRuntimeModule extends RuntimeModule {
    /**
     * @param {OutputOptions["publicPath"]} publicPath public path
     */
    constructor(publicPath: any);
    publicPath: any;
}
declare namespace PublicPathRuntimeModule {
    export { OutputOptions, Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type OutputOptions = any;
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/RelativeUrlRuntimeModule.d.ts
export = RelativeUrlRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class RelativeUrlRuntimeModule extends HelperRuntimeModule {
    constructor();
}
declare namespace RelativeUrlRuntimeModule {
    export { Compilation };
}
import HelperRuntimeModule = require("webpack/lib/runtime/HelperRuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/RuntimeIdRuntimeModule.d.ts
export = RuntimeIdRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
declare class RuntimeIdRuntimeModule extends RuntimeModule {
    constructor();
}
declare namespace RuntimeIdRuntimeModule {
    export { Chunk, ChunkGraph };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/StartupChunkDependenciesPlugin.d.ts
export = StartupChunkDependenciesPlugin;
/** @typedef {import("../../declarations/WebpackOptions").ChunkLoadingType} ChunkLoadingType */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
/**
 * @typedef {Object} Options
 * @property {ChunkLoadingType} chunkLoading
 * @property {boolean=} asyncChunkLoading
 */
declare class StartupChunkDependenciesPlugin {
    /**
     * @param {Options} options options
     */
    constructor(options: Options);
    chunkLoading: any;
    asyncChunkLoading: boolean;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace StartupChunkDependenciesPlugin {
    export { ChunkLoadingType, Chunk, Compiler, Options };
}
type Compiler = import("../Compiler");
type Options = {
    chunkLoading: any;
    asyncChunkLoading?: boolean | undefined;
};
type ChunkLoadingType = any;
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/StartupChunkDependenciesRuntimeModule.d.ts
export = StartupChunkDependenciesRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Compilation")} Compilation */
declare class StartupChunkDependenciesRuntimeModule extends RuntimeModule {
    /**
     * @param {boolean} asyncChunkLoading use async chunk loading
     */
    constructor(asyncChunkLoading: boolean);
    asyncChunkLoading: boolean;
}
declare namespace StartupChunkDependenciesRuntimeModule {
    export { Chunk, ChunkGraph, Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/StartupEntrypointRuntimeModule.d.ts
export = StartupEntrypointRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../MainTemplate")} MainTemplate */
declare class StartupEntrypointRuntimeModule extends RuntimeModule {
    /**
     * @param {boolean} asyncChunkLoading use async chunk loading
     */
    constructor(asyncChunkLoading: boolean);
    asyncChunkLoading: boolean;
}
declare namespace StartupEntrypointRuntimeModule {
    export { Compilation, MainTemplate };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Compilation = import("../Compilation");
type MainTemplate = import("../MainTemplate");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/runtime/SystemContextRuntimeModule.d.ts
export = SystemContextRuntimeModule;
/** @typedef {import("../Compilation")} Compilation */
declare class SystemContextRuntimeModule extends RuntimeModule {
    constructor();
}
declare namespace SystemContextRuntimeModule {
    export { Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/schemes/DataUriPlugin.d.ts
export = DataUriPlugin;
declare class DataUriPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DataUriPlugin {
    export { Compiler };
}
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/schemes/FileUriPlugin.d.ts
export = FileUriPlugin;
/** @typedef {import("../Compiler")} Compiler */
declare class FileUriPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace FileUriPlugin {
    export { Compiler };
}
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/schemes/HttpUriPlugin.d.ts
export = HttpUriPlugin;
declare class HttpUriPlugin {
    /**
     * @param {HttpUriPluginOptions} options options
     */
    constructor(options: any);
    _lockfileLocation: any;
    _cacheLocation: any;
    _upgrade: any;
    _frozen: any;
    _allowedUris: any;
    _proxy: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace HttpUriPlugin {
    export { HttpUriPluginOptions, Compiler, LockfileEntry };
}
type Compiler = import("../Compiler");
type HttpUriPluginOptions = any;
type LockfileEntry = {
    resolved: string;
    integrity: string;
    contentType: string;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/ArraySerializer.d.ts
export = ArraySerializer;
/** @typedef {import("./ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class ArraySerializer {
    /**
     * @template T
     * @param {T[]} array array
     * @param {ObjectSerializerContext} context context
     */
    serialize<T>(array: T[], context: ObjectSerializerContext): void;
    /**
     * @template T
     * @param {ObjectDeserializerContext} context context
     * @returns {T[]} array
     */
    deserialize<T_1>(context: ObjectDeserializerContext): T_1[];
}
declare namespace ArraySerializer {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
type ObjectSerializerContext = import("./ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./ObjectMiddleware").ObjectDeserializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/BinaryMiddleware.d.ts
export = BinaryMiddleware;
/**
 * @typedef {PrimitiveSerializableType[]} DeserializedType
 * @typedef {BufferSerializableType[]} SerializedType
 * @extends {SerializerMiddleware<DeserializedType, SerializedType>}
 */
declare class BinaryMiddleware extends SerializerMiddleware<DeserializedType, SerializedType> {
    constructor();
    _serializeLazy(fn: any, context: any): () => any;
    /**
     * @param {DeserializedType} data data
     * @param {Object} context context object
     * @param {{ leftOverBuffer: Buffer | null, allocationSize: number, increaseCounter: number }} allocationScope allocation scope
     * @returns {SerializedType} serialized data
     */
    _serialize(data: DeserializedType, context: any, allocationScope?: {
        leftOverBuffer: Buffer | null;
        allocationSize: number;
        increaseCounter: number;
    }): SerializedType;
    _createLazyDeserialized(content: any, context: any): () => any;
    _deserializeLazy(fn: any, context: any): () => any;
    /**
     * @param {SerializedType} data data
     * @param {Object} context context object
     * @returns {DeserializedType} deserialized data
     */
    _deserialize(data: SerializedType, context: any): DeserializedType;
}
declare namespace BinaryMiddleware {
    export { MEASURE_START_OPERATION, MEASURE_END_OPERATION, BufferSerializableType, PrimitiveSerializableType, MEASURE_START_OPERATION_TYPE, MEASURE_END_OPERATION_TYPE, DeserializedType, SerializedType };
}
type DeserializedType = PrimitiveSerializableType[];
type SerializedType = BufferSerializableType[];
import SerializerMiddleware = require("webpack/lib/serialization/SerializerMiddleware");
declare const MEASURE_START_OPERATION: unique symbol;
declare const MEASURE_END_OPERATION: unique symbol;
type BufferSerializableType = import("./types").BufferSerializableType;
type PrimitiveSerializableType = import("./types").PrimitiveSerializableType;
type MEASURE_START_OPERATION_TYPE = typeof MEASURE_START_OPERATION;
type MEASURE_END_OPERATION_TYPE = typeof MEASURE_END_OPERATION;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/DateObjectSerializer.d.ts
export = DateObjectSerializer;
/** @typedef {import("./ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class DateObjectSerializer {
    /**
     * @param {Date} obj date
     * @param {ObjectSerializerContext} context context
     */
    serialize(obj: Date, context: ObjectSerializerContext): void;
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {Date} date
     */
    deserialize(context: ObjectDeserializerContext): Date;
}
declare namespace DateObjectSerializer {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
type ObjectSerializerContext = import("./ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./ObjectMiddleware").ObjectDeserializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/ErrorObjectSerializer.d.ts
export = ErrorObjectSerializer;
/** @typedef {import("./ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class ErrorObjectSerializer {
    /**
     * @param {ErrorConstructor | EvalErrorConstructor | RangeErrorConstructor | ReferenceErrorConstructor | SyntaxErrorConstructor | TypeErrorConstructor} Type error type
     */
    constructor(Type: ErrorConstructor | EvalErrorConstructor | RangeErrorConstructor | ReferenceErrorConstructor | SyntaxErrorConstructor | TypeErrorConstructor);
    Type: ErrorConstructor | EvalErrorConstructor | RangeErrorConstructor | ReferenceErrorConstructor | SyntaxErrorConstructor | TypeErrorConstructor;
    /**
     * @param {Error | EvalError | RangeError | ReferenceError | SyntaxError | TypeError} obj error
     * @param {ObjectSerializerContext} context context
     */
    serialize(obj: Error | EvalError | RangeError | ReferenceError | SyntaxError | TypeError, context: ObjectSerializerContext): void;
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {Error | EvalError | RangeError | ReferenceError | SyntaxError | TypeError} error
     */
    deserialize(context: ObjectDeserializerContext): Error | EvalError | RangeError | ReferenceError | SyntaxError | TypeError;
}
declare namespace ErrorObjectSerializer {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
type ObjectSerializerContext = import("./ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./ObjectMiddleware").ObjectDeserializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/FileMiddleware.d.ts
export = FileMiddleware;
/**
 * @typedef {BufferSerializableType[]} DeserializedType
 * @typedef {true} SerializedType
 * @extends {SerializerMiddleware<DeserializedType, SerializedType>}
 */
declare class FileMiddleware extends SerializerMiddleware<DeserializedType, true> {
    /**
     * @param {IntermediateFileSystem} fs filesystem
     * @param {string | Hash} hashFunction hash function to use
     */
    constructor(fs: IntermediateFileSystem, hashFunction?: string | Hash);
    fs: import("webpack/lib/util/fs").IntermediateFileSystem;
    _hashFunction: string | typeof import("webpack/lib/util/Hash");
}
declare namespace FileMiddleware {
    export { Hash, IntermediateFileSystem, BufferSerializableType, SerializeResult, DeserializedType, SerializedType };
}
type DeserializedType = BufferSerializableType[];
import SerializerMiddleware = require("webpack/lib/serialization/SerializerMiddleware");
type IntermediateFileSystem = import("../util/fs").IntermediateFileSystem;
type Hash = typeof import("../util/Hash");
type BufferSerializableType = import("./types").BufferSerializableType;
type SerializeResult = {
    name: string | false;
    size: number;
    backgroundJob?: Promise<any> | undefined;
};
type SerializedType = true;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/MapObjectSerializer.d.ts
export = MapObjectSerializer;
/** @typedef {import("./ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class MapObjectSerializer {
    /**
     * @template K, V
     * @param {Map<K, V>} obj map
     * @param {ObjectSerializerContext} context context
     */
    serialize<K, V>(obj: Map<K, V>, context: ObjectSerializerContext): void;
    /**
     * @template K, V
     * @param {ObjectDeserializerContext} context context
     * @returns {Map<K, V>} map
     */
    deserialize<K_1, V_1>(context: ObjectDeserializerContext): Map<K_1, V_1>;
}
declare namespace MapObjectSerializer {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
type ObjectSerializerContext = import("./ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./ObjectMiddleware").ObjectDeserializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/NullPrototypeObjectSerializer.d.ts
export = NullPrototypeObjectSerializer;
/** @typedef {import("./ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class NullPrototypeObjectSerializer {
    /**
     * @template {Object} T
     * @param {T} obj null object
     * @param {ObjectSerializerContext} context context
     */
    serialize<T extends unknown>(obj: T, context: ObjectSerializerContext): void;
    /**
     * @template {Object} T
     * @param {ObjectDeserializerContext} context context
     * @returns {T} null object
     */
    deserialize<T_1 extends unknown>(context: ObjectDeserializerContext): T_1;
}
declare namespace NullPrototypeObjectSerializer {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
type ObjectSerializerContext = import("./ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./ObjectMiddleware").ObjectDeserializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/ObjectMiddleware.d.ts
export = ObjectMiddleware;
/**
 * @typedef {ComplexSerializableType[]} DeserializedType
 * @typedef {PrimitiveSerializableType[]} SerializedType
 * @extends {SerializerMiddleware<DeserializedType, SerializedType>}
 */
declare class ObjectMiddleware extends SerializerMiddleware<DeserializedType, SerializedType> {
    /**
     * @param {RegExp} regExp RegExp for which the request is tested
     * @param {function(string): boolean} loader loader to load the request, returns true when successful
     * @returns {void}
     */
    static registerLoader(regExp: RegExp, loader: (arg0: string) => boolean): void;
    /**
     * @param {Constructor} Constructor the constructor
     * @param {string} request the request which will be required when deserializing
     * @param {string | null} name the name to make multiple serializer unique when sharing a request
     * @param {ObjectSerializer} serializer the serializer
     * @returns {void}
     */
    static register(Constructor: Constructor, request: string, name: string | null, serializer: ObjectSerializer): void;
    /**
     * @param {Constructor} Constructor the constructor
     * @returns {void}
     */
    static registerNotSerializable(Constructor: Constructor): void;
    static getSerializerFor(object: any): {
        request?: string;
        name?: string | number;
        serializer?: ObjectSerializer;
    };
    /**
     * @param {string} request request
     * @param {TODO} name name
     * @returns {ObjectSerializer} serializer
     */
    static getDeserializerFor(request: string, name: TODO): ObjectSerializer;
    /**
     * @param {string} request request
     * @param {TODO} name name
     * @returns {ObjectSerializer} serializer
     */
    static _getDeserializerForWithoutError(request: string, name: TODO): ObjectSerializer;
    /**
     * @param {function(any): void} extendContext context extensions
     * @param {string | Hash} hashFunction hash function to use
     */
    constructor(extendContext: (arg0: any) => void, hashFunction?: string | Hash);
    extendContext: (arg0: any) => void;
    _hashFunction: string | typeof import("webpack/lib/util/Hash");
}
declare namespace ObjectMiddleware {
    export { NOT_SERIALIZABLE, Hash, ComplexSerializableType, PrimitiveSerializableType, Constructor, ObjectSerializerContext, ObjectDeserializerContext, ObjectSerializer, DeserializedType, SerializedType };
}
type DeserializedType = ComplexSerializableType[];
type SerializedType = PrimitiveSerializableType[];
import SerializerMiddleware = require("webpack/lib/serialization/SerializerMiddleware");
type Constructor = new (...params: any[]) => any;
type ObjectSerializer = {
    serialize: (arg0: any, arg1: ObjectSerializerContext) => void;
    deserialize: (arg0: ObjectDeserializerContext) => any;
};
type Hash = typeof import("../util/Hash");
declare const NOT_SERIALIZABLE: {};
type ComplexSerializableType = import("./types").ComplexSerializableType;
type PrimitiveSerializableType = import("./types").PrimitiveSerializableType;
type ObjectSerializerContext = {
    write: (arg0: any) => void;
    setCircularReference: (arg0: any) => void;
};
type ObjectDeserializerContext = {
    read: () => any;
    setCircularReference: (arg0: any) => void;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/PlainObjectSerializer.d.ts
export = PlainObjectSerializer;
declare class PlainObjectSerializer {
    /**
     * @param {Object} obj plain object
     * @param {ObjectSerializerContext} context context
     */
    serialize(obj: any, context: ObjectSerializerContext): void;
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {Object} plain object
     */
    deserialize(context: ObjectDeserializerContext): any;
}
declare namespace PlainObjectSerializer {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
type ObjectSerializerContext = import("./ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./ObjectMiddleware").ObjectDeserializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/RegExpObjectSerializer.d.ts
export = RegExpObjectSerializer;
/** @typedef {import("./ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class RegExpObjectSerializer {
    /**
     * @param {RegExp} obj regexp
     * @param {ObjectSerializerContext} context context
     */
    serialize(obj: RegExp, context: ObjectSerializerContext): void;
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {RegExp} regexp
     */
    deserialize(context: ObjectDeserializerContext): RegExp;
}
declare namespace RegExpObjectSerializer {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
type ObjectSerializerContext = import("./ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./ObjectMiddleware").ObjectDeserializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/Serializer.d.ts
export = Serializer;
declare class Serializer {
    constructor(middlewares: any, context: any);
    serializeMiddlewares: any;
    deserializeMiddlewares: any;
    context: any;
    serialize(obj: any, context: any): any;
    deserialize(value: any, context: any): any;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/SerializerMiddleware.d.ts
export = SerializerMiddleware;
/**
 * @template DeserializedType
 * @template SerializedType
 */
declare class SerializerMiddleware<DeserializedType, SerializedType> {
    /**
     * @param {any | function(): Promise<any> | any} value contained value or function to value
     * @param {SerializerMiddleware<any, any>} target target middleware
     * @param {object=} options lazy options
     * @param {any=} serializedValue serialized value
     * @returns {function(): Promise<any> | any} lazy function
     */
    static createLazy(value: any | (() => Promise<any> | any), target: SerializerMiddleware<any, any>, options?: object | undefined, serializedValue?: any | undefined): () => Promise<any> | any;
    /**
     * @param {function(): Promise<any> | any} fn lazy function
     * @param {SerializerMiddleware<any, any>=} target target middleware
     * @returns {boolean} true, when fn is a lazy function (optionally of that target)
     */
    static isLazy(fn: () => Promise<any> | any, target?: SerializerMiddleware<any, any> | undefined): boolean;
    /**
     * @param {function(): Promise<any> | any} fn lazy function
     * @returns {object} options
     */
    static getLazyOptions(fn: () => Promise<any> | any): object;
    /**
     * @param {function(): Promise<any> | any} fn lazy function
     * @returns {any} serialized value
     */
    static getLazySerializedValue(fn: () => Promise<any> | any): any;
    /**
     * @param {function(): Promise<any> | any} fn lazy function
     * @param {any} value serialized value
     * @returns {void}
     */
    static setLazySerializedValue(fn: () => Promise<any> | any, value: any): void;
    /**
     * @param {function(): Promise<any> | any} lazy lazy function
     * @param {function(any): Promise<any> | any} serialize serialize function
     * @returns {function(): Promise<any> | any} new lazy
     */
    static serializeLazy(lazy: () => Promise<any> | any, serialize: (arg0: any) => Promise<any> | any): () => Promise<any> | any;
    /**
     * @param {function(): Promise<any> | any} lazy lazy function
     * @param {function(any): Promise<any> | any} deserialize deserialize function
     * @returns {function(): Promise<any> | any} new lazy
     */
    static deserializeLazy(lazy: () => Promise<any> | any, deserialize: (arg0: any) => Promise<any> | any): () => Promise<any> | any;
    /**
     * @param {function(): Promise<any> | any} lazy lazy function
     * @returns {function(): Promise<any> | any} new lazy
     */
    static unMemoizeLazy(lazy: () => Promise<any> | any): () => Promise<any> | any;
    /**
     * @abstract
     * @param {DeserializedType} data data
     * @param {Object} context context object
     * @returns {SerializedType|Promise<SerializedType>} serialized data
     */
    serialize(data: DeserializedType, context: any): SerializedType | Promise<SerializedType>;
    /**
     * @abstract
     * @param {SerializedType} data data
     * @param {Object} context context object
     * @returns {DeserializedType|Promise<DeserializedType>} deserialized data
     */
    deserialize(data: SerializedType, context: any): DeserializedType | Promise<DeserializedType>;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/SetObjectSerializer.d.ts
export = SetObjectSerializer;
/** @typedef {import("./ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("./ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class SetObjectSerializer {
    /**
     * @template T
     * @param {Set<T>} obj set
     * @param {ObjectSerializerContext} context context
     */
    serialize<T>(obj: Set<T>, context: ObjectSerializerContext): void;
    /**
     * @template T
     * @param {ObjectDeserializerContext} context context
     * @returns {Set<T>} date
     */
    deserialize<T_1>(context: ObjectDeserializerContext): Set<T_1>;
}
declare namespace SetObjectSerializer {
    export { ObjectDeserializerContext, ObjectSerializerContext };
}
type ObjectSerializerContext = import("./ObjectMiddleware").ObjectSerializerContext;
type ObjectDeserializerContext = import("./ObjectMiddleware").ObjectDeserializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/SingleItemMiddleware.d.ts
export = SingleItemMiddleware;
/**
 * @typedef {any} DeserializedType
 * @typedef {any[]} SerializedType
 * @extends {SerializerMiddleware<any, any[]>}
 */
declare class SingleItemMiddleware extends SerializerMiddleware<any, any[]> {
    constructor();
}
declare namespace SingleItemMiddleware {
    export { DeserializedType, SerializedType };
}
import SerializerMiddleware = require("webpack/lib/serialization/SerializerMiddleware");
type DeserializedType = any;
type SerializedType = any[];

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/serialization/types.d.ts
export type ComplexSerializableType = undefined | null | number | string | boolean | Buffer | any | (() => ComplexSerializableType[] | Promise<ComplexSerializableType[]>);
export type PrimitiveSerializableType = undefined | null | number | bigint | string | boolean | Buffer | (() => PrimitiveSerializableType[] | Promise<PrimitiveSerializableType[]>);
export type BufferSerializableType = Buffer | (() => BufferSerializableType[] | Promise<BufferSerializableType[]>);

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/ConsumeSharedFallbackDependency.d.ts
export = ConsumeSharedFallbackDependency;
declare class ConsumeSharedFallbackDependency extends ModuleDependency {
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/ConsumeSharedModule.d.ts
export = ConsumeSharedModule;
declare class ConsumeSharedModule extends Module {
    /**
     * @param {string} context context
     * @param {ConsumeOptions} options consume options
     */
    constructor(context: string, options: ConsumeOptions);
    options: ConsumeOptions;
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @param {UpdateHashContext} context context
     * @returns {void}
     */
    updateHash(hash: Hash, context: UpdateHashContext): void;
}
declare namespace ConsumeSharedModule {
    export { WebpackOptions, ChunkGraph, ChunkGroup, Compilation, UpdateHashContext, CodeGenerationContext, CodeGenerationResult, LibIdentOptions, NeedBuildContext, RequestShortener, ResolverWithOptions, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, Hash, InputFileSystem, SemVerRange, ConsumeOptions };
}
import Module = require("webpack/lib/Module");
type ConsumeOptions = {
    /**
     * fallback request
     */
    import?: string | undefined;
    /**
     * resolved fallback request
     */
    importResolved?: string | undefined;
    /**
     * global share key
     */
    shareKey: string;
    /**
     * share scope
     */
    shareScope: string;
    /**
     * version requirement
     */
    requiredVersion: import("webpack/lib/util/semver").SemVerRange | false | undefined;
    /**
     * package name to determine required version automatically
     */
    packageName: string;
    /**
     * don't use shared version even if version isn't valid
     */
    strictVersion: boolean;
    /**
     * use single global version
     */
    singleton: boolean;
    /**
     * include the fallback module in a sync way
     */
    eager: boolean;
};
type Hash = import("../util/Hash");
type UpdateHashContext = import("../Dependency").UpdateHashContext;
type WebpackOptions = any;
type ChunkGraph = import("../ChunkGraph");
type ChunkGroup = import("../ChunkGroup");
type Compilation = import("../Compilation");
type CodeGenerationContext = import("../Module").CodeGenerationContext;
type CodeGenerationResult = import("../Module").CodeGenerationResult;
type LibIdentOptions = import("../Module").LibIdentOptions;
type NeedBuildContext = import("../Module").NeedBuildContext;
type RequestShortener = import("../RequestShortener");
type ResolverWithOptions = import("../ResolverFactory").ResolverWithOptions;
type WebpackError = import("../WebpackError");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type InputFileSystem = import("../util/fs").InputFileSystem;
type SemVerRange = import("../util/semver").SemVerRange;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/ConsumeSharedPlugin.d.ts
export = ConsumeSharedPlugin;
declare class ConsumeSharedPlugin {
    /**
     * @param {ConsumeSharedPluginOptions} options options
     */
    constructor(options: any);
    /** @type {[string, ConsumeOptions][]} */
    _consumes: [string, ConsumeOptions][];
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ConsumeSharedPlugin {
    export { ConsumeSharedPluginOptions, ConsumesConfig, Compiler, ResolveOptionsWithDependencyType, ConsumeOptions };
}
type ConsumeOptions = import("./ConsumeSharedModule").ConsumeOptions;
type Compiler = import("../Compiler");
type ConsumeSharedPluginOptions = any;
type ConsumesConfig = any;
type ResolveOptionsWithDependencyType = import("../ResolverFactory").ResolveOptionsWithDependencyType;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/ConsumeSharedRuntimeModule.d.ts
export = ConsumeSharedRuntimeModule;
/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../Module")} Module */
/** @typedef {import("./ConsumeSharedModule")} ConsumeSharedModule */
declare class ConsumeSharedRuntimeModule extends RuntimeModule {
    /**
     * @param {ReadonlySet<string>} runtimeRequirements runtime requirements
     */
    constructor(runtimeRequirements: ReadonlySet<string>);
    _runtimeRequirements: ReadonlySet<string>;
}
declare namespace ConsumeSharedRuntimeModule {
    export { Source, Chunk, ChunkGraph, Compilation, Module, ConsumeSharedModule };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Source = import("webpack-sources").Source;
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type Compilation = import("../Compilation");
type Module = import("../Module");
type ConsumeSharedModule = import("./ConsumeSharedModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/ProvideForSharedDependency.d.ts
export = ProvideForSharedDependency;
declare class ProvideForSharedDependency extends ModuleDependency {
}
import ModuleDependency = require("webpack/lib/dependencies/ModuleDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/ProvideSharedDependency.d.ts
export = ProvideSharedDependency;
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext} ObjectSerializerContext */
declare class ProvideSharedDependency extends Dependency {
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {ProvideSharedDependency} deserialize fallback dependency
     */
    static deserialize(context: ObjectDeserializerContext): ProvideSharedDependency;
    /**
     * @param {string} shareScope share scope
     * @param {string} name module name
     * @param {string | false} version version
     * @param {string} request request
     * @param {boolean} eager true, if this is an eager dependency
     */
    constructor(shareScope: string, name: string, version: string | false, request: string, eager: boolean);
    shareScope: string;
    name: string;
    version: string | false;
    request: string;
    eager: boolean;
}
declare namespace ProvideSharedDependency {
    export { shareScope, ObjectDeserializerContext, ObjectSerializerContext };
}
import Dependency = require("webpack/lib/Dependency");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
declare var shareScope: any;
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/ProvideSharedModule.d.ts
export = ProvideSharedModule;
declare class ProvideSharedModule extends Module {
    /**
     * @param {ObjectDeserializerContext} context context
     * @returns {ProvideSharedModule} deserialize fallback dependency
     */
    static deserialize(context: ObjectDeserializerContext): ProvideSharedModule;
    /**
     * @param {string} shareScope shared scope name
     * @param {string} name shared key
     * @param {string | false} version version
     * @param {string} request request to the provided module
     * @param {boolean} eager include the module in sync way
     */
    constructor(shareScope: string, name: string, version: string | false, request: string, eager: boolean);
    _shareScope: string;
    _name: string;
    _version: string | false;
    _request: string;
    _eager: boolean;
}
declare namespace ProvideSharedModule {
    export { WebpackOptions, Chunk, ChunkGraph, ChunkGroup, Compilation, CodeGenerationContext, CodeGenerationResult, LibIdentOptions, NeedBuildContext, RequestShortener, ResolverWithOptions, WebpackError, ObjectDeserializerContext, ObjectSerializerContext, Hash, InputFileSystem };
}
import Module = require("webpack/lib/Module");
type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
type WebpackOptions = any;
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type ChunkGroup = import("../ChunkGroup");
type Compilation = import("../Compilation");
type CodeGenerationContext = import("../Module").CodeGenerationContext;
type CodeGenerationResult = import("../Module").CodeGenerationResult;
type LibIdentOptions = import("../Module").LibIdentOptions;
type NeedBuildContext = import("../Module").NeedBuildContext;
type RequestShortener = import("../RequestShortener");
type ResolverWithOptions = import("../ResolverFactory").ResolverWithOptions;
type WebpackError = import("../WebpackError");
type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
type Hash = import("../util/Hash");
type InputFileSystem = import("../util/fs").InputFileSystem;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/ProvideSharedModuleFactory.d.ts
export = ProvideSharedModuleFactory;
/** @typedef {import("../ModuleFactory").ModuleFactoryCreateData} ModuleFactoryCreateData */
/** @typedef {import("../ModuleFactory").ModuleFactoryResult} ModuleFactoryResult */
/** @typedef {import("./ProvideSharedDependency")} ProvideSharedDependency */
declare class ProvideSharedModuleFactory extends ModuleFactory {
}
declare namespace ProvideSharedModuleFactory {
    export { ModuleFactoryCreateData, ModuleFactoryResult, ProvideSharedDependency };
}
import ModuleFactory = require("webpack/lib/ModuleFactory");
type ModuleFactoryCreateData = import("../ModuleFactory").ModuleFactoryCreateData;
type ModuleFactoryResult = import("../ModuleFactory").ModuleFactoryResult;
type ProvideSharedDependency = import("./ProvideSharedDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/ProvideSharedPlugin.d.ts
export = ProvideSharedPlugin;
/**
 * @typedef {Object} ProvideOptions
 * @property {string} shareKey
 * @property {string} shareScope
 * @property {string | undefined | false} version
 * @property {boolean} eager
 */
/** @typedef {Map<string, { config: ProvideOptions, version: string | undefined | false }>} ResolvedProvideMap */
declare class ProvideSharedPlugin {
    /**
     * @param {ProvideSharedPluginOptions} options options
     */
    constructor(options: any);
    _provides: [string, ProvideOptions][];
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ProvideSharedPlugin {
    export { ProvideSharedPluginOptions, Compilation, Compiler, ProvideOptions, ResolvedProvideMap };
}
type ProvideOptions = {
    shareKey: string;
    shareScope: string;
    version: string | undefined | false;
    eager: boolean;
};
type Compiler = import("../Compiler");
type ProvideSharedPluginOptions = any;
type Compilation = import("../Compilation");
type ResolvedProvideMap = Map<string, {
    config: ProvideOptions;
    version: string | undefined | false;
}>;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/SharePlugin.d.ts
export = SharePlugin;
/** @typedef {import("../../declarations/plugins/sharing/ConsumeSharedPlugin").ConsumeSharedPluginOptions} ConsumeSharedPluginOptions */
/** @typedef {import("../../declarations/plugins/sharing/ConsumeSharedPlugin").ConsumesConfig} ConsumesConfig */
/** @typedef {import("../../declarations/plugins/sharing/ProvideSharedPlugin").ProvideSharedPluginOptions} ProvideSharedPluginOptions */
/** @typedef {import("../../declarations/plugins/sharing/ProvideSharedPlugin").ProvidesConfig} ProvidesConfig */
/** @typedef {import("../../declarations/plugins/sharing/SharePlugin").SharePluginOptions} SharePluginOptions */
/** @typedef {import("../../declarations/plugins/sharing/SharePlugin").SharedConfig} SharedConfig */
/** @typedef {import("../Compiler")} Compiler */
declare class SharePlugin {
    /**
     * @param {SharePluginOptions} options options
     */
    constructor(options: any);
    _shareScope: any;
    _consumes: Record<string, any>[];
    _provides: Record<string, any>[];
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace SharePlugin {
    export { ConsumeSharedPluginOptions, ConsumesConfig, ProvideSharedPluginOptions, ProvidesConfig, SharePluginOptions, SharedConfig, Compiler };
}
type Compiler = import("../Compiler");
type ConsumeSharedPluginOptions = any;
type ConsumesConfig = any;
type ProvideSharedPluginOptions = any;
type ProvidesConfig = any;
type SharePluginOptions = any;
type SharedConfig = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/ShareRuntimeModule.d.ts
export = ShareRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Compilation")} Compilation */
declare class ShareRuntimeModule extends RuntimeModule {
    constructor();
}
declare namespace ShareRuntimeModule {
    export { Chunk, ChunkGraph, Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/resolveMatchedConfigs.d.ts
export function resolveMatchedConfigs<T>(compilation: Compilation, configs: [string, T][]): Promise<MatchedConfigs<T>>;
export type Compilation = import("../Compilation");
export type ResolveOptionsWithDependencyType = import("../ResolverFactory").ResolveOptionsWithDependencyType;
export type MatchedConfigs<T> = {
    resolved: Map<string, T>;
    unresolved: Map<string, T>;
    prefixed: Map<string, T>;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/sharing/utils.d.ts
export function getRequiredVersionFromDescriptionFile(data: any, packageName: any): string;
export type InputFileSystem = import("../util/fs").InputFileSystem;
/**
 * @param {string} str maybe required version
 * @returns {boolean} true, if it looks like a version
 */
export function isRequiredVersion(str: string): boolean;
/**
 * @see https://docs.npmjs.com/cli/v7/configuring-npm/package-json#urls-as-dependencies
 * @param {string} versionDesc version to be normalized
 * @returns {string} normalized version
 */
export function normalizeVersion(versionDesc: string): string;
/**
 *
 * @param {InputFileSystem} fs file system
 * @param {string} directory directory to start looking into
 * @param {string[]} descriptionFiles possible description filenames
 * @param {function((Error | null)=, {data: object, path: string}=): void} callback callback
 */
export function getDescriptionFile(fs: InputFileSystem, directory: string, descriptionFiles: string[], callback: (arg0: (Error | null) | undefined, arg1: {
    data: object;
    path: string;
} | undefined) => void): void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/stats/DefaultStatsFactoryPlugin.d.ts
export = DefaultStatsFactoryPlugin;
declare class DefaultStatsFactoryPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DefaultStatsFactoryPlugin {
    export { Source, Chunk, ChunkGroup, OriginRecord, Compilation, Asset, AssetInfo, NormalizedStatsOptions, Compiler, Dependency, DependencyLocation, Module, ModuleGraphConnection, ModuleProfile, RequestShortener, WebpackError, Comparator, RuntimeSpec, GroupConfig, StatsFactory, StatsFactoryContext, StatsCompilation, KnownStatsCompilation, StatsLogging, KnownStatsLogging, StatsLoggingEntry, KnownStatsLoggingEntry, StatsAsset, KnownStatsAsset, StatsChunkGroup, KnownStatsChunkGroup, StatsModule, KnownStatsModule, StatsProfile, KnownStatsProfile, StatsModuleIssuer, KnownStatsModuleIssuer, StatsModuleReason, KnownStatsModuleReason, StatsChunk, KnownStatsChunk, StatsChunkOrigin, KnownStatsChunkOrigin, StatsModuleTraceItem, KnownStatsModuleTraceItem, StatsModuleTraceDependency, KnownStatsModuleTraceDependency, StatsError, KnownStatsError, PreprocessedAsset, ExtractorsByOption, SimpleExtractors, MappedValues };
}
type Compiler = import("../Compiler");
type Source = import("webpack-sources").Source;
type Chunk = import("../Chunk");
type ChunkGroup = import("../ChunkGroup");
type OriginRecord = import("../ChunkGroup").OriginRecord;
type Compilation = import("../Compilation");
type Asset = import("../Compilation").Asset;
type AssetInfo = import("../Compilation").AssetInfo;
type NormalizedStatsOptions = import("../Compilation").NormalizedStatsOptions;
type Dependency = import("../Dependency");
type DependencyLocation = import("../Dependency").DependencyLocation;
type Module = import("../Module");
type ModuleGraphConnection = import("../ModuleGraphConnection");
type ModuleProfile = import("../ModuleProfile");
type RequestShortener = import("../RequestShortener");
type WebpackError = import("../WebpackError");
/**
 * <T>
 */
type Comparator<T> = import("../util/comparators").Comparator<T>;
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
type GroupConfig = import("../util/smartGrouping").GroupConfig<any, object>;
type StatsFactory = import("./StatsFactory");
type StatsFactoryContext = import("./StatsFactory").StatsFactoryContext;
type StatsCompilation = KnownStatsCompilation & Record<string, any>;
type KnownStatsCompilation = {
    env?: any | undefined;
    name?: string | undefined;
    hash?: string | undefined;
    version?: string | undefined;
    time?: number | undefined;
    builtAt?: number | undefined;
    needAdditionalPass?: boolean | undefined;
    publicPath?: string | undefined;
    outputPath?: string | undefined;
    assetsByChunkName?: Record<string, string[]> | undefined;
    assets?: StatsAsset[] | undefined;
    filteredAssets?: number | undefined;
    chunks?: StatsChunk[] | undefined;
    modules?: StatsModule[] | undefined;
    filteredModules?: number | undefined;
    entrypoints?: Record<string, StatsChunkGroup> | undefined;
    namedChunkGroups?: Record<string, StatsChunkGroup> | undefined;
    errors?: StatsError[] | undefined;
    errorsCount?: number | undefined;
    warnings?: StatsError[] | undefined;
    warningsCount?: number | undefined;
    children?: StatsCompilation[] | undefined;
    logging?: Record<string, StatsLogging> | undefined;
};
type StatsLogging = KnownStatsLogging & Record<string, any>;
type KnownStatsLogging = {
    entries: StatsLoggingEntry[];
    filteredEntries: number;
    debug: boolean;
};
type StatsLoggingEntry = KnownStatsLoggingEntry & Record<string, any>;
type KnownStatsLoggingEntry = {
    type: string;
    message: string;
    trace?: string[] | undefined;
    children?: StatsLoggingEntry[] | undefined;
    args?: any[] | undefined;
    time?: number | undefined;
};
type StatsAsset = KnownStatsAsset & Record<string, any>;
type KnownStatsAsset = {
    type: string;
    name: string;
    info: AssetInfo;
    size: number;
    emitted: boolean;
    comparedForEmit: boolean;
    cached: boolean;
    related?: StatsAsset[] | undefined;
    chunkNames?: (string | number)[] | undefined;
    chunkIdHints?: (string | number)[] | undefined;
    chunks?: (string | number)[] | undefined;
    auxiliaryChunkNames?: (string | number)[] | undefined;
    auxiliaryChunks?: (string | number)[] | undefined;
    auxiliaryChunkIdHints?: (string | number)[] | undefined;
    filteredRelated?: number | undefined;
    isOverSizeLimit?: boolean | undefined;
};
type StatsChunkGroup = KnownStatsChunkGroup & Record<string, any>;
type KnownStatsChunkGroup = {
    name?: string | undefined;
    chunks?: (string | number)[] | undefined;
    assets?: ({
        name: string;
        size?: number;
    })[] | undefined;
    filteredAssets?: number | undefined;
    assetsSize?: number | undefined;
    auxiliaryAssets?: ({
        name: string;
        size?: number;
    })[] | undefined;
    filteredAuxiliaryAssets?: number | undefined;
    auxiliaryAssetsSize?: number | undefined;
    children?: {
        [x: string]: StatsChunkGroup[];
    };
    childAssets?: {
        [x: string]: string[];
    };
    isOverSizeLimit?: boolean | undefined;
};
type StatsModule = KnownStatsModule & Record<string, any>;
type KnownStatsModule = {
    type?: string | undefined;
    moduleType?: string | undefined;
    layer?: string | undefined;
    identifier?: string | undefined;
    name?: string | undefined;
    nameForCondition?: string | undefined;
    index?: number | undefined;
    preOrderIndex?: number | undefined;
    index2?: number | undefined;
    postOrderIndex?: number | undefined;
    size?: number | undefined;
    sizes?: {
        [x: string]: number;
    };
    cacheable?: boolean | undefined;
    built?: boolean | undefined;
    codeGenerated?: boolean | undefined;
    buildTimeExecuted?: boolean | undefined;
    cached?: boolean | undefined;
    optional?: boolean | undefined;
    orphan?: boolean | undefined;
    id?: (string | number) | undefined;
    issuerId?: (string | number) | undefined;
    chunks?: (string | number)[] | undefined;
    assets?: (string | number)[] | undefined;
    dependent?: boolean | undefined;
    issuer?: string | undefined;
    issuerName?: string | undefined;
    issuerPath?: StatsModuleIssuer[] | undefined;
    failed?: boolean | undefined;
    errors?: number | undefined;
    warnings?: number | undefined;
    profile?: StatsProfile | undefined;
    reasons?: StatsModuleReason[] | undefined;
    usedExports?: (boolean | string[]) | undefined;
    providedExports?: string[] | undefined;
    optimizationBailout?: string[] | undefined;
    depth?: number | undefined;
    modules?: StatsModule[] | undefined;
    filteredModules?: number | undefined;
    source?: ReturnType<Source["source"]> | undefined;
};
type StatsProfile = KnownStatsProfile & Record<string, any>;
type KnownStatsProfile = {
    total: number;
    resolving: number;
    restoring: number;
    building: number;
    integration: number;
    storing: number;
    additionalResolving: number;
    additionalIntegration: number;
    factory: number;
    dependencies: number;
};
type StatsModuleIssuer = KnownStatsModuleIssuer & Record<string, any>;
type KnownStatsModuleIssuer = {
    identifier?: string | undefined;
    name?: string | undefined;
    id?: (string | number) | undefined;
    profile?: StatsProfile | undefined;
};
type StatsModuleReason = KnownStatsModuleReason & Record<string, any>;
type KnownStatsModuleReason = {
    moduleIdentifier?: string | undefined;
    module?: string | undefined;
    moduleName?: string | undefined;
    resolvedModuleIdentifier?: string | undefined;
    resolvedModule?: string | undefined;
    type?: string | undefined;
    active: boolean;
    explanation?: string | undefined;
    userRequest?: string | undefined;
    loc?: string | undefined;
    moduleId?: (string | number) | undefined;
    resolvedModuleId?: (string | number) | undefined;
};
type StatsChunk = KnownStatsChunk & Record<string, any>;
type KnownStatsChunk = {
    rendered: boolean;
    initial: boolean;
    entry: boolean;
    recorded: boolean;
    reason?: string | undefined;
    size: number;
    sizes?: Record<string, number> | undefined;
    names?: string[] | undefined;
    idHints?: string[] | undefined;
    runtime?: string[] | undefined;
    files?: string[] | undefined;
    auxiliaryFiles?: string[] | undefined;
    hash: string;
    childrenByOrder?: Record<string, (string | number)[]> | undefined;
    id?: (string | number) | undefined;
    siblings?: (string | number)[] | undefined;
    parents?: (string | number)[] | undefined;
    children?: (string | number)[] | undefined;
    modules?: StatsModule[] | undefined;
    filteredModules?: number | undefined;
    origins?: StatsChunkOrigin[] | undefined;
};
type StatsChunkOrigin = KnownStatsChunkOrigin & Record<string, any>;
type KnownStatsChunkOrigin = {
    module?: string | undefined;
    moduleIdentifier?: string | undefined;
    moduleName?: string | undefined;
    loc?: string | undefined;
    request?: string | undefined;
    moduleId?: (string | number) | undefined;
};
type StatsModuleTraceItem = KnownStatsModuleTraceItem & Record<string, any>;
type KnownStatsModuleTraceItem = {
    originIdentifier?: string | undefined;
    originName?: string | undefined;
    moduleIdentifier?: string | undefined;
    moduleName?: string | undefined;
    dependencies?: StatsModuleTraceDependency[] | undefined;
    originId?: (string | number) | undefined;
    moduleId?: (string | number) | undefined;
};
type StatsModuleTraceDependency = KnownStatsModuleTraceDependency & Record<string, any>;
type KnownStatsModuleTraceDependency = {
    loc?: string | undefined;
};
type StatsError = KnownStatsError & Record<string, any>;
type KnownStatsError = {
    message: string;
    chunkName?: string | undefined;
    chunkEntry?: boolean | undefined;
    chunkInitial?: boolean | undefined;
    file?: string | undefined;
    moduleIdentifier?: string | undefined;
    moduleName?: string | undefined;
    loc?: string | undefined;
    chunkId?: (string | number) | undefined;
    moduleId?: (string | number) | undefined;
    moduleTrace?: StatsModuleTraceItem[] | undefined;
    details?: any | undefined;
    stack?: string | undefined;
};
type PreprocessedAsset = Asset & {
    type: string;
    related: PreprocessedAsset[];
};
type ExtractorsByOption<T, O> = {
    [x: string]: (object: O, data: T, context: StatsFactoryContext, options: NormalizedStatsOptions, factory: StatsFactory) => void;
};
type SimpleExtractors = {
    compilation: ExtractorsByOption<Compilation, StatsCompilation>;
    asset: ExtractorsByOption<PreprocessedAsset, StatsAsset>;
    asset$visible: ExtractorsByOption<PreprocessedAsset, StatsAsset>;
    chunkGroup: ExtractorsByOption<{
        name: string;
        chunkGroup: ChunkGroup;
    }, StatsChunkGroup>;
    module: ExtractorsByOption<Module, StatsModule>;
    module$visible: ExtractorsByOption<Module, StatsModule>;
    moduleIssuer: ExtractorsByOption<Module, StatsModuleIssuer>;
    profile: ExtractorsByOption<ModuleProfile, StatsProfile>;
    moduleReason: ExtractorsByOption<ModuleGraphConnection, StatsModuleReason>;
    chunk: ExtractorsByOption<Chunk, StatsChunk>;
    chunkOrigin: ExtractorsByOption<OriginRecord, StatsChunkOrigin>;
    error: ExtractorsByOption<WebpackError, StatsError>;
    warning: ExtractorsByOption<WebpackError, StatsError>;
    moduleTraceItem: ExtractorsByOption<{
        origin: Module;
        module: Module;
    }, StatsModuleTraceItem>;
    moduleTraceDependency: ExtractorsByOption<Dependency, StatsModuleTraceDependency>;
};
/**
 * <T, R>
 */
type MappedValues<T, R> = { [P in keyof T]: R; };
declare namespace module {
    namespace exports {
        export { Source, Chunk, ChunkGroup, OriginRecord, Compilation, Asset, AssetInfo, NormalizedStatsOptions, Compiler, Dependency, DependencyLocation, Module, ModuleGraphConnection, ModuleProfile, RequestShortener, WebpackError, Comparator, RuntimeSpec, GroupConfig, StatsFactory, StatsFactoryContext, StatsCompilation, KnownStatsCompilation, StatsLogging, KnownStatsLogging, StatsLoggingEntry, KnownStatsLoggingEntry, StatsAsset, KnownStatsAsset, StatsChunkGroup, KnownStatsChunkGroup, StatsModule, KnownStatsModule, StatsProfile, KnownStatsProfile, StatsModuleIssuer, KnownStatsModuleIssuer, StatsModuleReason, KnownStatsModuleReason, StatsChunk, KnownStatsChunk, StatsChunkOrigin, KnownStatsChunkOrigin, StatsModuleTraceItem, KnownStatsModuleTraceItem, StatsModuleTraceDependency, KnownStatsModuleTraceDependency, StatsError, KnownStatsError, PreprocessedAsset, ExtractorsByOption, SimpleExtractors, MappedValues };
    }
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/stats/DefaultStatsPresetPlugin.d.ts
export = DefaultStatsPresetPlugin;
declare class DefaultStatsPresetPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DefaultStatsPresetPlugin {
    export { StatsOptions, Compilation, CreateStatsOptionsContext, Compiler };
}
type Compiler = import("../Compiler");
type StatsOptions = any;
type Compilation = import("../Compilation");
type CreateStatsOptionsContext = import("../Compilation").CreateStatsOptionsContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/stats/DefaultStatsPrinterPlugin.d.ts
export = DefaultStatsPrinterPlugin;
declare class DefaultStatsPrinterPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace DefaultStatsPrinterPlugin {
    export { Compiler, StatsPrinter, StatsPrinterContext };
}
type Compiler = import("../Compiler");
type StatsPrinter = import("./StatsPrinter");
type StatsPrinterContext = import("./StatsPrinter").StatsPrinterContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/stats/StatsFactory.d.ts
export = StatsFactory;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../WebpackError")} WebpackError */
/** @typedef {import("../util/runtime").RuntimeSpec} RuntimeSpec */
/** @typedef {import("../util/smartGrouping").GroupConfig<any, object>} GroupConfig */
/**
 * @typedef {Object} KnownStatsFactoryContext
 * @property {string} type
 * @property {function(string): string=} makePathsRelative
 * @property {Compilation=} compilation
 * @property {Set<Module>=} rootModules
 * @property {Map<string,Chunk[]>=} compilationFileToChunks
 * @property {Map<string,Chunk[]>=} compilationAuxiliaryFileToChunks
 * @property {RuntimeSpec=} runtime
 * @property {function(Compilation): WebpackError[]=} cachedGetErrors
 * @property {function(Compilation): WebpackError[]=} cachedGetWarnings
 */
/** @typedef {KnownStatsFactoryContext & Record<string, any>} StatsFactoryContext */
declare class StatsFactory {
    hooks: Readonly<{
        /** @type {HookMap<SyncBailHook<[Object, any, StatsFactoryContext]>>} */
        extract: HookMap<SyncBailHook<[any, any, StatsFactoryContext], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {HookMap<SyncBailHook<[any, StatsFactoryContext, number, number]>>} */
        filter: HookMap<SyncBailHook<[any, StatsFactoryContext, number, number], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {HookMap<SyncBailHook<[(function(any, any): number)[], StatsFactoryContext]>>} */
        sort: HookMap<SyncBailHook<[((arg0: any, arg1: any) => number)[], StatsFactoryContext], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {HookMap<SyncBailHook<[any, StatsFactoryContext, number, number]>>} */
        filterSorted: HookMap<SyncBailHook<[any, StatsFactoryContext, number, number], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {HookMap<SyncBailHook<[GroupConfig[], StatsFactoryContext]>>} */
        groupResults: HookMap<SyncBailHook<[GroupConfig[], StatsFactoryContext], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {HookMap<SyncBailHook<[(function(any, any): number)[], StatsFactoryContext]>>} */
        sortResults: HookMap<SyncBailHook<[((arg0: any, arg1: any) => number)[], StatsFactoryContext], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {HookMap<SyncBailHook<[any, StatsFactoryContext, number, number]>>} */
        filterResults: HookMap<SyncBailHook<[any, StatsFactoryContext, number, number], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {HookMap<SyncBailHook<[any[], StatsFactoryContext]>>} */
        merge: HookMap<SyncBailHook<[any[], StatsFactoryContext], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {HookMap<SyncBailHook<[any[], StatsFactoryContext]>>} */
        result: HookMap<SyncBailHook<[any[], StatsFactoryContext], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {HookMap<SyncBailHook<[any, StatsFactoryContext]>>} */
        getItemName: HookMap<SyncBailHook<[any, StatsFactoryContext], any, import("tapable").UnsetAdditionalOptions>>;
        /** @type {HookMap<SyncBailHook<[any, StatsFactoryContext]>>} */
        getItemFactory: HookMap<SyncBailHook<[any, StatsFactoryContext], any, import("tapable").UnsetAdditionalOptions>>;
    }>;
    _caches: Record<"filter" | "sort" | "result" | "merge" | "extract" | "filterSorted" | "groupResults" | "sortResults" | "filterResults" | "getItemName" | "getItemFactory", Map<string, SyncBailHook<[any[], StatsFactoryContext], any, import("tapable").UnsetAdditionalOptions>[]>>;
    _inCreate: boolean;
    _getAllLevelHooks(hookMap: any, cache: any, type: any): any;
    _forEachLevel(hookMap: any, cache: any, type: any, fn: any): any;
    _forEachLevelWaterfall(hookMap: any, cache: any, type: any, data: any, fn: any): any;
    _forEachLevelFilter(hookMap: any, cache: any, type: any, items: any, fn: any, forceClone: any): any;
    /**
     * @param {string} type type
     * @param {any} data factory data
     * @param {Omit<StatsFactoryContext, "type">} baseContext context used as base
     * @returns {any} created object
     */
    create(type: string, data: any, baseContext: Omit<StatsFactoryContext, "type">): any;
    _create(type: any, data: any, baseContext: any): any;
}
declare namespace StatsFactory {
    export { Chunk, Compilation, Module, WebpackError, RuntimeSpec, GroupConfig, KnownStatsFactoryContext, StatsFactoryContext };
}
import { HookMap } from "tapable";
type StatsFactoryContext = KnownStatsFactoryContext & Record<string, any>;
import { SyncBailHook } from "tapable";
type GroupConfig = import("../util/smartGrouping").GroupConfig<any, object>;
type Chunk = import("../Chunk");
type Compilation = import("../Compilation");
type Module = import("../Module");
type WebpackError = import("../WebpackError");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
type KnownStatsFactoryContext = {
    type: string;
    makePathsRelative?: ((arg0: string) => string) | undefined;
    compilation?: Compilation | undefined;
    rootModules?: Set<Module> | undefined;
    compilationFileToChunks?: Map<string, Chunk[]> | undefined;
    compilationAuxiliaryFileToChunks?: Map<string, Chunk[]> | undefined;
    runtime?: RuntimeSpec | undefined;
    cachedGetErrors?: ((arg0: Compilation) => WebpackError[]) | undefined;
    cachedGetWarnings?: ((arg0: Compilation) => WebpackError[]) | undefined;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/stats/StatsPrinter.d.ts
export = StatsPrinter;
/** @template T @typedef {import("tapable").AsArray<T>} AsArray<T> */
/** @typedef {import("tapable").Hook} Hook */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsAsset} StatsAsset */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsChunk} StatsChunk */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsChunkGroup} StatsChunkGroup */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsCompilation} StatsCompilation */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModule} StatsModule */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModuleReason} StatsModuleReason */
/**
 * @typedef {Object} PrintedElement
 * @property {string} element
 * @property {string} content
 */
/**
 * @typedef {Object} KnownStatsPrinterContext
 * @property {string=} type
 * @property {StatsCompilation=} compilation
 * @property {StatsChunkGroup=} chunkGroup
 * @property {StatsAsset=} asset
 * @property {StatsModule=} module
 * @property {StatsChunk=} chunk
 * @property {StatsModuleReason=} moduleReason
 * @property {(str: string) => string=} bold
 * @property {(str: string) => string=} yellow
 * @property {(str: string) => string=} red
 * @property {(str: string) => string=} green
 * @property {(str: string) => string=} magenta
 * @property {(str: string) => string=} cyan
 * @property {(file: string, oversize?: boolean) => string=} formatFilename
 * @property {(id: string) => string=} formatModuleId
 * @property {(id: string, direction?: "parent"|"child"|"sibling") => string=} formatChunkId
 * @property {(size: number) => string=} formatSize
 * @property {(dateTime: number) => string=} formatDateTime
 * @property {(flag: string) => string=} formatFlag
 * @property {(time: number, boldQuantity?: boolean) => string=} formatTime
 * @property {string=} chunkGroupKind
 */
/** @typedef {KnownStatsPrinterContext & Record<string, any>} StatsPrinterContext */
declare class StatsPrinter {
    hooks: Readonly<{
        /** @type {HookMap<SyncBailHook<[string[], StatsPrinterContext], true>>} */
        sortElements: HookMap<SyncBailHook<[string[], StatsPrinterContext], true>>;
        /** @type {HookMap<SyncBailHook<[PrintedElement[], StatsPrinterContext], string>>} */
        printElements: HookMap<SyncBailHook<[PrintedElement[], StatsPrinterContext], string>>;
        /** @type {HookMap<SyncBailHook<[any[], StatsPrinterContext], true>>} */
        sortItems: HookMap<SyncBailHook<[any[], StatsPrinterContext], true>>;
        /** @type {HookMap<SyncBailHook<[any, StatsPrinterContext], string>>} */
        getItemName: HookMap<SyncBailHook<[any, StatsPrinterContext], string>>;
        /** @type {HookMap<SyncBailHook<[string[], StatsPrinterContext], string>>} */
        printItems: HookMap<SyncBailHook<[string[], StatsPrinterContext], string>>;
        /** @type {HookMap<SyncBailHook<[{}, StatsPrinterContext], string>>} */
        print: HookMap<SyncBailHook<[{}, StatsPrinterContext], string>>;
        /** @type {HookMap<SyncWaterfallHook<[string, StatsPrinterContext]>>} */
        result: HookMap<SyncWaterfallHook<[string, StatsPrinterContext]>>;
    }>;
    /** @type {Map<HookMap<Hook>, Map<string, Hook[]>>} */
    _levelHookCache: Map<HookMap<import("tapable").Hook<any, any, import("tapable").UnsetAdditionalOptions>>, Map<string, import("tapable").Hook<any, any, import("tapable").UnsetAdditionalOptions>[]>>;
    _inPrint: boolean;
    /**
     * get all level hooks
     * @private
     * @template {Hook} T
     * @param {HookMap<T>} hookMap HookMap
     * @param {string} type type
     * @returns {T[]} hooks
     */
    private _getAllLevelHooks;
    /**
     * Run `fn` for each level
     * @private
     * @template T
     * @template R
     * @param {HookMap<SyncBailHook<T, R>>} hookMap HookMap
     * @param {string} type type
     * @param {(hook: SyncBailHook<T, R>) => R} fn function
     * @returns {R} result of `fn`
     */
    private _forEachLevel;
    /**
     * Run `fn` for each level
     * @private
     * @template T
     * @param {HookMap<SyncWaterfallHook<T>>} hookMap HookMap
     * @param {string} type type
     * @param {AsArray<T>[0]} data data
     * @param {(hook: SyncWaterfallHook<T>, data: AsArray<T>[0]) => AsArray<T>[0]} fn function
     * @returns {AsArray<T>[0]} result of `fn`
     */
    private _forEachLevelWaterfall;
    /**
     * @param {string} type The type
     * @param {Object} object Object to print
     * @param {Object=} baseContext The base context
     * @returns {string} printed result
     */
    print(type: string, object: any, baseContext?: any | undefined): string;
    /**
     * @private
     * @param {string} type type
     * @param {Object} object object
     * @param {Object=} baseContext context
     * @returns {string} printed result
     */
    private _print;
}
declare namespace StatsPrinter {
    export { AsArray, Hook, StatsAsset, StatsChunk, StatsChunkGroup, StatsCompilation, StatsModule, StatsModuleReason, PrintedElement, KnownStatsPrinterContext, StatsPrinterContext };
}
import { HookMap } from "tapable";
import { SyncBailHook } from "tapable";
type StatsPrinterContext = KnownStatsPrinterContext & Record<string, any>;
type PrintedElement = {
    element: string;
    content: string;
};
import { SyncWaterfallHook } from "tapable";
/**
 * <T>
 */
type AsArray<T> = import("tapable").AsArray<T>;
type Hook = import("tapable").Hook<any, any, import("tapable").UnsetAdditionalOptions>;
type StatsAsset = import("./DefaultStatsFactoryPlugin").StatsAsset;
type StatsChunk = import("./DefaultStatsFactoryPlugin").StatsChunk;
type StatsChunkGroup = import("./DefaultStatsFactoryPlugin").StatsChunkGroup;
type StatsCompilation = import("./DefaultStatsFactoryPlugin").StatsCompilation;
type StatsModule = import("./DefaultStatsFactoryPlugin").StatsModule;
type StatsModuleReason = import("./DefaultStatsFactoryPlugin").StatsModuleReason;
type KnownStatsPrinterContext = {
    type?: string | undefined;
    compilation?: StatsCompilation | undefined;
    chunkGroup?: StatsChunkGroup | undefined;
    asset?: StatsAsset | undefined;
    module?: StatsModule | undefined;
    chunk?: StatsChunk | undefined;
    moduleReason?: StatsModuleReason | undefined;
    bold?: (str: string) => string;
    yellow?: (str: string) => string;
    red?: (str: string) => string;
    green?: (str: string) => string;
    magenta?: (str: string) => string;
    cyan?: (str: string) => string;
    formatFilename?: (file: string, oversize?: boolean) => string;
    formatModuleId?: (id: string) => string;
    formatChunkId?: (id: string, direction?: "parent" | "child" | "sibling") => string;
    formatSize?: (size: number) => string;
    formatDateTime?: (dateTime: number) => string;
    formatFlag?: (flag: string) => string;
    formatTime?: (time: number, boldQuantity?: boolean) => string;
    chunkGroupKind?: string | undefined;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/ArrayHelpers.d.ts
export function equals<T>(a: ArrayLike<T>, b: ArrayLike<T>): boolean;
export function groupBy<T>(arr: T[], fn: (value: T) => boolean): [T[], T[]];

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/ArrayQueue.d.ts
export = ArrayQueue;
/**
 * @template T
 */
declare class ArrayQueue<T> {
    /**
     * @param {Iterable<T>=} items The initial elements.
     */
    constructor(items?: Iterable<T> | undefined);
    /** @private @type {T[]} */
    private _list;
    /** @private @type {T[]} */
    private _listReversed;
    /**
     * Returns the number of elements in this queue.
     * @returns {number} The number of elements in this queue.
     */
    get length(): number;
    /**
     * Empties the queue.
     */
    clear(): void;
    /**
     * Appends the specified element to this queue.
     * @param {T} item The element to add.
     * @returns {void}
     */
    enqueue(item: T): void;
    /**
     * Retrieves and removes the head of this queue.
     * @returns {T | undefined} The head of the queue of `undefined` if this queue is empty.
     */
    dequeue(): T | undefined;
    /**
     * Finds and removes an item
     * @param {T} item the item
     * @returns {void}
     */
    delete(item: T): void;
    [Symbol.iterator](): {
        next: () => {
            done: boolean;
            value: T;
        };
    };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/AsyncQueue.d.ts
export = AsyncQueue;
/**
 * @template T
 * @template K
 * @template R
 */
declare class AsyncQueue<T, K, R> {
    /**
     * @param {Object} options options object
     * @param {string=} options.name name of the queue
     * @param {number=} options.parallelism how many items should be processed at once
     * @param {AsyncQueue<any, any, any>=} options.parent parent queue, which will have priority over this queue and with shared parallelism
     * @param {function(T): K=} options.getKey extract key from item
     * @param {function(T, Callback<R>): void} options.processor async function to process items
     */
    constructor({ name, parallelism, parent, processor, getKey }: {
        name?: string | undefined;
        parallelism?: number | undefined;
        parent?: AsyncQueue<any, any, any> | undefined;
        getKey?: ((arg0: T) => K) | undefined;
        processor: (arg0: T, arg1: Callback<R>) => void;
    });
    _name: string;
    _parallelism: number;
    _processor: (arg0: T, arg1: Callback<R>) => void;
    _getKey: (arg0: T) => K;
    /** @type {Map<K, AsyncQueueEntry<T, K, R>>} */
    _entries: Map<K, AsyncQueueEntry<T, K, R>>;
    /** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>} */
    _queued: ArrayQueue<AsyncQueueEntry<T, K, R>>;
    /** @type {AsyncQueue<any, any, any>[] | undefined} */
    _children: AsyncQueue<any, any, any>[] | undefined;
    _activeTasks: number;
    _willEnsureProcessing: boolean;
    _needProcessing: boolean;
    _stopped: boolean;
    _root: this;
    hooks: {
        /** @type {AsyncSeriesHook<[T]>} */
        beforeAdd: AsyncSeriesHook<[T]>;
        /** @type {SyncHook<[T]>} */
        added: SyncHook<[T]>;
        /** @type {AsyncSeriesHook<[T]>} */
        beforeStart: AsyncSeriesHook<[T]>;
        /** @type {SyncHook<[T]>} */
        started: SyncHook<[T]>;
        /** @type {SyncHook<[T, Error, R]>} */
        result: SyncHook<[T, Error, R]>;
    };
    /**
     * @returns {void}
     */
    _ensureProcessing(): void;
    /**
     * @param {T} item an item
     * @param {Callback<R>} callback callback function
     * @returns {void}
     */
    add(item: T, callback: Callback<R>): void;
    /**
     * @param {T} item an item
     * @returns {void}
     */
    invalidate(item: T): void;
    /**
     * Waits for an already started item
     * @param {T} item an item
     * @param {Callback<R>} callback callback function
     * @returns {void}
     */
    waitFor(item: T, callback: Callback<R>): void;
    /**
     * @returns {void}
     */
    stop(): void;
    /**
     * @returns {void}
     */
    increaseParallelism(): void;
    /**
     * @returns {void}
     */
    decreaseParallelism(): void;
    /**
     * @param {T} item an item
     * @returns {boolean} true, if the item is currently being processed
     */
    isProcessing(item: T): boolean;
    /**
     * @param {T} item an item
     * @returns {boolean} true, if the item is currently queued
     */
    isQueued(item: T): boolean;
    /**
     * @param {T} item an item
     * @returns {boolean} true, if the item is currently queued
     */
    isDone(item: T): boolean;
    /**
     * @param {AsyncQueueEntry<T, K, R>} entry the entry
     * @returns {void}
     */
    _startProcessing(entry: AsyncQueueEntry<T, K, R>): void;
    /**
     * @param {AsyncQueueEntry<T, K, R>} entry the entry
     * @param {WebpackError=} err error, if any
     * @param {R=} result result, if any
     * @returns {void}
     */
    _handleResult(entry: AsyncQueueEntry<T, K, R>, err?: WebpackError | undefined, result?: R | undefined): void;
    clear(): void;
}
declare namespace AsyncQueue {
    export { Callback };
}
type Callback<T> = (err?: (WebpackError | null) | undefined, result?: T | undefined) => any;
/**
 * @template T
 * @callback Callback
 * @param {(WebpackError | null)=} err
 * @param {T=} result
 */
/**
 * @template T
 * @template K
 * @template R
 */
declare class AsyncQueueEntry<T, K, R> {
    /**
     * @param {T} item the item
     * @param {Callback<R>} callback the callback
     */
    constructor(item: T, callback: Callback<R>);
    item: T;
    /** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE} */
    state: typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE;
    callback: Callback<R>;
    /** @type {Callback<R>[] | undefined} */
    callbacks: Callback<R>[] | undefined;
    result: any;
    /** @type {WebpackError | undefined} */
    error: WebpackError | undefined;
}
import ArrayQueue = require("webpack/lib/util/ArrayQueue");
import { AsyncSeriesHook } from "tapable";
import { SyncHook } from "tapable";
import WebpackError = require("webpack/lib/WebpackError");
declare const QUEUED_STATE: 0;
declare const PROCESSING_STATE: 1;
declare const DONE_STATE: 2;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/Hash.d.ts
export = Hash;
declare class Hash {
    /**
     * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
     * @abstract
     * @param {string|Buffer} data data
     * @param {string=} inputEncoding data encoding
     * @returns {this} updated hash
     */
    update(data: string | Buffer, inputEncoding?: string | undefined): this;
    /**
     * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
     * @abstract
     * @param {string=} encoding encoding of the return value
     * @returns {string|Buffer} digest
     */
    digest(encoding?: string | undefined): string | Buffer;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/IterableHelpers.d.ts
/**
 * @template T
 * @param {Iterable<T>} set a set
 * @returns {T | undefined} last item
 */
export function last<T>(set: Iterable<T>): T;
/**
 * @template T
 * @param {Iterable<T>} iterable iterable
 * @param {function(T): boolean} filter predicate
 * @returns {boolean} true, if some items match the filter predicate
 */
export function someInIterable<T>(iterable: Iterable<T>, filter: (arg0: T) => boolean): boolean;
/**
 * @template T
 * @param {Iterable<T>} iterable an iterable
 * @returns {number} count of items
 */
export function countIterable<T>(iterable: Iterable<T>): number;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/LazyBucketSortedSet.d.ts
export = LazyBucketSortedSet;
/**
 * Multi layer bucket sorted set:
 * Supports adding non-existing items (DO NOT ADD ITEM TWICE),
 * Supports removing exiting items (DO NOT REMOVE ITEM NOT IN SET),
 * Supports popping the first items according to defined order,
 * Supports iterating all items without order,
 * Supports updating an item in an efficient way,
 * Supports size property, which is the number of items,
 * Items are lazy partially sorted when needed
 * @template T
 * @template K
 */
declare class LazyBucketSortedSet<T, K> {
    /**
     * @param {function(T): K} getKey function to get key from item
     * @param {function(K, K): number} comparator comparator to sort keys
     * @param  {...((function(T): any) | (function(any, any): number))} args more pairs of getKey and comparator plus optional final comparator for the last layer
     */
    constructor(getKey: (arg0: T) => K, comparator: (arg0: K, arg1: K) => number, ...args: (((arg0: T) => any) | ((arg0: any, arg1: any) => number))[]);
    _getKey: (arg0: T) => K;
    _innerArgs: (((arg0: T) => any) | ((arg0: any, arg1: any) => number))[];
    _leaf: boolean;
    _keys: SortableSet<K>;
    /** @type {Map<K, LazyBucketSortedSet<T, any> | SortableSet<T>>} */
    _map: Map<K, LazyBucketSortedSet<T, any> | SortableSet<T>>;
    _unsortedItems: Set<any>;
    size: number;
    /**
     * @param {T} item an item
     * @returns {void}
     */
    add(item: T): void;
    /**
     * @param {K} key key of item
     * @param {T} item the item
     * @returns {void}
     */
    _addInternal(key: K, item: T): void;
    /**
     * @param {T} item an item
     * @returns {void}
     */
    delete(item: T): void;
    /**
     * @param {K} key key to be removed
     * @returns {void}
     */
    _deleteKey(key: K): void;
    /**
     * @returns {T | undefined} an item
     */
    popFirst(): T | undefined;
    /**
     * @param {T} item to be updated item
     * @returns {function(true=): void} finish update
     */
    startUpdate(item: T): (arg0: true | undefined) => void;
    /**
     * @param {Iterator<T>[]} iterators list of iterators to append to
     * @returns {void}
     */
    _appendIterators(iterators: Iterator<T>[]): void;
    /**
     * @returns {Iterator<T>} the iterator
     */
    [Symbol.iterator](): Iterator<T>;
}
import SortableSet = require("webpack/lib/util/SortableSet");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/LazySet.d.ts
export = LazySet;
/**
 * Like Set but with an addAll method to eventually add items from another iterable.
 * Access methods make sure that all delayed operations are executed.
 * Iteration methods deopts to normal Set performance until clear is called again (because of the chance of modifications during iteration).
 * @template T
 */
declare class LazySet<T> {
    /**
     * @template T
     * @param {import("../serialization/ObjectMiddleware").ObjectDeserializerContext} context context
     * @returns {LazySet<T>} lazy set
     */
    static deserialize<T_1>({ read }: import("../serialization/ObjectMiddleware").ObjectDeserializerContext): LazySet<T_1>;
    /**
     * @param {Iterable<T>=} iterable init iterable
     */
    constructor(iterable?: Iterable<T> | undefined);
    /** @type {Set<T>} */
    _set: Set<T>;
    /** @type {Set<Iterable<T>>} */
    _toMerge: Set<Iterable<T>>;
    /** @type {Array<LazySet<T>>} */
    _toDeepMerge: Array<LazySet<T>>;
    _needMerge: boolean;
    _deopt: boolean;
    _flatten(): void;
    _merge(): void;
    _isEmpty(): boolean;
    get size(): number;
    /**
     * @param {T} item an item
     * @returns {LazySet<T>} itself
     */
    add(item: T): LazySet<T>;
    /**
     * @param {Iterable<T> | LazySet<T>} iterable a immutable iterable or another immutable LazySet which will eventually be merged into the Set
     * @returns {LazySet<T>} itself
     */
    addAll(iterable: Iterable<T> | LazySet<T>): LazySet<T>;
    clear(): void;
    /**
     * @param {T} value an item
     * @returns {boolean} true, if the value was in the Set before
     */
    delete(value: T): boolean;
    entries(): IterableIterator<[T, T]>;
    /**
     * @param {function(T, T, Set<T>): void} callbackFn function called for each entry
     * @param {any} thisArg this argument for the callbackFn
     * @returns {void}
     */
    forEach(callbackFn: (arg0: T, arg1: T, arg2: Set<T>) => void, thisArg: any): void;
    /**
     * @param {T} item an item
     * @returns {boolean} true, when the item is in the Set
     */
    has(item: T): boolean;
    keys(): IterableIterator<T>;
    values(): IterableIterator<T>;
    /**
     * @param {import("../serialization/ObjectMiddleware").ObjectSerializerContext} context context
     */
    serialize({ write }: import("../serialization/ObjectMiddleware").ObjectSerializerContext): void;
    [Symbol.iterator](): IterableIterator<T>;
    get [Symbol.toStringTag](): string;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/MapHelpers.d.ts
export function getOrInsert<K, V>(map: Map<K, V>, key: K, computer: () => V): V;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/ParallelismFactorCalculator.d.ts
export = ParallelismFactorCalculator;
/** @typedef {function(number): void} Callback */
declare class ParallelismFactorCalculator {
    /** @type {number[]} */
    _rangePoints: number[];
    /** @type {Callback[]} */
    _rangeCallbacks: Callback[];
    /**
     * @param {number} start range start
     * @param {number} end range end
     * @param {Callback} callback callback
     * @returns {void}
     */
    range(start: number, end: number, callback: Callback): void;
    calculate(): void;
}
declare namespace ParallelismFactorCalculator {
    export { Callback };
}
type Callback = (arg0: number) => void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/Queue.d.ts
export = Queue;
/**
 * @template T
 */
declare class Queue<T> {
    /**
     * @param {Iterable<T>=} items The initial elements.
     */
    constructor(items?: Iterable<T> | undefined);
    /** @private @type {Set<T>} */
    private _set;
    /** @private @type {Iterator<T>} */
    private _iterator;
    /**
     * Returns the number of elements in this queue.
     * @returns {number} The number of elements in this queue.
     */
    get length(): number;
    /**
     * Appends the specified element to this queue.
     * @param {T} item The element to add.
     * @returns {void}
     */
    enqueue(item: T): void;
    /**
     * Retrieves and removes the head of this queue.
     * @returns {T | undefined} The head of the queue of `undefined` if this queue is empty.
     */
    dequeue(): T | undefined;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/Semaphore.d.ts
export = Semaphore;
declare class Semaphore {
    /**
     * Creates an instance of Semaphore.
     *
     * @param {number} available the amount available number of "tasks"
     * in the Semaphore
     */
    constructor(available: number);
    available: number;
    /** @type {(function(): void)[]} */
    waiters: (() => void)[];
    _continue(): void;
    /**
     * @param {function(): void} callback function block to capture and run
     * @returns {void}
     */
    acquire(callback: () => void): void;
    release(): void;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/SetHelpers.d.ts
/**
 * intersect creates Set containing the intersection of elements between all sets
 * @template T
 * @param {Set<T>[]} sets an array of sets being checked for shared elements
 * @returns {Set<T>} returns a new Set containing the intersecting items
 */
export function intersect<T>(sets: Set<T>[]): Set<T>;
/**
 * Checks if a set is the subset of another set
 * @template T
 * @param {Set<T>} bigSet a Set which contains the original elements to compare against
 * @param {Set<T>} smallSet the set whose elements might be contained inside of bigSet
 * @returns {boolean} returns true if smallSet contains all elements inside of the bigSet
 */
export function isSubset<T>(bigSet: Set<T>, smallSet: Set<T>): boolean;
/**
 * @template T
 * @param {Set<T>} set a set
 * @param {function(T): boolean} fn selector function
 * @returns {T | undefined} found item
 */
export function find<T>(set: Set<T>, fn: (arg0: T) => boolean): T;
/**
 * @template T
 * @param {Set<T>} set a set
 * @returns {T | undefined} first item
 */
export function first<T>(set: Set<T>): T;
/**
 * @template T
 * @param {Set<T>} a first
 * @param {Set<T>} b second
 * @returns {Set<T>} combined set, may be identical to a or b
 */
export function combine<T>(a: Set<T>, b: Set<T>): Set<T>;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/SortableSet.d.ts
export = SortableSet;
/**
 * A subset of Set that offers sorting functionality
 * @template T item type in set
 * @extends {Set<T>}
 */
declare class SortableSet<T> extends Set<T> {
    /**
     * Create a new sortable set
     * @param {Iterable<T>=} initialIterable The initial iterable value
     * @typedef {function(T, T): number} SortFunction
     * @param {SortFunction=} defaultSort Default sorting function
     */
    constructor(initialIterable?: Iterable<T> | undefined, defaultSort?: (arg0: T, arg1: T) => number);
    /** @private @type {undefined | function(T, T): number}} */
    private _sortFn;
    /** @private @type {typeof NONE | undefined | function(T, T): number}} */
    private _lastActiveSortFn;
    /** @private @type {Map<Function, any> | undefined} */
    private _cache;
    /** @private @type {Map<Function, any> | undefined} */
    private _cacheOrderIndependent;
    /**
     * @param {T} value value to add to set
     * @returns {this} returns itself
     */
    add(value: T): this;
    /**
     * Sort with a comparer function
     * @param {SortFunction} sortFn Sorting comparer function
     * @returns {void}
     */
    sortWith(sortFn: (arg0: T, arg1: T) => number): void;
    sort(): this;
    /**
     * Get data from cache
     * @template R
     * @param {function(SortableSet<T>): R} fn function to calculate value
     * @returns {R} returns result of fn(this), cached until set changes
     */
    getFromCache<R>(fn: (arg0: SortableSet<T>) => R): R;
    /**
     * Get data from cache (ignoring sorting)
     * @template R
     * @param {function(SortableSet<T>): R} fn function to calculate value
     * @returns {R} returns result of fn(this), cached until set changes
     */
    getFromUnorderedCache<R_1>(fn: (arg0: SortableSet<T>) => R_1): R_1;
    /**
     * @private
     * @returns {void}
     */
    private _invalidateCache;
    /**
     * @private
     * @returns {void}
     */
    private _invalidateOrderedCache;
    /**
     * @returns {T[]} the raw array
     */
    toJSON(): T[];
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/StackedCacheMap.d.ts
export = StackedCacheMap;
/**
 * @template K
 * @template V
 */
declare class StackedCacheMap<K, V> {
    /** @type {Map<K, V>} */
    map: Map<K, V>;
    /** @type {ReadonlyMap<K, V>[]} */
    stack: ReadonlyMap<K, V>[];
    /**
     * @param {ReadonlyMap<K, V>} map map to add
     * @param {boolean=} immutable if 'map' is immutable and StackedCacheMap can keep referencing it
     */
    addAll(map: ReadonlyMap<K, V>, immutable?: boolean | undefined): void;
    /**
     * @param {K} item the key of the element to add
     * @param {V} value the value of the element to add
     * @returns {void}
     */
    set(item: K, value: V): void;
    /**
     * @param {K} item the item to delete
     * @returns {void}
     */
    delete(item: K): void;
    /**
     * @param {K} item the item to test
     * @returns {boolean} true if the item exists in this set
     */
    has(item: K): boolean;
    /**
     * @param {K} item the key of the element to return
     * @returns {V} the value of the element
     */
    get(item: K): V;
    clear(): void;
    /**
     * @returns {number} size of the map
     */
    get size(): number;
    /**
     * @returns {Iterator<[K, V]>} iterator
     */
    [Symbol.iterator](): Iterator<[K, V]>;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/StackedMap.d.ts
export = StackedMap;
/**
 * @template K
 * @template V
 */
declare class StackedMap<K, V> {
    /**
     * @param {Map<K, InternalCell<V>>[]=} parentStack an optional parent
     */
    constructor(parentStack?: Map<K, InternalCell<V>>[] | undefined);
    /** @type {Map<K, InternalCell<V>>} */
    map: Map<K, InternalCell<V>>;
    /** @type {Map<K, InternalCell<V>>[]} */
    stack: Map<K, InternalCell<V>>[];
    /**
     * @param {K} item the key of the element to add
     * @param {V} value the value of the element to add
     * @returns {void}
     */
    set(item: K, value: V): void;
    /**
     * @param {K} item the item to delete
     * @returns {void}
     */
    delete(item: K): void;
    /**
     * @param {K} item the item to test
     * @returns {boolean} true if the item exists in this set
     */
    has(item: K): boolean;
    /**
     * @param {K} item the key of the element to return
     * @returns {Cell<V>} the value of the element
     */
    get(item: K): Cell<V>;
    _compress(): void;
    asArray(): K[];
    asSet(): Set<K>;
    asPairArray(): [K, V][];
    asMap(): Map<K, V>;
    get size(): number;
    createChild(): StackedMap<K, V>;
}
declare namespace StackedMap {
    export { Cell, InternalCell };
}
/**
 * <T>
 */
type InternalCell<T> = T | typeof TOMBSTONE | typeof UNDEFINED_MARKER;
/**
 * <T>
 */
type Cell<T> = T | undefined;
declare const TOMBSTONE: unique symbol;
declare const UNDEFINED_MARKER: unique symbol;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/StringXor.d.ts
export = StringXor;
/** @typedef {import("../util/Hash")} Hash */
/**
 * StringXor class provides methods for performing
 * [XOR operations](https://en.wikipedia.org/wiki/Exclusive_or) on strings. In this context
 * we operating on the character codes of two strings, which are represented as
 * [Buffer](https://nodejs.org/api/buffer.html) objects.
 *
 * We use [StringXor in webpack](https://github.com/webpack/webpack/commit/41a8e2ea483a544c4ccd3e6217bdfb80daffca39)
 * to create a hash of the current state of the compilation. By XOR'ing the Module hashes, it
 * doesn't matter if the Module hashes are sorted or not. This is useful because it allows us to avoid sorting the
 * Module hashes.
 *
 * @example
 * ```js
 * const xor = new StringXor();
 * xor.add('hello');
 * xor.add('world');
 * console.log(xor.toString());
 * ```
 *
 * @example
 * ```js
 * const xor = new StringXor();
 * xor.add('foo');
 * xor.add('bar');
 * const hash = createHash('sha256');
 * hash.update(xor.toString());
 * console.log(hash.digest('hex'));
 * ```
 */
declare class StringXor {
    /** @type {Buffer|undefined} */
    _value: Buffer | undefined;
    /**
     * Adds a string to the current StringXor object.
     *
     * @param {string} str string
     * @returns {void}
     */
    add(str: string): void;
    /**
     * Returns a string that represents the current state of the StringXor object. We chose to use "latin1" encoding
     * here because "latin1" encoding is a single-byte encoding that can represent all characters in the
     * [ISO-8859-1 character set](https://en.wikipedia.org/wiki/ISO/IEC_8859-1). This is useful when working
     * with binary data that needs to be represented as a string.
     *
     * @returns {string} Returns a string that represents the current state of the StringXor object.
     */
    toString(): string;
    /**
     * Updates the hash with the current state of the StringXor object.
     *
     * @param {Hash} hash Hash instance
     */
    updateHash(hash: Hash): void;
}
declare namespace StringXor {
    export { Hash };
}
type Hash = import("../util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/TupleQueue.d.ts
export = TupleQueue;
/**
 * @template {any[]} T
 */
declare class TupleQueue<T extends any[]> {
    /**
     * @param {Iterable<T>=} items The initial elements.
     */
    constructor(items?: Iterable<T> | undefined);
    /** @private @type {TupleSet<T>} */
    private _set;
    /** @private @type {Iterator<T>} */
    private _iterator;
    /**
     * Returns the number of elements in this queue.
     * @returns {number} The number of elements in this queue.
     */
    get length(): number;
    /**
     * Appends the specified element to this queue.
     * @param {T} item The element to add.
     * @returns {void}
     */
    enqueue(...item: T): void;
    /**
     * Retrieves and removes the head of this queue.
     * @returns {T | undefined} The head of the queue of `undefined` if this queue is empty.
     */
    dequeue(): T | undefined;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/TupleSet.d.ts
export = TupleSet;
/**
 * @template {any[]} T
 */
declare class TupleSet<T extends any[]> {
    constructor(init: any);
    _map: Map<any, any>;
    size: number;
    /**
     * @param  {T} args tuple
     * @returns {void}
     */
    add(...args: T): void;
    /**
     * @param  {T} args tuple
     * @returns {boolean} true, if the tuple is in the Set
     */
    has(...args: T): boolean;
    /**
     * @param {T} args tuple
     * @returns {void}
     */
    delete(...args: T): void;
    /**
     * @returns {Iterator<T>} iterator
     */
    [Symbol.iterator](): Iterator<T>;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/URLAbsoluteSpecifier.d.ts
export type InputFileSystem = import("./fs").InputFileSystem;
export type ErrorFirstCallback = (error: Error | null, result?: Buffer) => void;
/**
 * Get scheme if specifier is an absolute URL specifier
 * e.g. Absolute specifiers like 'file:///user/webpack/index.js'
 * https://tools.ietf.org/html/rfc3986#section-3.1
 * @param {string} specifier specifier
 * @returns {string|undefined} scheme if absolute URL specifier provided
 */
export function getScheme(specifier: string): string | undefined;
/**
 * @param {string} specifier specifier
 * @returns {string | null | undefined} protocol if absolute URL specifier provided
 */
export function getProtocol(specifier: string): string | null | undefined;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/WeakTupleMap.d.ts
export = WeakTupleMap;
/**
 * @template {any[]} T
 * @template V
 */
declare class WeakTupleMap<T extends any[], V> {
    /** @private */
    private f;
    /** @private @type {any} */
    private v;
    /** @private @type {Map<object, WeakTupleMap<T, V>> | undefined} */
    private m;
    /** @private @type {WeakMap<object, WeakTupleMap<T, V>> | undefined} */
    private w;
    /**
     * @param {[...T, V]} args tuple
     * @returns {void}
     */
    set(...args: [...T, V]): void;
    /**
     * @param {T} args tuple
     * @returns {boolean} true, if the tuple is in the Set
     */
    has(...args: T): boolean;
    /**
     * @param {T} args tuple
     * @returns {V} the value
     */
    get(...args: T): V;
    /**
     * @param {[...T, function(): V]} args tuple
     * @returns {V} the value
     */
    provide(...args: [...T, () => V]): V;
    /**
     * @param {T} args tuple
     * @returns {void}
     */
    delete(...args: T): void;
    /**
     * @returns {void}
     */
    clear(): void;
    _getValue(): any;
    _hasValue(): boolean;
    _setValue(v: any): void;
    _deleteValue(): void;
    _peek(thing: any): WeakTupleMap<T, V>;
    _get(thing: any): WeakTupleMap<T, V>;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/binarySearchBounds.d.ts
export type BinarySearchPredicate = ">=" | "<=" | "<" | ">" | "-";
export type SearchPredicateSuffix = "GE" | "GT" | "LT" | "LE" | "EQ";
declare let ge: Function;
declare let gt: Function;
declare let lt: Function;
declare let le: Function;
declare let eq: Function;
export {};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/cleverMerge.d.ts
export type ObjectParsedPropertyEntry = {
    /**
     * base value
     */
    base: any | undefined;
    /**
     * the name of the selector property
     */
    byProperty: string | undefined;
    /**
     * value depending on selector property, merged with base
     */
    byValues: Map<string, any>;
};
export type ParsedObject = {
    /**
     * static properties (key is property name)
     */
    static: Map<string, ObjectParsedPropertyEntry>;
    /**
     * dynamic part
     */
    dynamic: {
        byProperty: string;
        fn: Function;
    } | undefined;
};
/**
 * @template T
 * @param {Partial<T>} obj object
 * @param {string} property property
 * @param {string|number|boolean} value assignment value
 * @returns {T} new object
 */
export function cachedSetProperty<T>(obj: Partial<T>, property: string, value: string | number | boolean): T;
/**
 * Merges two given objects and caches the result to avoid computation if same objects passed as arguments again.
 * @template T
 * @template O
 * @example
 * // performs cleverMerge(first, second), stores the result in WeakMap and returns result
 * cachedCleverMerge({a: 1}, {a: 2})
 * {a: 2}
 *  // when same arguments passed, gets the result from WeakMap and returns it.
 * cachedCleverMerge({a: 1}, {a: 2})
 * {a: 2}
 * @param {T} first first object
 * @param {O} second second object
 * @returns {T & O | T | O} merged object of first and second object
 */
export function cachedCleverMerge<T, O>(first: T, second: O): T | O | (T & O);
/**
 * Merges two objects. Objects are deeply clever merged.
 * Arrays might reference the old value with "...".
 * Non-object values take preference over object values.
 * @template T
 * @template O
 * @param {T} first first object
 * @param {O} second second object
 * @returns {T & O | T | O} merged object of first and second object
 */
export function cleverMerge<T, O>(first: T, second: O): T | O | (T & O);
/**
 * @template T
 * @template {string} P
 * @param {T} obj the object
 * @param {P} byProperty the by description
 * @param  {...any} values values
 * @returns {Omit<T, P>} object with merged byProperty
 */
export function resolveByProperty<T, P extends string>(obj: T, byProperty: P, ...values: any[]): Omit<T, P>;
/**
 * @template T
 * @param {T} obj the object
 * @returns {T} the object without operations like "..." or DELETE
 */
export function removeOperations<T>(obj: T): T;
export const DELETE: unique symbol;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/comparators.d.ts
export function compareChunksById(a: Chunk, b: Chunk): -1 | 0 | 1;
export function compareModulesByIdentifier(a: Module, b: Module): -1 | 0 | 1;
export const compareModulesById: ParameterizedComparator<ChunkGraph, Module>;
export const compareModulesByPostOrderIndexOrIdentifier: ParameterizedComparator<ModuleGraph, Module>;
export const compareModulesByPreOrderIndexOrIdentifier: ParameterizedComparator<ModuleGraph, Module>;
export const compareModulesByIdOrIdentifier: ParameterizedComparator<ChunkGraph, Module>;
export const compareChunks: ParameterizedComparator<ChunkGraph, Chunk>;
export function keepOriginalOrder<T>(iterable: Iterable<T>): Comparator<T>;
export function compareChunksNatural(chunkGraph: ChunkGraph): Comparator<Chunk>;
export function compareLocations(a: DependencyLocation, b: DependencyLocation): -1 | 0 | 1;
export type Chunk = import("../Chunk");
export type ChunkGraph = import("../ChunkGraph");
export type ChunkGroup = import("../ChunkGroup");
export type DependencyLocation = import("../Dependency").DependencyLocation;
export type Module = import("../Module");
export type ModuleGraph = import("../ModuleGraph");
export type Comparator<T> = (arg0: T, arg1: T) => -1 | 0 | 1;
export type RawParameterizedComparator<TArg, T> = (arg0: TArg, arg1: T, arg2: T) => -1 | 0 | 1;
export type ParameterizedComparator<TArg, T> = (arg0: TArg) => Comparator<T>;
export type Selector<A, B> = (input: A) => B;
/**
 * @param {number} a number
 * @param {number} b number
 * @returns {-1|0|1} compare result
 */
export function compareNumbers(a: number, b: number): -1 | 0 | 1;
/**
 * @param {string} a string
 * @param {string} b string
 * @returns {-1|0|1} compare result
 */
export function compareStringsNumeric(a: string, b: string): -1 | 0 | 1;
/**
 * @param {string|number} a first id
 * @param {string|number} b second id
 * @returns {-1|0|1} compare result
 */
export function compareIds(a: string | number, b: string | number): -1 | 0 | 1;
/**
 * @param {string} a first string
 * @param {string} b second string
 * @returns {-1|0|1} compare result
 */
export function compareStrings(a: string, b: string): -1 | 0 | 1;
/**
 * @param {ChunkGroup} a first chunk group
 * @param {ChunkGroup} b second chunk group
 * @returns {-1|0|1} compare result
 */
export function compareChunkGroupsByIndex(a: ChunkGroup, b: ChunkGroup): -1 | 0 | 1;
/**
 * @template T
 * @param {Comparator<T>} c1 comparator
 * @param {Comparator<T>} c2 comparator
 * @param {Comparator<T>[]} cRest comparators
 * @returns {Comparator<T>} comparator
 */
export function concatComparators<T>(c1: Comparator<T>, c2: Comparator<T>, ...cRest: Comparator<T>[]): Comparator<T>;
/**
 * @template T
 * @template R
 * @param {Selector<T, R>} getter getter for value
 * @param {Comparator<R>} comparator comparator
 * @returns {Comparator<T>} comparator
 */
export function compareSelect<T, R>(getter: Selector<T, R>, comparator: Comparator<R>): Comparator<T>;
/**
 * @template T
 * @param {Comparator<T>} elementComparator comparator for elements
 * @returns {Comparator<Iterable<T>>} comparator for iterables of elements
 */
export function compareIterables<T>(elementComparator: Comparator<T>): Comparator<Iterable<T>>;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/compileBooleanMatcher.d.ts
export = compileBooleanMatcher;
/**
 * @param {Record<string|number, boolean>} map value map
 * @returns {boolean|(function(string): string)} true/false, when unconditionally true/false, or a template function to determine the value at runtime
 */
declare function compileBooleanMatcher(map: Record<string | number, boolean>): boolean | ((arg0: string) => string);
declare namespace compileBooleanMatcher {
    export { compileBooleanMatcherFromLists as fromLists };
    export { itemsToRegexp };
}
/**
 * @param {string[]} positiveItems positive items
 * @param {string[]} negativeItems negative items
 * @returns {function(string): string} a template function to determine the value at runtime
 */
declare function compileBooleanMatcherFromLists(positiveItems: string[], negativeItems: string[]): (arg0: string) => string;
/**
 * @param {Array<string>} itemsArr array of items
 * @returns {string} regexp
 */
declare function itemsToRegexp(itemsArr: Array<string>): string;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/create-schema-validation.d.ts
export = createSchemaValidation;
declare function createSchemaValidation(check: any, getSchema: any, options: any): (value: any) => void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/createHash.d.ts
declare function _exports(algorithm: string | typeof Hash | undefined): Hash;
export = _exports;
export type HashFactory = () => Hash;
import Hash = require("webpack/lib/util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/deprecation.d.ts
export function arrayToSetDeprecation(set: any, name: string): void;
export function createArrayToSetDeprecationSet(name: any): {
    new (items: any): {
        add(value: any): any;
        clear(): void;
        delete(value: any): boolean;
        forEach(callbackfn: (value: any, value2: any, set: Set<any>) => void, thisArg?: any): void;
        has(value: any): boolean;
        readonly size: number;
        entries(): IterableIterator<[any, any]>;
        keys(): IterableIterator<any>;
        values(): IterableIterator<any>;
        [Symbol.iterator](): IterableIterator<any>;
        readonly [Symbol.toStringTag]: string;
    };
    readonly [Symbol.species]: SetConstructor;
};
export function soonFrozenObjectDeprecation<T>(obj: any, name: string, code: string, note?: string): any;
export function createFakeHook<T>(fakeHook: T, message?: string | undefined, code?: string | undefined): FakeHook<T>;
export type FakeHookMarker = {
    /**
     * it's a fake hook
     */
    _fakeHook: true;
};
/**
 * <T>
 */
export type FakeHook<T> = T & FakeHookMarker;
/**
 * @template T
 * @param {T} obj object
 * @param {string} message deprecation message
 * @param {string} code deprecation code
 * @returns {T} object with property access deprecated
 */
export function deprecateAllProperties<T>(obj: T, message: string, code: string): T;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/deterministicGrouping.d.ts
declare function _exports<T>({ maxSize, minSize, items, getSize, getKey }: Options<T>): GroupedItems<T>[];
export = _exports;
/**
 * <T>
 */
export type GroupedItems<T> = {
    key: string;
    items: T[];
    size: Record<string, number>;
};
export type Options<T> = {
    /**
     * maximum size of a group
     */
    maxSize: Record<string, number>;
    /**
     * minimum size of a group (preferred over maximum size)
     */
    minSize: Record<string, number>;
    /**
     * a list of items
     */
    items: Iterable<T>;
    /**
     * function to get size of an item
     */
    getSize: (arg0: T) => Record<string, number>;
    /**
     * function to get the key of an item
     */
    getKey: (arg0: T) => string;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/extractUrlAndGlobal.d.ts
declare function _exports(urlAndGlobal: string): string[];
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/findGraphRoots.d.ts
declare function _exports<T>(items: Iterable<T>, getDependencies: (arg0: T) => Iterable<T>): Iterable<T>;
export = _exports;
export type StackEntry<T> = {
    node: Node<T>;
    openEdges: Node<T>[];
};
/**
 * @template T
 */
declare class Node<T> {
    /**
     * @param {T} item the value of the node
     */
    constructor(item: T);
    item: T;
    /** @type {Set<Node<T>>} */
    dependencies: Set<Node<T>>;
    marker: number;
    /** @type {Cycle<T> | undefined} */
    cycle: Cycle<T> | undefined;
    incoming: number;
}
/**
 * @template T
 */
declare class Cycle<T> {
    /** @type {Set<Node<T>>} */
    nodes: Set<Node<T>>;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/fs.d.ts
export type WatchOptions = any;
export type FileSystemInfoEntry = import("../FileSystemInfo").FileSystemInfoEntry;
export type IStats = {
    isFile: () => boolean;
    isDirectory: () => boolean;
    isBlockDevice: () => boolean;
    isCharacterDevice: () => boolean;
    isSymbolicLink: () => boolean;
    isFIFO: () => boolean;
    isSocket: () => boolean;
    dev: number | bigint;
    ino: number | bigint;
    mode: number | bigint;
    nlink: number | bigint;
    uid: number | bigint;
    gid: number | bigint;
    rdev: number | bigint;
    size: number | bigint;
    blksize: number | bigint;
    blocks: number | bigint;
    atimeMs: number | bigint;
    mtimeMs: number | bigint;
    ctimeMs: number | bigint;
    birthtimeMs: number | bigint;
    atime: Date;
    mtime: Date;
    ctime: Date;
    birthtime: Date;
};
export type IDirent = {
    isFile: () => boolean;
    isDirectory: () => boolean;
    isBlockDevice: () => boolean;
    isCharacterDevice: () => boolean;
    isSymbolicLink: () => boolean;
    isFIFO: () => boolean;
    isSocket: () => boolean;
    name: string | Buffer;
};
export type Callback = (arg0: (NodeJS.ErrnoException | null) | undefined) => void;
export type BufferCallback = (arg0: (NodeJS.ErrnoException | null) | undefined, arg1: Buffer | undefined) => void;
export type BufferOrStringCallback = (arg0: (NodeJS.ErrnoException | null) | undefined, arg1: (Buffer | string) | undefined) => void;
export type DirentArrayCallback = (arg0: (NodeJS.ErrnoException | null) | undefined, arg1: ((string | Buffer)[] | IDirent[]) | undefined) => void;
export type StringCallback = (arg0: (NodeJS.ErrnoException | null) | undefined, arg1: string | undefined) => void;
export type NumberCallback = (arg0: (NodeJS.ErrnoException | null) | undefined, arg1: number | undefined) => void;
export type StatsCallback = (arg0: (NodeJS.ErrnoException | null) | undefined, arg1: IStats | undefined) => void;
export type ReadJsonCallback = (arg0: (NodeJS.ErrnoException | Error | null) | undefined, arg1: any | undefined) => void;
export type LstatReadlinkAbsoluteCallback = (arg0: (NodeJS.ErrnoException | Error | null) | undefined, arg1: (IStats | string) | undefined) => void;
export type WatcherInfo = {
    /**
     * get current aggregated changes that have not yet send to callback
     */
    changes: Set<string>;
    /**
     * get current aggregated removals that have not yet send to callback
     */
    removals: Set<string>;
    /**
     * get info about files
     */
    fileTimeInfoEntries: Map<string, FileSystemInfoEntry | "ignore">;
    /**
     * get info about directories
     */
    contextTimeInfoEntries: Map<string, FileSystemInfoEntry | "ignore">;
};
export type Watcher = {
    /**
     * closes the watcher and all underlying file watchers
     */
    close: () => void;
    /**
     * closes the watcher, but keeps underlying file watchers alive until the next watch call
     */
    pause: () => void;
    /**
     * get current aggregated changes that have not yet send to callback
     */
    getAggregatedChanges?: (() => Set<string>) | undefined;
    /**
     * get current aggregated removals that have not yet send to callback
     */
    getAggregatedRemovals?: (() => Set<string>) | undefined;
    /**
     * get info about files
     */
    getFileTimeInfoEntries: () => Map<string, FileSystemInfoEntry | "ignore">;
    /**
     * get info about directories
     */
    getContextTimeInfoEntries: () => Map<string, FileSystemInfoEntry | "ignore">;
    /**
     * get info about timestamps and changes
     */
    getInfo?: (() => WatcherInfo) | undefined;
};
export type WatchMethod = (files: Iterable<string>, directories: Iterable<string>, missing: Iterable<string>, startTime: number, options: any, callback: (arg0: Error | undefined, arg1: Map<string, FileSystemInfoEntry | "ignore">, arg2: Map<string, FileSystemInfoEntry | "ignore">, arg3: Set<string>, arg4: Set<string>) => void, callbackUndelayed: (arg0: string, arg1: number) => void) => Watcher;
export type OutputFileSystem = {
    writeFile: (arg0: string, arg1: Buffer | string, arg2: Callback) => void;
    mkdir: (arg0: string, arg1: Callback) => void;
    readdir?: ((arg0: string, arg1: DirentArrayCallback) => void) | undefined;
    rmdir?: ((arg0: string, arg1: Callback) => void) | undefined;
    unlink?: ((arg0: string, arg1: Callback) => void) | undefined;
    stat: (arg0: string, arg1: StatsCallback) => void;
    lstat?: ((arg0: string, arg1: StatsCallback) => void) | undefined;
    readFile: (arg0: string, arg1: BufferOrStringCallback) => void;
    join?: ((arg0: string, arg1: string) => string) | undefined;
    relative?: ((arg0: string, arg1: string) => string) | undefined;
    dirname?: ((arg0: string) => string) | undefined;
};
export type InputFileSystem = {
    readFile: (arg0: string, arg1: BufferOrStringCallback) => void;
    readJson?: ((arg0: string, arg1: ReadJsonCallback) => void) | undefined;
    readlink: (arg0: string, arg1: BufferOrStringCallback) => void;
    readdir: (arg0: string, arg1: DirentArrayCallback) => void;
    stat: (arg0: string, arg1: StatsCallback) => void;
    lstat?: ((arg0: string, arg1: StatsCallback) => void) | undefined;
    realpath?: ((arg0: string, arg1: BufferOrStringCallback) => void) | undefined;
    purge?: ((arg0: string | undefined) => void) | undefined;
    join?: ((arg0: string, arg1: string) => string) | undefined;
    relative?: ((arg0: string, arg1: string) => string) | undefined;
    dirname?: ((arg0: string) => string) | undefined;
};
export type WatchFileSystem = {
    watch: WatchMethod;
};
export type IntermediateFileSystemExtras = {
    mkdirSync: (arg0: string) => void;
    createWriteStream: (arg0: string) => NodeJS.WritableStream;
    open: (arg0: string, arg1: string, arg2: NumberCallback) => void;
    read: (arg0: number, arg1: Buffer, arg2: number, arg3: number, arg4: number, arg5: NumberCallback) => void;
    close: (arg0: number, arg1: Callback) => void;
    rename: (arg0: string, arg1: string, arg2: Callback) => void;
};
export type IntermediateFileSystem = InputFileSystem & OutputFileSystem & IntermediateFileSystemExtras;
/** @typedef {import("../../declarations/WebpackOptions").WatchOptions} WatchOptions */
/** @typedef {import("../FileSystemInfo").FileSystemInfoEntry} FileSystemInfoEntry */
/**
 * @typedef {Object} IStats
 * @property {() => boolean} isFile
 * @property {() => boolean} isDirectory
 * @property {() => boolean} isBlockDevice
 * @property {() => boolean} isCharacterDevice
 * @property {() => boolean} isSymbolicLink
 * @property {() => boolean} isFIFO
 * @property {() => boolean} isSocket
 * @property {number | bigint} dev
 * @property {number | bigint} ino
 * @property {number | bigint} mode
 * @property {number | bigint} nlink
 * @property {number | bigint} uid
 * @property {number | bigint} gid
 * @property {number | bigint} rdev
 * @property {number | bigint} size
 * @property {number | bigint} blksize
 * @property {number | bigint} blocks
 * @property {number | bigint} atimeMs
 * @property {number | bigint} mtimeMs
 * @property {number | bigint} ctimeMs
 * @property {number | bigint} birthtimeMs
 * @property {Date} atime
 * @property {Date} mtime
 * @property {Date} ctime
 * @property {Date} birthtime
 */
/**
 * @typedef {Object} IDirent
 * @property {() => boolean} isFile
 * @property {() => boolean} isDirectory
 * @property {() => boolean} isBlockDevice
 * @property {() => boolean} isCharacterDevice
 * @property {() => boolean} isSymbolicLink
 * @property {() => boolean} isFIFO
 * @property {() => boolean} isSocket
 * @property {string | Buffer} name
 */
/** @typedef {function((NodeJS.ErrnoException | null)=): void} Callback */
/** @typedef {function((NodeJS.ErrnoException | null)=, Buffer=): void} BufferCallback */
/** @typedef {function((NodeJS.ErrnoException | null)=, Buffer|string=): void} BufferOrStringCallback */
/** @typedef {function((NodeJS.ErrnoException | null)=, (string | Buffer)[] | IDirent[]=): void} DirentArrayCallback */
/** @typedef {function((NodeJS.ErrnoException | null)=, string=): void} StringCallback */
/** @typedef {function((NodeJS.ErrnoException | null)=, number=): void} NumberCallback */
/** @typedef {function((NodeJS.ErrnoException | null)=, IStats=): void} StatsCallback */
/** @typedef {function((NodeJS.ErrnoException | Error | null)=, any=): void} ReadJsonCallback */
/** @typedef {function((NodeJS.ErrnoException | Error | null)=, IStats|string=): void} LstatReadlinkAbsoluteCallback */
/**
 * @typedef {Object} WatcherInfo
 * @property {Set<string>} changes get current aggregated changes that have not yet send to callback
 * @property {Set<string>} removals get current aggregated removals that have not yet send to callback
 * @property {Map<string, FileSystemInfoEntry | "ignore">} fileTimeInfoEntries get info about files
 * @property {Map<string, FileSystemInfoEntry | "ignore">} contextTimeInfoEntries get info about directories
 */
/**
 * @typedef {Object} Watcher
 * @property {function(): void} close closes the watcher and all underlying file watchers
 * @property {function(): void} pause closes the watcher, but keeps underlying file watchers alive until the next watch call
 * @property {function(): Set<string>=} getAggregatedChanges get current aggregated changes that have not yet send to callback
 * @property {function(): Set<string>=} getAggregatedRemovals get current aggregated removals that have not yet send to callback
 * @property {function(): Map<string, FileSystemInfoEntry | "ignore">} getFileTimeInfoEntries get info about files
 * @property {function(): Map<string, FileSystemInfoEntry | "ignore">} getContextTimeInfoEntries get info about directories
 * @property {function(): WatcherInfo=} getInfo get info about timestamps and changes
 */
/**
 * @callback WatchMethod
 * @param {Iterable<string>} files watched files
 * @param {Iterable<string>} directories watched directories
 * @param {Iterable<string>} missing watched exitance entries
 * @param {number} startTime timestamp of start time
 * @param {WatchOptions} options options object
 * @param {function(Error=, Map<string, FileSystemInfoEntry | "ignore">, Map<string, FileSystemInfoEntry | "ignore">, Set<string>, Set<string>): void} callback aggregated callback
 * @param {function(string, number): void} callbackUndelayed callback when the first change was detected
 * @returns {Watcher} a watcher
 */
/**
 * @typedef {Object} OutputFileSystem
 * @property {function(string, Buffer|string, Callback): void} writeFile
 * @property {function(string, Callback): void} mkdir
 * @property {function(string, DirentArrayCallback): void=} readdir
 * @property {function(string, Callback): void=} rmdir
 * @property {function(string, Callback): void=} unlink
 * @property {function(string, StatsCallback): void} stat
 * @property {function(string, StatsCallback): void=} lstat
 * @property {function(string, BufferOrStringCallback): void} readFile
 * @property {(function(string, string): string)=} join
 * @property {(function(string, string): string)=} relative
 * @property {(function(string): string)=} dirname
 */
/**
 * @typedef {Object} InputFileSystem
 * @property {function(string, BufferOrStringCallback): void} readFile
 * @property {(function(string, ReadJsonCallback): void)=} readJson
 * @property {function(string, BufferOrStringCallback): void} readlink
 * @property {function(string, DirentArrayCallback): void} readdir
 * @property {function(string, StatsCallback): void} stat
 * @property {function(string, StatsCallback): void=} lstat
 * @property {(function(string, BufferOrStringCallback): void)=} realpath
 * @property {(function(string=): void)=} purge
 * @property {(function(string, string): string)=} join
 * @property {(function(string, string): string)=} relative
 * @property {(function(string): string)=} dirname
 */
/**
 * @typedef {Object} WatchFileSystem
 * @property {WatchMethod} watch
 */
/**
 * @typedef {Object} IntermediateFileSystemExtras
 * @property {function(string): void} mkdirSync
 * @property {function(string): NodeJS.WritableStream} createWriteStream
 * @property {function(string, string, NumberCallback): void} open
 * @property {function(number, Buffer, number, number, number, NumberCallback): void} read
 * @property {function(number, Callback): void} close
 * @property {function(string, string, Callback): void} rename
 */
/** @typedef {InputFileSystem & OutputFileSystem & IntermediateFileSystemExtras} IntermediateFileSystem */
/**
 *
 * @param {InputFileSystem|OutputFileSystem|undefined} fs a file system
 * @param {string} rootPath the root path
 * @param {string} targetPath the target path
 * @returns {string} location of targetPath relative to rootPath
 */
export function relative(fs: InputFileSystem | OutputFileSystem | undefined, rootPath: string, targetPath: string): string;
/**
 * @param {InputFileSystem|OutputFileSystem|undefined} fs a file system
 * @param {string} rootPath a path
 * @param {string} filename a filename
 * @returns {string} the joined path
 */
export function join(fs: InputFileSystem | OutputFileSystem | undefined, rootPath: string, filename: string): string;
/**
 * @param {InputFileSystem|OutputFileSystem|undefined} fs a file system
 * @param {string} absPath an absolute path
 * @returns {string} the parent directory of the absolute path
 */
export function dirname(fs: InputFileSystem | OutputFileSystem | undefined, absPath: string): string;
/**
 * @param {OutputFileSystem} fs a file system
 * @param {string} p an absolute path
 * @param {function(Error=): void} callback callback function for the error
 * @returns {void}
 */
export function mkdirp(fs: OutputFileSystem, p: string, callback: (arg0: Error | undefined) => void): void;
/**
 * @param {IntermediateFileSystem} fs a file system
 * @param {string} p an absolute path
 * @returns {void}
 */
export function mkdirpSync(fs: IntermediateFileSystem, p: string): void;
/**
 * @param {InputFileSystem} fs a file system
 * @param {string} p an absolute path
 * @param {ReadJsonCallback} callback callback
 * @returns {void}
 */
export function readJson(fs: InputFileSystem, p: string, callback: ReadJsonCallback): void;
/**
 * @param {InputFileSystem} fs a file system
 * @param {string} p an absolute path
 * @param {ReadJsonCallback} callback callback
 * @returns {void}
 */
export function lstatReadlinkAbsolute(fs: InputFileSystem, p: string, callback: ReadJsonCallback): void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/hash/BatchedHash.d.ts
export = BatchedHash;
declare class BatchedHash extends Hash {
    constructor(hash: any);
    string: string;
    encoding: string;
    hash: any;
    /**
     * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
     * @param {string|Buffer} data data
     * @param {string=} inputEncoding data encoding
     * @returns {this} updated hash
     */
    update(data: string | Buffer, inputEncoding?: string | undefined): this;
}
import Hash = require("webpack/lib/util/Hash");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/hash/md4.d.ts
declare const _exports: any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/hash/wasm-hash.d.ts
export = create;
declare function create(wasmModule: any, instancesPool: any, chunkSize: any, digestSize: any): any;
declare namespace create {
    export { MAX_SHORT_STRING };
}
declare const MAX_SHORT_STRING: number;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/hash/xxhash64.d.ts
declare const _exports: any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/identifier.d.ts
/**
 * @param {string} context context used to create relative path
 * @param {string} identifier identifier used to create relative path
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} the returned relative path
 */
export function makePathsRelative(context: string, identifier: string, associatedObjectForCache?: any | undefined): string;
export namespace makePathsRelative {
    /**
     * @param {Object=} associatedObjectForCache an object to which the cache will be attached
     * @returns {function(string, string): string} cached function
     */
    function bindCache(associatedObjectForCache?: any): (arg0: string, arg1: string) => string;
    /**
     * @param {string} context context used to create relative path
     * @param {Object=} associatedObjectForCache an object to which the cache will be attached
     * @returns {function(string): string} cached function
     */
    function bindContextCache(context: string, associatedObjectForCache?: any): (arg0: string) => string;
}
/**
 * @param {string} context context used to create relative path
 * @param {string} identifier identifier used to create relative path
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} the returned relative path
 */
export function makePathsAbsolute(context: string, identifier: string, associatedObjectForCache?: any | undefined): string;
export namespace makePathsAbsolute { }
/**
 * @param {string} str the path with query and fragment
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {ParsedResource} parsed parts
 */
export function parseResource(str: string, associatedObjectForCache?: any | undefined): ParsedResource;
export namespace parseResource {
    function bindCache(associatedObjectForCache: any): (str: any) => any;
}
/**
 * @param {string} str the path with query and fragment
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {ParsedResource} parsed parts
 */
export function parseResourceWithoutFragment(str: string, associatedObjectForCache?: any | undefined): ParsedResource;
export namespace parseResourceWithoutFragment { }
export function getUndoPath(filename: string, outputPath: string, enforceRelative: boolean): string;
export type MakeRelativePathsCache = {
    relativePaths?: Map<string, Map<string, string>> | undefined;
};
export type ParsedResource = {
    resource: string;
    path: string;
    query: string;
    fragment: string;
};
export type ParsedResourceWithoutFragment = {
    resource: string;
    path: string;
    query: string;
};
/**
 * @param {string} context context used to create relative path
 * @param {string} identifier identifier used to create relative path
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} the returned relative path
 */
export function contextify(context: string, identifier: string, associatedObjectForCache?: any | undefined): string;
export namespace contextify { }
/**
 * @param {string} context context used to create relative path
 * @param {string} identifier identifier used to create relative path
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} the returned relative path
 */
export function absolutify(context: string, identifier: string, associatedObjectForCache?: any | undefined): string;
export namespace absolutify { }
import path = require("path");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/internalSerializables.d.ts
declare const _exports: {
    AsyncDependenciesBlock: () => typeof import("webpack/lib/AsyncDependenciesBlock");
    CommentCompilationWarning: () => typeof import("webpack/lib/CommentCompilationWarning");
    ContextModule: () => typeof import("webpack/lib/ContextModule");
    "cache/PackFileCacheStrategy": () => typeof import("webpack/lib/cache/PackFileCacheStrategy");
    "cache/ResolverCachePlugin": () => typeof import("webpack/lib/cache/ResolverCachePlugin");
    "container/ContainerEntryDependency": () => typeof import("webpack/lib/container/ContainerEntryDependency");
    "container/ContainerEntryModule": () => typeof import("webpack/lib/container/ContainerEntryModule");
    "container/ContainerExposedDependency": () => typeof import("webpack/lib/container/ContainerExposedDependency");
    "container/FallbackDependency": () => typeof import("webpack/lib/container/FallbackDependency");
    "container/FallbackItemDependency": () => typeof import("webpack/lib/container/FallbackItemDependency");
    "container/FallbackModule": () => typeof import("webpack/lib/container/FallbackModule");
    "container/RemoteModule": () => typeof import("webpack/lib/container/RemoteModule");
    "container/RemoteToExternalDependency": () => typeof import("webpack/lib/container/RemoteToExternalDependency");
    "dependencies/AMDDefineDependency": () => typeof import("webpack/lib/dependencies/AMDDefineDependency");
    "dependencies/AMDRequireArrayDependency": () => typeof import("webpack/lib/dependencies/AMDRequireArrayDependency");
    "dependencies/AMDRequireContextDependency": () => typeof import("webpack/lib/dependencies/AMDRequireContextDependency");
    "dependencies/AMDRequireDependenciesBlock": () => typeof import("webpack/lib/dependencies/AMDRequireDependenciesBlock");
    "dependencies/AMDRequireDependency": () => typeof import("webpack/lib/dependencies/AMDRequireDependency");
    "dependencies/AMDRequireItemDependency": () => typeof import("webpack/lib/dependencies/AMDRequireItemDependency");
    "dependencies/CachedConstDependency": () => typeof import("webpack/lib/dependencies/CachedConstDependency");
    "dependencies/CreateScriptUrlDependency": () => typeof import("webpack/lib/dependencies/CreateScriptUrlDependency");
    "dependencies/CommonJsRequireContextDependency": () => typeof import("webpack/lib/dependencies/CommonJsRequireContextDependency");
    "dependencies/CommonJsExportRequireDependency": () => typeof import("webpack/lib/dependencies/CommonJsExportRequireDependency");
    "dependencies/CommonJsExportsDependency": () => typeof import("webpack/lib/dependencies/CommonJsExportsDependency");
    "dependencies/CommonJsFullRequireDependency": () => typeof import("webpack/lib/dependencies/CommonJsFullRequireDependency");
    "dependencies/CommonJsRequireDependency": () => typeof import("webpack/lib/dependencies/CommonJsRequireDependency");
    "dependencies/CommonJsSelfReferenceDependency": () => typeof import("webpack/lib/dependencies/CommonJsSelfReferenceDependency");
    "dependencies/ConstDependency": () => typeof import("webpack/lib/dependencies/ConstDependency");
    "dependencies/ContextDependency": () => typeof import("webpack/lib/dependencies/ContextDependency");
    "dependencies/ContextElementDependency": () => typeof import("webpack/lib/dependencies/ContextElementDependency");
    "dependencies/CriticalDependencyWarning": () => typeof import("webpack/lib/dependencies/CriticalDependencyWarning");
    "dependencies/CssImportDependency": () => typeof import("webpack/lib/dependencies/CssImportDependency");
    "dependencies/CssLocalIdentifierDependency": () => typeof import("webpack/lib/dependencies/CssLocalIdentifierDependency");
    "dependencies/CssSelfLocalIdentifierDependency": () => typeof import("webpack/lib/dependencies/CssSelfLocalIdentifierDependency");
    "dependencies/CssExportDependency": () => typeof import("webpack/lib/dependencies/CssExportDependency");
    "dependencies/CssUrlDependency": () => typeof import("webpack/lib/dependencies/CssUrlDependency");
    "dependencies/DelegatedSourceDependency": () => typeof import("webpack/lib/dependencies/DelegatedSourceDependency");
    "dependencies/DllEntryDependency": () => typeof import("webpack/lib/dependencies/DllEntryDependency");
    "dependencies/EntryDependency": () => typeof import("webpack/lib/dependencies/EntryDependency");
    "dependencies/ExportsInfoDependency": () => typeof import("webpack/lib/dependencies/ExportsInfoDependency");
    "dependencies/HarmonyAcceptDependency": () => typeof import("webpack/lib/dependencies/HarmonyAcceptDependency");
    "dependencies/HarmonyAcceptImportDependency": () => typeof import("webpack/lib/dependencies/HarmonyAcceptImportDependency");
    "dependencies/HarmonyCompatibilityDependency": () => typeof import("webpack/lib/dependencies/HarmonyCompatibilityDependency");
    "dependencies/HarmonyExportExpressionDependency": () => typeof import("webpack/lib/dependencies/HarmonyExportExpressionDependency");
    "dependencies/HarmonyExportHeaderDependency": () => typeof import("webpack/lib/dependencies/HarmonyExportHeaderDependency");
    "dependencies/HarmonyExportImportedSpecifierDependency": () => typeof import("webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency");
    "dependencies/HarmonyExportSpecifierDependency": () => typeof import("webpack/lib/dependencies/HarmonyExportSpecifierDependency");
    "dependencies/HarmonyImportSideEffectDependency": () => typeof import("webpack/lib/dependencies/HarmonyImportSideEffectDependency");
    "dependencies/HarmonyImportSpecifierDependency": () => typeof import("webpack/lib/dependencies/HarmonyImportSpecifierDependency");
    "dependencies/HarmonyEvaluatedImportSpecifierDependency": () => typeof import("webpack/lib/dependencies/HarmonyEvaluatedImportSpecifierDependency");
    "dependencies/ImportContextDependency": () => typeof import("webpack/lib/dependencies/ImportContextDependency");
    "dependencies/ImportDependency": () => typeof import("webpack/lib/dependencies/ImportDependency");
    "dependencies/ImportEagerDependency": () => typeof import("webpack/lib/dependencies/ImportEagerDependency");
    "dependencies/ImportWeakDependency": () => typeof import("webpack/lib/dependencies/ImportWeakDependency");
    "dependencies/JsonExportsDependency": () => typeof import("webpack/lib/dependencies/JsonExportsDependency");
    "dependencies/LocalModule": () => typeof import("webpack/lib/dependencies/LocalModule");
    "dependencies/LocalModuleDependency": () => typeof import("webpack/lib/dependencies/LocalModuleDependency");
    "dependencies/ModuleDecoratorDependency": () => typeof import("webpack/lib/dependencies/ModuleDecoratorDependency");
    "dependencies/ModuleHotAcceptDependency": () => typeof import("webpack/lib/dependencies/ModuleHotAcceptDependency");
    "dependencies/ModuleHotDeclineDependency": () => typeof import("webpack/lib/dependencies/ModuleHotDeclineDependency");
    "dependencies/ImportMetaHotAcceptDependency": () => typeof import("webpack/lib/dependencies/ImportMetaHotAcceptDependency");
    "dependencies/ImportMetaHotDeclineDependency": () => typeof import("webpack/lib/dependencies/ImportMetaHotDeclineDependency");
    "dependencies/ImportMetaContextDependency": () => typeof import("webpack/lib/dependencies/ImportMetaContextDependency");
    "dependencies/ProvidedDependency": () => typeof import("webpack/lib/dependencies/ProvidedDependency");
    "dependencies/PureExpressionDependency": () => typeof import("webpack/lib/dependencies/PureExpressionDependency");
    "dependencies/RequireContextDependency": () => typeof import("webpack/lib/dependencies/RequireContextDependency");
    "dependencies/RequireEnsureDependenciesBlock": () => typeof import("webpack/lib/dependencies/RequireEnsureDependenciesBlock");
    "dependencies/RequireEnsureDependency": () => typeof import("webpack/lib/dependencies/RequireEnsureDependency");
    "dependencies/RequireEnsureItemDependency": () => typeof import("webpack/lib/dependencies/RequireEnsureItemDependency");
    "dependencies/RequireHeaderDependency": () => typeof import("webpack/lib/dependencies/RequireHeaderDependency");
    "dependencies/RequireIncludeDependency": () => typeof import("webpack/lib/dependencies/RequireIncludeDependency");
    "dependencies/RequireIncludeDependencyParserPlugin": () => typeof import("webpack/lib/dependencies/RequireIncludeDependencyParserPlugin");
    "dependencies/RequireResolveContextDependency": () => typeof import("webpack/lib/dependencies/RequireResolveContextDependency");
    "dependencies/RequireResolveDependency": () => typeof import("webpack/lib/dependencies/RequireResolveDependency");
    "dependencies/RequireResolveHeaderDependency": () => typeof import("webpack/lib/dependencies/RequireResolveHeaderDependency");
    "dependencies/RuntimeRequirementsDependency": () => typeof import("webpack/lib/dependencies/RuntimeRequirementsDependency");
    "dependencies/StaticExportsDependency": () => typeof import("webpack/lib/dependencies/StaticExportsDependency");
    "dependencies/SystemPlugin": () => typeof import("webpack/lib/dependencies/SystemPlugin");
    "dependencies/UnsupportedDependency": () => typeof import("webpack/lib/dependencies/UnsupportedDependency");
    "dependencies/URLDependency": () => typeof import("webpack/lib/dependencies/URLDependency");
    "dependencies/WebAssemblyExportImportedDependency": () => typeof import("webpack/lib/dependencies/WebAssemblyExportImportedDependency");
    "dependencies/WebAssemblyImportDependency": () => typeof import("webpack/lib/dependencies/WebAssemblyImportDependency");
    "dependencies/WebpackIsIncludedDependency": () => typeof import("webpack/lib/dependencies/WebpackIsIncludedDependency");
    "dependencies/WorkerDependency": () => typeof import("webpack/lib/dependencies/WorkerDependency");
    "json/JsonData": () => typeof import("webpack/lib/json/JsonData");
    "optimize/ConcatenatedModule": () => typeof import("webpack/lib/optimize/ConcatenatedModule");
    DelegatedModule: () => typeof import("webpack/lib/DelegatedModule");
    DependenciesBlock: () => typeof import("webpack/lib/DependenciesBlock");
    DllModule: () => typeof import("webpack/lib/DllModule");
    ExternalModule: () => typeof import("webpack/lib/ExternalModule");
    FileSystemInfo: () => typeof import("webpack/lib/FileSystemInfo");
    InitFragment: () => typeof import("webpack/lib/InitFragment");
    InvalidDependenciesModuleWarning: () => typeof import("webpack/lib/InvalidDependenciesModuleWarning");
    Module: () => typeof import("webpack/lib/Module");
    ModuleBuildError: () => typeof import("webpack/lib/ModuleBuildError");
    ModuleDependencyWarning: () => typeof import("webpack/lib/ModuleDependencyWarning");
    ModuleError: () => typeof import("webpack/lib/ModuleError");
    ModuleGraph: () => typeof import("webpack/lib/ModuleGraph");
    ModuleParseError: () => typeof import("webpack/lib/ModuleParseError");
    ModuleWarning: () => typeof import("webpack/lib/ModuleWarning");
    NormalModule: () => typeof import("webpack/lib/NormalModule");
    CssModule: () => typeof import("webpack/lib/CssModule");
    RawDataUrlModule: () => typeof import("webpack/lib/asset/RawDataUrlModule");
    RawModule: () => typeof import("webpack/lib/RawModule");
    "sharing/ConsumeSharedModule": () => typeof import("webpack/lib/sharing/ConsumeSharedModule");
    "sharing/ConsumeSharedFallbackDependency": () => typeof import("webpack/lib/sharing/ConsumeSharedFallbackDependency");
    "sharing/ProvideSharedModule": () => typeof import("webpack/lib/sharing/ProvideSharedModule");
    "sharing/ProvideSharedDependency": () => typeof import("webpack/lib/sharing/ProvideSharedDependency");
    "sharing/ProvideForSharedDependency": () => typeof import("webpack/lib/sharing/ProvideForSharedDependency");
    UnsupportedFeatureWarning: () => typeof import("webpack/lib/UnsupportedFeatureWarning");
    "util/LazySet": () => typeof import("webpack/lib/util/LazySet");
    UnhandledSchemeError: () => typeof import("webpack/lib/UnhandledSchemeError");
    NodeStuffInWebError: () => typeof import("webpack/lib/NodeStuffInWebError");
    WebpackError: () => typeof import("webpack/lib/WebpackError");
    "util/registerExternalSerializer": () => void;
};
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/makeSerializable.d.ts
declare function _exports(Constructor: Constructor, request: string, name?: string | null): void;
export = _exports;
export type Constructor = import("../serialization/ObjectMiddleware").Constructor;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/memoize.d.ts
export = memoize;
/** @template T @typedef {function(): T} FunctionReturning */
/**
 * @template T
 * @param {FunctionReturning<T>} fn memorized function
 * @returns {FunctionReturning<T>} new function
 */
declare function memoize<T>(fn: FunctionReturning<T>): FunctionReturning<T>;
declare namespace memoize {
    export { FunctionReturning };
}
type FunctionReturning<T> = () => T;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/nonNumericOnlyHash.d.ts
declare function _exports(hash: string, hashLength: number): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/numberHash.d.ts
declare function _exports(str: string, range: number): number;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/objectToMap.d.ts
declare function _exports(obj: object): Map<string, any>;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/processAsyncTree.d.ts
export = processAsyncTree;
/**
 * @template T
 * @template {Error} E
 * @param {Iterable<T>} items initial items
 * @param {number} concurrency number of items running in parallel
 * @param {function(T, function(T): void, function(E=): void): void} processor worker which pushes more items
 * @param {function(E=): void} callback all items processed
 * @returns {void}
 */
declare function processAsyncTree<T, E extends Error>(items: Iterable<T>, concurrency: number, processor: (arg0: T, arg1: (arg0: T) => void, arg2: (arg0?: E) => void) => void, callback: (arg0?: E) => void): void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/propertyAccess.d.ts
export = propertyAccess;
/**
 * @param {ArrayLike<string>} properties properties
 * @param {number} start start index
 * @returns {string} chain of property accesses
 */
declare function propertyAccess(properties: ArrayLike<string>, start?: number): string;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/propertyName.d.ts
export const SAFE_IDENTIFIER: RegExp;
export const RESERVED_IDENTIFIER: Set<string>;
/**
 * @summary Returns a valid JS property name for the given property.
 * Certain strings like "default", "null", and names with whitespace are not
 * valid JS property names, so they are returned as strings.
 *
 * @param {string} prop property name to analyze
 * @returns {string} valid JS property name
 */
export function propertyName(prop: string): string;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/registerExternalSerializer.d.ts
export type Position = import("acorn").Position;
export type RealDependencyLocation = import("../Dependency").RealDependencyLocation;
export type SourcePosition = import("../Dependency").SourcePosition;
export type ObjectDeserializerContext = import("./serialization").ObjectDeserializerContext;
export type ObjectSerializerContext = import("./serialization").ObjectSerializerContext;
export type WebpackObjectSerializerContext = import("webpack/lib/serialization/ObjectMiddleware").ObjectSerializerContext & {
    writeLazy?: (value: any) => void;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/runtime.d.ts
export function getEntryRuntime(compilation: Compilation, name: string, options?: EntryOptions | undefined): RuntimeSpec;
export function forEachRuntime(runtime: RuntimeSpec, fn: (arg0: string | undefined) => void, deterministicOrder?: boolean): void;
export function runtimeConditionToString(runtimeCondition: RuntimeCondition): string;
export function compareRuntime(a: RuntimeSpec, b: RuntimeSpec): -1 | 0 | 1;
export function mergeRuntimeCondition(a: RuntimeCondition, b: RuntimeCondition, runtime: RuntimeSpec): RuntimeCondition;
export function mergeRuntimeConditionNonFalse(a: RuntimeSpec | true, b: RuntimeSpec | true, runtime: RuntimeSpec): RuntimeSpec | true;
export function intersectRuntime(a: RuntimeSpec, b: RuntimeSpec): RuntimeSpec;
export function subtractRuntimeCondition(a: RuntimeCondition, b: RuntimeCondition, runtime: RuntimeSpec): RuntimeCondition;
export function filterRuntime(runtime: RuntimeSpec, filter: (arg0: RuntimeSpec) => boolean): boolean | RuntimeSpec;
export type Compilation = import("../Compilation");
export type EntryOptions = import("../Entrypoint").EntryOptions;
export type RuntimeSpec = string | SortableSet<string> | undefined;
export type RuntimeCondition = RuntimeSpec | boolean;
export type RuntimeSpecMapInnerMap<T> = Map<string, T>;
/**
 * @param {RuntimeSpec} runtime runtime(s)
 * @returns {string} key of runtimes
 */
export function getRuntimeKey(runtime: RuntimeSpec): string;
/**
 * @param {string} key key of runtimes
 * @returns {RuntimeSpec} runtime(s)
 */
export function keyToRuntime(key: string): RuntimeSpec;
/**
 * @param {RuntimeSpec} runtime runtime(s)
 * @returns {string} readable version
 */
export function runtimeToString(runtime: RuntimeSpec): string;
/**
 * @param {RuntimeSpec} a first
 * @param {RuntimeSpec} b second
 * @returns {boolean} true, when they are equal
 */
export function runtimeEqual(a: RuntimeSpec, b: RuntimeSpec): boolean;
/**
 * @param {RuntimeSpec} a first
 * @param {RuntimeSpec} b second
 * @returns {RuntimeSpec} merged
 */
export function mergeRuntime(a: RuntimeSpec, b: RuntimeSpec): RuntimeSpec;
/**
 * @param {RuntimeSpec} a first (may be modified)
 * @param {RuntimeSpec} b second
 * @returns {RuntimeSpec} merged
 */
export function mergeRuntimeOwned(a: RuntimeSpec, b: RuntimeSpec): RuntimeSpec;
/**
 * @param {RuntimeSpec} a first
 * @param {RuntimeSpec} b second
 * @returns {RuntimeSpec} result
 */
export function subtractRuntime(a: RuntimeSpec, b: RuntimeSpec): RuntimeSpec;
/**
 * @template T
 * @typedef {Map<string, T>} RuntimeSpecMapInnerMap
 * */
/**
 * @template T
 */
export class RuntimeSpecMap<T> {
    /**
     * @param {RuntimeSpecMap<T>=} clone copy form this
     */
    constructor(clone?: RuntimeSpecMap<T> | undefined);
    _mode: number;
    /** @type {RuntimeSpec} */
    _singleRuntime: RuntimeSpec;
    /** @type {T | undefined} */
    _singleValue: T | undefined;
    /** @type {RuntimeSpecMapInnerMap<T> | undefined} */
    _map: RuntimeSpecMapInnerMap<T> | undefined;
    /**
     * @param {RuntimeSpec} runtime the runtimes
     * @returns {T | undefined} value
     */
    get(runtime: RuntimeSpec): T | undefined;
    /**
     * @param {RuntimeSpec} runtime the runtimes
     * @returns {boolean} true, when the runtime is stored
     */
    has(runtime: RuntimeSpec): boolean;
    /**
     * @param {RuntimeSpec} runtime the runtimes
     * @param {T} value the value
     */
    set(runtime: RuntimeSpec, value: T): void;
    /**
     * @param {RuntimeSpec} runtime the runtimes
     * @param {() => TODO} computer function to compute the value
     * @returns {TODO} true, when the runtime was deleted
     */
    provide(runtime: RuntimeSpec, computer: () => TODO): TODO;
    /**
     * @param {RuntimeSpec} runtime the runtimes
     */
    delete(runtime: RuntimeSpec): void;
    /**
     * @param {RuntimeSpec} runtime the runtimes
     * @param {function(T | undefined): T} fn function to update the value
     */
    update(runtime: RuntimeSpec, fn: (arg0: T | undefined) => T): void;
    keys(): RuntimeSpec[];
    values(): IterableIterator<any>;
    get size(): number;
}
export class RuntimeSpecSet {
    /**
     * @param {Iterable<RuntimeSpec>=} iterable iterable
     */
    constructor(iterable?: Iterable<RuntimeSpec> | undefined);
    /** @type {Map<string, RuntimeSpec>} */
    _map: Map<string, RuntimeSpec>;
    /**
     * @param {RuntimeSpec} runtime runtime
     */
    add(runtime: RuntimeSpec): void;
    /**
     * @param {RuntimeSpec} runtime runtime
     * @returns {boolean} true, when the runtime exists
     */
    has(runtime: RuntimeSpec): boolean;
    get size(): number;
    [Symbol.iterator](): IterableIterator<RuntimeSpec>;
}
import SortableSet = require("webpack/lib/util/SortableSet");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/semver.d.ts
export function parseRange(str: string): SemVerRange;
export function stringifyHoley(json: any): string;
export function parseVersionRuntimeCode(runtimeTemplate: any): string;
export function versionLtRuntimeCode(runtimeTemplate: any): string;
export function rangeToStringRuntimeCode(runtimeTemplate: any): string;
export function satisfyRuntimeCode(runtimeTemplate: any): string;
export type RuntimeTemplate = import("../RuntimeTemplate");
export type SemVerRange = (string | number | undefined | [])[];
/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */
/** @typedef {(string|number|undefined|[])[]} SemVerRange */
/**
 * @param {string} str version string
 * @returns {(string|number|undefined|[])[]} parsed version
 */
export function parseVersion(str: string): (string | number | undefined | [])[];
/**
 * @param {string} a version
 * @param {string} b version
 * @returns {boolean} true, iff a < b
 */
export function versionLt(a: string, b: string): boolean;
export function rangeToString(range: any): any;
/**
 * @param {SemVerRange} range version range
 * @param {string} version the version
 * @returns {boolean} if version satisfy the range
 */
export function satisfy(range: SemVerRange, version: string): boolean;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/serialization.d.ts
export type MEASURE_END_OPERATION = import("../serialization/BinaryMiddleware").MEASURE_END_OPERATION_TYPE;
export type MEASURE_START_OPERATION = import("../serialization/BinaryMiddleware").MEASURE_START_OPERATION_TYPE;
export type ObjectDeserializerContext = import("../serialization/ObjectMiddleware").ObjectDeserializerContext;
export type ObjectSerializerContext = import("../serialization/ObjectMiddleware").ObjectSerializerContext;
export type Serializer = import("../serialization/Serializer");
export type Hash = typeof import("../util/Hash");
export type IntermediateFileSystem = import("../util/fs").IntermediateFileSystem;
declare let register: typeof import("webpack/lib/serialization/ObjectMiddleware").register;
declare let registerLoader: typeof import("webpack/lib/serialization/ObjectMiddleware").registerLoader;
declare let registerNotSerializable: typeof import("webpack/lib/serialization/ObjectMiddleware").registerNotSerializable;
declare let NOT_SERIALIZABLE: {};
export type MEASURE_START_OPERATION = import("../serialization/BinaryMiddleware").MEASURE_START_OPERATION_TYPE;
export let MEASURE_START_OPERATION: unique symbol;
export type MEASURE_END_OPERATION = import("../serialization/BinaryMiddleware").MEASURE_END_OPERATION_TYPE;
export let MEASURE_END_OPERATION: unique symbol;
declare let buffersSerializer: import("webpack/lib/serialization/Serializer");
declare function createFileSerializer(fs: import("webpack/lib/util/fs").IntermediateFileSystem, hashFunction: string | typeof import("webpack/lib/util/Hash")): import("webpack/lib/serialization/Serializer");
export {};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/smartGrouping.d.ts
export = smartGrouping;
/**
 * @typedef {Object} GroupOptions
 * @property {boolean=} groupChildren
 * @property {boolean=} force
 * @property {number=} targetGroupCount
 */
/**
 * @template T
 * @template R
 * @typedef {Object} GroupConfig
 * @property {function(T): string[]} getKeys
 * @property {function(string, (R | T)[], T[]): R} createGroup
 * @property {function(string, T[]): GroupOptions=} getOptions
 */
/**
 * @template T
 * @template R
 * @typedef {Object} ItemWithGroups
 * @property {T} item
 * @property {Set<Group<T, R>>} groups
 */
/**
 * @template T
 * @template R
 * @typedef {{ config: GroupConfig<T, R>, name: string, alreadyGrouped: boolean, items: Set<ItemWithGroups<T, R>> | undefined }} Group
 */
/**
 * @template T
 * @template R
 * @param {T[]} items the list of items
 * @param {GroupConfig<T, R>[]} groupConfigs configuration
 * @returns {(R | T)[]} grouped items
 */
declare function smartGrouping<T, R>(items: T[], groupConfigs: GroupConfig<T, R>[]): (T | R)[];
declare namespace smartGrouping {
    export { GroupOptions, GroupConfig, ItemWithGroups, Group };
}
type GroupConfig<T, R> = {
    getKeys: (arg0: T) => string[];
    createGroup: (arg0: string, arg1: (R | T)[], arg2: T[]) => R;
    getOptions?: ((arg0: string, arg1: T[]) => GroupOptions) | undefined;
};
type GroupOptions = {
    groupChildren?: boolean | undefined;
    force?: boolean | undefined;
    targetGroupCount?: number | undefined;
};
type ItemWithGroups<T, R> = {
    item: T;
    groups: Set<Group<T, R>>;
};
type Group<T, R> = {
    config: GroupConfig<T, R>;
    name: string;
    alreadyGrouped: boolean;
    items: Set<ItemWithGroups<T, R>> | undefined;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/util/source.d.ts
export type Source = import("webpack-sources").Source;
/**
 * @param {Source} a a source
 * @param {Source} b another source
 * @returns {boolean} true, when both sources are equal
 */
export function isSourceEqual(a: Source, b: Source): boolean;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/validateSchema.d.ts
export = validateSchema;
/**
 * @param {Parameters<typeof validate>[0]} schema a json schema
 * @param {Parameters<typeof validate>[1]} options the options that should be validated
 * @param {Parameters<typeof validate>[2]=} validationConfiguration configuration for generating errors
 * @returns {void}
 */
declare function validateSchema(schema: [schema: import("webpack/node_modules/schema-utils/declarations/validate").Schema, options: object | object[], configuration?: import("webpack/node_modules/schema-utils/declarations/validate").ValidationErrorConfiguration][0], options: [schema: import("webpack/node_modules/schema-utils/declarations/validate").Schema, options: object | object[], configuration?: import("webpack/node_modules/schema-utils/declarations/validate").ValidationErrorConfiguration][1], validationConfiguration?: [schema: import("webpack/node_modules/schema-utils/declarations/validate").Schema, options: object | object[], configuration?: import("webpack/node_modules/schema-utils/declarations/validate").ValidationErrorConfiguration][2] | undefined): void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm/EnableWasmLoadingPlugin.d.ts
export = EnableWasmLoadingPlugin;
declare class EnableWasmLoadingPlugin {
    /**
     * @param {Compiler} compiler the compiler instance
     * @param {WasmLoadingType} type type of library
     * @returns {void}
     */
    static setEnabled(compiler: Compiler, type: any): void;
    /**
     * @param {Compiler} compiler the compiler instance
     * @param {WasmLoadingType} type type of library
     * @returns {void}
     */
    static checkEnabled(compiler: Compiler, type: any): void;
    /**
     * @param {WasmLoadingType} type library type that should be available
     */
    constructor(type: any);
    type: any;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace EnableWasmLoadingPlugin {
    export { LibraryOptions, WasmLoadingType, Compiler };
}
type Compiler = import("../Compiler");
type LibraryOptions = any;
type WasmLoadingType = any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-async/AsyncWasmLoadingRuntimeModule.d.ts
export = AsyncWasmLoadingRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compilation")} Compilation */
/**
 * @typedef {Object} AsyncWasmLoadingRuntimeModuleOptions
 * @property {function(string): string} generateLoadBinaryCode
 * @property {boolean} supportsStreaming
 */
declare class AsyncWasmLoadingRuntimeModule extends RuntimeModule {
    /**
     * @param {AsyncWasmLoadingRuntimeModuleOptions} options options
     */
    constructor({ generateLoadBinaryCode, supportsStreaming }: AsyncWasmLoadingRuntimeModuleOptions);
    generateLoadBinaryCode: (arg0: string) => string;
    supportsStreaming: boolean;
}
declare namespace AsyncWasmLoadingRuntimeModule {
    export { Chunk, Compilation, AsyncWasmLoadingRuntimeModuleOptions };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type AsyncWasmLoadingRuntimeModuleOptions = {
    generateLoadBinaryCode: (arg0: string) => string;
    supportsStreaming: boolean;
};
type Chunk = import("../Chunk");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-async/AsyncWebAssemblyGenerator.d.ts
export = AsyncWebAssemblyGenerator;
/**
 * @typedef {Object} AsyncWebAssemblyGeneratorOptions
 * @property {boolean} [mangleImports] mangle imports
 */
declare class AsyncWebAssemblyGenerator extends Generator {
    /**
     * @param {AsyncWebAssemblyGeneratorOptions} options options
     */
    constructor(options: AsyncWebAssemblyGeneratorOptions);
    options: AsyncWebAssemblyGeneratorOptions;
}
declare namespace AsyncWebAssemblyGenerator {
    export { Source, GenerateContext, NormalModule, AsyncWebAssemblyGeneratorOptions };
}
import Generator = require("webpack/lib/Generator");
type AsyncWebAssemblyGeneratorOptions = {
    /**
     * mangle imports
     */
    mangleImports?: boolean;
};
type Source = import("webpack-sources").Source;
type GenerateContext = import("../Generator").GenerateContext;
type NormalModule = import("../NormalModule");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-async/AsyncWebAssemblyJavascriptGenerator.d.ts
export = AsyncWebAssemblyJavascriptGenerator;
/**
 * @typedef {{ request: string, importVar: string }} ImportObjRequestItem
 */
declare class AsyncWebAssemblyJavascriptGenerator extends Generator {
    /**
     * @param {OutputOptions["webassemblyModuleFilename"]} filenameTemplate template for the WebAssembly module filename
     */
    constructor(filenameTemplate: any);
    filenameTemplate: any;
}
declare namespace AsyncWebAssemblyJavascriptGenerator {
    export { Source, OutputOptions, DependencyTemplates, GenerateContext, Module, NormalModule, RuntimeTemplate, ImportObjRequestItem };
}
import Generator = require("webpack/lib/Generator");
type Source = import("webpack-sources").Source;
type OutputOptions = any;
type DependencyTemplates = import("../DependencyTemplates");
type GenerateContext = import("../Generator").GenerateContext;
type Module = import("../Module");
type NormalModule = import("../NormalModule");
type RuntimeTemplate = import("../RuntimeTemplate");
type ImportObjRequestItem = {
    request: string;
    importVar: string;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-async/AsyncWebAssemblyModulesPlugin.d.ts
export = AsyncWebAssemblyModulesPlugin;
declare class AsyncWebAssemblyModulesPlugin {
    /**
     * @param {Compilation} compilation the compilation
     * @returns {CompilationHooks} the attached hooks
     */
    static getCompilationHooks(compilation: Compilation): CompilationHooks;
    /**
     * @param {AsyncWebAssemblyModulesPluginOptions} options options
     */
    constructor(options: AsyncWebAssemblyModulesPluginOptions);
    options: AsyncWebAssemblyModulesPluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
    /**
     * @param {Module} module the rendered module
     * @param {WebAssemblyRenderContext} renderContext options object
     * @param {CompilationHooks} hooks hooks
     * @returns {Source} the newly generated source from rendering
     */
    renderModule(module: Module, renderContext: WebAssemblyRenderContext, hooks: CompilationHooks): Source;
}
declare namespace AsyncWebAssemblyModulesPlugin {
    export { Source, OutputOptions, Chunk, ChunkGraph, CodeGenerationResults, Compiler, DependencyTemplates, Module, ModuleGraph, RuntimeTemplate, RenderManifestEntry, RenderManifestOptions, WebpackError, WebAssemblyRenderContext, CompilationHooks, AsyncWebAssemblyModulesPluginOptions };
}
type AsyncWebAssemblyModulesPluginOptions = {
    /**
     * mangle imports
     */
    mangleImports?: boolean;
};
type Compiler = import("../Compiler");
type Module = import("../Module");
type WebAssemblyRenderContext = {
    /**
     * the chunk
     */
    chunk: Chunk;
    /**
     * the dependency templates
     */
    dependencyTemplates: DependencyTemplates;
    /**
     * the runtime template
     */
    runtimeTemplate: RuntimeTemplate;
    /**
     * the module graph
     */
    moduleGraph: ModuleGraph;
    /**
     * the chunk graph
     */
    chunkGraph: ChunkGraph;
    /**
     * results of code generation
     */
    codeGenerationResults: CodeGenerationResults;
};
type CompilationHooks = {
    renderModuleContent: SyncWaterfallHook<[Source, Module, WebAssemblyRenderContext]>;
};
type Source = import("webpack-sources").Source;
import Compilation = require("webpack/lib/Compilation");
type OutputOptions = any;
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type CodeGenerationResults = import("../CodeGenerationResults");
type DependencyTemplates = import("../DependencyTemplates");
type ModuleGraph = import("../ModuleGraph");
type RuntimeTemplate = import("../RuntimeTemplate");
type RenderManifestEntry = import("../Template").RenderManifestEntry;
type RenderManifestOptions = import("../Template").RenderManifestOptions;
type WebpackError = import("../WebpackError");
import { SyncWaterfallHook } from "tapable";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-async/AsyncWebAssemblyParser.d.ts
export = WebAssemblyParser;
declare class WebAssemblyParser extends Parser {
    /**
     * @param {{}=} options parser options
     */
    constructor(options?: {} | undefined);
    hooks: Readonly<{}>;
    options: {};
}
declare namespace WebAssemblyParser {
    export { BuildInfo, BuildMeta, ParserState, PreparsedAst };
}
import Parser = require("webpack/lib/Parser");
type BuildInfo = import("../Module").BuildInfo;
type BuildMeta = import("../Module").BuildMeta;
type ParserState = import("../Parser").ParserState;
type PreparsedAst = import("../Parser").PreparsedAst;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-sync/UnsupportedWebAssemblyFeatureError.d.ts
export = UnsupportedWebAssemblyFeatureError;
declare class UnsupportedWebAssemblyFeatureError extends WebpackError {
    /** @param {string} message Error message */
    constructor(message: string);
}
import WebpackError = require("webpack/lib/WebpackError");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-sync/WasmChunkLoadingRuntimeModule.d.ts
export = WasmChunkLoadingRuntimeModule;
/**
 * @typedef {Object} WasmChunkLoadingRuntimeModuleOptions
 * @property {(path: string) => string} generateLoadBinaryCode
 * @property {boolean} [supportsStreaming]
 * @property {boolean} [mangleImports]
 * @property {Set<string>} runtimeRequirements
 */
declare class WasmChunkLoadingRuntimeModule extends RuntimeModule {
    /**
     * @param {WasmChunkLoadingRuntimeModuleOptions} options options
     */
    constructor({ generateLoadBinaryCode, supportsStreaming, mangleImports, runtimeRequirements }: WasmChunkLoadingRuntimeModuleOptions);
    generateLoadBinaryCode: (path: string) => string;
    supportsStreaming: boolean;
    mangleImports: boolean;
    _runtimeRequirements: Set<string>;
}
declare namespace WasmChunkLoadingRuntimeModule {
    export { Signature, Chunk, ChunkGraph, Compilation, Module, ModuleGraph, RuntimeSpec, WasmChunkLoadingRuntimeModuleOptions };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type WasmChunkLoadingRuntimeModuleOptions = {
    generateLoadBinaryCode: (path: string) => string;
    supportsStreaming?: boolean;
    mangleImports?: boolean;
    runtimeRequirements: Set<string>;
};
type Signature = any;
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type Compilation = import("../Compilation");
type Module = import("../Module");
type ModuleGraph = import("../ModuleGraph");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-sync/WasmFinalizeExportsPlugin.d.ts
export = WasmFinalizeExportsPlugin;
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../Module").BuildMeta} BuildMeta */
declare class WasmFinalizeExportsPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace WasmFinalizeExportsPlugin {
    export { Compiler, Dependency, Module, BuildMeta };
}
type Compiler = import("../Compiler");
type Dependency = import("../Dependency");
type Module = import("../Module");
type BuildMeta = import("../Module").BuildMeta;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-sync/WebAssemblyGenerator.d.ts
export = WebAssemblyGenerator;
/**
 * @typedef {Object} WebAssemblyGeneratorOptions
 * @property {boolean} [mangleImports] mangle imports
 */
declare class WebAssemblyGenerator extends Generator {
    /**
     * @param {WebAssemblyGeneratorOptions} options options
     */
    constructor(options: WebAssemblyGeneratorOptions);
    options: WebAssemblyGeneratorOptions;
}
declare namespace WebAssemblyGenerator {
    export { Source, DependencyTemplates, GenerateContext, Module, ModuleGraph, NormalModule, RuntimeTemplate, RuntimeSpec, UsedWasmDependency, ArrayBufferTransform, WebAssemblyGeneratorOptions };
}
import Generator = require("webpack/lib/Generator");
type WebAssemblyGeneratorOptions = {
    /**
     * mangle imports
     */
    mangleImports?: boolean;
};
type Source = import("webpack-sources").Source;
type DependencyTemplates = import("../DependencyTemplates");
type GenerateContext = import("../Generator").GenerateContext;
type Module = import("../Module");
type ModuleGraph = import("../ModuleGraph");
type NormalModule = import("../NormalModule");
type RuntimeTemplate = import("../RuntimeTemplate");
type RuntimeSpec = import("../util/runtime").RuntimeSpec;
type UsedWasmDependency = import("./WebAssemblyUtils").UsedWasmDependency;
type ArrayBufferTransform = (buf: ArrayBuffer) => ArrayBuffer;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-sync/WebAssemblyInInitialChunkError.d.ts
export = WebAssemblyInInitialChunkError;
declare class WebAssemblyInInitialChunkError extends WebpackError {
    /**
     * @param {Module} module WASM module
     * @param {ModuleGraph} moduleGraph the module graph
     * @param {ChunkGraph} chunkGraph the chunk graph
     * @param {RequestShortener} requestShortener request shortener
     */
    constructor(module: Module, moduleGraph: ModuleGraph, chunkGraph: ChunkGraph, requestShortener: RequestShortener);
}
declare namespace WebAssemblyInInitialChunkError {
    export { ChunkGraph, Module, ModuleGraph, RequestShortener };
}
import WebpackError = require("webpack/lib/WebpackError");
type Module = import("../Module");
type ModuleGraph = import("../ModuleGraph");
type ChunkGraph = import("../ChunkGraph");
type RequestShortener = import("../RequestShortener");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-sync/WebAssemblyJavascriptGenerator.d.ts
export = WebAssemblyJavascriptGenerator;
declare class WebAssemblyJavascriptGenerator extends Generator {
}
declare namespace WebAssemblyJavascriptGenerator {
    export { Source, Dependency, DependencyTemplates, GenerateContext, NormalModule, RuntimeTemplate };
}
import Generator = require("webpack/lib/Generator");
type Source = import("webpack-sources").Source;
type Dependency = import("../Dependency");
type DependencyTemplates = import("../DependencyTemplates");
type GenerateContext = import("../Generator").GenerateContext;
type NormalModule = import("../NormalModule");
type RuntimeTemplate = import("../RuntimeTemplate");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-sync/WebAssemblyModulesPlugin.d.ts
export = WebAssemblyModulesPlugin;
/**
 * @typedef {Object} WebAssemblyModulesPluginOptions
 * @property {boolean} [mangleImports] mangle imports
 */
declare class WebAssemblyModulesPlugin {
    /**
     * @param {WebAssemblyModulesPluginOptions} options options
     */
    constructor(options: WebAssemblyModulesPluginOptions);
    options: WebAssemblyModulesPluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace WebAssemblyModulesPlugin {
    export { Source, OutputOptions, Compiler, Module, ModuleTemplate, RenderContext, WebAssemblyModulesPluginOptions };
}
type WebAssemblyModulesPluginOptions = {
    /**
     * mangle imports
     */
    mangleImports?: boolean;
};
type Compiler = import("../Compiler");
type Source = import("webpack-sources").Source;
type OutputOptions = any;
type Module = import("../Module");
type ModuleTemplate = import("../ModuleTemplate");
type RenderContext = import("../javascript/JavascriptModulesPlugin").RenderContext;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-sync/WebAssemblyParser.d.ts
export = WebAssemblyParser;
declare class WebAssemblyParser extends Parser {
    /**
     * @param {{}=} options parser options
     */
    constructor(options?: {} | undefined);
    hooks: Readonly<{}>;
    options: {};
}
declare namespace WebAssemblyParser {
    export { Module, BuildInfo, BuildMeta, ParserState, PreparsedAst };
}
import Parser = require("webpack/lib/Parser");
type Module = import("../Module");
type BuildInfo = import("../Module").BuildInfo;
type BuildMeta = import("../Module").BuildMeta;
type ParserState = import("../Parser").ParserState;
type PreparsedAst = import("../Parser").PreparsedAst;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/wasm-sync/WebAssemblyUtils.d.ts
export type Module = import("../Module");
export type ModuleGraph = import("../ModuleGraph");
export type UsedWasmDependency = {
    /**
     * the dependency
     */
    dependency: WebAssemblyImportDependency;
    /**
     * the export name
     */
    name: string;
    /**
     * the module name
     */
    module: string;
};
/**
 * @param {ModuleGraph} moduleGraph the module graph
 * @param {Module} module the module
 * @param {boolean | undefined} mangle mangle module and export names
 * @returns {UsedWasmDependency[]} used dependencies and (mangled) name
 */
export function getUsedDependencies(moduleGraph: ModuleGraph, module: Module, mangle: boolean | undefined): UsedWasmDependency[];
/** @typedef {import("../Module")} Module */
/** @typedef {import("../ModuleGraph")} ModuleGraph */
/** @typedef {Object} UsedWasmDependency
 * @property {WebAssemblyImportDependency} dependency the dependency
 * @property {string} name the export name
 * @property {string} module the module name
 */
export const MANGLED_MODULE: "a";
import WebAssemblyImportDependency = require("webpack/lib/dependencies/WebAssemblyImportDependency");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/web/FetchCompileAsyncWasmPlugin.d.ts
export = FetchCompileAsyncWasmPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
declare class FetchCompileAsyncWasmPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace FetchCompileAsyncWasmPlugin {
    export { Chunk, Compiler };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/web/FetchCompileWasmPlugin.d.ts
export = FetchCompileWasmPlugin;
/**
 * @typedef {Object} FetchCompileWasmPluginOptions
 * @property {boolean} [mangleImports] mangle imports
 */
declare class FetchCompileWasmPlugin {
    /**
     * @param {FetchCompileWasmPluginOptions} [options] options
     */
    constructor(options?: FetchCompileWasmPluginOptions);
    options: FetchCompileWasmPluginOptions;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace FetchCompileWasmPlugin {
    export { Chunk, Compiler, FetchCompileWasmPluginOptions };
}
type FetchCompileWasmPluginOptions = {
    /**
     * mangle imports
     */
    mangleImports?: boolean;
};
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/web/JsonpChunkLoadingPlugin.d.ts
export = JsonpChunkLoadingPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
declare class JsonpChunkLoadingPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace JsonpChunkLoadingPlugin {
    export { Chunk, Compiler };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/web/JsonpChunkLoadingRuntimeModule.d.ts
export = JsonpChunkLoadingRuntimeModule;
declare class JsonpChunkLoadingRuntimeModule extends RuntimeModule {
    /**
     * @param {Compilation} compilation the compilation
     * @returns {JsonpCompilationPluginHooks} hooks
     */
    static getCompilationHooks(compilation: Compilation): JsonpCompilationPluginHooks;
    /**
     * @param {Set<string>} runtimeRequirements runtime requirements
     */
    constructor(runtimeRequirements: Set<string>);
    _runtimeRequirements: Set<string>;
    /**
     * @private
     * @param {Chunk} chunk chunk
     * @returns {string} generated code
     */
    private _generateBaseUri;
}
declare namespace JsonpChunkLoadingRuntimeModule {
    export { Chunk, ChunkGraph, JsonpCompilationPluginHooks };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
import Compilation = require("webpack/lib/Compilation");
type JsonpCompilationPluginHooks = {
    linkPreload: SyncWaterfallHook<[string, Chunk]>;
    linkPrefetch: SyncWaterfallHook<[string, Chunk]>;
};
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
import { SyncWaterfallHook } from "tapable";

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/web/JsonpTemplatePlugin.d.ts
export = JsonpTemplatePlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../Compiler")} Compiler */
declare class JsonpTemplatePlugin {
    /**
     * @deprecated use JsonpChunkLoadingRuntimeModule.getCompilationHooks instead
     * @param {Compilation} compilation the compilation
     * @returns {JsonpChunkLoadingRuntimeModule.JsonpCompilationPluginHooks} hooks
     */
    static getCompilationHooks(compilation: Compilation): JsonpChunkLoadingRuntimeModule.JsonpCompilationPluginHooks;
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace JsonpTemplatePlugin {
    export { Chunk, Compilation, Compiler };
}
type Compiler = import("../Compiler");
type Compilation = import("../Compilation");
import JsonpChunkLoadingRuntimeModule = require("webpack/lib/web/JsonpChunkLoadingRuntimeModule");
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/webpack.d.ts
export = webpack;
declare const webpack: WebpackFunctionSingle & WebpackFunctionMulti;
declare namespace webpack {
    export { WebpackOptions, WatchOptions, MultiCompilerOptions, MultiStats, Stats, Callback, WebpackFunctionSingle, WebpackFunctionMulti };
}
type WebpackFunctionSingle = (options: any, callback?: Callback<Stats> | undefined) => Compiler;
type WebpackFunctionMulti = (options: ReadonlyArray<WebpackOptions> & MultiCompilerOptions, callback?: Callback<MultiStats> | undefined) => MultiCompiler;
type WebpackOptions = any;
type WatchOptions = import("./Compiler").WatchOptions;
type MultiCompilerOptions = import("./MultiCompiler").MultiCompilerOptions;
type MultiStats = import("./MultiStats");
type Stats = import("./Stats");
type Callback<T> = (err?: Error | undefined, stats?: T | undefined) => void;
import Compiler = require("webpack/lib/Compiler.js");
import MultiCompiler = require("webpack/lib/MultiCompiler.js");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/webworker/ImportScriptsChunkLoadingPlugin.d.ts
export = ImportScriptsChunkLoadingPlugin;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */
declare class ImportScriptsChunkLoadingPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace ImportScriptsChunkLoadingPlugin {
    export { Chunk, Compiler };
}
type Compiler = import("../Compiler");
type Chunk = import("../Chunk");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/webworker/ImportScriptsChunkLoadingRuntimeModule.d.ts
export = ImportScriptsChunkLoadingRuntimeModule;
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../Compilation")} Compilation */
declare class ImportScriptsChunkLoadingRuntimeModule extends RuntimeModule {
    /**
     * @param {Set<string>} runtimeRequirements runtime requirements
     * @param {boolean} withCreateScriptUrl with createScriptUrl support
     */
    constructor(runtimeRequirements: Set<string>, withCreateScriptUrl: boolean);
    runtimeRequirements: Set<string>;
    _withCreateScriptUrl: boolean;
    /**
     * @private
     * @param {Chunk} chunk chunk
     * @returns {string} generated code
     */
    private _generateBaseUri;
}
declare namespace ImportScriptsChunkLoadingRuntimeModule {
    export { Chunk, ChunkGraph, Compilation };
}
import RuntimeModule = require("webpack/lib/RuntimeModule");
type Chunk = import("../Chunk");
type ChunkGraph = import("../ChunkGraph");
type Compilation = import("../Compilation");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/lib/webworker/WebWorkerTemplatePlugin.d.ts
export = WebWorkerTemplatePlugin;
/** @typedef {import("../Compiler")} Compiler */
declare class WebWorkerTemplatePlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler the compiler instance
     * @returns {void}
     */
    apply(compiler: Compiler): void;
}
declare namespace WebWorkerTemplatePlugin {
    export { Compiler };
}
type Compiler = import("../Compiler");

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/module.d.ts
declare namespace webpack {
	type DeclinedEvent =
		| {
				type: "declined";
				/** The module in question. */
				moduleId: number | string;
				/** the chain from where the update was propagated. */
				chain: (number | string)[];
				/** the module id of the declining parent */
				parentId: number | string;
		  }
		| {
				type: "self-declined";
				/** The module in question. */
				moduleId: number | string;
				/** the chain from where the update was propagated. */
				chain: (number | string)[];
		  };

	type UnacceptedEvent = {
		type: "unaccepted";
		/** The module in question. */
		moduleId: number | string;
		/** the chain from where the update was propagated. */
		chain: (number | string)[];
	};

	type AcceptedEvent = {
		type: "accepted";
		/** The module in question. */
		moduleId: number | string;
		/** the modules that are outdated and will be disposed */
		outdatedModules: (number | string)[];
		/** the accepted dependencies that are outdated */
		outdatedDependencies: {
			[id: number]: (number | string)[];
		};
	};

	type DisposedEvent = {
		type: "disposed";
		/** The module in question. */
		moduleId: number | string;
	};

	type ErroredEvent =
		| {
				type: "accept-error-handler-errored";
				/** The module in question. */
				moduleId: number | string;
				/** the module id owning the accept handler. */
				dependencyId: number | string;
				/** the thrown error */
				error: Error;
				/** the error thrown by the module before the error handler tried to handle it. */
				originalError: Error;
		  }
		| {
				type: "self-accept-error-handler-errored";
				/** The module in question. */
				moduleId: number | string;
				/** the thrown error */
				error: Error;
				/** the error thrown by the module before the error handler tried to handle it. */
				originalError: Error;
		  }
		| {
				type: "accept-errored";
				/** The module in question. */
				moduleId: number | string;
				/** the module id owning the accept handler. */
				dependencyId: number | string;
				/** the thrown error */
				error: Error;
		  }
		| {
				type: "self-accept-errored";
				/** The module in question. */
				moduleId: number | string;
				/** the thrown error */
				error: Error;
		  };

	type HotEvent =
		| DeclinedEvent
		| UnacceptedEvent
		| AcceptedEvent
		| DisposedEvent
		| ErroredEvent;

	interface ApplyOptions {
		ignoreUnaccepted?: boolean;
		ignoreDeclined?: boolean;
		ignoreErrored?: boolean;
		onDeclined?: (event: DeclinedEvent) => void;
		onUnaccepted?: (event: UnacceptedEvent) => void;
		onAccepted?: (event: AcceptedEvent) => void;
		onDisposed?: (event: DisposedEvent) => void;
		onErrored?: (event: ErroredEvent) => void;
	}

	const enum HotUpdateStatus {
		idle = "idle",
		check = "check",
		prepare = "prepare",
		ready = "ready",
		dispose = "dispose",
		apply = "apply",
		abort = "abort",
		fail = "fail"
	}

	interface Hot {
		accept: {
			(
				modules: string | string[],
				callback?: (outdatedDependencies: string[]) => void,
				errorHandler?: (
					err: Error,
					context: { moduleId: string | number; dependencyId: string | number }
				) => void
			): void;
			(
				errorHandler?: (
					err: Error,
					ids: { moduleId: string | number; module: NodeJS.Module }
				) => void
			): void;
		};
		status(): HotUpdateStatus;
		decline(module?: string | string[]): void;
		dispose(callback: (data: object) => void): void;
		addDisposeHandler(callback: (data: object) => void): void;
		removeDisposeHandler(callback: (data: object) => void): void;
		invalidate(): void;
		addStatusHandler(callback: (status: HotUpdateStatus) => void): void;
		removeStatusHandler(callback: (status: HotUpdateStatus) => void): void;
		data: object;
		check(
			autoApply?: boolean | ApplyOptions
		): Promise<(string | number)[] | null>;
		apply(options?: ApplyOptions): Promise<(string | number)[] | null>;
	}

	interface ExportInfo {
		used: boolean;
		provideInfo: boolean | null | undefined;
		useInfo: boolean | null | undefined;
		canMangle: boolean;
	}

	interface ExportsInfo {
		[k: string]: ExportInfo & ExportsInfo;
	}

	interface Context {
		resolve(dependency: string): string | number;
		keys(): Array<string>;
		id: string | number;
		(dependency: string): unknown;
	}
}

interface ImportMeta {
	url: string;
	webpack: number;
	webpackHot: webpack.Hot;
	webpackContext: (
		request: string,
		options?: {
			recursive?: boolean;
			regExp?: RegExp;
			include?: RegExp;
			exclude?: RegExp;
			preload?: boolean | number;
			prefetch?: boolean | number;
			fetchPriority?: "low" | "high" | "auto";
			chunkName?: string;
			exports?: string | string[][];
			mode?: "sync" | "eager" | "weak" | "lazy" | "lazy-once";
		}
	) => webpack.Context;
}

declare const __resourceQuery: string;
declare var __webpack_public_path__: string;
declare var __webpack_nonce__: string;
declare const __webpack_chunkname__: string;
declare var __webpack_base_uri__: string;
declare var __webpack_runtime_id__: string;
declare const __webpack_hash__: string;
declare const __webpack_modules__: Record<string | number, NodeJS.Module>;
declare const __webpack_require__: (id: string | number) => unknown;
declare var __webpack_chunk_load__: (chunkId: string | number) => Promise<void>;
declare var __webpack_get_script_filename__: (
	chunkId: string | number
) => string;
declare var __webpack_is_included__: (request: string) => boolean;
declare var __webpack_exports_info__: webpack.ExportsInfo;
declare const __webpack_share_scopes__: Record<
	string,
	Record<
		string,
		{ loaded?: 1; get: () => Promise<unknown>; from: string; eager: boolean }
	>
>;
declare var __webpack_init_sharing__: (scope: string) => Promise<void>;
declare var __non_webpack_require__: (id: any) => unknown;
declare const __system_context__: object;

declare namespace NodeJS {
	interface Module {
		hot: webpack.Hot;
	}

	interface Require {
		ensure(
			dependencies: string[],
			callback: (require: (module: string) => void) => void,
			errorCallback?: (error: Error) => void,
			chunkName?: string
		): void;
		context(
			request: string,
			includeSubdirectories?: boolean,
			filter?: RegExp,
			mode?: "sync" | "eager" | "weak" | "lazy" | "lazy-once"
		): webpack.Context;
		include(dependency: string): void;
		resolveWeak(dependency: string): void;
		onError?: (error: Error) => void;
	}
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/dist/ajv.min.d.ts
declare const _exports: any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/ajv.d.ts
declare var ajv: {
  (options?: ajv.Options): ajv.Ajv;
  new(options?: ajv.Options): ajv.Ajv;
  ValidationError: typeof AjvErrors.ValidationError;
  MissingRefError: typeof AjvErrors.MissingRefError;
  $dataMetaSchema: object;
}

declare namespace AjvErrors {
  class ValidationError extends Error {
    constructor(errors: Array<ajv.ErrorObject>);

    message: string;
    errors: Array<ajv.ErrorObject>;
    ajv: true;
    validation: true;
  }

  class MissingRefError extends Error {
    constructor(baseId: string, ref: string, message?: string);
    static message: (baseId: string, ref: string) => string;

    message: string;
    missingRef: string;
    missingSchema: string;
  }
}

declare namespace ajv {
  type ValidationError = AjvErrors.ValidationError;

  type MissingRefError = AjvErrors.MissingRefError;

  interface Ajv {
    /**
    * Validate data using schema
    * Schema will be compiled and cached (using serialized JSON as key, [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize by default).
    * @param  {string|object|Boolean} schemaKeyRef key, ref or schema object
    * @param  {Any} data to be validated
    * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
    */
    validate(schemaKeyRef: object | string | boolean, data: any): boolean | PromiseLike<any>;
    /**
    * Create validating function for passed schema.
    * @param  {object|Boolean} schema schema object
    * @return {Function} validating function
    */
    compile(schema: object | boolean): ValidateFunction;
    /**
    * Creates validating function for passed schema with asynchronous loading of missing schemas.
    * `loadSchema` option should be a function that accepts schema uri and node-style callback.
    * @this  Ajv
    * @param {object|Boolean} schema schema object
    * @param {Boolean} meta optional true to compile meta-schema; this parameter can be skipped
    * @param {Function} callback optional node-style callback, it is always called with 2 parameters: error (or null) and validating function.
    * @return {PromiseLike<ValidateFunction>} validating function
    */
    compileAsync(schema: object | boolean, meta?: Boolean, callback?: (err: Error, validate: ValidateFunction) => any): PromiseLike<ValidateFunction>;
    /**
    * Adds schema to the instance.
    * @param {object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
    * @param {string} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
    * @return {Ajv} this for method chaining
    */
    addSchema(schema: Array<object> | object, key?: string): Ajv;
    /**
    * Add schema that will be used to validate other schemas
    * options in META_IGNORE_OPTIONS are alway set to false
    * @param {object} schema schema object
    * @param {string} key optional schema key
    * @return {Ajv} this for method chaining
    */
    addMetaSchema(schema: object, key?: string): Ajv;
    /**
    * Validate schema
    * @param {object|Boolean} schema schema to validate
    * @return {Boolean} true if schema is valid
    */
    validateSchema(schema: object | boolean): boolean;
    /**
    * Get compiled schema from the instance by `key` or `ref`.
    * @param  {string} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
    * @return {Function} schema validating function (with property `schema`). Returns undefined if keyRef can't be resolved to an existing schema.
    */
    getSchema(keyRef: string): ValidateFunction | undefined;
    /**
    * Remove cached schema(s).
    * If no parameter is passed all schemas but meta-schemas are removed.
    * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    * @param  {string|object|RegExp|Boolean} schemaKeyRef key, ref, pattern to match key/ref or schema object
    * @return {Ajv} this for method chaining
    */
    removeSchema(schemaKeyRef?: object | string | RegExp | boolean): Ajv;
    /**
    * Add custom format
    * @param {string} name format name
    * @param {string|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
    * @return {Ajv} this for method chaining
    */
    addFormat(name: string, format: FormatValidator | FormatDefinition): Ajv;
    /**
    * Define custom keyword
    * @this  Ajv
    * @param {string} keyword custom keyword, should be a valid identifier, should be different from all standard, custom and macro keywords.
    * @param {object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
    * @return {Ajv} this for method chaining
    */
    addKeyword(keyword: string, definition: KeywordDefinition): Ajv;
    /**
    * Get keyword definition
    * @this  Ajv
    * @param {string} keyword pre-defined or custom keyword.
    * @return {object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
    */
    getKeyword(keyword: string): object | boolean;
    /**
    * Remove keyword
    * @this  Ajv
    * @param {string} keyword pre-defined or custom keyword.
    * @return {Ajv} this for method chaining
    */
    removeKeyword(keyword: string): Ajv;
    /**
    * Validate keyword
    * @this  Ajv
    * @param {object} definition keyword definition object
    * @param {boolean} throwError true to throw exception if definition is invalid
    * @return {boolean} validation result
    */
    validateKeyword(definition: KeywordDefinition, throwError: boolean): boolean;
    /**
    * Convert array of error message objects to string
    * @param  {Array<object>} errors optional array of validation errors, if not passed errors from the instance are used.
    * @param  {object} options optional options with properties `separator` and `dataVar`.
    * @return {string} human readable string with all errors descriptions
    */
    errorsText(errors?: Array<ErrorObject> | null, options?: ErrorsTextOptions): string;
    errors?: Array<ErrorObject> | null;
    _opts: Options;
  }

  interface CustomLogger {
    log(...args: any[]): any;
    warn(...args: any[]): any;
    error(...args: any[]): any;
  }

  interface ValidateFunction {
    (
      data: any,
      dataPath?: string,
      parentData?: object | Array<any>,
      parentDataProperty?: string | number,
      rootData?: object | Array<any>
    ): boolean | PromiseLike<any>;
    schema?: object | boolean;
    errors?: null | Array<ErrorObject>;
    refs?: object;
    refVal?: Array<any>;
    root?: ValidateFunction | object;
    $async?: true;
    source?: object;
  }

  interface Options {
    $data?: boolean;
    allErrors?: boolean;
    verbose?: boolean;
    jsonPointers?: boolean;
    uniqueItems?: boolean;
    unicode?: boolean;
    format?: false | string;
    formats?: object;
    keywords?: object;
    unknownFormats?: true | string[] | 'ignore';
    schemas?: Array<object> | object;
    schemaId?: '$id' | 'id' | 'auto';
    missingRefs?: true | 'ignore' | 'fail';
    extendRefs?: true | 'ignore' | 'fail';
    loadSchema?: (uri: string, cb?: (err: Error, schema: object) => void) => PromiseLike<object | boolean>;
    removeAdditional?: boolean | 'all' | 'failing';
    useDefaults?: boolean | 'empty' | 'shared';
    coerceTypes?: boolean | 'array';
    strictDefaults?: boolean | 'log';
    strictKeywords?: boolean | 'log';
    strictNumbers?: boolean;
    async?: boolean | string;
    transpile?: string | ((code: string) => string);
    meta?: boolean | object;
    validateSchema?: boolean | 'log';
    addUsedSchema?: boolean;
    inlineRefs?: boolean | number;
    passContext?: boolean;
    loopRequired?: number;
    ownProperties?: boolean;
    multipleOfPrecision?: boolean | number;
    errorDataPath?: string,
    messages?: boolean;
    sourceCode?: boolean;
    processCode?: (code: string, schema: object) => string;
    cache?: object;
    logger?: CustomLogger | false;
    nullable?: boolean;
    serialize?: ((schema: object | boolean) => any) | false;
  }

  type FormatValidator = string | RegExp | ((data: string) => boolean | PromiseLike<any>);
  type NumberFormatValidator = ((data: number) => boolean | PromiseLike<any>);

  interface NumberFormatDefinition {
    type: "number",
    validate: NumberFormatValidator;
    compare?: (data1: number, data2: number) => number;
    async?: boolean;
  }

  interface StringFormatDefinition {
    type?: "string",
    validate: FormatValidator;
    compare?: (data1: string, data2: string) => number;
    async?: boolean;
  }

  type FormatDefinition = NumberFormatDefinition | StringFormatDefinition;

  interface KeywordDefinition {
    type?: string | Array<string>;
    async?: boolean;
    $data?: boolean;
    errors?: boolean | string;
    metaSchema?: object;
    // schema: false makes validate not to expect schema (ValidateFunction)
    schema?: boolean;
    statements?: boolean;
    dependencies?: Array<string>;
    modifying?: boolean;
    valid?: boolean;
    // one and only one of the following properties should be present
    validate?: SchemaValidateFunction | ValidateFunction;
    compile?: (schema: any, parentSchema: object, it: CompilationContext) => ValidateFunction;
    macro?: (schema: any, parentSchema: object, it: CompilationContext) => object | boolean;
    inline?: (it: CompilationContext, keyword: string, schema: any, parentSchema: object) => string;
  }

  interface CompilationContext {
    level: number;
    dataLevel: number;
    dataPathArr: string[];
    schema: any;
    schemaPath: string;
    baseId: string;
    async: boolean;
    opts: Options;
    formats: {
      [index: string]: FormatDefinition | undefined;
    };
    keywords: {
      [index: string]: KeywordDefinition | undefined;
    };
    compositeRule: boolean;
    validate: (schema: object) => boolean;
    util: {
      copy(obj: any, target?: any): any;
      toHash(source: string[]): { [index: string]: true | undefined };
      equal(obj: any, target: any): boolean;
      getProperty(str: string): string;
      schemaHasRules(schema: object, rules: any): string;
      escapeQuotes(str: string): string;
      toQuotedString(str: string): string;
      getData(jsonPointer: string, dataLevel: number, paths: string[]): string;
      escapeJsonPointer(str: string): string;
      unescapeJsonPointer(str: string): string;
      escapeFragment(str: string): string;
      unescapeFragment(str: string): string;
    };
    self: Ajv;
  }

  interface SchemaValidateFunction {
    (
      schema: any,
      data: any,
      parentSchema?: object,
      dataPath?: string,
      parentData?: object | Array<any>,
      parentDataProperty?: string | number,
      rootData?: object | Array<any>
    ): boolean | PromiseLike<any>;
    errors?: Array<ErrorObject>;
  }

  interface ErrorsTextOptions {
    separator?: string;
    dataVar?: string;
  }

  interface ErrorObject {
    keyword: string;
    dataPath: string;
    schemaPath: string;
    params: ErrorParameters;
    // Added to validation errors of propertyNames keyword schema
    propertyName?: string;
    // Excluded if messages set to false.
    message?: string;
    // These are added with the `verbose` option.
    schema?: any;
    parentSchema?: object;
    data?: any;
  }

  type ErrorParameters = RefParams | LimitParams | AdditionalPropertiesParams |
    DependenciesParams | FormatParams | ComparisonParams |
    MultipleOfParams | PatternParams | RequiredParams |
    TypeParams | UniqueItemsParams | CustomParams |
    PatternRequiredParams | PropertyNamesParams |
    IfParams | SwitchParams | NoParams | EnumParams;

  interface RefParams {
    ref: string;
  }

  interface LimitParams {
    limit: number;
  }

  interface AdditionalPropertiesParams {
    additionalProperty: string;
  }

  interface DependenciesParams {
    property: string;
    missingProperty: string;
    depsCount: number;
    deps: string;
  }

  interface FormatParams {
    format: string
  }

  interface ComparisonParams {
    comparison: string;
    limit: number | string;
    exclusive: boolean;
  }

  interface MultipleOfParams {
    multipleOf: number;
  }

  interface PatternParams {
    pattern: string;
  }

  interface RequiredParams {
    missingProperty: string;
  }

  interface TypeParams {
    type: string;
  }

  interface UniqueItemsParams {
    i: number;
    j: number;
  }

  interface CustomParams {
    keyword: string;
  }

  interface PatternRequiredParams {
    missingPattern: string;
  }

  interface PropertyNamesParams {
    propertyName: string;
  }

  interface IfParams {
    failingKeyword: string;
  }

  interface SwitchParams {
    caseIndex: number;
  }

  interface NoParams { }

  interface EnumParams {
    allowedValues: Array<any>;
  }
}

export = ajv;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/compile/async.d.ts
export = compileAsync;
/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
declare function compileAsync(this: Ajv, schema: any, meta: boolean, callback: Function): Promise<any>;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/compile/equal.d.ts
declare const _exports: (a: any, b: any) => boolean;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/compile/error_classes.d.ts
export let Validation: any;
export let MissingRef: any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/compile/formats.d.ts
export = formats;
declare function formats(mode: any): any;
declare namespace formats {
    let fast: {
        date: RegExp;
        time: RegExp;
        'date-time': RegExp;
        uri: RegExp;
        'uri-reference': RegExp;
        'uri-template': RegExp;
        url: RegExp;
        email: RegExp;
        hostname: RegExp;
        ipv4: RegExp;
        ipv6: RegExp;
        regex: typeof regex;
        uuid: RegExp;
        'json-pointer': RegExp;
        'json-pointer-uri-fragment': RegExp;
        'relative-json-pointer': RegExp;
    };
    let full: {
        date: typeof date;
        time: typeof time;
        'date-time': typeof date_time;
        uri: typeof uri;
        'uri-reference': RegExp;
        'uri-template': RegExp;
        url: RegExp;
        email: RegExp;
        hostname: RegExp;
        ipv4: RegExp;
        ipv6: RegExp;
        regex: typeof regex;
        uuid: RegExp;
        'json-pointer': RegExp;
        'json-pointer-uri-fragment': RegExp;
        'relative-json-pointer': RegExp;
    };
}
declare function regex(str: any): boolean;
declare function date(str: any): boolean;
declare function time(str: any, full: any): any;
declare function date_time(str: any): any;
declare function uri(str: any): boolean;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/compile/index.d.ts
export = compile;
/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
declare function compile(this: Ajv, schema: any, root: any, localRefs: any, baseId: string): Function;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/compile/resolve.d.ts
export = resolve;
/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
declare function resolve(this: Ajv, compile: Function, root: any, ref: string): any | Function;
declare namespace resolve {
    export { normalizeId };
    export { getFullPath as fullPath };
    export { resolveUrl as url };
    export { resolveIds as ids };
    export { inlineRef };
    export { resolveSchema as schema };
}
declare function normalizeId(id: any): any;
declare function getFullPath(id: any, normalize: any): string;
declare function resolveUrl(baseId: any, id: any): string;
declare function resolveIds(schema: any): {};
declare function inlineRef(schema: any, limit: any): boolean;
/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
declare function resolveSchema(this: Ajv, root: any, ref: string): any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/compile/rules.d.ts
declare function _exports(): ({
    type: string;
    rules: (string | {
        maximum: string[];
        minimum?: undefined;
    } | {
        minimum: string[];
        maximum?: undefined;
    })[];
} | {
    type: string;
    rules: (string | {
        properties: string[];
    })[];
} | {
    rules: string[];
    type?: undefined;
})[];
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/compile/schema_obj.d.ts
export = SchemaObject;
declare function SchemaObject(obj: any): void;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/compile/ucs2length.d.ts
declare function _exports(str: any): number;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/compile/util.d.ts
export function copy(o: any, to: any): any;
export function checkDataType(dataType: any, data: any, strictNumbers: any, negate: any): string;
export function checkDataTypes(dataTypes: any, data: any, strictNumbers: any): string;
export function coerceToTypes(optionCoerceTypes: any, dataTypes: any): any[];
export function toHash(arr: any): {};
export function getProperty(key: any): string;
export function escapeQuotes(str: any): any;
export function varOccurences(str: any, dataVar: any): any;
export function varReplace(str: any, dataVar: any, expr: any): any;
export function schemaHasRules(schema: any, rules: any): boolean;
export function schemaHasRulesExcept(schema: any, rules: any, exceptKeyword: any): boolean;
export function schemaUnknownRules(schema: any, rules: any): string;
export function toQuotedString(str: any): string;
export function getPathExpr(currentPath: any, expr: any, jsonPointers: any, isNumber: any): any;
export function getPath(currentPath: any, prop: any, jsonPointers: any): any;
export function getData($data: any, lvl: any, paths: any): any;
export function unescapeFragment(str: any): any;
export function unescapeJsonPointer(str: any): any;
export function escapeFragment(str: any): string;
export function escapeJsonPointer(str: any): any;
export declare let equal: (a: any, b: any) => boolean;
export declare let ucs2length: (str: any) => number;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/data.d.ts
declare function _exports(metaSchema: any, keywordsJsonPointers: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/definition_schema.d.ts
export let $id: string;
export namespace definitions {
    let simpleTypes: any;
}
export let type: string;
export namespace dependencies {
    let schema: string[];
    let $data: string[];
    let statements: string[];
    namespace valid {
        namespace not {
            let required: string[];
        }
    }
}
export namespace properties {
    let type_1: any;
    export { type_1 as type };
    export namespace schema_1 {
        let type_2: string;
        export { type_2 as type };
    }
    export { schema_1 as schema };
    export namespace statements_1 {
        let type_3: string;
        export { type_3 as type };
    }
    export { statements_1 as statements };
    export namespace dependencies_1 {
        let type_4: string;
        export { type_4 as type };
        export namespace items {
            let type_5: string;
            export { type_5 as type };
        }
    }
    export { dependencies_1 as dependencies };
    export namespace metaSchema {
        let type_6: string;
        export { type_6 as type };
    }
    export namespace modifying {
        let type_7: string;
        export { type_7 as type };
    }
    export namespace valid_1 {
        let type_8: string;
        export { type_8 as type };
    }
    export { valid_1 as valid };
    export namespace $data_1 {
        let type_9: string;
        export { type_9 as type };
    }
    export { $data_1 as $data };
    export namespace async {
        let type_10: string;
        export { type_10 as type };
    }
    export namespace errors {
        let anyOf: ({
            type: string;
            const?: undefined;
        } | {
            const: string;
            type?: undefined;
        })[];
    }
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/_limit.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/_limitItems.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/_limitLength.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/_limitProperties.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/allOf.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/anyOf.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/comment.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/const.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/contains.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/custom.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/dependencies.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/enum.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/format.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/if.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/index.d.ts
export declare let $ref: (it: any, $keyword: any, $ruleType: any) => string;
export declare let allOf: (it: any, $keyword: any, $ruleType: any) => string;
export declare let anyOf: (it: any, $keyword: any, $ruleType: any) => string;
export declare let $comment: (it: any, $keyword: any, $ruleType: any) => string;
declare let _const: (it: any, $keyword: any, $ruleType: any) => string;
export declare let contains: (it: any, $keyword: any, $ruleType: any) => string;
export declare let dependencies: (it: any, $keyword: any, $ruleType: any) => string;
declare let _enum: (it: any, $keyword: any, $ruleType: any) => string;
export declare let format: (it: any, $keyword: any, $ruleType: any) => string;
declare let _if: (it: any, $keyword: any, $ruleType: any) => string;
export declare let items: (it: any, $keyword: any, $ruleType: any) => string;
export declare let maximum: (it: any, $keyword: any, $ruleType: any) => string;
export declare let minimum: (it: any, $keyword: any, $ruleType: any) => string;
export declare let maxItems: (it: any, $keyword: any, $ruleType: any) => string;
export declare let minItems: (it: any, $keyword: any, $ruleType: any) => string;
export declare let maxLength: (it: any, $keyword: any, $ruleType: any) => string;
export declare let minLength: (it: any, $keyword: any, $ruleType: any) => string;
export declare let maxProperties: (it: any, $keyword: any, $ruleType: any) => string;
export declare let minProperties: (it: any, $keyword: any, $ruleType: any) => string;
export declare let multipleOf: (it: any, $keyword: any, $ruleType: any) => string;
export declare let not: (it: any, $keyword: any, $ruleType: any) => string;
export declare let oneOf: (it: any, $keyword: any, $ruleType: any) => string;
export declare let pattern: (it: any, $keyword: any, $ruleType: any) => string;
export declare let properties: (it: any, $keyword: any, $ruleType: any) => string;
export declare let propertyNames: (it: any, $keyword: any, $ruleType: any) => string;
export declare let required: (it: any, $keyword: any, $ruleType: any) => string;
export declare let uniqueItems: (it: any, $keyword: any, $ruleType: any) => string;
export declare let validate: (it: any, $keyword: any, $ruleType: any) => string;
export { _const as const, _enum as enum, _if as if };

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/items.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/multipleOf.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/not.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/oneOf.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/pattern.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/properties.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/propertyNames.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/ref.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/required.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/uniqueItems.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/dotjs/validate.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/lib/keyword.d.ts
/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */
declare function addKeyword(this: Ajv, keyword: string, definition: any): Ajv;
/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
declare function getKeyword(this: Ajv, keyword: string): any | boolean;
/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
declare function removeKeyword(this: Ajv, keyword: string): Ajv;
/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
declare function validateKeyword(this: Ajv, definition: any, throwError: boolean): boolean;
declare class validateKeyword {
    /**
     * Validate keyword definition
     * @this  Ajv
     * @param {Object} definition keyword definition object.
     * @param {Boolean} throwError true to throw exception if definition is invalid
     * @return {boolean} validation result
     */
    constructor(this: Ajv, definition: any, throwError: boolean);
    _validateKeyword: any;
}
export { addKeyword as add, getKeyword as get, removeKeyword as remove, validateKeyword as validate };

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/scripts/bundle.d.ts
export {};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv/scripts/compile-dots.d.ts
export {};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/ajv-keywords.d.ts
declare module 'ajv-keywords' {
  import { Ajv } from 'ajv';

  function keywords(ajv: Ajv, include?: string | string[]): Ajv;

  export = keywords;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/index.d.ts
export = defineKeywords;
/**
 * Defines one or several keywords in ajv instance
 * @param  {Ajv} ajv validator instance
 * @param  {String|Array<String>|undefined} keyword keyword(s) to define
 * @return {Ajv} ajv instance (for chaining)
 */
declare function defineKeywords(ajv: Ajv, keyword: string | Array<string> | undefined): Ajv;
declare namespace defineKeywords {
    export { get };
}
declare function get(keyword: any): any;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/_formatLimit.d.ts
declare function _exports(minMax: any): (ajv: any) => any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/_util.d.ts
export function metaSchemaRef(ajv: any): {
    $ref: string;
} | {
    $ref?: undefined;
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/allRequired.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/anyRequired.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/deepProperties.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/deepRequired.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/dotjs/_formatLimit.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/dotjs/patternRequired.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/dotjs/switch.d.ts
declare function _exports(it: any, $keyword: any, $ruleType: any): string;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/dynamicDefaults.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/formatMaximum.d.ts
declare const _exports: (ajv: any) => any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/formatMinimum.d.ts
declare const _exports: (ajv: any) => any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/index.d.ts
declare let _instanceof: (ajv: any) => any;
export declare let range: (ajv: any) => any;
export declare let regexp: (ajv: any) => any;
declare let _typeof: (ajv: any) => any;
export declare let dynamicDefaults: (ajv: any) => any;
export declare let allRequired: (ajv: any) => any;
export declare let anyRequired: (ajv: any) => any;
export declare let oneRequired: (ajv: any) => any;
export declare let prohibited: (ajv: any) => any;
export declare let uniqueItemProperties: (ajv: any) => any;
export declare let deepProperties: (ajv: any) => any;
export declare let deepRequired: (ajv: any) => any;
export declare let formatMinimum: (ajv: any) => any;
export declare let formatMaximum: (ajv: any) => any;
export declare let patternRequired: (ajv: any) => any;
declare let _switch: (ajv: any) => any;
export declare let select: (ajv: any) => any;
export declare let transform: (ajv: any) => any;
export { _instanceof as instanceof, _typeof as typeof, _switch as switch };

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/instanceof.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/oneRequired.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/patternRequired.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/prohibited.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/range.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/regexp.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/select.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/switch.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/transform.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/typeof.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/ajv-keywords/keywords/uniqueItemProperties.d.ts
declare function _exports(ajv: any): any;
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/json-schema-traverse/index.d.ts
declare function _exports(schema: any, opts: any, cb: any): void;
declare namespace _exports {
    namespace keywords {
        let additionalItems: boolean;
        let items: boolean;
        let contains: boolean;
        let additionalProperties: boolean;
        let propertyNames: boolean;
        let not: boolean;
    }
    namespace arrayKeywords {
        let items_1: boolean;
        export { items_1 as items };
        export let allOf: boolean;
        export let anyOf: boolean;
        export let oneOf: boolean;
    }
    namespace propsKeywords {
        let definitions: boolean;
        let properties: boolean;
        let patternProperties: boolean;
        let dependencies: boolean;
    }
    namespace skipKeywords {
        let _default: boolean;
        export { _default as default };
        let _enum: boolean;
        export { _enum as enum };
        let _const: boolean;
        export { _const as const };
        export let required: boolean;
        export let maximum: boolean;
        export let minimum: boolean;
        export let exclusiveMaximum: boolean;
        export let exclusiveMinimum: boolean;
        export let multipleOf: boolean;
        export let maxLength: boolean;
        export let minLength: boolean;
        export let pattern: boolean;
        export let format: boolean;
        export let maxItems: boolean;
        export let minItems: boolean;
        export let uniqueItems: boolean;
        export let maxProperties: boolean;
        export let minProperties: boolean;
    }
}
export = _exports;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/json-schema-traverse/spec/fixtures/schema.d.ts
export namespace schema {
    export namespace additionalItems {
        export let properties: {};
        export let additionalProperties: boolean;
        let additionalItems_1: boolean;
        export { additionalItems_1 as additionalItems };
        export let anyOf: {
            format: string;
        }[];
    }
    export namespace items { }
    export namespace contains { }
    export namespace additionalProperties_1 { }
    export { additionalProperties_1 as additionalProperties };
    export namespace propertyNames { }
    export namespace not { }
    export let allOf: ({
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    } | {
        items: {
            properties: {};
            additionalProperties: boolean;
            additionalItems: boolean;
            anyOf: {
                format: string;
            }[];
        }[];
    })[];
    let anyOf_1: {
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    }[];
    export { anyOf_1 as anyOf };
    export let oneOf: {
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    }[];
    export namespace definitions {
        namespace foo { }
        namespace bar { }
    }
    export namespace properties_1 {
        export namespace foo_1 { }
        export { foo_1 as foo };
        export namespace bar_1 { }
        export { bar_1 as bar };
    }
    export { properties_1 as properties };
    export namespace patternProperties {
        export namespace foo_2 { }
        export { foo_2 as foo };
        export namespace bar_2 { }
        export { bar_2 as bar };
    }
    export namespace dependencies {
        export namespace foo_3 { }
        export { foo_3 as foo };
        export namespace bar_3 { }
        export { bar_3 as bar };
    }
    export let required: string[];
}
export declare let expectedCalls: (string | {
    additionalItems: {
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    };
    items: {
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    };
    contains: {
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    };
    additionalProperties: {
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    };
    propertyNames: {
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    };
    not: {
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    };
    allOf: ({
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    } | {
        items: {
            properties: {};
            additionalProperties: boolean;
            additionalItems: boolean;
            anyOf: {
                format: string;
            }[];
        }[];
    })[];
    anyOf: {
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    }[];
    oneOf: {
        properties: {};
        additionalProperties: boolean;
        additionalItems: boolean;
        anyOf: {
            format: string;
        }[];
    }[];
    definitions: {
        foo: {
            properties: {};
            additionalProperties: boolean;
            additionalItems: boolean;
            anyOf: {
                format: string;
            }[];
        };
        bar: {
            properties: {};
            additionalProperties: boolean;
            additionalItems: boolean;
            anyOf: {
                format: string;
            }[];
        };
    };
    properties: {
        foo: {
            properties: {};
            additionalProperties: boolean;
            additionalItems: boolean;
            anyOf: {
                format: string;
            }[];
        };
        bar: {
            properties: {};
            additionalProperties: boolean;
            additionalItems: boolean;
            anyOf: {
                format: string;
            }[];
        };
    };
    patternProperties: {
        foo: {
            properties: {};
            additionalProperties: boolean;
            additionalItems: boolean;
            anyOf: {
                format: string;
            }[];
        };
        bar: {
            properties: {};
            additionalProperties: boolean;
            additionalItems: boolean;
            anyOf: {
                format: string;
            }[];
        };
    };
    dependencies: {
        foo: {
            properties: {};
            additionalProperties: boolean;
            additionalItems: boolean;
            anyOf: {
                format: string;
            }[];
        };
        bar: {
            properties: {};
            additionalProperties: boolean;
            additionalItems: boolean;
            anyOf: {
                format: string;
            }[];
        };
    };
    required: string[];
})[][];

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/json-schema-traverse/spec/index.spec.d.ts
export {};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/declarations/ValidationError.d.ts
export default ValidationError;
export type JSONSchema6 = import("json-schema").JSONSchema6;
export type JSONSchema7 = import("json-schema").JSONSchema7;
export type Schema = import("./validate").Schema;
export type ValidationErrorConfiguration =
  import("./validate").ValidationErrorConfiguration;
export type PostFormatter = import("./validate").PostFormatter;
export type SchemaUtilErrorObject = import("./validate").SchemaUtilErrorObject;
declare class ValidationError extends Error {
  /**
   * @param {Array<SchemaUtilErrorObject>} errors
   * @param {Schema} schema
   * @param {ValidationErrorConfiguration} configuration
   */
  constructor(
    errors: Array<SchemaUtilErrorObject>,
    schema: Schema,
    configuration?: ValidationErrorConfiguration
  );
  /** @type {Array<SchemaUtilErrorObject>} */
  errors: Array<SchemaUtilErrorObject>;
  /** @type {Schema} */
  schema: Schema;
  /** @type {string} */
  headerName: string;
  /** @type {string} */
  baseDataPath: string;
  /** @type {PostFormatter | null} */
  postFormatter: PostFormatter | null;
  /**
   * @param {string} path
   * @returns {Schema}
   */
  getSchemaPart(path: string): Schema;
  /**
   * @param {Schema} schema
   * @param {boolean} logic
   * @param {Array<Object>} prevSchemas
   * @returns {string}
   */
  formatSchema(
    schema: Schema,
    logic?: boolean,
    prevSchemas?: Array<Object>
  ): string;
  /**
   * @param {Schema=} schemaPart
   * @param {(boolean | Array<string>)=} additionalPath
   * @param {boolean=} needDot
   * @param {boolean=} logic
   * @returns {string}
   */
  getSchemaPartText(
    schemaPart?: Schema | undefined,
    additionalPath?: (boolean | Array<string>) | undefined,
    needDot?: boolean | undefined,
    logic?: boolean | undefined
  ): string;
  /**
   * @param {Schema=} schemaPart
   * @returns {string}
   */
  getSchemaPartDescription(schemaPart?: Schema | undefined): string;
  /**
   * @param {SchemaUtilErrorObject} error
   * @returns {string}
   */
  formatValidationError(error: SchemaUtilErrorObject): string;
  /**
   * @param {Array<SchemaUtilErrorObject>} errors
   * @returns {string}
   */
  formatValidationErrors(errors: Array<SchemaUtilErrorObject>): string;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/declarations/index.d.ts
import { validate } from "./validate";
import { ValidationError } from "./validate";
import { enableValidation } from "./validate";
import { disableValidation } from "./validate";
import { needValidate } from "./validate";
export {
  validate,
  ValidationError,
  enableValidation,
  disableValidation,
  needValidate,
};

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/declarations/keywords/absolutePath.d.ts
export default addAbsolutePathKeyword;
export type Ajv = import("ajv").Ajv;
export type ValidateFunction = import("ajv").ValidateFunction;
export type SchemaUtilErrorObject = import("../validate").SchemaUtilErrorObject;
/**
 *
 * @param {Ajv} ajv
 * @returns {Ajv}
 */
declare function addAbsolutePathKeyword(ajv: Ajv): Ajv;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/declarations/keywords/undefinedAsNull.d.ts
export default addUndefinedAsNullKeyword;
export type Ajv = import("ajv").Ajv;
/**
 *
 * @param {Ajv} ajv
 * @returns {Ajv}
 */
declare function addUndefinedAsNullKeyword(ajv: Ajv): Ajv;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/declarations/util/Range.d.ts
export = Range;
/**
 * @typedef {[number, boolean]} RangeValue
 */
/**
 * @callback RangeValueCallback
 * @param {RangeValue} rangeValue
 * @returns {boolean}
 */
declare class Range {
  /**
   * @param {"left" | "right"} side
   * @param {boolean} exclusive
   * @returns {">" | ">=" | "<" | "<="}
   */
  static getOperator(
    side: "left" | "right",
    exclusive: boolean
  ): ">" | ">=" | "<" | "<=";
  /**
   * @param {number} value
   * @param {boolean} logic is not logic applied
   * @param {boolean} exclusive is range exclusive
   * @returns {string}
   */
  static formatRight(value: number, logic: boolean, exclusive: boolean): string;
  /**
   * @param {number} value
   * @param {boolean} logic is not logic applied
   * @param {boolean} exclusive is range exclusive
   * @returns {string}
   */
  static formatLeft(value: number, logic: boolean, exclusive: boolean): string;
  /**
   * @param {number} start left side value
   * @param {number} end right side value
   * @param {boolean} startExclusive is range exclusive from left side
   * @param {boolean} endExclusive is range exclusive from right side
   * @param {boolean} logic is not logic applied
   * @returns {string}
   */
  static formatRange(
    start: number,
    end: number,
    startExclusive: boolean,
    endExclusive: boolean,
    logic: boolean
  ): string;
  /**
   * @param {Array<RangeValue>} values
   * @param {boolean} logic is not logic applied
   * @return {RangeValue} computed value and it's exclusive flag
   */
  static getRangeValue(values: Array<RangeValue>, logic: boolean): RangeValue;
  /** @type {Array<RangeValue>} */
  _left: Array<RangeValue>;
  /** @type {Array<RangeValue>} */
  _right: Array<RangeValue>;
  /**
   * @param {number} value
   * @param {boolean=} exclusive
   */
  left(value: number, exclusive?: boolean | undefined): void;
  /**
   * @param {number} value
   * @param {boolean=} exclusive
   */
  right(value: number, exclusive?: boolean | undefined): void;
  /**
   * @param {boolean} logic is not logic applied
   * @return {string} "smart" range string representation
   */
  format(logic?: boolean): string;
}
declare namespace Range {
  export { RangeValue, RangeValueCallback };
}
type RangeValue = [number, boolean];
type RangeValueCallback = (rangeValue: RangeValue) => boolean;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/declarations/util/hints.d.ts
export function stringHints(schema: Schema, logic: boolean): string[];
export function numberHints(schema: Schema, logic: boolean): string[];
export type Schema = import("../validate").Schema;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/declarations/validate.d.ts
export type JSONSchema4 = import("json-schema").JSONSchema4;
export type JSONSchema6 = import("json-schema").JSONSchema6;
export type JSONSchema7 = import("json-schema").JSONSchema7;
export type ErrorObject = import("ajv").ErrorObject;
export type ValidateFunction = import("ajv").ValidateFunction;
export type Extend = {
  formatMinimum?: number | undefined;
  formatMaximum?: number | undefined;
  formatExclusiveMinimum?: boolean | undefined;
  formatExclusiveMaximum?: boolean | undefined;
  link?: string | undefined;
  undefinedAsNull?: boolean | undefined;
};
export type Schema = (JSONSchema4 | JSONSchema6 | JSONSchema7) & Extend;
export type SchemaUtilErrorObject = ErrorObject & {
  children?: Array<ErrorObject>;
};
export type PostFormatter = (
  formattedError: string,
  error: SchemaUtilErrorObject
) => string;
export type ValidationErrorConfiguration = {
  name?: string | undefined;
  baseDataPath?: string | undefined;
  postFormatter?: PostFormatter | undefined;
};
/**
 * @param {Schema} schema
 * @param {Array<object> | object} options
 * @param {ValidationErrorConfiguration=} configuration
 * @returns {void}
 */
export function validate(
  schema: Schema,
  options: Array<object> | object,
  configuration?: ValidationErrorConfiguration | undefined
): void;
export function enableValidation(): void;
export function disableValidation(): void;
export function needValidate(): boolean;
import ValidationError from "./ValidationError";
export { ValidationError };

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/dist/ValidationError.d.ts
export const __esModule: boolean;
export default _default;
export type JSONSchema6 = import("json-schema").JSONSchema6;
export type JSONSchema7 = import("json-schema").JSONSchema7;
export type Schema = import("./validate").Schema;
export type ValidationErrorConfiguration = import("./validate").ValidationErrorConfiguration;
export type PostFormatter = import("./validate").PostFormatter;
export type SchemaUtilErrorObject = import("./validate").SchemaUtilErrorObject;
declare var _default: typeof ValidationError;
declare class ValidationError extends Error {
    /**
     * @param {Array<SchemaUtilErrorObject>} errors
     * @param {Schema} schema
     * @param {ValidationErrorConfiguration} configuration
     */
    constructor(errors: Array<SchemaUtilErrorObject>, schema: Schema, configuration?: ValidationErrorConfiguration);
    /** @type {Array<SchemaUtilErrorObject>} */
    errors: Array<SchemaUtilErrorObject>;
    /** @type {Schema} */
    schema: Schema;
    /** @type {string} */
    headerName: string;
    /** @type {string} */
    baseDataPath: string;
    /** @type {PostFormatter | null} */
    postFormatter: PostFormatter | null;
    /**
     * @param {string} path
     * @returns {Schema}
     */
    getSchemaPart(path: string): Schema;
    /**
     * @param {Schema} schema
     * @param {boolean} logic
     * @param {Array<Object>} prevSchemas
     * @returns {string}
     */
    formatSchema(schema: Schema, logic?: boolean, prevSchemas?: Array<any>): string;
    /**
     * @param {Schema=} schemaPart
     * @param {(boolean | Array<string>)=} additionalPath
     * @param {boolean=} needDot
     * @param {boolean=} logic
     * @returns {string}
     */
    getSchemaPartText(schemaPart?: Schema | undefined, additionalPath?: (boolean | Array<string>) | undefined, needDot?: boolean | undefined, logic?: boolean | undefined): string;
    /**
     * @param {Schema=} schemaPart
     * @returns {string}
     */
    getSchemaPartDescription(schemaPart?: Schema | undefined): string;
    /**
     * @param {SchemaUtilErrorObject} error
     * @returns {string}
     */
    formatValidationError(error: SchemaUtilErrorObject): string;
    /**
     * @param {Array<SchemaUtilErrorObject>} errors
     * @returns {string}
     */
    formatValidationErrors(errors: Array<SchemaUtilErrorObject>): string;
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/dist/index.d.ts
import { validate } from "./validate";
import { ValidationError } from "./validate";
import { enableValidation } from "./validate";
import { disableValidation } from "./validate";
import { needValidate } from "./validate";
export { validate, ValidationError, enableValidation, disableValidation, needValidate };

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/dist/keywords/absolutePath.d.ts
export const __esModule: boolean;
export default _default;
export type Ajv = import("ajv").Ajv;
export type ValidateFunction = import("ajv").ValidateFunction;
export type SchemaUtilErrorObject = import("../validate").SchemaUtilErrorObject;
/**
 *
 * @param {Ajv} ajv
 * @returns {Ajv}
 */
declare function _default(ajv: Ajv): Ajv;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/dist/keywords/undefinedAsNull.d.ts
export const __esModule: boolean;
export default _default;
export type Ajv = import("ajv").Ajv;
/**
 *
 * @param {Ajv} ajv
 * @returns {Ajv}
 */
declare function _default(ajv: Ajv): Ajv;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/dist/util/Range.d.ts
export = Range;
/**
 * @typedef {[number, boolean]} RangeValue
 */
/**
 * @callback RangeValueCallback
 * @param {RangeValue} rangeValue
 * @returns {boolean}
 */
declare class Range {
    /**
     * @param {"left" | "right"} side
     * @param {boolean} exclusive
     * @returns {">" | ">=" | "<" | "<="}
     */
    static getOperator(side: "left" | "right", exclusive: boolean): ">" | ">=" | "<" | "<=";
    /**
     * @param {number} value
     * @param {boolean} logic is not logic applied
     * @param {boolean} exclusive is range exclusive
     * @returns {string}
     */
    static formatRight(value: number, logic: boolean, exclusive: boolean): string;
    /**
     * @param {number} value
     * @param {boolean} logic is not logic applied
     * @param {boolean} exclusive is range exclusive
     * @returns {string}
     */
    static formatLeft(value: number, logic: boolean, exclusive: boolean): string;
    /**
     * @param {number} start left side value
     * @param {number} end right side value
     * @param {boolean} startExclusive is range exclusive from left side
     * @param {boolean} endExclusive is range exclusive from right side
     * @param {boolean} logic is not logic applied
     * @returns {string}
     */
    static formatRange(start: number, end: number, startExclusive: boolean, endExclusive: boolean, logic: boolean): string;
    /**
     * @param {Array<RangeValue>} values
     * @param {boolean} logic is not logic applied
     * @return {RangeValue} computed value and it's exclusive flag
     */
    static getRangeValue(values: Array<RangeValue>, logic: boolean): RangeValue;
    /** @type {Array<RangeValue>} */
    _left: Array<RangeValue>;
    /** @type {Array<RangeValue>} */
    _right: Array<RangeValue>;
    /**
     * @param {number} value
     * @param {boolean=} exclusive
     */
    left(value: number, exclusive?: boolean | undefined): void;
    /**
     * @param {number} value
     * @param {boolean=} exclusive
     */
    right(value: number, exclusive?: boolean | undefined): void;
    /**
     * @param {boolean} logic is not logic applied
     * @return {string} "smart" range string representation
     */
    format(logic?: boolean): string;
}
declare namespace Range {
    export { RangeValue, RangeValueCallback };
}
type RangeValue = [number, boolean];
type RangeValueCallback = (rangeValue: RangeValue) => boolean;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/dist/util/hints.d.ts
export function stringHints(schema: Schema, logic: boolean): string[];
export function numberHints(schema: Schema, logic: boolean): string[];
export type Schema = import("../validate").Schema;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/node_modules/schema-utils/dist/validate.d.ts
export const __esModule: boolean;
export const ValidationError: any;
export type JSONSchema4 = import("json-schema").JSONSchema4;
export type JSONSchema6 = import("json-schema").JSONSchema6;
export type JSONSchema7 = import("json-schema").JSONSchema7;
export type ErrorObject = import("ajv").ErrorObject;
export type ValidateFunction = import("ajv").ValidateFunction;
export type Extend = {
    formatMinimum?: number | undefined;
    formatMaximum?: number | undefined;
    formatExclusiveMinimum?: boolean | undefined;
    formatExclusiveMaximum?: boolean | undefined;
    link?: string | undefined;
    undefinedAsNull?: boolean | undefined;
};
export type Schema = (JSONSchema4 | JSONSchema6 | JSONSchema7) & Extend;
export type SchemaUtilErrorObject = ErrorObject & {
    children?: Array<ErrorObject>;
};
export type PostFormatter = (formattedError: string, error: SchemaUtilErrorObject) => string;
export type ValidationErrorConfiguration = {
    name?: string | undefined;
    baseDataPath?: string | undefined;
    postFormatter?: PostFormatter | undefined;
};
/**
 * @param {Schema} schema
 * @param {Array<object> | object} options
 * @param {ValidationErrorConfiguration=} configuration
 * @returns {void}
 */
export function validate(schema: Schema, options: Array<object> | object, configuration?: ValidationErrorConfiguration | undefined): void;
export function enableValidation(): void;
export function disableValidation(): void;
export function needValidate(): boolean;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/WebpackOptions.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../declarations/WebpackOptions").WebpackOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/BannerPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../declarations/plugins/BannerPlugin").BannerPluginArgument) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/DllPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../declarations/plugins/DllPlugin").DllPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/DllReferencePlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../declarations/plugins/DllReferencePlugin").DllReferencePluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/HashedModuleIdsPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../declarations/plugins/HashedModuleIdsPlugin").HashedModuleIdsPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/IgnorePlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../declarations/plugins/IgnorePlugin").IgnorePluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/JsonModulesPluginParser.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../declarations/plugins/JsonModulesPluginParser").JsonModulesPluginParserOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/LoaderOptionsPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../declarations/plugins/LoaderOptionsPlugin").LoaderOptionsPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/ProgressPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../declarations/plugins/ProgressPlugin").ProgressPluginArgument) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/SourceMapDevToolPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../declarations/plugins/SourceMapDevToolPlugin").SourceMapDevToolPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/WatchIgnorePlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../declarations/plugins/WatchIgnorePlugin").WatchIgnorePluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/asset/AssetGeneratorOptions.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: any) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/asset/AssetInlineGeneratorOptions.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: any) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/asset/AssetParserOptions.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: any) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/asset/AssetResourceGeneratorOptions.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: any) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/container/ContainerPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/container/ContainerPlugin").ContainerPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/container/ContainerReferencePlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/container/ContainerReferencePlugin").ContainerReferencePluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/container/ExternalsType.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: any) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/container/ModuleFederationPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/container/ModuleFederationPlugin").ModuleFederationPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/css/CssGeneratorOptions.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: any) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/css/CssParserOptions.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: any) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/debug/ProfilingPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/debug/ProfilingPlugin").ProfilingPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/ids/OccurrenceChunkIdsPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/ids/OccurrenceChunkIdsPlugin").OccurrenceChunkIdsPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/ids/OccurrenceModuleIdsPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/ids/OccurrenceModuleIdsPlugin").OccurrenceModuleIdsPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/optimize/AggressiveSplittingPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/optimize/AggressiveSplittingPlugin").AggressiveSplittingPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/optimize/LimitChunkCountPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/optimize/LimitChunkCountPlugin").LimitChunkCountPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/optimize/MinChunkSizePlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/optimize/MinChunkSizePlugin").MinChunkSizePluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/schemes/HttpUriPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/schemes/HttpUriPlugin").HttpUriPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/sharing/ConsumeSharedPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/sharing/ConsumeSharedPlugin").ConsumeSharedPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/sharing/ProvideSharedPlugin.check.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
declare const check: (options: import("../../../declarations/plugins/sharing/ProvideSharedPlugin").ProvideSharedPluginOptions) => boolean;
export = check;

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas/plugins/sharing/SharePlugin.check.d.ts
export = a;
declare function a(r: any, { instancePath: e, parentData: t, parentDataProperty: n, rootData: o }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): boolean;
declare namespace a {
    export { a as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/WebpackOptions.check.d.ts
export = we;
declare function we(r: any, { instancePath: o, parentData: i, parentDataProperty: a, rootData: l }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): boolean;
declare namespace we {
    export { we as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/BannerPlugin.check.d.ts
export = t;
declare function t(l: any, { instancePath: e, parentData: s, parentDataProperty: a, rootData: r }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace t {
    export { t as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/DllPlugin.check.d.ts
export = r;
declare function r(e: any, { instancePath: t, parentData: o, parentDataProperty: n, rootData: a }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/DllReferencePlugin.check.d.ts
export = e;
declare function e(n: any, { instancePath: l, parentData: o, parentDataProperty: r, rootData: i }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace e {
    export { e as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/HashedModuleIdsPlugin.check.d.ts
export = e;
declare function e(r: any, { instancePath: s, parentData: n, parentDataProperty: a, rootData: i }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace e {
    export { e as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/IgnorePlugin.check.d.ts
export = e;
declare function e(s: any, { instancePath: o, parentData: r, parentDataProperty: t, rootData: n }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace e {
    export { e as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/JsonModulesPluginParser.check.d.ts
export = r;
declare function r(t: any, { instancePath: e, parentData: a, parentDataProperty: o, rootData: n }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/LoaderOptionsPlugin.check.d.ts
export = e;
declare function e(t: any, { instancePath: o, parentData: a, parentDataProperty: i, rootData: n }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace e {
    export { e as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/ProgressPlugin.check.d.ts
export = t;
declare function t(e: any, { instancePath: r, parentData: o, parentDataProperty: s, rootData: a }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): boolean;
declare namespace t {
    export { t as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/SourceMapDevToolPlugin.check.d.ts
export = l;
declare function l(r: any, { instancePath: o, parentData: a, parentDataProperty: i, rootData: u }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): boolean;
declare namespace l {
    export { l as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/WatchIgnorePlugin.check.d.ts
export = r;
declare function r(t: any, { instancePath: e, parentData: s, parentDataProperty: a, rootData: n }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/asset/AssetGeneratorOptions.check.d.ts
export = e;
declare function e(t: any, { instancePath: n, parentData: a, parentDataProperty: s, rootData: o }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace e {
    export { e as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/asset/AssetInlineGeneratorOptions.check.d.ts
export = a;
declare function a(t: any, { instancePath: n, parentData: e, parentDataProperty: o, rootData: s }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace a {
    export { a as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/asset/AssetParserOptions.check.d.ts
export = r;
declare function r(a: any, { instancePath: n, parentData: o, parentDataProperty: e, rootData: s }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/asset/AssetResourceGeneratorOptions.check.d.ts
export = r;
declare function r(t: any, { instancePath: e, parentData: s, parentDataProperty: a, rootData: o }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/container/ContainerPlugin.check.d.ts
export = l;
declare function l(t: any, { instancePath: e, parentData: n, parentDataProperty: a, rootData: o }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace l {
    export { l as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/container/ContainerReferencePlugin.check.d.ts
export = n;
declare function n(r: any, { instancePath: t, parentData: e, parentDataProperty: o, rootData: s }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace n {
    export { n as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/container/ExternalsType.check.d.ts
export = o;
declare function o(r: any, { instancePath: s, parentData: m, parentDataProperty: t, rootData: e }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace o {
    export { o as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/container/ModuleFederationPlugin.check.d.ts
export = D;
declare function D(n: any, { instancePath: s, parentData: a, parentDataProperty: i, rootData: l }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): boolean;
declare namespace D {
    export { D as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/css/CssGeneratorOptions.check.d.ts
export = r;
declare function r(t: any, { instancePath: e, parentData: a, parentDataProperty: o, rootData: n }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/css/CssParserOptions.check.d.ts
export = r;
declare function r(t: any, { instancePath: e, parentData: a, parentDataProperty: o, rootData: n }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/debug/ProfilingPlugin.check.d.ts
export = t;
declare function t(e: any, { instancePath: a, parentData: o, parentDataProperty: n, rootData: s }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace t {
    export { t as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/ids/OccurrenceChunkIdsPlugin.check.d.ts
export = r;
declare function r(t: any, { instancePath: e, parentData: o, parentDataProperty: a, rootData: i }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/ids/OccurrenceModuleIdsPlugin.check.d.ts
export = r;
declare function r(t: any, { instancePath: e, parentData: o, parentDataProperty: a, rootData: i }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/optimize/AggressiveSplittingPlugin.check.d.ts
export = r;
declare function r(e: any, { instancePath: t, parentData: n, parentDataProperty: i, rootData: o }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/optimize/LimitChunkCountPlugin.check.d.ts
export = r;
declare function r(e: any, { instancePath: t, parentData: n, parentDataProperty: a, rootData: o }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/optimize/MinChunkSizePlugin.check.d.ts
export = r;
declare function r(e: any, { instancePath: t, parentData: n, parentDataProperty: i, rootData: o }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace r {
    export { r as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/schemes/HttpUriPlugin.check.d.ts
export = n;
declare function n(r: any, { instancePath: t, parentData: o, parentDataProperty: s, rootData: a }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): boolean;
declare namespace n {
    export { n as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/sharing/ConsumeSharedPlugin.check.d.ts
export = n;
declare function n(r: any, { instancePath: e, parentData: s, parentDataProperty: a, rootData: o }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace n {
    export { n as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/sharing/ProvideSharedPlugin.check.d.ts
export = e;
declare function e(r: any, { instancePath: s, parentData: n, parentDataProperty: a, rootData: o }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): any;
declare namespace e {
    export { e as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/schemas copy/plugins/sharing/SharePlugin.check.d.ts
export = a;
declare function a(r: any, { instancePath: e, parentData: t, parentDataProperty: n, rootData: o }?: {
    instancePath?: string;
    parentData: any;
    parentDataProperty: any;
    rootData?: any;
}): boolean;
declare namespace a {
    export { a as default };
}

// /Users/zackjackson/lulu_dev/universe/node_modules/webpack/types.d.ts
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

import { Buffer } from "buffer";
import {
	ArrayExpression,
	ArrayPattern,
	ArrowFunctionExpression,
	AssignmentExpression,
	AssignmentPattern,
	AssignmentProperty,
	AwaitExpression,
	BigIntLiteral,
	BinaryExpression,
	BlockStatement,
	BreakStatement,
	CatchClause,
	ChainExpression,
	ClassBody,
	ClassDeclaration,
	ClassExpression,
	Comment,
	ConditionalExpression,
	ContinueStatement,
	DebuggerStatement,
	Directive,
	DoWhileStatement,
	EmptyStatement,
	ExportAllDeclaration,
	ExportDefaultDeclaration,
	ExportNamedDeclaration,
	ExportSpecifier,
	ExpressionStatement,
	ForInStatement,
	ForOfStatement,
	ForStatement,
	FunctionDeclaration,
	FunctionExpression,
	Identifier,
	IfStatement,
	ImportDeclaration,
	ImportDefaultSpecifier,
	ImportExpression,
	ImportNamespaceSpecifier,
	ImportSpecifier,
	LabeledStatement,
	LogicalExpression,
	MemberExpression,
	MetaProperty,
	MethodDefinition,
	NewExpression,
	ObjectExpression,
	ObjectPattern,
	PrivateIdentifier,
	Program,
	Property,
	PropertyDefinition,
	RegExpLiteral,
	RestElement,
	ReturnStatement,
	SequenceExpression,
	SimpleCallExpression,
	SimpleLiteral,
	SpreadElement,
	StaticBlock,
	Super,
	SwitchCase,
	SwitchStatement,
	TaggedTemplateExpression,
	TemplateElement,
	TemplateLiteral,
	ThisExpression,
	ThrowStatement,
	TryStatement,
	UnaryExpression,
	UpdateExpression,
	VariableDeclaration,
	VariableDeclarator,
	WhileStatement,
	WithStatement,
	YieldExpression
} from "estree";
import { Dirent } from "fs";
import {
	IncomingMessage,
	ServerOptions as ServerOptionsImport,
	ServerResponse
} from "http";
import { ListenOptions, Server } from "net";
import { validate as validateFunction } from "schema-utils";
import { default as ValidationError } from "schema-utils/declarations/ValidationError";
import { ValidationErrorConfiguration } from "schema-utils/declarations/validate";
import {
	AsArray,
	AsyncParallelHook,
	AsyncSeriesBailHook,
	AsyncSeriesHook,
	AsyncSeriesWaterfallHook,
	HookMap,
	MultiHook,
	SyncBailHook,
	SyncHook,
	SyncWaterfallHook
} from "tapable";
import { SecureContextOptions, TlsOptions } from "tls";

declare class AbstractLibraryPlugin<T> {
	constructor(__0: {
		/**
		 * name of the plugin
		 */
		pluginName: string;
		/**
		 * used library type
		 */
		type: string;
	});

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	parseOptions(library: LibraryOptions): false | T;
	finishEntryModule(
		module: Module,
		entryName: string,
		libraryContext: LibraryContext<T>
	): void;
	embedInRuntimeBailout(
		module: Module,
		renderContext: RenderContext,
		libraryContext: LibraryContext<T>
	): undefined | string;
	strictRuntimeBailout(
		renderContext: RenderContext,
		libraryContext: LibraryContext<T>
	): undefined | string;
	runtimeRequirements(
		chunk: Chunk,
		set: Set<string>,
		libraryContext: LibraryContext<T>
	): void;
	render(
		source: Source,
		renderContext: RenderContext,
		libraryContext: LibraryContext<T>
	): Source;
	renderStartup(
		source: Source,
		module: Module,
		renderContext: StartupRenderContext,
		libraryContext: LibraryContext<T>
	): Source;
	chunkHash(
		chunk: Chunk,
		hash: Hash,
		chunkHashContext: ChunkHashContext,
		libraryContext: LibraryContext<T>
	): void;
	static COMMON_LIBRARY_NAME_MESSAGE: string;
}
declare interface AdditionalData {
	[index: string]: any;
	webpackAST: object;
}
declare class AggressiveMergingPlugin {
	constructor(options?: AggressiveMergingPluginOptions);
	options: AggressiveMergingPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface AggressiveMergingPluginOptions {
	/**
	 * minimal size reduction to trigger merging
	 */
	minSizeReduce?: number;
}
declare class AggressiveSplittingPlugin {
	constructor(options?: AggressiveSplittingPluginOptions);
	options: AggressiveSplittingPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static wasChunkRecorded(chunk: Chunk): boolean;
}
declare interface AggressiveSplittingPluginOptions {
	/**
	 * Extra cost for each chunk (Default: 9.8kiB).
	 */
	chunkOverhead?: number;

	/**
	 * Extra cost multiplicator for entry chunks (Default: 10).
	 */
	entryChunkMultiplicator?: number;

	/**
	 * Byte, max size of per file (Default: 50kiB).
	 */
	maxSize?: number;

	/**
	 * Byte, split point. (Default: 30kiB).
	 */
	minSize?: number;
}
type Alias = string | false | string[];
declare interface AliasOption {
	alias: Alias;
	name: string;
	onlyModule?: boolean;
}
type AliasOptionNewRequest = string | false | string[];
declare interface AliasOptions {
	[index: string]: AliasOptionNewRequest;
}
declare interface Argument {
	description: string;
	simpleType: "string" | "number" | "boolean";
	multiple: boolean;
	configs: ArgumentConfig[];
}
declare interface ArgumentConfig {
	description: string;
	negatedDescription?: string;
	path: string;
	multiple: boolean;
	type: "string" | "number" | "boolean" | "path" | "enum" | "RegExp" | "reset";
	values?: any[];
}
declare interface Assertions {
	[index: string]: any;
}
declare interface Asset {
	/**
	 * the filename of the asset
	 */
	name: string;

	/**
	 * source of the asset
	 */
	source: Source;

	/**
	 * info about the asset
	 */
	info: AssetInfo;
}
declare interface AssetEmittedInfo {
	content: Buffer;
	source: Source;
	compilation: Compilation;
	outputPath: string;
	targetPath: string;
}
type AssetFilterItemTypes =
	| string
	| RegExp
	| ((name: string, asset: StatsAsset) => boolean);

/**
 * Options object for data url generation.
 */
declare interface AssetGeneratorDataUrlOptions {
	/**
	 * Asset encoding (defaults to base64).
	 */
	encoding?: false | "base64";

	/**
	 * Asset mimetype (getting from file extension by default).
	 */
	mimetype?: string;
}
type AssetGeneratorOptions = AssetInlineGeneratorOptions &
	AssetResourceGeneratorOptions;
type AssetInfo = KnownAssetInfo & Record<string, any>;

/**
 * Generator options for asset/inline modules.
 */
declare interface AssetInlineGeneratorOptions {
	/**
	 * The options for data url generator.
	 */
	dataUrl?:
		| AssetGeneratorDataUrlOptions
		| ((
				source: string | Buffer,
				context: { filename: string; module: Module }
		  ) => string);
}

/**
 * Options object for DataUrl condition.
 */
declare interface AssetParserDataUrlOptions {
	/**
	 * Maximum size of asset that should be inline as modules. Default: 8kb.
	 */
	maxSize?: number;
}

/**
 * Parser options for asset modules.
 */
declare interface AssetParserOptions {
	/**
	 * The condition for inlining the asset as DataUrl.
	 */
	dataUrlCondition?:
		| AssetParserDataUrlOptions
		| ((
				source: string | Buffer,
				context: { filename: string; module: Module }
		  ) => boolean);
}

/**
 * Generator options for asset/resource modules.
 */
declare interface AssetResourceGeneratorOptions {
	/**
	 * Emit an output asset from this asset module. This can be set to 'false' to omit emitting e. g. for SSR.
	 */
	emit?: boolean;

	/**
	 * Specifies the filename template of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Emit the asset in the specified folder relative to 'output.path'. This should only be needed when custom 'publicPath' is specified to match the folder structure there.
	 */
	outputPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);
}
declare class AsyncDependenciesBlock extends DependenciesBlock {
	constructor(
		groupOptions:
			| null
			| (RawChunkGroupOptions & { name?: string } & {
					entryOptions?: EntryOptions;
			  }),
		loc?: null | SyntheticDependencyLocation | RealDependencyLocation,
		request?: null | string
	);
	groupOptions: RawChunkGroupOptions & { name?: string } & {
		entryOptions?: EntryOptions;
	};
	loc?: null | SyntheticDependencyLocation | RealDependencyLocation;
	request?: null | string;
	chunkName?: string;
	module: any;
}
declare abstract class AsyncQueue<T, K, R> {
	hooks: {
		beforeAdd: AsyncSeriesHook<[T]>;
		added: SyncHook<[T]>;
		beforeStart: AsyncSeriesHook<[T]>;
		started: SyncHook<[T]>;
		result: SyncHook<[T, Error, R]>;
	};
	add(item: T, callback: CallbackAsyncQueue<R>): void;
	invalidate(item: T): void;

	/**
	 * Waits for an already started item
	 */
	waitFor(item: T, callback: CallbackAsyncQueue<R>): void;
	stop(): void;
	increaseParallelism(): void;
	decreaseParallelism(): void;
	isProcessing(item: T): boolean;
	isQueued(item: T): boolean;
	isDone(item: T): boolean;
	clear(): void;
}
declare class AsyncWebAssemblyModulesPlugin {
	constructor(options: AsyncWebAssemblyModulesPluginOptions);
	options: AsyncWebAssemblyModulesPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	renderModule(
		module: Module,
		renderContext: WebAssemblyRenderContext,
		hooks: CompilationHooksAsyncWebAssemblyModulesPlugin
	): Source;
	static getCompilationHooks(
		compilation: Compilation
	): CompilationHooksAsyncWebAssemblyModulesPlugin;
}
declare interface AsyncWebAssemblyModulesPluginOptions {
	/**
	 * mangle imports
	 */
	mangleImports?: boolean;
}
declare class AutomaticPrefetchPlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type AuxiliaryComment = string | LibraryCustomUmdCommentObject;
declare interface BackendApi {
	dispose: (arg0?: Error) => void;
	module: (arg0: Module) => { client: string; data: string; active: boolean };
}
declare class BannerPlugin {
	constructor(options: BannerPluginArgument);
	options: BannerPluginOptions;
	banner: (data: { hash: string; chunk: Chunk; filename: string }) => string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type BannerPluginArgument =
	| string
	| BannerPluginOptions
	| ((data: { hash: string; chunk: Chunk; filename: string }) => string);
declare interface BannerPluginOptions {
	/**
	 * Specifies the banner.
	 */
	banner:
		| string
		| ((data: { hash: string; chunk: Chunk; filename: string }) => string);

	/**
	 * If true, the banner will only be added to the entry chunks.
	 */
	entryOnly?: boolean;

	/**
	 * Exclude all modules matching any of these conditions.
	 */
	exclude?: string | RegExp | Rule[];

	/**
	 * If true, banner will be placed at the end of the output.
	 */
	footer?: boolean;

	/**
	 * Include all modules matching any of these conditions.
	 */
	include?: string | RegExp | Rule[];

	/**
	 * If true, banner will not be wrapped in a comment.
	 */
	raw?: boolean;

	/**
	 * Include all modules that pass test assertion.
	 */
	test?: string | RegExp | Rule[];
}
declare interface BaseResolveRequest {
	path: string | false;
	context?: object;
	descriptionFilePath?: string;
	descriptionFileRoot?: string;
	descriptionFileData?: JsonObject;
	relativePath?: string;
	ignoreSymlinks?: boolean;
	fullySpecified?: boolean;
	__innerRequest?: string;
	__innerRequest_request?: string;
	__innerRequest_relativePath?: string;
}
declare abstract class BasicEvaluatedExpression {
	type: number;
	range?: [number, number];
	falsy: boolean;
	truthy: boolean;
	nullish?: boolean;
	sideEffects: boolean;
	bool?: boolean;
	number?: number;
	bigint?: bigint;
	regExp?: RegExp;
	string?: string;
	quasis?: BasicEvaluatedExpression[];
	parts?: BasicEvaluatedExpression[];
	array?: any[];
	items?: BasicEvaluatedExpression[];
	options?: BasicEvaluatedExpression[];
	prefix?: null | BasicEvaluatedExpression;
	postfix?: null | BasicEvaluatedExpression;
	wrappedInnerExpressions?: BasicEvaluatedExpression[];
	identifier?: string | VariableInfoInterface;
	rootInfo?: string | VariableInfoInterface;
	getMembers?: () => string[];
	getMembersOptionals?: () => boolean[];
	getMemberRanges?: () => [number, number][];
	expression?:
		| UnaryExpression
		| ArrayExpression
		| ArrowFunctionExpression
		| AssignmentExpression
		| AwaitExpression
		| BinaryExpression
		| SimpleCallExpression
		| NewExpression
		| ChainExpression
		| ClassExpression
		| ConditionalExpression
		| FunctionExpression
		| Identifier
		| ImportExpression
		| SimpleLiteral
		| RegExpLiteral
		| BigIntLiteral
		| LogicalExpression
		| MemberExpression
		| MetaProperty
		| ObjectExpression
		| SequenceExpression
		| TaggedTemplateExpression
		| TemplateLiteral
		| ThisExpression
		| UpdateExpression
		| YieldExpression
		| FunctionDeclaration
		| VariableDeclaration
		| ClassDeclaration
		| PrivateIdentifier
		| ExpressionStatement
		| BlockStatement
		| StaticBlock
		| EmptyStatement
		| DebuggerStatement
		| WithStatement
		| ReturnStatement
		| LabeledStatement
		| BreakStatement
		| ContinueStatement
		| IfStatement
		| SwitchStatement
		| ThrowStatement
		| TryStatement
		| WhileStatement
		| DoWhileStatement
		| ForStatement
		| ForInStatement
		| ForOfStatement
		| ImportDeclaration
		| ExportNamedDeclaration
		| ExportDefaultDeclaration
		| ExportAllDeclaration
		| MethodDefinition
		| PropertyDefinition
		| VariableDeclarator
		| Program
		| SwitchCase
		| CatchClause
		| ObjectPattern
		| ArrayPattern
		| RestElement
		| AssignmentPattern
		| SpreadElement
		| Property
		| AssignmentProperty
		| ClassBody
		| ImportSpecifier
		| ImportDefaultSpecifier
		| ImportNamespaceSpecifier
		| ExportSpecifier
		| Super
		| TemplateElement;
	isUnknown(): boolean;
	isNull(): boolean;
	isUndefined(): boolean;
	isString(): boolean;
	isNumber(): boolean;
	isBigInt(): boolean;
	isBoolean(): boolean;
	isRegExp(): boolean;
	isConditional(): boolean;
	isArray(): boolean;
	isConstArray(): boolean;
	isIdentifier(): boolean;
	isWrapped(): boolean;
	isTemplateString(): boolean;

	/**
	 * Is expression a primitive or an object type value?
	 */
	isPrimitiveType(): undefined | boolean;

	/**
	 * Is expression a runtime or compile-time value?
	 */
	isCompileTimeValue(): boolean;

	/**
	 * Gets the compile-time value of the expression
	 */
	asCompileTimeValue(): any;
	isTruthy(): boolean;
	isFalsy(): boolean;
	isNullish(): undefined | boolean;

	/**
	 * Can this expression have side effects?
	 */
	couldHaveSideEffects(): boolean;

	/**
	 * Creates a boolean representation of this evaluated expression.
	 */
	asBool(): undefined | boolean;

	/**
	 * Creates a nullish coalescing representation of this evaluated expression.
	 */
	asNullish(): undefined | boolean;

	/**
	 * Creates a string representation of this evaluated expression.
	 */
	asString(): undefined | string;
	setString(string: string): BasicEvaluatedExpression;
	setUndefined(): BasicEvaluatedExpression;
	setNull(): BasicEvaluatedExpression;

	/**
	 * Set's the value of this expression to a number
	 */
	setNumber(number: number): BasicEvaluatedExpression;

	/**
	 * Set's the value of this expression to a BigInt
	 */
	setBigInt(bigint: bigint): BasicEvaluatedExpression;

	/**
	 * Set's the value of this expression to a boolean
	 */
	setBoolean(bool: boolean): BasicEvaluatedExpression;

	/**
	 * Set's the value of this expression to a regular expression
	 */
	setRegExp(regExp: RegExp): BasicEvaluatedExpression;

	/**
	 * Set's the value of this expression to a particular identifier and its members.
	 */
	setIdentifier(
		identifier: string | VariableInfoInterface,
		rootInfo: string | VariableInfoInterface,
		getMembers: () => string[],
		getMembersOptionals?: () => boolean[],
		getMemberRanges?: () => [number, number][]
	): BasicEvaluatedExpression;

	/**
	 * Wraps an array of expressions with a prefix and postfix expression.
	 */
	setWrapped(
		prefix: undefined | null | BasicEvaluatedExpression,
		postfix: undefined | null | BasicEvaluatedExpression,
		innerExpressions: BasicEvaluatedExpression[]
	): BasicEvaluatedExpression;

	/**
	 * Stores the options of a conditional expression.
	 */
	setOptions(options: BasicEvaluatedExpression[]): BasicEvaluatedExpression;

	/**
	 * Adds options to a conditional expression.
	 */
	addOptions(options: BasicEvaluatedExpression[]): BasicEvaluatedExpression;

	/**
	 * Set's the value of this expression to an array of expressions.
	 */
	setItems(items: BasicEvaluatedExpression[]): BasicEvaluatedExpression;

	/**
	 * Set's the value of this expression to an array of strings.
	 */
	setArray(array: string[]): BasicEvaluatedExpression;

	/**
	 * Set's the value of this expression to a processed/unprocessed template string. Used
	 * for evaluating TemplateLiteral expressions in the JavaScript Parser.
	 */
	setTemplateString(
		quasis: BasicEvaluatedExpression[],
		parts: BasicEvaluatedExpression[],
		kind: "raw" | "cooked"
	): BasicEvaluatedExpression;
	templateStringKind?: "raw" | "cooked";
	setTruthy(): BasicEvaluatedExpression;
	setFalsy(): BasicEvaluatedExpression;

	/**
	 * Set's the value of the expression to nullish.
	 */
	setNullish(value: boolean): BasicEvaluatedExpression;

	/**
	 * Set's the range for the expression.
	 */
	setRange(range: [number, number]): BasicEvaluatedExpression;

	/**
	 * Set whether or not the expression has side effects.
	 */
	setSideEffects(sideEffects?: boolean): BasicEvaluatedExpression;

	/**
	 * Set the expression node for the expression.
	 */
	setExpression(
		expression?:
			| UnaryExpression
			| ArrayExpression
			| ArrowFunctionExpression
			| AssignmentExpression
			| AwaitExpression
			| BinaryExpression
			| SimpleCallExpression
			| NewExpression
			| ChainExpression
			| ClassExpression
			| ConditionalExpression
			| FunctionExpression
			| Identifier
			| ImportExpression
			| SimpleLiteral
			| RegExpLiteral
			| BigIntLiteral
			| LogicalExpression
			| MemberExpression
			| MetaProperty
			| ObjectExpression
			| SequenceExpression
			| TaggedTemplateExpression
			| TemplateLiteral
			| ThisExpression
			| UpdateExpression
			| YieldExpression
			| FunctionDeclaration
			| VariableDeclaration
			| ClassDeclaration
			| PrivateIdentifier
			| ExpressionStatement
			| BlockStatement
			| StaticBlock
			| EmptyStatement
			| DebuggerStatement
			| WithStatement
			| ReturnStatement
			| LabeledStatement
			| BreakStatement
			| ContinueStatement
			| IfStatement
			| SwitchStatement
			| ThrowStatement
			| TryStatement
			| WhileStatement
			| DoWhileStatement
			| ForStatement
			| ForInStatement
			| ForOfStatement
			| ImportDeclaration
			| ExportNamedDeclaration
			| ExportDefaultDeclaration
			| ExportAllDeclaration
			| MethodDefinition
			| PropertyDefinition
			| VariableDeclarator
			| Program
			| SwitchCase
			| CatchClause
			| ObjectPattern
			| ArrayPattern
			| RestElement
			| AssignmentPattern
			| SpreadElement
			| Property
			| AssignmentProperty
			| ClassBody
			| ImportSpecifier
			| ImportDefaultSpecifier
			| ImportNamespaceSpecifier
			| ExportSpecifier
			| Super
			| TemplateElement
	): BasicEvaluatedExpression;
}
declare interface BuildInfo {
	[index: string]: any;
}
type BuildMeta = KnownBuildMeta & Record<string, any>;
declare abstract class ByTypeGenerator extends Generator {
	map: Record<string, Generator>;
}
declare const CIRCULAR_CONNECTION: unique symbol;
declare class Cache {
	constructor();
	hooks: {
		get: AsyncSeriesBailHook<
			[
				string,
				null | Etag,
				((result: any, callback: (arg0?: Error) => void) => void)[]
			],
			any
		>;
		store: AsyncParallelHook<[string, null | Etag, any]>;
		storeBuildDependencies: AsyncParallelHook<[Iterable<string>]>;
		beginIdle: SyncHook<[]>;
		endIdle: AsyncParallelHook<[]>;
		shutdown: AsyncParallelHook<[]>;
	};
	get<T>(
		identifier: string,
		etag: null | Etag,
		callback: CallbackCache<T>
	): void;
	store<T>(
		identifier: string,
		etag: null | Etag,
		data: T,
		callback: CallbackCache<void>
	): void;

	/**
	 * After this method has succeeded the cache can only be restored when build dependencies are
	 */
	storeBuildDependencies(
		dependencies: Iterable<string>,
		callback: CallbackCache<void>
	): void;
	beginIdle(): void;
	endIdle(callback: CallbackCache<void>): void;
	shutdown(callback: CallbackCache<void>): void;
	static STAGE_MEMORY: number;
	static STAGE_DEFAULT: number;
	static STAGE_DISK: number;
	static STAGE_NETWORK: number;
}
declare abstract class CacheFacade {
	getChildCache(name: string): CacheFacade;
	getItemCache(identifier: string, etag: null | Etag): ItemCacheFacade;
	getLazyHashedEtag(obj: HashableObject): Etag;
	mergeEtags(a: Etag, b: Etag): Etag;
	get<T>(
		identifier: string,
		etag: null | Etag,
		callback: CallbackCache<T>
	): void;
	getPromise<T>(identifier: string, etag: null | Etag): Promise<T>;
	store<T>(
		identifier: string,
		etag: null | Etag,
		data: T,
		callback: CallbackCache<void>
	): void;
	storePromise<T>(
		identifier: string,
		etag: null | Etag,
		data: T
	): Promise<void>;
	provide<T>(
		identifier: string,
		etag: null | Etag,
		computer: (arg0: CallbackNormalErrorCache<T>) => void,
		callback: CallbackNormalErrorCache<T>
	): void;
	providePromise<T>(
		identifier: string,
		etag: null | Etag,
		computer: () => T | Promise<T>
	): Promise<T>;
}
declare interface CacheGroupSource {
	key?: string;
	priority?: number;
	getName?: (
		module?: Module,
		chunks?: Chunk[],
		key?: string
	) => undefined | string;
	chunksFilter?: (chunk: Chunk) => undefined | boolean;
	enforce?: boolean;
	minSize: SplitChunksSizes;
	minSizeReduction: SplitChunksSizes;
	minRemainingSize: SplitChunksSizes;
	enforceSizeThreshold: SplitChunksSizes;
	maxAsyncSize: SplitChunksSizes;
	maxInitialSize: SplitChunksSizes;
	minChunks?: number;
	maxAsyncRequests?: number;
	maxInitialRequests?: number;
	filename?: string | ((arg0: PathData, arg1?: AssetInfo) => string);
	idHint?: string;
	automaticNameDelimiter?: string;
	reuseExistingChunk?: boolean;
	usedExports?: boolean;
}
declare interface CacheGroupsContext {
	moduleGraph: ModuleGraph;
	chunkGraph: ChunkGraph;
}
type CacheOptionsNormalized = false | FileCacheOptions | MemoryCacheOptions;
declare class CachedSource extends Source {
	constructor(source: Source);
	constructor(source: Source | (() => Source), cachedData?: any);
	original(): Source;
	originalLazy(): Source | (() => Source);
	getCachedData(): any;
}
type CallExpression = SimpleCallExpression | NewExpression;
declare interface CallExpressionInfo {
	type: "call";
	call: CallExpression;
	calleeName: string;
	rootInfo: string | VariableInfo;
	getCalleeMembers: () => string[];
	name: string;
	getMembers: () => string[];
	getMembersOptionals: () => boolean[];
	getMemberRanges: () => [number, number][];
}
declare interface CallbackAsyncQueue<T> {
	(err?: null | WebpackError, result?: T): any;
}
declare interface CallbackCache<T> {
	(err?: null | WebpackError, result?: T): void;
}
declare interface CallbackFunction<T> {
	(err?: null | Error, result?: T): any;
}
declare interface CallbackNormalErrorCache<T> {
	(err?: null | Error, result?: T): void;
}
declare interface CallbackWebpack<T> {
	(err?: Error, stats?: T): void;
}
type Cell<T> = undefined | T;
declare class Chunk {
	constructor(name?: string, backCompat?: boolean);
	id: null | string | number;
	ids: null | ChunkId[];
	debugId: number;
	name?: string;
	idNameHints: SortableSet<string>;
	preventIntegration: boolean;
	filenameTemplate?: string | ((arg0: PathData, arg1?: AssetInfo) => string);
	cssFilenameTemplate?: string | ((arg0: PathData, arg1?: AssetInfo) => string);
	runtime: RuntimeSpec;
	files: Set<string>;
	auxiliaryFiles: Set<string>;
	rendered: boolean;
	hash?: string;
	contentHash: Record<string, string>;
	renderedHash?: string;
	chunkReason?: string;
	extraAsync: boolean;
	get entryModule(): Module;
	hasEntryModule(): boolean;
	addModule(module: Module): boolean;
	removeModule(module: Module): void;
	getNumberOfModules(): number;
	get modulesIterable(): Iterable<Module>;
	compareTo(otherChunk: Chunk): 0 | 1 | -1;
	containsModule(module: Module): boolean;
	getModules(): Module[];
	remove(): void;
	moveModule(module: Module, otherChunk: Chunk): void;
	integrate(otherChunk: Chunk): boolean;
	canBeIntegrated(otherChunk: Chunk): boolean;
	isEmpty(): boolean;
	modulesSize(): number;
	size(options?: ChunkSizeOptions): number;
	integratedSize(otherChunk: Chunk, options: ChunkSizeOptions): number;
	getChunkModuleMaps(filterFn: (m: Module) => boolean): ChunkModuleMaps;
	hasModuleInGraph(
		filterFn: (m: Module) => boolean,
		filterChunkFn?: (c: Chunk, chunkGraph: ChunkGraph) => boolean
	): boolean;
	getChunkMaps(realHash: boolean): ChunkMaps;
	hasRuntime(): boolean;
	canBeInitial(): boolean;
	isOnlyInitial(): boolean;
	getEntryOptions(): undefined | EntryOptions;
	addGroup(chunkGroup: ChunkGroup): void;
	removeGroup(chunkGroup: ChunkGroup): void;
	isInGroup(chunkGroup: ChunkGroup): boolean;
	getNumberOfGroups(): number;
	get groupsIterable(): SortableSet<ChunkGroup>;
	disconnectFromGroups(): void;
	split(newChunk: Chunk): void;
	updateHash(hash: Hash, chunkGraph: ChunkGraph): void;
	getAllAsyncChunks(): Set<Chunk>;
	getAllInitialChunks(): Set<Chunk>;
	getAllReferencedChunks(): Set<Chunk>;
	getAllReferencedAsyncEntrypoints(): Set<Entrypoint>;
	hasAsyncChunks(): boolean;
	getChildIdsByOrders(
		chunkGraph: ChunkGraph,
		filterFn?: (c: Chunk, chunkGraph: ChunkGraph) => boolean
	): Record<string, (string | number)[]>;
	getChildrenOfTypeInOrder(
		chunkGraph: ChunkGraph,
		type: string
	): undefined | { onChunks: Chunk[]; chunks: Set<Chunk> }[];
	getChildIdsByOrdersMap(
		chunkGraph: ChunkGraph,
		includeDirectChildren?: boolean,
		filterFn?: (c: Chunk, chunkGraph: ChunkGraph) => boolean
	): Record<string | number, Record<string, (string | number)[]>>;
}
declare class ChunkGraph {
	constructor(moduleGraph: ModuleGraph, hashFunction?: string | typeof Hash);
	moduleGraph: ModuleGraph;
	connectChunkAndModule(chunk: Chunk, module: Module): void;
	disconnectChunkAndModule(chunk: Chunk, module: Module): void;
	disconnectChunk(chunk: Chunk): void;
	attachModules(chunk: Chunk, modules: Iterable<Module>): void;
	attachRuntimeModules(chunk: Chunk, modules: Iterable<RuntimeModule>): void;
	attachFullHashModules(chunk: Chunk, modules: Iterable<RuntimeModule>): void;
	attachDependentHashModules(
		chunk: Chunk,
		modules: Iterable<RuntimeModule>
	): void;
	replaceModule(oldModule: Module, newModule: Module): void;
	isModuleInChunk(module: Module, chunk: Chunk): boolean;
	isModuleInChunkGroup(module: Module, chunkGroup: ChunkGroup): boolean;
	isEntryModule(module: Module): boolean;
	getModuleChunksIterable(module: Module): Iterable<Chunk>;
	getOrderedModuleChunksIterable(
		module: Module,
		sortFn: (arg0: Chunk, arg1: Chunk) => 0 | 1 | -1
	): Iterable<Chunk>;
	getModuleChunks(module: Module): Chunk[];
	getNumberOfModuleChunks(module: Module): number;
	getModuleRuntimes(module: Module): RuntimeSpecSet;
	getNumberOfChunkModules(chunk: Chunk): number;
	getNumberOfChunkFullHashModules(chunk: Chunk): number;
	getChunkModulesIterable(chunk: Chunk): Iterable<Module>;
	getChunkModulesIterableBySourceType(
		chunk: Chunk,
		sourceType: string
	): undefined | Iterable<Module>;
	setChunkModuleSourceTypes(
		chunk: Chunk,
		module: Module,
		sourceTypes: Set<string>
	): void;
	getChunkModuleSourceTypes(chunk: Chunk, module: Module): Set<string>;
	getModuleSourceTypes(module: Module): Set<string>;
	getOrderedChunkModulesIterable(
		chunk: Chunk,
		comparator: (arg0: Module, arg1: Module) => 0 | 1 | -1
	): Iterable<Module>;
	getOrderedChunkModulesIterableBySourceType(
		chunk: Chunk,
		sourceType: string,
		comparator: (arg0: Module, arg1: Module) => 0 | 1 | -1
	): undefined | Iterable<Module>;
	getChunkModules(chunk: Chunk): Module[];
	getOrderedChunkModules(
		chunk: Chunk,
		comparator: (arg0: Module, arg1: Module) => 0 | 1 | -1
	): Module[];
	getChunkModuleIdMap(
		chunk: Chunk,
		filterFn: (m: Module) => boolean,
		includeAllChunks?: boolean
	): Record<string | number, (string | number)[]>;
	getChunkModuleRenderedHashMap(
		chunk: Chunk,
		filterFn: (m: Module) => boolean,
		hashLength?: number,
		includeAllChunks?: boolean
	): Record<string | number, Record<string | number, string>>;
	getChunkConditionMap(
		chunk: Chunk,
		filterFn: (c: Chunk, chunkGraph: ChunkGraph) => boolean
	): Record<string | number, boolean>;
	hasModuleInGraph(
		chunk: Chunk,
		filterFn: (m: Module) => boolean,
		filterChunkFn?: (c: Chunk, chunkGraph: ChunkGraph) => boolean
	): boolean;
	compareChunks(chunkA: Chunk, chunkB: Chunk): 0 | 1 | -1;
	getChunkModulesSize(chunk: Chunk): number;
	getChunkModulesSizes(chunk: Chunk): Record<string, number>;
	getChunkRootModules(chunk: Chunk): Module[];
	getChunkSize(chunk: Chunk, options?: ChunkSizeOptions): number;
	getIntegratedChunksSize(
		chunkA: Chunk,
		chunkB: Chunk,
		options?: ChunkSizeOptions
	): number;
	canChunksBeIntegrated(chunkA: Chunk, chunkB: Chunk): boolean;
	integrateChunks(chunkA: Chunk, chunkB: Chunk): void;
	upgradeDependentToFullHashModules(chunk: Chunk): void;
	isEntryModuleInChunk(module: Module, chunk: Chunk): boolean;
	connectChunkAndEntryModule(
		chunk: Chunk,
		module: Module,
		entrypoint?: Entrypoint
	): void;
	connectChunkAndRuntimeModule(chunk: Chunk, module: RuntimeModule): void;
	addFullHashModuleToChunk(chunk: Chunk, module: RuntimeModule): void;
	addDependentHashModuleToChunk(chunk: Chunk, module: RuntimeModule): void;
	disconnectChunkAndEntryModule(chunk: Chunk, module: Module): void;
	disconnectChunkAndRuntimeModule(chunk: Chunk, module: RuntimeModule): void;
	disconnectEntryModule(module: Module): void;
	disconnectEntries(chunk: Chunk): void;
	getNumberOfEntryModules(chunk: Chunk): number;
	getNumberOfRuntimeModules(chunk: Chunk): number;
	getChunkEntryModulesIterable(chunk: Chunk): Iterable<Module>;
	getChunkEntryDependentChunksIterable(chunk: Chunk): Iterable<Chunk>;
	hasChunkEntryDependentChunks(chunk: Chunk): boolean;
	getChunkRuntimeModulesIterable(chunk: Chunk): Iterable<RuntimeModule>;
	getChunkRuntimeModulesInOrder(chunk: Chunk): RuntimeModule[];
	getChunkFullHashModulesIterable(
		chunk: Chunk
	): undefined | Iterable<RuntimeModule>;
	getChunkFullHashModulesSet(
		chunk: Chunk
	): undefined | ReadonlySet<RuntimeModule>;
	getChunkDependentHashModulesIterable(
		chunk: Chunk
	): undefined | Iterable<RuntimeModule>;
	getChunkEntryModulesWithChunkGroupIterable(
		chunk: Chunk
	): Iterable<[Module, undefined | Entrypoint]>;
	getBlockChunkGroup(depBlock: AsyncDependenciesBlock): ChunkGroup;
	connectBlockAndChunkGroup(
		depBlock: AsyncDependenciesBlock,
		chunkGroup: ChunkGroup
	): void;
	disconnectChunkGroup(chunkGroup: ChunkGroup): void;
	getModuleId(module: Module): string | number;
	setModuleId(module: Module, id: string | number): void;
	getRuntimeId(runtime: string): string | number;
	setRuntimeId(runtime: string, id: string | number): void;
	hasModuleHashes(module: Module, runtime: RuntimeSpec): boolean;
	getModuleHash(module: Module, runtime: RuntimeSpec): string;
	getRenderedModuleHash(module: Module, runtime: RuntimeSpec): string;
	setModuleHashes(
		module: Module,
		runtime: RuntimeSpec,
		hash: string,
		renderedHash: string
	): void;
	addModuleRuntimeRequirements(
		module: Module,
		runtime: RuntimeSpec,
		items: Set<string>,
		transferOwnership?: boolean
	): void;
	addChunkRuntimeRequirements(chunk: Chunk, items: Set<string>): void;
	addTreeRuntimeRequirements(chunk: Chunk, items: Iterable<string>): void;
	getModuleRuntimeRequirements(
		module: Module,
		runtime: RuntimeSpec
	): ReadonlySet<string>;
	getChunkRuntimeRequirements(chunk: Chunk): ReadonlySet<string>;
	getModuleGraphHash(
		module: Module,
		runtime: RuntimeSpec,
		withConnections?: boolean
	): string;
	getModuleGraphHashBigInt(
		module: Module,
		runtime: RuntimeSpec,
		withConnections?: boolean
	): bigint;
	getTreeRuntimeRequirements(chunk: Chunk): ReadonlySet<string>;
	static getChunkGraphForModule(
		module: Module,
		deprecateMessage: string,
		deprecationCode: string
	): ChunkGraph;
	static setChunkGraphForModule(module: Module, chunkGraph: ChunkGraph): void;
	static clearChunkGraphForModule(module: Module): void;
	static getChunkGraphForChunk(
		chunk: Chunk,
		deprecateMessage: string,
		deprecationCode: string
	): ChunkGraph;
	static setChunkGraphForChunk(chunk: Chunk, chunkGraph: ChunkGraph): void;
	static clearChunkGraphForChunk(chunk: Chunk): void;
}
declare abstract class ChunkGroup {
	groupDebugId: number;
	options: ChunkGroupOptions;
	chunks: Chunk[];
	origins: OriginRecord[];
	index?: number;

	/**
	 * when a new chunk is added to a chunkGroup, addingOptions will occur.
	 */
	addOptions(options: ChunkGroupOptions): void;

	/**
	 * returns the name of current ChunkGroup
	 * sets a new name for current ChunkGroup
	 */
	name?: string;

	/**
	 * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's
	 */
	get debugId(): string;

	/**
	 * get a unique id for ChunkGroup, made up of its member Chunk id's
	 */
	get id(): string;

	/**
	 * Performs an unshift of a specific chunk
	 */
	unshiftChunk(chunk: Chunk): boolean;

	/**
	 * inserts a chunk before another existing chunk in group
	 */
	insertChunk(chunk: Chunk, before: Chunk): boolean;

	/**
	 * add a chunk into ChunkGroup. Is pushed on or prepended
	 */
	pushChunk(chunk: Chunk): boolean;
	replaceChunk(oldChunk: Chunk, newChunk: Chunk): boolean;
	removeChunk(chunk: Chunk): boolean;
	isInitial(): boolean;
	addChild(group: ChunkGroup): boolean;
	getChildren(): ChunkGroup[];
	getNumberOfChildren(): number;
	get childrenIterable(): SortableSet<ChunkGroup>;
	removeChild(group: ChunkGroup): boolean;
	addParent(parentChunk: ChunkGroup): boolean;
	getParents(): ChunkGroup[];
	getNumberOfParents(): number;
	hasParent(parent: ChunkGroup): boolean;
	get parentsIterable(): SortableSet<ChunkGroup>;
	removeParent(chunkGroup: ChunkGroup): boolean;
	addAsyncEntrypoint(entrypoint: Entrypoint): boolean;
	get asyncEntrypointsIterable(): SortableSet<ChunkGroup>;
	getBlocks(): AsyncDependenciesBlock[];
	getNumberOfBlocks(): number;
	hasBlock(block: AsyncDependenciesBlock): boolean;
	get blocksIterable(): Iterable<AsyncDependenciesBlock>;
	addBlock(block: AsyncDependenciesBlock): boolean;
	addOrigin(module: Module, loc: DependencyLocation, request: string): void;
	getFiles(): string[];
	remove(): void;
	sortItems(): void;

	/**
	 * Sorting predicate which allows current ChunkGroup to be compared against another.
	 * Sorting values are based off of number of chunks in ChunkGroup.
	 */
	compareTo(chunkGraph: ChunkGraph, otherGroup: ChunkGroup): 0 | 1 | -1;
	getChildrenByOrders(
		moduleGraph: ModuleGraph,
		chunkGraph: ChunkGraph
	): Record<string, ChunkGroup[]>;

	/**
	 * Sets the top-down index of a module in this ChunkGroup
	 */
	setModulePreOrderIndex(module: Module, index: number): void;

	/**
	 * Gets the top-down index of a module in this ChunkGroup
	 */
	getModulePreOrderIndex(module: Module): undefined | number;

	/**
	 * Sets the bottom-up index of a module in this ChunkGroup
	 */
	setModulePostOrderIndex(module: Module, index: number): void;

	/**
	 * Gets the bottom-up index of a module in this ChunkGroup
	 */
	getModulePostOrderIndex(module: Module): undefined | number;
	checkConstraints(): void;
	getModuleIndex: (module: Module) => undefined | number;
	getModuleIndex2: (module: Module) => undefined | number;
}
type ChunkGroupOptions = RawChunkGroupOptions & { name?: string };
declare interface ChunkHashContext {
	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;
}
type ChunkId = string | number;
declare interface ChunkMaps {
	hash: Record<string | number, string>;
	contentHash: Record<string | number, Record<string, string>>;
	name: Record<string | number, string>;
}
declare class ChunkModuleIdRangePlugin {
	constructor(options: ChunkModuleIdRangePluginOptions);
	options: ChunkModuleIdRangePluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ChunkModuleIdRangePluginOptions {
	/**
	 * the chunk name
	 */
	name: string;

	/**
	 * order
	 */
	order?: "index" | "index2" | "preOrderIndex" | "postOrderIndex";

	/**
	 * start id
	 */
	start?: number;

	/**
	 * end id
	 */
	end?: number;
}
declare interface ChunkModuleMaps {
	id: Record<string | number, (string | number)[]>;
	hash: Record<string | number, string>;
}
declare interface ChunkPathData {
	id: string | number;
	name?: string;
	hash: string;
	hashWithLength?: (arg0: number) => string;
	contentHash?: Record<string, string>;
	contentHashWithLength?: Record<string, (length: number) => string>;
}
declare class ChunkPrefetchPreloadPlugin {
	constructor();
	apply(compiler: Compiler): void;
}
declare interface ChunkRenderContext {
	/**
	 * the chunk
	 */
	chunk: Chunk;

	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;

	/**
	 * init fragments for the chunk
	 */
	chunkInitFragments: InitFragment<ChunkRenderContext>[];

	/**
	 * rendering in strict context
	 */
	strictMode: boolean;
}
declare interface ChunkSizeOptions {
	/**
	 * constant overhead for a chunk
	 */
	chunkOverhead?: number;

	/**
	 * multiplicator for initial chunks
	 */
	entryChunkMultiplicator?: number;
}
declare abstract class ChunkTemplate {
	hooks: Readonly<{
		renderManifest: { tap: (options?: any, fn?: any) => void };
		modules: { tap: (options?: any, fn?: any) => void };
		render: { tap: (options?: any, fn?: any) => void };
		renderWithEntry: { tap: (options?: any, fn?: any) => void };
		hash: { tap: (options?: any, fn?: any) => void };
		hashForChunk: { tap: (options?: any, fn?: any) => void };
	}>;
	get outputOptions(): Output;
}

/**
 * Advanced options for cleaning assets.
 */
declare interface CleanOptions {
	/**
	 * Log the assets that should be removed instead of deleting them.
	 */
	dry?: boolean;

	/**
	 * Keep these assets.
	 */
	keep?: string | RegExp | ((filename: string) => boolean);
}
declare class CleanPlugin {
	constructor(options?: CleanOptions);
	options: {
		/**
		 * Log the assets that should be removed instead of deleting them.
		 */
		dry: boolean;
		/**
		 * Keep these assets.
		 */
		keep?: string | RegExp | ((filename: string) => boolean);
	};

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static getCompilationHooks(
		compilation: Compilation
	): CleanPluginCompilationHooks;
}
declare interface CleanPluginCompilationHooks {
	/**
	 * when returning true the file/directory will be kept during cleaning, returning false will clean it and ignore the following plugins and config
	 */
	keep: SyncBailHook<[string], boolean>;
}
declare interface CodeGenerationContext {
	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * the runtimes code should be generated for
	 */
	runtime: RuntimeSpec;

	/**
	 * when in concatenated module, information about other concatenated modules
	 */
	concatenationScope?: ConcatenationScope;

	/**
	 * code generation results of other modules (need to have a codeGenerationDependency to use that)
	 */
	codeGenerationResults: CodeGenerationResults;

	/**
	 * the compilation
	 */
	compilation?: Compilation;

	/**
	 * source types
	 */
	sourceTypes?: ReadonlySet<string>;
}
declare interface CodeGenerationResult {
	/**
	 * the resulting sources for all source types
	 */
	sources: Map<string, Source>;

	/**
	 * the resulting data for all source types
	 */
	data?: Map<string, any>;

	/**
	 * the runtime requirements
	 */
	runtimeRequirements: ReadonlySet<string>;

	/**
	 * a hash of the code generation result (will be automatically calculated from sources and runtimeRequirements if not provided)
	 */
	hash?: string;
}
declare abstract class CodeGenerationResults {
	map: Map<Module, RuntimeSpecMap<CodeGenerationResult>>;
	get(module: Module, runtime: RuntimeSpec): CodeGenerationResult;
	has(module: Module, runtime: RuntimeSpec): boolean;
	getSource(module: Module, runtime: RuntimeSpec, sourceType: string): Source;
	getRuntimeRequirements(
		module: Module,
		runtime: RuntimeSpec
	): ReadonlySet<string>;
	getData(module: Module, runtime: RuntimeSpec, key: string): any;
	getHash(module: Module, runtime: RuntimeSpec): any;
	add(module: Module, runtime: RuntimeSpec, result: CodeGenerationResult): void;
}
type CodeValue =
	| undefined
	| null
	| string
	| number
	| bigint
	| boolean
	| Function
	| RegExp
	| RuntimeValue
	| {
			[index: string]: RecursiveArrayOrRecord<
				| undefined
				| null
				| string
				| number
				| bigint
				| boolean
				| Function
				| RegExp
				| RuntimeValue
			>;
	  }
	| RecursiveArrayOrRecord<
			| undefined
			| null
			| string
			| number
			| bigint
			| boolean
			| Function
			| RegExp
			| RuntimeValue
	  >[];
type CodeValuePrimitive =
	| undefined
	| null
	| string
	| number
	| bigint
	| boolean
	| Function
	| RegExp;
declare interface Comparator<T> {
	(arg0: T, arg1: T): 0 | 1 | -1;
}
declare class CompatSource extends Source {
	constructor(sourceLike: SourceLike);
	static from(sourceLike: SourceLike): Source;
}
declare class Compilation {
	/**
	 * Creates an instance of Compilation.
	 */
	constructor(compiler: Compiler, params: CompilationParams);
	hooks: Readonly<{
		buildModule: SyncHook<[Module]>;
		rebuildModule: SyncHook<[Module]>;
		failedModule: SyncHook<[Module, WebpackError]>;
		succeedModule: SyncHook<[Module]>;
		stillValidModule: SyncHook<[Module]>;
		addEntry: SyncHook<[Dependency, EntryOptions]>;
		failedEntry: SyncHook<[Dependency, EntryOptions, Error]>;
		succeedEntry: SyncHook<[Dependency, EntryOptions, Module]>;
		dependencyReferencedExports: SyncWaterfallHook<
			[(string[] | ReferencedExport)[], Dependency, RuntimeSpec]
		>;
		executeModule: SyncHook<[ExecuteModuleArgument, ExecuteModuleContext]>;
		prepareModuleExecution: AsyncParallelHook<
			[ExecuteModuleArgument, ExecuteModuleContext]
		>;
		finishModules: AsyncSeriesHook<[Iterable<Module>]>;
		finishRebuildingModule: AsyncSeriesHook<[Module]>;
		unseal: SyncHook<[]>;
		seal: SyncHook<[]>;
		beforeChunks: SyncHook<[]>;
		/**
		 * The `afterChunks` hook is called directly after the chunks and module graph have
		 * been created and before the chunks and modules have been optimized. This hook is useful to
		 * inspect, analyze, and/or modify the chunk graph.
		 */
		afterChunks: SyncHook<[Iterable<Chunk>]>;
		optimizeDependencies: SyncBailHook<[Iterable<Module>], any>;
		afterOptimizeDependencies: SyncHook<[Iterable<Module>]>;
		optimize: SyncHook<[]>;
		optimizeModules: SyncBailHook<[Iterable<Module>], any>;
		afterOptimizeModules: SyncHook<[Iterable<Module>]>;
		optimizeChunks: SyncBailHook<[Iterable<Chunk>, ChunkGroup[]], any>;
		afterOptimizeChunks: SyncHook<[Iterable<Chunk>, ChunkGroup[]]>;
		optimizeTree: AsyncSeriesHook<[Iterable<Chunk>, Iterable<Module>]>;
		afterOptimizeTree: SyncHook<[Iterable<Chunk>, Iterable<Module>]>;
		optimizeChunkModules: AsyncSeriesBailHook<
			[Iterable<Chunk>, Iterable<Module>],
			any
		>;
		afterOptimizeChunkModules: SyncHook<[Iterable<Chunk>, Iterable<Module>]>;
		shouldRecord: SyncBailHook<[], undefined | boolean>;
		additionalChunkRuntimeRequirements: SyncHook<
			[Chunk, Set<string>, RuntimeRequirementsContext]
		>;
		runtimeRequirementInChunk: HookMap<
			SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext], any>
		>;
		additionalModuleRuntimeRequirements: SyncHook<
			[Module, Set<string>, RuntimeRequirementsContext]
		>;
		runtimeRequirementInModule: HookMap<
			SyncBailHook<[Module, Set<string>, RuntimeRequirementsContext], any>
		>;
		additionalTreeRuntimeRequirements: SyncHook<
			[Chunk, Set<string>, RuntimeRequirementsContext]
		>;
		runtimeRequirementInTree: HookMap<
			SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext], any>
		>;
		runtimeModule: SyncHook<[RuntimeModule, Chunk]>;
		reviveModules: SyncHook<[Iterable<Module>, any]>;
		beforeModuleIds: SyncHook<[Iterable<Module>]>;
		moduleIds: SyncHook<[Iterable<Module>]>;
		optimizeModuleIds: SyncHook<[Iterable<Module>]>;
		afterOptimizeModuleIds: SyncHook<[Iterable<Module>]>;
		reviveChunks: SyncHook<[Iterable<Chunk>, any]>;
		beforeChunkIds: SyncHook<[Iterable<Chunk>]>;
		chunkIds: SyncHook<[Iterable<Chunk>]>;
		optimizeChunkIds: SyncHook<[Iterable<Chunk>]>;
		afterOptimizeChunkIds: SyncHook<[Iterable<Chunk>]>;
		recordModules: SyncHook<[Iterable<Module>, any]>;
		recordChunks: SyncHook<[Iterable<Chunk>, any]>;
		optimizeCodeGeneration: SyncHook<[Iterable<Module>]>;
		beforeModuleHash: SyncHook<[]>;
		afterModuleHash: SyncHook<[]>;
		beforeCodeGeneration: SyncHook<[]>;
		afterCodeGeneration: SyncHook<[]>;
		beforeRuntimeRequirements: SyncHook<[]>;
		afterRuntimeRequirements: SyncHook<[]>;
		beforeHash: SyncHook<[]>;
		contentHash: SyncHook<[Chunk]>;
		afterHash: SyncHook<[]>;
		recordHash: SyncHook<[any]>;
		record: SyncHook<[Compilation, any]>;
		beforeModuleAssets: SyncHook<[]>;
		shouldGenerateChunkAssets: SyncBailHook<[], boolean>;
		beforeChunkAssets: SyncHook<[]>;
		additionalChunkAssets: FakeHook<
			Pick<
				AsyncSeriesHook<[Set<Chunk>]>,
				"name" | "tap" | "tapAsync" | "tapPromise"
			>
		>;
		additionalAssets: FakeHook<
			Pick<AsyncSeriesHook<[]>, "name" | "tap" | "tapAsync" | "tapPromise">
		>;
		optimizeChunkAssets: FakeHook<
			Pick<
				AsyncSeriesHook<[Set<Chunk>]>,
				"name" | "tap" | "tapAsync" | "tapPromise"
			>
		>;
		afterOptimizeChunkAssets: FakeHook<
			Pick<
				AsyncSeriesHook<[Set<Chunk>]>,
				"name" | "tap" | "tapAsync" | "tapPromise"
			>
		>;
		optimizeAssets: AsyncSeriesHook<
			[CompilationAssets],
			ProcessAssetsAdditionalOptions
		>;
		afterOptimizeAssets: SyncHook<[CompilationAssets]>;
		processAssets: AsyncSeriesHook<
			[CompilationAssets],
			ProcessAssetsAdditionalOptions
		>;
		afterProcessAssets: SyncHook<[CompilationAssets]>;
		processAdditionalAssets: AsyncSeriesHook<[CompilationAssets]>;
		needAdditionalSeal: SyncBailHook<[], boolean>;
		afterSeal: AsyncSeriesHook<[]>;
		renderManifest: SyncWaterfallHook<
			[RenderManifestEntry[], RenderManifestOptions]
		>;
		fullHash: SyncHook<[Hash]>;
		chunkHash: SyncHook<[Chunk, Hash, ChunkHashContext]>;
		moduleAsset: SyncHook<[Module, string]>;
		chunkAsset: SyncHook<[Chunk, string]>;
		assetPath: SyncWaterfallHook<[string, object, AssetInfo]>;
		needAdditionalPass: SyncBailHook<[], boolean>;
		childCompiler: SyncHook<[Compiler, string, number]>;
		log: SyncBailHook<[string, LogEntry], true>;
		processWarnings: SyncWaterfallHook<[WebpackError[]]>;
		processErrors: SyncWaterfallHook<[WebpackError[]]>;
		statsPreset: HookMap<
			SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>
		>;
		statsNormalize: SyncHook<
			[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]
		>;
		statsFactory: SyncHook<[StatsFactory, NormalizedStatsOptions]>;
		statsPrinter: SyncHook<[StatsPrinter, NormalizedStatsOptions]>;
		get normalModuleLoader(): SyncHook<[object, NormalModule]>;
	}>;
	name?: string;
	startTime: any;
	endTime: any;
	compiler: Compiler;
	resolverFactory: ResolverFactory;
	inputFileSystem: InputFileSystem;
	fileSystemInfo: FileSystemInfo;
	valueCacheVersions: Map<string, string | Set<string>>;
	requestShortener: RequestShortener;
	compilerPath: string;
	logger: WebpackLogger;
	options: WebpackOptionsNormalized;
	outputOptions: OutputNormalized;
	bail: boolean;
	profile: boolean;
	params: CompilationParams;
	mainTemplate: MainTemplate;
	chunkTemplate: ChunkTemplate;
	runtimeTemplate: RuntimeTemplate;
	moduleTemplates: { javascript: ModuleTemplate };
	moduleMemCaches?: Map<Module, WeakTupleMap<any, any>>;
	moduleMemCaches2?: Map<Module, WeakTupleMap<any, any>>;
	moduleGraph: ModuleGraph;
	chunkGraph: ChunkGraph;
	codeGenerationResults: CodeGenerationResults;
	processDependenciesQueue: AsyncQueue<Module, Module, Module>;
	addModuleQueue: AsyncQueue<Module, string, Module>;
	factorizeQueue: AsyncQueue<
		FactorizeModuleOptions,
		string,
		Module | ModuleFactoryResult
	>;
	buildQueue: AsyncQueue<Module, Module, Module>;
	rebuildQueue: AsyncQueue<Module, Module, Module>;

	/**
	 * Modules in value are building during the build of Module in key.
	 * Means value blocking key from finishing.
	 * Needed to detect build cycles.
	 */
	creatingModuleDuringBuild: WeakMap<Module, Set<Module>>;
	entries: Map<string, EntryData>;
	globalEntry: EntryData;
	entrypoints: Map<string, Entrypoint>;
	asyncEntrypoints: Entrypoint[];
	chunks: Set<Chunk>;
	chunkGroups: ChunkGroup[];
	namedChunkGroups: Map<string, ChunkGroup>;
	namedChunks: Map<string, Chunk>;
	modules: Set<Module>;
	records: any;
	additionalChunkAssets: string[];
	assets: CompilationAssets;
	assetsInfo: Map<string, AssetInfo>;
	errors: WebpackError[];
	warnings: WebpackError[];
	children: Compilation[];
	logging: Map<string, LogEntry[]>;
	dependencyFactories: Map<DepConstructor, ModuleFactory>;
	dependencyTemplates: DependencyTemplates;
	childrenCounters: object;
	usedChunkIds: Set<string | number>;
	usedModuleIds: Set<number>;
	needAdditionalPass: boolean;
	builtModules: WeakSet<Module>;
	codeGeneratedModules: WeakSet<Module>;
	buildTimeExecutedModules: WeakSet<Module>;
	emittedAssets: Set<string>;
	comparedForEmitAssets: Set<string>;
	fileDependencies: LazySet<string>;
	contextDependencies: LazySet<string>;
	missingDependencies: LazySet<string>;
	buildDependencies: LazySet<string>;
	compilationDependencies: { add: (item?: any) => LazySet<string> };
	getStats(): Stats;
	createStatsOptions(
		optionsOrPreset: string | StatsOptions,
		context?: CreateStatsOptionsContext
	): NormalizedStatsOptions;
	createStatsFactory(options?: any): StatsFactory;
	createStatsPrinter(options?: any): StatsPrinter;
	getCache(name: string): CacheFacade;
	getLogger(name: string | (() => string)): WebpackLogger;
	addModule(
		module: Module,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;

	/**
	 * Fetches a module from a compilation by its identifier
	 */
	getModule(module: Module): Module;

	/**
	 * Attempts to search for a module by its identifier
	 */
	findModule(identifier: string): undefined | Module;

	/**
	 * Schedules a build of the module object
	 */
	buildModule(
		module: Module,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	processModuleDependencies(
		module: Module,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	processModuleDependenciesNonRecursive(module: Module): void;
	handleModuleCreation(
		__0: HandleModuleCreationOptions,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	addModuleChain(
		context: string,
		dependency: Dependency,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	addModuleTree(
		__0: {
			/**
			 * context string path
			 */
			context: string;
			/**
			 * dependency used to create Module chain
			 */
			dependency: Dependency;
			/**
			 * additional context info for the root module
			 */
			contextInfo?: Partial<ModuleFactoryCreateDataContextInfo>;
		},
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	addEntry(
		context: string,
		entry: Dependency,
		optionsOrName: string | EntryOptions,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	addInclude(
		context: string,
		dependency: Dependency,
		options: EntryOptions,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	rebuildModule(
		module: Module,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	finish(callback?: any): void;
	unseal(): void;
	seal(callback: (err?: null | WebpackError) => void): void;
	reportDependencyErrorsAndWarnings(
		module: Module,
		blocks: DependenciesBlock[]
	): boolean;
	codeGeneration(callback?: any): void;
	processRuntimeRequirements(__0?: {
		/**
		 * the chunk graph
		 */
		chunkGraph?: ChunkGraph;
		/**
		 * modules
		 */
		modules?: Iterable<Module>;
		/**
		 * chunks
		 */
		chunks?: Iterable<Chunk>;
		/**
		 * codeGenerationResults
		 */
		codeGenerationResults?: CodeGenerationResults;
		/**
		 * chunkGraphEntries
		 */
		chunkGraphEntries?: Iterable<Chunk>;
	}): void;
	addRuntimeModule(
		chunk: Chunk,
		module: RuntimeModule,
		chunkGraph?: ChunkGraph
	): void;

	/**
	 * If `module` is passed, `loc` and `request` must also be passed.
	 */
	addChunkInGroup(
		groupOptions: string | ChunkGroupOptions,
		module?: Module,
		loc?: SyntheticDependencyLocation | RealDependencyLocation,
		request?: string
	): ChunkGroup;
	addAsyncEntrypoint(
		options: EntryOptions,
		module: Module,
		loc: DependencyLocation,
		request: string
	): Entrypoint;

	/**
	 * This method first looks to see if a name is provided for a new chunk,
	 * and first looks to see if any named chunks already exist and reuse that chunk instead.
	 */
	addChunk(name?: string): Chunk;
	assignDepth(module: Module): void;
	assignDepths(modules: Set<Module>): void;
	getDependencyReferencedExports(
		dependency: Dependency,
		runtime: RuntimeSpec
	): (string[] | ReferencedExport)[];
	removeReasonsOfDependencyBlock(
		module: Module,
		block: DependenciesBlockLike
	): void;
	patchChunksAfterReasonRemoval(module: Module, chunk: Chunk): void;
	removeChunkFromDependencies(block: DependenciesBlock, chunk: Chunk): void;
	assignRuntimeIds(): void;
	sortItemsWithChunkIds(): void;
	summarizeDependencies(): void;
	createModuleHashes(): void;
	createHash(): {
		module: Module;
		hash: string;
		runtime: RuntimeSpec;
		runtimes: RuntimeSpec[];
	}[];
	fullHash?: string;
	hash?: string;
	emitAsset(file: string, source: Source, assetInfo?: AssetInfo): void;
	updateAsset(
		file: string,
		newSourceOrFunction: Source | ((arg0: Source) => Source),
		assetInfoUpdateOrFunction?: AssetInfo | ((arg0?: AssetInfo) => AssetInfo)
	): void;
	renameAsset(file?: any, newFile?: any): void;
	deleteAsset(file: string): void;
	getAssets(): Readonly<Asset>[];
	getAsset(name: string): undefined | Readonly<Asset>;
	clearAssets(): void;
	createModuleAssets(): void;
	getRenderManifest(options: RenderManifestOptions): RenderManifestEntry[];
	createChunkAssets(callback: (err?: null | WebpackError) => void): void;
	getPath(
		filename: string | ((arg0: PathData, arg1?: AssetInfo) => string),
		data?: PathData
	): string;
	getPathWithInfo(
		filename: string | ((arg0: PathData, arg1?: AssetInfo) => string),
		data?: PathData
	): { path: string; info: AssetInfo };
	getAssetPath(
		filename: string | ((arg0: PathData, arg1?: AssetInfo) => string),
		data: PathData
	): string;
	getAssetPathWithInfo(
		filename: string | ((arg0: PathData, arg1?: AssetInfo) => string),
		data: PathData
	): { path: string; info: AssetInfo };
	getWarnings(): WebpackError[];
	getErrors(): WebpackError[];

	/**
	 * This function allows you to run another instance of webpack inside of webpack however as
	 * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins
	 * from parent (or top level compiler) and creates a child Compilation
	 */
	createChildCompiler(
		name: string,
		outputOptions?: OutputNormalized,
		plugins?: (
			| ((this: Compiler, compiler: Compiler) => void)
			| WebpackPluginInstance
		)[]
	): Compiler;
	executeModule(
		module: Module,
		options: ExecuteModuleOptions,
		callback: (err?: null | WebpackError, result?: ExecuteModuleResult) => void
	): void;
	checkConstraints(): void;
	factorizeModule: {
		(
			options: FactorizeModuleOptions & { factoryResult?: false },
			callback: (err?: null | WebpackError, result?: Module) => void
		): void;
		(
			options: FactorizeModuleOptions & { factoryResult: true },
			callback: (
				err?: null | WebpackError,
				result?: ModuleFactoryResult
			) => void
		): void;
	};

	/**
	 * Add additional assets to the compilation.
	 */
	static PROCESS_ASSETS_STAGE_ADDITIONAL: number;

	/**
	 * Basic preprocessing of assets.
	 */
	static PROCESS_ASSETS_STAGE_PRE_PROCESS: number;

	/**
	 * Derive new assets from existing assets.
	 * Existing assets should not be treated as complete.
	 */
	static PROCESS_ASSETS_STAGE_DERIVED: number;

	/**
	 * Add additional sections to existing assets, like a banner or initialization code.
	 */
	static PROCESS_ASSETS_STAGE_ADDITIONS: number;

	/**
	 * Optimize existing assets in a general way.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE: number;

	/**
	 * Optimize the count of existing assets, e. g. by merging them.
	 * Only assets of the same type should be merged.
	 * For assets of different types see PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT: number;

	/**
	 * Optimize the compatibility of existing assets, e. g. add polyfills or vendor-prefixes.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY: number;

	/**
	 * Optimize the size of existing assets, e. g. by minimizing or omitting whitespace.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE: number;

	/**
	 * Add development tooling to assets, e. g. by extracting a SourceMap.
	 */
	static PROCESS_ASSETS_STAGE_DEV_TOOLING: number;

	/**
	 * Optimize the count of existing assets, e. g. by inlining assets of into other assets.
	 * Only assets of different types should be inlined.
	 * For assets of the same type see PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE: number;

	/**
	 * Summarize the list of existing assets
	 * e. g. creating an assets manifest of Service Workers.
	 */
	static PROCESS_ASSETS_STAGE_SUMMARIZE: number;

	/**
	 * Optimize the hashes of the assets, e. g. by generating real hashes of the asset content.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_HASH: number;

	/**
	 * Optimize the transfer of existing assets, e. g. by preparing a compressed (gzip) file as separate asset.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER: number;

	/**
	 * Analyse existing assets.
	 */
	static PROCESS_ASSETS_STAGE_ANALYSE: number;

	/**
	 * Creating assets for reporting purposes.
	 */
	static PROCESS_ASSETS_STAGE_REPORT: number;
}
declare interface CompilationAssets {
	[index: string]: Source;
}
declare interface CompilationHooksAsyncWebAssemblyModulesPlugin {
	renderModuleContent: SyncWaterfallHook<
		[Source, Module, WebAssemblyRenderContext]
	>;
}
declare interface CompilationHooksJavascriptModulesPlugin {
	renderModuleContent: SyncWaterfallHook<[Source, Module, ChunkRenderContext]>;
	renderModuleContainer: SyncWaterfallHook<
		[Source, Module, ChunkRenderContext]
	>;
	renderModulePackage: SyncWaterfallHook<[Source, Module, ChunkRenderContext]>;
	renderChunk: SyncWaterfallHook<[Source, RenderContext]>;
	renderMain: SyncWaterfallHook<[Source, RenderContext]>;
	renderContent: SyncWaterfallHook<[Source, RenderContext]>;
	render: SyncWaterfallHook<[Source, RenderContext]>;
	renderStartup: SyncWaterfallHook<[Source, Module, StartupRenderContext]>;
	renderRequire: SyncWaterfallHook<[string, RenderBootstrapContext]>;
	inlineInRuntimeBailout: SyncBailHook<
		[Module, RenderBootstrapContext],
		string
	>;
	embedInRuntimeBailout: SyncBailHook<[Module, RenderContext], string | void>;
	strictRuntimeBailout: SyncBailHook<[RenderContext], string | void>;
	chunkHash: SyncHook<[Chunk, Hash, ChunkHashContext]>;
	useSourceMap: SyncBailHook<[Chunk, RenderContext], boolean>;
}
declare interface CompilationHooksRealContentHashPlugin {
	updateHash: SyncBailHook<[Buffer[], string], string>;
}
declare interface CompilationParams {
	normalModuleFactory: NormalModuleFactory;
	contextModuleFactory: ContextModuleFactory;
}
declare class Compiler {
	constructor(context: string, options?: WebpackOptionsNormalized);
	hooks: Readonly<{
		initialize: SyncHook<[]>;
		shouldEmit: SyncBailHook<[Compilation], undefined | boolean>;
		done: AsyncSeriesHook<[Stats]>;
		afterDone: SyncHook<[Stats]>;
		additionalPass: AsyncSeriesHook<[]>;
		beforeRun: AsyncSeriesHook<[Compiler]>;
		run: AsyncSeriesHook<[Compiler]>;
		emit: AsyncSeriesHook<[Compilation]>;
		assetEmitted: AsyncSeriesHook<[string, AssetEmittedInfo]>;
		afterEmit: AsyncSeriesHook<[Compilation]>;
		thisCompilation: SyncHook<[Compilation, CompilationParams]>;
		compilation: SyncHook<[Compilation, CompilationParams]>;
		normalModuleFactory: SyncHook<[NormalModuleFactory]>;
		contextModuleFactory: SyncHook<[ContextModuleFactory]>;
		beforeCompile: AsyncSeriesHook<[CompilationParams]>;
		compile: SyncHook<[CompilationParams]>;
		make: AsyncParallelHook<[Compilation]>;
		finishMake: AsyncParallelHook<[Compilation]>;
		afterCompile: AsyncSeriesHook<[Compilation]>;
		readRecords: AsyncSeriesHook<[]>;
		emitRecords: AsyncSeriesHook<[]>;
		watchRun: AsyncSeriesHook<[Compiler]>;
		failed: SyncHook<[Error]>;
		invalid: SyncHook<[null | string, number]>;
		watchClose: SyncHook<[]>;
		shutdown: AsyncSeriesHook<[]>;
		infrastructureLog: SyncBailHook<[string, string, any[]], true>;
		environment: SyncHook<[]>;
		afterEnvironment: SyncHook<[]>;
		afterPlugins: SyncHook<[Compiler]>;
		afterResolvers: SyncHook<[Compiler]>;
		entryOption: SyncBailHook<[string, EntryNormalized], boolean>;
	}>;
	webpack: typeof exports;
	name?: string;
	parentCompilation?: Compilation;
	root: Compiler;
	outputPath: string;
	watching?: Watching;
	outputFileSystem: OutputFileSystem;
	intermediateFileSystem: IntermediateFileSystem;
	inputFileSystem: InputFileSystem;
	watchFileSystem: WatchFileSystem;
	recordsInputPath: null | string;
	recordsOutputPath: null | string;
	records: object;
	managedPaths: Set<string | RegExp>;
	immutablePaths: Set<string | RegExp>;
	modifiedFiles?: ReadonlySet<string>;
	removedFiles?: ReadonlySet<string>;
	fileTimestamps?: ReadonlyMap<string, null | FileSystemInfoEntry | "ignore">;
	contextTimestamps?: ReadonlyMap<
		string,
		null | FileSystemInfoEntry | "ignore"
	>;
	fsStartTime?: number;
	resolverFactory: ResolverFactory;
	infrastructureLogger: any;
	options: WebpackOptionsNormalized;
	context: string;
	requestShortener: RequestShortener;
	cache: Cache;
	moduleMemCaches?: Map<
		Module,
		{
			buildInfo: object;
			references: WeakMap<Dependency, Module>;
			memCache: WeakTupleMap<any, any>;
		}
	>;
	compilerPath: string;
	running: boolean;
	idle: boolean;
	watchMode: boolean;
	getCache(name: string): CacheFacade;
	getInfrastructureLogger(name: string | (() => string)): WebpackLogger;
	watch(watchOptions: WatchOptions, handler: CallbackFunction<Stats>): Watching;
	run(callback: CallbackFunction<Stats>): void;
	runAsChild(
		callback: (
			err?: null | Error,
			entries?: Chunk[],
			compilation?: Compilation
		) => any
	): void;
	purgeInputFileSystem(): void;
	emitAssets(compilation: Compilation, callback: CallbackFunction<void>): void;
	emitRecords(callback: CallbackFunction<void>): void;
	readRecords(callback: CallbackFunction<void>): void;
	createChildCompiler(
		compilation: Compilation,
		compilerName: string,
		compilerIndex: number,
		outputOptions?: OutputNormalized,
		plugins?: WebpackPluginInstance[]
	): Compiler;
	isChild(): boolean;
	createCompilation(params?: any): Compilation;
	newCompilation(params: CompilationParams): Compilation;
	createNormalModuleFactory(): NormalModuleFactory;
	createContextModuleFactory(): ContextModuleFactory;
	newCompilationParams(): {
		normalModuleFactory: NormalModuleFactory;
		contextModuleFactory: ContextModuleFactory;
	};
	compile(callback: CallbackFunction<Compilation>): void;
	close(callback: CallbackFunction<void>): void;
}
declare class ConcatSource extends Source {
	constructor(...args: (string | Source)[]);
	getChildren(): Source[];
	add(item: string | Source): void;
	addAllSkipOptimizing(items: Source[]): void;
}
declare interface ConcatenatedModuleInfo {
	index: number;
	module: Module;

	/**
	 * mapping from export name to symbol
	 */
	exportMap: Map<string, string>;

	/**
	 * mapping from export name to symbol
	 */
	rawExportMap: Map<string, string>;
	namespaceExportSymbol?: string;
}
declare interface ConcatenationBailoutReasonContext {
	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;
}
declare class ConcatenationScope {
	constructor(
		modulesMap: ModuleInfo[] | Map<Module, ModuleInfo>,
		currentModule: ConcatenatedModuleInfo
	);
	isModuleInScope(module: Module): boolean;
	registerExport(exportName: string, symbol: string): void;
	registerRawExport(exportName: string, expression: string): void;
	registerNamespaceExport(symbol: string): void;
	createModuleReference(
		module: Module,
		__1: Partial<ModuleReferenceOptions>
	): string;
	static isModuleReference(name: string): boolean;
	static matchModuleReference(
		name: string
	): null | (ModuleReferenceOptions & { index: number });
	static DEFAULT_EXPORT: string;
	static NAMESPACE_OBJECT_EXPORT: string;
}

/**
 * Options object as provided by the user.
 */
declare interface Configuration {
	/**
	 * Set the value of `require.amd` and `define.amd`. Or disable AMD support.
	 */
	amd?: false | { [index: string]: any };

	/**
	 * Report the first error as a hard error instead of tolerating it.
	 */
	bail?: boolean;

	/**
	 * Cache generated modules and chunks to improve performance for multiple incremental builds.
	 */
	cache?: boolean | FileCacheOptions | MemoryCacheOptions;

	/**
	 * The base directory (absolute path!) for resolving the `entry` option. If `output.pathinfo` is set, the included pathinfo is shortened to this directory.
	 */
	context?: string;

	/**
	 * References to other configurations to depend on.
	 */
	dependencies?: string[];

	/**
	 * A developer tool to enhance debugging (false | eval | [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map).
	 */
	devtool?: string | false;

	/**
	 * The entry point(s) of the compilation.
	 */
	entry?:
		| string
		| (() => string | EntryObject | string[] | Promise<EntryStatic>)
		| EntryObject
		| string[];

	/**
	 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
	 */
	experiments?: Experiments;

	/**
	 * Extend configuration from another configuration (only works when using webpack-cli).
	 */
	extends?: string | string[];

	/**
	 * Specify dependencies that shouldn't be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.
	 */
	externals?:
		| string
		| RegExp
		| ExternalItem[]
		| (ExternalItemObjectKnown & ExternalItemObjectUnknown)
		| ((
				data: ExternalItemFunctionData,
				callback: (
					err?: null | Error,
					result?: string | boolean | string[] | { [index: string]: any }
				) => void
		  ) => void)
		| ((data: ExternalItemFunctionData) => Promise<ExternalItemValue>);

	/**
	 * Enable presets of externals for specific targets.
	 */
	externalsPresets?: ExternalsPresets;

	/**
	 * Specifies the default type of externals ('amd*', 'umd*', 'system' and 'jsonp' depend on output.libraryTarget set to the same value).
	 */
	externalsType?:
		| "import"
		| "var"
		| "module"
		| "assign"
		| "this"
		| "window"
		| "self"
		| "global"
		| "commonjs"
		| "commonjs2"
		| "commonjs-module"
		| "commonjs-static"
		| "amd"
		| "amd-require"
		| "umd"
		| "umd2"
		| "jsonp"
		| "system"
		| "promise"
		| "script"
		| "node-commonjs";

	/**
	 * Ignore specific warnings.
	 */
	ignoreWarnings?: (
		| RegExp
		| {
				/**
				 * A RegExp to select the origin file for the warning.
				 */
				file?: RegExp;
				/**
				 * A RegExp to select the warning message.
				 */
				message?: RegExp;
				/**
				 * A RegExp to select the origin module for the warning.
				 */
				module?: RegExp;
		  }
		| ((warning: WebpackError, compilation: Compilation) => boolean)
	)[];

	/**
	 * Options for infrastructure level logging.
	 */
	infrastructureLogging?: InfrastructureLogging;

	/**
	 * Custom values available in the loader context.
	 */
	loader?: Loader;

	/**
	 * Enable production optimizations or development hints.
	 */
	mode?: "none" | "development" | "production";

	/**
	 * Options affecting the normal modules (`NormalModuleFactory`).
	 */
	module?: ModuleOptions;

	/**
	 * Name of the configuration. Used when loading multiple configurations.
	 */
	name?: string;

	/**
	 * Include polyfills or mocks for various node stuff.
	 */
	node?: false | NodeOptions;

	/**
	 * Enables/Disables integrated optimizations.
	 */
	optimization?: Optimization;

	/**
	 * Options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
	 */
	output?: Output;

	/**
	 * The number of parallel processed modules in the compilation.
	 */
	parallelism?: number;

	/**
	 * Configuration for web performance recommendations.
	 */
	performance?: false | PerformanceOptions;

	/**
	 * Add additional plugins to the compiler.
	 */
	plugins?: (
		| undefined
		| null
		| false
		| ""
		| 0
		| ((this: Compiler, compiler: Compiler) => void)
		| WebpackPluginInstance
	)[];

	/**
	 * Capture timing information for each module.
	 */
	profile?: boolean;

	/**
	 * Store compiler state to a json file.
	 */
	recordsInputPath?: string | false;

	/**
	 * Load compiler state from a json file.
	 */
	recordsOutputPath?: string | false;

	/**
	 * Store/Load compiler state from/to a json file. This will result in persistent ids of modules and chunks. An absolute path is expected. `recordsPath` is used for `recordsInputPath` and `recordsOutputPath` if they left undefined.
	 */
	recordsPath?: string | false;

	/**
	 * Options for the resolver.
	 */
	resolve?: ResolveOptionsWebpackOptions;

	/**
	 * Options for the resolver when resolving loaders.
	 */
	resolveLoader?: ResolveOptionsWebpackOptions;

	/**
	 * Options affecting how file system snapshots are created and validated.
	 */
	snapshot?: SnapshotOptionsWebpackOptions;

	/**
	 * Stats options object or preset name.
	 */
	stats?:
		| boolean
		| StatsOptions
		| "none"
		| "verbose"
		| "summary"
		| "errors-only"
		| "errors-warnings"
		| "minimal"
		| "normal"
		| "detailed";

	/**
	 * Environment to build for. An array of environments to build for all of them when possible.
	 */
	target?: string | false | string[];

	/**
	 * Enter watch mode, which rebuilds on file change.
	 */
	watch?: boolean;

	/**
	 * Options for the watcher.
	 */
	watchOptions?: WatchOptions;
}
type ConnectionState =
	| boolean
	| typeof TRANSITIVE_ONLY
	| typeof CIRCULAR_CONNECTION;
declare class ConstDependency extends NullDependency {
	constructor(
		expression: string,
		range: number | [number, number],
		runtimeRequirements?: null | string[]
	);
	expression: string;
	range: number | [number, number];
	runtimeRequirements: null | Set<string>;
	static Template: typeof ConstDependencyTemplate;
	static NO_EXPORTS_REFERENCED: string[][];
	static EXPORTS_OBJECT_REFERENCED: string[][];
	static TRANSITIVE: typeof TRANSITIVE;
}
declare class ConstDependencyTemplate extends NullDependencyTemplate {
	constructor();
}
declare interface Constructor {
	new (...params: any[]): any;
}
declare class ConsumeSharedPlugin {
	constructor(options: ConsumeSharedPluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}

/**
 * Options for consuming shared modules.
 */
declare interface ConsumeSharedPluginOptions {
	/**
	 * Modules that should be consumed from share scope. When provided, property names are used to match requested modules in this compilation.
	 */
	consumes: Consumes;

	/**
	 * Share scope name used for all consumed modules (defaults to 'default').
	 */
	shareScope?: string;
}
type Consumes = (string | ConsumesObject)[] | ConsumesObject;

/**
 * Advanced configuration for modules that should be consumed from share scope.
 */
declare interface ConsumesConfig {
	/**
	 * Include the fallback module directly instead behind an async request. This allows to use fallback module in initial load too. All possible shared modules need to be eager too.
	 */
	eager?: boolean;

	/**
	 * Fallback module if no shared module is found in share scope. Defaults to the property name.
	 */
	import?: string | false;

	/**
	 * Package name to determine required version from description file. This is only needed when package name can't be automatically determined from request.
	 */
	packageName?: string;

	/**
	 * Version requirement from module in share scope.
	 */
	requiredVersion?: string | false;

	/**
	 * Module is looked up under this key from the share scope.
	 */
	shareKey?: string;

	/**
	 * Share scope name.
	 */
	shareScope?: string;

	/**
	 * Allow only a single version of the shared module in share scope (disabled by default).
	 */
	singleton?: boolean;

	/**
	 * Do not accept shared module if version is not valid (defaults to yes, if local fallback module is available and shared module is not a singleton, otherwise no, has no effect if there is no required version specified).
	 */
	strictVersion?: boolean;
}

/**
 * Modules that should be consumed from share scope. Property names are used to match requested modules in this compilation. Relative requests are resolved, module requests are matched unresolved, absolute paths will match resolved requests. A trailing slash will match all requests with this prefix. In this case shareKey must also have a trailing slash.
 */
declare interface ConsumesObject {
	[index: string]: string | ConsumesConfig;
}
type ContainerOptionsFormat<T> =
	| Record<string, string | string[] | T>
	| (string | Record<string, string | string[] | T>)[];
declare class ContainerPlugin {
	constructor(options: ContainerPluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ContainerPluginOptions {
	/**
	 * Modules that should be exposed by this container. When provided, property name is used as public name, otherwise public name is automatically inferred from request.
	 */
	exposes: Exposes;

	/**
	 * The filename for this container relative path inside the `output.path` directory.
	 */
	filename?: string;

	/**
	 * Options for library.
	 */
	library?: LibraryOptions;

	/**
	 * The name for this container.
	 */
	name: string;

	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: string | false;

	/**
	 * The name of the share scope which is shared with the host (defaults to 'default').
	 */
	shareScope?: string;
}
declare class ContainerReferencePlugin {
	constructor(options: ContainerReferencePluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ContainerReferencePluginOptions {
	/**
	 * The external type of the remote containers.
	 */
	remoteType: ExternalsType;

	/**
	 * Container locations and request scopes from which modules should be resolved and loaded at runtime. When provided, property name is used as request scope, otherwise request scope is automatically inferred from container location.
	 */
	remotes: Remotes;

	/**
	 * The name of the share scope shared with all remotes (defaults to 'default').
	 */
	shareScope?: string;
}
declare abstract class ContextElementDependency extends ModuleDependency {
	referencedExports?: string[][];
}
declare class ContextExclusionPlugin {
	constructor(negativeMatcher: RegExp);
	negativeMatcher: RegExp;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ContextFileSystemInfoEntry {
	safeTime: number;
	timestampHash?: string;
	resolved?: ResolvedContextFileSystemInfoEntry;
	symlinks?: Set<string>;
}
declare interface ContextHash {
	hash: string;
	resolved?: string;
	symlinks?: Set<string>;
}
type ContextMode =
	| "weak"
	| "eager"
	| "lazy"
	| "lazy-once"
	| "sync"
	| "async-weak";
declare abstract class ContextModuleFactory extends ModuleFactory {
	hooks: Readonly<{
		beforeResolve: AsyncSeriesWaterfallHook<[any]>;
		afterResolve: AsyncSeriesWaterfallHook<[any]>;
		contextModuleFiles: SyncWaterfallHook<[string[]]>;
		alternatives: FakeHook<
			Pick<
				AsyncSeriesWaterfallHook<[any[]]>,
				"name" | "tap" | "tapAsync" | "tapPromise"
			>
		>;
		alternativeRequests: AsyncSeriesWaterfallHook<
			[any[], ContextModuleOptions]
		>;
	}>;
	resolverFactory: ResolverFactory;
	resolveDependencies(
		fs: InputFileSystem,
		options: ContextModuleOptions,
		callback: (
			err?: null | Error,
			dependencies?: ContextElementDependency[]
		) => any
	): void;
}

declare interface ContextModuleOptions {
	mode: ContextMode;
	recursive: boolean;
	regExp: RegExp;
	namespaceObject?: boolean | "strict";
	addon?: string;
	chunkName?: string;
	include?: RegExp;
	exclude?: RegExp;
	groupOptions?: RawChunkGroupOptions;
	typePrefix?: string;
	category?: string;

	/**
	 * exports referenced from modules (won't be mangled)
	 */
	referencedExports?: null | string[][];
	layer?: string;
	resource: string | false | string[];
	resourceQuery?: string;
	resourceFragment?: string;
	resolveOptions: any;
}
declare class ContextReplacementPlugin {
	constructor(
		resourceRegExp: RegExp,
		newContentResource?: any,
		newContentRecursive?: any,
		newContentRegExp?: any
	);
	resourceRegExp: RegExp;
	newContentCallback: any;
	newContentResource: any;
	newContentCreateContextMap: any;
	newContentRecursive: any;
	newContentRegExp: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ContextTimestampAndHash {
	safeTime: number;
	timestampHash?: string;
	hash: string;
	resolved?: ResolvedContextTimestampAndHash;
	symlinks?: Set<string>;
}
type CreateStatsOptionsContext = KnownCreateStatsOptionsContext &
	Record<string, any>;

/**
 * Options for css handling.
 */
declare interface CssExperimentOptions {
	/**
	 * Avoid generating and loading a stylesheet and only embed exports from css into output javascript files.
	 */
	exportsOnly?: boolean;
}
type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration;
declare class DefinePlugin {
	/**
	 * Create a new define plugin
	 */
	constructor(definitions: Record<string, CodeValue>);
	definitions: Record<string, CodeValue>;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static runtimeValue(
		fn: (arg0: {
			module: NormalModule;
			key: string;
			readonly version?: string;
		}) => CodeValuePrimitive,
		options?: true | string[] | RuntimeValueOptions
	): RuntimeValue;
}
declare class DelegatedPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface DepConstructor {
	new (...args: any[]): Dependency;
}
declare abstract class DependenciesBlock {
	dependencies: Dependency[];
	blocks: AsyncDependenciesBlock[];
	parent?: DependenciesBlock;
	getRootBlock(): DependenciesBlock;

	/**
	 * Adds a DependencyBlock to DependencyBlock relationship.
	 * This is used for when a Module has a AsyncDependencyBlock tie (for code-splitting)
	 */
	addBlock(block: AsyncDependenciesBlock): void;
	addDependency(dependency: Dependency): void;
	removeDependency(dependency: Dependency): void;

	/**
	 * Removes all dependencies and blocks
	 */
	clearDependenciesAndBlocks(): void;
	updateHash(hash: Hash, context: UpdateHashContextDependency): void;
	serialize(__0: ObjectSerializerContext): void;
	deserialize(__0: ObjectDeserializerContext): void;
}
declare interface DependenciesBlockLike {
	dependencies: Dependency[];
	blocks: AsyncDependenciesBlock[];
}
declare class Dependency {
	constructor();
	weak: boolean;
	optional: boolean;
	get type(): string;
	get category(): string;
	loc: DependencyLocation;
	setLoc(
		startLine: number,
		startColumn: number,
		endLine: number,
		endColumn: number
	): void;
	getContext(): undefined | string;
	getResourceIdentifier(): null | string;
	couldAffectReferencingModule(): boolean | typeof TRANSITIVE;

	/**
	 * Returns the referenced module and export
	 */
	getReference(moduleGraph: ModuleGraph): never;

	/**
	 * Returns list of exports referenced by this dependency
	 */
	getReferencedExports(
		moduleGraph: ModuleGraph,
		runtime: RuntimeSpec
	): (string[] | ReferencedExport)[];
	getCondition(
		moduleGraph: ModuleGraph
	):
		| null
		| false
		| ((arg0: ModuleGraphConnection, arg1: RuntimeSpec) => ConnectionState);

	/**
	 * Returns the exported names
	 */
	getExports(moduleGraph: ModuleGraph): undefined | ExportsSpec;

	/**
	 * Returns warnings
	 */
	getWarnings(moduleGraph: ModuleGraph): undefined | null | WebpackError[];

	/**
	 * Returns errors
	 */
	getErrors(moduleGraph: ModuleGraph): undefined | null | WebpackError[];

	/**
	 * Update the hash
	 */
	updateHash(hash: Hash, context: UpdateHashContextDependency): void;

	/**
	 * implement this method to allow the occurrence order plugin to count correctly
	 */
	getNumberOfIdOccurrences(): number;
	getModuleEvaluationSideEffectsState(
		moduleGraph: ModuleGraph
	): ConnectionState;
	createIgnoredModule(context: string): null | Module;
	serialize(__0: ObjectSerializerContext): void;
	deserialize(__0: ObjectDeserializerContext): void;
	module: any;
	get disconnect(): any;
	static NO_EXPORTS_REFERENCED: string[][];
	static EXPORTS_OBJECT_REFERENCED: string[][];
	static TRANSITIVE: typeof TRANSITIVE;
}
declare interface DependencyConstructor {
	new (...args: any[]): Dependency;
}
type DependencyLocation = SyntheticDependencyLocation | RealDependencyLocation;
declare class DependencyTemplate {
	constructor();
	apply(
		dependency: Dependency,
		source: ReplaceSource,
		templateContext: DependencyTemplateContext
	): void;
}
declare interface DependencyTemplateContext {
	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * the requirements for runtime
	 */
	runtimeRequirements: Set<string>;

	/**
	 * current module
	 */
	module: Module;

	/**
	 * current runtimes, for which code is generated
	 */
	runtime: RuntimeSpec;

	/**
	 * mutable array of init fragments for the current module
	 */
	initFragments: InitFragment<GenerateContext>[];

	/**
	 * when in a concatenated module, information about other concatenated modules
	 */
	concatenationScope?: ConcatenationScope;

	/**
	 * the code generation results
	 */
	codeGenerationResults: CodeGenerationResults;
}
declare abstract class DependencyTemplates {
	get(dependency: DependencyConstructor): undefined | DependencyTemplate;
	set(
		dependency: DependencyConstructor,
		dependencyTemplate: DependencyTemplate
	): void;
	updateHash(part: string): void;
	getHash(): string;
	clone(): DependencyTemplates;
}
declare class DeterministicChunkIdsPlugin {
	constructor(options?: DeterministicChunkIdsPluginOptions);
	options: DeterministicChunkIdsPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface DeterministicChunkIdsPluginOptions {
	/**
	 * context for ids
	 */
	context?: string;

	/**
	 * maximum length of ids
	 */
	maxLength?: number;
}
declare class DeterministicModuleIdsPlugin {
	constructor(options?: DeterministicModuleIdsPluginOptions);
	options: DeterministicModuleIdsPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface DeterministicModuleIdsPluginOptions {
	/**
	 * context relative to which module identifiers are computed
	 */
	context?: string;

	/**
	 * selector function for modules
	 */
	test?: (arg0: Module) => boolean;

	/**
	 * maximum id length in digits (used as starting point)
	 */
	maxLength?: number;

	/**
	 * hash salt for ids
	 */
	salt?: number;

	/**
	 * do not increase the maxLength to find an optimal id space size
	 */
	fixedLength?: boolean;

	/**
	 * throw an error when id conflicts occur (instead of rehashing)
	 */
	failOnConflict?: boolean;
}

/**
 * Options for the webpack-dev-server.
 */
declare interface DevServer {
	[index: string]: any;
}
declare class DllPlugin {
	constructor(options: DllPluginOptions);
	options: {
		entryOnly: boolean;
		/**
		 * Context of requests in the manifest file (defaults to the webpack context).
		 */
		context?: string;
		/**
		 * If true, manifest json file (output) will be formatted.
		 */
		format?: boolean;
		/**
		 * Name of the exposed dll function (external name, use value of 'output.library').
		 */
		name?: string;
		/**
		 * Absolute path to the manifest json file (output).
		 */
		path: string;
		/**
		 * Type of the dll bundle (external type, use value of 'output.libraryTarget').
		 */
		type?: string;
	};

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface DllPluginOptions {
	/**
	 * Context of requests in the manifest file (defaults to the webpack context).
	 */
	context?: string;

	/**
	 * If true, only entry points will be exposed (default: true).
	 */
	entryOnly?: boolean;

	/**
	 * If true, manifest json file (output) will be formatted.
	 */
	format?: boolean;

	/**
	 * Name of the exposed dll function (external name, use value of 'output.library').
	 */
	name?: string;

	/**
	 * Absolute path to the manifest json file (output).
	 */
	path: string;

	/**
	 * Type of the dll bundle (external type, use value of 'output.libraryTarget').
	 */
	type?: string;
}
declare class DllReferencePlugin {
	constructor(options: DllReferencePluginOptions);
	options: DllReferencePluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type DllReferencePluginOptions =
	| {
			/**
			 * Context of requests in the manifest (or content property) as absolute path.
			 */
			context?: string;
			/**
			 * Extensions used to resolve modules in the dll bundle (only used when using 'scope').
			 */
			extensions?: string[];
			/**
			 * An object containing content and name or a string to the absolute path of the JSON manifest to be loaded upon compilation.
			 */
			manifest: string | DllReferencePluginOptionsManifest;
			/**
			 * The name where the dll is exposed (external name, defaults to manifest.name).
			 */
			name?: string;
			/**
			 * Prefix which is used for accessing the content of the dll.
			 */
			scope?: string;
			/**
			 * How the dll is exposed (libraryTarget, defaults to manifest.type).
			 */
			sourceType?:
				| "var"
				| "assign"
				| "this"
				| "window"
				| "global"
				| "commonjs"
				| "commonjs2"
				| "commonjs-module"
				| "amd"
				| "amd-require"
				| "umd"
				| "umd2"
				| "jsonp"
				| "system";
			/**
			 * The way how the export of the dll bundle is used.
			 */
			type?: "object" | "require";
	  }
	| {
			/**
			 * The mappings from request to module info.
			 */
			content: DllReferencePluginOptionsContent;
			/**
			 * Context of requests in the manifest (or content property) as absolute path.
			 */
			context?: string;
			/**
			 * Extensions used to resolve modules in the dll bundle (only used when using 'scope').
			 */
			extensions?: string[];
			/**
			 * The name where the dll is exposed (external name).
			 */
			name: string;
			/**
			 * Prefix which is used for accessing the content of the dll.
			 */
			scope?: string;
			/**
			 * How the dll is exposed (libraryTarget).
			 */
			sourceType?:
				| "var"
				| "assign"
				| "this"
				| "window"
				| "global"
				| "commonjs"
				| "commonjs2"
				| "commonjs-module"
				| "amd"
				| "amd-require"
				| "umd"
				| "umd2"
				| "jsonp"
				| "system";
			/**
			 * The way how the export of the dll bundle is used.
			 */
			type?: "object" | "require";
	  };

/**
 * The mappings from request to module info.
 */
declare interface DllReferencePluginOptionsContent {
	[index: string]: {
		/**
		 * Meta information about the module.
		 */
		buildMeta?: { [index: string]: any };
		/**
		 * Information about the provided exports of the module.
		 */
		exports?: true | string[];
		/**
		 * Module ID.
		 */
		id: string | number;
	};
}

/**
 * An object containing content, name and type.
 */
declare interface DllReferencePluginOptionsManifest {
	/**
	 * The mappings from request to module info.
	 */
	content: DllReferencePluginOptionsContent;

	/**
	 * The name where the dll is exposed (external name).
	 */
	name?: string;

	/**
	 * The type how the dll is exposed (external type).
	 */
	type?:
		| "var"
		| "assign"
		| "this"
		| "window"
		| "global"
		| "commonjs"
		| "commonjs2"
		| "commonjs-module"
		| "amd"
		| "amd-require"
		| "umd"
		| "umd2"
		| "jsonp"
		| "system";
}
declare class DynamicEntryPlugin {
	constructor(context: string, entry: () => Promise<EntryStaticNormalized>);
	context: string;
	entry: () => Promise<EntryStaticNormalized>;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface Effect {
	type: string;
	value: any;
}
declare class ElectronTargetPlugin {
	constructor(context?: "main" | "preload" | "renderer");

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}

/**
 * No generator options are supported for this module type.
 */
declare interface EmptyGeneratorOptions {}

/**
 * No parser options are supported for this module type.
 */
declare interface EmptyParserOptions {}
declare class EnableChunkLoadingPlugin {
	constructor(type: string);
	type: string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static setEnabled(compiler: Compiler, type: string): void;
	static checkEnabled(compiler: Compiler, type: string): void;
}
declare class EnableLibraryPlugin {
	constructor(type: string);
	type: string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static setEnabled(compiler: Compiler, type: string): void;
	static checkEnabled(compiler: Compiler, type: string): void;
}
declare class EnableWasmLoadingPlugin {
	constructor(type: string);
	type: string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static setEnabled(compiler: Compiler, type: string): void;
	static checkEnabled(compiler: Compiler, type: string): void;
}
type Entry =
	| string
	| (() => string | EntryObject | string[] | Promise<EntryStatic>)
	| EntryObject
	| string[];
declare interface EntryData {
	/**
	 * dependencies of the entrypoint that should be evaluated at startup
	 */
	dependencies: Dependency[];

	/**
	 * dependencies of the entrypoint that should be included but not evaluated
	 */
	includeDependencies: Dependency[];

	/**
	 * options of the entrypoint
	 */
	options: EntryOptions;
}
declare abstract class EntryDependency extends ModuleDependency {}

/**
 * An object with entry point description.
 */
declare interface EntryDescription {
	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;

	/**
	 * Base uri for this entry.
	 */
	baseUri?: string;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: string | false;

	/**
	 * The entrypoints that the current entrypoint depend on. They must be loaded when this entrypoint is loaded.
	 */
	dependOn?: string | string[];

	/**
	 * Specifies the filename of the output file on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Module(s) that are loaded upon startup.
	 */
	import: EntryItem;

	/**
	 * Specifies the layer in which modules of this entrypoint are placed.
	 */
	layer?: null | string;

	/**
	 * Options for library.
	 */
	library?: LibraryOptions;

	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: string | false;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: string | false;
}

/**
 * An object with entry point description.
 */
declare interface EntryDescriptionNormalized {
	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;

	/**
	 * Base uri for this entry.
	 */
	baseUri?: string;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: string | false;

	/**
	 * The entrypoints that the current entrypoint depend on. They must be loaded when this entrypoint is loaded.
	 */
	dependOn?: string[];

	/**
	 * Specifies the filename of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Module(s) that are loaded upon startup. The last one is exported.
	 */
	import?: string[];

	/**
	 * Specifies the layer in which modules of this entrypoint are placed.
	 */
	layer?: null | string;

	/**
	 * Options for library.
	 */
	library?: LibraryOptions;

	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: string | false;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: string | false;
}
type EntryItem = string | string[];
type EntryNormalized =
	| (() => Promise<EntryStaticNormalized>)
	| EntryStaticNormalized;

/**
 * Multiple entry bundles are created. The key is the entry name. The value can be a string, an array or an entry description object.
 */
declare interface EntryObject {
	[index: string]: string | string[] | EntryDescription;
}
declare class EntryOptionPlugin {
	constructor();
	apply(compiler: Compiler): void;
	static applyEntryOption(
		compiler: Compiler,
		context: string,
		entry: EntryNormalized
	): void;
	static entryDescriptionToOptions(
		compiler: Compiler,
		name: string,
		desc: EntryDescriptionNormalized
	): EntryOptions;
}
type EntryOptions = { name?: string } & Omit<
	EntryDescriptionNormalized,
	"import"
>;
declare class EntryPlugin {
	/**
	 * An entry plugin which will handle
	 * creation of the EntryDependency
	 */
	constructor(context: string, entry: string, options?: string | EntryOptions);
	context: string;
	entry: string;
	options: string | EntryOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static createDependency(
		entry: string,
		options: string | EntryOptions
	): EntryDependency;
}
type EntryStatic = string | EntryObject | string[];

/**
 * Multiple entry bundles are created. The key is the entry name. The value is an entry description object.
 */
declare interface EntryStaticNormalized {
	[index: string]: EntryDescriptionNormalized;
}
declare abstract class Entrypoint extends ChunkGroup {
	/**
	 * Sets the runtimeChunk for an entrypoint.
	 */
	setRuntimeChunk(chunk: Chunk): void;

	/**
	 * Fetches the chunk reference containing the webpack bootstrap code
	 */
	getRuntimeChunk(): null | Chunk;

	/**
	 * Sets the chunk with the entrypoint modules for an entrypoint.
	 */
	setEntrypointChunk(chunk: Chunk): void;

	/**
	 * Returns the chunk which contains the entrypoint modules
	 * (or at least the execution of them)
	 */
	getEntrypointChunk(): Chunk;
}

/**
 * The abilities of the environment where the webpack generated code should run.
 */
declare interface Environment {
	/**
	 * The environment supports arrow functions ('() => { ... }').
	 */
	arrowFunction?: boolean;

	/**
	 * The environment supports BigInt as literal (123n).
	 */
	bigIntLiteral?: boolean;

	/**
	 * The environment supports const and let for variable declarations.
	 */
	const?: boolean;

	/**
	 * The environment supports destructuring ('{ a, b } = obj').
	 */
	destructuring?: boolean;

	/**
	 * The environment supports an async import() function to import EcmaScript modules.
	 */
	dynamicImport?: boolean;

	/**
	 * The environment supports an async import() is available when creating a worker.
	 */
	dynamicImportInWorker?: boolean;

	/**
	 * The environment supports 'for of' iteration ('for (const x of array) { ... }').
	 */
	forOf?: boolean;

	/**
	 * The environment supports 'globalThis'.
	 */
	globalThis?: boolean;

	/**
	 * The environment supports EcmaScript Module syntax to import EcmaScript modules (import ... from '...').
	 */
	module?: boolean;

	/**
	 * The environment supports optional chaining ('obj?.a' or 'obj?.()').
	 */
	optionalChaining?: boolean;

	/**
	 * The environment supports template literals.
	 */
	templateLiteral?: boolean;
}
declare class EnvironmentPlugin {
	constructor(...keys: any[]);
	keys: any[];
	defaultValues: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type ErrorWithDetail = Error & { details?: string };
declare interface Etag {
	toString: () => string;
}
declare class EvalDevToolModulePlugin {
	constructor(options?: any);
	namespace: any;
	sourceUrlComment: any;
	moduleFilenameTemplate: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class EvalSourceMapDevToolPlugin {
	constructor(inputOptions: string | SourceMapDevToolPluginOptions);
	sourceMapComment: string;
	moduleFilenameTemplate: string | Function;
	namespace: string;
	options: SourceMapDevToolPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ExecuteModuleArgument {
	module: Module;
	moduleObject?: { id: string; exports: any; loaded: boolean };
	preparedInfo: any;
	codeGenerationResult: CodeGenerationResult;
}
declare interface ExecuteModuleContext {
	assets: Map<string, { source: Source; info: AssetInfo }>;
	chunk: Chunk;
	chunkGraph: ChunkGraph;
	__webpack_require__?: (arg0: string) => any;
}
declare interface ExecuteModuleOptions {
	entryOptions?: EntryOptions;
}
declare interface ExecuteModuleResult {
	exports: any;
	cacheable: boolean;
	assets: Map<string, { source: Source; info: AssetInfo }>;
	fileDependencies: LazySet<string>;
	contextDependencies: LazySet<string>;
	missingDependencies: LazySet<string>;
	buildDependencies: LazySet<string>;
}
type Experiments = ExperimentsCommon & ExperimentsExtra;

/**
 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
 */
declare interface ExperimentsCommon {
	/**
	 * Support WebAssembly as asynchronous EcmaScript Module.
	 */
	asyncWebAssembly?: boolean;

	/**
	 * Enable backward-compat layer with deprecation warnings for many webpack 4 APIs.
	 */
	backCompat?: boolean;

	/**
	 * Enable additional in memory caching of modules that are unchanged and reference only unchanged modules.
	 */
	cacheUnaffected?: boolean;

	/**
	 * Apply defaults of next major version.
	 */
	futureDefaults?: boolean;

	/**
	 * Enable module layers.
	 */
	layers?: boolean;

	/**
	 * Allow output javascript files as module source type.
	 */
	outputModule?: boolean;

	/**
	 * Support WebAssembly as synchronous EcmaScript Module (outdated).
	 */
	syncWebAssembly?: boolean;

	/**
	 * Allow using top-level-await in EcmaScript Modules.
	 */
	topLevelAwait?: boolean;
}

/**
 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
 */
declare interface ExperimentsExtra {
	/**
	 * Build http(s): urls using a lockfile and resource content cache.
	 */
	buildHttp?: HttpUriOptions | (string | RegExp | ((uri: string) => boolean))[];

	/**
	 * Enable css support.
	 */
	css?: boolean | CssExperimentOptions;

	/**
	 * Compile entrypoints and import()s only when they are accessed.
	 */
	lazyCompilation?: boolean | LazyCompilationOptions;
}
type ExperimentsNormalized = ExperimentsCommon & ExperimentsNormalizedExtra;

/**
 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
 */
declare interface ExperimentsNormalizedExtra {
	/**
	 * Build http(s): urls using a lockfile and resource content cache.
	 */
	buildHttp?: HttpUriOptions;

	/**
	 * Enable css support.
	 */
	css?: false | CssExperimentOptions;

	/**
	 * Compile entrypoints and import()s only when they are accessed.
	 */
	lazyCompilation?: false | LazyCompilationOptions;
}
declare abstract class ExportInfo {
	name: string;

	/**
	 * true: it is provided
	 * false: it is not provided
	 * null: only the runtime knows if it is provided
	 * undefined: it was not determined if it is provided
	 */
	provided?: null | boolean;

	/**
	 * is the export a terminal binding that should be checked for export star conflicts
	 */
	terminalBinding: boolean;

	/**
	 * true: it can be mangled
	 * false: is can not be mangled
	 * undefined: it was not determined if it can be mangled
	 */
	canMangleProvide?: boolean;

	/**
	 * true: it can be mangled
	 * false: is can not be mangled
	 * undefined: it was not determined if it can be mangled
	 */
	canMangleUse?: boolean;
	exportsInfoOwned: boolean;
	exportsInfo?: ExportsInfo;
	get canMangle(): boolean;
	setUsedInUnknownWay(runtime: RuntimeSpec): boolean;
	setUsedWithoutInfo(runtime: RuntimeSpec): boolean;
	setHasUseInfo(): void;
	setUsedConditionally(
		condition: (arg0: UsageStateType) => boolean,
		newValue: UsageStateType,
		runtime: RuntimeSpec
	): boolean;
	setUsed(newValue: UsageStateType, runtime: RuntimeSpec): boolean;
	unsetTarget(key?: any): boolean;
	setTarget(
		key: any,
		connection: ModuleGraphConnection,
		exportName?: string[],
		priority?: number
	): boolean;
	getUsed(runtime: RuntimeSpec): UsageStateType;

	/**
	 * get used name
	 */
	getUsedName(
		fallbackName: undefined | string,
		runtime: RuntimeSpec
	): string | false;
	hasUsedName(): boolean;

	/**
	 * Sets the mangled name of this export
	 */
	setUsedName(name: string): void;
	getTerminalBinding(
		moduleGraph: ModuleGraph,
		resolveTargetFilter?: (arg0: {
			module: Module;
			export?: string[];
		}) => boolean
	): undefined | ExportsInfo | ExportInfo;
	isReexport(): undefined | boolean;
	findTarget(
		moduleGraph: ModuleGraph,
		validTargetModuleFilter: (arg0: Module) => boolean
	): undefined | false | { module: Module; export?: string[] };
	getTarget(
		moduleGraph: ModuleGraph,
		resolveTargetFilter?: (arg0: {
			module: Module;
			export?: string[];
		}) => boolean
	): undefined | { module: Module; export?: string[] };

	/**
	 * Move the target forward as long resolveTargetFilter is fulfilled
	 */
	moveTarget(
		moduleGraph: ModuleGraph,
		resolveTargetFilter: (arg0: {
			module: Module;
			export?: string[];
		}) => boolean,
		updateOriginalConnection?: (arg0: {
			module: Module;
			export?: string[];
		}) => ModuleGraphConnection
	): undefined | { module: Module; export?: string[] };
	createNestedExportsInfo(): undefined | ExportsInfo;
	getNestedExportsInfo(): undefined | ExportsInfo;
	hasInfo(baseInfo?: any, runtime?: any): boolean;
	updateHash(hash?: any, runtime?: any): void;
	getUsedInfo(): string;
	getProvidedInfo():
		| "no provided info"
		| "maybe provided (runtime-defined)"
		| "provided"
		| "not provided";
	getRenameInfo(): string;
}
declare interface ExportSpec {
	/**
	 * the name of the export
	 */
	name: string;

	/**
	 * can the export be renamed (defaults to true)
	 */
	canMangle?: boolean;

	/**
	 * is the export a terminal binding that should be checked for export star conflicts
	 */
	terminalBinding?: boolean;

	/**
	 * nested exports
	 */
	exports?: (string | ExportSpec)[];

	/**
	 * when reexported: from which module
	 */
	from?: ModuleGraphConnection;

	/**
	 * when reexported: from which export
	 */
	export?: null | string[];

	/**
	 * when reexported: with which priority
	 */
	priority?: number;

	/**
	 * export is not visible, because another export blends over it
	 */
	hidden?: boolean;
}
type ExportedVariableInfo = string | ScopeInfo | VariableInfo;
declare abstract class ExportsInfo {
	get ownedExports(): Iterable<ExportInfo>;
	get orderedOwnedExports(): Iterable<ExportInfo>;
	get exports(): Iterable<ExportInfo>;
	get orderedExports(): Iterable<ExportInfo>;
	get otherExportsInfo(): ExportInfo;
	setRedirectNamedTo(exportsInfo?: any): boolean;
	setHasProvideInfo(): void;
	setHasUseInfo(): void;
	getOwnExportInfo(name: string): ExportInfo;
	getExportInfo(name: string): ExportInfo;
	getReadOnlyExportInfo(name: string): ExportInfo;
	getReadOnlyExportInfoRecursive(name: string[]): undefined | ExportInfo;
	getNestedExportsInfo(name?: string[]): undefined | ExportsInfo;
	setUnknownExportsProvided(
		canMangle?: boolean,
		excludeExports?: Set<string>,
		targetKey?: any,
		targetModule?: ModuleGraphConnection,
		priority?: number
	): boolean;
	setUsedInUnknownWay(runtime: RuntimeSpec): boolean;
	setUsedWithoutInfo(runtime: RuntimeSpec): boolean;
	setAllKnownExportsUsed(runtime: RuntimeSpec): boolean;
	setUsedForSideEffectsOnly(runtime: RuntimeSpec): boolean;
	isUsed(runtime: RuntimeSpec): boolean;
	isModuleUsed(runtime: RuntimeSpec): boolean;
	getUsedExports(runtime: RuntimeSpec): null | boolean | SortableSet<string>;
	getProvidedExports(): null | true | string[];
	getRelevantExports(runtime: RuntimeSpec): ExportInfo[];
	isExportProvided(name: string | string[]): undefined | null | boolean;
	getUsageKey(runtime: RuntimeSpec): string;
	isEquallyUsed(runtimeA: RuntimeSpec, runtimeB: RuntimeSpec): boolean;
	getUsed(name: string | string[], runtime: RuntimeSpec): UsageStateType;
	getUsedName(
		name: string | string[],
		runtime: RuntimeSpec
	): string | false | string[];
	updateHash(hash: Hash, runtime: RuntimeSpec): void;
	getRestoreProvidedData(): any;
	restoreProvided(__0: {
		otherProvided: any;
		otherCanMangleProvide: any;
		otherTerminalBinding: any;
		exports: any;
	}): void;
}
declare interface ExportsSpec {
	/**
	 * exported names, true for unknown exports or null for no exports
	 */
	exports: null | true | (string | ExportSpec)[];

	/**
	 * when exports = true, list of unaffected exports
	 */
	excludeExports?: Set<string>;

	/**
	 * list of maybe prior exposed, but now hidden exports
	 */
	hideExports?: Set<string>;

	/**
	 * when reexported: from which module
	 */
	from?: ModuleGraphConnection;

	/**
	 * when reexported: with which priority
	 */
	priority?: number;

	/**
	 * can the export be renamed (defaults to true)
	 */
	canMangle?: boolean;

	/**
	 * are the exports terminal bindings that should be checked for export star conflicts
	 */
	terminalBinding?: boolean;

	/**
	 * module on which the result depends on
	 */
	dependencies?: Module[];
}
type Exposes = (string | ExposesObject)[] | ExposesObject;

/**
 * Advanced configuration for modules that should be exposed by this container.
 */
declare interface ExposesConfig {
	/**
	 * Request to a module that should be exposed by this container.
	 */
	import: string | string[];

	/**
	 * Custom chunk name for the exposed module.
	 */
	name?: string;
}

/**
 * Modules that should be exposed by this container. Property names are used as public paths.
 */
declare interface ExposesObject {
	[index: string]: string | ExposesConfig | string[];
}
type Expression =
	| UnaryExpression
	| ArrayExpression
	| ArrowFunctionExpression
	| AssignmentExpression
	| AwaitExpression
	| BinaryExpression
	| SimpleCallExpression
	| NewExpression
	| ChainExpression
	| ClassExpression
	| ConditionalExpression
	| FunctionExpression
	| Identifier
	| ImportExpression
	| SimpleLiteral
	| RegExpLiteral
	| BigIntLiteral
	| LogicalExpression
	| MemberExpression
	| MetaProperty
	| ObjectExpression
	| SequenceExpression
	| TaggedTemplateExpression
	| TemplateLiteral
	| ThisExpression
	| UpdateExpression
	| YieldExpression;
declare interface ExpressionExpressionInfo {
	type: "expression";
	rootInfo: string | VariableInfo;
	name: string;
	getMembers: () => string[];
	getMembersOptionals: () => boolean[];
	getMemberRanges: () => [number, number][];
}
declare interface ExtensionAliasOption {
	alias: string | string[];
	extension: string;
}
declare interface ExtensionAliasOptions {
	[index: string]: string | string[];
}
type ExternalItem =
	| string
	| RegExp
	| (ExternalItemObjectKnown & ExternalItemObjectUnknown)
	| ((
			data: ExternalItemFunctionData,
			callback: (
				err?: null | Error,
				result?: string | boolean | string[] | { [index: string]: any }
			) => void
	  ) => void)
	| ((data: ExternalItemFunctionData) => Promise<ExternalItemValue>);

/**
 * Data object passed as argument when a function is set for 'externals'.
 */
declare interface ExternalItemFunctionData {
	/**
	 * The directory in which the request is placed.
	 */
	context?: string;

	/**
	 * Contextual information.
	 */
	contextInfo?: ModuleFactoryCreateDataContextInfo;

	/**
	 * The category of the referencing dependencies.
	 */
	dependencyType?: string;

	/**
	 * Get a resolve function with the current resolver options.
	 */
	getResolve?: (
		options?: ResolveOptionsWebpackOptions
	) =>
		| ((
				context: string,
				request: string,
				callback: (err?: Error, result?: string) => void
		  ) => void)
		| ((context: string, request: string) => Promise<string>);

	/**
	 * The request as written by the user in the require/import expression/statement.
	 */
	request?: string;
}

/**
 * If an dependency matches exactly a property of the object, the property value is used as dependency.
 */
declare interface ExternalItemObjectKnown {
	/**
	 * Specify externals depending on the layer.
	 */
	byLayer?:
		| { [index: string]: ExternalItem }
		| ((layer: null | string) => ExternalItem);
}

/**
 * If an dependency matches exactly a property of the object, the property value is used as dependency.
 */
declare interface ExternalItemObjectUnknown {
	[index: string]: ExternalItemValue;
}
type ExternalItemValue = string | boolean | string[] | { [index: string]: any };
declare class ExternalModule extends Module {
	constructor(
		request: string | string[] | Record<string, string | string[]>,
		type: any,
		userRequest: string
	);
	request: string | string[] | Record<string, string | string[]>;
	externalType: string;
	userRequest: string;
	restoreFromUnsafeCache(
		unsafeCacheData?: any,
		normalModuleFactory?: any
	): void;
}
declare interface ExternalModuleInfo {
	index: number;
	module: Module;
}
type Externals =
	| string
	| RegExp
	| ExternalItem[]
	| (ExternalItemObjectKnown & ExternalItemObjectUnknown)
	| ((
			data: ExternalItemFunctionData,
			callback: (
				err?: null | Error,
				result?: string | boolean | string[] | { [index: string]: any }
			) => void
	  ) => void)
	| ((data: ExternalItemFunctionData) => Promise<ExternalItemValue>);
declare class ExternalsPlugin {
	constructor(type: undefined | string, externals: Externals);
	type?: string;
	externals: Externals;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}

/**
 * Enable presets of externals for specific targets.
 */
declare interface ExternalsPresets {
	/**
	 * Treat common electron built-in modules in main and preload context like 'electron', 'ipc' or 'shell' as external and load them via require() when used.
	 */
	electron?: boolean;

	/**
	 * Treat electron built-in modules in the main context like 'app', 'ipc-main' or 'shell' as external and load them via require() when used.
	 */
	electronMain?: boolean;

	/**
	 * Treat electron built-in modules in the preload context like 'web-frame', 'ipc-renderer' or 'shell' as external and load them via require() when used.
	 */
	electronPreload?: boolean;

	/**
	 * Treat electron built-in modules in the renderer context like 'web-frame', 'ipc-renderer' or 'shell' as external and load them via require() when used.
	 */
	electronRenderer?: boolean;

	/**
	 * Treat node.js built-in modules like fs, path or vm as external and load them via require() when used.
	 */
	node?: boolean;

	/**
	 * Treat NW.js legacy nw.gui module as external and load it via require() when used.
	 */
	nwjs?: boolean;

	/**
	 * Treat references to 'http(s)://...' and 'std:...' as external and load them via import when used (Note that this changes execution order as externals are executed before any other code in the chunk).
	 */
	web?: boolean;

	/**
	 * Treat references to 'http(s)://...' and 'std:...' as external and load them via async import() when used (Note that this external type is an async module, which has various effects on the execution).
	 */
	webAsync?: boolean;
}
type ExternalsType =
	| "import"
	| "var"
	| "module"
	| "assign"
	| "this"
	| "window"
	| "self"
	| "global"
	| "commonjs"
	| "commonjs2"
	| "commonjs-module"
	| "commonjs-static"
	| "amd"
	| "amd-require"
	| "umd"
	| "umd2"
	| "jsonp"
	| "system"
	| "promise"
	| "script"
	| "node-commonjs";
declare interface FactorizeModuleOptions {
	currentProfile: ModuleProfile;
	factory: ModuleFactory;
	dependencies: Dependency[];

	/**
	 * return full ModuleFactoryResult instead of only module
	 */
	factoryResult?: boolean;
	originModule: null | Module;
	contextInfo?: Partial<ModuleFactoryCreateDataContextInfo>;
	context?: string;
}
declare interface FactoryMeta {
	sideEffectFree?: boolean;
}
type FakeHook<T> = T & FakeHookMarker;
declare interface FakeHookMarker {}
declare interface FallbackCacheGroup {
	chunksFilter: (chunk: Chunk) => undefined | boolean;
	minSize: SplitChunksSizes;
	maxAsyncSize: SplitChunksSizes;
	maxInitialSize: SplitChunksSizes;
	automaticNameDelimiter: string;
}
declare class FetchCompileAsyncWasmPlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class FetchCompileWasmPlugin {
	constructor(options?: FetchCompileWasmPluginOptions);
	options: FetchCompileWasmPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface FetchCompileWasmPluginOptions {
	/**
	 * mangle imports
	 */
	mangleImports?: boolean;
}

/**
 * Options object for persistent file-based caching.
 */
declare interface FileCacheOptions {
	/**
	 * Allows to collect unused memory allocated during deserialization. This requires copying data into smaller buffers and has a performance cost.
	 */
	allowCollectingMemory?: boolean;

	/**
	 * Dependencies the build depends on (in multiple categories, default categories: 'defaultWebpack').
	 */
	buildDependencies?: { [index: string]: string[] };

	/**
	 * Base directory for the cache (defaults to node_modules/.cache/webpack).
	 */
	cacheDirectory?: string;

	/**
	 * Locations for the cache (defaults to cacheDirectory / name).
	 */
	cacheLocation?: string;

	/**
	 * Compression type used for the cache files.
	 */
	compression?: false | "gzip" | "brotli";

	/**
	 * Algorithm used for generation the hash (see node.js crypto package).
	 */
	hashAlgorithm?: string;

	/**
	 * Time in ms after which idle period the cache storing should happen.
	 */
	idleTimeout?: number;

	/**
	 * Time in ms after which idle period the cache storing should happen when larger changes has been detected (cumulative build time > 2 x avg cache store time).
	 */
	idleTimeoutAfterLargeChanges?: number;

	/**
	 * Time in ms after which idle period the initial cache storing should happen.
	 */
	idleTimeoutForInitialStore?: number;

	/**
	 * List of paths that are managed by a package manager and contain a version or hash in its path so all files are immutable.
	 */
	immutablePaths?: (string | RegExp)[];

	/**
	 * List of paths that are managed by a package manager and can be trusted to not be modified otherwise.
	 */
	managedPaths?: (string | RegExp)[];

	/**
	 * Time for which unused cache entries stay in the filesystem cache at minimum (in milliseconds).
	 */
	maxAge?: number;

	/**
	 * Number of generations unused cache entries stay in memory cache at minimum (0 = no memory cache used, 1 = may be removed after unused for a single compilation, ..., Infinity: kept forever). Cache entries will be deserialized from disk when removed from memory cache.
	 */
	maxMemoryGenerations?: number;

	/**
	 * Additionally cache computation of modules that are unchanged and reference only unchanged modules in memory.
	 */
	memoryCacheUnaffected?: boolean;

	/**
	 * Name for the cache. Different names will lead to different coexisting caches.
	 */
	name?: string;

	/**
	 * Track and log detailed timing information for individual cache items.
	 */
	profile?: boolean;

	/**
	 * Enable/disable readonly mode.
	 */
	readonly?: boolean;

	/**
	 * When to store data to the filesystem. (pack: Store data when compiler is idle in a single file).
	 */
	store?: "pack";

	/**
	 * Filesystem caching.
	 */
	type: "filesystem";

	/**
	 * Version of the cache data. Different versions won't allow to reuse the cache and override existing content. Update the version when config changed in a way which doesn't allow to reuse cache. This will invalidate the cache.
	 */
	version?: string;
}
declare interface FileSystem {
	readFile: {
		(arg0: string, arg1: FileSystemCallback<string | Buffer>): void;
		(
			arg0: string,
			arg1: object,
			arg2: FileSystemCallback<string | Buffer>
		): void;
	};
	readdir: (
		arg0: string,
		arg1?:
			| null
			| "ascii"
			| "utf8"
			| "utf16le"
			| "ucs2"
			| "latin1"
			| "binary"
			| ((
					arg0?: null | NodeJS.ErrnoException,
					arg1?: (string | Buffer)[] | (typeof Dirent)[]
			  ) => void)
			| ReaddirOptions
			| "utf-8"
			| "ucs-2"
			| "base64"
			| "base64url"
			| "hex"
			| "buffer",
		arg2?: (
			arg0?: null | NodeJS.ErrnoException,
			arg1?: (string | Buffer)[] | (typeof Dirent)[]
		) => void
	) => void;
	readJson?: {
		(arg0: string, arg1: FileSystemCallback<object>): void;
		(arg0: string, arg1: object, arg2: FileSystemCallback<object>): void;
	};
	readlink: {
		(arg0: string, arg1: FileSystemCallback<string | Buffer>): void;
		(
			arg0: string,
			arg1: object,
			arg2: FileSystemCallback<string | Buffer>
		): void;
	};
	lstat?: {
		(arg0: string, arg1: FileSystemCallback<FileSystemStats>): void;
		(
			arg0: string,
			arg1: object,
			arg2: FileSystemCallback<string | Buffer>
		): void;
	};
	stat: {
		(arg0: string, arg1: FileSystemCallback<FileSystemStats>): void;
		(
			arg0: string,
			arg1: object,
			arg2: FileSystemCallback<string | Buffer>
		): void;
	};
}
declare interface FileSystemCallback<T> {
	(err?: null | (PossibleFileSystemError & Error), result?: T): any;
}
declare abstract class FileSystemInfo {
	fs: InputFileSystem;
	logger?: WebpackLogger;
	fileTimestampQueue: AsyncQueue<string, string, null | FileSystemInfoEntry>;
	fileHashQueue: AsyncQueue<string, string, null | string>;
	contextTimestampQueue: AsyncQueue<
		string,
		string,
		null | ContextFileSystemInfoEntry
	>;
	contextHashQueue: AsyncQueue<string, string, null | ContextHash>;
	contextTshQueue: AsyncQueue<string, string, null | ContextTimestampAndHash>;
	managedItemQueue: AsyncQueue<string, string, null | string>;
	managedItemDirectoryQueue: AsyncQueue<string, string, Set<string>>;
	managedPaths: (string | RegExp)[];
	managedPathsWithSlash: string[];
	managedPathsRegExps: RegExp[];
	immutablePaths: (string | RegExp)[];
	immutablePathsWithSlash: string[];
	immutablePathsRegExps: RegExp[];
	logStatistics(): void;
	clear(): void;
	addFileTimestamps(
		map: ReadonlyMap<string, null | FileSystemInfoEntry | "ignore">,
		immutable?: boolean
	): void;
	addContextTimestamps(
		map: ReadonlyMap<string, null | FileSystemInfoEntry | "ignore">,
		immutable?: boolean
	): void;
	getFileTimestamp(
		path: string,
		callback: (
			arg0?: null | WebpackError,
			arg1?: null | FileSystemInfoEntry | "ignore"
		) => void
	): void;
	getContextTimestamp(
		path: string,
		callback: (
			arg0?: null | WebpackError,
			arg1?: null | "ignore" | ResolvedContextFileSystemInfoEntry
		) => void
	): void;
	getFileHash(
		path: string,
		callback: (arg0?: null | WebpackError, arg1?: null | string) => void
	): void;
	getContextHash(
		path: string,
		callback: (arg0?: null | WebpackError, arg1?: string) => void
	): void;
	getContextTsh(
		path: string,
		callback: (
			arg0?: null | WebpackError,
			arg1?: ResolvedContextTimestampAndHash
		) => void
	): void;
	resolveBuildDependencies(
		context: string,
		deps: Iterable<string>,
		callback: (
			arg0?: null | Error,
			arg1?: ResolveBuildDependenciesResult
		) => void
	): void;
	checkResolveResultsValid(
		resolveResults: Map<string, string | false>,
		callback: (arg0?: null | Error, arg1?: boolean) => void
	): void;
	createSnapshot(
		startTime: undefined | null | number,
		files: Iterable<string>,
		directories: Iterable<string>,
		missing: Iterable<string>,
		options: undefined | null | SnapshotOptionsFileSystemInfo,
		callback: (arg0?: null | WebpackError, arg1?: null | Snapshot) => void
	): void;
	mergeSnapshots(snapshot1: Snapshot, snapshot2: Snapshot): Snapshot;
	checkSnapshotValid(
		snapshot: Snapshot,
		callback: (arg0?: null | WebpackError, arg1?: boolean) => void
	): void;
	getDeprecatedFileTimestamps(): Map<any, any>;
	getDeprecatedContextTimestamps(): Map<any, any>;
}
declare interface FileSystemInfoEntry {
	safeTime: number;
	timestamp?: number;
}
declare interface FileSystemStats {
	isDirectory: () => boolean;
	isFile: () => boolean;
}
type FilterItemTypes = string | RegExp | ((value: string) => boolean);
declare interface GenerateContext {
	/**
	 * mapping from dependencies to templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * the requirements for runtime
	 */
	runtimeRequirements: Set<string>;

	/**
	 * the runtime
	 */
	runtime: RuntimeSpec;

	/**
	 * when in concatenated module, information about other concatenated modules
	 */
	concatenationScope?: ConcatenationScope;

	/**
	 * code generation results of other modules (need to have a codeGenerationDependency to use that)
	 */
	codeGenerationResults?: CodeGenerationResults;

	/**
	 * which kind of code should be generated
	 */
	type: string;

	/**
	 * get access to the code generation data
	 */
	getData?: () => Map<string, any>;
}
declare class Generator {
	constructor();
	getTypes(module: NormalModule): Set<string>;
	getSize(module: NormalModule, type?: string): number;
	generate(module: NormalModule, __1: GenerateContext): Source;
	getConcatenationBailoutReason(
		module: NormalModule,
		context: ConcatenationBailoutReasonContext
	): undefined | string;
	updateHash(hash: Hash, __1: UpdateHashContextGenerator): void;
	static byType(map: Record<string, Generator>): ByTypeGenerator;
}
type GeneratorOptionsByModuleType = GeneratorOptionsByModuleTypeKnown &
	GeneratorOptionsByModuleTypeUnknown;

/**
 * Specify options for each generator.
 */
declare interface GeneratorOptionsByModuleTypeKnown {
	/**
	 * Generator options for asset modules.
	 */
	asset?: AssetGeneratorOptions;

	/**
	 * Generator options for asset/inline modules.
	 */
	"asset/inline"?: AssetInlineGeneratorOptions;

	/**
	 * Generator options for asset/resource modules.
	 */
	"asset/resource"?: AssetResourceGeneratorOptions;

	/**
	 * No generator options are supported for this module type.
	 */
	javascript?: EmptyGeneratorOptions;

	/**
	 * No generator options are supported for this module type.
	 */
	"javascript/auto"?: EmptyGeneratorOptions;

	/**
	 * No generator options are supported for this module type.
	 */
	"javascript/dynamic"?: EmptyGeneratorOptions;

	/**
	 * No generator options are supported for this module type.
	 */
	"javascript/esm"?: EmptyGeneratorOptions;
}

/**
 * Specify options for each generator.
 */
declare interface GeneratorOptionsByModuleTypeUnknown {
	[index: string]: { [index: string]: any };
}
declare class GetChunkFilenameRuntimeModule extends RuntimeModule {
	constructor(
		contentType: string,
		name: string,
		global: string,
		getFilenameForChunk: (
			arg0: Chunk
		) => string | ((arg0: PathData, arg1?: AssetInfo) => string),
		allChunks: boolean
	);
	contentType: string;
	global: string;
	getFilenameForChunk: (
		arg0: Chunk
	) => string | ((arg0: PathData, arg1?: AssetInfo) => string);
	allChunks: boolean;

	/**
	 * Runtime modules without any dependencies to other runtime modules
	 */
	static STAGE_NORMAL: number;

	/**
	 * Runtime modules with simple dependencies on other runtime modules
	 */
	static STAGE_BASIC: number;

	/**
	 * Runtime modules which attach to handlers of other runtime modules
	 */
	static STAGE_ATTACH: number;

	/**
	 * Runtime modules which trigger actions on bootstrap
	 */
	static STAGE_TRIGGER: number;
}
declare interface GroupConfig {
	getKeys: (arg0?: any) => string[];
	createGroup: (arg0: string, arg1: any[], arg2: any[]) => object;
	getOptions?: (arg0: string, arg1: any[]) => GroupOptions;
}
declare interface GroupOptions {
	groupChildren?: boolean;
	force?: boolean;
	targetGroupCount?: number;
}
declare interface HMRJavascriptParserHooks {
	hotAcceptCallback: SyncBailHook<[any, string[]], void>;
	hotAcceptWithoutCallback: SyncBailHook<[any, string[]], void>;
}
declare interface HandleModuleCreationOptions {
	factory: ModuleFactory;
	dependencies: Dependency[];
	originModule: null | Module;
	contextInfo?: Partial<ModuleFactoryCreateDataContextInfo>;
	context?: string;

	/**
	 * recurse into dependencies of the created module
	 */
	recursive?: boolean;

	/**
	 * connect the resolved module with the origin module
	 */
	connectOrigin?: boolean;
}
declare class HarmonyImportDependency extends ModuleDependency {
	constructor(request: string, sourceOrder: number, assertions?: Assertions);
	sourceOrder: number;
	getImportVar(moduleGraph: ModuleGraph): string;
	getImportStatement(
		update: boolean,
		__1: DependencyTemplateContext
	): [string, string];
	getLinkingErrors(
		moduleGraph: ModuleGraph,
		ids: string[],
		additionalMessage: string
	): undefined | WebpackError[];
	static Template: typeof HarmonyImportDependencyTemplate;
	static ExportPresenceModes: {
		NONE: 0;
		WARN: 1;
		AUTO: 2;
		ERROR: 3;
		fromUserOption(str?: any): 0 | 1 | 2 | 3;
	};
	static NO_EXPORTS_REFERENCED: string[][];
	static EXPORTS_OBJECT_REFERENCED: string[][];
	static TRANSITIVE: typeof TRANSITIVE;
}
declare class HarmonyImportDependencyTemplate extends DependencyTemplate {
	constructor();
	static getImportEmittedRuntime(
		module: Module,
		referencedModule: Module
	): undefined | string | boolean | SortableSet<string>;
}
declare class Hash {
	constructor();

	/**
	 * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
	 */
	update(data: string | Buffer, inputEncoding?: string): Hash;

	/**
	 * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
	 */
	digest(encoding?: string): string | Buffer;
}
declare interface HashableObject {
	updateHash: (arg0: Hash) => void;
}
declare class HashedModuleIdsPlugin {
	constructor(options?: HashedModuleIdsPluginOptions);
	options: HashedModuleIdsPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface HashedModuleIdsPluginOptions {
	/**
	 * The context directory for creating names.
	 */
	context?: string;

	/**
	 * The encoding to use when generating the hash, defaults to 'base64'. All encodings from Node.JS' hash.digest are supported.
	 */
	hashDigest?: "latin1" | "base64" | "hex";

	/**
	 * The prefix length of the hash digest to use, defaults to 4.
	 */
	hashDigestLength?: number;

	/**
	 * The hashing algorithm to use, defaults to 'md4'. All functions from Node.JS' crypto.createHash are supported.
	 */
	hashFunction?: string | typeof Hash;
}
declare abstract class HelperRuntimeModule extends RuntimeModule {}
declare class HotModuleReplacementPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static getParserHooks(parser: JavascriptParser): HMRJavascriptParserHooks;
}

/**
 * These properties are added by the HotModuleReplacementPlugin
 */
declare interface HotModuleReplacementPluginLoaderContext {
	hot?: boolean;
}
declare class HotUpdateChunk extends Chunk {
	constructor();
}

/**
 * Options for building http resources.
 */
declare interface HttpUriOptions {
	/**
	 * List of allowed URIs (resp. the beginning of them).
	 */
	allowedUris: (string | RegExp | ((uri: string) => boolean))[];

	/**
	 * Location where resource content is stored for lockfile entries. It's also possible to disable storing by passing false.
	 */
	cacheLocation?: string | false;

	/**
	 * When set, anything that would lead to a modification of the lockfile or any resource content, will result in an error.
	 */
	frozen?: boolean;

	/**
	 * Location of the lockfile.
	 */
	lockfileLocation?: string;

	/**
	 * Proxy configuration, which can be used to specify a proxy server to use for HTTP requests.
	 */
	proxy?: string;

	/**
	 * When set, resources of existing lockfile entries will be fetched and entries will be upgraded when resource content has changed.
	 */
	upgrade?: boolean;
}
declare class HttpUriPlugin {
	constructor(options: HttpUriOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface IDirent {
	isFile: () => boolean;
	isDirectory: () => boolean;
	isBlockDevice: () => boolean;
	isCharacterDevice: () => boolean;
	isSymbolicLink: () => boolean;
	isFIFO: () => boolean;
	isSocket: () => boolean;
	name: string | Buffer;
}
declare interface IStats {
	isFile: () => boolean;
	isDirectory: () => boolean;
	isBlockDevice: () => boolean;
	isCharacterDevice: () => boolean;
	isSymbolicLink: () => boolean;
	isFIFO: () => boolean;
	isSocket: () => boolean;
	dev: number | bigint;
	ino: number | bigint;
	mode: number | bigint;
	nlink: number | bigint;
	uid: number | bigint;
	gid: number | bigint;
	rdev: number | bigint;
	size: number | bigint;
	blksize: number | bigint;
	blocks: number | bigint;
	atimeMs: number | bigint;
	mtimeMs: number | bigint;
	ctimeMs: number | bigint;
	birthtimeMs: number | bigint;
	atime: Date;
	mtime: Date;
	ctime: Date;
	birthtime: Date;
}
declare class IgnorePlugin {
	constructor(options: IgnorePluginOptions);
	options: IgnorePluginOptions;

	/**
	 * Note that if "contextRegExp" is given, both the "resourceRegExp"
	 * and "contextRegExp" have to match.
	 */
	checkIgnore(resolveData: ResolveData): undefined | false;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type IgnorePluginOptions =
	| {
			/**
			 * A RegExp to test the context (directory) against.
			 */
			contextRegExp?: RegExp;
			/**
			 * A RegExp to test the request against.
			 */
			resourceRegExp: RegExp;
	  }
	| {
			/**
			 * A filter function for resource and context.
			 */
			checkResource: (resource: string, context: string) => boolean;
	  };
declare interface ImportModuleOptions {
	/**
	 * the target layer
	 */
	layer?: string;

	/**
	 * the target public path
	 */
	publicPath?: string;

	/**
	 * target base uri
	 */
	baseUri?: string;
}
type ImportSource =
	| undefined
	| null
	| string
	| SimpleLiteral
	| RegExpLiteral
	| BigIntLiteral;

/**
 * Options for infrastructure level logging.
 */
declare interface InfrastructureLogging {
	/**
	 * Only appends lines to the output. Avoids updating existing output e. g. for status messages. This option is only used when no custom console is provided.
	 */
	appendOnly?: boolean;

	/**
	 * Enables/Disables colorful output. This option is only used when no custom console is provided.
	 */
	colors?: boolean;

	/**
	 * Custom console used for logging.
	 */
	console?: Console;

	/**
	 * Enable debug logging for specific loggers.
	 */
	debug?:
		| string
		| boolean
		| RegExp
		| FilterItemTypes[]
		| ((value: string) => boolean);

	/**
	 * Log level.
	 */
	level?: "none" | "error" | "warn" | "info" | "log" | "verbose";

	/**
	 * Stream used for logging output. Defaults to process.stderr. This option is only used when no custom console is provided.
	 */
	stream?: NodeJS.WritableStream;
}
declare abstract class InitFragment<Context> {
	content: string | Source;
	stage: number;
	position: number;
	key?: string;
	endContent?: string | Source;
	getContent(context: Context): string | Source;
	getEndContent(context: Context): undefined | string | Source;
	serialize(context: ObjectSerializerContext): void;
	deserialize(context: ObjectDeserializerContext): void;
	merge: any;
}
declare interface InputFileSystem {
	readFile: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: string | Buffer) => void
	) => void;
	readJson?: (
		arg0: string,
		arg1: (arg0?: null | Error | NodeJS.ErrnoException, arg1?: any) => void
	) => void;
	readlink: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: string | Buffer) => void
	) => void;
	readdir: (
		arg0: string,
		arg1: (
			arg0?: null | NodeJS.ErrnoException,
			arg1?: (string | Buffer)[] | IDirent[]
		) => void
	) => void;
	stat: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: IStats) => void
	) => void;
	lstat?: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: IStats) => void
	) => void;
	realpath?: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: string | Buffer) => void
	) => void;
	purge?: (arg0?: string) => void;
	join?: (arg0: string, arg1: string) => string;
	relative?: (arg0: string, arg1: string) => string;
	dirname?: (arg0: string) => string;
}
type IntermediateFileSystem = InputFileSystem &
	OutputFileSystem &
	IntermediateFileSystemExtras;
declare interface IntermediateFileSystemExtras {
	mkdirSync: (arg0: string) => void;
	createWriteStream: (arg0: string) => NodeJS.WritableStream;
	open: (
		arg0: string,
		arg1: string,
		arg2: (arg0?: null | NodeJS.ErrnoException, arg1?: number) => void
	) => void;
	read: (
		arg0: number,
		arg1: Buffer,
		arg2: number,
		arg3: number,
		arg4: number,
		arg5: (arg0?: null | NodeJS.ErrnoException, arg1?: number) => void
	) => void;
	close: (
		arg0: number,
		arg1: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
	rename: (
		arg0: string,
		arg1: string,
		arg2: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
}
type InternalCell<T> = T | typeof TOMBSTONE | typeof UNDEFINED_MARKER;
declare abstract class ItemCacheFacade {
	get<T>(callback: CallbackCache<T>): void;
	getPromise<T>(): Promise<T>;
	store<T>(data: T, callback: CallbackCache<void>): void;
	storePromise<T>(data: T): Promise<void>;
	provide<T>(
		computer: (arg0: CallbackNormalErrorCache<T>) => void,
		callback: CallbackNormalErrorCache<T>
	): void;
	providePromise<T>(computer: () => T | Promise<T>): Promise<T>;
}
declare class JavascriptModulesPlugin {
	constructor(options?: object);
	options: object;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	renderModule(
		module: Module,
		renderContext: ChunkRenderContext,
		hooks: CompilationHooksJavascriptModulesPlugin,
		factory: boolean
	): Source;
	renderChunk(
		renderContext: RenderContext,
		hooks: CompilationHooksJavascriptModulesPlugin
	): Source;
	renderMain(
		renderContext: MainRenderContext,
		hooks: CompilationHooksJavascriptModulesPlugin,
		compilation: Compilation
	): Source;
	updateHashWithBootstrap(
		hash: Hash,
		renderContext: RenderBootstrapContext,
		hooks: CompilationHooksJavascriptModulesPlugin
	): void;
	renderBootstrap(
		renderContext: RenderBootstrapContext,
		hooks: CompilationHooksJavascriptModulesPlugin
	): {
		header: string[];
		beforeStartup: string[];
		startup: string[];
		afterStartup: string[];
		allowInlineStartup: boolean;
	};
	renderRequire(
		renderContext: RenderBootstrapContext,
		hooks: CompilationHooksJavascriptModulesPlugin
	): string;
	static getCompilationHooks(
		compilation: Compilation
	): CompilationHooksJavascriptModulesPlugin;
	static getChunkFilenameTemplate(chunk?: any, outputOptions?: any): any;
	static chunkHasJs: (chunk: Chunk, chunkGraph: ChunkGraph) => boolean;
}
declare class JavascriptParser extends Parser {
	constructor(sourceType?: "module" | "auto" | "script");
	hooks: Readonly<{
		evaluateTypeof: HookMap<
			SyncBailHook<
				[UnaryExpression],
				undefined | null | BasicEvaluatedExpression
			>
		>;
		evaluate: HookMap<
			SyncBailHook<[Expression], undefined | null | BasicEvaluatedExpression>
		>;
		evaluateIdentifier: HookMap<
			SyncBailHook<
				[Identifier | MemberExpression | MetaProperty | ThisExpression],
				undefined | null | BasicEvaluatedExpression
			>
		>;
		evaluateDefinedIdentifier: HookMap<
			SyncBailHook<
				[Identifier | MemberExpression | ThisExpression],
				undefined | null | BasicEvaluatedExpression
			>
		>;
		evaluateNewExpression: HookMap<
			SyncBailHook<[NewExpression], undefined | null | BasicEvaluatedExpression>
		>;
		evaluateCallExpression: HookMap<
			SyncBailHook<
				[CallExpression],
				undefined | null | BasicEvaluatedExpression
			>
		>;
		evaluateCallExpressionMember: HookMap<
			SyncBailHook<
				[CallExpression, undefined | BasicEvaluatedExpression],
				undefined | null | BasicEvaluatedExpression
			>
		>;
		isPure: HookMap<
			SyncBailHook<
				[
					(
						| UnaryExpression
						| ArrayExpression
						| ArrowFunctionExpression
						| AssignmentExpression
						| AwaitExpression
						| BinaryExpression
						| SimpleCallExpression
						| NewExpression
						| ChainExpression
						| ClassExpression
						| ConditionalExpression
						| FunctionExpression
						| Identifier
						| ImportExpression
						| SimpleLiteral
						| RegExpLiteral
						| BigIntLiteral
						| LogicalExpression
						| MemberExpression
						| MetaProperty
						| ObjectExpression
						| SequenceExpression
						| TaggedTemplateExpression
						| TemplateLiteral
						| ThisExpression
						| UpdateExpression
						| YieldExpression
						| FunctionDeclaration
						| VariableDeclaration
						| ClassDeclaration
						| PrivateIdentifier
					),
					number
				],
				boolean | void
			>
		>;
		preStatement: SyncBailHook<
			[
				| FunctionDeclaration
				| VariableDeclaration
				| ClassDeclaration
				| ExpressionStatement
				| BlockStatement
				| StaticBlock
				| EmptyStatement
				| DebuggerStatement
				| WithStatement
				| ReturnStatement
				| LabeledStatement
				| BreakStatement
				| ContinueStatement
				| IfStatement
				| SwitchStatement
				| ThrowStatement
				| TryStatement
				| WhileStatement
				| DoWhileStatement
				| ForStatement
				| ForInStatement
				| ForOfStatement
				| ImportDeclaration
				| ExportNamedDeclaration
				| ExportDefaultDeclaration
				| ExportAllDeclaration
			],
			boolean | void
		>;
		blockPreStatement: SyncBailHook<
			[
				| FunctionDeclaration
				| VariableDeclaration
				| ClassDeclaration
				| ExpressionStatement
				| BlockStatement
				| StaticBlock
				| EmptyStatement
				| DebuggerStatement
				| WithStatement
				| ReturnStatement
				| LabeledStatement
				| BreakStatement
				| ContinueStatement
				| IfStatement
				| SwitchStatement
				| ThrowStatement
				| TryStatement
				| WhileStatement
				| DoWhileStatement
				| ForStatement
				| ForInStatement
				| ForOfStatement
				| ImportDeclaration
				| ExportNamedDeclaration
				| ExportDefaultDeclaration
				| ExportAllDeclaration
			],
			boolean | void
		>;
		statement: SyncBailHook<
			[
				| FunctionDeclaration
				| VariableDeclaration
				| ClassDeclaration
				| ExpressionStatement
				| BlockStatement
				| StaticBlock
				| EmptyStatement
				| DebuggerStatement
				| WithStatement
				| ReturnStatement
				| LabeledStatement
				| BreakStatement
				| ContinueStatement
				| IfStatement
				| SwitchStatement
				| ThrowStatement
				| TryStatement
				| WhileStatement
				| DoWhileStatement
				| ForStatement
				| ForInStatement
				| ForOfStatement
				| ImportDeclaration
				| ExportNamedDeclaration
				| ExportDefaultDeclaration
				| ExportAllDeclaration
			],
			boolean | void
		>;
		statementIf: SyncBailHook<[IfStatement], boolean | void>;
		classExtendsExpression: SyncBailHook<
			[Expression, ClassExpression | ClassDeclaration],
			boolean | void
		>;
		classBodyElement: SyncBailHook<
			[
				StaticBlock | MethodDefinition | PropertyDefinition,
				ClassExpression | ClassDeclaration
			],
			boolean | void
		>;
		classBodyValue: SyncBailHook<
			[
				Expression,
				MethodDefinition | PropertyDefinition,
				ClassExpression | ClassDeclaration
			],
			boolean | void
		>;
		label: HookMap<SyncBailHook<[LabeledStatement], boolean | void>>;
		import: SyncBailHook<[ImportDeclaration, ImportSource], boolean | void>;
		importSpecifier: SyncBailHook<
			[ImportDeclaration, ImportSource, string, string],
			boolean | void
		>;
		export: SyncBailHook<
			[ExportNamedDeclaration | ExportAllDeclaration],
			boolean | void
		>;
		exportImport: SyncBailHook<
			[ExportNamedDeclaration | ExportAllDeclaration, ImportSource],
			boolean | void
		>;
		exportDeclaration: SyncBailHook<
			[ExportNamedDeclaration | ExportAllDeclaration, Declaration],
			boolean | void
		>;
		exportExpression: SyncBailHook<
			[ExportDefaultDeclaration, Declaration],
			boolean | void
		>;
		exportSpecifier: SyncBailHook<
			[
				ExportNamedDeclaration | ExportAllDeclaration,
				string,
				string,
				undefined | number
			],
			boolean | void
		>;
		exportImportSpecifier: SyncBailHook<
			[
				ExportNamedDeclaration | ExportAllDeclaration,
				ImportSource,
				string,
				string,
				undefined | number
			],
			boolean | void
		>;
		preDeclarator: SyncBailHook<
			[VariableDeclarator, Statement],
			boolean | void
		>;
		declarator: SyncBailHook<[VariableDeclarator, Statement], boolean | void>;
		varDeclaration: HookMap<SyncBailHook<[Declaration], boolean | void>>;
		varDeclarationLet: HookMap<SyncBailHook<[Declaration], boolean | void>>;
		varDeclarationConst: HookMap<SyncBailHook<[Declaration], boolean | void>>;
		varDeclarationVar: HookMap<SyncBailHook<[Declaration], boolean | void>>;
		pattern: HookMap<SyncBailHook<[Identifier], boolean | void>>;
		canRename: HookMap<SyncBailHook<[Expression], boolean | void>>;
		rename: HookMap<SyncBailHook<[Expression], boolean | void>>;
		assign: HookMap<SyncBailHook<[AssignmentExpression], boolean | void>>;
		assignMemberChain: HookMap<
			SyncBailHook<[AssignmentExpression, string[]], boolean | void>
		>;
		typeof: HookMap<SyncBailHook<[Expression], boolean | void>>;
		importCall: SyncBailHook<[ImportExpression], boolean | void>;
		topLevelAwait: SyncBailHook<[Expression], boolean | void>;
		call: HookMap<SyncBailHook<[CallExpression], boolean | void>>;
		callMemberChain: HookMap<
			SyncBailHook<
				[CallExpression, string[], boolean[], [number, number][]],
				boolean | void
			>
		>;
		memberChainOfCallMemberChain: HookMap<
			SyncBailHook<
				[Expression, string[], CallExpression, string[]],
				boolean | void
			>
		>;
		callMemberChainOfCallMemberChain: HookMap<
			SyncBailHook<
				[CallExpression, string[], CallExpression, string[]],
				boolean | void
			>
		>;
		optionalChaining: SyncBailHook<[ChainExpression], boolean | void>;
		new: HookMap<SyncBailHook<[NewExpression], boolean | void>>;
		binaryExpression: SyncBailHook<[BinaryExpression], boolean | void>;
		expression: HookMap<SyncBailHook<[Expression], boolean | void>>;
		expressionMemberChain: HookMap<
			SyncBailHook<
				[MemberExpression, string[], boolean[], [number, number][]],
				boolean | void
			>
		>;
		unhandledExpressionMemberChain: HookMap<
			SyncBailHook<[MemberExpression, string[]], boolean | void>
		>;
		expressionConditionalOperator: SyncBailHook<
			[ConditionalExpression],
			boolean | void
		>;
		expressionLogicalOperator: SyncBailHook<
			[LogicalExpression],
			boolean | void
		>;
		program: SyncBailHook<[Program, Comment[]], boolean | void>;
		finish: SyncBailHook<[Program, Comment[]], boolean | void>;
	}>;
	sourceType: "module" | "auto" | "script";
	scope: ScopeInfo;
	state: ParserState;
	comments: any;
	semicolons: any;
	statementPath: (
		| UnaryExpression
		| ArrayExpression
		| ArrowFunctionExpression
		| AssignmentExpression
		| AwaitExpression
		| BinaryExpression
		| SimpleCallExpression
		| NewExpression
		| ChainExpression
		| ClassExpression
		| ConditionalExpression
		| FunctionExpression
		| Identifier
		| ImportExpression
		| SimpleLiteral
		| RegExpLiteral
		| BigIntLiteral
		| LogicalExpression
		| MemberExpression
		| MetaProperty
		| ObjectExpression
		| SequenceExpression
		| TaggedTemplateExpression
		| TemplateLiteral
		| ThisExpression
		| UpdateExpression
		| YieldExpression
		| FunctionDeclaration
		| VariableDeclaration
		| ClassDeclaration
		| ExpressionStatement
		| BlockStatement
		| StaticBlock
		| EmptyStatement
		| DebuggerStatement
		| WithStatement
		| ReturnStatement
		| LabeledStatement
		| BreakStatement
		| ContinueStatement
		| IfStatement
		| SwitchStatement
		| ThrowStatement
		| TryStatement
		| WhileStatement
		| DoWhileStatement
		| ForStatement
		| ForInStatement
		| ForOfStatement
		| ImportDeclaration
		| ExportNamedDeclaration
		| ExportDefaultDeclaration
		| ExportAllDeclaration
	)[];
	prevStatement?:
		| UnaryExpression
		| ArrayExpression
		| ArrowFunctionExpression
		| AssignmentExpression
		| AwaitExpression
		| BinaryExpression
		| SimpleCallExpression
		| NewExpression
		| ChainExpression
		| ClassExpression
		| ConditionalExpression
		| FunctionExpression
		| Identifier
		| ImportExpression
		| SimpleLiteral
		| RegExpLiteral
		| BigIntLiteral
		| LogicalExpression
		| MemberExpression
		| MetaProperty
		| ObjectExpression
		| SequenceExpression
		| TaggedTemplateExpression
		| TemplateLiteral
		| ThisExpression
		| UpdateExpression
		| YieldExpression
		| FunctionDeclaration
		| VariableDeclaration
		| ClassDeclaration
		| ExpressionStatement
		| BlockStatement
		| StaticBlock
		| EmptyStatement
		| DebuggerStatement
		| WithStatement
		| ReturnStatement
		| LabeledStatement
		| BreakStatement
		| ContinueStatement
		| IfStatement
		| SwitchStatement
		| ThrowStatement
		| TryStatement
		| WhileStatement
		| DoWhileStatement
		| ForStatement
		| ForInStatement
		| ForOfStatement
		| ImportDeclaration
		| ExportNamedDeclaration
		| ExportDefaultDeclaration
		| ExportAllDeclaration;
	destructuringAssignmentProperties: WeakMap<Expression, Set<string>>;
	currentTagData: any;
	destructuringAssignmentPropertiesFor(
		node: Expression
	): undefined | Set<string>;
	getRenameIdentifier(
		expr: Expression
	): undefined | string | VariableInfoInterface;
	walkClass(classy: ClassExpression | ClassDeclaration): void;

	/**
	 * Pre walking iterates the scope for variable declarations
	 */
	preWalkStatements(
		statements: (
			| FunctionDeclaration
			| VariableDeclaration
			| ClassDeclaration
			| ExpressionStatement
			| BlockStatement
			| StaticBlock
			| EmptyStatement
			| DebuggerStatement
			| WithStatement
			| ReturnStatement
			| LabeledStatement
			| BreakStatement
			| ContinueStatement
			| IfStatement
			| SwitchStatement
			| ThrowStatement
			| TryStatement
			| WhileStatement
			| DoWhileStatement
			| ForStatement
			| ForInStatement
			| ForOfStatement
			| ImportDeclaration
			| ExportNamedDeclaration
			| ExportDefaultDeclaration
			| ExportAllDeclaration
		)[]
	): void;

	/**
	 * Block pre walking iterates the scope for block variable declarations
	 */
	blockPreWalkStatements(
		statements: (
			| FunctionDeclaration
			| VariableDeclaration
			| ClassDeclaration
			| ExpressionStatement
			| BlockStatement
			| StaticBlock
			| EmptyStatement
			| DebuggerStatement
			| WithStatement
			| ReturnStatement
			| LabeledStatement
			| BreakStatement
			| ContinueStatement
			| IfStatement
			| SwitchStatement
			| ThrowStatement
			| TryStatement
			| WhileStatement
			| DoWhileStatement
			| ForStatement
			| ForInStatement
			| ForOfStatement
			| ImportDeclaration
			| ExportNamedDeclaration
			| ExportDefaultDeclaration
			| ExportAllDeclaration
		)[]
	): void;

	/**
	 * Walking iterates the statements and expressions and processes them
	 */
	walkStatements(
		statements: (
			| FunctionDeclaration
			| VariableDeclaration
			| ClassDeclaration
			| ExpressionStatement
			| BlockStatement
			| StaticBlock
			| EmptyStatement
			| DebuggerStatement
			| WithStatement
			| ReturnStatement
			| LabeledStatement
			| BreakStatement
			| ContinueStatement
			| IfStatement
			| SwitchStatement
			| ThrowStatement
			| TryStatement
			| WhileStatement
			| DoWhileStatement
			| ForStatement
			| ForInStatement
			| ForOfStatement
			| ImportDeclaration
			| ExportNamedDeclaration
			| ExportDefaultDeclaration
			| ExportAllDeclaration
		)[]
	): void;

	/**
	 * Walking iterates the statements and expressions and processes them
	 */
	preWalkStatement(
		statement:
			| FunctionDeclaration
			| VariableDeclaration
			| ClassDeclaration
			| ExpressionStatement
			| BlockStatement
			| StaticBlock
			| EmptyStatement
			| DebuggerStatement
			| WithStatement
			| ReturnStatement
			| LabeledStatement
			| BreakStatement
			| ContinueStatement
			| IfStatement
			| SwitchStatement
			| ThrowStatement
			| TryStatement
			| WhileStatement
			| DoWhileStatement
			| ForStatement
			| ForInStatement
			| ForOfStatement
			| ImportDeclaration
			| ExportNamedDeclaration
			| ExportDefaultDeclaration
			| ExportAllDeclaration
	): void;
	blockPreWalkStatement(
		statement:
			| FunctionDeclaration
			| VariableDeclaration
			| ClassDeclaration
			| ExpressionStatement
			| BlockStatement
			| StaticBlock
			| EmptyStatement
			| DebuggerStatement
			| WithStatement
			| ReturnStatement
			| LabeledStatement
			| BreakStatement
			| ContinueStatement
			| IfStatement
			| SwitchStatement
			| ThrowStatement
			| TryStatement
			| WhileStatement
			| DoWhileStatement
			| ForStatement
			| ForInStatement
			| ForOfStatement
			| ImportDeclaration
			| ExportNamedDeclaration
			| ExportDefaultDeclaration
			| ExportAllDeclaration
	): void;
	walkStatement(
		statement:
			| FunctionDeclaration
			| VariableDeclaration
			| ClassDeclaration
			| ExpressionStatement
			| BlockStatement
			| StaticBlock
			| EmptyStatement
			| DebuggerStatement
			| WithStatement
			| ReturnStatement
			| LabeledStatement
			| BreakStatement
			| ContinueStatement
			| IfStatement
			| SwitchStatement
			| ThrowStatement
			| TryStatement
			| WhileStatement
			| DoWhileStatement
			| ForStatement
			| ForInStatement
			| ForOfStatement
			| ImportDeclaration
			| ExportNamedDeclaration
			| ExportDefaultDeclaration
			| ExportAllDeclaration
	): void;

	/**
	 * Walks a statements that is nested within a parent statement
	 * and can potentially be a non-block statement.
	 * This enforces the nested statement to never be in ASI position.
	 */
	walkNestedStatement(statement: Statement): void;
	preWalkBlockStatement(statement: BlockStatement): void;
	walkBlockStatement(statement: BlockStatement): void;
	walkExpressionStatement(statement: ExpressionStatement): void;
	preWalkIfStatement(statement: IfStatement): void;
	walkIfStatement(statement: IfStatement): void;
	preWalkLabeledStatement(statement: LabeledStatement): void;
	walkLabeledStatement(statement: LabeledStatement): void;
	preWalkWithStatement(statement: WithStatement): void;
	walkWithStatement(statement: WithStatement): void;
	preWalkSwitchStatement(statement: SwitchStatement): void;
	walkSwitchStatement(statement: SwitchStatement): void;
	walkTerminatingStatement(statement: ReturnStatement | ThrowStatement): void;
	walkReturnStatement(statement: ReturnStatement): void;
	walkThrowStatement(statement: ThrowStatement): void;
	preWalkTryStatement(statement: TryStatement): void;
	walkTryStatement(statement: TryStatement): void;
	preWalkWhileStatement(statement: WhileStatement): void;
	walkWhileStatement(statement: WhileStatement): void;
	preWalkDoWhileStatement(statement: DoWhileStatement): void;
	walkDoWhileStatement(statement: DoWhileStatement): void;
	preWalkForStatement(statement: ForStatement): void;
	walkForStatement(statement: ForStatement): void;
	preWalkForInStatement(statement: ForInStatement): void;
	walkForInStatement(statement: ForInStatement): void;
	preWalkForOfStatement(statement?: any): void;
	walkForOfStatement(statement: ForOfStatement): void;
	preWalkFunctionDeclaration(statement: FunctionDeclaration): void;
	walkFunctionDeclaration(statement: FunctionDeclaration): void;
	blockPreWalkExpressionStatement(statement: ExpressionStatement): void;
	preWalkAssignmentExpression(expression: AssignmentExpression): void;
	blockPreWalkImportDeclaration(statement?: any): void;
	enterDeclaration(declaration?: any, onIdent?: any): void;
	blockPreWalkExportNamedDeclaration(statement?: any): void;
	walkExportNamedDeclaration(statement: ExportNamedDeclaration): void;
	blockPreWalkExportDefaultDeclaration(statement?: any): void;
	walkExportDefaultDeclaration(statement?: any): void;
	blockPreWalkExportAllDeclaration(statement?: any): void;
	preWalkVariableDeclaration(statement: VariableDeclaration): void;
	blockPreWalkVariableDeclaration(statement: VariableDeclaration): void;
	preWalkVariableDeclarator(declarator: VariableDeclarator): void;
	walkVariableDeclaration(statement: VariableDeclaration): void;
	blockPreWalkClassDeclaration(statement: ClassDeclaration): void;
	walkClassDeclaration(statement: ClassDeclaration): void;
	preWalkSwitchCases(switchCases: SwitchCase[]): void;
	walkSwitchCases(switchCases: SwitchCase[]): void;
	preWalkCatchClause(catchClause: CatchClause): void;
	walkCatchClause(catchClause: CatchClause): void;
	walkPattern(pattern: Pattern): void;
	walkAssignmentPattern(pattern: AssignmentPattern): void;
	walkObjectPattern(pattern?: any): void;
	walkArrayPattern(pattern: ArrayPattern): void;
	walkRestElement(pattern: RestElement): void;
	walkExpressions(
		expressions: (
			| null
			| UnaryExpression
			| ArrayExpression
			| ArrowFunctionExpression
			| AssignmentExpression
			| AwaitExpression
			| BinaryExpression
			| SimpleCallExpression
			| NewExpression
			| ChainExpression
			| ClassExpression
			| ConditionalExpression
			| FunctionExpression
			| Identifier
			| ImportExpression
			| SimpleLiteral
			| RegExpLiteral
			| BigIntLiteral
			| LogicalExpression
			| MemberExpression
			| MetaProperty
			| ObjectExpression
			| SequenceExpression
			| TaggedTemplateExpression
			| TemplateLiteral
			| ThisExpression
			| UpdateExpression
			| YieldExpression
			| SpreadElement
		)[]
	): void;
	walkExpression(expression?: any): void;
	walkAwaitExpression(expression: AwaitExpression): void;
	walkArrayExpression(expression: ArrayExpression): void;
	walkSpreadElement(expression: SpreadElement): void;
	walkObjectExpression(expression: ObjectExpression): void;
	walkProperty(prop: SpreadElement | Property): void;
	walkFunctionExpression(expression: FunctionExpression): void;
	walkArrowFunctionExpression(expression: ArrowFunctionExpression): void;
	walkSequenceExpression(expression: SequenceExpression): void;
	walkUpdateExpression(expression: UpdateExpression): void;
	walkUnaryExpression(expression: UnaryExpression): void;
	walkLeftRightExpression(
		expression: BinaryExpression | LogicalExpression
	): void;
	walkBinaryExpression(expression: BinaryExpression): void;
	walkLogicalExpression(expression: LogicalExpression): void;
	walkAssignmentExpression(expression: AssignmentExpression): void;
	walkConditionalExpression(expression: ConditionalExpression): void;
	walkNewExpression(expression: NewExpression): void;
	walkYieldExpression(expression: YieldExpression): void;
	walkTemplateLiteral(expression: TemplateLiteral): void;
	walkTaggedTemplateExpression(expression: TaggedTemplateExpression): void;
	walkClassExpression(expression: ClassExpression): void;
	walkChainExpression(expression: ChainExpression): void;
	walkImportExpression(expression: ImportExpression): void;
	walkCallExpression(expression?: any): void;
	walkMemberExpression(expression: MemberExpression): void;
	walkMemberExpressionWithExpressionName(
		expression?: any,
		name?: any,
		rootInfo?: any,
		members?: any,
		onUnhandled?: any
	): void;
	walkThisExpression(expression: ThisExpression): void;
	walkIdentifier(expression: Identifier): void;
	walkMetaProperty(metaProperty: MetaProperty): void;
	callHooksForExpression(hookMap: any, expr: any, ...args: any[]): any;
	callHooksForExpressionWithFallback<T, R>(
		hookMap: HookMap<SyncBailHook<T, R>>,
		expr: MemberExpression,
		fallback:
			| undefined
			| ((
					arg0: string,
					arg1: string | ScopeInfo | VariableInfo,
					arg2: () => string[]
			  ) => any),
		defined: undefined | ((arg0: string) => any),
		...args: AsArray<T>
	): undefined | R;
	callHooksForName<T, R>(
		hookMap: HookMap<SyncBailHook<T, R>>,
		name: string,
		...args: AsArray<T>
	): undefined | R;
	callHooksForInfo<T, R>(
		hookMap: HookMap<SyncBailHook<T, R>>,
		info: ExportedVariableInfo,
		...args: AsArray<T>
	): undefined | R;
	callHooksForInfoWithFallback<T, R>(
		hookMap: HookMap<SyncBailHook<T, R>>,
		info: ExportedVariableInfo,
		fallback: undefined | ((arg0: string) => any),
		defined: undefined | (() => any),
		...args: AsArray<T>
	): undefined | R;
	callHooksForNameWithFallback<T, R>(
		hookMap: HookMap<SyncBailHook<T, R>>,
		name: string,
		fallback: undefined | ((arg0: string) => any),
		defined: undefined | (() => any),
		...args: AsArray<T>
	): undefined | R;
	inScope(params: any, fn: () => void): void;
	inClassScope(hasThis: boolean, params: any, fn: () => void): void;
	inFunctionScope(hasThis: boolean, params: any, fn: () => void): void;
	inBlockScope(fn: () => void): void;
	detectMode(
		statements: (
			| FunctionDeclaration
			| VariableDeclaration
			| ClassDeclaration
			| ExpressionStatement
			| BlockStatement
			| StaticBlock
			| EmptyStatement
			| DebuggerStatement
			| WithStatement
			| ReturnStatement
			| LabeledStatement
			| BreakStatement
			| ContinueStatement
			| IfStatement
			| SwitchStatement
			| ThrowStatement
			| TryStatement
			| WhileStatement
			| DoWhileStatement
			| ForStatement
			| ForInStatement
			| ForOfStatement
			| ImportDeclaration
			| ExportNamedDeclaration
			| ExportDefaultDeclaration
			| ExportAllDeclaration
			| Directive
		)[]
	): void;
	enterPatterns(patterns?: any, onIdent?: any): void;
	enterPattern(pattern?: any, onIdent?: any): void;
	enterIdentifier(pattern: Identifier, onIdent?: any): void;
	enterObjectPattern(pattern: ObjectPattern, onIdent?: any): void;
	enterArrayPattern(pattern: ArrayPattern, onIdent?: any): void;
	enterRestElement(pattern: RestElement, onIdent?: any): void;
	enterAssignmentPattern(pattern: AssignmentPattern, onIdent?: any): void;
	evaluateExpression(expression?: any): BasicEvaluatedExpression;
	parseString(expression: Expression): string;
	parseCalculatedString(expression?: any): any;
	evaluate(source: string): BasicEvaluatedExpression;
	isPure(
		expr:
			| undefined
			| null
			| UnaryExpression
			| ArrayExpression
			| ArrowFunctionExpression
			| AssignmentExpression
			| AwaitExpression
			| BinaryExpression
			| SimpleCallExpression
			| NewExpression
			| ChainExpression
			| ClassExpression
			| ConditionalExpression
			| FunctionExpression
			| Identifier
			| ImportExpression
			| SimpleLiteral
			| RegExpLiteral
			| BigIntLiteral
			| LogicalExpression
			| MemberExpression
			| MetaProperty
			| ObjectExpression
			| SequenceExpression
			| TaggedTemplateExpression
			| TemplateLiteral
			| ThisExpression
			| UpdateExpression
			| YieldExpression
			| FunctionDeclaration
			| VariableDeclaration
			| ClassDeclaration
			| PrivateIdentifier,
		commentsStartPos: number
	): boolean;
	getComments(range: [number, number]): any[];
	isAsiPosition(pos: number): boolean;
	unsetAsiPosition(pos: number): void;
	isStatementLevelExpression(expr: Expression): boolean;
	getTagData(name?: any, tag?: any): any;
	tagVariable(name?: any, tag?: any, data?: any): void;
	defineVariable(name: string): void;
	undefineVariable(name: string): void;
	isVariableDefined(name: string): boolean;
	getVariableInfo(name: string): ExportedVariableInfo;
	setVariable(name: string, variableInfo: ExportedVariableInfo): void;
	evaluatedVariable(tagInfo: TagInfo): VariableInfo;
	parseCommentOptions(range: [number, number]): any;
	extractMemberExpressionChain(expression: MemberExpression): {
		members: string[];
		object:
			| UnaryExpression
			| ArrayExpression
			| ArrowFunctionExpression
			| AssignmentExpression
			| AwaitExpression
			| BinaryExpression
			| SimpleCallExpression
			| NewExpression
			| ChainExpression
			| ClassExpression
			| ConditionalExpression
			| FunctionExpression
			| Identifier
			| ImportExpression
			| SimpleLiteral
			| RegExpLiteral
			| BigIntLiteral
			| LogicalExpression
			| MemberExpression
			| MetaProperty
			| ObjectExpression
			| SequenceExpression
			| TaggedTemplateExpression
			| TemplateLiteral
			| ThisExpression
			| UpdateExpression
			| YieldExpression
			| Super;
		membersOptionals: boolean[];
		memberRanges: [number, number][];
	};
	getFreeInfoFromVariable(
		varName: string
	): undefined | { name: string; info: string | VariableInfo };
	getMemberExpressionInfo(
		expression: MemberExpression,
		allowedTypes: number
	): undefined | CallExpressionInfo | ExpressionExpressionInfo;
	getNameForExpression(
		expression: MemberExpression
	):
		| undefined
		| {
				name: string;
				rootInfo: ExportedVariableInfo;
				getMembers: () => string[];
		  };
	static ALLOWED_MEMBER_TYPES_ALL: 3;
	static ALLOWED_MEMBER_TYPES_EXPRESSION: 2;
	static ALLOWED_MEMBER_TYPES_CALL_EXPRESSION: 1;
}

/**
 * Parser options for javascript modules.
 */
declare interface JavascriptParserOptions {
	[index: string]: any;

	/**
	 * Set the value of `require.amd` and `define.amd`. Or disable AMD support.
	 */
	amd?: false | { [index: string]: any };

	/**
	 * Enable/disable special handling for browserify bundles.
	 */
	browserify?: boolean;

	/**
	 * Enable/disable parsing of CommonJs syntax.
	 */
	commonjs?: boolean;

	/**
	 * Enable/disable parsing of magic comments in CommonJs syntax.
	 */
	commonjsMagicComments?: boolean;

	/**
	 * Enable/disable parsing "import { createRequire } from "module"" and evaluating createRequire().
	 */
	createRequire?: string | boolean;

	/**
	 * Specifies global fetchPriority for dynamic import.
	 */
	dynamicImportFetchPriority?: false | "auto" | "low" | "high";

	/**
	 * Specifies global mode for dynamic import.
	 */
	dynamicImportMode?: "weak" | "eager" | "lazy" | "lazy-once";

	/**
	 * Specifies global prefetch for dynamic import.
	 */
	dynamicImportPrefetch?: number | boolean;

	/**
	 * Specifies global preload for dynamic import.
	 */
	dynamicImportPreload?: number | boolean;

	/**
	 * Specifies the behavior of invalid export names in "import ... from ..." and "export ... from ...".
	 */
	exportsPresence?: false | "auto" | "error" | "warn";

	/**
	 * Enable warnings for full dynamic dependencies.
	 */
	exprContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup for full dynamic dependencies.
	 */
	exprContextRecursive?: boolean;

	/**
	 * Sets the default regular expression for full dynamic dependencies.
	 */
	exprContextRegExp?: boolean | RegExp;

	/**
	 * Set the default request for full dynamic dependencies.
	 */
	exprContextRequest?: string;

	/**
	 * Enable/disable parsing of EcmaScript Modules syntax.
	 */
	harmony?: boolean;

	/**
	 * Enable/disable parsing of import() syntax.
	 */
	import?: boolean;

	/**
	 * Specifies the behavior of invalid export names in "import ... from ...".
	 */
	importExportsPresence?: false | "auto" | "error" | "warn";

	/**
	 * Enable/disable evaluating import.meta.
	 */
	importMeta?: boolean;

	/**
	 * Enable/disable evaluating import.meta.webpackContext.
	 */
	importMetaContext?: boolean;

	/**
	 * Include polyfills or mocks for various node stuff.
	 */
	node?: false | NodeOptions;

	/**
	 * Specifies the behavior of invalid export names in "export ... from ...". This might be useful to disable during the migration from "export ... from ..." to "export type ... from ..." when reexporting types in TypeScript.
	 */
	reexportExportsPresence?: false | "auto" | "error" | "warn";

	/**
	 * Enable/disable parsing of require.context syntax.
	 */
	requireContext?: boolean;

	/**
	 * Enable/disable parsing of require.ensure syntax.
	 */
	requireEnsure?: boolean;

	/**
	 * Enable/disable parsing of require.include syntax.
	 */
	requireInclude?: boolean;

	/**
	 * Enable/disable parsing of require.js special syntax like require.config, requirejs.config, require.version and requirejs.onError.
	 */
	requireJs?: boolean;

	/**
	 * Deprecated in favor of "exportsPresence". Emit errors instead of warnings when imported names don't exist in imported module.
	 */
	strictExportPresence?: boolean;

	/**
	 * Handle the this context correctly according to the spec for namespace objects.
	 */
	strictThisContextOnImports?: boolean;

	/**
	 * Enable/disable parsing of System.js special syntax like System.import, System.get, System.set and System.register.
	 */
	system?: boolean;

	/**
	 * Enable warnings when using the require function in a not statically analyse-able way.
	 */
	unknownContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup when using the require function in a not statically analyse-able way.
	 */
	unknownContextRecursive?: boolean;

	/**
	 * Sets the regular expression when using the require function in a not statically analyse-able way.
	 */
	unknownContextRegExp?: boolean | RegExp;

	/**
	 * Sets the request when using the require function in a not statically analyse-able way.
	 */
	unknownContextRequest?: string;

	/**
	 * Enable/disable parsing of new URL() syntax.
	 */
	url?: boolean | "relative";

	/**
	 * Disable or configure parsing of WebWorker syntax like new Worker() or navigator.serviceWorker.register().
	 */
	worker?: boolean | string[];

	/**
	 * Enable warnings for partial dynamic dependencies.
	 */
	wrappedContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup for partial dynamic dependencies.
	 */
	wrappedContextRecursive?: boolean;

	/**
	 * Set the inner regular expression for partial dynamic dependencies.
	 */
	wrappedContextRegExp?: RegExp;
}
type JsonObject = { [index: string]: JsonValue } & {
	[index: string]:
		| undefined
		| null
		| string
		| number
		| boolean
		| JsonObject
		| JsonValue[];
};
type JsonValue = null | string | number | boolean | JsonObject | JsonValue[];
declare class JsonpChunkLoadingRuntimeModule extends RuntimeModule {
	constructor(runtimeRequirements: Set<string>);
	static getCompilationHooks(
		compilation: Compilation
	): JsonpCompilationPluginHooks;

	/**
	 * Runtime modules without any dependencies to other runtime modules
	 */
	static STAGE_NORMAL: number;

	/**
	 * Runtime modules with simple dependencies on other runtime modules
	 */
	static STAGE_BASIC: number;

	/**
	 * Runtime modules which attach to handlers of other runtime modules
	 */
	static STAGE_ATTACH: number;

	/**
	 * Runtime modules which trigger actions on bootstrap
	 */
	static STAGE_TRIGGER: number;
}
declare interface JsonpCompilationPluginHooks {
	linkPreload: SyncWaterfallHook<[string, Chunk]>;
	linkPrefetch: SyncWaterfallHook<[string, Chunk]>;
}
declare class JsonpTemplatePlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static getCompilationHooks(
		compilation: Compilation
	): JsonpCompilationPluginHooks;
}
declare interface KnownAssetInfo {
	/**
	 * true, if the asset can be long term cached forever (contains a hash)
	 */
	immutable?: boolean;

	/**
	 * whether the asset is minimized
	 */
	minimized?: boolean;

	/**
	 * the value(s) of the full hash used for this asset
	 */
	fullhash?: string | string[];

	/**
	 * the value(s) of the chunk hash used for this asset
	 */
	chunkhash?: string | string[];

	/**
	 * the value(s) of the module hash used for this asset
	 */
	modulehash?: string | string[];

	/**
	 * the value(s) of the content hash used for this asset
	 */
	contenthash?: string | string[];

	/**
	 * when asset was created from a source file (potentially transformed), the original filename relative to compilation context
	 */
	sourceFilename?: string;

	/**
	 * size in bytes, only set after asset has been emitted
	 */
	size?: number;

	/**
	 * true, when asset is only used for development and doesn't count towards user-facing assets
	 */
	development?: boolean;

	/**
	 * true, when asset ships data for updating an existing application (HMR)
	 */
	hotModuleReplacement?: boolean;

	/**
	 * true, when asset is javascript and an ESM
	 */
	javascriptModule?: boolean;

	/**
	 * object of pointers to other assets, keyed by type of relation (only points from parent to child)
	 */
	related?: Record<string, string | string[]>;
}
declare interface KnownBuildMeta {
	moduleArgument?: string;
	exportsArgument?: string;
	strict?: boolean;
	moduleConcatenationBailout?: string;
	exportsType?: "namespace" | "dynamic" | "default" | "flagged";
	defaultObject?: false | "redirect" | "redirect-warn";
	strictHarmonyModule?: boolean;
	async?: boolean;
	sideEffectFree?: boolean;
}
declare interface KnownCreateStatsOptionsContext {
	forToString?: boolean;
}
declare interface KnownHooks {
	resolveStep: SyncHook<
		[
			AsyncSeriesBailHook<
				[ResolveRequest, ResolveContext],
				null | ResolveRequest
			>,
			ResolveRequest
		]
	>;
	noResolve: SyncHook<[ResolveRequest, Error]>;
	resolve: AsyncSeriesBailHook<
		[ResolveRequest, ResolveContext],
		null | ResolveRequest
	>;
	result: AsyncSeriesHook<[ResolveRequest, ResolveContext]>;
}
declare interface KnownNormalizedStatsOptions {
	context: string;
	requestShortener: RequestShortener;
	chunksSort: string;
	modulesSort: string;
	chunkModulesSort: string;
	nestedModulesSort: string;
	assetsSort: string;
	ids: boolean;
	cachedAssets: boolean;
	groupAssetsByEmitStatus: boolean;
	groupAssetsByPath: boolean;
	groupAssetsByExtension: boolean;
	assetsSpace: number;
	excludeAssets: ((value: string, asset: StatsAsset) => boolean)[];
	excludeModules: ((
		name: string,
		module: StatsModule,
		type: "module" | "chunk" | "root-of-chunk" | "nested"
	) => boolean)[];
	warningsFilter: ((warning: StatsError, textValue: string) => boolean)[];
	cachedModules: boolean;
	orphanModules: boolean;
	dependentModules: boolean;
	runtimeModules: boolean;
	groupModulesByCacheStatus: boolean;
	groupModulesByLayer: boolean;
	groupModulesByAttributes: boolean;
	groupModulesByPath: boolean;
	groupModulesByExtension: boolean;
	groupModulesByType: boolean;
	entrypoints: boolean | "auto";
	chunkGroups: boolean;
	chunkGroupAuxiliary: boolean;
	chunkGroupChildren: boolean;
	chunkGroupMaxAssets: number;
	modulesSpace: number;
	chunkModulesSpace: number;
	nestedModulesSpace: number;
	logging: false | "none" | "error" | "warn" | "info" | "log" | "verbose";
	loggingDebug: ((value: string) => boolean)[];
	loggingTrace: boolean;
}
declare interface KnownStatsAsset {
	type: string;
	name: string;
	info: AssetInfo;
	size: number;
	emitted: boolean;
	comparedForEmit: boolean;
	cached: boolean;
	related?: StatsAsset[];
	chunkNames?: (string | number)[];
	chunkIdHints?: (string | number)[];
	chunks?: (string | number)[];
	auxiliaryChunkNames?: (string | number)[];
	auxiliaryChunks?: (string | number)[];
	auxiliaryChunkIdHints?: (string | number)[];
	filteredRelated?: number;
	isOverSizeLimit?: boolean;
}
declare interface KnownStatsChunk {
	rendered: boolean;
	initial: boolean;
	entry: boolean;
	recorded: boolean;
	reason?: string;
	size: number;
	sizes?: Record<string, number>;
	names?: string[];
	idHints?: string[];
	runtime?: string[];
	files?: string[];
	auxiliaryFiles?: string[];
	hash: string;
	childrenByOrder?: Record<string, (string | number)[]>;
	id?: string | number;
	siblings?: (string | number)[];
	parents?: (string | number)[];
	children?: (string | number)[];
	modules?: StatsModule[];
	filteredModules?: number;
	origins?: StatsChunkOrigin[];
}
declare interface KnownStatsChunkGroup {
	name?: string;
	chunks?: (string | number)[];
	assets?: { name: string; size?: number }[];
	filteredAssets?: number;
	assetsSize?: number;
	auxiliaryAssets?: { name: string; size?: number }[];
	filteredAuxiliaryAssets?: number;
	auxiliaryAssetsSize?: number;
	children?: { [index: string]: StatsChunkGroup[] };
	childAssets?: { [index: string]: string[] };
	isOverSizeLimit?: boolean;
}
declare interface KnownStatsChunkOrigin {
	module?: string;
	moduleIdentifier?: string;
	moduleName?: string;
	loc?: string;
	request?: string;
	moduleId?: string | number;
}
declare interface KnownStatsCompilation {
	env?: any;
	name?: string;
	hash?: string;
	version?: string;
	time?: number;
	builtAt?: number;
	needAdditionalPass?: boolean;
	publicPath?: string;
	outputPath?: string;
	assetsByChunkName?: Record<string, string[]>;
	assets?: StatsAsset[];
	filteredAssets?: number;
	chunks?: StatsChunk[];
	modules?: StatsModule[];
	filteredModules?: number;
	entrypoints?: Record<string, StatsChunkGroup>;
	namedChunkGroups?: Record<string, StatsChunkGroup>;
	errors?: StatsError[];
	errorsCount?: number;
	warnings?: StatsError[];
	warningsCount?: number;
	children?: StatsCompilation[];
	logging?: Record<string, StatsLogging>;
}
declare interface KnownStatsError {
	message: string;
	chunkName?: string;
	chunkEntry?: boolean;
	chunkInitial?: boolean;
	file?: string;
	moduleIdentifier?: string;
	moduleName?: string;
	loc?: string;
	chunkId?: string | number;
	moduleId?: string | number;
	moduleTrace?: StatsModuleTraceItem[];
	details?: any;
	stack?: string;
}
declare interface KnownStatsFactoryContext {
	type: string;
	makePathsRelative?: (arg0: string) => string;
	compilation?: Compilation;
	rootModules?: Set<Module>;
	compilationFileToChunks?: Map<string, Chunk[]>;
	compilationAuxiliaryFileToChunks?: Map<string, Chunk[]>;
	runtime?: RuntimeSpec;
	cachedGetErrors?: (arg0: Compilation) => WebpackError[];
	cachedGetWarnings?: (arg0: Compilation) => WebpackError[];
}
declare interface KnownStatsLogging {
	entries: StatsLoggingEntry[];
	filteredEntries: number;
	debug: boolean;
}
declare interface KnownStatsLoggingEntry {
	type: string;
	message: string;
	trace?: string[];
	children?: StatsLoggingEntry[];
	args?: any[];
	time?: number;
}
declare interface KnownStatsModule {
	type?: string;
	moduleType?: string;
	layer?: string;
	identifier?: string;
	name?: string;
	nameForCondition?: string;
	index?: number;
	preOrderIndex?: number;
	index2?: number;
	postOrderIndex?: number;
	size?: number;
	sizes?: { [index: string]: number };
	cacheable?: boolean;
	built?: boolean;
	codeGenerated?: boolean;
	buildTimeExecuted?: boolean;
	cached?: boolean;
	optional?: boolean;
	orphan?: boolean;
	id?: string | number;
	issuerId?: string | number;
	chunks?: (string | number)[];
	assets?: (string | number)[];
	dependent?: boolean;
	issuer?: string;
	issuerName?: string;
	issuerPath?: StatsModuleIssuer[];
	failed?: boolean;
	errors?: number;
	warnings?: number;
	profile?: StatsProfile;
	reasons?: StatsModuleReason[];
	usedExports?: boolean | string[];
	providedExports?: string[];
	optimizationBailout?: string[];
	depth?: number;
	modules?: StatsModule[];
	filteredModules?: number;
	source?: string | Buffer;
}
declare interface KnownStatsModuleIssuer {
	identifier?: string;
	name?: string;
	id?: string | number;
	profile?: StatsProfile;
}
declare interface KnownStatsModuleReason {
	moduleIdentifier?: string;
	module?: string;
	moduleName?: string;
	resolvedModuleIdentifier?: string;
	resolvedModule?: string;
	type?: string;
	active: boolean;
	explanation?: string;
	userRequest?: string;
	loc?: string;
	moduleId?: string | number;
	resolvedModuleId?: string | number;
}
declare interface KnownStatsModuleTraceDependency {
	loc?: string;
}
declare interface KnownStatsModuleTraceItem {
	originIdentifier?: string;
	originName?: string;
	moduleIdentifier?: string;
	moduleName?: string;
	dependencies?: StatsModuleTraceDependency[];
	originId?: string | number;
	moduleId?: string | number;
}
declare interface KnownStatsPrinterContext {
	type?: string;
	compilation?: StatsCompilation;
	chunkGroup?: StatsChunkGroup;
	asset?: StatsAsset;
	module?: StatsModule;
	chunk?: StatsChunk;
	moduleReason?: StatsModuleReason;
	bold?: (str: string) => string;
	yellow?: (str: string) => string;
	red?: (str: string) => string;
	green?: (str: string) => string;
	magenta?: (str: string) => string;
	cyan?: (str: string) => string;
	formatFilename?: (file: string, oversize?: boolean) => string;
	formatModuleId?: (id: string) => string;
	formatChunkId?: (
		id: string,
		direction?: "parent" | "child" | "sibling"
	) => string;
	formatSize?: (size: number) => string;
	formatDateTime?: (dateTime: number) => string;
	formatFlag?: (flag: string) => string;
	formatTime?: (time: number, boldQuantity?: boolean) => string;
	chunkGroupKind?: string;
}
declare interface KnownStatsProfile {
	total: number;
	resolving: number;
	restoring: number;
	building: number;
	integration: number;
	storing: number;
	additionalResolving: number;
	additionalIntegration: number;
	factory: number;
	dependencies: number;
}

/**
 * Options for the default backend.
 */
declare interface LazyCompilationDefaultBackendOptions {
	/**
	 * A custom client.
	 */
	client?: string;

	/**
	 * Specifies where to listen to from the server.
	 */
	listen?: number | ListenOptions | ((server: typeof Server) => void);

	/**
	 * Specifies the protocol the client should use to connect to the server.
	 */
	protocol?: "http" | "https";

	/**
	 * Specifies how to create the server handling the EventSource requests.
	 */
	server?:
		| ServerOptionsImport<typeof IncomingMessage>
		| ServerOptionsHttps<typeof IncomingMessage, typeof ServerResponse>
		| (() => typeof Server);
}

/**
 * Options for compiling entrypoints and import()s only when they are accessed.
 */
declare interface LazyCompilationOptions {
	/**
	 * Specifies the backend that should be used for handling client keep alive.
	 */
	backend?:
		| ((
				compiler: Compiler,
				callback: (err?: Error, api?: BackendApi) => void
		  ) => void)
		| ((compiler: Compiler) => Promise<BackendApi>)
		| LazyCompilationDefaultBackendOptions;

	/**
	 * Enable/disable lazy compilation for entries.
	 */
	entries?: boolean;

	/**
	 * Enable/disable lazy compilation for import() modules.
	 */
	imports?: boolean;

	/**
	 * Specify which entrypoints or import()ed modules should be lazily compiled. This is matched with the imported module and not the entrypoint name.
	 */
	test?: string | RegExp | ((module: Module) => boolean);
}
declare class LazySet<T> {
	constructor(iterable?: Iterable<T>);
	get size(): number;
	add(item: T): LazySet<T>;
	addAll(iterable: LazySet<T> | Iterable<T>): LazySet<T>;
	clear(): void;
	delete(value: T): boolean;
	entries(): IterableIterator<[T, T]>;
	forEach(
		callbackFn: (arg0: T, arg1: T, arg2: Set<T>) => void,
		thisArg?: any
	): void;
	has(item: T): boolean;
	keys(): IterableIterator<T>;
	values(): IterableIterator<T>;
	serialize(__0: ObjectSerializerContext): void;
	[Symbol.iterator](): IterableIterator<T>;
	static deserialize<T>(__0: ObjectDeserializerContext): LazySet<T>;
}
declare interface LibIdentOptions {
	/**
	 * absolute context path to which lib ident is relative to
	 */
	context: string;

	/**
	 * object for caching
	 */
	associatedObjectForCache?: Object;
}
declare class LibManifestPlugin {
	constructor(options: LibManifestPluginOptions);
	options: LibManifestPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface LibManifestPluginOptions {
	/**
	 * Context of requests in the manifest file (defaults to the webpack context).
	 */
	context?: string;

	/**
	 * If true, only entry points will be exposed (default: true).
	 */
	entryOnly?: boolean;

	/**
	 * If true, manifest json file (output) will be formatted.
	 */
	format?: boolean;

	/**
	 * Name of the exposed dll function (external name, use value of 'output.library').
	 */
	name?: string;

	/**
	 * Absolute path to the manifest json file (output).
	 */
	path: string;

	/**
	 * Type of the dll bundle (external type, use value of 'output.libraryTarget').
	 */
	type?: string;
}
declare interface LibraryContext<T> {
	compilation: Compilation;
	chunkGraph: ChunkGraph;
	options: T;
}

/**
 * Set explicit comments for `commonjs`, `commonjs2`, `amd`, and `root`.
 */
declare interface LibraryCustomUmdCommentObject {
	/**
	 * Set comment for `amd` section in UMD.
	 */
	amd?: string;

	/**
	 * Set comment for `commonjs` (exports) section in UMD.
	 */
	commonjs?: string;

	/**
	 * Set comment for `commonjs2` (module.exports) section in UMD.
	 */
	commonjs2?: string;

	/**
	 * Set comment for `root` (global variable) section in UMD.
	 */
	root?: string;
}

/**
 * Description object for all UMD variants of the library name.
 */
declare interface LibraryCustomUmdObject {
	/**
	 * Name of the exposed AMD library in the UMD.
	 */
	amd?: string;

	/**
	 * Name of the exposed commonjs export in the UMD.
	 */
	commonjs?: string;

	/**
	 * Name of the property exposed globally by a UMD library.
	 */
	root?: string | string[];
}
type LibraryExport = string | string[];
type LibraryName = string | string[] | LibraryCustomUmdObject;

/**
 * Options for library.
 */
declare interface LibraryOptions {
	/**
	 * Add a container for define/require functions in the AMD module.
	 */
	amdContainer?: string;

	/**
	 * Add a comment in the UMD wrapper.
	 */
	auxiliaryComment?: string | LibraryCustomUmdCommentObject;

	/**
	 * Specify which export should be exposed as library.
	 */
	export?: string | string[];

	/**
	 * The name of the library (some types allow unnamed libraries too).
	 */
	name?: string | string[] | LibraryCustomUmdObject;

	/**
	 * Type of library (types included by default are 'var', 'module', 'assign', 'assign-properties', 'this', 'window', 'self', 'global', 'commonjs', 'commonjs2', 'commonjs-module', 'commonjs-static', 'amd', 'amd-require', 'umd', 'umd2', 'jsonp', 'system', but others might be added by plugins).
	 */
	type: string;

	/**
	 * If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.
	 */
	umdNamedDefine?: boolean;
}
declare class LibraryTemplatePlugin {
	constructor(
		name: LibraryName,
		target: string,
		umdNamedDefine: boolean,
		auxiliaryComment: AuxiliaryComment,
		exportProperty: LibraryExport
	);
	library: {
		type: string;
		name: LibraryName;
		umdNamedDefine: boolean;
		auxiliaryComment: AuxiliaryComment;
		export: LibraryExport;
	};

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class LimitChunkCountPlugin {
	constructor(options?: LimitChunkCountPluginOptions);
	options?: LimitChunkCountPluginOptions;
	apply(compiler: Compiler): void;
}
declare interface LimitChunkCountPluginOptions {
	/**
	 * Constant overhead for a chunk.
	 */
	chunkOverhead?: number;

	/**
	 * Multiplicator for initial chunks.
	 */
	entryChunkMultiplicator?: number;

	/**
	 * Limit the maximum number of chunks using a value greater greater than or equal to 1.
	 */
	maxChunks: number;
}
declare interface LoadScriptCompilationHooks {
	createScript: SyncWaterfallHook<[string, Chunk]>;
}
declare class LoadScriptRuntimeModule extends HelperRuntimeModule {
	constructor(withCreateScriptUrl?: boolean, withFetchPriority?: boolean);
	static getCompilationHooks(
		compilation: Compilation
	): LoadScriptCompilationHooks;

	/**
	 * Runtime modules without any dependencies to other runtime modules
	 */
	static STAGE_NORMAL: number;

	/**
	 * Runtime modules with simple dependencies on other runtime modules
	 */
	static STAGE_BASIC: number;

	/**
	 * Runtime modules which attach to handlers of other runtime modules
	 */
	static STAGE_ATTACH: number;

	/**
	 * Runtime modules which trigger actions on bootstrap
	 */
	static STAGE_TRIGGER: number;
}

/**
 * Custom values available in the loader context.
 */
declare interface Loader {
	[index: string]: any;
}
type LoaderContext<OptionsType> = NormalModuleLoaderContext<OptionsType> &
	LoaderRunnerLoaderContext<OptionsType> &
	LoaderPluginLoaderContext &
	HotModuleReplacementPluginLoaderContext;
type LoaderDefinition<
	OptionsType = {},
	ContextAdditions = {}
> = LoaderDefinitionFunction<OptionsType, ContextAdditions> & {
	raw?: false;
	pitch?: PitchLoaderDefinitionFunction<OptionsType, ContextAdditions>;
};
declare interface LoaderDefinitionFunction<
	OptionsType = {},
	ContextAdditions = {}
> {
	(
		this: NormalModuleLoaderContext<OptionsType> &
			LoaderRunnerLoaderContext<OptionsType> &
			LoaderPluginLoaderContext &
			HotModuleReplacementPluginLoaderContext &
			ContextAdditions,
		content: string,
		sourceMap?: string | SourceMap,
		additionalData?: AdditionalData
	): string | void | Buffer | Promise<string | Buffer>;
}
declare interface LoaderItem {
	loader: string;
	options: any;
	ident: null | string;
	type: null | string;
}
declare interface LoaderModule<OptionsType = {}, ContextAdditions = {}> {
	default?:
		| RawLoaderDefinitionFunction<OptionsType, ContextAdditions>
		| LoaderDefinitionFunction<OptionsType, ContextAdditions>;
	raw?: false;
	pitch?: PitchLoaderDefinitionFunction<OptionsType, ContextAdditions>;
}
declare class LoaderOptionsPlugin {
	constructor(options?: LoaderOptionsPluginOptions & MatchObject);
	options: LoaderOptionsPluginOptions & MatchObject;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface LoaderOptionsPluginOptions {
	[index: string]: any;

	/**
	 * Whether loaders should be in debug mode or not. debug will be removed as of webpack 3.
	 */
	debug?: boolean;

	/**
	 * Where loaders can be switched to minimize mode.
	 */
	minimize?: boolean;

	/**
	 * A configuration object that can be used to configure older loaders.
	 */
	options?: {
		[index: string]: any;
		/**
		 * The context that can be used to configure older loaders.
		 */
		context?: string;
	};
}

/**
 * These properties are added by the LoaderPlugin
 */
declare interface LoaderPluginLoaderContext {
	/**
	 * Resolves the given request to a module, applies all configured loaders and calls
	 * back with the generated source, the sourceMap and the module instance (usually an
	 * instance of NormalModule). Use this function if you need to know the source code
	 * of another module to generate the result.
	 */
	loadModule(
		request: string,
		callback: (
			err: null | Error,
			source: string,
			sourceMap: any,
			module: NormalModule
		) => void
	): void;
	importModule(
		request: string,
		options: ImportModuleOptions,
		callback: (err?: null | Error, exports?: any) => any
	): void;
	importModule(request: string, options?: ImportModuleOptions): Promise<any>;
}

/**
 * The properties are added by https://github.com/webpack/loader-runner
 */
declare interface LoaderRunnerLoaderContext<OptionsType> {
	/**
	 * Add a directory as dependency of the loader result.
	 */
	addContextDependency(context: string): void;

	/**
	 * Adds a file as dependency of the loader result in order to make them watchable.
	 * For example, html-loader uses this technique as it finds src and src-set attributes.
	 * Then, it sets the url's for those attributes as dependencies of the html file that is parsed.
	 */
	addDependency(file: string): void;
	addMissingDependency(context: string): void;

	/**
	 * Make this loader async.
	 */
	async(): (
		err?: null | Error,
		content?: string | Buffer,
		sourceMap?: string | SourceMap,
		additionalData?: AdditionalData
	) => void;

	/**
	 * Make this loader result cacheable. By default it's cacheable.
	 * A cacheable loader must have a deterministic result, when inputs and dependencies haven't changed.
	 * This means the loader shouldn't have other dependencies than specified with this.addDependency.
	 * Most loaders are deterministic and cacheable.
	 */
	cacheable(flag?: boolean): void;
	callback: (
		err?: null | Error,
		content?: string | Buffer,
		sourceMap?: string | SourceMap,
		additionalData?: AdditionalData
	) => void;

	/**
	 * Remove all dependencies of the loader result. Even initial dependencies and these of other loaders.
	 */
	clearDependencies(): void;

	/**
	 * The directory of the module. Can be used as context for resolving other stuff.
	 * eg '/workspaces/ts-loader/examples/vanilla/src'
	 */
	context: string;
	readonly currentRequest: string;
	readonly data: any;

	/**
	 * alias of addDependency
	 * Adds a file as dependency of the loader result in order to make them watchable.
	 * For example, html-loader uses this technique as it finds src and src-set attributes.
	 * Then, it sets the url's for those attributes as dependencies of the html file that is parsed.
	 */
	dependency(file: string): void;
	getContextDependencies(): string[];
	getDependencies(): string[];
	getMissingDependencies(): string[];

	/**
	 * The index in the loaders array of the current loader.
	 * In the example: in loader1: 0, in loader2: 1
	 */
	loaderIndex: number;
	readonly previousRequest: string;
	readonly query: string | OptionsType;
	readonly remainingRequest: string;
	readonly request: string;

	/**
	 * An array of all the loaders. It is writeable in the pitch phase.
	 * loaders = [{request: string, path: string, query: string, module: function}]
	 * In the example:
	 * [
	 *   { request: "/abc/loader1.js?xyz",
	 *     path: "/abc/loader1.js",
	 *     query: "?xyz",
	 *     module: [Function]
	 *   },
	 *   { request: "/abc/node_modules/loader2/index.js",
	 *     path: "/abc/node_modules/loader2/index.js",
	 *     query: "",
	 *     module: [Function]
	 *   }
	 * ]
	 */
	loaders: {
		request: string;
		path: string;
		query: string;
		fragment: string;
		options?: string | object;
		ident: string;
		normal?: Function;
		pitch?: Function;
		raw?: boolean;
		data?: object;
		pitchExecuted: boolean;
		normalExecuted: boolean;
		type?: "module" | "commonjs";
	}[];

	/**
	 * The resource path.
	 * In the example: "/abc/resource.js"
	 */
	resourcePath: string;

	/**
	 * The resource query string.
	 * Example: "?query"
	 */
	resourceQuery: string;

	/**
	 * The resource fragment.
	 * Example: "#frag"
	 */
	resourceFragment: string;

	/**
	 * The resource inclusive query and fragment.
	 * Example: "/abc/resource.js?query#frag"
	 */
	resource: string;

	/**
	 * Target of compilation.
	 * Example: "web"
	 */
	target: string;

	/**
	 * Tell what kind of ES-features may be used in the generated runtime-code.
	 * Example: { arrowFunction: true }
	 */
	environment: Environment;
}
declare class LoaderTargetPlugin {
	constructor(target: string);
	target: string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface LogEntry {
	type: string;
	args: any[];
	time: number;
	trace?: string[];
}
declare const MEASURE_END_OPERATION: unique symbol;
declare const MEASURE_START_OPERATION: unique symbol;
declare interface MainRenderContext {
	/**
	 * the chunk
	 */
	chunk: Chunk;

	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;

	/**
	 * hash to be used for render call
	 */
	hash: string;

	/**
	 * rendering in strict context
	 */
	strictMode: boolean;
}
declare abstract class MainTemplate {
	hooks: Readonly<{
		renderManifest: { tap: (options?: any, fn?: any) => void };
		modules: { tap: () => never };
		moduleObj: { tap: () => never };
		require: { tap: (options?: any, fn?: any) => void };
		beforeStartup: { tap: () => never };
		startup: { tap: () => never };
		afterStartup: { tap: () => never };
		render: { tap: (options?: any, fn?: any) => void };
		renderWithEntry: { tap: (options?: any, fn?: any) => void };
		assetPath: {
			tap: (options?: any, fn?: any) => void;
			call: (filename?: any, options?: any) => string;
		};
		hash: { tap: (options?: any, fn?: any) => void };
		hashForChunk: { tap: (options?: any, fn?: any) => void };
		globalHashPaths: { tap: () => void };
		globalHash: { tap: () => void };
		hotBootstrap: { tap: () => never };
		bootstrap: SyncWaterfallHook<
			[string, Chunk, string, ModuleTemplate, DependencyTemplates]
		>;
		localVars: SyncWaterfallHook<[string, Chunk, string]>;
		requireExtensions: SyncWaterfallHook<[string, Chunk, string]>;
		requireEnsure: SyncWaterfallHook<[string, Chunk, string, string]>;
		get jsonpScript(): SyncWaterfallHook<[string, Chunk]>;
		get linkPrefetch(): SyncWaterfallHook<[string, Chunk]>;
		get linkPreload(): SyncWaterfallHook<[string, Chunk]>;
	}>;
	renderCurrentHashCode: (hash: string, length?: number) => string;
	getPublicPath: (options: object) => string;
	getAssetPath: (path?: any, options?: any) => string;
	getAssetPathWithInfo: (
		path?: any,
		options?: any
	) => { path: string; info: AssetInfo };
	get requireFn(): "__webpack_require__";
	get outputOptions(): Output;
}
declare interface MapOptions {
	columns?: boolean;
	module?: boolean;
}
declare interface MatchObject {
	test?: string | RegExp | (string | RegExp)[];
	include?: string | RegExp | (string | RegExp)[];
	exclude?: string | RegExp | (string | RegExp)[];
}
type Matcher = string | RegExp | (string | RegExp)[];

/**
 * Options object for in-memory caching.
 */
declare interface MemoryCacheOptions {
	/**
	 * Additionally cache computation of modules that are unchanged and reference only unchanged modules.
	 */
	cacheUnaffected?: boolean;

	/**
	 * Number of generations unused cache entries stay in memory cache at minimum (1 = may be removed after unused for a single compilation, ..., Infinity: kept forever).
	 */
	maxGenerations?: number;

	/**
	 * In memory caching.
	 */
	type: "memory";
}
declare class MemoryCachePlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class MinChunkSizePlugin {
	constructor(options: MinChunkSizePluginOptions);
	options: MinChunkSizePluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface MinChunkSizePluginOptions {
	/**
	 * Constant overhead for a chunk.
	 */
	chunkOverhead?: number;

	/**
	 * Multiplicator for initial chunks.
	 */
	entryChunkMultiplicator?: number;

	/**
	 * Minimum number of characters.
	 */
	minChunkSize: number;
}
declare class Module extends DependenciesBlock {
	constructor(type: string, context?: null | string, layer?: null | string);
	type: string;
	context: null | string;
	layer: null | string;
	needId: boolean;
	debugId: number;
	resolveOptions?: ResolveOptionsWebpackOptions;
	factoryMeta?: FactoryMeta;
	useSourceMap: boolean;
	useSimpleSourceMap: boolean;
	buildMeta?: BuildMeta;
	buildInfo?: BuildInfo;
	presentationalDependencies?: Dependency[];
	codeGenerationDependencies?: Dependency[];
	id: string | number;
	get hash(): string;
	get renderedHash(): string;
	profile: null | ModuleProfile;
	index: null | number;
	index2: null | number;
	depth: null | number;
	issuer: null | Module;
	get usedExports(): null | boolean | SortableSet<string>;
	get optimizationBailout(): (
		| string
		| ((requestShortener: RequestShortener) => string)
	)[];
	get optional(): boolean;
	addChunk(chunk: Chunk): boolean;
	removeChunk(chunk: Chunk): void;
	isInChunk(chunk: Chunk): boolean;
	isEntryModule(): boolean;
	getChunks(): Chunk[];
	getNumberOfChunks(): number;
	get chunksIterable(): Iterable<Chunk>;
	isProvided(exportName: string): null | boolean;
	get exportsArgument(): string;
	get moduleArgument(): string;
	getExportsType(
		moduleGraph: ModuleGraph,
		strict?: boolean
	): "namespace" | "default-only" | "default-with-named" | "dynamic";
	addPresentationalDependency(presentationalDependency: Dependency): void;
	addCodeGenerationDependency(codeGenerationDependency: Dependency): void;
	addWarning(warning: WebpackError): void;
	getWarnings(): undefined | Iterable<WebpackError>;
	getNumberOfWarnings(): number;
	addError(error: WebpackError): void;
	getErrors(): undefined | Iterable<WebpackError>;
	getNumberOfErrors(): number;

	/**
	 * removes all warnings and errors
	 */
	clearWarningsAndErrors(): void;
	isOptional(moduleGraph: ModuleGraph): boolean;
	isAccessibleInChunk(
		chunkGraph: ChunkGraph,
		chunk: Chunk,
		ignoreChunk?: Chunk
	): boolean;
	isAccessibleInChunkGroup(
		chunkGraph: ChunkGraph,
		chunkGroup: ChunkGroup,
		ignoreChunk?: Chunk
	): boolean;
	hasReasonForChunk(
		chunk: Chunk,
		moduleGraph: ModuleGraph,
		chunkGraph: ChunkGraph
	): boolean;
	hasReasons(moduleGraph: ModuleGraph, runtime: RuntimeSpec): boolean;
	needBuild(
		context: NeedBuildContext,
		callback: (arg0?: null | WebpackError, arg1?: boolean) => void
	): void;
	needRebuild(
		fileTimestamps: Map<string, null | number>,
		contextTimestamps: Map<string, null | number>
	): boolean;
	invalidateBuild(): void;
	identifier(): string;
	readableIdentifier(requestShortener: RequestShortener): string;
	build(
		options: WebpackOptionsNormalized,
		compilation: Compilation,
		resolver: ResolverWithOptions,
		fs: InputFileSystem,
		callback: (arg0?: WebpackError) => void
	): void;
	getSourceTypes(): Set<string>;
	source(
		dependencyTemplates: DependencyTemplates,
		runtimeTemplate: RuntimeTemplate,
		type?: string
	): Source;
	size(type?: string): number;
	libIdent(options: LibIdentOptions): null | string;
	nameForCondition(): null | string;
	getConcatenationBailoutReason(
		context: ConcatenationBailoutReasonContext
	): undefined | string;
	getSideEffectsConnectionState(moduleGraph: ModuleGraph): ConnectionState;
	codeGeneration(context: CodeGenerationContext): CodeGenerationResult;
	chunkCondition(chunk: Chunk, compilation: Compilation): boolean;
	hasChunkCondition(): boolean;

	/**
	 * Assuming this module is in the cache. Update the (cached) module with
	 * the fresh module from the factory. Usually updates internal references
	 * and properties.
	 */
	updateCacheModule(module: Module): void;

	/**
	 * Module should be unsafe cached. Get data that's needed for that.
	 * This data will be passed to restoreFromUnsafeCache later.
	 */
	getUnsafeCacheData(): object;

	/**
	 * Assuming this module is in the cache. Remove internal references to allow freeing some memory.
	 */
	cleanupForCache(): void;
	originalSource(): null | Source;
	addCacheDependencies(
		fileDependencies: LazySet<string>,
		contextDependencies: LazySet<string>,
		missingDependencies: LazySet<string>,
		buildDependencies: LazySet<string>
	): void;
	get hasEqualsChunks(): any;
	get isUsed(): any;
	get errors(): any;
	get warnings(): any;
	used: any;
}
declare class ModuleConcatenationPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class ModuleDependency extends Dependency {
	constructor(request: string);
	request: string;
	userRequest: string;
	range: any;
	assertions?: Record<string, any>;
	static Template: typeof DependencyTemplate;
	static NO_EXPORTS_REFERENCED: string[][];
	static EXPORTS_OBJECT_REFERENCED: string[][];
	static TRANSITIVE: typeof TRANSITIVE;
}
declare abstract class ModuleFactory {
	create(
		data: ModuleFactoryCreateData,
		callback: (arg0?: null | Error, arg1?: ModuleFactoryResult) => void
	): void;
}
declare interface ModuleFactoryCreateData {
	contextInfo: ModuleFactoryCreateDataContextInfo;
	resolveOptions?: ResolveOptionsWebpackOptions;
	context: string;
	dependencies: Dependency[];
}
declare interface ModuleFactoryCreateDataContextInfo {
	issuer: string;
	issuerLayer?: null | string;
	compiler: string;
}
declare interface ModuleFactoryResult {
	/**
	 * the created module or unset if no module was created
	 */
	module?: Module;
	fileDependencies?: Set<string>;
	contextDependencies?: Set<string>;
	missingDependencies?: Set<string>;

	/**
	 * allow to use the unsafe cache
	 */
	cacheable?: boolean;
}
declare class ModuleFederationPlugin {
	constructor(options: ModuleFederationPluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ModuleFederationPluginOptions {
	/**
	 * Modules that should be exposed by this container. When provided, property name is used as public name, otherwise public name is automatically inferred from request.
	 */
	exposes?: (string | ExposesObject)[] | ExposesObject;

	/**
	 * The filename of the container as relative path inside the `output.path` directory.
	 */
	filename?: string;

	/**
	 * Options for library.
	 */
	library?: LibraryOptions;

	/**
	 * The name of the container.
	 */
	name?: string;

	/**
	 * The external type of the remote containers.
	 */
	remoteType?:
		| "import"
		| "var"
		| "module"
		| "assign"
		| "this"
		| "window"
		| "self"
		| "global"
		| "commonjs"
		| "commonjs2"
		| "commonjs-module"
		| "commonjs-static"
		| "amd"
		| "amd-require"
		| "umd"
		| "umd2"
		| "jsonp"
		| "system"
		| "promise"
		| "script"
		| "node-commonjs";

	/**
	 * Container locations and request scopes from which modules should be resolved and loaded at runtime. When provided, property name is used as request scope, otherwise request scope is automatically inferred from container location.
	 */
	remotes?: (string | RemotesObject)[] | RemotesObject;

	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: string | false;

	/**
	 * Share scope name used for all shared modules (defaults to 'default').
	 */
	shareScope?: string;

	/**
	 * Modules that should be shared in the share scope. When provided, property names are used to match requested modules in this compilation.
	 */
	shared?: (string | SharedObject)[] | SharedObject;
}
type ModuleFilterItemTypes =
	| string
	| RegExp
	| ((
			name: string,
			module: StatsModule,
			type: "module" | "chunk" | "root-of-chunk" | "nested"
	  ) => boolean);
declare class ModuleGraph {
	constructor();
	setParents(
		dependency: Dependency,
		block: DependenciesBlock,
		module: Module,
		indexInBlock?: number
	): void;
	getParentModule(dependency: Dependency): Module;
	getParentBlock(dependency: Dependency): DependenciesBlock;
	getParentBlockIndex(dependency: Dependency): number;
	setResolvedModule(
		originModule: Module,
		dependency: Dependency,
		module: Module
	): void;
	updateModule(dependency: Dependency, module: Module): void;
	removeConnection(dependency: Dependency): void;
	addExplanation(dependency: Dependency, explanation: string): void;
	cloneModuleAttributes(sourceModule: Module, targetModule: Module): void;
	removeModuleAttributes(module: Module): void;
	removeAllModuleAttributes(): void;
	moveModuleConnections(
		oldModule: Module,
		newModule: Module,
		filterConnection: (arg0: ModuleGraphConnection) => boolean
	): void;
	copyOutgoingModuleConnections(
		oldModule: Module,
		newModule: Module,
		filterConnection: (arg0: ModuleGraphConnection) => boolean
	): void;
	addExtraReason(module: Module, explanation: string): void;
	getResolvedModule(dependency: Dependency): null | Module;
	getConnection(dependency: Dependency): undefined | ModuleGraphConnection;
	getModule(dependency: Dependency): null | Module;
	getOrigin(dependency: Dependency): null | Module;
	getResolvedOrigin(dependency: Dependency): null | Module;
	getIncomingConnections(module: Module): Iterable<ModuleGraphConnection>;
	getOutgoingConnections(module: Module): Iterable<ModuleGraphConnection>;
	getIncomingConnectionsByOriginModule(
		module: Module
	): Map<undefined | Module, ReadonlyArray<ModuleGraphConnection>>;
	getOutgoingConnectionsByModule(
		module: Module
	): undefined | Map<undefined | Module, ReadonlyArray<ModuleGraphConnection>>;
	getProfile(module: Module): null | ModuleProfile;
	setProfile(module: Module, profile: null | ModuleProfile): void;
	getIssuer(module: Module): null | Module;
	setIssuer(module: Module, issuer: null | Module): void;
	setIssuerIfUnset(module: Module, issuer: null | Module): void;
	getOptimizationBailout(
		module: Module
	): (string | ((requestShortener: RequestShortener) => string))[];
	getProvidedExports(module: Module): null | true | string[];
	isExportProvided(
		module: Module,
		exportName: string | string[]
	): null | boolean;
	getExportsInfo(module: Module): ExportsInfo;
	getExportInfo(module: Module, exportName: string): ExportInfo;
	getReadOnlyExportInfo(module: Module, exportName: string): ExportInfo;
	getUsedExports(
		module: Module,
		runtime: RuntimeSpec
	): null | boolean | SortableSet<string>;
	getPreOrderIndex(module: Module): null | number;
	getPostOrderIndex(module: Module): null | number;
	setPreOrderIndex(module: Module, index: number): void;
	setPreOrderIndexIfUnset(module: Module, index: number): boolean;
	setPostOrderIndex(module: Module, index: number): void;
	setPostOrderIndexIfUnset(module: Module, index: number): boolean;
	getDepth(module: Module): null | number;
	setDepth(module: Module, depth: number): void;
	setDepthIfLower(module: Module, depth: number): boolean;
	isAsync(module: Module): boolean;
	setAsync(module: Module): void;
	getMeta(thing?: any): Object;
	getMetaIfExisting(thing?: any): undefined | Object;
	freeze(cacheStage?: string): void;
	unfreeze(): void;
	cached<T extends any[], V>(
		fn: (moduleGraph: ModuleGraph, ...args: T) => V,
		...args: T
	): V;
	setModuleMemCaches(
		moduleMemCaches: Map<Module, WeakTupleMap<any, any>>
	): void;
	dependencyCacheProvide(dependency: Dependency, ...args: any[]): any;
	static getModuleGraphForModule(
		module: Module,
		deprecateMessage: string,
		deprecationCode: string
	): ModuleGraph;
	static setModuleGraphForModule(
		module: Module,
		moduleGraph: ModuleGraph
	): void;
	static clearModuleGraphForModule(module: Module): void;
	static ModuleGraphConnection: typeof ModuleGraphConnection;
}
declare class ModuleGraphConnection {
	constructor(
		originModule: null | Module,
		dependency: null | Dependency,
		module: Module,
		explanation?: string,
		weak?: boolean,
		condition?:
			| false
			| ((arg0: ModuleGraphConnection, arg1: RuntimeSpec) => ConnectionState)
	);
	originModule: null | Module;
	resolvedOriginModule: null | Module;
	dependency: null | Dependency;
	resolvedModule: Module;
	module: Module;
	weak: boolean;
	conditional: boolean;
	condition?: (
		arg0: ModuleGraphConnection,
		arg1: RuntimeSpec
	) => ConnectionState;
	explanations?: Set<string>;
	clone(): ModuleGraphConnection;
	addCondition(
		condition: (
			arg0: ModuleGraphConnection,
			arg1: RuntimeSpec
		) => ConnectionState
	): void;
	addExplanation(explanation: string): void;
	get explanation(): string;
	active: void;
	isActive(runtime: RuntimeSpec): boolean;
	isTargetActive(runtime: RuntimeSpec): boolean;
	getActiveState(runtime: RuntimeSpec): ConnectionState;
	setActive(value: boolean): void;
	static addConnectionStates: (
		a: ConnectionState,
		b: ConnectionState
	) => ConnectionState;
	static TRANSITIVE_ONLY: typeof TRANSITIVE_ONLY;
	static CIRCULAR_CONNECTION: typeof CIRCULAR_CONNECTION;
}
type ModuleInfo = ConcatenatedModuleInfo | ExternalModuleInfo;

/**
 * Options affecting the normal modules (`NormalModuleFactory`).
 */
declare interface ModuleOptions {
	/**
	 * An array of rules applied by default for modules.
	 */
	defaultRules?: (undefined | null | false | "" | 0 | RuleSetRule | "...")[];

	/**
	 * Enable warnings for full dynamic dependencies.
	 */
	exprContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup for full dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.exprContextRecursive'.
	 */
	exprContextRecursive?: boolean;

	/**
	 * Sets the default regular expression for full dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.exprContextRegExp'.
	 */
	exprContextRegExp?: boolean | RegExp;

	/**
	 * Set the default request for full dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.exprContextRequest'.
	 */
	exprContextRequest?: string;

	/**
	 * Specify options for each generator.
	 */
	generator?: GeneratorOptionsByModuleType;

	/**
	 * Don't parse files matching. It's matched against the full resolved request.
	 */
	noParse?: string | Function | RegExp | (string | Function | RegExp)[];

	/**
	 * Specify options for each parser.
	 */
	parser?: ParserOptionsByModuleType;

	/**
	 * An array of rules applied for modules.
	 */
	rules?: (undefined | null | false | "" | 0 | RuleSetRule | "...")[];

	/**
	 * Emit errors instead of warnings when imported names don't exist in imported module. Deprecated: This option has moved to 'module.parser.javascript.strictExportPresence'.
	 */
	strictExportPresence?: boolean;

	/**
	 * Handle the this context correctly according to the spec for namespace objects. Deprecated: This option has moved to 'module.parser.javascript.strictThisContextOnImports'.
	 */
	strictThisContextOnImports?: boolean;

	/**
	 * Enable warnings when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextCritical'.
	 */
	unknownContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextRecursive'.
	 */
	unknownContextRecursive?: boolean;

	/**
	 * Sets the regular expression when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextRegExp'.
	 */
	unknownContextRegExp?: boolean | RegExp;

	/**
	 * Sets the request when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextRequest'.
	 */
	unknownContextRequest?: string;

	/**
	 * Cache the resolving of module requests.
	 */
	unsafeCache?: boolean | Function;

	/**
	 * Enable warnings for partial dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.wrappedContextCritical'.
	 */
	wrappedContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup for partial dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.wrappedContextRecursive'.
	 */
	wrappedContextRecursive?: boolean;

	/**
	 * Set the inner regular expression for partial dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.wrappedContextRegExp'.
	 */
	wrappedContextRegExp?: RegExp;
}

/**
 * Options affecting the normal modules (`NormalModuleFactory`).
 */
declare interface ModuleOptionsNormalized {
	/**
	 * An array of rules applied by default for modules.
	 */
	defaultRules: (undefined | null | false | "" | 0 | RuleSetRule | "...")[];

	/**
	 * Specify options for each generator.
	 */
	generator: GeneratorOptionsByModuleType;

	/**
	 * Don't parse files matching. It's matched against the full resolved request.
	 */
	noParse?: string | Function | RegExp | (string | Function | RegExp)[];

	/**
	 * Specify options for each parser.
	 */
	parser: ParserOptionsByModuleType;

	/**
	 * An array of rules applied for modules.
	 */
	rules: (undefined | null | false | "" | 0 | RuleSetRule | "...")[];

	/**
	 * Cache the resolving of module requests.
	 */
	unsafeCache?: boolean | Function;
}
declare interface ModulePathData {
	id: string | number;
	hash: string;
	hashWithLength?: (arg0: number) => string;
}
declare abstract class ModuleProfile {
	startTime: number;
	factoryStartTime: number;
	factoryEndTime: number;
	factory: number;
	factoryParallelismFactor: number;
	restoringStartTime: number;
	restoringEndTime: number;
	restoring: number;
	restoringParallelismFactor: number;
	integrationStartTime: number;
	integrationEndTime: number;
	integration: number;
	integrationParallelismFactor: number;
	buildingStartTime: number;
	buildingEndTime: number;
	building: number;
	buildingParallelismFactor: number;
	storingStartTime: number;
	storingEndTime: number;
	storing: number;
	storingParallelismFactor: number;
	additionalFactoryTimes?: { start: number; end: number }[];
	additionalFactories: number;
	additionalFactoriesParallelismFactor: number;
	additionalIntegration: number;
	markFactoryStart(): void;
	markFactoryEnd(): void;
	markRestoringStart(): void;
	markRestoringEnd(): void;
	markIntegrationStart(): void;
	markIntegrationEnd(): void;
	markBuildingStart(): void;
	markBuildingEnd(): void;
	markStoringStart(): void;
	markStoringEnd(): void;

	/**
	 * Merge this profile into another one
	 */
	mergeInto(realProfile: ModuleProfile): void;
}
declare interface ModuleReferenceOptions {
	/**
	 * the properties/exports of the module
	 */
	ids: string[];

	/**
	 * true, when this referenced export is called
	 */
	call: boolean;

	/**
	 * true, when this referenced export is directly imported (not via property access)
	 */
	directImport: boolean;

	/**
	 * if the position is ASI safe or unknown
	 */
	asiSafe?: boolean;
}
declare interface ModuleSettings {
	/**
	 * Specifies the layer in which the module should be placed in.
	 */
	layer?: string;

	/**
	 * Module type to use for the module.
	 */
	type?: string;

	/**
	 * Options for the resolver.
	 */
	resolve?: ResolveOptionsWebpackOptions;

	/**
	 * Options for parsing.
	 */
	parser?: { [index: string]: any };

	/**
	 * The options for the module generator.
	 */
	generator?: { [index: string]: any };

	/**
	 * Flags a module as with or without side effects.
	 */
	sideEffects?: boolean;
}
declare abstract class ModuleTemplate {
	type: string;
	hooks: Readonly<{
		content: { tap: (options?: any, fn?: any) => void };
		module: { tap: (options?: any, fn?: any) => void };
		render: { tap: (options?: any, fn?: any) => void };
		package: { tap: (options?: any, fn?: any) => void };
		hash: { tap: (options?: any, fn?: any) => void };
	}>;
	get runtimeTemplate(): any;
}
declare class MultiCompiler {
	constructor(
		compilers: Compiler[] | Record<string, Compiler>,
		options: MultiCompilerOptions
	);
	hooks: Readonly<{
		done: SyncHook<[MultiStats]>;
		invalid: MultiHook<SyncHook<[null | string, number]>>;
		run: MultiHook<AsyncSeriesHook<[Compiler]>>;
		watchClose: SyncHook<[]>;
		watchRun: MultiHook<AsyncSeriesHook<[Compiler]>>;
		infrastructureLog: MultiHook<SyncBailHook<[string, string, any[]], true>>;
	}>;
	compilers: Compiler[];
	dependencies: WeakMap<Compiler, string[]>;
	running: boolean;
	get options(): WebpackOptionsNormalized[] & MultiCompilerOptions;
	get outputPath(): string;
	inputFileSystem: InputFileSystem;
	outputFileSystem: OutputFileSystem;
	watchFileSystem: WatchFileSystem;
	intermediateFileSystem: IntermediateFileSystem;
	getInfrastructureLogger(name?: any): WebpackLogger;
	setDependencies(compiler: Compiler, dependencies: string[]): void;
	validateDependencies(callback: CallbackFunction<MultiStats>): boolean;
	runWithDependencies(
		compilers: Compiler[],
		fn: (compiler: Compiler, callback: CallbackFunction<MultiStats>) => any,
		callback: CallbackFunction<MultiStats>
	): void;
	watch(
		watchOptions: WatchOptions | WatchOptions[],
		handler: CallbackFunction<MultiStats>
	): MultiWatching;
	run(callback: CallbackFunction<MultiStats>): void;
	purgeInputFileSystem(): void;
	close(callback: CallbackFunction<void>): void;
}
declare interface MultiCompilerOptions {
	/**
	 * how many Compilers are allows to run at the same time in parallel
	 */
	parallelism?: number;
}
declare abstract class MultiStats {
	stats: Stats[];
	get hash(): string;
	hasErrors(): boolean;
	hasWarnings(): boolean;
	toJson(options?: any): StatsCompilation;
	toString(options?: any): string;
}
declare abstract class MultiWatching {
	watchings: Watching[];
	compiler: MultiCompiler;
	invalidate(callback?: CallbackFunction<void>): void;
	suspend(): void;
	resume(): void;
	close(callback: CallbackFunction<void>): void;
}
declare class NamedChunkIdsPlugin {
	constructor(options?: NamedChunkIdsPluginOptions);
	delimiter: string;
	context?: string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface NamedChunkIdsPluginOptions {
	/**
	 * context
	 */
	context?: string;

	/**
	 * delimiter
	 */
	delimiter?: string;
}
declare class NamedModuleIdsPlugin {
	constructor(options?: NamedModuleIdsPluginOptions);
	options: NamedModuleIdsPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface NamedModuleIdsPluginOptions {
	/**
	 * context
	 */
	context?: string;
}
declare class NaturalModuleIdsPlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface NeedBuildContext {
	compilation: Compilation;
	fileSystemInfo: FileSystemInfo;
	valueCacheVersions: Map<string, string | Set<string>>;
}
declare class NoEmitOnErrorsPlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type Node = false | NodeOptions;
declare class NodeEnvironmentPlugin {
	constructor(options: {
		/**
		 * infrastructure logging options
		 */
		infrastructureLogging: InfrastructureLogging;
	});
	options: {
		/**
		 * infrastructure logging options
		 */
		infrastructureLogging: InfrastructureLogging;
	};

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}

/**
 * Options object for node compatibility features.
 */
declare interface NodeOptions {
	/**
	 * Include a polyfill for the '__dirname' variable.
	 */
	__dirname?: boolean | "warn-mock" | "mock" | "eval-only";

	/**
	 * Include a polyfill for the '__filename' variable.
	 */
	__filename?: boolean | "warn-mock" | "mock" | "eval-only";

	/**
	 * Include a polyfill for the 'global' variable.
	 */
	global?: boolean | "warn";
}
declare class NodeSourcePlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class NodeTargetPlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class NodeTemplatePlugin {
	constructor(options?: NodeTemplatePluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface NodeTemplatePluginOptions {
	/**
	 * enable async chunk loading
	 */
	asyncChunkLoading?: boolean;
}
declare class NormalModule extends Module {
	constructor(__0: NormalModuleCreateData);
	request: string;
	userRequest: string;
	rawRequest: string;
	binary: boolean;
	parser: Parser;
	parserOptions?: Record<string, any>;
	generator: Generator;
	generatorOptions?: Record<string, any>;
	resource: string;
	resourceResolveData?: Record<string, any>;
	matchResource?: string;
	loaders: LoaderItem[];
	error?: null | WebpackError;
	restoreFromUnsafeCache(
		unsafeCacheData?: any,
		normalModuleFactory?: any
	): void;
	createSourceForAsset(
		context: string,
		name: string,
		content: string,
		sourceMap?: any,
		associatedObjectForCache?: Object
	): Source;
	getCurrentLoader(loaderContext?: any, index?: any): null | LoaderItem;
	createSource(
		context: string,
		content: string | Buffer,
		sourceMap?: any,
		associatedObjectForCache?: Object
	): Source;
	markModuleAsErrored(error: WebpackError): void;
	applyNoParseRule(rule?: any, content?: any): any;
	shouldPreventParsing(noParseRule?: any, request?: any): any;
	static getCompilationHooks(
		compilation: Compilation
	): NormalModuleCompilationHooks;
	static deserialize(context?: any): NormalModule;
}
declare interface NormalModuleCompilationHooks {
	loader: SyncHook<[object, NormalModule]>;
	beforeLoaders: SyncHook<[LoaderItem[], NormalModule, object]>;
	beforeParse: SyncHook<[NormalModule]>;
	beforeSnapshot: SyncHook<[NormalModule]>;
	readResourceForScheme: HookMap<
		AsyncSeriesBailHook<[string, NormalModule], string | Buffer>
	>;
	readResource: HookMap<AsyncSeriesBailHook<[object], string | Buffer>>;
	needBuild: AsyncSeriesBailHook<[NormalModule, NeedBuildContext], boolean>;
}
declare interface NormalModuleCreateData {
	/**
	 * an optional layer in which the module is
	 */
	layer?: string;

	/**
	 * module type. When deserializing, this is set to an empty string "".
	 */
	type: "" | "javascript/auto" | "javascript/dynamic" | "javascript/esm";

	/**
	 * request string
	 */
	request: string;

	/**
	 * request intended by user (without loaders from config)
	 */
	userRequest: string;

	/**
	 * request without resolving
	 */
	rawRequest: string;

	/**
	 * list of loaders
	 */
	loaders: LoaderItem[];

	/**
	 * path + query of the real resource
	 */
	resource: string;

	/**
	 * resource resolve data
	 */
	resourceResolveData?: Record<string, any>;

	/**
	 * context directory for resolving
	 */
	context: string;

	/**
	 * path + query of the matched resource (virtual)
	 */
	matchResource?: string;

	/**
	 * the parser used
	 */
	parser: Parser;

	/**
	 * the options of the parser used
	 */
	parserOptions?: Record<string, any>;

	/**
	 * the generator used
	 */
	generator: Generator;

	/**
	 * the options of the generator used
	 */
	generatorOptions?: Record<string, any>;

	/**
	 * options used for resolving requests from this module
	 */
	resolveOptions?: ResolveOptionsWebpackOptions;
}
declare abstract class NormalModuleFactory extends ModuleFactory {
	hooks: Readonly<{
		resolve: AsyncSeriesBailHook<[ResolveData], false | void | Module>;
		resolveForScheme: HookMap<
			AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>
		>;
		resolveInScheme: HookMap<
			AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>
		>;
		factorize: AsyncSeriesBailHook<[ResolveData], Module>;
		beforeResolve: AsyncSeriesBailHook<[ResolveData], false | void>;
		afterResolve: AsyncSeriesBailHook<[ResolveData], false | void>;
		createModule: AsyncSeriesBailHook<
			[
				Partial<NormalModuleCreateData & { settings: ModuleSettings }>,
				ResolveData
			],
			void | Module
		>;
		module: SyncWaterfallHook<
			[
				Module,
				Partial<NormalModuleCreateData & { settings: ModuleSettings }>,
				ResolveData
			],
			Module
		>;
		createParser: HookMap<SyncBailHook<any, any>>;
		parser: HookMap<SyncHook<any>>;
		createGenerator: HookMap<SyncBailHook<any, any>>;
		generator: HookMap<SyncHook<any>>;
		createModuleClass: HookMap<SyncBailHook<any, any>>;
	}>;
	resolverFactory: ResolverFactory;
	ruleSet: RuleSet;
	context: string;
	fs: InputFileSystem;
	parserCache: Map<string, WeakMap<Object, any>>;
	generatorCache: Map<string, WeakMap<Object, Generator>>;
	cleanupForCache(): void;
	resolveResource(
		contextInfo?: any,
		context?: any,
		unresolvedResource?: any,
		resolver?: any,
		resolveContext?: any,
		callback?: any
	): void;
	resolveRequestArray(
		contextInfo?: any,
		context?: any,
		array?: any,
		resolver?: any,
		resolveContext?: any,
		callback?: any
	): any;
	getParser(type?: any, parserOptions?: object): any;
	createParser(type: string, parserOptions?: { [index: string]: any }): Parser;
	getGenerator(type?: any, generatorOptions?: object): undefined | Generator;
	createGenerator(type?: any, generatorOptions?: object): any;
	getResolver(type?: any, resolveOptions?: any): ResolverWithOptions;
}

/**
 * These properties are added by the NormalModule
 */
declare interface NormalModuleLoaderContext<OptionsType> {
	version: number;
	getOptions(): OptionsType;
	getOptions(schema: Parameters<typeof validateFunction>[0]): OptionsType;
	emitWarning(warning: Error): void;
	emitError(error: Error): void;
	getLogger(name?: string): WebpackLogger;
	resolve(
		context: string,
		request: string,
		callback: (
			err: null | ErrorWithDetail,
			res?: string | false,
			req?: ResolveRequest
		) => void
	): any;
	getResolve(options?: ResolveOptionsWithDependencyType): {
		(
			context: string,
			request: string,
			callback: (
				err: null | ErrorWithDetail,
				res?: string | false,
				req?: ResolveRequest
			) => void
		): void;
		(context: string, request: string): Promise<string>;
	};
	emitFile(
		name: string,
		content: string | Buffer,
		sourceMap?: string,
		assetInfo?: AssetInfo
	): void;
	addBuildDependency(dep: string): void;
	utils: {
		absolutify: (context: string, request: string) => string;
		contextify: (context: string, request: string) => string;
		createHash: (algorithm?: string) => Hash;
	};
	rootContext: string;
	fs: InputFileSystem;
	sourceMap?: boolean;
	mode: "none" | "development" | "production";
	webpack?: boolean;
	_module?: NormalModule;
	_compilation?: Compilation;
	_compiler?: Compiler;
}
declare class NormalModuleReplacementPlugin {
	/**
	 * Create an instance of the plugin
	 */
	constructor(
		resourceRegExp: RegExp,
		newResource: string | ((arg0: ResolveData) => void)
	);
	resourceRegExp: RegExp;
	newResource: string | ((arg0: ResolveData) => void);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type NormalizedStatsOptions = KnownNormalizedStatsOptions &
	Omit<
		StatsOptions,
		| "context"
		| "chunkGroups"
		| "requestShortener"
		| "chunksSort"
		| "modulesSort"
		| "chunkModulesSort"
		| "nestedModulesSort"
		| "assetsSort"
		| "ids"
		| "cachedAssets"
		| "groupAssetsByEmitStatus"
		| "groupAssetsByPath"
		| "groupAssetsByExtension"
		| "assetsSpace"
		| "excludeAssets"
		| "excludeModules"
		| "warningsFilter"
		| "cachedModules"
		| "orphanModules"
		| "dependentModules"
		| "runtimeModules"
		| "groupModulesByCacheStatus"
		| "groupModulesByLayer"
		| "groupModulesByAttributes"
		| "groupModulesByPath"
		| "groupModulesByExtension"
		| "groupModulesByType"
		| "entrypoints"
		| "chunkGroupAuxiliary"
		| "chunkGroupChildren"
		| "chunkGroupMaxAssets"
		| "modulesSpace"
		| "chunkModulesSpace"
		| "nestedModulesSpace"
		| "logging"
		| "loggingDebug"
		| "loggingTrace"
		| "_env"
	> &
	Record<string, any>;
declare class NullDependency extends Dependency {
	constructor();
	static Template: typeof NullDependencyTemplate;
	static NO_EXPORTS_REFERENCED: string[][];
	static EXPORTS_OBJECT_REFERENCED: string[][];
	static TRANSITIVE: typeof TRANSITIVE;
}
declare class NullDependencyTemplate extends DependencyTemplate {
	constructor();
}
declare interface ObjectDeserializerContext {
	read: () => any;
	setCircularReference: (arg0?: any) => void;
}
declare interface ObjectSerializer {
	serialize: (arg0: any, arg1: ObjectSerializerContext) => void;
	deserialize: (arg0: ObjectDeserializerContext) => any;
}
declare interface ObjectSerializerContext {
	write: (arg0?: any) => void;
	setCircularReference: (arg0?: any) => void;
}
declare class OccurrenceChunkIdsPlugin {
	constructor(options?: OccurrenceChunkIdsPluginOptions);
	options: OccurrenceChunkIdsPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface OccurrenceChunkIdsPluginOptions {
	/**
	 * Prioritise initial size over total size.
	 */
	prioritiseInitial?: boolean;
}
declare class OccurrenceModuleIdsPlugin {
	constructor(options?: OccurrenceModuleIdsPluginOptions);
	options: OccurrenceModuleIdsPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface OccurrenceModuleIdsPluginOptions {
	/**
	 * Prioritise initial size over total size.
	 */
	prioritiseInitial?: boolean;
}

/**
 * Enables/Disables integrated optimizations.
 */
declare interface Optimization {
	/**
	 * Check for incompatible wasm types when importing/exporting from/to ESM.
	 */
	checkWasmTypes?: boolean;

	/**
	 * Define the algorithm to choose chunk ids (named: readable ids for better debugging, deterministic: numeric hash ids for better long term caching, size: numeric ids focused on minimal initial download size, total-size: numeric ids focused on minimal total download size, false: no algorithm used, as custom one can be provided via plugin).
	 */
	chunkIds?:
		| false
		| "natural"
		| "named"
		| "deterministic"
		| "size"
		| "total-size";

	/**
	 * Concatenate modules when possible to generate less modules, more efficient code and enable more optimizations by the minimizer.
	 */
	concatenateModules?: boolean;

	/**
	 * Emit assets even when errors occur. Critical errors are emitted into the generated code and will cause errors at runtime.
	 */
	emitOnErrors?: boolean;

	/**
	 * Also flag chunks as loaded which contain a subset of the modules.
	 */
	flagIncludedChunks?: boolean;

	/**
	 * Creates a module-internal dependency graph for top level symbols, exports and imports, to improve unused exports detection.
	 */
	innerGraph?: boolean;

	/**
	 * Rename exports when possible to generate shorter code (depends on optimization.usedExports and optimization.providedExports, true/"deterministic": generate short deterministic names optimized for caching, "size": generate the shortest possible names).
	 */
	mangleExports?: boolean | "deterministic" | "size";

	/**
	 * Reduce size of WASM by changing imports to shorter strings.
	 */
	mangleWasmImports?: boolean;

	/**
	 * Merge chunks which contain the same modules.
	 */
	mergeDuplicateChunks?: boolean;

	/**
	 * Enable minimizing the output. Uses optimization.minimizer.
	 */
	minimize?: boolean;

	/**
	 * Minimizer(s) to use for minimizing the output.
	 */
	minimizer?: (
		| undefined
		| null
		| false
		| ""
		| 0
		| ((this: Compiler, compiler: Compiler) => void)
		| WebpackPluginInstance
		| "..."
	)[];

	/**
	 * Define the algorithm to choose module ids (natural: numeric ids in order of usage, named: readable ids for better debugging, hashed: (deprecated) short hashes as ids for better long term caching, deterministic: numeric hash ids for better long term caching, size: numeric ids focused on minimal initial download size, false: no algorithm used, as custom one can be provided via plugin).
	 */
	moduleIds?: false | "natural" | "named" | "deterministic" | "size" | "hashed";

	/**
	 * Avoid emitting assets when errors occur (deprecated: use 'emitOnErrors' instead).
	 */
	noEmitOnErrors?: boolean;

	/**
	 * Set process.env.NODE_ENV to a specific value.
	 */
	nodeEnv?: string | false;

	/**
	 * Generate records with relative paths to be able to move the context folder.
	 */
	portableRecords?: boolean;

	/**
	 * Figure out which exports are provided by modules to generate more efficient code.
	 */
	providedExports?: boolean;

	/**
	 * Use real [contenthash] based on final content of the assets.
	 */
	realContentHash?: boolean;

	/**
	 * Removes modules from chunks when these modules are already included in all parents.
	 */
	removeAvailableModules?: boolean;

	/**
	 * Remove chunks which are empty.
	 */
	removeEmptyChunks?: boolean;

	/**
	 * Create an additional chunk which contains only the webpack runtime and chunk hash maps.
	 */
	runtimeChunk?:
		| boolean
		| "single"
		| "multiple"
		| {
				/**
				 * The name or name factory for the runtime chunks.
				 */
				name?: string | Function;
		  };

	/**
	 * Skip over modules which contain no side effects when exports are not used (false: disabled, 'flag': only use manually placed side effects flag, true: also analyse source code for side effects).
	 */
	sideEffects?: boolean | "flag";

	/**
	 * Optimize duplication and caching by splitting chunks by shared modules and cache group.
	 */
	splitChunks?: false | OptimizationSplitChunksOptions;

	/**
	 * Figure out which exports are used by modules to mangle export names, omit unused exports and generate more efficient code (true: analyse used exports for each runtime, "global": analyse exports globally for all runtimes combined).
	 */
	usedExports?: boolean | "global";
}

/**
 * Options object for describing behavior of a cache group selecting modules that should be cached together.
 */
declare interface OptimizationSplitChunksCacheGroup {
	/**
	 * Sets the name delimiter for created chunks.
	 */
	automaticNameDelimiter?: string;

	/**
	 * Select chunks for determining cache group content (defaults to "initial", "initial" and "all" requires adding these chunks to the HTML).
	 */
	chunks?: RegExp | "all" | "initial" | "async" | ((chunk: Chunk) => boolean);

	/**
	 * Ignore minimum size, minimum chunks and maximum requests and always create chunks for this cache group.
	 */
	enforce?: boolean;

	/**
	 * Size threshold at which splitting is enforced and other restrictions (minRemainingSize, maxAsyncRequests, maxInitialRequests) are ignored.
	 */
	enforceSizeThreshold?: number | { [index: string]: number };

	/**
	 * Sets the template for the filename for created chunks.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Sets the hint for chunk id.
	 */
	idHint?: string;

	/**
	 * Assign modules to a cache group by module layer.
	 */
	layer?: string | Function | RegExp;

	/**
	 * Maximum number of requests which are accepted for on-demand loading.
	 */
	maxAsyncRequests?: number;

	/**
	 * Maximal size hint for the on-demand chunks.
	 */
	maxAsyncSize?: number | { [index: string]: number };

	/**
	 * Maximum number of initial chunks which are accepted for an entry point.
	 */
	maxInitialRequests?: number;

	/**
	 * Maximal size hint for the initial chunks.
	 */
	maxInitialSize?: number | { [index: string]: number };

	/**
	 * Maximal size hint for the created chunks.
	 */
	maxSize?: number | { [index: string]: number };

	/**
	 * Minimum number of times a module has to be duplicated until it's considered for splitting.
	 */
	minChunks?: number;

	/**
	 * Minimal size for the chunks the stay after moving the modules to a new chunk.
	 */
	minRemainingSize?: number | { [index: string]: number };

	/**
	 * Minimal size for the created chunk.
	 */
	minSize?: number | { [index: string]: number };

	/**
	 * Minimum size reduction due to the created chunk.
	 */
	minSizeReduction?: number | { [index: string]: number };

	/**
	 * Give chunks for this cache group a name (chunks with equal name are merged).
	 */
	name?: string | false | Function;

	/**
	 * Priority of this cache group.
	 */
	priority?: number;

	/**
	 * Try to reuse existing chunk (with name) when it has matching modules.
	 */
	reuseExistingChunk?: boolean;

	/**
	 * Assign modules to a cache group by module name.
	 */
	test?: string | Function | RegExp;

	/**
	 * Assign modules to a cache group by module type.
	 */
	type?: string | Function | RegExp;

	/**
	 * Compare used exports when checking common modules. Modules will only be put in the same chunk when exports are equal.
	 */
	usedExports?: boolean;
}

/**
 * Options object for splitting chunks into smaller chunks.
 */
declare interface OptimizationSplitChunksOptions {
	/**
	 * Sets the name delimiter for created chunks.
	 */
	automaticNameDelimiter?: string;

	/**
	 * Assign modules to a cache group (modules from different cache groups are tried to keep in separate chunks, default categories: 'default', 'defaultVendors').
	 */
	cacheGroups?: {
		[index: string]:
			| string
			| false
			| Function
			| RegExp
			| OptimizationSplitChunksCacheGroup;
	};

	/**
	 * Select chunks for determining shared modules (defaults to "async", "initial" and "all" requires adding these chunks to the HTML).
	 */
	chunks?: RegExp | "all" | "initial" | "async" | ((chunk: Chunk) => boolean);

	/**
	 * Sets the size types which are used when a number is used for sizes.
	 */
	defaultSizeTypes?: string[];

	/**
	 * Size threshold at which splitting is enforced and other restrictions (minRemainingSize, maxAsyncRequests, maxInitialRequests) are ignored.
	 */
	enforceSizeThreshold?: number | { [index: string]: number };

	/**
	 * Options for modules not selected by any other cache group.
	 */
	fallbackCacheGroup?: {
		/**
		 * Sets the name delimiter for created chunks.
		 */
		automaticNameDelimiter?: string;
		/**
		 * Select chunks for determining shared modules (defaults to "async", "initial" and "all" requires adding these chunks to the HTML).
		 */
		chunks?: RegExp | "all" | "initial" | "async" | ((chunk: Chunk) => boolean);
		/**
		 * Maximal size hint for the on-demand chunks.
		 */
		maxAsyncSize?: number | { [index: string]: number };
		/**
		 * Maximal size hint for the initial chunks.
		 */
		maxInitialSize?: number | { [index: string]: number };
		/**
		 * Maximal size hint for the created chunks.
		 */
		maxSize?: number | { [index: string]: number };
		/**
		 * Minimal size for the created chunk.
		 */
		minSize?: number | { [index: string]: number };
		/**
		 * Minimum size reduction due to the created chunk.
		 */
		minSizeReduction?: number | { [index: string]: number };
	};

	/**
	 * Sets the template for the filename for created chunks.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Prevents exposing path info when creating names for parts splitted by maxSize.
	 */
	hidePathInfo?: boolean;

	/**
	 * Maximum number of requests which are accepted for on-demand loading.
	 */
	maxAsyncRequests?: number;

	/**
	 * Maximal size hint for the on-demand chunks.
	 */
	maxAsyncSize?: number | { [index: string]: number };

	/**
	 * Maximum number of initial chunks which are accepted for an entry point.
	 */
	maxInitialRequests?: number;

	/**
	 * Maximal size hint for the initial chunks.
	 */
	maxInitialSize?: number | { [index: string]: number };

	/**
	 * Maximal size hint for the created chunks.
	 */
	maxSize?: number | { [index: string]: number };

	/**
	 * Minimum number of times a module has to be duplicated until it's considered for splitting.
	 */
	minChunks?: number;

	/**
	 * Minimal size for the chunks the stay after moving the modules to a new chunk.
	 */
	minRemainingSize?: number | { [index: string]: number };

	/**
	 * Minimal size for the created chunks.
	 */
	minSize?: number | { [index: string]: number };

	/**
	 * Minimum size reduction due to the created chunk.
	 */
	minSizeReduction?: number | { [index: string]: number };

	/**
	 * Give chunks created a name (chunks with equal name are merged).
	 */
	name?: string | false | Function;

	/**
	 * Compare used exports when checking common modules. Modules will only be put in the same chunk when exports are equal.
	 */
	usedExports?: boolean;
}
declare abstract class OptionsApply {
	process(options?: any, compiler?: any): void;
}
declare interface OriginRecord {
	module: Module;
	loc: DependencyLocation;
	request: string;
}
declare class OriginalSource extends Source {
	constructor(source: string | Buffer, name: string);
	getName(): string;
}

/**
 * Options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
 */
declare interface Output {
	/**
	 * Add a container for define/require functions in the AMD module.
	 */
	amdContainer?: string;

	/**
	 * The filename of asset modules as relative path inside the 'output.path' directory.
	 */
	assetModuleFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;

	/**
	 * Add a comment in the UMD wrapper.
	 */
	auxiliaryComment?: string | LibraryCustomUmdCommentObject;

	/**
	 * Add charset attribute for script tag.
	 */
	charset?: boolean;

	/**
	 * Specifies the filename template of output files of non-initial chunks on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	chunkFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * The format of chunks (formats included by default are 'array-push' (web/WebWorker), 'commonjs' (node.js), 'module' (ESM), but others might be added by plugins).
	 */
	chunkFormat?: string | false;

	/**
	 * Number of milliseconds before chunk request expires.
	 */
	chunkLoadTimeout?: number;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: string | false;

	/**
	 * The global variable used by webpack for loading of chunks.
	 */
	chunkLoadingGlobal?: string;

	/**
	 * Clean the output directory before emit.
	 */
	clean?: boolean | CleanOptions;

	/**
	 * Check if to be emitted file already exists and have the same content before writing to output filesystem.
	 */
	compareBeforeEmit?: boolean;

	/**
	 * This option enables cross-origin loading of chunks.
	 */
	crossOriginLoading?: false | "anonymous" | "use-credentials";

	/**
	 * Specifies the filename template of non-initial output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssChunkFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Specifies the filename template of output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Similar to `output.devtoolModuleFilenameTemplate`, but used in the case of duplicate module identifiers.
	 */
	devtoolFallbackModuleFilenameTemplate?: string | Function;

	/**
	 * Filename template string of function for the sources array in a generated SourceMap.
	 */
	devtoolModuleFilenameTemplate?: string | Function;

	/**
	 * Module namespace to use when interpolating filename template string for the sources array in a generated SourceMap. Defaults to `output.library` if not set. It's useful for avoiding runtime collisions in sourcemaps from multiple webpack projects built as libraries.
	 */
	devtoolNamespace?: string;

	/**
	 * List of chunk loading types enabled for use by entry points.
	 */
	enabledChunkLoadingTypes?: string[];

	/**
	 * List of library types enabled for use by entry points.
	 */
	enabledLibraryTypes?: string[];

	/**
	 * List of wasm loading types enabled for use by entry points.
	 */
	enabledWasmLoadingTypes?: string[];

	/**
	 * The abilities of the environment where the webpack generated code should run.
	 */
	environment?: Environment;

	/**
	 * Specifies the filename of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * An expression which is used to address the global object/scope in runtime code.
	 */
	globalObject?: string;

	/**
	 * Digest type used for the hash.
	 */
	hashDigest?: string;

	/**
	 * Number of chars which are used for the hash.
	 */
	hashDigestLength?: number;

	/**
	 * Algorithm used for generation the hash (see node.js crypto package).
	 */
	hashFunction?: string | typeof Hash;

	/**
	 * Any string which is added to the hash to salt it.
	 */
	hashSalt?: string;

	/**
	 * The filename of the Hot Update Chunks. They are inside the output.path directory.
	 */
	hotUpdateChunkFilename?: string;

	/**
	 * The global variable used by webpack for loading of hot update chunks.
	 */
	hotUpdateGlobal?: string;

	/**
	 * The filename of the Hot Update Main File. It is inside the 'output.path' directory.
	 */
	hotUpdateMainFilename?: string;

	/**
	 * Ignore warnings in the browser.
	 */
	ignoreBrowserWarnings?: boolean;

	/**
	 * Wrap javascript code into IIFE's to avoid leaking into global scope.
	 */
	iife?: boolean;

	/**
	 * The name of the native import() function (can be exchanged for a polyfill).
	 */
	importFunctionName?: string;

	/**
	 * The name of the native import.meta object (can be exchanged for a polyfill).
	 */
	importMetaName?: string;

	/**
	 * Make the output files a library, exporting the exports of the entry point.
	 */
	library?: string | string[] | LibraryOptions | LibraryCustomUmdObject;

	/**
	 * Specify which export should be exposed as library.
	 */
	libraryExport?: string | string[];

	/**
	 * Type of library (types included by default are 'var', 'module', 'assign', 'assign-properties', 'this', 'window', 'self', 'global', 'commonjs', 'commonjs2', 'commonjs-module', 'commonjs-static', 'amd', 'amd-require', 'umd', 'umd2', 'jsonp', 'system', but others might be added by plugins).
	 */
	libraryTarget?: string;

	/**
	 * Output javascript files as module source type.
	 */
	module?: boolean;

	/**
	 * The output directory as **absolute path** (required).
	 */
	path?: string;

	/**
	 * Include comments with information about the modules.
	 */
	pathinfo?: boolean | "verbose";

	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * This option enables loading async chunks via a custom script type, such as script type="module".
	 */
	scriptType?: false | "module" | "text/javascript";

	/**
	 * The filename of the SourceMaps for the JavaScript files. They are inside the 'output.path' directory.
	 */
	sourceMapFilename?: string;

	/**
	 * Prefixes every line of the source in the bundle with this string.
	 */
	sourcePrefix?: string;

	/**
	 * Handles error in module loading correctly at a performance cost. This will handle module error compatible with the EcmaScript Modules spec.
	 */
	strictModuleErrorHandling?: boolean;

	/**
	 * Handles exceptions in module loading correctly at a performance cost (Deprecated). This will handle module error compatible with the Node.js CommonJS way.
	 */
	strictModuleExceptionHandling?: boolean;

	/**
	 * Use a Trusted Types policy to create urls for chunks. 'output.uniqueName' is used a default policy name. Passing a string sets a custom policy name.
	 */
	trustedTypes?: string | true | TrustedTypes;

	/**
	 * If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.
	 */
	umdNamedDefine?: boolean;

	/**
	 * A unique name of the webpack build to avoid multiple webpack runtimes to conflict when using globals.
	 */
	uniqueName?: string;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: string | false;

	/**
	 * The filename of WebAssembly modules as relative path inside the 'output.path' directory.
	 */
	webassemblyModuleFilename?: string;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	workerChunkLoading?: string | false;

	/**
	 * Worker public path. Much like the public path, this sets the location where the worker script file is intended to be found. If not set, webpack will use the publicPath. Don't set this option unless your worker scripts are located at a different path from your other script files.
	 */
	workerPublicPath?: string;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	workerWasmLoading?: string | false;
}
declare interface OutputFileSystem {
	writeFile: (
		arg0: string,
		arg1: string | Buffer,
		arg2: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
	mkdir: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
	readdir?: (
		arg0: string,
		arg1: (
			arg0?: null | NodeJS.ErrnoException,
			arg1?: (string | Buffer)[] | IDirent[]
		) => void
	) => void;
	rmdir?: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
	unlink?: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
	stat: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: IStats) => void
	) => void;
	lstat?: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: IStats) => void
	) => void;
	readFile: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: string | Buffer) => void
	) => void;
	join?: (arg0: string, arg1: string) => string;
	relative?: (arg0: string, arg1: string) => string;
	dirname?: (arg0: string) => string;
}

/**
 * Normalized options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
 */
declare interface OutputNormalized {
	/**
	 * The filename of asset modules as relative path inside the 'output.path' directory.
	 */
	assetModuleFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;

	/**
	 * Add charset attribute for script tag.
	 */
	charset?: boolean;

	/**
	 * Specifies the filename template of output files of non-initial chunks on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	chunkFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * The format of chunks (formats included by default are 'array-push' (web/WebWorker), 'commonjs' (node.js), 'module' (ESM), but others might be added by plugins).
	 */
	chunkFormat?: string | false;

	/**
	 * Number of milliseconds before chunk request expires.
	 */
	chunkLoadTimeout?: number;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: string | false;

	/**
	 * The global variable used by webpack for loading of chunks.
	 */
	chunkLoadingGlobal?: string;

	/**
	 * Clean the output directory before emit.
	 */
	clean?: boolean | CleanOptions;

	/**
	 * Check if to be emitted file already exists and have the same content before writing to output filesystem.
	 */
	compareBeforeEmit?: boolean;

	/**
	 * This option enables cross-origin loading of chunks.
	 */
	crossOriginLoading?: false | "anonymous" | "use-credentials";

	/**
	 * Specifies the filename template of non-initial output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssChunkFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Specifies the filename template of output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Similar to `output.devtoolModuleFilenameTemplate`, but used in the case of duplicate module identifiers.
	 */
	devtoolFallbackModuleFilenameTemplate?: string | Function;

	/**
	 * Filename template string of function for the sources array in a generated SourceMap.
	 */
	devtoolModuleFilenameTemplate?: string | Function;

	/**
	 * Module namespace to use when interpolating filename template string for the sources array in a generated SourceMap. Defaults to `output.library` if not set. It's useful for avoiding runtime collisions in sourcemaps from multiple webpack projects built as libraries.
	 */
	devtoolNamespace?: string;

	/**
	 * List of chunk loading types enabled for use by entry points.
	 */
	enabledChunkLoadingTypes?: string[];

	/**
	 * List of library types enabled for use by entry points.
	 */
	enabledLibraryTypes?: string[];

	/**
	 * List of wasm loading types enabled for use by entry points.
	 */
	enabledWasmLoadingTypes?: string[];

	/**
	 * The abilities of the environment where the webpack generated code should run.
	 */
	environment?: Environment;

	/**
	 * Specifies the filename of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * An expression which is used to address the global object/scope in runtime code.
	 */
	globalObject?: string;

	/**
	 * Digest type used for the hash.
	 */
	hashDigest?: string;

	/**
	 * Number of chars which are used for the hash.
	 */
	hashDigestLength?: number;

	/**
	 * Algorithm used for generation the hash (see node.js crypto package).
	 */
	hashFunction?: string | typeof Hash;

	/**
	 * Any string which is added to the hash to salt it.
	 */
	hashSalt?: string;

	/**
	 * The filename of the Hot Update Chunks. They are inside the output.path directory.
	 */
	hotUpdateChunkFilename?: string;

	/**
	 * The global variable used by webpack for loading of hot update chunks.
	 */
	hotUpdateGlobal?: string;

	/**
	 * The filename of the Hot Update Main File. It is inside the 'output.path' directory.
	 */
	hotUpdateMainFilename?: string;

	/**
	 * Ignore warnings in the browser.
	 */
	ignoreBrowserWarnings?: boolean;

	/**
	 * Wrap javascript code into IIFE's to avoid leaking into global scope.
	 */
	iife?: boolean;

	/**
	 * The name of the native import() function (can be exchanged for a polyfill).
	 */
	importFunctionName?: string;

	/**
	 * The name of the native import.meta object (can be exchanged for a polyfill).
	 */
	importMetaName?: string;

	/**
	 * Options for library.
	 */
	library?: LibraryOptions;

	/**
	 * Output javascript files as module source type.
	 */
	module?: boolean;

	/**
	 * The output directory as **absolute path** (required).
	 */
	path?: string;

	/**
	 * Include comments with information about the modules.
	 */
	pathinfo?: boolean | "verbose";

	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * This option enables loading async chunks via a custom script type, such as script type="module".
	 */
	scriptType?: false | "module" | "text/javascript";

	/**
	 * The filename of the SourceMaps for the JavaScript files. They are inside the 'output.path' directory.
	 */
	sourceMapFilename?: string;

	/**
	 * Prefixes every line of the source in the bundle with this string.
	 */
	sourcePrefix?: string;

	/**
	 * Handles error in module loading correctly at a performance cost. This will handle module error compatible with the EcmaScript Modules spec.
	 */
	strictModuleErrorHandling?: boolean;

	/**
	 * Handles exceptions in module loading correctly at a performance cost (Deprecated). This will handle module error compatible with the Node.js CommonJS way.
	 */
	strictModuleExceptionHandling?: boolean;

	/**
	 * Use a Trusted Types policy to create urls for chunks.
	 */
	trustedTypes?: TrustedTypes;

	/**
	 * A unique name of the webpack build to avoid multiple webpack runtimes to conflict when using globals.
	 */
	uniqueName?: string;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: string | false;

	/**
	 * The filename of WebAssembly modules as relative path inside the 'output.path' directory.
	 */
	webassemblyModuleFilename?: string;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	workerChunkLoading?: string | false;

	/**
	 * Worker public path. Much like the public path, this sets the location where the worker script file is intended to be found. If not set, webpack will use the publicPath. Don't set this option unless your worker scripts are located at a different path from your other script files.
	 */
	workerPublicPath?: string;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	workerWasmLoading?: string | false;
}
declare interface ParameterizedComparator<TArg, T> {
	(arg0: TArg): Comparator<T>;
}
declare interface ParsedIdentifier {
	request: string;
	query: string;
	fragment: string;
	directory: boolean;
	module: boolean;
	file: boolean;
	internal: boolean;
}
declare class Parser {
	constructor();
	parse(
		source: string | Buffer | PreparsedAst,
		state: ParserState
	): ParserState;
}
type ParserOptionsByModuleType = ParserOptionsByModuleTypeKnown &
	ParserOptionsByModuleTypeUnknown;

/**
 * Specify options for each parser.
 */
declare interface ParserOptionsByModuleTypeKnown {
	/**
	 * Parser options for asset modules.
	 */
	asset?: AssetParserOptions;

	/**
	 * No parser options are supported for this module type.
	 */
	"asset/inline"?: EmptyParserOptions;

	/**
	 * No parser options are supported for this module type.
	 */
	"asset/resource"?: EmptyParserOptions;

	/**
	 * No parser options are supported for this module type.
	 */
	"asset/source"?: EmptyParserOptions;

	/**
	 * Parser options for javascript modules.
	 */
	javascript?: JavascriptParserOptions;

	/**
	 * Parser options for javascript modules.
	 */
	"javascript/auto"?: JavascriptParserOptions;

	/**
	 * Parser options for javascript modules.
	 */
	"javascript/dynamic"?: JavascriptParserOptions;

	/**
	 * Parser options for javascript modules.
	 */
	"javascript/esm"?: JavascriptParserOptions;
}

/**
 * Specify options for each parser.
 */
declare interface ParserOptionsByModuleTypeUnknown {
	[index: string]: { [index: string]: any };
}
type ParserState = Record<string, any> & ParserStateBase;
declare interface ParserStateBase {
	source: string | Buffer;
	current: NormalModule;
	module: NormalModule;
	compilation: Compilation;
	options: { [index: string]: any };
}
declare interface PathData {
	chunkGraph?: ChunkGraph;
	hash?: string;
	hashWithLength?: (arg0: number) => string;
	chunk?: Chunk | ChunkPathData;
	module?: Module | ModulePathData;
	runtime?: RuntimeSpec;
	filename?: string;
	basename?: string;
	query?: string;
	contentHashType?: string;
	contentHash?: string;
	contentHashWithLength?: (arg0: number) => string;
	noChunkHash?: boolean;
	url?: string;
}
type Pattern =
	| Identifier
	| MemberExpression
	| ObjectPattern
	| ArrayPattern
	| RestElement
	| AssignmentPattern;

/**
 * Configuration object for web performance recommendations.
 */
declare interface PerformanceOptions {
	/**
	 * Filter function to select assets that are checked.
	 */
	assetFilter?: Function;

	/**
	 * Sets the format of the hints: warnings, errors or nothing at all.
	 */
	hints?: false | "error" | "warning";

	/**
	 * File size limit (in bytes) when exceeded, that webpack will provide performance hints.
	 */
	maxAssetSize?: number;

	/**
	 * Total size of an entry point (in bytes).
	 */
	maxEntrypointSize?: number;
}
declare interface PitchLoaderDefinitionFunction<
	OptionsType = {},
	ContextAdditions = {}
> {
	(
		this: NormalModuleLoaderContext<OptionsType> &
			LoaderRunnerLoaderContext<OptionsType> &
			LoaderPluginLoaderContext &
			HotModuleReplacementPluginLoaderContext &
			ContextAdditions,
		remainingRequest: string,
		previousRequest: string,
		data: object
	): string | void | Buffer | Promise<string | Buffer>;
}
type Plugin =
	| undefined
	| null
	| false
	| ""
	| 0
	| { apply: (arg0: Resolver) => void }
	| ((this: Resolver, arg1: Resolver) => void);
declare interface PnpApiImpl {
	resolveToUnqualified: (arg0: string, arg1: string, arg2: object) => string;
}
declare interface PossibleFileSystemError {
	code?: string;
	errno?: number;
	path?: string;
	syscall?: string;
}
declare class PrefetchPlugin {
	constructor(context: string, request?: string);
	context: null | string;
	request: string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class PrefixSource extends Source {
	constructor(prefix: string, source: string | Source);
	original(): Source;
	getPrefix(): string;
}
declare interface PreparsedAst {
	[index: string]: any;
}
declare interface PrintedElement {
	element: string;
	content: string;
}
declare interface Problem {
	type: ProblemType;
	path: string;
	argument: string;
	value?: any;
	index?: number;
	expected?: string;
}
type ProblemType =
	| "unknown-argument"
	| "unexpected-non-array-in-path"
	| "unexpected-non-object-in-path"
	| "multiple-values-unexpected"
	| "invalid-value";
declare interface ProcessAssetsAdditionalOptions {
	additionalAssets?: true | Function;
}
declare class Profiler {
	constructor(inspector?: any);
	session: any;
	inspector: any;
	hasSession(): boolean;
	startProfiling(): Promise<void> | Promise<[any, any, any]>;
	sendCommand(method: string, params?: object): Promise<any>;
	destroy(): Promise<void>;
	stopProfiling(): Promise<{ profile: any }>;
}
declare class ProfilingPlugin {
	constructor(options?: ProfilingPluginOptions);
	outputPath: string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static Profiler: typeof Profiler;
}
declare interface ProfilingPluginOptions {
	/**
	 * Path to the output file e.g. `path.resolve(__dirname, 'profiling/events.json')`. Defaults to `events.json`.
	 */
	outputPath?: string;
}
declare class ProgressPlugin {
	constructor(options?: ProgressPluginArgument);
	profile?: null | boolean;
	handler?: (percentage: number, msg: string, ...args: string[]) => void;
	modulesCount?: number;
	dependenciesCount?: number;
	showEntries?: boolean;
	showModules?: boolean;
	showDependencies?: boolean;
	showActiveModules?: boolean;
	percentBy?: null | "entries" | "modules" | "dependencies";
	apply(compiler: Compiler | MultiCompiler): void;
	static getReporter(
		compiler: Compiler
	): undefined | ((p: number, ...args: string[]) => void);
	static defaultOptions: {
		profile: boolean;
		modulesCount: number;
		dependenciesCount: number;
		modules: boolean;
		dependencies: boolean;
		activeModules: boolean;
		entries: boolean;
	};
	static createDefaultHandler: (
		profile: undefined | null | boolean,
		logger: WebpackLogger
	) => (percentage: number, msg: string, ...args: string[]) => void;
}
type ProgressPluginArgument =
	| ProgressPluginOptions
	| ((percentage: number, msg: string, ...args: string[]) => void);

/**
 * Options object for the ProgressPlugin.
 */
declare interface ProgressPluginOptions {
	/**
	 * Show active modules count and one active module in progress message.
	 */
	activeModules?: boolean;

	/**
	 * Show dependencies count in progress message.
	 */
	dependencies?: boolean;

	/**
	 * Minimum dependencies count to start with. For better progress calculation. Default: 10000.
	 */
	dependenciesCount?: number;

	/**
	 * Show entries count in progress message.
	 */
	entries?: boolean;

	/**
	 * Function that executes for every progress step.
	 */
	handler?: (percentage: number, msg: string, ...args: string[]) => void;

	/**
	 * Show modules count in progress message.
	 */
	modules?: boolean;

	/**
	 * Minimum modules count to start with. For better progress calculation. Default: 5000.
	 */
	modulesCount?: number;

	/**
	 * Collect percent algorithm. By default it calculates by a median from modules, entries and dependencies percent.
	 */
	percentBy?: null | "entries" | "modules" | "dependencies";

	/**
	 * Collect profile data for progress steps. Default: false.
	 */
	profile?: null | boolean;
}
declare class ProvidePlugin {
	constructor(definitions: Record<string, string | string[]>);
	definitions: Record<string, string | string[]>;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class ProvideSharedPlugin {
	constructor(options: ProvideSharedPluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ProvideSharedPluginOptions {
	/**
	 * Modules that should be provided as shared modules to the share scope. When provided, property name is used to match modules, otherwise this is automatically inferred from share key.
	 */
	provides: Provides;

	/**
	 * Share scope name used for all provided modules (defaults to 'default').
	 */
	shareScope?: string;
}
type Provides = (string | ProvidesObject)[] | ProvidesObject;

/**
 * Advanced configuration for modules that should be provided as shared modules to the share scope.
 */
declare interface ProvidesConfig {
	/**
	 * Include the provided module directly instead behind an async request. This allows to use this shared module in initial load too. All possible shared modules need to be eager too.
	 */
	eager?: boolean;

	/**
	 * Key in the share scope under which the shared modules should be stored.
	 */
	shareKey?: string;

	/**
	 * Share scope name.
	 */
	shareScope?: string;

	/**
	 * Version of the provided module. Will replace lower matching versions, but not higher.
	 */
	version?: string | false;
}

/**
 * Modules that should be provided as shared modules to the share scope. Property names are used as share keys.
 */
declare interface ProvidesObject {
	[index: string]: string | ProvidesConfig;
}
declare interface RawChunkGroupOptions {
	preloadOrder?: number;
	prefetchOrder?: number;
	fetchPriority?: "auto" | "low" | "high";
}
type RawLoaderDefinition<
	OptionsType = {},
	ContextAdditions = {}
> = RawLoaderDefinitionFunction<OptionsType, ContextAdditions> & {
	raw: true;
	pitch?: PitchLoaderDefinitionFunction<OptionsType, ContextAdditions>;
};
declare interface RawLoaderDefinitionFunction<
	OptionsType = {},
	ContextAdditions = {}
> {
	(
		this: NormalModuleLoaderContext<OptionsType> &
			LoaderRunnerLoaderContext<OptionsType> &
			LoaderPluginLoaderContext &
			HotModuleReplacementPluginLoaderContext &
			ContextAdditions,
		content: Buffer,
		sourceMap?: string | SourceMap,
		additionalData?: AdditionalData
	): string | void | Buffer | Promise<string | Buffer>;
}
declare class RawSource extends Source {
	constructor(source: string | Buffer, convertToString?: boolean);
	isBuffer(): boolean;
}
declare interface RawSourceMap {
	version: number;
	sources: string[];
	names: string[];
	sourceRoot?: string;
	sourcesContent?: string[];
	mappings: string;
	file: string;
}
declare class ReadFileCompileWasmPlugin {
	constructor(options?: ReadFileCompileWasmPluginOptions);
	options: ReadFileCompileWasmPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ReadFileCompileWasmPluginOptions {
	/**
	 * mangle imports
	 */
	mangleImports?: boolean;
}
declare interface ReaddirOptions {
	encoding?:
		| null
		| "ascii"
		| "utf8"
		| "utf16le"
		| "ucs2"
		| "latin1"
		| "binary"
		| "utf-8"
		| "ucs-2"
		| "base64"
		| "base64url"
		| "hex"
		| "buffer";
	withFileTypes?: boolean;
}
declare class RealContentHashPlugin {
	constructor(__0: {
		/**
		 * the hash function to use
		 */
		hashFunction: string | typeof Hash;
		/**
		 * the hash digest to use
		 */
		hashDigest: string;
	});

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static getCompilationHooks(
		compilation: Compilation
	): CompilationHooksRealContentHashPlugin;
}
declare interface RealDependencyLocation {
	start: SourcePosition;
	end?: SourcePosition;
	index?: number;
}
type RecursiveArrayOrRecord<T> =
	| { [index: string]: RecursiveArrayOrRecord<T> }
	| RecursiveArrayOrRecord<T>[]
	| T;
declare interface ReferencedExport {
	/**
	 * name of the referenced export
	 */
	name: string[];

	/**
	 * when false, referenced export can not be mangled, defaults to true
	 */
	canMangle?: boolean;
}
type Remotes = (string | RemotesObject)[] | RemotesObject;

/**
 * Advanced configuration for container locations from which modules should be resolved and loaded at runtime.
 */
declare interface RemotesConfig {
	/**
	 * Container locations from which modules should be resolved and loaded at runtime.
	 */
	external: string | string[];

	/**
	 * The name of the share scope shared with this remote.
	 */
	shareScope?: string;
}

/**
 * Container locations from which modules should be resolved and loaded at runtime. Property names are used as request scopes.
 */
declare interface RemotesObject {
	[index: string]: string | RemotesConfig | string[];
}
declare interface RenderBootstrapContext {
	/**
	 * the chunk
	 */
	chunk: Chunk;

	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * hash to be used for render call
	 */
	hash: string;
}
declare interface RenderContext {
	/**
	 * the chunk
	 */
	chunk: Chunk;

	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;

	/**
	 * rendering in strict context
	 */
	strictMode: boolean;
}
type RenderManifestEntry =
	| RenderManifestEntryTemplated
	| RenderManifestEntryStatic;
declare interface RenderManifestEntryStatic {
	render: () => Source;
	filename: string;
	info: AssetInfo;
	identifier: string;
	hash?: string;
	auxiliary?: boolean;
}
declare interface RenderManifestEntryTemplated {
	render: () => Source;
	filenameTemplate: string | ((arg0: PathData, arg1?: AssetInfo) => string);
	pathOptions?: PathData;
	info?: AssetInfo;
	identifier: string;
	hash?: string;
	auxiliary?: boolean;
}
declare interface RenderManifestOptions {
	/**
	 * the chunk used to render
	 */
	chunk: Chunk;
	hash: string;
	fullHash: string;
	outputOptions: Output;
	codeGenerationResults: CodeGenerationResults;
	moduleTemplates: { javascript: ModuleTemplate };
	dependencyTemplates: DependencyTemplates;
	runtimeTemplate: RuntimeTemplate;
	moduleGraph: ModuleGraph;
	chunkGraph: ChunkGraph;
}
declare class ReplaceSource extends Source {
	constructor(source: Source, name?: string);
	replace(start: number, end: number, newValue: string, name?: string): void;
	insert(pos: number, newValue: string, name?: string): void;
	getName(): string;
	original(): string;
	getReplacements(): {
		start: number;
		end: number;
		content: string;
		insertIndex: number;
		name: string;
	}[];
}
declare abstract class RequestShortener {
	contextify: (arg0: string) => string;
	shorten(request?: null | string): undefined | null | string;
}
declare interface ResolveBuildDependenciesResult {
	/**
	 * list of files
	 */
	files: Set<string>;

	/**
	 * list of directories
	 */
	directories: Set<string>;

	/**
	 * list of missing entries
	 */
	missing: Set<string>;

	/**
	 * stored resolve results
	 */
	resolveResults: Map<string, string | false>;

	/**
	 * dependencies of the resolving
	 */
	resolveDependencies: {
		/**
		 * list of files
		 */
		files: Set<string>;
		/**
		 * list of directories
		 */
		directories: Set<string>;
		/**
		 * list of missing entries
		 */
		missing: Set<string>;
	};
}

/**
 * Resolve context
 */
declare interface ResolveContext {
	contextDependencies?: WriteOnlySet<string>;

	/**
	 * files that was found on file system
	 */
	fileDependencies?: WriteOnlySet<string>;

	/**
	 * dependencies that was not found on file system
	 */
	missingDependencies?: WriteOnlySet<string>;

	/**
	 * set of hooks' calls. For instance, `resolve  parsedResolve  describedResolve`,
	 */
	stack?: Set<string>;

	/**
	 * log function
	 */
	log?: (arg0: string) => void;

	/**
	 * yield result, if provided plugins can return several results
	 */
	yield?: (arg0: ResolveRequest) => void;
}
declare interface ResolveData {
	contextInfo: ModuleFactoryCreateDataContextInfo;
	resolveOptions?: ResolveOptionsWebpackOptions;
	context: string;
	request: string;
	assertions?: Record<string, any>;
	dependencies: ModuleDependency[];
	dependencyType: string;
	createData: Partial<NormalModuleCreateData & { settings: ModuleSettings }>;
	fileDependencies: LazySet<string>;
	missingDependencies: LazySet<string>;
	contextDependencies: LazySet<string>;

	/**
	 * allow to use the unsafe cache
	 */
	cacheable: boolean;
}
declare interface ResolveOptionsTypes {
	alias: AliasOption[];
	fallback: AliasOption[];
	aliasFields: Set<string | string[]>;
	extensionAlias: ExtensionAliasOption[];
	cachePredicate: (arg0: ResolveRequest) => boolean;
	cacheWithContext: boolean;

	/**
	 * A list of exports field condition names.
	 */
	conditionNames: Set<string>;
	descriptionFiles: string[];
	enforceExtension: boolean;
	exportsFields: Set<string | string[]>;
	importsFields: Set<string | string[]>;
	extensions: Set<string>;
	fileSystem: FileSystem;
	unsafeCache: false | object;
	symlinks: boolean;
	resolver?: Resolver;
	modules: (string | string[])[];
	mainFields: { name: string[]; forceRelative: boolean }[];
	mainFiles: Set<string>;
	plugins: Plugin[];
	pnpApi: null | PnpApiImpl;
	roots: Set<string>;
	fullySpecified: boolean;
	resolveToContext: boolean;
	restrictions: Set<string | RegExp>;
	preferRelative: boolean;
	preferAbsolute: boolean;
}

/**
 * Options object for resolving requests.
 */
declare interface ResolveOptionsWebpackOptions {
	/**
	 * Redirect module requests.
	 */
	alias?:
		| {
				/**
				 * New request.
				 */
				alias: string | false | string[];
				/**
				 * Request to be redirected.
				 */
				name: string;
				/**
				 * Redirect only exact matching request.
				 */
				onlyModule?: boolean;
		  }[]
		| { [index: string]: string | false | string[] };

	/**
	 * Fields in the description file (usually package.json) which are used to redirect requests inside the module.
	 */
	aliasFields?: (string | string[])[];

	/**
	 * Extra resolve options per dependency category. Typical categories are "commonjs", "amd", "esm".
	 */
	byDependency?: { [index: string]: ResolveOptionsWebpackOptions };

	/**
	 * Enable caching of successfully resolved requests (cache entries are revalidated).
	 */
	cache?: boolean;

	/**
	 * Predicate function to decide which requests should be cached.
	 */
	cachePredicate?: (request: ResolveRequest) => boolean;

	/**
	 * Include the context information in the cache identifier when caching.
	 */
	cacheWithContext?: boolean;

	/**
	 * Condition names for exports field entry point.
	 */
	conditionNames?: string[];

	/**
	 * Filenames used to find a description file (like a package.json).
	 */
	descriptionFiles?: string[];

	/**
	 * Enforce the resolver to use one of the extensions from the extensions option (User must specify requests without extension).
	 */
	enforceExtension?: boolean;

	/**
	 * Field names from the description file (usually package.json) which are used to provide entry points of a package.
	 */
	exportsFields?: string[];

	/**
	 * An object which maps extension to extension aliases.
	 */
	extensionAlias?: { [index: string]: string | string[] };

	/**
	 * Extensions added to the request when trying to find the file.
	 */
	extensions?: string[];

	/**
	 * Redirect module requests when normal resolving fails.
	 */
	fallback?:
		| {
				/**
				 * New request.
				 */
				alias: string | false | string[];
				/**
				 * Request to be redirected.
				 */
				name: string;
				/**
				 * Redirect only exact matching request.
				 */
				onlyModule?: boolean;
		  }[]
		| { [index: string]: string | false | string[] };

	/**
	 * Filesystem for the resolver.
	 */
	fileSystem?: InputFileSystem;

	/**
	 * Treats the request specified by the user as fully specified, meaning no extensions are added and the mainFiles in directories are not resolved (This doesn't affect requests from mainFields, aliasFields or aliases).
	 */
	fullySpecified?: boolean;

	/**
	 * Field names from the description file (usually package.json) which are used to provide internal request of a package (requests starting with # are considered as internal).
	 */
	importsFields?: string[];

	/**
	 * Field names from the description file (package.json) which are used to find the default entry point.
	 */
	mainFields?: (string | string[])[];

	/**
	 * Filenames used to find the default entry point if there is no description file or main field.
	 */
	mainFiles?: string[];

	/**
	 * Folder names or directory paths where to find modules.
	 */
	modules?: string[];

	/**
	 * Plugins for the resolver.
	 */
	plugins?: (
		| undefined
		| null
		| false
		| ""
		| 0
		| ResolvePluginInstance
		| "..."
	)[];

	/**
	 * Prefer to resolve server-relative URLs (starting with '/') as absolute paths before falling back to resolve in 'resolve.roots'.
	 */
	preferAbsolute?: boolean;

	/**
	 * Prefer to resolve module requests as relative request and fallback to resolving as module.
	 */
	preferRelative?: boolean;

	/**
	 * Custom resolver.
	 */
	resolver?: Resolver;

	/**
	 * A list of resolve restrictions. Resolve results must fulfill all of these restrictions to resolve successfully. Other resolve paths are taken when restrictions are not met.
	 */
	restrictions?: (string | RegExp)[];

	/**
	 * A list of directories in which requests that are server-relative URLs (starting with '/') are resolved.
	 */
	roots?: string[];

	/**
	 * Enable resolving symlinks to the original location.
	 */
	symlinks?: boolean;

	/**
	 * Enable caching of successfully resolved requests (cache entries are not revalidated).
	 */
	unsafeCache?: boolean | { [index: string]: any };

	/**
	 * Use synchronous filesystem calls for the resolver.
	 */
	useSyncFileSystemCalls?: boolean;
}
type ResolveOptionsWithDependencyType = ResolveOptionsWebpackOptions & {
	dependencyType?: string;
	resolveToContext?: boolean;
};

/**
 * Plugin instance.
 */
declare interface ResolvePluginInstance {
	[index: string]: any;

	/**
	 * The run point of the plugin, required method.
	 */
	apply: (resolver: Resolver) => void;
}
type ResolveRequest = BaseResolveRequest & Partial<ParsedIdentifier>;
declare interface ResolvedContextFileSystemInfoEntry {
	safeTime: number;
	timestampHash?: string;
}
declare interface ResolvedContextTimestampAndHash {
	safeTime: number;
	timestampHash?: string;
	hash: string;
}
declare abstract class Resolver {
	fileSystem: FileSystem;
	options: ResolveOptionsTypes;
	hooks: KnownHooks;
	ensureHook(
		name:
			| string
			| AsyncSeriesBailHook<
					[ResolveRequest, ResolveContext],
					null | ResolveRequest
			  >
	): AsyncSeriesBailHook<
		[ResolveRequest, ResolveContext],
		null | ResolveRequest
	>;
	getHook(
		name:
			| string
			| AsyncSeriesBailHook<
					[ResolveRequest, ResolveContext],
					null | ResolveRequest
			  >
	): AsyncSeriesBailHook<
		[ResolveRequest, ResolveContext],
		null | ResolveRequest
	>;
	resolveSync(context: object, path: string, request: string): string | false;
	resolve(
		context: object,
		path: string,
		request: string,
		resolveContext: ResolveContext,
		callback: (
			err: null | ErrorWithDetail,
			res?: string | false,
			req?: ResolveRequest
		) => void
	): void;
	doResolve(
		hook: AsyncSeriesBailHook<
			[ResolveRequest, ResolveContext],
			null | ResolveRequest
		>,
		request: ResolveRequest,
		message: null | string,
		resolveContext: ResolveContext,
		callback: (err?: null | Error, result?: ResolveRequest) => void
	): void;
	parse(identifier: string): ParsedIdentifier;
	isModule(path: string): boolean;
	isPrivate(path: string): boolean;
	isDirectory(path: string): boolean;
	join(path: string, request: string): string;
	normalize(path: string): string;
}
declare interface ResolverCache {
	direct: WeakMap<Object, ResolverWithOptions>;
	stringified: Map<string, ResolverWithOptions>;
}
declare abstract class ResolverFactory {
	hooks: Readonly<{
		resolveOptions: HookMap<
			SyncWaterfallHook<[ResolveOptionsWithDependencyType]>
		>;
		resolver: HookMap<
			SyncHook<[Resolver, UserResolveOptions, ResolveOptionsWithDependencyType]>
		>;
	}>;
	cache: Map<string, ResolverCache>;
	get(
		type: string,
		resolveOptions?: ResolveOptionsWithDependencyType
	): ResolverWithOptions;
}
type ResolverWithOptions = Resolver & WithOptions;

declare interface ResourceDataWithData {
	resource: string;
	path: string;
	query: string;
	fragment: string;
	context?: string;
	data: Record<string, any>;
}
type Rule = string | RegExp;
declare interface RuleSet {
	/**
	 * map of references in the rule set (may grow over time)
	 */
	references: Map<string, any>;

	/**
	 * execute the rule set
	 */
	exec: (arg0: object) => Effect[];
}
type RuleSetCondition =
	| string
	| RegExp
	| ((value: string) => boolean)
	| RuleSetLogicalConditions
	| RuleSetCondition[];
type RuleSetConditionAbsolute =
	| string
	| RegExp
	| ((value: string) => boolean)
	| RuleSetLogicalConditionsAbsolute
	| RuleSetConditionAbsolute[];
type RuleSetConditionOrConditions =
	| string
	| RegExp
	| ((value: string) => boolean)
	| RuleSetLogicalConditions
	| RuleSetCondition[];

/**
 * Logic operators used in a condition matcher.
 */
declare interface RuleSetLogicalConditions {
	/**
	 * Logical AND.
	 */
	and?: RuleSetCondition[];

	/**
	 * Logical NOT.
	 */
	not?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Logical OR.
	 */
	or?: RuleSetCondition[];
}

/**
 * Logic operators used in a condition matcher.
 */
declare interface RuleSetLogicalConditionsAbsolute {
	/**
	 * Logical AND.
	 */
	and?: RuleSetConditionAbsolute[];

	/**
	 * Logical NOT.
	 */
	not?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Logical OR.
	 */
	or?: RuleSetConditionAbsolute[];
}

/**
 * A rule description with conditions and effects for modules.
 */
declare interface RuleSetRule {
	/**
	 * Match on import assertions of the dependency.
	 */
	assert?: { [index: string]: RuleSetConditionOrConditions };

	/**
	 * Match the child compiler name.
	 */
	compiler?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Match dependency type.
	 */
	dependency?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Match values of properties in the description file (usually package.json).
	 */
	descriptionData?: { [index: string]: RuleSetConditionOrConditions };

	/**
	 * Enforce this rule as pre or post step.
	 */
	enforce?: "pre" | "post";

	/**
	 * Shortcut for resource.exclude.
	 */
	exclude?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * The options for the module generator.
	 */
	generator?: { [index: string]: any };

	/**
	 * Shortcut for resource.include.
	 */
	include?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Match the issuer of the module (The module pointing to this module).
	 */
	issuer?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Match layer of the issuer of this module (The module pointing to this module).
	 */
	issuerLayer?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Specifies the layer in which the module should be placed in.
	 */
	layer?: string;

	/**
	 * Shortcut for use.loader.
	 */
	loader?: string;

	/**
	 * Match module mimetype when load from Data URI.
	 */
	mimetype?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Only execute the first matching rule in this array.
	 */
	oneOf?: (undefined | null | false | "" | 0 | RuleSetRule)[];

	/**
	 * Shortcut for use.options.
	 */
	options?: string | { [index: string]: any };

	/**
	 * Options for parsing.
	 */
	parser?: { [index: string]: any };

	/**
	 * Match the real resource path of the module.
	 */
	realResource?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Options for the resolver.
	 */
	resolve?: ResolveOptionsWebpackOptions;

	/**
	 * Match the resource path of the module.
	 */
	resource?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Match the resource fragment of the module.
	 */
	resourceFragment?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Match the resource query of the module.
	 */
	resourceQuery?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Match and execute these rules when this rule is matched.
	 */
	rules?: (undefined | null | false | "" | 0 | RuleSetRule)[];

	/**
	 * Match module scheme.
	 */
	scheme?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Flags a module as with or without side effects.
	 */
	sideEffects?: boolean;

	/**
	 * Shortcut for resource.test.
	 */
	test?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Module type to use for the module.
	 */
	type?: string;

	/**
	 * Modifiers applied to the module when rule is matched.
	 */
	use?:
		| string
		| (
				| undefined
				| null
				| string
				| false
				| 0
				| {
						/**
						 * Unique loader options identifier.
						 */
						ident?: string;
						/**
						 * Loader name.
						 */
						loader?: string;
						/**
						 * Loader options.
						 */
						options?: string | { [index: string]: any };
				  }
				| ((data: object) =>
						| string
						| {
								/**
								 * Unique loader options identifier.
								 */
								ident?: string;
								/**
								 * Loader name.
								 */
								loader?: string;
								/**
								 * Loader options.
								 */
								options?: string | { [index: string]: any };
						  }
						| __TypeWebpackOptions
						| __Type_2[])
		  )[]
		| ((data: {
				resource: string;
				realResource: string;
				resourceQuery: string;
				issuer: string;
				compiler: string;
		  }) => __Type_2[])
		| {
				/**
				 * Unique loader options identifier.
				 */
				ident?: string;
				/**
				 * Loader name.
				 */
				loader?: string;
				/**
				 * Loader options.
				 */
				options?: string | { [index: string]: any };
		  }
		| __TypeWebpackOptions;
}
type RuleSetUse =
	| string
	| (
			| undefined
			| null
			| string
			| false
			| 0
			| {
					/**
					 * Unique loader options identifier.
					 */
					ident?: string;
					/**
					 * Loader name.
					 */
					loader?: string;
					/**
					 * Loader options.
					 */
					options?: string | { [index: string]: any };
			  }
			| ((data: object) =>
					| string
					| {
							/**
							 * Unique loader options identifier.
							 */
							ident?: string;
							/**
							 * Loader name.
							 */
							loader?: string;
							/**
							 * Loader options.
							 */
							options?: string | { [index: string]: any };
					  }
					| __TypeWebpackOptions
					| __Type_2[])
	  )[]
	| ((data: {
			resource: string;
			realResource: string;
			resourceQuery: string;
			issuer: string;
			compiler: string;
	  }) => __Type_2[])
	| {
			/**
			 * Unique loader options identifier.
			 */
			ident?: string;
			/**
			 * Loader name.
			 */
			loader?: string;
			/**
			 * Loader options.
			 */
			options?: string | { [index: string]: any };
	  }
	| __TypeWebpackOptions;
type RuleSetUseItem =
	| string
	| {
			/**
			 * Unique loader options identifier.
			 */
			ident?: string;
			/**
			 * Loader name.
			 */
			loader?: string;
			/**
			 * Loader options.
			 */
			options?: string | { [index: string]: any };
	  }
	| __TypeWebpackOptions;
declare class RuntimeChunkPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type RuntimeCondition = undefined | string | boolean | SortableSet<string>;
declare class RuntimeModule extends Module {
	constructor(name: string, stage?: number);
	name: string;
	stage: number;
	compilation?: Compilation;
	chunk?: Chunk;
	chunkGraph?: ChunkGraph;
	fullHash: boolean;
	dependentHash: boolean;
	attach(compilation: Compilation, chunk: Chunk, chunkGraph?: ChunkGraph): void;
	generate(): null | string;
	getGeneratedCode(): null | string;
	shouldIsolate(): boolean;

	/**
	 * Runtime modules without any dependencies to other runtime modules
	 */
	static STAGE_NORMAL: number;

	/**
	 * Runtime modules with simple dependencies on other runtime modules
	 */
	static STAGE_BASIC: number;

	/**
	 * Runtime modules which attach to handlers of other runtime modules
	 */
	static STAGE_ATTACH: number;

	/**
	 * Runtime modules which trigger actions on bootstrap
	 */
	static STAGE_TRIGGER: number;
}
declare interface RuntimeRequirementsContext {
	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * the code generation results
	 */
	codeGenerationResults: CodeGenerationResults;
}
type RuntimeSpec = undefined | string | SortableSet<string>;
declare class RuntimeSpecMap<T> {
	constructor(clone?: RuntimeSpecMap<T>);
	get(runtime: RuntimeSpec): undefined | T;
	has(runtime: RuntimeSpec): boolean;
	set(runtime: RuntimeSpec, value: T): void;
	provide(runtime: RuntimeSpec, computer: () => any): any;
	delete(runtime: RuntimeSpec): void;
	update(runtime: RuntimeSpec, fn: (arg0?: T) => T): void;
	keys(): RuntimeSpec[];
	values(): IterableIterator<T>;
	get size(): number;
}
declare class RuntimeSpecSet {
	constructor(iterable?: Iterable<RuntimeSpec>);
	add(runtime: RuntimeSpec): void;
	has(runtime: RuntimeSpec): boolean;
	get size(): number;
	[Symbol.iterator](): IterableIterator<RuntimeSpec>;
}
declare abstract class RuntimeTemplate {
	compilation: Compilation;
	outputOptions: OutputNormalized;
	requestShortener: RequestShortener;
	globalObject: string;
	contentHashReplacement: string;
	isIIFE(): undefined | boolean;
	isModule(): undefined | boolean;
	supportsConst(): undefined | boolean;
	supportsArrowFunction(): undefined | boolean;
	supportsOptionalChaining(): undefined | boolean;
	supportsForOf(): undefined | boolean;
	supportsDestructuring(): undefined | boolean;
	supportsBigIntLiteral(): undefined | boolean;
	supportsDynamicImport(): undefined | boolean;
	supportsEcmaScriptModuleSyntax(): undefined | boolean;
	supportTemplateLiteral(): undefined | boolean;
	returningFunction(returnValue?: any, args?: string): string;
	basicFunction(args?: any, body?: any): string;
	concatenation(...args: (string | { expr: string })[]): string;
	expressionFunction(expression?: any, args?: string): string;
	emptyFunction(): "x => {}" | "function() {}";
	destructureArray(items?: any, value?: any): string;
	destructureObject(items?: any, value?: any): string;
	iife(args?: any, body?: any): string;
	forEach(variable?: any, array?: any, body?: any): string;

	/**
	 * Add a comment
	 */
	comment(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
		/**
		 * name of the chunk referenced
		 */
		chunkName?: string;
		/**
		 * reason information of the chunk
		 */
		chunkReason?: string;
		/**
		 * additional message
		 */
		message?: string;
		/**
		 * name of the export
		 */
		exportName?: string;
	}): string;
	throwMissingModuleErrorBlock(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	throwMissingModuleErrorFunction(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	missingModule(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	missingModuleStatement(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	missingModulePromise(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	weakError(__0: {
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * expression to use as id expression
		 */
		idExpr?: string;
		/**
		 * which kind of code should be returned
		 */
		type: "promise" | "expression" | "statements";
	}): string;
	moduleId(__0: {
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * if the dependency is weak (will create a nice error message)
		 */
		weak?: boolean;
	}): string;
	moduleRaw(__0: {
		/**
		 * the module
		 */
		module: null | Module;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * if the dependency is weak (will create a nice error message)
		 */
		weak?: boolean;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	moduleExports(__0: {
		/**
		 * the module
		 */
		module: null | Module;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * if the dependency is weak (will create a nice error message)
		 */
		weak?: boolean;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	moduleNamespace(__0: {
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * if the current module is in strict esm mode
		 */
		strict?: boolean;
		/**
		 * if the dependency is weak (will create a nice error message)
		 */
		weak?: boolean;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	moduleNamespacePromise(__0: {
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the current dependencies block
		 */
		block?: AsyncDependenciesBlock;
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * a message for the comment
		 */
		message: string;
		/**
		 * if the current module is in strict esm mode
		 */
		strict?: boolean;
		/**
		 * if the dependency is weak (will create a nice error message)
		 */
		weak?: boolean;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	runtimeConditionExpression(__0: {
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * runtime for which this code will be generated
		 */
		runtime?: RuntimeSpec;
		/**
		 * only execute the statement in some runtimes
		 */
		runtimeCondition?: string | boolean | SortableSet<string>;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	importStatement(__0: {
		/**
		 * whether a new variable should be created or the existing one updated
		 */
		update?: boolean;
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * name of the import variable
		 */
		importVar: string;
		/**
		 * module in which the statement is emitted
		 */
		originModule: Module;
		/**
		 * true, if this is a weak dependency
		 */
		weak?: boolean;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): [string, string];
	exportFromImport(__0: {
		/**
		 * the module graph
		 */
		moduleGraph: ModuleGraph;
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the request
		 */
		request: string;
		/**
		 * the export name
		 */
		exportName: string | string[];
		/**
		 * the origin module
		 */
		originModule: Module;
		/**
		 * true, if location is safe for ASI, a bracket can be emitted
		 */
		asiSafe?: boolean;
		/**
		 * true, if expression will be called
		 */
		isCall: boolean;
		/**
		 * when false, call context will not be preserved
		 */
		callContext: null | boolean;
		/**
		 * when true and accessing the default exports, interop code will be generated
		 */
		defaultInterop: boolean;
		/**
		 * the identifier name of the import variable
		 */
		importVar: string;
		/**
		 * init fragments will be added here
		 */
		initFragments: InitFragment<any>[];
		/**
		 * runtime for which this code will be generated
		 */
		runtime: RuntimeSpec;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	blockPromise(__0: {
		/**
		 * the async block
		 */
		block: AsyncDependenciesBlock;
		/**
		 * the message
		 */
		message: string;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	asyncModuleFactory(__0: {
		/**
		 * the async block
		 */
		block: AsyncDependenciesBlock;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	syncModuleFactory(__0: {
		/**
		 * the dependency
		 */
		dependency: Dependency;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	defineEsModuleFlagStatement(__0: {
		/**
		 * the name of the exports object
		 */
		exportsArgument: string;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	assetUrl(__0: {
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the public path
		 */
		publicPath: string;
		/**
		 * runtime
		 */
		runtime?: RuntimeSpec;
		/**
		 * the code generation results
		 */
		codeGenerationResults: CodeGenerationResults;
	}): string;
}
declare abstract class RuntimeValue {
	fn: (arg0: {
		module: NormalModule;
		key: string;
		readonly version?: string;
	}) => CodeValuePrimitive;
	options: true | RuntimeValueOptions;
	get fileDependencies(): true | string[];
	exec(
		parser: JavascriptParser,
		valueCacheVersions: Map<string, string | Set<string>>,
		key: string
	): CodeValuePrimitive;
	getCacheVersion(): undefined | string;
}
declare interface RuntimeValueOptions {
	fileDependencies?: string[];
	contextDependencies?: string[];
	missingDependencies?: string[];
	buildDependencies?: string[];
	version?: string | (() => string);
}

/**
 * Helper function for joining two ranges into a single range. This is useful
 * when working with AST nodes, as it allows you to combine the ranges of child nodes
 * to create the range of the _parent node_.
 */
declare interface ScopeInfo {
	definitions: StackedMap<string, ScopeInfo | VariableInfo>;
	topLevelScope: boolean | "arrow";
	inShorthand: string | boolean;
	inTaggedTemplateTag: boolean;
	inTry: boolean;
	isStrict: boolean;
	isAsmJs: boolean;
}
declare interface Selector<A, B> {
	(input: A): B;
}
declare abstract class Serializer {
	serializeMiddlewares: any;
	deserializeMiddlewares: any;
	context: any;
	serialize(obj?: any, context?: any): any;
	deserialize(value?: any, context?: any): any;
}
type ServerOptionsHttps<
	Request extends typeof IncomingMessage = typeof IncomingMessage,
	Response extends typeof ServerResponse = typeof ServerResponse
> = SecureContextOptions & TlsOptions & ServerOptionsImport<Request, Response>;
declare class SharePlugin {
	constructor(options: SharePluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}

/**
 * Options for shared modules.
 */
declare interface SharePluginOptions {
	/**
	 * Share scope name used for all shared modules (defaults to 'default').
	 */
	shareScope?: string;

	/**
	 * Modules that should be shared in the share scope. When provided, property names are used to match requested modules in this compilation.
	 */
	shared: Shared;
}
type Shared = (string | SharedObject)[] | SharedObject;

/**
 * Advanced configuration for modules that should be shared in the share scope.
 */
declare interface SharedConfig {
	/**
	 * Include the provided and fallback module directly instead behind an async request. This allows to use this shared module in initial load too. All possible shared modules need to be eager too.
	 */
	eager?: boolean;

	/**
	 * Provided module that should be provided to share scope. Also acts as fallback module if no shared module is found in share scope or version isn't valid. Defaults to the property name.
	 */
	import?: string | false;

	/**
	 * Package name to determine required version from description file. This is only needed when package name can't be automatically determined from request.
	 */
	packageName?: string;

	/**
	 * Version requirement from module in share scope.
	 */
	requiredVersion?: string | false;

	/**
	 * Module is looked up under this key from the share scope.
	 */
	shareKey?: string;

	/**
	 * Share scope name.
	 */
	shareScope?: string;

	/**
	 * Allow only a single version of the shared module in share scope (disabled by default).
	 */
	singleton?: boolean;

	/**
	 * Do not accept shared module if version is not valid (defaults to yes, if local fallback module is available and shared module is not a singleton, otherwise no, has no effect if there is no required version specified).
	 */
	strictVersion?: boolean;

	/**
	 * Version of the provided module. Will replace lower matching versions, but not higher.
	 */
	version?: string | false;
}

/**
 * Modules that should be shared in the share scope. Property names are used to match requested modules in this compilation. Relative requests are resolved, module requests are matched unresolved, absolute paths will match resolved requests. A trailing slash will match all requests with this prefix. In this case shareKey must also have a trailing slash.
 */
declare interface SharedObject {
	[index: string]: string | SharedConfig;
}
declare class SideEffectsFlagPlugin {
	constructor(analyseSource?: boolean);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static moduleHasSideEffects(
		moduleName: string,
		flagValue: undefined | string | boolean | string[],
		cache: Map<string, RegExp>
	): undefined | boolean;
}
declare class SizeOnlySource extends Source {
	constructor(size: number);
}
declare abstract class Snapshot {
	startTime?: number;
	fileTimestamps?: Map<string, null | FileSystemInfoEntry>;
	fileHashes?: Map<string, null | string>;
	fileTshs?: Map<string, null | string | TimestampAndHash>;
	contextTimestamps?: Map<string, null | ResolvedContextFileSystemInfoEntry>;
	contextHashes?: Map<string, null | string>;
	contextTshs?: Map<string, null | ResolvedContextTimestampAndHash>;
	missingExistence?: Map<string, boolean>;
	managedItemInfo?: Map<string, string>;
	managedFiles?: Set<string>;
	managedContexts?: Set<string>;
	managedMissing?: Set<string>;
	children?: Set<Snapshot>;
	hasStartTime(): boolean;
	setStartTime(value?: any): void;
	setMergedStartTime(value?: any, snapshot?: any): void;
	hasFileTimestamps(): boolean;
	setFileTimestamps(value?: any): void;
	hasFileHashes(): boolean;
	setFileHashes(value?: any): void;
	hasFileTshs(): boolean;
	setFileTshs(value?: any): void;
	hasContextTimestamps(): boolean;
	setContextTimestamps(value?: any): void;
	hasContextHashes(): boolean;
	setContextHashes(value?: any): void;
	hasContextTshs(): boolean;
	setContextTshs(value?: any): void;
	hasMissingExistence(): boolean;
	setMissingExistence(value?: any): void;
	hasManagedItemInfo(): boolean;
	setManagedItemInfo(value?: any): void;
	hasManagedFiles(): boolean;
	setManagedFiles(value?: any): void;
	hasManagedContexts(): boolean;
	setManagedContexts(value?: any): void;
	hasManagedMissing(): boolean;
	setManagedMissing(value?: any): void;
	hasChildren(): boolean;
	setChildren(value?: any): void;
	addChild(child?: any): void;
	serialize(__0: ObjectSerializerContext): void;
	deserialize(__0: ObjectDeserializerContext): void;
	getFileIterable(): Iterable<string>;
	getContextIterable(): Iterable<string>;
	getMissingIterable(): Iterable<string>;
}
declare interface SnapshotOptionsFileSystemInfo {
	/**
	 * should use hash to snapshot
	 */
	hash?: boolean;

	/**
	 * should use timestamp to snapshot
	 */
	timestamp?: boolean;
}

/**
 * Options affecting how file system snapshots are created and validated.
 */
declare interface SnapshotOptionsWebpackOptions {
	/**
	 * Options for snapshotting build dependencies to determine if the whole cache need to be invalidated.
	 */
	buildDependencies?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};

	/**
	 * List of paths that are managed by a package manager and contain a version or hash in its path so all files are immutable.
	 */
	immutablePaths?: (string | RegExp)[];

	/**
	 * List of paths that are managed by a package manager and can be trusted to not be modified otherwise.
	 */
	managedPaths?: (string | RegExp)[];

	/**
	 * Options for snapshotting dependencies of modules to determine if they need to be built again.
	 */
	module?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};

	/**
	 * Options for snapshotting dependencies of request resolving to determine if requests need to be re-resolved.
	 */
	resolve?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};

	/**
	 * Options for snapshotting the resolving of build dependencies to determine if the build dependencies need to be re-resolved.
	 */
	resolveBuildDependencies?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};
}
declare abstract class SortableSet<T> extends Set<T> {
	/**
	 * Sort with a comparer function
	 */
	sortWith(sortFn: (arg0: T, arg1: T) => number): void;
	sort(): SortableSet<T>;

	/**
	 * Get data from cache
	 */
	getFromCache<R>(fn: (arg0: SortableSet<T>) => R): R;

	/**
	 * Get data from cache (ignoring sorting)
	 */
	getFromUnorderedCache<R>(fn: (arg0: SortableSet<T>) => R): R;
	toJSON(): T[];

	/**
	 * Iterates over values in the set.
	 */
	[Symbol.iterator](): IterableIterator<T>;
}
declare class Source {
	constructor();
	size(): number;
	map(options?: MapOptions): null | RawSourceMap;
	sourceAndMap(options?: MapOptions): { source: string | Buffer; map: Object };
	updateHash(hash: Hash): void;
	source(): string | Buffer;
	buffer(): Buffer;
}
declare interface SourceLike {
	source(): string | Buffer;
}
declare interface SourceMap {
	version: number;
	sources: string[];
	mappings: string;
	file?: string;
	sourceRoot?: string;
	sourcesContent?: string[];
	names?: string[];
}
declare class SourceMapDevToolPlugin {
	constructor(options?: SourceMapDevToolPluginOptions);
	sourceMapFilename: string | false;
	sourceMappingURLComment:
		| string
		| false
		| ((arg0: PathData, arg1?: AssetInfo) => string);
	moduleFilenameTemplate: string | Function;
	fallbackModuleFilenameTemplate: string | Function;
	namespace: string;
	options: SourceMapDevToolPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface SourceMapDevToolPluginOptions {
	/**
	 * Appends the given value to the original asset. Usually the #sourceMappingURL comment. [url] is replaced with a URL to the source map file. false disables the appending.
	 */
	append?:
		| null
		| string
		| false
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Indicates whether column mappings should be used (defaults to true).
	 */
	columns?: boolean;

	/**
	 * Exclude modules that match the given value from source map generation.
	 */
	exclude?: string | RegExp | Rule[];

	/**
	 * Generator string or function to create identifiers of modules for the 'sources' array in the SourceMap used only if 'moduleFilenameTemplate' would result in a conflict.
	 */
	fallbackModuleFilenameTemplate?: string | Function;

	/**
	 * Path prefix to which the [file] placeholder is relative to.
	 */
	fileContext?: string;

	/**
	 * Defines the output filename of the SourceMap (will be inlined if no value is provided).
	 */
	filename?: null | string | false;

	/**
	 * Include source maps for module paths that match the given value.
	 */
	include?: string | RegExp | Rule[];

	/**
	 * Indicates whether SourceMaps from loaders should be used (defaults to true).
	 */
	module?: boolean;

	/**
	 * Generator string or function to create identifiers of modules for the 'sources' array in the SourceMap.
	 */
	moduleFilenameTemplate?: string | Function;

	/**
	 * Namespace prefix to allow multiple webpack roots in the devtools.
	 */
	namespace?: string;

	/**
	 * Omit the 'sourceContents' array from the SourceMap.
	 */
	noSources?: boolean;

	/**
	 * Provide a custom public path for the SourceMapping comment.
	 */
	publicPath?: string;

	/**
	 * Provide a custom value for the 'sourceRoot' property in the SourceMap.
	 */
	sourceRoot?: string;

	/**
	 * Include source maps for modules based on their extension (defaults to .js and .css).
	 */
	test?: string | RegExp | Rule[];
}
declare class SourceMapSource extends Source {
	constructor(
		source: string | Buffer,
		name: string,
		sourceMap: string | Object | Buffer,
		originalSource?: string | Buffer,
		innerSourceMap?: string | Object | Buffer,
		removeOriginalSource?: boolean
	);
	getArgsAsBuffers(): [
		Buffer,
		string,
		Buffer,
		undefined | Buffer,
		undefined | Buffer,
		boolean
	];
}
declare interface SourcePosition {
	line: number;
	column?: number;
}
declare interface SplitChunksOptions {
	chunksFilter: (chunk: Chunk) => undefined | boolean;
	defaultSizeTypes: string[];
	minSize: SplitChunksSizes;
	minSizeReduction: SplitChunksSizes;
	minRemainingSize: SplitChunksSizes;
	enforceSizeThreshold: SplitChunksSizes;
	maxInitialSize: SplitChunksSizes;
	maxAsyncSize: SplitChunksSizes;
	minChunks: number;
	maxAsyncRequests: number;
	maxInitialRequests: number;
	hidePathInfo: boolean;
	filename: string | ((arg0: PathData, arg1?: AssetInfo) => string);
	automaticNameDelimiter: string;
	getCacheGroups: (
		module: Module,
		context: CacheGroupsContext
	) => CacheGroupSource[];
	getName: (
		module?: Module,
		chunks?: Chunk[],
		key?: string
	) => undefined | string;
	usedExports: boolean;
	fallbackCacheGroup: FallbackCacheGroup;
}
declare class SplitChunksPlugin {
	constructor(options?: OptimizationSplitChunksOptions);
	options: SplitChunksOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface SplitChunksSizes {
	[index: string]: number;
}
declare abstract class StackedMap<K, V> {
	map: Map<K, InternalCell<V>>;
	stack: Map<K, InternalCell<V>>[];
	set(item: K, value: V): void;
	delete(item: K): void;
	has(item: K): boolean;
	get(item: K): Cell<V>;
	asArray(): K[];
	asSet(): Set<K>;
	asPairArray(): [K, Cell<V>][];
	asMap(): Map<K, Cell<V>>;
	get size(): number;
	createChild(): StackedMap<K, V>;
}
type StartupRenderContext = RenderContext & { inlined: boolean };
type Statement =
	| FunctionDeclaration
	| VariableDeclaration
	| ClassDeclaration
	| ExpressionStatement
	| BlockStatement
	| StaticBlock
	| EmptyStatement
	| DebuggerStatement
	| WithStatement
	| ReturnStatement
	| LabeledStatement
	| BreakStatement
	| ContinueStatement
	| IfStatement
	| SwitchStatement
	| ThrowStatement
	| TryStatement
	| WhileStatement
	| DoWhileStatement
	| ForStatement
	| ForInStatement
	| ForOfStatement;
declare class Stats {
	constructor(compilation: Compilation);
	compilation: Compilation;
	get hash(): string;
	get startTime(): any;
	get endTime(): any;
	hasWarnings(): boolean;
	hasErrors(): boolean;
	toJson(options?: string | StatsOptions): StatsCompilation;
	toString(options?: any): string;
}
type StatsAsset = KnownStatsAsset & Record<string, any>;
type StatsChunk = KnownStatsChunk & Record<string, any>;
type StatsChunkGroup = KnownStatsChunkGroup & Record<string, any>;
type StatsChunkOrigin = KnownStatsChunkOrigin & Record<string, any>;
type StatsCompilation = KnownStatsCompilation & Record<string, any>;
type StatsError = KnownStatsError & Record<string, any>;
declare abstract class StatsFactory {
	hooks: Readonly<{
		extract: HookMap<SyncBailHook<[Object, any, StatsFactoryContext], any>>;
		filter: HookMap<
			SyncBailHook<[any, StatsFactoryContext, number, number], any>
		>;
		sort: HookMap<
			SyncBailHook<
				[((arg0?: any, arg1?: any) => number)[], StatsFactoryContext],
				any
			>
		>;
		filterSorted: HookMap<
			SyncBailHook<[any, StatsFactoryContext, number, number], any>
		>;
		groupResults: HookMap<
			SyncBailHook<[GroupConfig[], StatsFactoryContext], any>
		>;
		sortResults: HookMap<
			SyncBailHook<
				[((arg0?: any, arg1?: any) => number)[], StatsFactoryContext],
				any
			>
		>;
		filterResults: HookMap<
			SyncBailHook<[any, StatsFactoryContext, number, number], any>
		>;
		merge: HookMap<SyncBailHook<[any[], StatsFactoryContext], any>>;
		result: HookMap<SyncBailHook<[any[], StatsFactoryContext], any>>;
		getItemName: HookMap<SyncBailHook<[any, StatsFactoryContext], any>>;
		getItemFactory: HookMap<SyncBailHook<[any, StatsFactoryContext], any>>;
	}>;
	create(
		type: string,
		data: any,
		baseContext: Omit<StatsFactoryContext, "type">
	): any;
}
type StatsFactoryContext = KnownStatsFactoryContext & Record<string, any>;
type StatsLogging = KnownStatsLogging & Record<string, any>;
type StatsLoggingEntry = KnownStatsLoggingEntry & Record<string, any>;
type StatsModule = KnownStatsModule & Record<string, any>;
type StatsModuleIssuer = KnownStatsModuleIssuer & Record<string, any>;
type StatsModuleReason = KnownStatsModuleReason & Record<string, any>;
type StatsModuleTraceDependency = KnownStatsModuleTraceDependency &
	Record<string, any>;
type StatsModuleTraceItem = KnownStatsModuleTraceItem & Record<string, any>;

/**
 * Stats options object.
 */
declare interface StatsOptions {
	/**
	 * Fallback value for stats options when an option is not defined (has precedence over local webpack defaults).
	 */
	all?: boolean;

	/**
	 * Add assets information.
	 */
	assets?: boolean;

	/**
	 * Sort the assets by that field.
	 */
	assetsSort?: string;

	/**
	 * Space to display assets (groups will be collapsed to fit this space).
	 */
	assetsSpace?: number;

	/**
	 * Add built at time information.
	 */
	builtAt?: boolean;

	/**
	 * Add information about cached (not built) modules (deprecated: use 'cachedModules' instead).
	 */
	cached?: boolean;

	/**
	 * Show cached assets (setting this to `false` only shows emitted files).
	 */
	cachedAssets?: boolean;

	/**
	 * Add information about cached (not built) modules.
	 */
	cachedModules?: boolean;

	/**
	 * Add children information.
	 */
	children?: boolean;

	/**
	 * Display auxiliary assets in chunk groups.
	 */
	chunkGroupAuxiliary?: boolean;

	/**
	 * Display children of chunk groups.
	 */
	chunkGroupChildren?: boolean;

	/**
	 * Limit of assets displayed in chunk groups.
	 */
	chunkGroupMaxAssets?: number;

	/**
	 * Display all chunk groups with the corresponding bundles.
	 */
	chunkGroups?: boolean;

	/**
	 * Add built modules information to chunk information.
	 */
	chunkModules?: boolean;

	/**
	 * Space to display chunk modules (groups will be collapsed to fit this space, value is in number of modules/group).
	 */
	chunkModulesSpace?: number;

	/**
	 * Add the origins of chunks and chunk merging info.
	 */
	chunkOrigins?: boolean;

	/**
	 * Add information about parent, children and sibling chunks to chunk information.
	 */
	chunkRelations?: boolean;

	/**
	 * Add chunk information.
	 */
	chunks?: boolean;

	/**
	 * Sort the chunks by that field.
	 */
	chunksSort?: string;

	/**
	 * Enables/Disables colorful output.
	 */
	colors?:
		| boolean
		| {
				/**
				 * Custom color for bold text.
				 */
				bold?: string;
				/**
				 * Custom color for cyan text.
				 */
				cyan?: string;
				/**
				 * Custom color for green text.
				 */
				green?: string;
				/**
				 * Custom color for magenta text.
				 */
				magenta?: string;
				/**
				 * Custom color for red text.
				 */
				red?: string;
				/**
				 * Custom color for yellow text.
				 */
				yellow?: string;
		  };

	/**
	 * Context directory for request shortening.
	 */
	context?: string;

	/**
	 * Show chunk modules that are dependencies of other modules of the chunk.
	 */
	dependentModules?: boolean;

	/**
	 * Add module depth in module graph.
	 */
	depth?: boolean;

	/**
	 * Display the entry points with the corresponding bundles.
	 */
	entrypoints?: boolean | "auto";

	/**
	 * Add --env information.
	 */
	env?: boolean;

	/**
	 * Add details to errors (like resolving log).
	 */
	errorDetails?: boolean | "auto";

	/**
	 * Add internal stack trace to errors.
	 */
	errorStack?: boolean;

	/**
	 * Add errors.
	 */
	errors?: boolean;

	/**
	 * Add errors count.
	 */
	errorsCount?: boolean;

	/**
	 * Space to display errors (value is in number of lines).
	 */
	errorsSpace?: number;

	/**
	 * Please use excludeModules instead.
	 */
	exclude?:
		| string
		| boolean
		| RegExp
		| ModuleFilterItemTypes[]
		| ((
				name: string,
				module: StatsModule,
				type: "module" | "chunk" | "root-of-chunk" | "nested"
		  ) => boolean);

	/**
	 * Suppress assets that match the specified filters. Filters can be Strings, RegExps or Functions.
	 */
	excludeAssets?:
		| string
		| RegExp
		| AssetFilterItemTypes[]
		| ((name: string, asset: StatsAsset) => boolean);

	/**
	 * Suppress modules that match the specified filters. Filters can be Strings, RegExps, Booleans or Functions.
	 */
	excludeModules?:
		| string
		| boolean
		| RegExp
		| ModuleFilterItemTypes[]
		| ((
				name: string,
				module: StatsModule,
				type: "module" | "chunk" | "root-of-chunk" | "nested"
		  ) => boolean);

	/**
	 * Group assets by how their are related to chunks.
	 */
	groupAssetsByChunk?: boolean;

	/**
	 * Group assets by their status (emitted, compared for emit or cached).
	 */
	groupAssetsByEmitStatus?: boolean;

	/**
	 * Group assets by their extension.
	 */
	groupAssetsByExtension?: boolean;

	/**
	 * Group assets by their asset info (immutable, development, hotModuleReplacement, etc).
	 */
	groupAssetsByInfo?: boolean;

	/**
	 * Group assets by their path.
	 */
	groupAssetsByPath?: boolean;

	/**
	 * Group modules by their attributes (errors, warnings, assets, optional, orphan, or dependent).
	 */
	groupModulesByAttributes?: boolean;

	/**
	 * Group modules by their status (cached or built and cacheable).
	 */
	groupModulesByCacheStatus?: boolean;

	/**
	 * Group modules by their extension.
	 */
	groupModulesByExtension?: boolean;

	/**
	 * Group modules by their layer.
	 */
	groupModulesByLayer?: boolean;

	/**
	 * Group modules by their path.
	 */
	groupModulesByPath?: boolean;

	/**
	 * Group modules by their type.
	 */
	groupModulesByType?: boolean;

	/**
	 * Group reasons by their origin module.
	 */
	groupReasonsByOrigin?: boolean;

	/**
	 * Add the hash of the compilation.
	 */
	hash?: boolean;

	/**
	 * Add ids.
	 */
	ids?: boolean;

	/**
	 * Add logging output.
	 */
	logging?: boolean | "none" | "error" | "warn" | "info" | "log" | "verbose";

	/**
	 * Include debug logging of specified loggers (i. e. for plugins or loaders). Filters can be Strings, RegExps or Functions.
	 */
	loggingDebug?:
		| string
		| boolean
		| RegExp
		| FilterItemTypes[]
		| ((value: string) => boolean);

	/**
	 * Add stack traces to logging output.
	 */
	loggingTrace?: boolean;

	/**
	 * Add information about assets inside modules.
	 */
	moduleAssets?: boolean;

	/**
	 * Add dependencies and origin of warnings/errors.
	 */
	moduleTrace?: boolean;

	/**
	 * Add built modules information.
	 */
	modules?: boolean;

	/**
	 * Sort the modules by that field.
	 */
	modulesSort?: string;

	/**
	 * Space to display modules (groups will be collapsed to fit this space, value is in number of modules/groups).
	 */
	modulesSpace?: number;

	/**
	 * Add information about modules nested in other modules (like with module concatenation).
	 */
	nestedModules?: boolean;

	/**
	 * Space to display modules nested within other modules (groups will be collapsed to fit this space, value is in number of modules/group).
	 */
	nestedModulesSpace?: number;

	/**
	 * Show reasons why optimization bailed out for modules.
	 */
	optimizationBailout?: boolean;

	/**
	 * Add information about orphan modules.
	 */
	orphanModules?: boolean;

	/**
	 * Add output path information.
	 */
	outputPath?: boolean;

	/**
	 * Add performance hint flags.
	 */
	performance?: boolean;

	/**
	 * Preset for the default values.
	 */
	preset?: string | boolean;

	/**
	 * Show exports provided by modules.
	 */
	providedExports?: boolean;

	/**
	 * Add public path information.
	 */
	publicPath?: boolean;

	/**
	 * Add information about the reasons why modules are included.
	 */
	reasons?: boolean;

	/**
	 * Space to display reasons (groups will be collapsed to fit this space).
	 */
	reasonsSpace?: number;

	/**
	 * Add information about assets that are related to other assets (like SourceMaps for assets).
	 */
	relatedAssets?: boolean;

	/**
	 * Add information about runtime modules (deprecated: use 'runtimeModules' instead).
	 */
	runtime?: boolean;

	/**
	 * Add information about runtime modules.
	 */
	runtimeModules?: boolean;

	/**
	 * Add the source code of modules.
	 */
	source?: boolean;

	/**
	 * Add timing information.
	 */
	timings?: boolean;

	/**
	 * Show exports used by modules.
	 */
	usedExports?: boolean;

	/**
	 * Add webpack version information.
	 */
	version?: boolean;

	/**
	 * Add warnings.
	 */
	warnings?: boolean;

	/**
	 * Add warnings count.
	 */
	warningsCount?: boolean;

	/**
	 * Suppress listing warnings that match the specified filters (they will still be counted). Filters can be Strings, RegExps or Functions.
	 */
	warningsFilter?:
		| string
		| RegExp
		| WarningFilterItemTypes[]
		| ((warning: StatsError, value: string) => boolean);

	/**
	 * Space to display warnings (value is in number of lines).
	 */
	warningsSpace?: number;
}
declare abstract class StatsPrinter {
	hooks: Readonly<{
		sortElements: HookMap<SyncBailHook<[string[], StatsPrinterContext], true>>;
		printElements: HookMap<
			SyncBailHook<[PrintedElement[], StatsPrinterContext], string>
		>;
		sortItems: HookMap<SyncBailHook<[any[], StatsPrinterContext], true>>;
		getItemName: HookMap<SyncBailHook<[any, StatsPrinterContext], string>>;
		printItems: HookMap<SyncBailHook<[string[], StatsPrinterContext], string>>;
		print: HookMap<SyncBailHook<[{}, StatsPrinterContext], string>>;
		result: HookMap<SyncWaterfallHook<[string, StatsPrinterContext]>>;
	}>;
	print(type: string, object: Object, baseContext?: Object): string;
}
type StatsPrinterContext = KnownStatsPrinterContext & Record<string, any>;
type StatsProfile = KnownStatsProfile & Record<string, any>;
type StatsValue =
	| boolean
	| StatsOptions
	| "none"
	| "verbose"
	| "summary"
	| "errors-only"
	| "errors-warnings"
	| "minimal"
	| "normal"
	| "detailed";
declare class SyncModuleIdsPlugin {
	constructor(__0: {
		/**
		 * path to file
		 */
		path: string;
		/**
		 * context for module names
		 */
		context?: string;
		/**
		 * selector for modules
		 */
		test: (arg0: Module) => boolean;
		/**
		 * operation mode (defaults to merge)
		 */
		mode?: "read" | "merge" | "create" | "update";
	});

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface SyntheticDependencyLocation {
	name: string;
	index?: number;
}
declare const TOMBSTONE: unique symbol;
declare const TRANSITIVE: unique symbol;
declare const TRANSITIVE_ONLY: unique symbol;

/**
 * Helper function for joining two ranges into a single range. This is useful
 * when working with AST nodes, as it allows you to combine the ranges of child nodes
 * to create the range of the _parent node_.
 */
declare interface TagInfo {
	tag: any;
	data: any;
	next?: TagInfo;
}
declare class Template {
	constructor();
	static getFunctionContent(fn: Function): string;
	static toIdentifier(str: string): string;
	static toComment(str: string): string;
	static toNormalComment(str: string): string;
	static toPath(str: string): string;
	static numberToIdentifier(n: number): string;
	static numberToIdentifierContinuation(n: number): string;
	static indent(s: string | string[]): string;
	static prefix(s: string | string[], prefix: string): string;
	static asString(str: string | string[]): string;
	static getModulesArrayBounds(modules: WithId[]): false | [number, number];
	static renderChunkModules(
		renderContext: ChunkRenderContext,
		modules: Module[],
		renderModule: (arg0: Module) => Source,
		prefix?: string
	): null | Source;
	static renderRuntimeModules(
		runtimeModules: RuntimeModule[],
		renderContext: RenderContext & {
			codeGenerationResults?: CodeGenerationResults;
		}
	): Source;
	static renderChunkRuntimeModules(
		runtimeModules: RuntimeModule[],
		renderContext: RenderContext
	): Source;
	static NUMBER_OF_IDENTIFIER_START_CHARS: number;
	static NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS: number;
}
declare interface TimestampAndHash {
	safeTime: number;
	timestamp?: number;
	hash: string;
}
declare class TopLevelSymbol {
	constructor(name: string);
	name: string;
}

/**
 * Use a Trusted Types policy to create urls for chunks.
 */
declare interface TrustedTypes {
	/**
	 * If the call to `trustedTypes.createPolicy(...)` fails -- e.g., due to the policy name missing from the CSP `trusted-types` list, or it being a duplicate name, etc. -- controls whether to continue with loading in the hope that `require-trusted-types-for 'script'` isn't enforced yet, versus fail immediately. Default behavior is 'stop'.
	 */
	onPolicyCreationFailure?: "continue" | "stop";

	/**
	 * The name of the Trusted Types policy created by webpack to serve bundle chunks.
	 */
	policyName?: string;
}
declare const UNDEFINED_MARKER: unique symbol;
declare interface UpdateHashContextDependency {
	chunkGraph: ChunkGraph;
	runtime: RuntimeSpec;
	runtimeTemplate?: RuntimeTemplate;
}
declare interface UpdateHashContextGenerator {
	/**
	 * the module
	 */
	module: NormalModule;
	chunkGraph: ChunkGraph;
	runtime: RuntimeSpec;
	runtimeTemplate?: RuntimeTemplate;
}
type UsageStateType = 0 | 1 | 2 | 3 | 4;
declare interface UserResolveOptions {
	/**
	 * A list of module alias configurations or an object which maps key to value
	 */
	alias?: AliasOption[] | AliasOptions;

	/**
	 * A list of module alias configurations or an object which maps key to value, applied only after modules option
	 */
	fallback?: AliasOption[] | AliasOptions;

	/**
	 * An object which maps extension to extension aliases
	 */
	extensionAlias?: ExtensionAliasOptions;

	/**
	 * A list of alias fields in description files
	 */
	aliasFields?: (string | string[])[];

	/**
	 * A function which decides whether a request should be cached or not. An object is passed with at least `path` and `request` properties.
	 */
	cachePredicate?: (arg0: ResolveRequest) => boolean;

	/**
	 * Whether or not the unsafeCache should include request context as part of the cache key.
	 */
	cacheWithContext?: boolean;

	/**
	 * A list of description files to read from
	 */
	descriptionFiles?: string[];

	/**
	 * A list of exports field condition names.
	 */
	conditionNames?: string[];

	/**
	 * Enforce that a extension from extensions must be used
	 */
	enforceExtension?: boolean;

	/**
	 * A list of exports fields in description files
	 */
	exportsFields?: (string | string[])[];

	/**
	 * A list of imports fields in description files
	 */
	importsFields?: (string | string[])[];

	/**
	 * A list of extensions which should be tried for files
	 */
	extensions?: string[];

	/**
	 * The file system which should be used
	 */
	fileSystem: FileSystem;

	/**
	 * Use this cache object to unsafely cache the successful requests
	 */
	unsafeCache?: boolean | object;

	/**
	 * Resolve symlinks to their symlinked location
	 */
	symlinks?: boolean;

	/**
	 * A prepared Resolver to which the plugins are attached
	 */
	resolver?: Resolver;

	/**
	 * A list of directories to resolve modules from, can be absolute path or folder name
	 */
	modules?: string | string[];

	/**
	 * A list of main fields in description files
	 */
	mainFields?: (
		| string
		| string[]
		| { name: string | string[]; forceRelative: boolean }
	)[];

	/**
	 * A list of main files in directories
	 */
	mainFiles?: string[];

	/**
	 * A list of additional resolve plugins which should be applied
	 */
	plugins?: Plugin[];

	/**
	 * A PnP API that should be used - null is "never", undefined is "auto"
	 */
	pnpApi?: null | PnpApiImpl;

	/**
	 * A list of root paths
	 */
	roots?: string[];

	/**
	 * The request is already fully specified and no extensions or directories are resolved for it
	 */
	fullySpecified?: boolean;

	/**
	 * Resolve to a context instead of a file
	 */
	resolveToContext?: boolean;

	/**
	 * A list of resolve restrictions
	 */
	restrictions?: (string | RegExp)[];

	/**
	 * Use only the sync constraints of the file system calls
	 */
	useSyncFileSystemCalls?: boolean;

	/**
	 * Prefer to resolve module requests as relative requests before falling back to modules
	 */
	preferRelative?: boolean;

	/**
	 * Prefer to resolve server-relative urls as absolute paths before falling back to resolve in roots
	 */
	preferAbsolute?: boolean;
}
declare abstract class VariableInfo {
	declaredScope: ScopeInfo;
	freeName?: string | true;
	tagInfo?: TagInfo;
}
declare interface VariableInfoInterface {
	declaredScope: ScopeInfo;
	freeName: string | true;
	tagInfo?: TagInfo;
}
type WarningFilterItemTypes =
	| string
	| RegExp
	| ((warning: StatsError, value: string) => boolean);
declare interface WatchFileSystem {
	watch: (
		files: Iterable<string>,
		directories: Iterable<string>,
		missing: Iterable<string>,
		startTime: number,
		options: WatchOptions,
		callback: (
			arg0: undefined | Error,
			arg1: Map<string, FileSystemInfoEntry | "ignore">,
			arg2: Map<string, FileSystemInfoEntry | "ignore">,
			arg3: Set<string>,
			arg4: Set<string>
		) => void,
		callbackUndelayed: (arg0: string, arg1: number) => void
	) => Watcher;
}
declare class WatchIgnorePlugin {
	constructor(options: WatchIgnorePluginOptions);
	paths: (string | RegExp)[];

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface WatchIgnorePluginOptions {
	/**
	 * A list of RegExps or absolute paths to directories or files that should be ignored.
	 */
	paths: (string | RegExp)[];
}

/**
 * Options for the watcher.
 */
declare interface WatchOptions {
	/**
	 * Delay the rebuilt after the first change. Value is a time in ms.
	 */
	aggregateTimeout?: number;

	/**
	 * Resolve symlinks and watch symlink and real file. This is usually not needed as webpack already resolves symlinks ('resolve.symlinks').
	 */
	followSymlinks?: boolean;

	/**
	 * Ignore some files from watching (glob pattern or regexp).
	 */
	ignored?: string | RegExp | string[];

	/**
	 * Enable polling mode for watching.
	 */
	poll?: number | boolean;

	/**
	 * Stop watching when stdin stream has ended.
	 */
	stdin?: boolean;
}
declare interface Watcher {
	/**
	 * closes the watcher and all underlying file watchers
	 */
	close: () => void;

	/**
	 * closes the watcher, but keeps underlying file watchers alive until the next watch call
	 */
	pause: () => void;

	/**
	 * get current aggregated changes that have not yet send to callback
	 */
	getAggregatedChanges?: () => Set<string>;

	/**
	 * get current aggregated removals that have not yet send to callback
	 */
	getAggregatedRemovals?: () => Set<string>;

	/**
	 * get info about files
	 */
	getFileTimeInfoEntries: () => Map<string, FileSystemInfoEntry | "ignore">;

	/**
	 * get info about directories
	 */
	getContextTimeInfoEntries: () => Map<string, FileSystemInfoEntry | "ignore">;

	/**
	 * get info about timestamps and changes
	 */
	getInfo?: () => WatcherInfo;
}
declare interface WatcherInfo {
	/**
	 * get current aggregated changes that have not yet send to callback
	 */
	changes: Set<string>;

	/**
	 * get current aggregated removals that have not yet send to callback
	 */
	removals: Set<string>;

	/**
	 * get info about files
	 */
	fileTimeInfoEntries: Map<string, FileSystemInfoEntry | "ignore">;

	/**
	 * get info about directories
	 */
	contextTimeInfoEntries: Map<string, FileSystemInfoEntry | "ignore">;
}
declare abstract class Watching {
	startTime: null | number;
	invalid: boolean;
	handler: CallbackFunction<Stats>;
	callbacks: CallbackFunction<void>[];
	closed: boolean;
	suspended: boolean;
	blocked: boolean;
	watchOptions: {
		/**
		 * Delay the rebuilt after the first change. Value is a time in ms.
		 */
		aggregateTimeout?: number;
		/**
		 * Resolve symlinks and watch symlink and real file. This is usually not needed as webpack already resolves symlinks ('resolve.symlinks').
		 */
		followSymlinks?: boolean;
		/**
		 * Ignore some files from watching (glob pattern or regexp).
		 */
		ignored?: string | RegExp | string[];
		/**
		 * Enable polling mode for watching.
		 */
		poll?: number | boolean;
		/**
		 * Stop watching when stdin stream has ended.
		 */
		stdin?: boolean;
	};
	compiler: Compiler;
	running: boolean;
	watcher?: null | Watcher;
	pausedWatcher?: null | Watcher;
	lastWatcherStartTime?: number;
	watch(
		files: Iterable<string>,
		dirs: Iterable<string>,
		missing: Iterable<string>
	): void;
	invalidate(callback?: CallbackFunction<void>): void;
	suspend(): void;
	resume(): void;
	close(callback: CallbackFunction<void>): void;
}
declare abstract class WeakTupleMap<T extends any[], V> {
	set(...args: [T, ...V[]]): void;
	has(...args: T): boolean;
	get(...args: T): V;
	provide(...args: [T, ...(() => V)[]]): V;
	delete(...args: T): void;
	clear(): void;
}
declare interface WebAssemblyRenderContext {
	/**
	 * the chunk
	 */
	chunk: Chunk;

	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;
}
declare class WebWorkerTemplatePlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class WebpackError extends Error {
	/**
	 * Creates an instance of WebpackError.
	 */
	constructor(message?: string);
	details?: string;
	module?: null | Module;
	loc?: SyntheticDependencyLocation | RealDependencyLocation;
	hideStack?: boolean;
	chunk?: Chunk;
	file?: string;
	serialize(__0: ObjectSerializerContext): void;
	deserialize(__0: ObjectDeserializerContext): void;

	/**
	 * Create .stack property on a target object
	 */
	static captureStackTrace(
		targetObject: object,
		constructorOpt?: Function
	): void;

	/**
	 * Optional override for formatting stack traces
	 */
	static prepareStackTrace?: (
		err: Error,
		stackTraces: NodeJS.CallSite[]
	) => any;
	static stackTraceLimit: number;
}
declare abstract class WebpackLogger {
	getChildLogger: (arg0: string | (() => string)) => WebpackLogger;
	error(...args: any[]): void;
	warn(...args: any[]): void;
	info(...args: any[]): void;
	log(...args: any[]): void;
	debug(...args: any[]): void;
	assert(assertion: any, ...args: any[]): void;
	trace(): void;
	clear(): void;
	status(...args: any[]): void;
	group(...args: any[]): void;
	groupCollapsed(...args: any[]): void;
	groupEnd(...args: any[]): void;
	profile(label?: any): void;
	profileEnd(label?: any): void;
	time(label?: any): void;
	timeLog(label?: any): void;
	timeEnd(label?: any): void;
	timeAggregate(label?: any): void;
	timeAggregateEnd(label?: any): void;
}
declare class WebpackOptionsApply extends OptionsApply {
	constructor();
}
declare class WebpackOptionsDefaulter {
	constructor();
	process(options: Configuration): WebpackOptionsNormalized;
}

/**
 * Normalized webpack options object.
 */
declare interface WebpackOptionsNormalized {
	/**
	 * Set the value of `require.amd` and `define.amd`. Or disable AMD support.
	 */
	amd?: false | { [index: string]: any };

	/**
	 * Report the first error as a hard error instead of tolerating it.
	 */
	bail?: boolean;

	/**
	 * Cache generated modules and chunks to improve performance for multiple incremental builds.
	 */
	cache: CacheOptionsNormalized;

	/**
	 * The base directory (absolute path!) for resolving the `entry` option. If `output.pathinfo` is set, the included pathinfo is shortened to this directory.
	 */
	context?: string;

	/**
	 * References to other configurations to depend on.
	 */
	dependencies?: string[];

	/**
	 * Options for the webpack-dev-server.
	 */
	devServer?: DevServer;

	/**
	 * A developer tool to enhance debugging (false | eval | [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map).
	 */
	devtool?: string | false;

	/**
	 * The entry point(s) of the compilation.
	 */
	entry: EntryNormalized;

	/**
	 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
	 */
	experiments: ExperimentsNormalized;

	/**
	 * Specify dependencies that shouldn't be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.
	 */
	externals: Externals;

	/**
	 * Enable presets of externals for specific targets.
	 */
	externalsPresets: ExternalsPresets;

	/**
	 * Specifies the default type of externals ('amd*', 'umd*', 'system' and 'jsonp' depend on output.libraryTarget set to the same value).
	 */
	externalsType?:
		| "import"
		| "var"
		| "module"
		| "assign"
		| "this"
		| "window"
		| "self"
		| "global"
		| "commonjs"
		| "commonjs2"
		| "commonjs-module"
		| "commonjs-static"
		| "amd"
		| "amd-require"
		| "umd"
		| "umd2"
		| "jsonp"
		| "system"
		| "promise"
		| "script"
		| "node-commonjs";

	/**
	 * Ignore specific warnings.
	 */
	ignoreWarnings?: ((
		warning: WebpackError,
		compilation: Compilation
	) => boolean)[];

	/**
	 * Options for infrastructure level logging.
	 */
	infrastructureLogging: InfrastructureLogging;

	/**
	 * Custom values available in the loader context.
	 */
	loader?: Loader;

	/**
	 * Enable production optimizations or development hints.
	 */
	mode?: "none" | "development" | "production";

	/**
	 * Options affecting the normal modules (`NormalModuleFactory`).
	 */
	module: ModuleOptionsNormalized;

	/**
	 * Name of the configuration. Used when loading multiple configurations.
	 */
	name?: string;

	/**
	 * Include polyfills or mocks for various node stuff.
	 */
	node: Node;

	/**
	 * Enables/Disables integrated optimizations.
	 */
	optimization: Optimization;

	/**
	 * Normalized options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
	 */
	output: OutputNormalized;

	/**
	 * The number of parallel processed modules in the compilation.
	 */
	parallelism?: number;

	/**
	 * Configuration for web performance recommendations.
	 */
	performance?: false | PerformanceOptions;

	/**
	 * Add additional plugins to the compiler.
	 */
	plugins: (
		| undefined
		| null
		| false
		| ""
		| 0
		| ((this: Compiler, compiler: Compiler) => void)
		| WebpackPluginInstance
	)[];

	/**
	 * Capture timing information for each module.
	 */
	profile?: boolean;

	/**
	 * Store compiler state to a json file.
	 */
	recordsInputPath?: string | false;

	/**
	 * Load compiler state from a json file.
	 */
	recordsOutputPath?: string | false;

	/**
	 * Options for the resolver.
	 */
	resolve: ResolveOptionsWebpackOptions;

	/**
	 * Options for the resolver when resolving loaders.
	 */
	resolveLoader: ResolveOptionsWebpackOptions;

	/**
	 * Options affecting how file system snapshots are created and validated.
	 */
	snapshot: SnapshotOptionsWebpackOptions;

	/**
	 * Stats options object or preset name.
	 */
	stats: StatsValue;

	/**
	 * Environment to build for. An array of environments to build for all of them when possible.
	 */
	target?: string | false | string[];

	/**
	 * Enter watch mode, which rebuilds on file change.
	 */
	watch?: boolean;

	/**
	 * Options for the watcher.
	 */
	watchOptions: WatchOptions;
}

/**
 * Plugin instance.
 */
declare interface WebpackPluginInstance {
	[index: string]: any;

	/**
	 * The run point of the plugin, required method.
	 */
	apply: (compiler: Compiler) => void;
}
declare interface WithId {
	id: string | number;
}
declare interface WithOptions {
	/**
	 * create a resolver with additional/different options
	 */
	withOptions: (
		arg0: Partial<ResolveOptionsWithDependencyType>
	) => ResolverWithOptions;
}
declare interface WriteOnlySet<T> {
	add: (item: T) => void;
}
type __TypeWebpackOptions = (data: object) =>
	| string
	| {
			/**
			 * Unique loader options identifier.
			 */
			ident?: string;
			/**
			 * Loader name.
			 */
			loader?: string;
			/**
			 * Loader options.
			 */
			options?: string | { [index: string]: any };
	  }
	| __TypeWebpackOptions
	| __Type_2[];
type __Type_2 =
	| undefined
	| null
	| string
	| false
	| 0
	| {
			/**
			 * Unique loader options identifier.
			 */
			ident?: string;
			/**
			 * Loader name.
			 */
			loader?: string;
			/**
			 * Loader options.
			 */
			options?: string | { [index: string]: any };
	  }
	| ((data: object) =>
			| string
			| {
					/**
					 * Unique loader options identifier.
					 */
					ident?: string;
					/**
					 * Loader name.
					 */
					loader?: string;
					/**
					 * Loader options.
					 */
					options?: string | { [index: string]: any };
			  }
			| __TypeWebpackOptions
			| __Type_2[]);
declare function exports(
	options: Configuration,
	callback?: CallbackWebpack<Stats>
): Compiler;
declare function exports(
	options: ReadonlyArray<Configuration> & MultiCompilerOptions,
	callback?: CallbackWebpack<MultiStats>
): MultiCompiler;
declare namespace exports {
	export const webpack: {
		(options: Configuration, callback?: CallbackWebpack<Stats>): Compiler;
		(
			options: ReadonlyArray<Configuration> & MultiCompilerOptions,
			callback?: CallbackWebpack<MultiStats>
		): MultiCompiler;
	};
	export const validate: (options?: any) => void;
	export const validateSchema: (
		schema: Parameters<typeof validateFunction>[0],
		options: Parameters<typeof validateFunction>[1],
		validationConfiguration?: ValidationErrorConfiguration
	) => void;
	export const version: string;
	export namespace cli {
		export let getArguments: (schema?: any) => Record<string, Argument>;
		export let processArguments: (
			args: Record<string, Argument>,
			config: any,
			values: Record<
				string,
				| string
				| number
				| boolean
				| RegExp
				| (string | number | boolean | RegExp)[]
			>
		) => null | Problem[];
	}
	export namespace ModuleFilenameHelpers {
		export let ALL_LOADERS_RESOURCE: string;
		export let REGEXP_ALL_LOADERS_RESOURCE: RegExp;
		export let LOADERS_RESOURCE: string;
		export let REGEXP_LOADERS_RESOURCE: RegExp;
		export let RESOURCE: string;
		export let REGEXP_RESOURCE: RegExp;
		export let ABSOLUTE_RESOURCE_PATH: string;
		export let REGEXP_ABSOLUTE_RESOURCE_PATH: RegExp;
		export let RESOURCE_PATH: string;
		export let REGEXP_RESOURCE_PATH: RegExp;
		export let ALL_LOADERS: string;
		export let REGEXP_ALL_LOADERS: RegExp;
		export let LOADERS: string;
		export let REGEXP_LOADERS: RegExp;
		export let QUERY: string;
		export let REGEXP_QUERY: RegExp;
		export let ID: string;
		export let REGEXP_ID: RegExp;
		export let HASH: string;
		export let REGEXP_HASH: RegExp;
		export let NAMESPACE: string;
		export let REGEXP_NAMESPACE: RegExp;
		export let createFilename: (
			module: string | Module,
			options: any,
			__2: {
				/**
				 * requestShortener
				 */
				requestShortener: RequestShortener;
				/**
				 * chunk graph
				 */
				chunkGraph: ChunkGraph;
				/**
				 * the hash function to use
				 */
				hashFunction: string | typeof Hash;
			}
		) => string;
		export let replaceDuplicates: <T>(
			array: T[],
			fn: (
				duplicateItem: T,
				duplicateItemIndex: number,
				numberOfTimesReplaced: number
			) => T,
			comparator?: (firstElement: T, nextElement: T) => 0 | 1 | -1
		) => T[];
		export let matchPart: (str: string, test: Matcher) => boolean;
		export let matchObject: (obj: MatchObject, str: string) => boolean;
	}
	export namespace RuntimeGlobals {
		export let require: "__webpack_require__";
		export let requireScope: "__webpack_require__.*";
		export let exports: "__webpack_exports__";
		export let thisAsExports: "top-level-this-exports";
		export let returnExportsFromRuntime: "return-exports-from-runtime";
		export let module: "module";
		export let moduleId: "module.id";
		export let moduleLoaded: "module.loaded";
		export let publicPath: "__webpack_require__.p";
		export let entryModuleId: "__webpack_require__.s";
		export let moduleCache: "__webpack_require__.c";
		export let moduleFactories: "__webpack_require__.m";
		export let moduleFactoriesAddOnly: "__webpack_require__.m (add only)";
		export let ensureChunk: "__webpack_require__.e";
		export let ensureChunkHandlers: "__webpack_require__.f";
		export let ensureChunkIncludeEntries: "__webpack_require__.f (include entries)";
		export let prefetchChunk: "__webpack_require__.E";
		export let prefetchChunkHandlers: "__webpack_require__.F";
		export let preloadChunk: "__webpack_require__.G";
		export let preloadChunkHandlers: "__webpack_require__.H";
		export let definePropertyGetters: "__webpack_require__.d";
		export let makeNamespaceObject: "__webpack_require__.r";
		export let createFakeNamespaceObject: "__webpack_require__.t";
		export let compatGetDefaultExport: "__webpack_require__.n";
		export let harmonyModuleDecorator: "__webpack_require__.hmd";
		export let nodeModuleDecorator: "__webpack_require__.nmd";
		export let getFullHash: "__webpack_require__.h";
		export let wasmInstances: "__webpack_require__.w";
		export let instantiateWasm: "__webpack_require__.v";
		export let uncaughtErrorHandler: "__webpack_require__.oe";
		export let scriptNonce: "__webpack_require__.nc";
		export let loadScript: "__webpack_require__.l";
		export let createScript: "__webpack_require__.ts";
		export let createScriptUrl: "__webpack_require__.tu";
		export let getTrustedTypesPolicy: "__webpack_require__.tt";
		export let hasFetchPriority: "has fetch priority";
		export let chunkName: "__webpack_require__.cn";
		export let runtimeId: "__webpack_require__.j";
		export let getChunkScriptFilename: "__webpack_require__.u";
		export let getChunkCssFilename: "__webpack_require__.k";
		export let hasCssModules: "has css modules";
		export let getChunkUpdateScriptFilename: "__webpack_require__.hu";
		export let getChunkUpdateCssFilename: "__webpack_require__.hk";
		export let startup: "__webpack_require__.x";
		export let startupNoDefault: "__webpack_require__.x (no default handler)";
		export let startupOnlyAfter: "__webpack_require__.x (only after)";
		export let startupOnlyBefore: "__webpack_require__.x (only before)";
		export let chunkCallback: "webpackChunk";
		export let startupEntrypoint: "__webpack_require__.X";
		export let onChunksLoaded: "__webpack_require__.O";
		export let externalInstallChunk: "__webpack_require__.C";
		export let interceptModuleExecution: "__webpack_require__.i";
		export let global: "__webpack_require__.g";
		export let shareScopeMap: "__webpack_require__.S";
		export let initializeSharing: "__webpack_require__.I";
		export let currentRemoteGetScope: "__webpack_require__.R";
		export let getUpdateManifestFilename: "__webpack_require__.hmrF";
		export let hmrDownloadManifest: "__webpack_require__.hmrM";
		export let hmrDownloadUpdateHandlers: "__webpack_require__.hmrC";
		export let hmrModuleData: "__webpack_require__.hmrD";
		export let hmrInvalidateModuleHandlers: "__webpack_require__.hmrI";
		export let hmrRuntimeStatePrefix: "__webpack_require__.hmrS";
		export let amdDefine: "__webpack_require__.amdD";
		export let amdOptions: "__webpack_require__.amdO";
		export let system: "__webpack_require__.System";
		export let hasOwnProperty: "__webpack_require__.o";
		export let systemContext: "__webpack_require__.y";
		export let baseURI: "__webpack_require__.b";
		export let relativeUrl: "__webpack_require__.U";
		export let asyncModule: "__webpack_require__.a";
	}
	export const UsageState: Readonly<{
		Unused: 0;
		OnlyPropertiesUsed: 1;
		NoInfo: 2;
		Unknown: 3;
		Used: 4;
	}>;
	export namespace cache {
		export { MemoryCachePlugin };
	}
	export namespace config {
		export const getNormalizedWebpackOptions: (
			config: Configuration
		) => WebpackOptionsNormalized;
		export const applyWebpackOptionsDefaults: (
			options: WebpackOptionsNormalized
		) => void;
	}
	export namespace dependencies {
		export {
			ModuleDependency,
			HarmonyImportDependency,
			ConstDependency,
			NullDependency
		};
	}
	export namespace ids {
		export {
			ChunkModuleIdRangePlugin,
			NaturalModuleIdsPlugin,
			OccurrenceModuleIdsPlugin,
			NamedModuleIdsPlugin,
			DeterministicChunkIdsPlugin,
			DeterministicModuleIdsPlugin,
			NamedChunkIdsPlugin,
			OccurrenceChunkIdsPlugin,
			HashedModuleIdsPlugin
		};
	}
	export namespace javascript {
		export {
			EnableChunkLoadingPlugin,
			JavascriptModulesPlugin,
			JavascriptParser
		};
	}
	export namespace optimize {
		export namespace InnerGraph {
			export let bailout: (parserState: ParserState) => void;
			export let enable: (parserState: ParserState) => void;
			export let isEnabled: (parserState: ParserState) => boolean;
			export let addUsage: (
				state: ParserState,
				symbol: null | TopLevelSymbol,
				usage: string | true | TopLevelSymbol
			) => void;
			export let addVariableUsage: (
				parser: JavascriptParser,
				name: string,
				usage: string | true | TopLevelSymbol
			) => void;
			export let inferDependencyUsage: (state: ParserState) => void;
			export let onUsage: (
				state: ParserState,
				onUsageCallback: (arg0?: boolean | Set<string>) => void
			) => void;
			export let setTopLevelSymbol: (
				state: ParserState,
				symbol?: TopLevelSymbol
			) => void;
			export let getTopLevelSymbol: (
				state: ParserState
			) => void | TopLevelSymbol;
			export let tagTopLevelSymbol: (
				parser: JavascriptParser,
				name: string
			) => undefined | TopLevelSymbol;
			export let isDependencyUsedByExports: (
				dependency: Dependency,
				usedByExports: boolean | Set<string>,
				moduleGraph: ModuleGraph,
				runtime: RuntimeSpec
			) => boolean;
			export let getDependencyUsedByExportsCondition: (
				dependency: Dependency,
				usedByExports: undefined | boolean | Set<string>,
				moduleGraph: ModuleGraph
			) =>
				| null
				| false
				| ((arg0: ModuleGraphConnection, arg1: RuntimeSpec) => ConnectionState);
			export { TopLevelSymbol, topLevelSymbolTag };
		}
		export {
			AggressiveMergingPlugin,
			AggressiveSplittingPlugin,
			LimitChunkCountPlugin,
			MinChunkSizePlugin,
			ModuleConcatenationPlugin,
			RealContentHashPlugin,
			RuntimeChunkPlugin,
			SideEffectsFlagPlugin,
			SplitChunksPlugin
		};
	}
	export namespace runtime {
		export { GetChunkFilenameRuntimeModule, LoadScriptRuntimeModule };
	}
	export namespace prefetch {
		export { ChunkPrefetchPreloadPlugin };
	}
	export namespace web {
		export {
			FetchCompileAsyncWasmPlugin,
			FetchCompileWasmPlugin,
			JsonpChunkLoadingRuntimeModule,
			JsonpTemplatePlugin
		};
	}
	export namespace webworker {
		export { WebWorkerTemplatePlugin };
	}
	export namespace node {
		export {
			NodeEnvironmentPlugin,
			NodeSourcePlugin,
			NodeTargetPlugin,
			NodeTemplatePlugin,
			ReadFileCompileWasmPlugin
		};
	}
	export namespace electron {
		export { ElectronTargetPlugin };
	}
	export namespace wasm {
		export { AsyncWebAssemblyModulesPlugin, EnableWasmLoadingPlugin };
	}
	export namespace library {
		export { AbstractLibraryPlugin, EnableLibraryPlugin };
	}
	export namespace container {
		export const scope: <T>(
			scope: string,
			options: ContainerOptionsFormat<T>
		) => Record<string, string | string[] | T>;
		export {
			ContainerPlugin,
			ContainerReferencePlugin,
			ModuleFederationPlugin
		};
	}
	export namespace sharing {
		export const scope: <T>(
			scope: string,
			options: ContainerOptionsFormat<T>
		) => Record<string, string | string[] | T>;
		export { ConsumeSharedPlugin, ProvideSharedPlugin, SharePlugin };
	}
	export namespace debug {
		export { ProfilingPlugin };
	}
	export namespace util {
		export const createHash: (algorithm?: string | typeof Hash) => Hash;
		export namespace comparators {
			export let compareChunksById: (a: Chunk, b: Chunk) => 0 | 1 | -1;
			export let compareModulesByIdentifier: (
				a: Module,
				b: Module
			) => 0 | 1 | -1;
			export let compareModulesById: ParameterizedComparator<
				ChunkGraph,
				Module
			>;
			export let compareNumbers: (a: number, b: number) => 0 | 1 | -1;
			export let compareStringsNumeric: (a: string, b: string) => 0 | 1 | -1;
			export let compareModulesByPostOrderIndexOrIdentifier: ParameterizedComparator<
				ModuleGraph,
				Module
			>;
			export let compareModulesByPreOrderIndexOrIdentifier: ParameterizedComparator<
				ModuleGraph,
				Module
			>;
			export let compareModulesByIdOrIdentifier: ParameterizedComparator<
				ChunkGraph,
				Module
			>;
			export let compareChunks: ParameterizedComparator<ChunkGraph, Chunk>;
			export let compareIds: (
				a: string | number,
				b: string | number
			) => 0 | 1 | -1;
			export let compareStrings: (a: string, b: string) => 0 | 1 | -1;
			export let compareChunkGroupsByIndex: (
				a: ChunkGroup,
				b: ChunkGroup
			) => 0 | 1 | -1;
			export let concatComparators: <T>(
				c1: Comparator<T>,
				c2: Comparator<T>,
				...cRest: Comparator<T>[]
			) => Comparator<T>;
			export let compareSelect: <T, R>(
				getter: Selector<T, R>,
				comparator: Comparator<R>
			) => Comparator<T>;
			export let compareIterables: <T>(
				elementComparator: Comparator<T>
			) => Comparator<Iterable<T>>;
			export let keepOriginalOrder: <T>(iterable: Iterable<T>) => Comparator<T>;
			export let compareChunksNatural: (
				chunkGraph: ChunkGraph
			) => Comparator<Chunk>;
			export let compareLocations: (
				a: DependencyLocation,
				b: DependencyLocation
			) => 0 | 1 | -1;
		}
		export namespace runtime {
			export let getEntryRuntime: (
				compilation: Compilation,
				name: string,
				options?: EntryOptions
			) => RuntimeSpec;
			export let forEachRuntime: (
				runtime: RuntimeSpec,
				fn: (arg0?: string) => void,
				deterministicOrder?: boolean
			) => void;
			export let getRuntimeKey: (runtime: RuntimeSpec) => string;
			export let keyToRuntime: (key: string) => RuntimeSpec;
			export let runtimeToString: (runtime: RuntimeSpec) => string;
			export let runtimeConditionToString: (
				runtimeCondition: RuntimeCondition
			) => string;
			export let runtimeEqual: (a: RuntimeSpec, b: RuntimeSpec) => boolean;
			export let compareRuntime: (a: RuntimeSpec, b: RuntimeSpec) => 0 | 1 | -1;
			export let mergeRuntime: (a: RuntimeSpec, b: RuntimeSpec) => RuntimeSpec;
			export let mergeRuntimeCondition: (
				a: RuntimeCondition,
				b: RuntimeCondition,
				runtime: RuntimeSpec
			) => RuntimeCondition;
			export let mergeRuntimeConditionNonFalse: (
				a: undefined | string | true | SortableSet<string>,
				b: undefined | string | true | SortableSet<string>,
				runtime: RuntimeSpec
			) => undefined | string | true | SortableSet<string>;
			export let mergeRuntimeOwned: (
				a: RuntimeSpec,
				b: RuntimeSpec
			) => RuntimeSpec;
			export let intersectRuntime: (
				a: RuntimeSpec,
				b: RuntimeSpec
			) => RuntimeSpec;
			export let subtractRuntime: (
				a: RuntimeSpec,
				b: RuntimeSpec
			) => RuntimeSpec;
			export let subtractRuntimeCondition: (
				a: RuntimeCondition,
				b: RuntimeCondition,
				runtime: RuntimeSpec
			) => RuntimeCondition;
			export let filterRuntime: (
				runtime: RuntimeSpec,
				filter: (arg0: RuntimeSpec) => boolean
			) => undefined | string | boolean | SortableSet<string>;
			export { RuntimeSpecMap, RuntimeSpecSet };
		}
		export namespace serialization {
			export const register: (
				Constructor: Constructor,
				request: string,
				name: null | string,
				serializer: ObjectSerializer
			) => void;
			export const registerLoader: (
				regExp: RegExp,
				loader: (arg0: string) => boolean
			) => void;
			export const registerNotSerializable: (Constructor: Constructor) => void;
			export const NOT_SERIALIZABLE: object;
			export const buffersSerializer: Serializer;
			export let createFileSerializer: (
				fs: IntermediateFileSystem,
				hashFunction: string | typeof Hash
			) => Serializer;
			export { MEASURE_START_OPERATION, MEASURE_END_OPERATION };
		}
		export const cleverMerge: <T, O>(first: T, second: O) => T | O | (T & O);
		export { LazySet };
	}
	export namespace sources {
		export {
			Source,
			RawSource,
			OriginalSource,
			ReplaceSource,
			SourceMapSource,
			ConcatSource,
			PrefixSource,
			CachedSource,
			SizeOnlySource,
			CompatSource
		};
	}
	export namespace experiments {
		export namespace schemes {
			export { HttpUriPlugin };
		}
		export namespace ids {
			export { SyncModuleIdsPlugin };
		}
	}
	export type WebpackPluginFunction = (
		this: Compiler,
		compiler: Compiler
	) => void;
	export {
		AutomaticPrefetchPlugin,
		AsyncDependenciesBlock,
		BannerPlugin,
		Cache,
		Chunk,
		ChunkGraph,
		CleanPlugin,
		Compilation,
		Compiler,
		ConcatenationScope,
		ContextExclusionPlugin,
		ContextReplacementPlugin,
		DefinePlugin,
		DelegatedPlugin,
		Dependency,
		DllPlugin,
		DllReferencePlugin,
		DynamicEntryPlugin,
		EntryOptionPlugin,
		EntryPlugin,
		EnvironmentPlugin,
		EvalDevToolModulePlugin,
		EvalSourceMapDevToolPlugin,
		ExternalModule,
		ExternalsPlugin,
		Generator,
		HotUpdateChunk,
		HotModuleReplacementPlugin,
		IgnorePlugin,
		JavascriptModulesPlugin,
		LibManifestPlugin,
		LibraryTemplatePlugin,
		LoaderOptionsPlugin,
		LoaderTargetPlugin,
		Module,
		ModuleGraph,
		ModuleGraphConnection,
		NoEmitOnErrorsPlugin,
		NormalModule,
		NormalModuleReplacementPlugin,
		MultiCompiler,
		Parser,
		PrefetchPlugin,
		ProgressPlugin,
		ProvidePlugin,
		RuntimeModule,
		EntryPlugin as SingleEntryPlugin,
		SourceMapDevToolPlugin,
		Stats,
		Template,
		WatchIgnorePlugin,
		WebpackError,
		WebpackOptionsApply,
		WebpackOptionsDefaulter,
		ValidationError as WebpackOptionsValidationError,
		ValidationError,
		Entry,
		EntryNormalized,
		EntryObject,
		ExternalItemFunctionData,
		ExternalItemObjectKnown,
		ExternalItemObjectUnknown,
		ExternalItemValue,
		Externals,
		FileCacheOptions,
		LibraryOptions,
		MemoryCacheOptions,
		ModuleOptions,
		ResolveOptionsWebpackOptions as ResolveOptions,
		RuleSetCondition,
		RuleSetConditionAbsolute,
		RuleSetRule,
		RuleSetUse,
		RuleSetUseItem,
		StatsOptions,
		Configuration,
		WebpackOptionsNormalized,
		WebpackPluginInstance,
		ChunkGroup,
		Asset,
		AssetInfo,
		EntryOptions,
		PathData,
		AssetEmittedInfo,
		MultiStats,
		ResolveData,
		ParserState,
		ResolvePluginInstance,
		Resolver,
		Watching,
		Argument,
		Problem,
		StatsAsset,
		StatsChunk,
		StatsChunkGroup,
		StatsChunkOrigin,
		StatsCompilation,
		StatsError,
		StatsLogging,
		StatsLoggingEntry,
		StatsModule,
		StatsModuleIssuer,
		StatsModuleReason,
		StatsModuleTraceDependency,
		StatsModuleTraceItem,
		StatsProfile,
		LoaderModule,
		RawLoaderDefinition,
		LoaderDefinition,
		LoaderDefinitionFunction,
		PitchLoaderDefinitionFunction,
		RawLoaderDefinitionFunction,
		LoaderContext
	};
}
declare const topLevelSymbolTag: unique symbol;

export = exports;

