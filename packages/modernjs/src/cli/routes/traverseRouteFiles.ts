import { fs, normalizeToPosixPath } from '@modern-js/utils';
import path from 'path';
import os from 'os';
import { DEFAULT_ENTRY, MF_JSON, ROUTE_ID } from '../../constant';
import { getRemoteLayoutId } from '../../runtime/routes/utils';

const ROUTES = 'routes';

export function calcPathName(filePath: string, rootDir: string, entry: string) {
  const relativePath = path.relative(rootDir, filePath);
  const conditionalReg = /^\[(.*)\]$/;
  const splitPaths = relativePath.split('/').reduce((sum, cur) => {
    if (cur.includes('.')) {
      const split = cur.split('.').map((i) => {
        const match = i.match(conditionalReg);
        if (match) {
          return `:${match[1]}`;
        }
        return i.startsWith('__') ? '' : i;
      });
      sum.push(...split);
    } else {
      const match = cur.match(conditionalReg);
      if (match) {
        sum.push(`:${match[1]}`);
      } else {
        if (!cur.startsWith('__')) {
          sum.push(cur);
        }
      }
    }
    return sum;
  }, [] as string[]);
  return path.join('/', entry, splitPaths.filter((p) => !!p).join('/'));
}

export async function traverseRouteFiles(options: {
  appDirectory: string;
  remotePathMap: Record<string, { name: string; path: string }>;
  generateRouteFile?: boolean;
}) {
  const { appDirectory, generateRouteFile, remotePathMap } = options;
  const entries: string[] = [];
  const srcPath = `${appDirectory}/src`;

  const traverse = async (filepath: string, rootDir: string, entry: string) => {
    if (!(await fs.pathExists(filepath))) {
      return null;
    }
    const isDirectory = (await fs.stat(filepath)).isDirectory();
    if (!isDirectory) {
      return null;
    }

    const items = await fs.readdir(filepath);
    const mfJson = items.find((i) => i === MF_JSON);
    if (mfJson) {
      const mfJsonContent = (await fs.readJSON(
        normalizeToPosixPath(path.join(filepath, mfJson)),
      )) as { remoteName: string };
      const { remoteName } = mfJsonContent;
      const remoteLayoutId = getRemoteLayoutId(remoteName);

      const writeFile = async (
        id: string,
        type: 'layout' | 'page',
        pathname: string,
      ) => {
        const generatedFilePath = normalizeToPosixPath(
          path.join(filepath, `${type}.tsx`),
        );
        const content = [
          '// Do not edit this file. It is a auto generated.',
          `// It will render ${remoteName}'s ${type}.`,
          `// The ${type} pathname is: ${pathname}`,
          `// The ${type} route id is: ${ROUTE_ID}`,
        ];
        await fs.writeFile(generatedFilePath, content.join(os.EOL));
        return generatedFilePath;
      };

      if (remoteLayoutId) {
        const pathname = calcPathName(filepath, rootDir, entry);
        const filePath = await writeFile(remoteLayoutId, 'layout', pathname);
        remotePathMap[pathname] = { name: remoteName, path: filePath };
      }
      return;
    }
    await Promise.all(
      items.map(async (item) => {
        await traverse(
          normalizeToPosixPath(path.join(filepath, item)),
          rootDir,
          entry,
        );
      }),
    );
  };

  const traverseRoutes = async (dir: string, level = 1) => {
    if (level > 3) {
      return;
    }
    const isDirectory = (await fs.stat(dir)).isDirectory();
    if (!isDirectory) {
      return;
    }

    const items = await fs.readdir(dir);

    if (items.find((i) => i === ROUTES)) {
      const entry = path.relative(srcPath, dir);
      entries.push(entry);
      const rootDir = `${dir}/${ROUTES}`;
      if (generateRouteFile) {
        await traverse(rootDir, rootDir, entry);
      }
    } else {
      await Promise.all(
        items.map(async (item) => {
          await traverseRoutes(path.join(dir, item), level++);
        }),
      );
    }
  };

  await traverseRoutes(srcPath);
  const normalizedEntries = entries.map((entry) => {
    if (entry === '') {
      return DEFAULT_ENTRY;
    }
    return entry;
  });
  return {
    entries: normalizedEntries,
  };
}
