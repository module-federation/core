3b75fe44ae57ddcc3ae8b37b8725c6d1
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var polyfills = require('./polyfills.cjs.js');
var sdk = require('@module-federation/sdk');
var share = require('./share.cjs.js');
// Function to match a remote with its name and expose
// id: pkgName(@federation/app1) + expose(button) = @federation/app1/button
// id: alias(app1) + expose(button) = app1/button
// id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort
function matchRemoteWithNameAndExpose(remotes, id) {
    for (const remote of remotes){
        // match pkgName
        const isNameMatched = id.startsWith(remote.name);
        let expose = id.replace(remote.name, '');
        if (isNameMatched) {
            if (expose.startsWith('/')) {
                const pkgNameOrAlias = remote.name;
                expose = `.${expose}`;
                return {
                    pkgNameOrAlias,
                    expose,
                    remote
                };
            } else if (expose === '') {
                return {
                    pkgNameOrAlias: remote.name,
                    expose: '.',
                    remote
                };
            }
        }
        // match alias
        const isAliasMatched = remote.alias && id.startsWith(remote.alias);
        let exposeWithAlias = remote.alias && id.replace(remote.alias, '');
        if (remote.alias && isAliasMatched) {
            if (exposeWithAlias && exposeWithAlias.startsWith('/')) {
                const pkgNameOrAlias = remote.alias;
                exposeWithAlias = `.${exposeWithAlias}`;
                return {
                    pkgNameOrAlias,
                    expose: exposeWithAlias,
                    remote
                };
            } else if (exposeWithAlias === '') {
                return {
                    pkgNameOrAlias: remote.alias,
                    expose: '.',
                    remote
                };
            }
        }
    }
    return;
}
// Function to match a remote with its name or alias
function matchRemote(remotes, nameOrAlias) {
    for (const remote of remotes){
        const isNameMatched = nameOrAlias === remote.name;
        if (isNameMatched) {
            return remote;
        }
        const isAliasMatched = remote.alias && nameOrAlias === remote.alias;
        if (isAliasMatched) {
            return remote;
        }
    }
    return;
}
function registerPlugins$1(plugins, hookInstances) {
    const globalPlugins = share.getGlobalHostPlugins();
    // Incorporate global plugins
    if (globalPlugins.length > 0) {
        globalPlugins.forEach((plugin)=>{
            if (plugins == null ? void 0 : plugins.find((item)=>item.name !== plugin.name)) {
                plugins.push(plugin);
            }
        });
    }
    if (plugins && plugins.length > 0) {
        plugins.forEach((plugin)=>{
            hookInstances.forEach((hookInstance)=>{
                hookInstance.applyPlugin(plugin);
            });
        });
    }
    return plugins;
}
async function loadEsmEntry({ entry, remoteEntryExports }) {
    return new Promise((resolve, reject)=>{
        try {
            if (!remoteEntryExports) {
                // eslint-disable-next-line no-eval
                new Function('callbacks', `import("${entry}").then(callbacks[0]).catch(callbacks[1])`)([
                    resolve,
                    reject
                ]);
            } else {
                resolve(remoteEntryExports);
            }
        } catch (e) {
            reject(e);
        }
    });
}
async function loadSystemJsEntry({ entry, remoteEntryExports }) {
    return new Promise((resolve, reject)=>{
        try {
            if (!remoteEntryExports) {
                // eslint-disable-next-line no-eval
                new Function('callbacks', `System.import("${entry}").then(callbacks[0]).catch(callbacks[1])`)([
                    resolve,
                    reject
                ]);
            } else {
                resolve(remoteEntryExports);
            }
        } catch (e) {
            reject(e);
        }
    });
}
async function loadEntryScript({ name, globalName, entry, createScriptHook }) {
    const { entryExports: remoteEntryExports } = share.getRemoteEntryExports(name, globalName);
    if (remoteEntryExports) {
        return remoteEntryExports;
    }
    return sdk.loadScript(entry, {
        attrs: {},
        createScriptHook: (url, attrs)=>{
            const res = createScriptHook.emit({
                url,
                attrs
            });
            if (!res) return;
            if (res instanceof HTMLScriptElement) {
                return res;
            }
            if ('script' in res || 'timeout' in res) {
                return res;
            }
            return;
        }
    }).then(()=>{
        const { remoteEntryKey, entryExports } = share.getRemoteEntryExports(name, globalName);
        share.assert(entryExports, `
      Unable to use the ${name}'s '${entry}' URL with ${remoteEntryKey}'s globalName to get remoteEntry exports.
      Possible reasons could be:\n
      1. '${entry}' is not the correct URL, or the remoteEntry resource or name is incorrect.\n
      2. ${remoteEntryKey} cannot be used to get remoteEntry exports in the window object.
    `);
        return entryExports;
    }).catch((e)=>{
        throw e;
    });
}
async function loadEntryDom({ remoteInfo, remoteEntryExports, createScriptHook }) {
    const { entry, entryGlobalName: globalName, name, type } = remoteInfo;
    switch(type){
        case 'esm':
        case 'module':
            return loadEsmEntry({
                entry,
                remoteEntryExports
            });
        case 'system':
            return loadSystemJsEntry({
                entry,
                remoteEntryExports
            });
        default:
            return loadEntryScript({
                entry,
                globalName,
                name,
                createScriptHook
            });
    }
}
async function loadEntryNode({ remoteInfo, createScriptHook }) {
    const { entry, entryGlobalName: globalName, name } = remoteInfo;
    const { entryExports: remoteEntryExports } = share.getRemoteEntryExports(name, globalName);
    if (remoteEntryExports) {
        return remoteEntryExports;
    }
    return sdk.loadScriptNode(entry, {
        attrs: {
            name,
            globalName
        },
        createScriptHook: (url, attrs)=>{
            const res = createScriptHook.emit({
                url,
                attrs
            });
            if (!res) return;
            if ('url' in res) {
                return res;
            }
            return;
        }
    }).then(()=>{
        const { remoteEntryKey, entryExports } = share.getRemoteEntryExports(name, globalName);
        share.assert(entryExports, `
      Unable to use the ${name}'s '${entry}' URL with ${remoteEntryKey}'s globalName to get remoteEntry exports.
      Possible reasons could be:\n
      1. '${entry}' is not the correct URL, or the remoteEntry resource or name is incorrect.\n
      2. ${remoteEntryKey} cannot be used to get remoteEntry exports in the window object.
    `);
        return entryExports;
    }).catch((e)=>{
        throw e;
    });
}
function getRemoteEntryUniqueKey(remoteInfo) {
    const { entry, name } = remoteInfo;
    return sdk.composeKeyWithSeparator(name, entry);
}
async function getRemoteEntry({ origin, remoteEntryExports, remoteInfo }) {
    const uniqueKey = getRemoteEntryUniqueKey(remoteInfo);
    if (remoteEntryExports) {
        return remoteEntryExports;
    }
    if (!share.globalLoading[uniqueKey]) {
        const loadEntryHook = origin.remoteHandler.hooks.lifecycle.loadEntry;
        if (loadEntryHook.listeners.size) {
            share.globalLoading[uniqueKey] = loadEntryHook.emit({
                createScriptHook: origin.loaderHook.lifecycle.createScript,
                remoteInfo,
                remoteEntryExports
            }).then((res)=>res || undefined);
        } else {
            const createScriptHook = origin.loaderHook.lifecycle.createScript;
            if (!sdk.isBrowserEnv()) {
                share.globalLoading[uniqueKey] = loadEntryNode({
                    remoteInfo,
                    createScriptHook
                });
            } else {
                share.globalLoading[uniqueKey] = loadEntryDom({
                    remoteInfo,
                    remoteEntryExports,
                    createScriptHook
                });
            }
        }
    }
    return share.globalLoading[uniqueKey];
}
function getRemoteInfo(remote) {
    return polyfills._extends({}, remote, {
        entry: 'entry' in remote ? remote.entry : '',
        type: remote.type || share.DEFAULT_REMOTE_TYPE,
        entryGlobalName: remote.entryGlobalName || remote.name,
        shareScope: remote.shareScope || share.DEFAULT_SCOPE
    });
}
let Module = class Module {
    async getEntry() {
        if (this.remoteEntryExports) {
            return this.remoteEntryExports;
        }
        // Get remoteEntry.js
        const remoteEntryExports = await getRemoteEntry({
            origin: this.host,
            remoteInfo: this.remoteInfo,
            remoteEntryExports: this.remoteEntryExports
        });
        share.assert(remoteEntryExports, `remoteEntryExports is undefined \n ${sdk.safeToString(this.remoteInfo)}`);
        this.remoteEntryExports = remoteEntryExports;
        return this.remoteEntryExports;
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    async get(id, expose, options, remoteSnapshot) {
        const { loadFactory = true } = options || {
            loadFactory: true
        };
        // Get remoteEntry.js
        const remoteEntryExports = await this.getEntry();
        if (!this.inited) {
            const localShareScopeMap = this.host.shareScopeMap;
            const remoteShareScope = this.remoteInfo.shareScope || 'default';
            if (!localShareScopeMap[remoteShareScope]) {
                localShareScopeMap[remoteShareScope] = {};
            }
            const shareScope = localShareScopeMap[remoteShareScope];
            const initScope = [];
            const remoteEntryInitOptions = {
                version: this.remoteInfo.version || ''
            };
            // Help to find host instance
            Object.defineProperty(remoteEntryInitOptions, 'shareScopeMap', {
                value: localShareScopeMap,
                // remoteEntryInitOptions will be traversed and assigned during container init, ,so this attribute is not allowed to be traversed
                enumerable: false
            });
            const initContainerOptions = await this.host.hooks.lifecycle.beforeInitContainer.emit({
                shareScope,
                // @ts-ignore shareScopeMap will be set by Object.defineProperty
                remoteEntryInitOptions,
                initScope,
                remoteInfo: this.remoteInfo,
                origin: this.host
            });
            if (typeof (remoteEntryExports == null ? void 0 : remoteEntryExports.init) === 'undefined') {
                console.error('The remote entry interface does not contain "init"', '\n', 'Ensure the name of this remote is not reserved or in use. Check if anything already exists on window[nameOfRemote]', '\n', 'Ensure that window[nameOfRemote] is returning a {get,init} object.');
            }
            await remoteEntryExports.init(initContainerOptions.shareScope, initContainerOptions.initScope, initContainerOptions.remoteEntryInitOptions);
            await this.host.hooks.lifecycle.initContainer.emit(polyfills._extends({}, initContainerOptions, {
                id,
                remoteSnapshot,
                remoteEntryExports
            }));
        }
        this.lib = remoteEntryExports;
        this.inited = true;
        // get exposeGetter
        const moduleFactory = await remoteEntryExports.get(expose);
        share.assert(moduleFactory, `${share.getFMId(this.remoteInfo)} remote don't export ${expose}.`);
        const wrapModuleFactory = this.wraperFactory(moduleFactory, id);
        if (!loadFactory) {
            return wrapModuleFactory;
        }
        const exposeContent = await wrapModuleFactory();
        return exposeContent;
    }
    wraperFactory(moduleFactory, id) {
        function defineModuleId(res, id) {
            if (res && typeof res === 'object' && Object.isExtensible(res) && !Object.getOwnPropertyDescriptor(res, Symbol.for('mf_module_id'))) {
                Object.defineProperty(res, Symbol.for('mf_module_id'), {
                    value: id,
                    enumerable: false
                });
            }
        }
        if (moduleFactory instanceof Promise) {
            return async ()=>{
                const res = await moduleFactory();
                // This parameter is used for bridge debugging
                defineModuleId(res, id);
                return res;
            };
        } else {
            return ()=>{
                const res = moduleFactory();
                // This parameter is used for bridge debugging
                defineModuleId(res, id);
                return res;
            };
        }
    }
    constructor({ remoteInfo, host }){
        this.inited = false;
        this.lib = undefined;
        this.remoteInfo = remoteInfo;
        this.host = host;
    }
};
class SyncHook {
    on(fn) {
        if (typeof fn === 'function') {
            this.listeners.add(fn);
        }
    }
    once(fn) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this.on(function wrapper(...args) {
            self.remove(wrapper);
            // eslint-disable-next-line prefer-spread
            return fn.apply(null, args);
        });
    }
    emit(...data) {
        let result;
        if (this.listeners.size > 0) {
            // eslint-disable-next-line prefer-spread
            this.listeners.forEach((fn)=>{
                result = fn(...data);
            });
        }
        return result;
    }
    remove(fn) {
        this.listeners.delete(fn);
    }
    removeAll() {
        this.listeners.clear();
    }
    constructor(type){
        this.type = '';
        this.listeners = new Set();
        if (type) {
            this.type = type;
        }
    }
}
class AsyncHook extends SyncHook {
    emit(...data) {
        let result;
        const ls = Array.from(this.listeners);
        if (ls.length > 0) {
            let i = 0;
            const call = (prev)=>{
                if (prev === false) {
                    return false; // Abort process
                } else if (i < ls.length) {
                    return Promise.resolve(ls[i++].apply(null, data)).then(call);
                } else {
                    return prev;
                }
            };
            result = call();
        }
        return Promise.resolve(result);
    }
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function checkReturnData(originalData, returnedData) {
    if (!share.isObject(returnedData)) {
        return false;
    }
    if (originalData !== returnedData) {
        // eslint-disable-next-line no-restricted-syntax
        for(const key in originalData){
            if (!(key in returnedData)) {
                return false;
            }
        }
    }
    return true;
}
class SyncWaterfallHook extends SyncHook {
    emit(data) {
        if (!share.isObject(data)) {
            share.error(`The data for the "${this.type}" hook should be an object.`);
        }
        for (const fn of this.listeners){
            try {
                const tempData = fn(data);
                if (checkReturnData(data, tempData)) {
                    data = tempData;
                } else {
                    this.onerror(`A plugin returned an unacceptable value for the "${this.type}" type.`);
                    break;
                }
            } catch (e) {
                share.warn(e);
                this.onerror(e);
            }
        }
        return data;
    }
    constructor(type){
        super();
        this.onerror = share.error;
        this.type = type;
    }
}
class AsyncWaterfallHook extends SyncHook {
    emit(data) {
        if (!share.isObject(data)) {
            share.error(`The response data for the "${this.type}" hook must be an object.`);
        }
        const ls = Array.from(this.listeners);
        if (ls.length > 0) {
            let i = 0;
            const processError = (e)=>{
                share.warn(e);
                this.onerror(e);
                return data;
            };
            const call = (prevData)=>{
                if (checkReturnData(data, prevData)) {
                    data = prevData;
                    if (i < ls.length) {
                        try {
                            return Promise.resolve(ls[i++](data)).then(call, processError);
                        } catch (e) {
                            return processError(e);
                        }
                    }
                } else {
                    this.onerror(`A plugin returned an incorrect value for the "${this.type}" type.`);
                }
                return data;
            };
            return Promise.resolve(call(data));
        }
        return Promise.resolve(data);
    }
    constructor(type){
        super();
        this.onerror = share.error;
        this.type = type;
    }
}
class PluginSystem {
    applyPlugin(plugin) {
        share.assert(share.isPlainObject(plugin), 'Plugin configuration is invalid.');
        // The plugin's name is mandatory and must be unique
        const pluginName = plugin.name;
        share.assert(pluginName, 'A name must be provided by the plugin.');
        if (!this.registerPlugins[pluginName]) {
            this.registerPlugins[pluginName] = plugin;
            Object.keys(this.lifecycle).forEach((key)=>{
                const pluginLife = plugin[key];
                if (pluginLife) {
                    this.lifecycle[key].on(pluginLife);
                }
            });
        }
    }
    removePlugin(pluginName) {
        share.assert(pluginName, 'A name is required.');
        const plugin = this.registerPlugins[pluginName];
        share.assert(plugin, `The plugin "${pluginName}" is not registered.`);
        Object.keys(plugin).forEach((key)=>{
            if (key !== 'name') {
                this.lifecycle[key].remove(plugin[key]);
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-shadow
    inherit({ lifecycle, registerPlugins }) {
        Object.keys(lifecycle).forEach((hookName)=>{
            share.assert(!this.lifecycle[hookName], `The hook "${hookName}" has a conflict and cannot be inherited.`);
            this.lifecycle[hookName] = lifecycle[hookName];
        });
        Object.keys(registerPlugins).forEach((pluginName)=>{
            share.assert(!this.registerPlugins[pluginName], `The plugin "${pluginName}" has a conflict and cannot be inherited.`);
            this.applyPlugin(registerPlugins[pluginName]);
        });
    }
    constructor(lifecycle){
        this.registerPlugins = {};
        this.lifecycle = lifecycle;
        this.lifecycleKeys = Object.keys(lifecycle);
    }
}
function defaultPreloadArgs(preloadConfig) {
    return polyfills._extends({
        resourceCategory: 'sync',
        share: true,
        depsRemote: true,
        prefetchInterface: false
    }, preloadConfig);
}
function formatPreloadArgs(remotes, preloadArgs) {
    return preloadArgs.map((args)=>{
        const remoteInfo = matchRemote(remotes, args.nameOrAlias);
        share.assert(remoteInfo, `Unable to preload ${args.nameOrAlias} as it is not included in ${!remoteInfo && sdk.safeToString({
            remoteInfo,
            remotes
        })}`);
        return {
            remote: remoteInfo,
            preloadConfig: defaultPreloadArgs(args)
        };
    });
}
function normalizePreloadExposes(exposes) {
    if (!exposes) {
        return [];
    }
    return exposes.map((expose)=>{
        if (expose === '.') {
            return expose;
        }
        if (expose.startsWith('./')) {
            return expose.replace('./', '');
        }
        return expose;
    });
}
function preloadAssets(remoteInfo, host, assets, useLinkPreload = true) {
    const { cssAssets, jsAssetsWithoutEntry, entryAssets } = assets;
    if (host.options.inBrowser) {
        entryAssets.forEach((asset)=>{
            const { moduleInfo } = asset;
            const module = host.moduleCache.get(remoteInfo.name);
            if (module) {
                getRemoteEntry({
                    origin: host,
                    remoteInfo: moduleInfo,
                    remoteEntryExports: module.remoteEntryExports
                });
            } else {
                getRemoteEntry({
                    origin: host,
                    remoteInfo: moduleInfo,
                    remoteEntryExports: undefined
                });
            }
        });
        if (useLinkPreload) {
            const defaultAttrs = {
                rel: 'preload',
                as: 'style',
                crossorigin: 'anonymous'
            };
            cssAssets.forEach((cssUrl)=>{
                const { link: cssEl, needAttach } = sdk.createLink({
                    url: cssUrl,
                    cb: ()=>{},
                    attrs: defaultAttrs,
                    createLinkHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createLink.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    }
                });
                needAttach && document.head.appendChild(cssEl);
            });
        } else {
            const defaultAttrs = {
                rel: 'stylesheet',
                type: 'text/css'
            };
            cssAssets.forEach((cssUrl)=>{
                const { link: cssEl, needAttach } = sdk.createLink({
                    url: cssUrl,
                    cb: ()=>{},
                    attrs: defaultAttrs,
                    createLinkHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createLink.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    },
                    needDeleteLink: false
                });
                needAttach && document.head.appendChild(cssEl);
            });
        }
        if (useLinkPreload) {
            const defaultAttrs = {
                rel: 'preload',
                as: 'script',
                crossorigin: 'anonymous'
            };
            jsAssetsWithoutEntry.forEach((jsUrl)=>{
                const { link: linkEl, needAttach } = sdk.createLink({
                    url: jsUrl,
                    cb: ()=>{},
                    attrs: defaultAttrs,
                    createLinkHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createLink.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    }
                });
                needAttach && document.head.appendChild(linkEl);
            });
        } else {
            const defaultAttrs = {
                fetchpriority: 'high',
                type: (remoteInfo == null ? void 0 : remoteInfo.type) === 'module' ? 'module' : 'text/javascript'
            };
            jsAssetsWithoutEntry.forEach((jsUrl)=>{
                const { script: scriptEl, needAttach } = sdk.createScript({
                    url: jsUrl,
                    cb: ()=>{},
                    attrs: defaultAttrs,
                    createScriptHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createScript.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLScriptElement) {
                            return res;
                        }
                        return;
                    },
                    needDeleteScript: true
                });
                needAttach && document.head.appendChild(scriptEl);
            });
        }
    }
}
function assignRemoteInfo(remoteInfo, remoteSnapshot) {
    const remoteEntryInfo = share.getRemoteEntryInfoFromSnapshot(remoteSnapshot);
    if (!remoteEntryInfo.url) {
        share.error(`The attribute remoteEntry of ${remoteInfo.name} must not be undefined.`);
    }
    let entryUrl = sdk.getResourceUrl(remoteSnapshot, remoteEntryInfo.url);
    if (!sdk.isBrowserEnv() && !entryUrl.startsWith('http')) {
        entryUrl = `https:${entryUrl}`;
    }
    remoteInfo.type = remoteEntryInfo.type;
    remoteInfo.entryGlobalName = remoteEntryInfo.globalName;
    remoteInfo.entry = entryUrl;
    remoteInfo.version = remoteSnapshot.version;
    remoteInfo.buildVersion = remoteSnapshot.buildVersion;
}
function snapshotPlugin() {
    return {
        name: 'snapshot-plugin',
        async afterResolve (args) {
            const { remote, pkgNameOrAlias, expose, origin, remoteInfo } = args;
            if (!share.isRemoteInfoWithEntry(remote) || !share.isPureRemoteEntry(remote)) {
                const { remoteSnapshot, globalSnapshot } = await origin.snapshotHandler.loadRemoteSnapshotInfo(remote);
                assignRemoteInfo(remoteInfo, remoteSnapshot);
                // preloading assets
                const preloadOptions = {
                    remote,
                    preloadConfig: {
                        nameOrAlias: pkgNameOrAlias,
                        exposes: [
                            expose
                        ],
                        resourceCategory: 'sync',
                        share: false,
                        depsRemote: false
                    }
                };
                const assets = await origin.remoteHandler.hooks.lifecycle.generatePreloadAssets.emit({
                    origin,
                    preloadOptions,
                    remoteInfo,
                    remote,
                    remoteSnapshot,
                    globalSnapshot
                });
                if (assets) {
                    preloadAssets(remoteInfo, origin, assets, false);
                }
                return polyfills._extends({}, args, {
                    remoteSnapshot
                });
            }
            return args;
        }
    };
}
// name
// name:version
function splitId(id) {
    const splitInfo = id.split(':');
    if (splitInfo.length === 1) {
        return {
            name: splitInfo[0],
            version: undefined
        };
    } else if (splitInfo.length === 2) {
        return {
            name: splitInfo[0],
            version: splitInfo[1]
        };
    } else {
        return {
            name: splitInfo[1],
            version: splitInfo[2]
        };
    }
}
// Traverse all nodes in moduleInfo and traverse the entire snapshot
function traverseModuleInfo(globalSnapshot, remoteInfo, traverse, isRoot, memo = {}, remoteSnapshot) {
    const id = share.getFMId(remoteInfo);
    const { value: snapshotValue } = share.getInfoWithoutType(globalSnapshot, id);
    const effectiveRemoteSnapshot = remoteSnapshot || snapshotValue;
    if (effectiveRemoteSnapshot && !sdk.isManifestProvider(effectiveRemoteSnapshot)) {
        traverse(effectiveRemoteSnapshot, remoteInfo, isRoot);
        if (effectiveRemoteSnapshot.remotesInfo) {
            const remoteKeys = Object.keys(effectiveRemoteSnapshot.remotesInfo);
            for (const key of remoteKeys){
                if (memo[key]) {
                    continue;
                }
                memo[key] = true;
                const subRemoteInfo = splitId(key);
                const remoteValue = effectiveRemoteSnapshot.remotesInfo[key];
                traverseModuleInfo(globalSnapshot, {
                    name: subRemoteInfo.name,
                    version: remoteValue.matchedVersion
                }, traverse, false, memo, undefined);
            }
        }
    }
}
// eslint-disable-next-line max-lines-per-function
function generatePreloadAssets(origin, preloadOptions, remote, globalSnapshot, remoteSnapshot) {
    const cssAssets = [];
    const jsAssets = [];
    const entryAssets = [];
    const loadedSharedJsAssets = new Set();
    const loadedSharedCssAssets = new Set();
    const { options } = origin;
    const { preloadConfig: rootPreloadConfig } = preloadOptions;
    const { depsRemote } = rootPreloadConfig;
    const memo = {};
    traverseModuleInfo(globalSnapshot, remote, (moduleInfoSnapshot, remoteInfo, isRoot)=>{
        let preloadConfig;
        if (isRoot) {
            preloadConfig = rootPreloadConfig;
        } else {
            if (Array.isArray(depsRemote)) {
                // eslint-disable-next-line array-callback-return
                const findPreloadConfig = depsRemote.find((remoteConfig)=>{
                    if (remoteConfig.nameOrAlias === remoteInfo.name || remoteConfig.nameOrAlias === remoteInfo.alias) {
                        return true;
                    }
                    return false;
                });
                if (!findPreloadConfig) {
                    return;
                }
                preloadConfig = defaultPreloadArgs(findPreloadConfig);
            } else if (depsRemote === true) {
                preloadConfig = rootPreloadConfig;
            } else {
                return;
            }
        }
        const remoteEntryUrl = sdk.getResourceUrl(moduleInfoSnapshot, share.getRemoteEntryInfoFromSnapshot(moduleInfoSnapshot).url);
        if (remoteEntryUrl) {
            entryAssets.push({
                name: remoteInfo.name,
                moduleInfo: {
                    name: remoteInfo.name,
                    entry: remoteEntryUrl,
                    type: 'remoteEntryType' in moduleInfoSnapshot ? moduleInfoSnapshot.remoteEntryType : 'global',
                    entryGlobalName: 'globalName' in moduleInfoSnapshot ? moduleInfoSnapshot.globalName : remoteInfo.name,
                    shareScope: '',
                    version: 'version' in moduleInfoSnapshot ? moduleInfoSnapshot.version : undefined
                },
                url: remoteEntryUrl
            });
        }
        let moduleAssetsInfo = 'modules' in moduleInfoSnapshot ? moduleInfoSnapshot.modules : [];
        const normalizedPreloadExposes = normalizePreloadExposes(preloadConfig.exposes);
        if (normalizedPreloadExposes.length && 'modules' in moduleInfoSnapshot) {
            var _moduleInfoSnapshot_modules;
            moduleAssetsInfo = moduleInfoSnapshot == null ? void 0 : (_moduleInfoSnapshot_modules = moduleInfoSnapshot.modules) == null ? void 0 : _moduleInfoSnapshot_modules.reduce((assets, moduleAssetInfo)=>{
                if ((normalizedPreloadExposes == null ? void 0 : normalizedPreloadExposes.indexOf(moduleAssetInfo.moduleName)) !== -1) {
                    assets.push(moduleAssetInfo);
                }
                return assets;
            }, []);
        }
        function handleAssets(assets) {
            const assetsRes = assets.map((asset)=>sdk.getResourceUrl(moduleInfoSnapshot, asset));
            if (preloadConfig.filter) {
                return assetsRes.filter(preloadConfig.filter);
            }
            return assetsRes;
        }
        if (moduleAssetsInfo) {
            const assetsLength = moduleAssetsInfo.length;
            for(let index = 0; index < assetsLength; index++){
                const assetsInfo = moduleAssetsInfo[index];
                const exposeFullPath = `${remoteInfo.name}/${assetsInfo.moduleName}`;
                origin.remoteHandler.hooks.lifecycle.handlePreloadModule.emit({
                    id: assetsInfo.moduleName === '.' ? remoteInfo.name : exposeFullPath,
                    name: remoteInfo.name,
                    remoteSnapshot: moduleInfoSnapshot,
                    preloadConfig,
                    remote: remoteInfo,
                    origin
                });
                const preloaded = share.getPreloaded(exposeFullPath);
                if (preloaded) {
                    continue;
                }
                if (preloadConfig.resourceCategory === 'all') {
                    cssAssets.push(...handleAssets(assetsInfo.assets.css.async));
                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.async));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));
                // eslint-disable-next-line no-constant-condition
                } else if (preloadConfig.resourceCategory = 'sync') {
                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));
                }
                share.setPreloaded(exposeFullPath);
            }
        }
    }, true, memo, remoteSnapshot);
    if (remoteSnapshot.shared) {
        const collectSharedAssets = (shareInfo, snapshotShared)=>{
            const registeredShared = share.getRegisteredShare(origin.shareScopeMap, snapshotShared.sharedName, shareInfo, origin.sharedHandler.hooks.lifecycle.resolveShare);
            // If the global share does not exist, or the lib function does not exist, it means that the shared has not been loaded yet and can be preloaded.
            if (registeredShared && typeof registeredShared.lib === 'function') {
                snapshotShared.assets.js.sync.forEach((asset)=>{
                    loadedSharedJsAssets.add(asset);
                });
                snapshotShared.assets.css.sync.forEach((asset)=>{
                    loadedSharedCssAssets.add(asset);
                });
            }
        };
        remoteSnapshot.shared.forEach((shared)=>{
            var _options_shared;
            const shareInfos = (_options_shared = options.shared) == null ? void 0 : _options_shared[shared.sharedName];
            if (!shareInfos) {
                return;
            }
            // if no version, preload all shared
            const sharedOptions = shared.version ? shareInfos.find((s)=>s.version === shared.version) : shareInfos;
            if (!sharedOptions) {
                return;
            }
            const arrayShareInfo = share.arrayOptions(sharedOptions);
            arrayShareInfo.forEach((s)=>{
                collectSharedAssets(s, shared);
            });
        });
    }
    const needPreloadJsAssets = jsAssets.filter((asset)=>!loadedSharedJsAssets.has(asset));
    const needPreloadCssAssets = cssAssets.filter((asset)=>!loadedSharedCssAssets.has(asset));
    return {
        cssAssets: needPreloadCssAssets,
        jsAssetsWithoutEntry: needPreloadJsAssets,
        entryAssets
    };
}
const generatePreloadAssetsPlugin = function() {
    return {
        name: 'generate-preload-assets-plugin',
        async generatePreloadAssets (args) {
            const { origin, preloadOptions, remoteInfo, remote, globalSnapshot, remoteSnapshot } = args;
            if (share.isRemoteInfoWithEntry(remote) && share.isPureRemoteEntry(remote)) {
                return {
                    cssAssets: [],
                    jsAssetsWithoutEntry: [],
                    entryAssets: [
                        {
                            name: remote.name,
                            url: remote.entry,
                            moduleInfo: {
                                name: remoteInfo.name,
                                entry: remote.entry,
                                type: 'global',
                                entryGlobalName: '',
                                shareScope: ''
                            }
                        }
                    ]
                };
            }
            assignRemoteInfo(remoteInfo, remoteSnapshot);
            const assets = generatePreloadAssets(origin, preloadOptions, remoteInfo, globalSnapshot, remoteSnapshot);
            return assets;
        }
    };
};
function getGlobalRemoteInfo(moduleInfo, origin) {
    const hostGlobalSnapshot = share.getGlobalSnapshotInfoByModuleInfo({
        name: origin.options.name,
        version: origin.options.version
    });
    // get remote detail info from global
    const globalRemoteInfo = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && share.getInfoWithoutType(hostGlobalSnapshot.remotesInfo, moduleInfo.name).value;
    if (globalRemoteInfo && globalRemoteInfo.matchedVersion) {
        return {
            hostGlobalSnapshot,
            globalSnapshot: share.getGlobalSnapshot(),
            remoteSnapshot: share.getGlobalSnapshotInfoByModuleInfo({
                name: moduleInfo.name,
                version: globalRemoteInfo.matchedVersion
            })
        };
    }
    return {
        hostGlobalSnapshot: undefined,
        globalSnapshot: share.getGlobalSnapshot(),
        remoteSnapshot: share.getGlobalSnapshotInfoByModuleInfo({
            name: moduleInfo.name,
            version: 'version' in moduleInfo ? moduleInfo.version : undefined
        })
    };
}
class SnapshotHandler {
    async loadSnapshot(moduleInfo) {
        const { options } = this.HostInstance;
        const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } = this.getGlobalRemoteInfo(moduleInfo);
        const { remoteSnapshot: globalRemoteSnapshot, globalSnapshot: globalSnapshotRes } = await this.hooks.lifecycle.loadSnapshot.emit({
            options,
            moduleInfo,
            hostGlobalSnapshot,
            remoteSnapshot,
            globalSnapshot
        });
        return {
            remoteSnapshot: globalRemoteSnapshot,
            globalSnapshot: globalSnapshotRes
        };
    }
    // eslint-disable-next-line max-lines-per-function
    async loadRemoteSnapshotInfo(moduleInfo) {
        const { options } = this.HostInstance;
        await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({
            options,
            moduleInfo
        });
        let hostSnapshot = share.getGlobalSnapshotInfoByModuleInfo({
            name: this.HostInstance.options.name,
            version: this.HostInstance.options.version
        });
        if (!hostSnapshot) {
            hostSnapshot = {
                version: this.HostInstance.options.version || '',
                remoteEntry: '',
                remotesInfo: {}
            };
            share.addGlobalSnapshot({
                [this.HostInstance.options.name]: hostSnapshot
            });
        }
        // In dynamic loadRemote scenarios, incomplete remotesInfo delivery may occur. In such cases, the remotesInfo in the host needs to be completed in the snapshot at runtime.
        // This ensures the snapshot's integrity and helps the chrome plugin correctly identify all producer modules, ensuring that proxyable producer modules will not be missing.
        if (hostSnapshot && 'remotesInfo' in hostSnapshot && !share.getInfoWithoutType(hostSnapshot.remotesInfo, moduleInfo.name).value) {
            if ('version' in moduleInfo || 'entry' in moduleInfo) {
                hostSnapshot.remotesInfo = polyfills._extends({}, hostSnapshot == null ? void 0 : hostSnapshot.remotesInfo, {
                    [moduleInfo.name]: {
                        matchedVersion: 'version' in moduleInfo ? moduleInfo.version : moduleInfo.entry
                    }
                });
            }
        }
        const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } = this.getGlobalRemoteInfo(moduleInfo);
        const { remoteSnapshot: globalRemoteSnapshot, globalSnapshot: globalSnapshotRes } = await this.hooks.lifecycle.loadSnapshot.emit({
            options,
            moduleInfo,
            hostGlobalSnapshot,
            remoteSnapshot,
            globalSnapshot
        });
        // global snapshot includes manifest or module info includes manifest
        if (globalRemoteSnapshot) {
            if (sdk.isManifestProvider(globalRemoteSnapshot)) {
                const remoteEntry = sdk.isBrowserEnv() ? globalRemoteSnapshot.remoteEntry : globalRemoteSnapshot.ssrRemoteEntry || globalRemoteSnapshot.remoteEntry || '';
                const moduleSnapshot = await this.getManifestJson(remoteEntry, moduleInfo, {});
                // eslint-disable-next-line @typescript-eslint/no-shadow
                const globalSnapshotRes = share.setGlobalSnapshotInfoByModuleInfo(polyfills._extends({}, moduleInfo, {
                    // The global remote may be overridden
                    // Therefore, set the snapshot key to the global address of the actual request
                    entry: remoteEntry
                }), moduleSnapshot);
                return {
                    remoteSnapshot: moduleSnapshot,
                    globalSnapshot: globalSnapshotRes
                };
            } else {
                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                    options: this.HostInstance.options,
                    moduleInfo,
                    remoteSnapshot: globalRemoteSnapshot,
                    from: 'global'
                });
                return {
                    remoteSnapshot: remoteSnapshotRes,
                    globalSnapshot: globalSnapshotRes
                };
            }
        } else {
            if (share.isRemoteInfoWithEntry(moduleInfo)) {
                // get from manifest.json and merge remote info from remote server
                const moduleSnapshot = await this.getManifestJson(moduleInfo.entry, moduleInfo, {});
                // eslint-disable-next-line @typescript-eslint/no-shadow
                const globalSnapshotRes = share.setGlobalSnapshotInfoByModuleInfo(moduleInfo, moduleSnapshot);
                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                    options: this.HostInstance.options,
                    moduleInfo,
                    remoteSnapshot: moduleSnapshot,
                    from: 'global'
                });
                return {
                    remoteSnapshot: remoteSnapshotRes,
                    globalSnapshot: globalSnapshotRes
                };
            } else {
                share.error(`
          Cannot get remoteSnapshot with the name: '${moduleInfo.name}', version: '${moduleInfo.version}' from __FEDERATION__.moduleInfo. The following reasons may be causing the problem:\n
          1. The Deploy platform did not deliver the correct data. You can use __FEDERATION__.moduleInfo to check the remoteInfo.\n
          2. The remote '${moduleInfo.name}' version '${moduleInfo.version}' is not released.\n
          The transformed module info: ${JSON.stringify(globalSnapshotRes)}
        `);
            }
        }
    }
    getGlobalRemoteInfo(moduleInfo) {
        return getGlobalRemoteInfo(moduleInfo, this.HostInstance);
    }
    async getManifestJson(manifestUrl, moduleInfo, extraOptions) {
        const getManifest = async ()=>{
            let manifestJson = this.manifestCache.get(manifestUrl);
            if (manifestJson) {
                return manifestJson;
            }
            try {
                let res = await this.loaderHook.lifecycle.fetch.emit(manifestUrl, {});
                if (!res || !(res instanceof Response)) {
                    res = await fetch(manifestUrl, {});
                }
                manifestJson = await res.json();
                share.assert(manifestJson.metaData && manifestJson.exposes && manifestJson.shared, `${manifestUrl} is not a federation manifest`);
                this.manifestCache.set(manifestUrl, manifestJson);
                return manifestJson;
            } catch (err) {
                delete this.manifestLoading[manifestUrl];
                share.error(`Failed to get manifestJson for ${moduleInfo.name}. The manifest URL is ${manifestUrl}. Please ensure that the manifestUrl is accessible.
          \n Error message:
          \n ${err}`);
            }
        };
        const asyncLoadProcess = async ()=>{
            const manifestJson = await getManifest();
            const remoteSnapshot = sdk.generateSnapshotFromManifest(manifestJson, {
                version: manifestUrl
            });
            const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                options: this.HostInstance.options,
                moduleInfo,
                manifestJson,
                remoteSnapshot,
                manifestUrl,
                from: 'manifest'
            });
            return remoteSnapshotRes;
        };
        if (!this.manifestLoading[manifestUrl]) {
            this.manifestLoading[manifestUrl] = asyncLoadProcess().then((res)=>res);
        }
        return this.manifestLoading[manifestUrl];
    }
    constructor(HostInstance){
        this.loadingHostSnapshot = null;
        this.manifestCache = new Map();
        this.hooks = new PluginSystem({
            beforeLoadRemoteSnapshot: new AsyncHook('beforeLoadRemoteSnapshot'),
            loadSnapshot: new AsyncWaterfallHook('loadGlobalSnapshot'),
            loadRemoteSnapshot: new AsyncWaterfallHook('loadRemoteSnapshot')
        });
        this.manifestLoading = share.Global.__FEDERATION__.__MANIFEST_LOADING__;
        this.HostInstance = HostInstance;
        this.loaderHook = HostInstance.loaderHook;
    }
}
class SharedHandler {
    // register shared in shareScopeMap
    registerShared(globalOptions, userOptions) {
        const { shareInfos, shared } = share.formatShareConfigs(globalOptions, userOptions);
        const sharedKeys = Object.keys(shareInfos);
        sharedKeys.forEach((sharedKey)=>{
            const sharedVals = shareInfos[sharedKey];
            sharedVals.forEach((sharedVal)=>{
                const registeredShared = share.getRegisteredShare(this.shareScopeMap, sharedKey, sharedVal, this.hooks.lifecycle.resolveShare);
                if (!registeredShared && sharedVal && sharedVal.lib) {
                    this.setShared({
                        pkgName: sharedKey,
                        lib: sharedVal.lib,
                        get: sharedVal.get,
                        loaded: true,
                        shared: sharedVal,
                        from: userOptions.name
                    });
                }
            });
        });
        return {
            shareInfos,
            shared
        };
    }
    async loadShare(pkgName, extraOptions) {
        const { host } = this;
        // This function performs the following steps:
        // 1. Checks if the currently loaded share already exists, if not, it throws an error
        // 2. Searches globally for a matching share, if found, it uses it directly
        // 3. If not found, it retrieves it from the current share and stores the obtained share globally.
        const shareInfo = share.getTargetSharedOptions({
            pkgName,
            extraOptions,
            shareInfos: host.options.shared
        });
        if (shareInfo == null ? void 0 : shareInfo.scope) {
            await Promise.all(shareInfo.scope.map(async (shareScope)=>{
                await Promise.all(this.initializeSharing(shareScope, {
                    strategy: shareInfo.strategy
                }));
                return;
            }));
        }
        const loadShareRes = await this.hooks.lifecycle.beforeLoadShare.emit({
            pkgName,
            shareInfo,
            shared: host.options.shared,
            origin: host
        });
        const { shareInfo: shareInfoRes } = loadShareRes;
        // Assert that shareInfoRes exists, if not, throw an error
        share.assert(shareInfoRes, `Cannot find ${pkgName} Share in the ${host.options.name}. Please ensure that the ${pkgName} Share parameters have been injected`);
        // Retrieve from cache
        const registeredShared = share.getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
        const addUseIn = (shared)=>{
            if (!shared.useIn) {
                shared.useIn = [];
            }
            share.addUniqueItem(shared.useIn, host.options.name);
        };
        if (registeredShared && registeredShared.lib) {
            addUseIn(registeredShared);
            return registeredShared.lib;
        } else if (registeredShared && registeredShared.loading && !registeredShared.loaded) {
            const factory = await registeredShared.loading;
            registeredShared.loaded = true;
            if (!registeredShared.lib) {
                registeredShared.lib = factory;
            }
            addUseIn(registeredShared);
            return factory;
        } else if (registeredShared) {
            const asyncLoadProcess = async ()=>{
                const factory = await registeredShared.get();
                shareInfoRes.lib = factory;
                shareInfoRes.loaded = true;
                addUseIn(shareInfoRes);
                const gShared = share.getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
                if (gShared) {
                    gShared.lib = factory;
                    gShared.loaded = true;
                }
                return factory;
            };
            const loading = asyncLoadProcess();
            this.setShared({
                pkgName,
                loaded: false,
                shared: registeredShared,
                from: host.options.name,
                lib: null,
                loading
            });
            return loading;
        } else {
            if (extraOptions == null ? void 0 : extraOptions.customShareInfo) {
                return false;
            }
            const asyncLoadProcess = async ()=>{
                const factory = await shareInfoRes.get();
                shareInfoRes.lib = factory;
                shareInfoRes.loaded = true;
                addUseIn(shareInfoRes);
                const gShared = share.getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
                if (gShared) {
                    gShared.lib = factory;
                    gShared.loaded = true;
                }
                return factory;
            };
            const loading = asyncLoadProcess();
            this.setShared({
                pkgName,
                loaded: false,
                shared: shareInfoRes,
                from: host.options.name,
                lib: null,
                loading
            });
            return loading;
        }
    }
    /**
   * This function initializes the sharing sequence (executed only once per share scope).
   * It accepts one argument, the name of the share scope.
   * If the share scope does not exist, it creates one.
   */ // eslint-disable-next-line @typescript-eslint/member-ordering
    initializeSharing(shareScopeName = share.DEFAULT_SCOPE, extraOptions) {
        const { host } = this;
        const from = extraOptions == null ? void 0 : extraOptions.from;
        const strategy = extraOptions == null ? void 0 : extraOptions.strategy;
        let initScope = extraOptions == null ? void 0 : extraOptions.initScope;
        const promises = [];
        if (from !== 'build') {
            const { initTokens } = this;
            if (!initScope) initScope = [];
            let initToken = initTokens[shareScopeName];
            if (!initToken) initToken = initTokens[shareScopeName] = {
                from: this.host.name
            };
            if (initScope.indexOf(initToken) >= 0) return promises;
            initScope.push(initToken);
        }
        const shareScope = this.shareScopeMap;
        const hostName = host.options.name;
        // Creates a new share scope if necessary
        if (!shareScope[shareScopeName]) {
            shareScope[shareScopeName] = {};
        }
        // Executes all initialization snippets from all accessible modules
        const scope = shareScope[shareScopeName];
        const register = (name, shared)=>{
            var _activeVersion_shareConfig;
            const { version, eager } = shared;
            scope[name] = scope[name] || {};
            const versions = scope[name];
            const activeVersion = versions[version];
            const activeVersionEager = Boolean(activeVersion && (activeVersion.eager || ((_activeVersion_shareConfig = activeVersion.shareConfig) == null ? void 0 : _activeVersion_shareConfig.eager)));
            if (!activeVersion || activeVersion.strategy !== 'loaded-first' && !activeVersion.loaded && (Boolean(!eager) !== !activeVersionEager ? eager : hostName > activeVersion.from)) {
                versions[version] = shared;
            }
        };
        const initFn = (mod)=>mod && mod.init && mod.init(shareScope[shareScopeName], initScope);
        const initRemoteModule = async (key)=>{
            const { module } = await host.remoteHandler.getRemoteModuleAndOptions({
                id: key
            });
            if (module.getEntry) {
                const entry = await module.getEntry();
                if (!module.inited) {
                    await initFn(entry);
                    module.inited = true;
                }
            }
        };
        Object.keys(host.options.shared).forEach((shareName)=>{
            const sharedArr = host.options.shared[shareName];
            sharedArr.forEach((shared)=>{
                if (shared.scope.includes(shareScopeName)) {
                    register(shareName, shared);
                }
            });
        });
        // TODO: strategy==='version-first' need to be removed in the future
        if (host.options.shareStrategy === 'version-first' || strategy === 'version-first') {
            host.options.remotes.forEach((remote)=>{
                if (remote.shareScope === shareScopeName) {
                    promises.push(initRemoteModule(remote.name));
                }
            });
        }
        return promises;
    }
    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.
    // 1. If the loaded shared already exists globally, then it will be reused
    // 2. If lib exists in local shared, it will be used directly
    // 3. If the local get returns something other than Promise, then it will be used directly
    loadShareSync(pkgName, extraOptions) {
        const { host } = this;
        const shareInfo = share.getTargetSharedOptions({
            pkgName,
            extraOptions,
            shareInfos: host.options.shared
        });
        if (shareInfo == null ? void 0 : shareInfo.scope) {
            shareInfo.scope.forEach((shareScope)=>{
                this.initializeSharing(shareScope, {
                    strategy: shareInfo.strategy
                });
            });
        }
        const registeredShared = share.getRegisteredShare(this.shareScopeMap, pkgName, shareInfo, this.hooks.lifecycle.resolveShare);
        const addUseIn = (shared)=>{
            if (!shared.useIn) {
                shared.useIn = [];
            }
            share.addUniqueItem(shared.useIn, host.options.name);
        };
        if (registeredShared) {
            if (typeof registeredShared.lib === 'function') {
                addUseIn(registeredShared);
                if (!registeredShared.loaded) {
                    registeredShared.loaded = true;
                    if (registeredShared.from === host.options.name) {
                        shareInfo.loaded = true;
                    }
                }
                return registeredShared.lib;
            }
            if (typeof registeredShared.get === 'function') {
                const module = registeredShared.get();
                if (!(module instanceof Promise)) {
                    addUseIn(registeredShared);
                    this.setShared({
                        pkgName,
                        loaded: true,
                        from: host.options.name,
                        lib: module,
                        shared: registeredShared
                    });
                    return module;
                }
            }
        }
        if (shareInfo.lib) {
            if (!shareInfo.loaded) {
                shareInfo.loaded = true;
            }
            return shareInfo.lib;
        }
        if (shareInfo.get) {
            const module = shareInfo.get();
            if (module instanceof Promise) {
                throw new Error(`
        The loadShareSync function was unable to load ${pkgName}. The ${pkgName} could not be found in ${host.options.name}.
        Possible reasons for failure: \n
        1. The ${pkgName} share was registered with the 'get' attribute, but loadShare was not used beforehand.\n
        2. The ${pkgName} share was not registered with the 'lib' attribute.\n
      `);
            }
            shareInfo.lib = module;
            this.setShared({
                pkgName,
                loaded: true,
                from: host.options.name,
                lib: shareInfo.lib,
                shared: shareInfo
            });
            return shareInfo.lib;
        }
        throw new Error(`
        The loadShareSync function was unable to load ${pkgName}. The ${pkgName} could not be found in ${host.options.name}.
        Possible reasons for failure: \n
        1. The ${pkgName} share was registered with the 'get' attribute, but loadShare was not used beforehand.\n
        2. The ${pkgName} share was not registered with the 'lib' attribute.\n
      `);
    }
    initShareScopeMap(scopeName, shareScope, extraOptions = {}) {
        const { host } = this;
        this.shareScopeMap[scopeName] = shareScope;
        this.hooks.lifecycle.initContainerShareScopeMap.emit({
            shareScope,
            options: host.options,
            origin: host,
            scopeName,
            hostShareScopeMap: extraOptions.hostShareScopeMap
        });
    }
    setShared({ pkgName, shared, from, lib, loading, loaded, get }) {
        const { version, scope = 'default' } = shared, shareInfo = polyfills._object_without_properties_loose(shared, [
            "version",
            "scope"
        ]);
        const scopes = Array.isArray(scope) ? scope : [
            scope
        ];
        scopes.forEach((sc)=>{
            if (!this.shareScopeMap[sc]) {
                this.shareScopeMap[sc] = {};
            }
            if (!this.shareScopeMap[sc][pkgName]) {
                this.shareScopeMap[sc][pkgName] = {};
            }
            if (!this.shareScopeMap[sc][pkgName][version]) {
                this.shareScopeMap[sc][pkgName][version] = polyfills._extends({
                    version,
                    scope: [
                        'default'
                    ]
                }, shareInfo, {
                    lib,
                    loaded,
                    loading
                });
                if (get) {
                    this.shareScopeMap[sc][pkgName][version].get = get;
                }
                return;
            }
            const registeredShared = this.shareScopeMap[sc][pkgName][version];
            if (loading && !registeredShared.loading) {
                registeredShared.loading = loading;
            }
        });
    }
    _setGlobalShareScopeMap(hostOptions) {
        const globalShareScopeMap = share.getGlobalShareScope();
        const identifier = hostOptions.id || hostOptions.name;
        if (identifier && !globalShareScopeMap[identifier]) {
            globalShareScopeMap[identifier] = this.shareScopeMap;
        }
    }
    constructor(host){
        this.hooks = new PluginSystem({
            afterResolve: new AsyncWaterfallHook('afterResolve'),
            beforeLoadShare: new AsyncWaterfallHook('beforeLoadShare'),
            // not used yet
            loadShare: new AsyncHook(),
            resolveShare: new SyncWaterfallHook('resolveShare'),
            // maybe will change, temporarily for internal use only
            initContainerShareScopeMap: new SyncWaterfallHook('initContainerShareScopeMap')
        });
        this.host = host;
        this.shareScopeMap = {};
        this.initTokens = {};
        this._setGlobalShareScopeMap(host.options);
    }
}
class RemoteHandler {
    formatAndRegisterRemote(globalOptions, userOptions) {
        const userRemotes = userOptions.remotes || [];
        return userRemotes.reduce((res, remote)=>{
            this.registerRemote(remote, res, {
                force: false
            });
            return res;
        }, globalOptions.remotes);
    }
    setIdToRemoteMap(id, remoteMatchInfo) {
        const { remote, expose } = remoteMatchInfo;
        const { name, alias } = remote;
        this.idToRemoteMap[id] = {
            name: remote.name,
            expose
        };
        if (alias && id.startsWith(name)) {
            const idWithAlias = id.replace(name, alias);
            this.idToRemoteMap[idWithAlias] = {
                name: remote.name,
                expose
            };
            return;
        }
        if (alias && id.startsWith(alias)) {
            const idWithName = id.replace(alias, name);
            this.idToRemoteMap[idWithName] = {
                name: remote.name,
                expose
            };
        }
    }
    // eslint-disable-next-line max-lines-per-function
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async loadRemote(id, options) {
        const { host } = this;
        try {
            const { loadFactory = true } = options || {
                loadFactory: true
            };
            // 1. Validate the parameters of the retrieved module. There are two module request methods: pkgName + expose and alias + expose.
            // 2. Request the snapshot information of the current host and globally store the obtained snapshot information. The retrieved module information is partially offline and partially online. The online module information will retrieve the modules used online.
            // 3. Retrieve the detailed information of the current module from global (remoteEntry address, expose resource address)
            // 4. After retrieving remoteEntry, call the init of the module, and then retrieve the exported content of the module through get
            // id: pkgName(@federation/app1) + expose(button) = @federation/app1/button
            // id: alias(app1) + expose(button) = app1/button
            // id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort
            const { module, moduleOptions, remoteMatchInfo } = await this.getRemoteModuleAndOptions({
                id
            });
            const { pkgNameOrAlias, remote, expose, id: idRes, remoteSnapshot } = remoteMatchInfo;
            const moduleOrFactory = await module.get(idRes, expose, options, remoteSnapshot);
            const moduleWrapper = await this.hooks.lifecycle.onLoad.emit({
                id: idRes,
                pkgNameOrAlias,
                expose,
                exposeModule: loadFactory ? moduleOrFactory : undefined,
                exposeModuleFactory: loadFactory ? undefined : moduleOrFactory,
                remote,
                options: moduleOptions,
                moduleInstance: module,
                origin: host
            });
            this.setIdToRemoteMap(id, remoteMatchInfo);
            if (typeof moduleWrapper === 'function') {
                return moduleWrapper;
            }
            return moduleOrFactory;
        } catch (error) {
            const { from = 'runtime' } = options || {
                from: 'runtime'
            };
            const failOver = await this.hooks.lifecycle.errorLoadRemote.emit({
                id,
                error,
                from,
                lifecycle: 'onLoad',
                origin: host
            });
            if (!failOver) {
                throw error;
            }
            return failOver;
        }
    }
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async preloadRemote(preloadOptions) {
        const { host } = this;
        await this.hooks.lifecycle.beforePreloadRemote.emit({
            preloadOps: preloadOptions,
            options: host.options,
            origin: host
        });
        const preloadOps = formatPreloadArgs(host.options.remotes, preloadOptions);
        await Promise.all(preloadOps.map(async (ops)=>{
            const { remote } = ops;
            const remoteInfo = getRemoteInfo(remote);
            const { globalSnapshot, remoteSnapshot } = await host.snapshotHandler.loadRemoteSnapshotInfo(remote);
            const assets = await this.hooks.lifecycle.generatePreloadAssets.emit({
                origin: host,
                preloadOptions: ops,
                remote,
                remoteInfo,
                globalSnapshot,
                remoteSnapshot
            });
            if (!assets) {
                return;
            }
            preloadAssets(remoteInfo, host, assets);
        }));
    }
    registerRemotes(remotes, options) {
        const { host } = this;
        remotes.forEach((remote)=>{
            this.registerRemote(remote, host.options.remotes, {
                force: options == null ? void 0 : options.force
            });
        });
    }
    async getRemoteModuleAndOptions(options) {
        const { host } = this;
        const { id } = options;
        let loadRemoteArgs;
        try {
            loadRemoteArgs = await this.hooks.lifecycle.beforeRequest.emit({
                id,
                options: host.options,
                origin: host
            });
        } catch (error) {
            loadRemoteArgs = await this.hooks.lifecycle.errorLoadRemote.emit({
                id,
                options: host.options,
                origin: host,
                from: 'runtime',
                error,
                lifecycle: 'beforeRequest'
            });
            if (!loadRemoteArgs) {
                throw error;
            }
        }
        const { id: idRes } = loadRemoteArgs;
        const remoteSplitInfo = matchRemoteWithNameAndExpose(host.options.remotes, idRes);
        share.assert(remoteSplitInfo, `
        Unable to locate ${idRes} in ${host.options.name}. Potential reasons for failure include:\n
        1. ${idRes} was not included in the 'remotes' parameter of ${host.options.name || 'the host'}.\n
        2. ${idRes} could not be found in the 'remotes' of ${host.options.name} with either 'name' or 'alias' attributes.
        3. ${idRes} is not online, injected, or loaded.
        4. ${idRes}  cannot be accessed on the expected.
        5. The 'beforeRequest' hook was provided but did not return the correct 'remoteInfo' when attempting to load ${idRes}.
      `);
        const { remote: rawRemote } = remoteSplitInfo;
        const remoteInfo = getRemoteInfo(rawRemote);
        const matchInfo = await host.sharedHandler.hooks.lifecycle.afterResolve.emit(polyfills._extends({
            id: idRes
        }, remoteSplitInfo, {
            options: host.options,
            origin: host,
            remoteInfo
        }));
        const { remote, expose } = matchInfo;
        share.assert(remote && expose, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${idRes}.`);
        let module = host.moduleCache.get(remote.name);
        const moduleOptions = {
            host: host,
            remoteInfo
        };
        if (!module) {
            module = new Module(moduleOptions);
            host.moduleCache.set(remote.name, module);
        }
        return {
            module,
            moduleOptions,
            remoteMatchInfo: matchInfo
        };
    }
    registerRemote(remote, targetRemotes, options) {
        const { host } = this;
        const normalizeRemote = ()=>{
            if (remote.alias) {
                // Validate if alias equals the prefix of remote.name and remote.alias, if so, throw an error
                // As multi-level path references cannot guarantee unique names, alias being a prefix of remote.name is not supported
                const findEqual = targetRemotes.find((item)=>{
                    var _item_alias;
                    return remote.alias && (item.name.startsWith(remote.alias) || ((_item_alias = item.alias) == null ? void 0 : _item_alias.startsWith(remote.alias)));
                });
                share.assert(!findEqual, `The alias ${remote.alias} of remote ${remote.name} is not allowed to be the prefix of ${findEqual && findEqual.name} name or alias`);
            }
            // Set the remote entry to a complete path
            if ('entry' in remote) {
                if (sdk.isBrowserEnv() && !remote.entry.startsWith('http')) {
                    remote.entry = new URL(remote.entry, window.location.origin).href;
                }
            }
            if (!remote.shareScope) {
                remote.shareScope = share.DEFAULT_SCOPE;
            }
            if (!remote.type) {
                remote.type = share.DEFAULT_REMOTE_TYPE;
            }
        };
        this.hooks.lifecycle.beforeRegisterRemote.emit({
            remote,
            origin: host
        });
        const registeredRemote = targetRemotes.find((item)=>item.name === remote.name);
        if (!registeredRemote) {
            normalizeRemote();
            targetRemotes.push(remote);
            this.hooks.lifecycle.registerRemote.emit({
                remote,
                origin: host
            });
        } else {
            const messages = [
                `The remote "${remote.name}" is already registered.`,
                (options == null ? void 0 : options.force) ? 'Hope you have known that OVERRIDE it may have some unexpected errors' : 'If you want to merge the remote, you can set "force: true".'
            ];
            if (options == null ? void 0 : options.force) {
                // remove registered remote
                this.removeRemote(registeredRemote);
                normalizeRemote();
                targetRemotes.push(remote);
                this.hooks.lifecycle.registerRemote.emit({
                    remote,
                    origin: host
                });
            }
            sdk.warn(messages.join(' '));
        }
    }
    removeRemote(remote) {
        try {
            const { host } = this;
            const { name } = remote;
            const remoteIndex = host.options.remotes.findIndex((item)=>item.name === name);
            if (remoteIndex !== -1) {
                host.options.remotes.splice(remoteIndex, 1);
            }
            const loadedModule = host.moduleCache.get(remote.name);
            if (loadedModule) {
                const remoteInfo = loadedModule.remoteInfo;
                const key = remoteInfo.entryGlobalName;
                if (globalThis[key]) {
                    var _Object_getOwnPropertyDescriptor;
                    if ((_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(globalThis, key)) == null ? void 0 : _Object_getOwnPropertyDescriptor.configurable) {
                        delete globalThis[key];
                    } else {
                        // @ts-ignore
                        globalThis[key] = undefined;
                    }
                }
                const remoteEntryUniqueKey = getRemoteEntryUniqueKey(loadedModule.remoteInfo);
                if (share.globalLoading[remoteEntryUniqueKey]) {
                    delete share.globalLoading[remoteEntryUniqueKey];
                }
                host.snapshotHandler.manifestCache.delete(remoteInfo.entry);
                // delete unloaded shared and instance
                let remoteInsId = remoteInfo.buildVersion ? sdk.composeKeyWithSeparator(remoteInfo.name, remoteInfo.buildVersion) : remoteInfo.name;
                const remoteInsIndex = globalThis.__FEDERATION__.__INSTANCES__.findIndex((ins)=>{
                    if (remoteInfo.buildVersion) {
                        return ins.options.id === remoteInsId;
                    } else {
                        return ins.name === remoteInsId;
                    }
                });
                if (remoteInsIndex !== -1) {
                    const remoteIns = globalThis.__FEDERATION__.__INSTANCES__[remoteInsIndex];
                    remoteInsId = remoteIns.options.id || remoteInsId;
                    const globalShareScopeMap = share.getGlobalShareScope();
                    let isAllSharedNotUsed = true;
                    const needDeleteKeys = [];
                    Object.keys(globalShareScopeMap).forEach((instId)=>{
                        const shareScopeMap = globalShareScopeMap[instId];
                        shareScopeMap && Object.keys(shareScopeMap).forEach((shareScope)=>{
                            const shareScopeVal = shareScopeMap[shareScope];
                            shareScopeVal && Object.keys(shareScopeVal).forEach((shareName)=>{
                                const sharedPkgs = shareScopeVal[shareName];
                                sharedPkgs && Object.keys(sharedPkgs).forEach((shareVersion)=>{
                                    const shared = sharedPkgs[shareVersion];
                                    if (shared && typeof shared === 'object' && shared.from === remoteInfo.name) {
                                        if (shared.loaded || shared.loading) {
                                            shared.useIn = shared.useIn.filter((usedHostName)=>usedHostName !== remoteInfo.name);
                                            if (shared.useIn.length) {
                                                isAllSharedNotUsed = false;
                                            } else {
                                                needDeleteKeys.push([
                                                    instId,
                                                    shareScope,
                                                    shareName,
                                                    shareVersion
                                                ]);
                                            }
                                        } else {
                                            needDeleteKeys.push([
                                                instId,
                                                shareScope,
                                                shareName,
                                                shareVersion
                                            ]);
                                        }
                                    }
                                });
                            });
                        });
                    });
                    if (isAllSharedNotUsed) {
                        remoteIns.shareScopeMap = {};
                        delete globalShareScopeMap[remoteInsId];
                    }
                    needDeleteKeys.forEach(([insId, shareScope, shareName, shareVersion])=>{
                        var _globalShareScopeMap_insId_shareScope_shareName, _globalShareScopeMap_insId_shareScope, _globalShareScopeMap_insId;
                        (_globalShareScopeMap_insId = globalShareScopeMap[insId]) == null ? true : (_globalShareScopeMap_insId_shareScope = _globalShareScopeMap_insId[shareScope]) == null ? true : (_globalShareScopeMap_insId_shareScope_shareName = _globalShareScopeMap_insId_shareScope[shareName]) == null ? true : delete _globalShareScopeMap_insId_shareScope_shareName[shareVersion];
                    });
                    globalThis.__FEDERATION__.__INSTANCES__.splice(remoteInsIndex, 1);
                }
                const { hostGlobalSnapshot } = getGlobalRemoteInfo(remote, host);
                if (hostGlobalSnapshot) {
                    const remoteKey = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && share.getInfoWithoutType(hostGlobalSnapshot.remotesInfo, remote.name).key;
                    if (remoteKey) {
                        delete hostGlobalSnapshot.remotesInfo[remoteKey];
                        if (Boolean(share.Global.__FEDERATION__.__MANIFEST_LOADING__[remoteKey])) {
                            delete share.Global.__FEDERATION__.__MANIFEST_LOADING__[remoteKey];
                        }
                    }
                }
                host.moduleCache.delete(remote.name);
            }
        } catch (err) {
            console.log('removeRemote fail: ', err);
        }
    }
    constructor(host){
        this.hooks = new PluginSystem({
            beforeRegisterRemote: new SyncWaterfallHook('beforeRegisterRemote'),
            registerRemote: new SyncWaterfallHook('registerRemote'),
            beforeRequest: new AsyncWaterfallHook('beforeRequest'),
            onLoad: new AsyncHook('onLoad'),
            handlePreloadModule: new SyncHook('handlePreloadModule'),
            errorLoadRemote: new AsyncHook('errorLoadRemote'),
            beforePreloadRemote: new AsyncHook('beforePreloadRemote'),
            generatePreloadAssets: new AsyncHook('generatePreloadAssets'),
            // not used yet
            afterPreloadRemote: new AsyncHook(),
            loadEntry: new AsyncHook()
        });
        this.host = host;
        this.idToRemoteMap = {};
    }
}
class FederationHost {
    initOptions(userOptions) {
        this.registerPlugins(userOptions.plugins);
        const options = this.formatOptions(this.options, userOptions);
        this.options = options;
        return options;
    }
    async loadShare(pkgName, extraOptions) {
        return this.sharedHandler.loadShare(pkgName, extraOptions);
    }
    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.
    // 1. If the loaded shared already exists globally, then it will be reused
    // 2. If lib exists in local shared, it will be used directly
    // 3. If the local get returns something other than Promise, then it will be used directly
    loadShareSync(pkgName, extraOptions) {
        return this.sharedHandler.loadShareSync(pkgName, extraOptions);
    }
    initializeSharing(shareScopeName = share.DEFAULT_SCOPE, extraOptions) {
        return this.sharedHandler.initializeSharing(shareScopeName, extraOptions);
    }
    initRawContainer(name, url, container) {
        const remoteInfo = getRemoteInfo({
            name,
            entry: url
        });
        const module = new Module({
            host: this,
            remoteInfo
        });
        module.remoteEntryExports = container;
        this.moduleCache.set(name, module);
        return module;
    }
    // eslint-disable-next-line max-lines-per-function
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async loadRemote(id, options) {
        return this.remoteHandler.loadRemote(id, options);
    }
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async preloadRemote(preloadOptions) {
        return this.remoteHandler.preloadRemote(preloadOptions);
    }
    initShareScopeMap(scopeName, shareScope, extraOptions = {}) {
        this.sharedHandler.initShareScopeMap(scopeName, shareScope, extraOptions);
    }
    formatOptions(globalOptions, userOptions) {
        const { shared } = share.formatShareConfigs(globalOptions, userOptions);
        const { userOptions: userOptionsRes, options: globalOptionsRes } = this.hooks.lifecycle.beforeInit.emit({
            origin: this,
            userOptions,
            options: globalOptions,
            shareInfo: shared
        });
        const remotes = this.remoteHandler.formatAndRegisterRemote(globalOptionsRes, userOptionsRes);
        const { shared: handledShared } = this.sharedHandler.registerShared(globalOptionsRes, userOptionsRes);
        const plugins = [
            ...globalOptionsRes.plugins
        ];
        if (userOptionsRes.plugins) {
            userOptionsRes.plugins.forEach((plugin)=>{
                if (!plugins.includes(plugin)) {
                    plugins.push(plugin);
                }
            });
        }
        const optionsRes = polyfills._extends({}, globalOptions, userOptions, {
            plugins,
            remotes,
            shared: handledShared
        });
        this.hooks.lifecycle.init.emit({
            origin: this,
            options: optionsRes
        });
        return optionsRes;
    }
    registerPlugins(plugins) {
        const pluginRes = registerPlugins$1(plugins, [
            this.hooks,
            this.remoteHandler.hooks,
            this.sharedHandler.hooks,
            this.snapshotHandler.hooks,
            this.loaderHook
        ]);
        // Merge plugin
        this.options.plugins = this.options.plugins.reduce((res, plugin)=>{
            if (!plugin) return res;
            if (res && !res.find((item)=>item.name === plugin.name)) {
                res.push(plugin);
            }
            return res;
        }, pluginRes || []);
    }
    registerRemotes(remotes, options) {
        return this.remoteHandler.registerRemotes(remotes, options);
    }
    constructor(userOptions){
        this.hooks = new PluginSystem({
            beforeInit: new SyncWaterfallHook('beforeInit'),
            init: new SyncHook(),
            // maybe will change, temporarily for internal use only
            beforeInitContainer: new AsyncWaterfallHook('beforeInitContainer'),
            // maybe will change, temporarily for internal use only
            initContainer: new AsyncWaterfallHook('initContainer')
        });
        this.version = "0.6.4";
        this.moduleCache = new Map();
        this.loaderHook = new PluginSystem({
            // FIXME: may not be suitable , not open to the public yet
            getModuleInfo: new SyncHook(),
            createScript: new SyncHook(),
            createLink: new SyncHook(),
            // only work for manifest , so not open to the public yet
            fetch: new AsyncHook()
        });
        // TODO: Validate the details of the options
        // Initialize options with default values
        const defaultOptions = {
            id: share.getBuilderId(),
            name: userOptions.name,
            plugins: [
                snapshotPlugin(),
                generatePreloadAssetsPlugin()
            ],
            remotes: [],
            shared: {},
            inBrowser: sdk.isBrowserEnv()
        };
        this.name = userOptions.name;
        this.options = defaultOptions;
        this.snapshotHandler = new SnapshotHandler(this);
        this.sharedHandler = new SharedHandler(this);
        this.remoteHandler = new RemoteHandler(this);
        this.shareScopeMap = this.sharedHandler.shareScopeMap;
        this.registerPlugins([
            ...defaultOptions.plugins,
            ...userOptions.plugins || []
        ]);
        this.options = this.formatOptions(defaultOptions, userOptions);
    }
}
let FederationInstance = null;
function init(options) {
    // Retrieve the same instance with the same name
    const instance = share.getGlobalFederationInstance(options.name, options.version);
    if (!instance) {
        // Retrieve debug constructor
        const FederationConstructor = share.getGlobalFederationConstructor() || FederationHost;
        FederationInstance = new FederationConstructor(options);
        share.setGlobalFederationInstance(FederationInstance);
        return FederationInstance;
    } else {
        // Merge options
        instance.initOptions(options);
        if (!FederationInstance) {
            FederationInstance = instance;
        }
        return instance;
    }
}
function loadRemote(...args) {
    share.assert(FederationInstance, 'Please call init first');
    const loadRemote1 = FederationInstance.loadRemote;
    // eslint-disable-next-line prefer-spread
    return loadRemote1.apply(FederationInstance, args);
}
function loadShare(...args) {
    share.assert(FederationInstance, 'Please call init first');
    // eslint-disable-next-line prefer-spread
    const loadShare1 = FederationInstance.loadShare;
    return loadShare1.apply(FederationInstance, args);
}
function loadShareSync(...args) {
    share.assert(FederationInstance, 'Please call init first');
    const loadShareSync1 = FederationInstance.loadShareSync;
    // eslint-disable-next-line prefer-spread
    return loadShareSync1.apply(FederationInstance, args);
}
function preloadRemote(...args) {
    share.assert(FederationInstance, 'Please call init first');
    // eslint-disable-next-line prefer-spread
    return FederationInstance.preloadRemote.apply(FederationInstance, args);
}
function registerRemotes(...args) {
    share.assert(FederationInstance, 'Please call init first');
    // eslint-disable-next-line prefer-spread
    return FederationInstance.registerRemotes.apply(FederationInstance, args);
}
function registerPlugins(...args) {
    share.assert(FederationInstance, 'Please call init first');
    // eslint-disable-next-line prefer-spread
    return FederationInstance.registerPlugins.apply(FederationInstance, args);
}
function getInstance() {
    return FederationInstance;
}
// Inject for debug
share.setGlobalFederationConstructor(FederationHost);
Object.defineProperty(exports, 'loadScript', {
    enumerable: true,
    get: function() {
        return sdk.loadScript;
    }
});
Object.defineProperty(exports, 'loadScriptNode', {
    enumerable: true,
    get: function() {
        return sdk.loadScriptNode;
    }
});
exports.registerGlobalPlugins = share.registerGlobalPlugins;
exports.FederationHost = FederationHost;
exports.Module = Module;
exports.getInstance = getInstance;
exports.getRemoteEntry = getRemoteEntry;
exports.getRemoteInfo = getRemoteInfo;
exports.init = init;
exports.loadRemote = loadRemote;
exports.loadShare = loadShare;
exports.loadShareSync = loadShareSync;
exports.preloadRemote = preloadRemote;
exports.registerPlugins = registerPlugins;
exports.registerRemotes = registerRemotes;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXRlZGFuY2UvV2Vic3Rvcm1Qcm9qZWN0cy91bml2ZXJzZS9wYWNrYWdlcy9ydW50aW1lL2Rpc3QvaW5kZXguY2pzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHBvbHlmaWxscyA9IHJlcXVpcmUoJy4vcG9seWZpbGxzLmNqcy5qcycpO1xudmFyIHNkayA9IHJlcXVpcmUoJ0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsnKTtcbnZhciBzaGFyZSA9IHJlcXVpcmUoJy4vc2hhcmUuY2pzLmpzJyk7XG5cbi8vIEZ1bmN0aW9uIHRvIG1hdGNoIGEgcmVtb3RlIHdpdGggaXRzIG5hbWUgYW5kIGV4cG9zZVxuLy8gaWQ6IHBrZ05hbWUoQGZlZGVyYXRpb24vYXBwMSkgKyBleHBvc2UoYnV0dG9uKSA9IEBmZWRlcmF0aW9uL2FwcDEvYnV0dG9uXG4vLyBpZDogYWxpYXMoYXBwMSkgKyBleHBvc2UoYnV0dG9uKSA9IGFwcDEvYnV0dG9uXG4vLyBpZDogYWxpYXMoYXBwMS91dGlscykgKyBleHBvc2UobG9hZGFzaC9zb3J0KSA9IGFwcDEvdXRpbHMvbG9hZGFzaC9zb3J0XG5mdW5jdGlvbiBtYXRjaFJlbW90ZVdpdGhOYW1lQW5kRXhwb3NlKHJlbW90ZXMsIGlkKSB7XG4gICAgZm9yIChjb25zdCByZW1vdGUgb2YgcmVtb3Rlcyl7XG4gICAgICAgIC8vIG1hdGNoIHBrZ05hbWVcbiAgICAgICAgY29uc3QgaXNOYW1lTWF0Y2hlZCA9IGlkLnN0YXJ0c1dpdGgocmVtb3RlLm5hbWUpO1xuICAgICAgICBsZXQgZXhwb3NlID0gaWQucmVwbGFjZShyZW1vdGUubmFtZSwgJycpO1xuICAgICAgICBpZiAoaXNOYW1lTWF0Y2hlZCkge1xuICAgICAgICAgICAgaWYgKGV4cG9zZS5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwa2dOYW1lT3JBbGlhcyA9IHJlbW90ZS5uYW1lO1xuICAgICAgICAgICAgICAgIGV4cG9zZSA9IGAuJHtleHBvc2V9YDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwa2dOYW1lT3JBbGlhcyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHBvc2UgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGtnTmFtZU9yQWxpYXM6IHJlbW90ZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBleHBvc2U6ICcuJyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBtYXRjaCBhbGlhc1xuICAgICAgICBjb25zdCBpc0FsaWFzTWF0Y2hlZCA9IHJlbW90ZS5hbGlhcyAmJiBpZC5zdGFydHNXaXRoKHJlbW90ZS5hbGlhcyk7XG4gICAgICAgIGxldCBleHBvc2VXaXRoQWxpYXMgPSByZW1vdGUuYWxpYXMgJiYgaWQucmVwbGFjZShyZW1vdGUuYWxpYXMsICcnKTtcbiAgICAgICAgaWYgKHJlbW90ZS5hbGlhcyAmJiBpc0FsaWFzTWF0Y2hlZCkge1xuICAgICAgICAgICAgaWYgKGV4cG9zZVdpdGhBbGlhcyAmJiBleHBvc2VXaXRoQWxpYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGtnTmFtZU9yQWxpYXMgPSByZW1vdGUuYWxpYXM7XG4gICAgICAgICAgICAgICAgZXhwb3NlV2l0aEFsaWFzID0gYC4ke2V4cG9zZVdpdGhBbGlhc31gO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBrZ05hbWVPckFsaWFzLFxuICAgICAgICAgICAgICAgICAgICBleHBvc2U6IGV4cG9zZVdpdGhBbGlhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwb3NlV2l0aEFsaWFzID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBrZ05hbWVPckFsaWFzOiByZW1vdGUuYWxpYXMsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZTogJy4nLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn1cbi8vIEZ1bmN0aW9uIHRvIG1hdGNoIGEgcmVtb3RlIHdpdGggaXRzIG5hbWUgb3IgYWxpYXNcbmZ1bmN0aW9uIG1hdGNoUmVtb3RlKHJlbW90ZXMsIG5hbWVPckFsaWFzKSB7XG4gICAgZm9yIChjb25zdCByZW1vdGUgb2YgcmVtb3Rlcyl7XG4gICAgICAgIGNvbnN0IGlzTmFtZU1hdGNoZWQgPSBuYW1lT3JBbGlhcyA9PT0gcmVtb3RlLm5hbWU7XG4gICAgICAgIGlmIChpc05hbWVNYXRjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQWxpYXNNYXRjaGVkID0gcmVtb3RlLmFsaWFzICYmIG5hbWVPckFsaWFzID09PSByZW1vdGUuYWxpYXM7XG4gICAgICAgIGlmIChpc0FsaWFzTWF0Y2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2lucyQxKHBsdWdpbnMsIGhvb2tJbnN0YW5jZXMpIHtcbiAgICBjb25zdCBnbG9iYWxQbHVnaW5zID0gc2hhcmUuZ2V0R2xvYmFsSG9zdFBsdWdpbnMoKTtcbiAgICAvLyBJbmNvcnBvcmF0ZSBnbG9iYWwgcGx1Z2luc1xuICAgIGlmIChnbG9iYWxQbHVnaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZ2xvYmFsUGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pPT57XG4gICAgICAgICAgICBpZiAocGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5maW5kKChpdGVtKT0+aXRlbS5uYW1lICE9PSBwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwbHVnaW5zICYmIHBsdWdpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbik9PntcbiAgICAgICAgICAgIGhvb2tJbnN0YW5jZXMuZm9yRWFjaCgoaG9va0luc3RhbmNlKT0+e1xuICAgICAgICAgICAgICAgIGhvb2tJbnN0YW5jZS5hcHBseVBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGx1Z2lucztcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZEVzbUVudHJ5KHsgZW50cnksIHJlbW90ZUVudHJ5RXhwb3J0cyB9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXJlbW90ZUVudHJ5RXhwb3J0cykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1ldmFsXG4gICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKCdjYWxsYmFja3MnLCBgaW1wb3J0KFwiJHtlbnRyeX1cIikudGhlbihjYWxsYmFja3NbMF0pLmNhdGNoKGNhbGxiYWNrc1sxXSlgKShbXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlbW90ZUVudHJ5RXhwb3J0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFN5c3RlbUpzRW50cnkoeyBlbnRyeSwgcmVtb3RlRW50cnlFeHBvcnRzIH0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghcmVtb3RlRW50cnlFeHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV2YWxcbiAgICAgICAgICAgICAgICBuZXcgRnVuY3Rpb24oJ2NhbGxiYWNrcycsIGBTeXN0ZW0uaW1wb3J0KFwiJHtlbnRyeX1cIikudGhlbihjYWxsYmFja3NbMF0pLmNhdGNoKGNhbGxiYWNrc1sxXSlgKShbXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlbW90ZUVudHJ5RXhwb3J0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEVudHJ5U2NyaXB0KHsgbmFtZSwgZ2xvYmFsTmFtZSwgZW50cnksIGNyZWF0ZVNjcmlwdEhvb2sgfSkge1xuICAgIGNvbnN0IHsgZW50cnlFeHBvcnRzOiByZW1vdGVFbnRyeUV4cG9ydHMgfSA9IHNoYXJlLmdldFJlbW90ZUVudHJ5RXhwb3J0cyhuYW1lLCBnbG9iYWxOYW1lKTtcbiAgICBpZiAocmVtb3RlRW50cnlFeHBvcnRzKSB7XG4gICAgICAgIHJldHVybiByZW1vdGVFbnRyeUV4cG9ydHM7XG4gICAgfVxuICAgIHJldHVybiBzZGsubG9hZFNjcmlwdChlbnRyeSwge1xuICAgICAgICBhdHRyczoge30sXG4gICAgICAgIGNyZWF0ZVNjcmlwdEhvb2s6ICh1cmwsIGF0dHJzKT0+e1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlU2NyaXB0SG9vay5lbWl0KHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXR0cnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3NjcmlwdCcgaW4gcmVzIHx8ICd0aW1lb3V0JyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSkudGhlbigoKT0+e1xuICAgICAgICBjb25zdCB7IHJlbW90ZUVudHJ5S2V5LCBlbnRyeUV4cG9ydHMgfSA9IHNoYXJlLmdldFJlbW90ZUVudHJ5RXhwb3J0cyhuYW1lLCBnbG9iYWxOYW1lKTtcbiAgICAgICAgc2hhcmUuYXNzZXJ0KGVudHJ5RXhwb3J0cywgYFxuICAgICAgVW5hYmxlIHRvIHVzZSB0aGUgJHtuYW1lfSdzICcke2VudHJ5fScgVVJMIHdpdGggJHtyZW1vdGVFbnRyeUtleX0ncyBnbG9iYWxOYW1lIHRvIGdldCByZW1vdGVFbnRyeSBleHBvcnRzLlxuICAgICAgUG9zc2libGUgcmVhc29ucyBjb3VsZCBiZTpcXG5cbiAgICAgIDEuICcke2VudHJ5fScgaXMgbm90IHRoZSBjb3JyZWN0IFVSTCwgb3IgdGhlIHJlbW90ZUVudHJ5IHJlc291cmNlIG9yIG5hbWUgaXMgaW5jb3JyZWN0LlxcblxuICAgICAgMi4gJHtyZW1vdGVFbnRyeUtleX0gY2Fubm90IGJlIHVzZWQgdG8gZ2V0IHJlbW90ZUVudHJ5IGV4cG9ydHMgaW4gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgYCk7XG4gICAgICAgIHJldHVybiBlbnRyeUV4cG9ydHM7XG4gICAgfSkuY2F0Y2goKGUpPT57XG4gICAgICAgIHRocm93IGU7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkRW50cnlEb20oeyByZW1vdGVJbmZvLCByZW1vdGVFbnRyeUV4cG9ydHMsIGNyZWF0ZVNjcmlwdEhvb2sgfSkge1xuICAgIGNvbnN0IHsgZW50cnksIGVudHJ5R2xvYmFsTmFtZTogZ2xvYmFsTmFtZSwgbmFtZSwgdHlwZSB9ID0gcmVtb3RlSW5mbztcbiAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgIGNhc2UgJ2VzbSc6XG4gICAgICAgIGNhc2UgJ21vZHVsZSc6XG4gICAgICAgICAgICByZXR1cm4gbG9hZEVzbUVudHJ5KHtcbiAgICAgICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdzeXN0ZW0nOlxuICAgICAgICAgICAgcmV0dXJuIGxvYWRTeXN0ZW1Kc0VudHJ5KHtcbiAgICAgICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGxvYWRFbnRyeVNjcmlwdCh7XG4gICAgICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICAgICAgZ2xvYmFsTmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2tcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRFbnRyeU5vZGUoeyByZW1vdGVJbmZvLCBjcmVhdGVTY3JpcHRIb29rIH0pIHtcbiAgICBjb25zdCB7IGVudHJ5LCBlbnRyeUdsb2JhbE5hbWU6IGdsb2JhbE5hbWUsIG5hbWUgfSA9IHJlbW90ZUluZm87XG4gICAgY29uc3QgeyBlbnRyeUV4cG9ydHM6IHJlbW90ZUVudHJ5RXhwb3J0cyB9ID0gc2hhcmUuZ2V0UmVtb3RlRW50cnlFeHBvcnRzKG5hbWUsIGdsb2JhbE5hbWUpO1xuICAgIGlmIChyZW1vdGVFbnRyeUV4cG9ydHMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICB9XG4gICAgcmV0dXJuIHNkay5sb2FkU2NyaXB0Tm9kZShlbnRyeSwge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGdsb2JhbE5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU2NyaXB0SG9vazogKHVybCwgYXR0cnMpPT57XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGVTY3JpcHRIb29rLmVtaXQoe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBhdHRyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlcykgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCd1cmwnIGluIHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KS50aGVuKCgpPT57XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlRW50cnlLZXksIGVudHJ5RXhwb3J0cyB9ID0gc2hhcmUuZ2V0UmVtb3RlRW50cnlFeHBvcnRzKG5hbWUsIGdsb2JhbE5hbWUpO1xuICAgICAgICBzaGFyZS5hc3NlcnQoZW50cnlFeHBvcnRzLCBgXG4gICAgICBVbmFibGUgdG8gdXNlIHRoZSAke25hbWV9J3MgJyR7ZW50cnl9JyBVUkwgd2l0aCAke3JlbW90ZUVudHJ5S2V5fSdzIGdsb2JhbE5hbWUgdG8gZ2V0IHJlbW90ZUVudHJ5IGV4cG9ydHMuXG4gICAgICBQb3NzaWJsZSByZWFzb25zIGNvdWxkIGJlOlxcblxuICAgICAgMS4gJyR7ZW50cnl9JyBpcyBub3QgdGhlIGNvcnJlY3QgVVJMLCBvciB0aGUgcmVtb3RlRW50cnkgcmVzb3VyY2Ugb3IgbmFtZSBpcyBpbmNvcnJlY3QuXFxuXG4gICAgICAyLiAke3JlbW90ZUVudHJ5S2V5fSBjYW5ub3QgYmUgdXNlZCB0byBnZXQgcmVtb3RlRW50cnkgZXhwb3J0cyBpbiB0aGUgd2luZG93IG9iamVjdC5cbiAgICBgKTtcbiAgICAgICAgcmV0dXJuIGVudHJ5RXhwb3J0cztcbiAgICB9KS5jYXRjaCgoZSk9PntcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KHJlbW90ZUluZm8pIHtcbiAgICBjb25zdCB7IGVudHJ5LCBuYW1lIH0gPSByZW1vdGVJbmZvO1xuICAgIHJldHVybiBzZGsuY29tcG9zZUtleVdpdGhTZXBhcmF0b3IobmFtZSwgZW50cnkpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVtb3RlRW50cnkoeyBvcmlnaW4sIHJlbW90ZUVudHJ5RXhwb3J0cywgcmVtb3RlSW5mbyB9KSB7XG4gICAgY29uc3QgdW5pcXVlS2V5ID0gZ2V0UmVtb3RlRW50cnlVbmlxdWVLZXkocmVtb3RlSW5mbyk7XG4gICAgaWYgKHJlbW90ZUVudHJ5RXhwb3J0cykge1xuICAgICAgICByZXR1cm4gcmVtb3RlRW50cnlFeHBvcnRzO1xuICAgIH1cbiAgICBpZiAoIXNoYXJlLmdsb2JhbExvYWRpbmdbdW5pcXVlS2V5XSkge1xuICAgICAgICBjb25zdCBsb2FkRW50cnlIb29rID0gb3JpZ2luLnJlbW90ZUhhbmRsZXIuaG9va3MubGlmZWN5Y2xlLmxvYWRFbnRyeTtcbiAgICAgICAgaWYgKGxvYWRFbnRyeUhvb2subGlzdGVuZXJzLnNpemUpIHtcbiAgICAgICAgICAgIHNoYXJlLmdsb2JhbExvYWRpbmdbdW5pcXVlS2V5XSA9IGxvYWRFbnRyeUhvb2suZW1pdCh7XG4gICAgICAgICAgICAgICAgY3JlYXRlU2NyaXB0SG9vazogb3JpZ2luLmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZVNjcmlwdCxcbiAgICAgICAgICAgICAgICByZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0c1xuICAgICAgICAgICAgfSkudGhlbigocmVzKT0+cmVzIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVTY3JpcHRIb29rID0gb3JpZ2luLmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZVNjcmlwdDtcbiAgICAgICAgICAgIGlmICghc2RrLmlzQnJvd3NlckVudigpKSB7XG4gICAgICAgICAgICAgICAgc2hhcmUuZ2xvYmFsTG9hZGluZ1t1bmlxdWVLZXldID0gbG9hZEVudHJ5Tm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcmUuZ2xvYmFsTG9hZGluZ1t1bmlxdWVLZXldID0gbG9hZEVudHJ5RG9tKHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlRW50cnlFeHBvcnRzLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTY3JpcHRIb29rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNoYXJlLmdsb2JhbExvYWRpbmdbdW5pcXVlS2V5XTtcbn1cbmZ1bmN0aW9uIGdldFJlbW90ZUluZm8ocmVtb3RlKSB7XG4gICAgcmV0dXJuIHBvbHlmaWxscy5fZXh0ZW5kcyh7fSwgcmVtb3RlLCB7XG4gICAgICAgIGVudHJ5OiAnZW50cnknIGluIHJlbW90ZSA/IHJlbW90ZS5lbnRyeSA6ICcnLFxuICAgICAgICB0eXBlOiByZW1vdGUudHlwZSB8fCBzaGFyZS5ERUZBVUxUX1JFTU9URV9UWVBFLFxuICAgICAgICBlbnRyeUdsb2JhbE5hbWU6IHJlbW90ZS5lbnRyeUdsb2JhbE5hbWUgfHwgcmVtb3RlLm5hbWUsXG4gICAgICAgIHNoYXJlU2NvcGU6IHJlbW90ZS5zaGFyZVNjb3BlIHx8IHNoYXJlLkRFRkFVTFRfU0NPUEVcbiAgICB9KTtcbn1cblxubGV0IE1vZHVsZSA9IGNsYXNzIE1vZHVsZSB7XG4gICAgYXN5bmMgZ2V0RW50cnkoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRW50cnlFeHBvcnRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCByZW1vdGVFbnRyeS5qc1xuICAgICAgICBjb25zdCByZW1vdGVFbnRyeUV4cG9ydHMgPSBhd2FpdCBnZXRSZW1vdGVFbnRyeSh7XG4gICAgICAgICAgICBvcmlnaW46IHRoaXMuaG9zdCxcbiAgICAgICAgICAgIHJlbW90ZUluZm86IHRoaXMucmVtb3RlSW5mbyxcbiAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0czogdGhpcy5yZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgfSk7XG4gICAgICAgIHNoYXJlLmFzc2VydChyZW1vdGVFbnRyeUV4cG9ydHMsIGByZW1vdGVFbnRyeUV4cG9ydHMgaXMgdW5kZWZpbmVkIFxcbiAke3Nkay5zYWZlVG9TdHJpbmcodGhpcy5yZW1vdGVJbmZvKX1gKTtcbiAgICAgICAgdGhpcy5yZW1vdGVFbnRyeUV4cG9ydHMgPSByZW1vdGVFbnRyeUV4cG9ydHM7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICBhc3luYyBnZXQoaWQsIGV4cG9zZSwgb3B0aW9ucywgcmVtb3RlU25hcHNob3QpIHtcbiAgICAgICAgY29uc3QgeyBsb2FkRmFjdG9yeSA9IHRydWUgfSA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgbG9hZEZhY3Rvcnk6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gR2V0IHJlbW90ZUVudHJ5LmpzXG4gICAgICAgIGNvbnN0IHJlbW90ZUVudHJ5RXhwb3J0cyA9IGF3YWl0IHRoaXMuZ2V0RW50cnkoKTtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRlZCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTaGFyZVNjb3BlTWFwID0gdGhpcy5ob3N0LnNoYXJlU2NvcGVNYXA7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVTaGFyZVNjb3BlID0gdGhpcy5yZW1vdGVJbmZvLnNoYXJlU2NvcGUgfHwgJ2RlZmF1bHQnO1xuICAgICAgICAgICAgaWYgKCFsb2NhbFNoYXJlU2NvcGVNYXBbcmVtb3RlU2hhcmVTY29wZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbFNoYXJlU2NvcGVNYXBbcmVtb3RlU2hhcmVTY29wZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNoYXJlU2NvcGUgPSBsb2NhbFNoYXJlU2NvcGVNYXBbcmVtb3RlU2hhcmVTY29wZV07XG4gICAgICAgICAgICBjb25zdCBpbml0U2NvcGUgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5yZW1vdGVJbmZvLnZlcnNpb24gfHwgJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBIZWxwIHRvIGZpbmQgaG9zdCBpbnN0YW5jZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMsICdzaGFyZVNjb3BlTWFwJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsb2NhbFNoYXJlU2NvcGVNYXAsXG4gICAgICAgICAgICAgICAgLy8gcmVtb3RlRW50cnlJbml0T3B0aW9ucyB3aWxsIGJlIHRyYXZlcnNlZCBhbmQgYXNzaWduZWQgZHVyaW5nIGNvbnRhaW5lciBpbml0LCAsc28gdGhpcyBhdHRyaWJ1dGUgaXMgbm90IGFsbG93ZWQgdG8gYmUgdHJhdmVyc2VkXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaW5pdENvbnRhaW5lck9wdGlvbnMgPSBhd2FpdCB0aGlzLmhvc3QuaG9va3MubGlmZWN5Y2xlLmJlZm9yZUluaXRDb250YWluZXIuZW1pdCh7XG4gICAgICAgICAgICAgICAgc2hhcmVTY29wZSxcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHNoYXJlU2NvcGVNYXAgd2lsbCBiZSBzZXQgYnkgT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICAgICAgICAgICAgICAgcmVtb3RlRW50cnlJbml0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbml0U2NvcGUsXG4gICAgICAgICAgICAgICAgcmVtb3RlSW5mbzogdGhpcy5yZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogdGhpcy5ob3N0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlbW90ZUVudHJ5RXhwb3J0cyA9PSBudWxsID8gdm9pZCAwIDogcmVtb3RlRW50cnlFeHBvcnRzLmluaXQpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSByZW1vdGUgZW50cnkgaW50ZXJmYWNlIGRvZXMgbm90IGNvbnRhaW4gXCJpbml0XCInLCAnXFxuJywgJ0Vuc3VyZSB0aGUgbmFtZSBvZiB0aGlzIHJlbW90ZSBpcyBub3QgcmVzZXJ2ZWQgb3IgaW4gdXNlLiBDaGVjayBpZiBhbnl0aGluZyBhbHJlYWR5IGV4aXN0cyBvbiB3aW5kb3dbbmFtZU9mUmVtb3RlXScsICdcXG4nLCAnRW5zdXJlIHRoYXQgd2luZG93W25hbWVPZlJlbW90ZV0gaXMgcmV0dXJuaW5nIGEge2dldCxpbml0fSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCByZW1vdGVFbnRyeUV4cG9ydHMuaW5pdChpbml0Q29udGFpbmVyT3B0aW9ucy5zaGFyZVNjb3BlLCBpbml0Q29udGFpbmVyT3B0aW9ucy5pbml0U2NvcGUsIGluaXRDb250YWluZXJPcHRpb25zLnJlbW90ZUVudHJ5SW5pdE9wdGlvbnMpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ob3N0Lmhvb2tzLmxpZmVjeWNsZS5pbml0Q29udGFpbmVyLmVtaXQocG9seWZpbGxzLl9leHRlbmRzKHt9LCBpbml0Q29udGFpbmVyT3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90LFxuICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0c1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGliID0gcmVtb3RlRW50cnlFeHBvcnRzO1xuICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XG4gICAgICAgIC8vIGdldCBleHBvc2VHZXR0ZXJcbiAgICAgICAgY29uc3QgbW9kdWxlRmFjdG9yeSA9IGF3YWl0IHJlbW90ZUVudHJ5RXhwb3J0cy5nZXQoZXhwb3NlKTtcbiAgICAgICAgc2hhcmUuYXNzZXJ0KG1vZHVsZUZhY3RvcnksIGAke3NoYXJlLmdldEZNSWQodGhpcy5yZW1vdGVJbmZvKX0gcmVtb3RlIGRvbid0IGV4cG9ydCAke2V4cG9zZX0uYCk7XG4gICAgICAgIGNvbnN0IHdyYXBNb2R1bGVGYWN0b3J5ID0gdGhpcy53cmFwZXJGYWN0b3J5KG1vZHVsZUZhY3RvcnksIGlkKTtcbiAgICAgICAgaWYgKCFsb2FkRmFjdG9yeSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBNb2R1bGVGYWN0b3J5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cG9zZUNvbnRlbnQgPSBhd2FpdCB3cmFwTW9kdWxlRmFjdG9yeSgpO1xuICAgICAgICByZXR1cm4gZXhwb3NlQ29udGVudDtcbiAgICB9XG4gICAgd3JhcGVyRmFjdG9yeShtb2R1bGVGYWN0b3J5LCBpZCkge1xuICAgICAgICBmdW5jdGlvbiBkZWZpbmVNb2R1bGVJZChyZXMsIGlkKSB7XG4gICAgICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmIE9iamVjdC5pc0V4dGVuc2libGUocmVzKSAmJiAhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZXMsIFN5bWJvbC5mb3IoJ21mX21vZHVsZV9pZCcpKSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXMsIFN5bWJvbC5mb3IoJ21mX21vZHVsZV9pZCcpLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kdWxlRmFjdG9yeSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG1vZHVsZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIGZvciBicmlkZ2UgZGVidWdnaW5nXG4gICAgICAgICAgICAgICAgZGVmaW5lTW9kdWxlSWQocmVzLCBpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBtb2R1bGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCBmb3IgYnJpZGdlIGRlYnVnZ2luZ1xuICAgICAgICAgICAgICAgIGRlZmluZU1vZHVsZUlkKHJlcywgaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgcmVtb3RlSW5mbywgaG9zdCB9KXtcbiAgICAgICAgdGhpcy5pbml0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saWIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVtb3RlSW5mbyA9IHJlbW90ZUluZm87XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgfVxufTtcblxuY2xhc3MgU3luY0hvb2sge1xuICAgIG9uKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmFkZChmbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25jZShmbikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMub24oZnVuY3Rpb24gd3JhcHBlciguLi5hcmdzKSB7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZSh3cmFwcGVyKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbWl0KC4uLmRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgoZm4pPT57XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4oLi4uZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZW1vdmUoZm4pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGZuKTtcbiAgICB9XG4gICAgcmVtb3ZlQWxsKCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5jbGVhcigpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0eXBlKXtcbiAgICAgICAgdGhpcy50eXBlID0gJyc7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQXN5bmNIb29rIGV4dGVuZHMgU3luY0hvb2sge1xuICAgIGVtaXQoLi4uZGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBjb25zdCBscyA9IEFycmF5LmZyb20odGhpcy5saXN0ZW5lcnMpO1xuICAgICAgICBpZiAobHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgY29uc3QgY2FsbCA9IChwcmV2KT0+e1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEFib3J0IHByb2Nlc3NcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCBscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsc1tpKytdLmFwcGx5KG51bGwsIGRhdGEpKS50aGVuKGNhbGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGNoZWNrUmV0dXJuRGF0YShvcmlnaW5hbERhdGEsIHJldHVybmVkRGF0YSkge1xuICAgIGlmICghc2hhcmUuaXNPYmplY3QocmV0dXJuZWREYXRhKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcmlnaW5hbERhdGEgIT09IHJldHVybmVkRGF0YSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiBvcmlnaW5hbERhdGEpe1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHJldHVybmVkRGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBTeW5jV2F0ZXJmYWxsSG9vayBleHRlbmRzIFN5bmNIb29rIHtcbiAgICBlbWl0KGRhdGEpIHtcbiAgICAgICAgaWYgKCFzaGFyZS5pc09iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgc2hhcmUuZXJyb3IoYFRoZSBkYXRhIGZvciB0aGUgXCIke3RoaXMudHlwZX1cIiBob29rIHNob3VsZCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLmxpc3RlbmVycyl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBEYXRhID0gZm4oZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUmV0dXJuRGF0YShkYXRhLCB0ZW1wRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRlbXBEYXRhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25lcnJvcihgQSBwbHVnaW4gcmV0dXJuZWQgYW4gdW5hY2NlcHRhYmxlIHZhbHVlIGZvciB0aGUgXCIke3RoaXMudHlwZX1cIiB0eXBlLmApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc2hhcmUud2FybihlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHR5cGUpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSBzaGFyZS5lcnJvcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG59XG5cbmNsYXNzIEFzeW5jV2F0ZXJmYWxsSG9vayBleHRlbmRzIFN5bmNIb29rIHtcbiAgICBlbWl0KGRhdGEpIHtcbiAgICAgICAgaWYgKCFzaGFyZS5pc09iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgc2hhcmUuZXJyb3IoYFRoZSByZXNwb25zZSBkYXRhIGZvciB0aGUgXCIke3RoaXMudHlwZX1cIiBob29rIG11c3QgYmUgYW4gb2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxzID0gQXJyYXkuZnJvbSh0aGlzLmxpc3RlbmVycyk7XG4gICAgICAgIGlmIChscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBzaGFyZS53YXJuKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvcihlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsID0gKHByZXZEYXRhKT0+e1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1JldHVybkRhdGEoZGF0YSwgcHJldkRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwcmV2RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsc1tpKytdKGRhdGEpKS50aGVuKGNhbGwsIHByb2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25lcnJvcihgQSBwbHVnaW4gcmV0dXJuZWQgYW4gaW5jb3JyZWN0IHZhbHVlIGZvciB0aGUgXCIke3RoaXMudHlwZX1cIiB0eXBlLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhbGwoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHR5cGUpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSBzaGFyZS5lcnJvcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG59XG5cbmNsYXNzIFBsdWdpblN5c3RlbSB7XG4gICAgYXBwbHlQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIHNoYXJlLmFzc2VydChzaGFyZS5pc1BsYWluT2JqZWN0KHBsdWdpbiksICdQbHVnaW4gY29uZmlndXJhdGlvbiBpcyBpbnZhbGlkLicpO1xuICAgICAgICAvLyBUaGUgcGx1Z2luJ3MgbmFtZSBpcyBtYW5kYXRvcnkgYW5kIG11c3QgYmUgdW5pcXVlXG4gICAgICAgIGNvbnN0IHBsdWdpbk5hbWUgPSBwbHVnaW4ubmFtZTtcbiAgICAgICAgc2hhcmUuYXNzZXJ0KHBsdWdpbk5hbWUsICdBIG5hbWUgbXVzdCBiZSBwcm92aWRlZCBieSB0aGUgcGx1Z2luLicpO1xuICAgICAgICBpZiAoIXRoaXMucmVnaXN0ZXJQbHVnaW5zW3BsdWdpbk5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbjtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMubGlmZWN5Y2xlKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcGx1Z2luTGlmZSA9IHBsdWdpbltrZXldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5MaWZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlmZWN5Y2xlW2tleV0ub24ocGx1Z2luTGlmZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlUGx1Z2luKHBsdWdpbk5hbWUpIHtcbiAgICAgICAgc2hhcmUuYXNzZXJ0KHBsdWdpbk5hbWUsICdBIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMucmVnaXN0ZXJQbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgICBzaGFyZS5hc3NlcnQocGx1Z2luLCBgVGhlIHBsdWdpbiBcIiR7cGx1Z2luTmFtZX1cIiBpcyBub3QgcmVnaXN0ZXJlZC5gKTtcbiAgICAgICAgT2JqZWN0LmtleXMocGx1Z2luKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnbmFtZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpZmVjeWNsZVtrZXldLnJlbW92ZShwbHVnaW5ba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIGluaGVyaXQoeyBsaWZlY3ljbGUsIHJlZ2lzdGVyUGx1Z2lucyB9KSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGxpZmVjeWNsZSkuZm9yRWFjaCgoaG9va05hbWUpPT57XG4gICAgICAgICAgICBzaGFyZS5hc3NlcnQoIXRoaXMubGlmZWN5Y2xlW2hvb2tOYW1lXSwgYFRoZSBob29rIFwiJHtob29rTmFtZX1cIiBoYXMgYSBjb25mbGljdCBhbmQgY2Fubm90IGJlIGluaGVyaXRlZC5gKTtcbiAgICAgICAgICAgIHRoaXMubGlmZWN5Y2xlW2hvb2tOYW1lXSA9IGxpZmVjeWNsZVtob29rTmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyhyZWdpc3RlclBsdWdpbnMpLmZvckVhY2goKHBsdWdpbk5hbWUpPT57XG4gICAgICAgICAgICBzaGFyZS5hc3NlcnQoIXRoaXMucmVnaXN0ZXJQbHVnaW5zW3BsdWdpbk5hbWVdLCBgVGhlIHBsdWdpbiBcIiR7cGx1Z2luTmFtZX1cIiBoYXMgYSBjb25mbGljdCBhbmQgY2Fubm90IGJlIGluaGVyaXRlZC5gKTtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlQbHVnaW4ocmVnaXN0ZXJQbHVnaW5zW3BsdWdpbk5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxpZmVjeWNsZSl7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJQbHVnaW5zID0ge307XG4gICAgICAgIHRoaXMubGlmZWN5Y2xlID0gbGlmZWN5Y2xlO1xuICAgICAgICB0aGlzLmxpZmVjeWNsZUtleXMgPSBPYmplY3Qua2V5cyhsaWZlY3ljbGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWxvYWRBcmdzKHByZWxvYWRDb25maWcpIHtcbiAgICByZXR1cm4gcG9seWZpbGxzLl9leHRlbmRzKHtcbiAgICAgICAgcmVzb3VyY2VDYXRlZ29yeTogJ3N5bmMnLFxuICAgICAgICBzaGFyZTogdHJ1ZSxcbiAgICAgICAgZGVwc1JlbW90ZTogdHJ1ZSxcbiAgICAgICAgcHJlZmV0Y2hJbnRlcmZhY2U6IGZhbHNlXG4gICAgfSwgcHJlbG9hZENvbmZpZyk7XG59XG5mdW5jdGlvbiBmb3JtYXRQcmVsb2FkQXJncyhyZW1vdGVzLCBwcmVsb2FkQXJncykge1xuICAgIHJldHVybiBwcmVsb2FkQXJncy5tYXAoKGFyZ3MpPT57XG4gICAgICAgIGNvbnN0IHJlbW90ZUluZm8gPSBtYXRjaFJlbW90ZShyZW1vdGVzLCBhcmdzLm5hbWVPckFsaWFzKTtcbiAgICAgICAgc2hhcmUuYXNzZXJ0KHJlbW90ZUluZm8sIGBVbmFibGUgdG8gcHJlbG9hZCAke2FyZ3MubmFtZU9yQWxpYXN9IGFzIGl0IGlzIG5vdCBpbmNsdWRlZCBpbiAkeyFyZW1vdGVJbmZvICYmIHNkay5zYWZlVG9TdHJpbmcoe1xuICAgICAgICAgICAgcmVtb3RlSW5mbyxcbiAgICAgICAgICAgIHJlbW90ZXNcbiAgICAgICAgfSl9YCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW1vdGU6IHJlbW90ZUluZm8sXG4gICAgICAgICAgICBwcmVsb2FkQ29uZmlnOiBkZWZhdWx0UHJlbG9hZEFyZ3MoYXJncylcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByZWxvYWRFeHBvc2VzKGV4cG9zZXMpIHtcbiAgICBpZiAoIWV4cG9zZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3Nlcy5tYXAoKGV4cG9zZSk9PntcbiAgICAgICAgaWYgKGV4cG9zZSA9PT0gJy4nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3NlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvc2Uuc3RhcnRzV2l0aCgnLi8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9zZS5yZXBsYWNlKCcuLycsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3NlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJlbG9hZEFzc2V0cyhyZW1vdGVJbmZvLCBob3N0LCBhc3NldHMsIC8vIEl0IGlzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggcHJlbG9hZCBmcm9tIGxvYWQgcmVtb3RlIHBhcmFsbGVsIGxvYWRpbmdcbnVzZUxpbmtQcmVsb2FkID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgY3NzQXNzZXRzLCBqc0Fzc2V0c1dpdGhvdXRFbnRyeSwgZW50cnlBc3NldHMgfSA9IGFzc2V0cztcbiAgICBpZiAoaG9zdC5vcHRpb25zLmluQnJvd3Nlcikge1xuICAgICAgICBlbnRyeUFzc2V0cy5mb3JFYWNoKChhc3NldCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kdWxlSW5mbyB9ID0gYXNzZXQ7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGUgPSBob3N0Lm1vZHVsZUNhY2hlLmdldChyZW1vdGVJbmZvLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGdldFJlbW90ZUVudHJ5KHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBob3N0LFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVJbmZvOiBtb2R1bGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHM6IG1vZHVsZS5yZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UmVtb3RlRW50cnkoe1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3QsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUluZm86IG1vZHVsZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0czogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodXNlTGlua1ByZWxvYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRBdHRycyA9IHtcbiAgICAgICAgICAgICAgICByZWw6ICdwcmVsb2FkJyxcbiAgICAgICAgICAgICAgICBhczogJ3N0eWxlJyxcbiAgICAgICAgICAgICAgICBjcm9zc29yaWdpbjogJ2Fub255bW91cydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjc3NBc3NldHMuZm9yRWFjaCgoY3NzVXJsKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGluazogY3NzRWwsIG5lZWRBdHRhY2ggfSA9IHNkay5jcmVhdGVMaW5rKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjc3NVcmwsXG4gICAgICAgICAgICAgICAgICAgIGNiOiAoKT0+e30sXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiBkZWZhdWx0QXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUxpbmtIb29rOiAodXJsLCBhdHRycyk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGhvc3QubG9hZGVySG9vay5saWZlY3ljbGUuY3JlYXRlTGluay5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIEhUTUxMaW5rRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoY3NzRWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0QXR0cnMgPSB7XG4gICAgICAgICAgICAgICAgcmVsOiAnc3R5bGVzaGVldCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQvY3NzJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNzc0Fzc2V0cy5mb3JFYWNoKChjc3NVcmwpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsaW5rOiBjc3NFbCwgbmVlZEF0dGFjaCB9ID0gc2RrLmNyZWF0ZUxpbmsoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGNzc1VybCxcbiAgICAgICAgICAgICAgICAgICAgY2I6ICgpPT57fSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IGRlZmF1bHRBdHRycyxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlTGlua0hvb2s6ICh1cmwsIGF0dHJzKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gaG9zdC5sb2FkZXJIb29rLmxpZmVjeWNsZS5jcmVhdGVMaW5rLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgSFRNTExpbmtFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbmVlZERlbGV0ZUxpbms6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGNzc0VsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VMaW5rUHJlbG9hZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdEF0dHJzID0ge1xuICAgICAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgICAgIGFzOiAnc2NyaXB0JyxcbiAgICAgICAgICAgICAgICBjcm9zc29yaWdpbjogJ2Fub255bW91cydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBqc0Fzc2V0c1dpdGhvdXRFbnRyeS5mb3JFYWNoKChqc1VybCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxpbms6IGxpbmtFbCwgbmVlZEF0dGFjaCB9ID0gc2RrLmNyZWF0ZUxpbmsoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGpzVXJsLFxuICAgICAgICAgICAgICAgICAgICBjYjogKCk9Pnt9LFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogZGVmYXVsdEF0dHJzLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVMaW5rSG9vazogKHVybCwgYXR0cnMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBob3N0LmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZUxpbmsuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MTGlua0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmtFbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRBdHRycyA9IHtcbiAgICAgICAgICAgICAgICBmZXRjaHByaW9yaXR5OiAnaGlnaCcsXG4gICAgICAgICAgICAgICAgdHlwZTogKHJlbW90ZUluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IHJlbW90ZUluZm8udHlwZSkgPT09ICdtb2R1bGUnID8gJ21vZHVsZScgOiAndGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGpzQXNzZXRzV2l0aG91dEVudHJ5LmZvckVhY2goKGpzVXJsKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NyaXB0OiBzY3JpcHRFbCwgbmVlZEF0dGFjaCB9ID0gc2RrLmNyZWF0ZVNjcmlwdCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDoganNVcmwsXG4gICAgICAgICAgICAgICAgICAgIGNiOiAoKT0+e30sXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiBkZWZhdWx0QXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2s6ICh1cmwsIGF0dHJzKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gaG9zdC5sb2FkZXJIb29rLmxpZmVjeWNsZS5jcmVhdGVTY3JpcHQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG5lZWREZWxldGVTY3JpcHQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnblJlbW90ZUluZm8ocmVtb3RlSW5mbywgcmVtb3RlU25hcHNob3QpIHtcbiAgICBjb25zdCByZW1vdGVFbnRyeUluZm8gPSBzaGFyZS5nZXRSZW1vdGVFbnRyeUluZm9Gcm9tU25hcHNob3QocmVtb3RlU25hcHNob3QpO1xuICAgIGlmICghcmVtb3RlRW50cnlJbmZvLnVybCkge1xuICAgICAgICBzaGFyZS5lcnJvcihgVGhlIGF0dHJpYnV0ZSByZW1vdGVFbnRyeSBvZiAke3JlbW90ZUluZm8ubmFtZX0gbXVzdCBub3QgYmUgdW5kZWZpbmVkLmApO1xuICAgIH1cbiAgICBsZXQgZW50cnlVcmwgPSBzZGsuZ2V0UmVzb3VyY2VVcmwocmVtb3RlU25hcHNob3QsIHJlbW90ZUVudHJ5SW5mby51cmwpO1xuICAgIGlmICghc2RrLmlzQnJvd3NlckVudigpICYmICFlbnRyeVVybC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgZW50cnlVcmwgPSBgaHR0cHM6JHtlbnRyeVVybH1gO1xuICAgIH1cbiAgICByZW1vdGVJbmZvLnR5cGUgPSByZW1vdGVFbnRyeUluZm8udHlwZTtcbiAgICByZW1vdGVJbmZvLmVudHJ5R2xvYmFsTmFtZSA9IHJlbW90ZUVudHJ5SW5mby5nbG9iYWxOYW1lO1xuICAgIHJlbW90ZUluZm8uZW50cnkgPSBlbnRyeVVybDtcbiAgICByZW1vdGVJbmZvLnZlcnNpb24gPSByZW1vdGVTbmFwc2hvdC52ZXJzaW9uO1xuICAgIHJlbW90ZUluZm8uYnVpbGRWZXJzaW9uID0gcmVtb3RlU25hcHNob3QuYnVpbGRWZXJzaW9uO1xufVxuZnVuY3Rpb24gc25hcHNob3RQbHVnaW4oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ3NuYXBzaG90LXBsdWdpbicsXG4gICAgICAgIGFzeW5jIGFmdGVyUmVzb2x2ZSAoYXJncykge1xuICAgICAgICAgICAgY29uc3QgeyByZW1vdGUsIHBrZ05hbWVPckFsaWFzLCBleHBvc2UsIG9yaWdpbiwgcmVtb3RlSW5mbyB9ID0gYXJncztcbiAgICAgICAgICAgIGlmICghc2hhcmUuaXNSZW1vdGVJbmZvV2l0aEVudHJ5KHJlbW90ZSkgfHwgIXNoYXJlLmlzUHVyZVJlbW90ZUVudHJ5KHJlbW90ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90LCBnbG9iYWxTbmFwc2hvdCB9ID0gYXdhaXQgb3JpZ2luLnNuYXBzaG90SGFuZGxlci5sb2FkUmVtb3RlU25hcHNob3RJbmZvKHJlbW90ZSk7XG4gICAgICAgICAgICAgICAgYXNzaWduUmVtb3RlSW5mbyhyZW1vdGVJbmZvLCByZW1vdGVTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgLy8gcHJlbG9hZGluZyBhc3NldHNcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVsb2FkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lT3JBbGlhczogcGtnTmFtZU9yQWxpYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VDYXRlZ29yeTogJ3N5bmMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwc1JlbW90ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzZXRzID0gYXdhaXQgb3JpZ2luLnJlbW90ZUhhbmRsZXIuaG9va3MubGlmZWN5Y2xlLmdlbmVyYXRlUHJlbG9hZEFzc2V0cy5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU25hcHNob3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYXNzZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRBc3NldHMocmVtb3RlSW5mbywgb3JpZ2luLCBhc3NldHMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlmaWxscy5fZXh0ZW5kcyh7fSwgYXJncywge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBuYW1lXG4vLyBuYW1lOnZlcnNpb25cbmZ1bmN0aW9uIHNwbGl0SWQoaWQpIHtcbiAgICBjb25zdCBzcGxpdEluZm8gPSBpZC5zcGxpdCgnOicpO1xuICAgIGlmIChzcGxpdEluZm8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzcGxpdEluZm9bMF0sXG4gICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHNwbGl0SW5mby5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHNwbGl0SW5mb1swXSxcbiAgICAgICAgICAgIHZlcnNpb246IHNwbGl0SW5mb1sxXVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzcGxpdEluZm9bMV0sXG4gICAgICAgICAgICB2ZXJzaW9uOiBzcGxpdEluZm9bMl1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyBUcmF2ZXJzZSBhbGwgbm9kZXMgaW4gbW9kdWxlSW5mbyBhbmQgdHJhdmVyc2UgdGhlIGVudGlyZSBzbmFwc2hvdFxuZnVuY3Rpb24gdHJhdmVyc2VNb2R1bGVJbmZvKGdsb2JhbFNuYXBzaG90LCByZW1vdGVJbmZvLCB0cmF2ZXJzZSwgaXNSb290LCBtZW1vID0ge30sIHJlbW90ZVNuYXBzaG90KSB7XG4gICAgY29uc3QgaWQgPSBzaGFyZS5nZXRGTUlkKHJlbW90ZUluZm8pO1xuICAgIGNvbnN0IHsgdmFsdWU6IHNuYXBzaG90VmFsdWUgfSA9IHNoYXJlLmdldEluZm9XaXRob3V0VHlwZShnbG9iYWxTbmFwc2hvdCwgaWQpO1xuICAgIGNvbnN0IGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90ID0gcmVtb3RlU25hcHNob3QgfHwgc25hcHNob3RWYWx1ZTtcbiAgICBpZiAoZWZmZWN0aXZlUmVtb3RlU25hcHNob3QgJiYgIXNkay5pc01hbmlmZXN0UHJvdmlkZXIoZWZmZWN0aXZlUmVtb3RlU25hcHNob3QpKSB7XG4gICAgICAgIHRyYXZlcnNlKGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90LCByZW1vdGVJbmZvLCBpc1Jvb3QpO1xuICAgICAgICBpZiAoZWZmZWN0aXZlUmVtb3RlU25hcHNob3QucmVtb3Rlc0luZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUtleXMgPSBPYmplY3Qua2V5cyhlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdC5yZW1vdGVzSW5mbyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiByZW1vdGVLZXlzKXtcbiAgICAgICAgICAgICAgICBpZiAobWVtb1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YlJlbW90ZUluZm8gPSBzcGxpdElkKGtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlVmFsdWUgPSBlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdC5yZW1vdGVzSW5mb1trZXldO1xuICAgICAgICAgICAgICAgIHRyYXZlcnNlTW9kdWxlSW5mbyhnbG9iYWxTbmFwc2hvdCwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdWJSZW1vdGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHJlbW90ZVZhbHVlLm1hdGNoZWRWZXJzaW9uXG4gICAgICAgICAgICAgICAgfSwgdHJhdmVyc2UsIGZhbHNlLCBtZW1vLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbmZ1bmN0aW9uIGdlbmVyYXRlUHJlbG9hZEFzc2V0cyhvcmlnaW4sIHByZWxvYWRPcHRpb25zLCByZW1vdGUsIGdsb2JhbFNuYXBzaG90LCByZW1vdGVTbmFwc2hvdCkge1xuICAgIGNvbnN0IGNzc0Fzc2V0cyA9IFtdO1xuICAgIGNvbnN0IGpzQXNzZXRzID0gW107XG4gICAgY29uc3QgZW50cnlBc3NldHMgPSBbXTtcbiAgICBjb25zdCBsb2FkZWRTaGFyZWRKc0Fzc2V0cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBsb2FkZWRTaGFyZWRDc3NBc3NldHMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSBvcmlnaW47XG4gICAgY29uc3QgeyBwcmVsb2FkQ29uZmlnOiByb290UHJlbG9hZENvbmZpZyB9ID0gcHJlbG9hZE9wdGlvbnM7XG4gICAgY29uc3QgeyBkZXBzUmVtb3RlIH0gPSByb290UHJlbG9hZENvbmZpZztcbiAgICBjb25zdCBtZW1vID0ge307XG4gICAgdHJhdmVyc2VNb2R1bGVJbmZvKGdsb2JhbFNuYXBzaG90LCByZW1vdGUsIChtb2R1bGVJbmZvU25hcHNob3QsIHJlbW90ZUluZm8sIGlzUm9vdCk9PntcbiAgICAgICAgbGV0IHByZWxvYWRDb25maWc7XG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgIHByZWxvYWRDb25maWcgPSByb290UHJlbG9hZENvbmZpZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlcHNSZW1vdGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmRQcmVsb2FkQ29uZmlnID0gZGVwc1JlbW90ZS5maW5kKChyZW1vdGVDb25maWcpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdGVDb25maWcubmFtZU9yQWxpYXMgPT09IHJlbW90ZUluZm8ubmFtZSB8fCByZW1vdGVDb25maWcubmFtZU9yQWxpYXMgPT09IHJlbW90ZUluZm8uYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbmRQcmVsb2FkQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJlbG9hZENvbmZpZyA9IGRlZmF1bHRQcmVsb2FkQXJncyhmaW5kUHJlbG9hZENvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlcHNSZW1vdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBwcmVsb2FkQ29uZmlnID0gcm9vdFByZWxvYWRDb25maWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdGVFbnRyeVVybCA9IHNkay5nZXRSZXNvdXJjZVVybChtb2R1bGVJbmZvU25hcHNob3QsIHNoYXJlLmdldFJlbW90ZUVudHJ5SW5mb0Zyb21TbmFwc2hvdChtb2R1bGVJbmZvU25hcHNob3QpLnVybCk7XG4gICAgICAgIGlmIChyZW1vdGVFbnRyeVVybCkge1xuICAgICAgICAgICAgZW50cnlBc3NldHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogcmVtb3RlSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgIG1vZHVsZUluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcmVtb3RlSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBlbnRyeTogcmVtb3RlRW50cnlVcmwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZW1vdGVFbnRyeVR5cGUnIGluIG1vZHVsZUluZm9TbmFwc2hvdCA/IG1vZHVsZUluZm9TbmFwc2hvdC5yZW1vdGVFbnRyeVR5cGUgOiAnZ2xvYmFsJyxcbiAgICAgICAgICAgICAgICAgICAgZW50cnlHbG9iYWxOYW1lOiAnZ2xvYmFsTmFtZScgaW4gbW9kdWxlSW5mb1NuYXBzaG90ID8gbW9kdWxlSW5mb1NuYXBzaG90Lmdsb2JhbE5hbWUgOiByZW1vdGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlU2NvcGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAndmVyc2lvbicgaW4gbW9kdWxlSW5mb1NuYXBzaG90ID8gbW9kdWxlSW5mb1NuYXBzaG90LnZlcnNpb24gOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVybDogcmVtb3RlRW50cnlVcmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtb2R1bGVBc3NldHNJbmZvID0gJ21vZHVsZXMnIGluIG1vZHVsZUluZm9TbmFwc2hvdCA/IG1vZHVsZUluZm9TbmFwc2hvdC5tb2R1bGVzIDogW107XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRQcmVsb2FkRXhwb3NlcyA9IG5vcm1hbGl6ZVByZWxvYWRFeHBvc2VzKHByZWxvYWRDb25maWcuZXhwb3Nlcyk7XG4gICAgICAgIGlmIChub3JtYWxpemVkUHJlbG9hZEV4cG9zZXMubGVuZ3RoICYmICdtb2R1bGVzJyBpbiBtb2R1bGVJbmZvU25hcHNob3QpIHtcbiAgICAgICAgICAgIHZhciBfbW9kdWxlSW5mb1NuYXBzaG90X21vZHVsZXM7XG4gICAgICAgICAgICBtb2R1bGVBc3NldHNJbmZvID0gbW9kdWxlSW5mb1NuYXBzaG90ID09IG51bGwgPyB2b2lkIDAgOiAoX21vZHVsZUluZm9TbmFwc2hvdF9tb2R1bGVzID0gbW9kdWxlSW5mb1NuYXBzaG90Lm1vZHVsZXMpID09IG51bGwgPyB2b2lkIDAgOiBfbW9kdWxlSW5mb1NuYXBzaG90X21vZHVsZXMucmVkdWNlKChhc3NldHMsIG1vZHVsZUFzc2V0SW5mbyk9PntcbiAgICAgICAgICAgICAgICBpZiAoKG5vcm1hbGl6ZWRQcmVsb2FkRXhwb3NlcyA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXplZFByZWxvYWRFeHBvc2VzLmluZGV4T2YobW9kdWxlQXNzZXRJbmZvLm1vZHVsZU5hbWUpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXRzLnB1c2gobW9kdWxlQXNzZXRJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2V0cztcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVBc3NldHMoYXNzZXRzKSB7XG4gICAgICAgICAgICBjb25zdCBhc3NldHNSZXMgPSBhc3NldHMubWFwKChhc3NldCk9PnNkay5nZXRSZXNvdXJjZVVybChtb2R1bGVJbmZvU25hcHNob3QsIGFzc2V0KSk7XG4gICAgICAgICAgICBpZiAocHJlbG9hZENvbmZpZy5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXRzUmVzLmZpbHRlcihwcmVsb2FkQ29uZmlnLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXNzZXRzUmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2R1bGVBc3NldHNJbmZvKSB7XG4gICAgICAgICAgICBjb25zdCBhc3NldHNMZW5ndGggPSBtb2R1bGVBc3NldHNJbmZvLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFzc2V0c0xlbmd0aDsgaW5kZXgrKyl7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzZXRzSW5mbyA9IG1vZHVsZUFzc2V0c0luZm9baW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9zZUZ1bGxQYXRoID0gYCR7cmVtb3RlSW5mby5uYW1lfS8ke2Fzc2V0c0luZm8ubW9kdWxlTmFtZX1gO1xuICAgICAgICAgICAgICAgIG9yaWdpbi5yZW1vdGVIYW5kbGVyLmhvb2tzLmxpZmVjeWNsZS5oYW5kbGVQcmVsb2FkTW9kdWxlLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBpZDogYXNzZXRzSW5mby5tb2R1bGVOYW1lID09PSAnLicgPyByZW1vdGVJbmZvLm5hbWUgOiBleHBvc2VGdWxsUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcmVtb3RlSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogbW9kdWxlSW5mb1NuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGU6IHJlbW90ZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWxvYWRlZCA9IHNoYXJlLmdldFByZWxvYWRlZChleHBvc2VGdWxsUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZWxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZWxvYWRDb25maWcucmVzb3VyY2VDYXRlZ29yeSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmNzcy5hc3luYykpO1xuICAgICAgICAgICAgICAgICAgICBjc3NBc3NldHMucHVzaCguLi5oYW5kbGVBc3NldHMoYXNzZXRzSW5mby5hc3NldHMuY3NzLnN5bmMpKTtcbiAgICAgICAgICAgICAgICAgICAganNBc3NldHMucHVzaCguLi5oYW5kbGVBc3NldHMoYXNzZXRzSW5mby5hc3NldHMuanMuYXN5bmMpKTtcbiAgICAgICAgICAgICAgICAgICAganNBc3NldHMucHVzaCguLi5oYW5kbGVBc3NldHMoYXNzZXRzSW5mby5hc3NldHMuanMuc3luYykpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZWxvYWRDb25maWcucmVzb3VyY2VDYXRlZ29yeSA9ICdzeW5jJykge1xuICAgICAgICAgICAgICAgICAgICBjc3NBc3NldHMucHVzaCguLi5oYW5kbGVBc3NldHMoYXNzZXRzSW5mby5hc3NldHMuY3NzLnN5bmMpKTtcbiAgICAgICAgICAgICAgICAgICAganNBc3NldHMucHVzaCguLi5oYW5kbGVBc3NldHMoYXNzZXRzSW5mby5hc3NldHMuanMuc3luYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaGFyZS5zZXRQcmVsb2FkZWQoZXhwb3NlRnVsbFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgdHJ1ZSwgbWVtbywgcmVtb3RlU25hcHNob3QpO1xuICAgIGlmIChyZW1vdGVTbmFwc2hvdC5zaGFyZWQpIHtcbiAgICAgICAgY29uc3QgY29sbGVjdFNoYXJlZEFzc2V0cyA9IChzaGFyZUluZm8sIHNuYXBzaG90U2hhcmVkKT0+e1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFNoYXJlZCA9IHNoYXJlLmdldFJlZ2lzdGVyZWRTaGFyZShvcmlnaW4uc2hhcmVTY29wZU1hcCwgc25hcHNob3RTaGFyZWQuc2hhcmVkTmFtZSwgc2hhcmVJbmZvLCBvcmlnaW4uc2hhcmVkSGFuZGxlci5ob29rcy5saWZlY3ljbGUucmVzb2x2ZVNoYXJlKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBnbG9iYWwgc2hhcmUgZG9lcyBub3QgZXhpc3QsIG9yIHRoZSBsaWIgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QsIGl0IG1lYW5zIHRoYXQgdGhlIHNoYXJlZCBoYXMgbm90IGJlZW4gbG9hZGVkIHlldCBhbmQgY2FuIGJlIHByZWxvYWRlZC5cbiAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkU2hhcmVkICYmIHR5cGVvZiByZWdpc3RlcmVkU2hhcmVkLmxpYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHNuYXBzaG90U2hhcmVkLmFzc2V0cy5qcy5zeW5jLmZvckVhY2goKGFzc2V0KT0+e1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWRTaGFyZWRKc0Fzc2V0cy5hZGQoYXNzZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNuYXBzaG90U2hhcmVkLmFzc2V0cy5jc3Muc3luYy5mb3JFYWNoKChhc3NldCk9PntcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkU2hhcmVkQ3NzQXNzZXRzLmFkZChhc3NldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlbW90ZVNuYXBzaG90LnNoYXJlZC5mb3JFYWNoKChzaGFyZWQpPT57XG4gICAgICAgICAgICB2YXIgX29wdGlvbnNfc2hhcmVkO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVJbmZvcyA9IChfb3B0aW9uc19zaGFyZWQgPSBvcHRpb25zLnNoYXJlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRpb25zX3NoYXJlZFtzaGFyZWQuc2hhcmVkTmFtZV07XG4gICAgICAgICAgICBpZiAoIXNoYXJlSW5mb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBubyB2ZXJzaW9uLCBwcmVsb2FkIGFsbCBzaGFyZWRcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSBzaGFyZWQudmVyc2lvbiA/IHNoYXJlSW5mb3MuZmluZCgocyk9PnMudmVyc2lvbiA9PT0gc2hhcmVkLnZlcnNpb24pIDogc2hhcmVJbmZvcztcbiAgICAgICAgICAgIGlmICghc2hhcmVkT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFycmF5U2hhcmVJbmZvID0gc2hhcmUuYXJyYXlPcHRpb25zKHNoYXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgYXJyYXlTaGFyZUluZm8uZm9yRWFjaCgocyk9PntcbiAgICAgICAgICAgICAgICBjb2xsZWN0U2hhcmVkQXNzZXRzKHMsIHNoYXJlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRQcmVsb2FkSnNBc3NldHMgPSBqc0Fzc2V0cy5maWx0ZXIoKGFzc2V0KT0+IWxvYWRlZFNoYXJlZEpzQXNzZXRzLmhhcyhhc3NldCkpO1xuICAgIGNvbnN0IG5lZWRQcmVsb2FkQ3NzQXNzZXRzID0gY3NzQXNzZXRzLmZpbHRlcigoYXNzZXQpPT4hbG9hZGVkU2hhcmVkQ3NzQXNzZXRzLmhhcyhhc3NldCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNzc0Fzc2V0czogbmVlZFByZWxvYWRDc3NBc3NldHMsXG4gICAgICAgIGpzQXNzZXRzV2l0aG91dEVudHJ5OiBuZWVkUHJlbG9hZEpzQXNzZXRzLFxuICAgICAgICBlbnRyeUFzc2V0c1xuICAgIH07XG59XG5jb25zdCBnZW5lcmF0ZVByZWxvYWRBc3NldHNQbHVnaW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnZ2VuZXJhdGUtcHJlbG9hZC1hc3NldHMtcGx1Z2luJyxcbiAgICAgICAgYXN5bmMgZ2VuZXJhdGVQcmVsb2FkQXNzZXRzIChhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9yaWdpbiwgcHJlbG9hZE9wdGlvbnMsIHJlbW90ZUluZm8sIHJlbW90ZSwgZ2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90IH0gPSBhcmdzO1xuICAgICAgICAgICAgaWYgKHNoYXJlLmlzUmVtb3RlSW5mb1dpdGhFbnRyeShyZW1vdGUpICYmIHNoYXJlLmlzUHVyZVJlbW90ZUVudHJ5KHJlbW90ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjc3NBc3NldHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBqc0Fzc2V0c1dpdGhvdXRFbnRyeTogW10sXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5QXNzZXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcmVtb3RlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByZW1vdGUuZW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByZW1vdGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5OiByZW1vdGUuZW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdnbG9iYWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeUdsb2JhbE5hbWU6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlOiAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25SZW1vdGVJbmZvKHJlbW90ZUluZm8sIHJlbW90ZVNuYXBzaG90KTtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0cyA9IGdlbmVyYXRlUHJlbG9hZEFzc2V0cyhvcmlnaW4sIHByZWxvYWRPcHRpb25zLCByZW1vdGVJbmZvLCBnbG9iYWxTbmFwc2hvdCwgcmVtb3RlU25hcHNob3QpO1xuICAgICAgICAgICAgcmV0dXJuIGFzc2V0cztcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBnZXRHbG9iYWxSZW1vdGVJbmZvKG1vZHVsZUluZm8sIG9yaWdpbikge1xuICAgIGNvbnN0IGhvc3RHbG9iYWxTbmFwc2hvdCA9IHNoYXJlLmdldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyh7XG4gICAgICAgIG5hbWU6IG9yaWdpbi5vcHRpb25zLm5hbWUsXG4gICAgICAgIHZlcnNpb246IG9yaWdpbi5vcHRpb25zLnZlcnNpb25cbiAgICB9KTtcbiAgICAvLyBnZXQgcmVtb3RlIGRldGFpbCBpbmZvIGZyb20gZ2xvYmFsXG4gICAgY29uc3QgZ2xvYmFsUmVtb3RlSW5mbyA9IGhvc3RHbG9iYWxTbmFwc2hvdCAmJiAncmVtb3Rlc0luZm8nIGluIGhvc3RHbG9iYWxTbmFwc2hvdCAmJiBob3N0R2xvYmFsU25hcHNob3QucmVtb3Rlc0luZm8gJiYgc2hhcmUuZ2V0SW5mb1dpdGhvdXRUeXBlKGhvc3RHbG9iYWxTbmFwc2hvdC5yZW1vdGVzSW5mbywgbW9kdWxlSW5mby5uYW1lKS52YWx1ZTtcbiAgICBpZiAoZ2xvYmFsUmVtb3RlSW5mbyAmJiBnbG9iYWxSZW1vdGVJbmZvLm1hdGNoZWRWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBob3N0R2xvYmFsU25hcHNob3QsXG4gICAgICAgICAgICBnbG9iYWxTbmFwc2hvdDogc2hhcmUuZ2V0R2xvYmFsU25hcHNob3QoKSxcbiAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBzaGFyZS5nZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICAgICAgICAgIG5hbWU6IG1vZHVsZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBnbG9iYWxSZW1vdGVJbmZvLm1hdGNoZWRWZXJzaW9uXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBob3N0R2xvYmFsU25hcHNob3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2xvYmFsU25hcHNob3Q6IHNoYXJlLmdldEdsb2JhbFNuYXBzaG90KCksXG4gICAgICAgIHJlbW90ZVNuYXBzaG90OiBzaGFyZS5nZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICAgICAgbmFtZTogbW9kdWxlSW5mby5uYW1lLFxuICAgICAgICAgICAgdmVyc2lvbjogJ3ZlcnNpb24nIGluIG1vZHVsZUluZm8gPyBtb2R1bGVJbmZvLnZlcnNpb24gOiB1bmRlZmluZWRcbiAgICAgICAgfSlcbiAgICB9O1xufVxuY2xhc3MgU25hcHNob3RIYW5kbGVyIHtcbiAgICBhc3luYyBsb2FkU25hcHNob3QobW9kdWxlSW5mbykge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuSG9zdEluc3RhbmNlO1xuICAgICAgICBjb25zdCB7IGhvc3RHbG9iYWxTbmFwc2hvdCwgcmVtb3RlU25hcHNob3QsIGdsb2JhbFNuYXBzaG90IH0gPSB0aGlzLmdldEdsb2JhbFJlbW90ZUluZm8obW9kdWxlSW5mbyk7XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlU25hcHNob3Q6IGdsb2JhbFJlbW90ZVNuYXBzaG90LCBnbG9iYWxTbmFwc2hvdDogZ2xvYmFsU25hcHNob3RSZXMgfSA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmxvYWRTbmFwc2hvdC5lbWl0KHtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtb2R1bGVJbmZvLFxuICAgICAgICAgICAgaG9zdEdsb2JhbFNuYXBzaG90LFxuICAgICAgICAgICAgcmVtb3RlU25hcHNob3QsXG4gICAgICAgICAgICBnbG9iYWxTbmFwc2hvdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBnbG9iYWxSZW1vdGVTbmFwc2hvdCxcbiAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90OiBnbG9iYWxTbmFwc2hvdFJlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxpbmVzLXBlci1mdW5jdGlvblxuICAgIGFzeW5jIGxvYWRSZW1vdGVTbmFwc2hvdEluZm8obW9kdWxlSW5mbykge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuSG9zdEluc3RhbmNlO1xuICAgICAgICBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5iZWZvcmVMb2FkUmVtb3RlU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbW9kdWxlSW5mb1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGhvc3RTbmFwc2hvdCA9IHNoYXJlLmdldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyh7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLnZlcnNpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaG9zdFNuYXBzaG90KSB7XG4gICAgICAgICAgICBob3N0U25hcHNob3QgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy52ZXJzaW9uIHx8ICcnLFxuICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5OiAnJyxcbiAgICAgICAgICAgICAgICByZW1vdGVzSW5mbzoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaGFyZS5hZGRHbG9iYWxTbmFwc2hvdCh7XG4gICAgICAgICAgICAgICAgW3RoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMubmFtZV06IGhvc3RTbmFwc2hvdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gZHluYW1pYyBsb2FkUmVtb3RlIHNjZW5hcmlvcywgaW5jb21wbGV0ZSByZW1vdGVzSW5mbyBkZWxpdmVyeSBtYXkgb2NjdXIuIEluIHN1Y2ggY2FzZXMsIHRoZSByZW1vdGVzSW5mbyBpbiB0aGUgaG9zdCBuZWVkcyB0byBiZSBjb21wbGV0ZWQgaW4gdGhlIHNuYXBzaG90IGF0IHJ1bnRpbWUuXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUgc25hcHNob3QncyBpbnRlZ3JpdHkgYW5kIGhlbHBzIHRoZSBjaHJvbWUgcGx1Z2luIGNvcnJlY3RseSBpZGVudGlmeSBhbGwgcHJvZHVjZXIgbW9kdWxlcywgZW5zdXJpbmcgdGhhdCBwcm94eWFibGUgcHJvZHVjZXIgbW9kdWxlcyB3aWxsIG5vdCBiZSBtaXNzaW5nLlxuICAgICAgICBpZiAoaG9zdFNuYXBzaG90ICYmICdyZW1vdGVzSW5mbycgaW4gaG9zdFNuYXBzaG90ICYmICFzaGFyZS5nZXRJbmZvV2l0aG91dFR5cGUoaG9zdFNuYXBzaG90LnJlbW90ZXNJbmZvLCBtb2R1bGVJbmZvLm5hbWUpLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoJ3ZlcnNpb24nIGluIG1vZHVsZUluZm8gfHwgJ2VudHJ5JyBpbiBtb2R1bGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgaG9zdFNuYXBzaG90LnJlbW90ZXNJbmZvID0gcG9seWZpbGxzLl9leHRlbmRzKHt9LCBob3N0U25hcHNob3QgPT0gbnVsbCA/IHZvaWQgMCA6IGhvc3RTbmFwc2hvdC5yZW1vdGVzSW5mbywge1xuICAgICAgICAgICAgICAgICAgICBbbW9kdWxlSW5mby5uYW1lXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb246ICd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvID8gbW9kdWxlSW5mby52ZXJzaW9uIDogbW9kdWxlSW5mby5lbnRyeVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBob3N0R2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90LCBnbG9iYWxTbmFwc2hvdCB9ID0gdGhpcy5nZXRHbG9iYWxSZW1vdGVJbmZvKG1vZHVsZUluZm8pO1xuICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90OiBnbG9iYWxSZW1vdGVTbmFwc2hvdCwgZ2xvYmFsU25hcHNob3Q6IGdsb2JhbFNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbW9kdWxlSW5mbyxcbiAgICAgICAgICAgIGhvc3RHbG9iYWxTbmFwc2hvdCxcbiAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90LFxuICAgICAgICAgICAgZ2xvYmFsU25hcHNob3RcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGdsb2JhbCBzbmFwc2hvdCBpbmNsdWRlcyBtYW5pZmVzdCBvciBtb2R1bGUgaW5mbyBpbmNsdWRlcyBtYW5pZmVzdFxuICAgICAgICBpZiAoZ2xvYmFsUmVtb3RlU25hcHNob3QpIHtcbiAgICAgICAgICAgIGlmIChzZGsuaXNNYW5pZmVzdFByb3ZpZGVyKGdsb2JhbFJlbW90ZVNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUVudHJ5ID0gc2RrLmlzQnJvd3NlckVudigpID8gZ2xvYmFsUmVtb3RlU25hcHNob3QucmVtb3RlRW50cnkgOiBnbG9iYWxSZW1vdGVTbmFwc2hvdC5zc3JSZW1vdGVFbnRyeSB8fCBnbG9iYWxSZW1vdGVTbmFwc2hvdC5yZW1vdGVFbnRyeSB8fCAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGVTbmFwc2hvdCA9IGF3YWl0IHRoaXMuZ2V0TWFuaWZlc3RKc29uKHJlbW90ZUVudHJ5LCBtb2R1bGVJbmZvLCB7fSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICAgICAgICAgICAgICBjb25zdCBnbG9iYWxTbmFwc2hvdFJlcyA9IHNoYXJlLnNldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyhwb2x5ZmlsbHMuX2V4dGVuZHMoe30sIG1vZHVsZUluZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGdsb2JhbCByZW1vdGUgbWF5IGJlIG92ZXJyaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCBzZXQgdGhlIHNuYXBzaG90IGtleSB0byB0aGUgZ2xvYmFsIGFkZHJlc3Mgb2YgdGhlIGFjdHVhbCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5OiByZW1vdGVFbnRyeVxuICAgICAgICAgICAgICAgIH0pLCBtb2R1bGVTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3Q6IG1vZHVsZVNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxTbmFwc2hvdDogZ2xvYmFsU25hcHNob3RSZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90OiByZW1vdGVTbmFwc2hvdFJlcyB9ID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUubG9hZFJlbW90ZVNuYXBzaG90LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogZ2xvYmFsUmVtb3RlU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgIGZyb206ICdnbG9iYWwnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3Q6IHJlbW90ZVNuYXBzaG90UmVzLFxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxTbmFwc2hvdDogZ2xvYmFsU25hcHNob3RSZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNoYXJlLmlzUmVtb3RlSW5mb1dpdGhFbnRyeShtb2R1bGVJbmZvKSkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBmcm9tIG1hbmlmZXN0Lmpzb24gYW5kIG1lcmdlIHJlbW90ZSBpbmZvIGZyb20gcmVtb3RlIHNlcnZlclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNuYXBzaG90ID0gYXdhaXQgdGhpcy5nZXRNYW5pZmVzdEpzb24obW9kdWxlSW5mby5lbnRyeSwgbW9kdWxlSW5mbywge30pO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsU25hcHNob3RSZXMgPSBzaGFyZS5zZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8obW9kdWxlSW5mbywgbW9kdWxlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVtb3RlU25hcHNob3Q6IHJlbW90ZVNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkUmVtb3RlU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBtb2R1bGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogJ2dsb2JhbCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogcmVtb3RlU25hcHNob3RSZXMsXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90OiBnbG9iYWxTbmFwc2hvdFJlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYXJlLmVycm9yKGBcbiAgICAgICAgICBDYW5ub3QgZ2V0IHJlbW90ZVNuYXBzaG90IHdpdGggdGhlIG5hbWU6ICcke21vZHVsZUluZm8ubmFtZX0nLCB2ZXJzaW9uOiAnJHttb2R1bGVJbmZvLnZlcnNpb259JyBmcm9tIF9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8uIFRoZSBmb2xsb3dpbmcgcmVhc29ucyBtYXkgYmUgY2F1c2luZyB0aGUgcHJvYmxlbTpcXG5cbiAgICAgICAgICAxLiBUaGUgRGVwbG95IHBsYXRmb3JtIGRpZCBub3QgZGVsaXZlciB0aGUgY29ycmVjdCBkYXRhLiBZb3UgY2FuIHVzZSBfX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvIHRvIGNoZWNrIHRoZSByZW1vdGVJbmZvLlxcblxuICAgICAgICAgIDIuIFRoZSByZW1vdGUgJyR7bW9kdWxlSW5mby5uYW1lfScgdmVyc2lvbiAnJHttb2R1bGVJbmZvLnZlcnNpb259JyBpcyBub3QgcmVsZWFzZWQuXFxuXG4gICAgICAgICAgVGhlIHRyYW5zZm9ybWVkIG1vZHVsZSBpbmZvOiAke0pTT04uc3RyaW5naWZ5KGdsb2JhbFNuYXBzaG90UmVzKX1cbiAgICAgICAgYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0R2xvYmFsUmVtb3RlSW5mbyhtb2R1bGVJbmZvKSB7XG4gICAgICAgIHJldHVybiBnZXRHbG9iYWxSZW1vdGVJbmZvKG1vZHVsZUluZm8sIHRoaXMuSG9zdEluc3RhbmNlKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWFuaWZlc3RKc29uKG1hbmlmZXN0VXJsLCBtb2R1bGVJbmZvLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZ2V0TWFuaWZlc3QgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgbGV0IG1hbmlmZXN0SnNvbiA9IHRoaXMubWFuaWZlc3RDYWNoZS5nZXQobWFuaWZlc3RVcmwpO1xuICAgICAgICAgICAgaWYgKG1hbmlmZXN0SnNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdEpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLmxvYWRlckhvb2subGlmZWN5Y2xlLmZldGNoLmVtaXQobWFuaWZlc3RVcmwsIHt9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBmZXRjaChtYW5pZmVzdFVybCwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYW5pZmVzdEpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgICAgIHNoYXJlLmFzc2VydChtYW5pZmVzdEpzb24ubWV0YURhdGEgJiYgbWFuaWZlc3RKc29uLmV4cG9zZXMgJiYgbWFuaWZlc3RKc29uLnNoYXJlZCwgYCR7bWFuaWZlc3RVcmx9IGlzIG5vdCBhIGZlZGVyYXRpb24gbWFuaWZlc3RgKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0Q2FjaGUuc2V0KG1hbmlmZXN0VXJsLCBtYW5pZmVzdEpzb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdEpzb247XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5tYW5pZmVzdExvYWRpbmdbbWFuaWZlc3RVcmxdO1xuICAgICAgICAgICAgICAgIHNoYXJlLmVycm9yKGBGYWlsZWQgdG8gZ2V0IG1hbmlmZXN0SnNvbiBmb3IgJHttb2R1bGVJbmZvLm5hbWV9LiBUaGUgbWFuaWZlc3QgVVJMIGlzICR7bWFuaWZlc3RVcmx9LiBQbGVhc2UgZW5zdXJlIHRoYXQgdGhlIG1hbmlmZXN0VXJsIGlzIGFjY2Vzc2libGUuXG4gICAgICAgICAgXFxuIEVycm9yIG1lc3NhZ2U6XG4gICAgICAgICAgXFxuICR7ZXJyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhc3luY0xvYWRQcm9jZXNzID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0SnNvbiA9IGF3YWl0IGdldE1hbmlmZXN0KCk7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVTbmFwc2hvdCA9IHNkay5nZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0KG1hbmlmZXN0SnNvbiwge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IG1hbmlmZXN0VXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVtb3RlU25hcHNob3Q6IHJlbW90ZVNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkUmVtb3RlU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtb2R1bGVJbmZvLFxuICAgICAgICAgICAgICAgIG1hbmlmZXN0SnNvbixcbiAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICBtYW5pZmVzdFVybCxcbiAgICAgICAgICAgICAgICBmcm9tOiAnbWFuaWZlc3QnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZW1vdGVTbmFwc2hvdFJlcztcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLm1hbmlmZXN0TG9hZGluZ1ttYW5pZmVzdFVybF0pIHtcbiAgICAgICAgICAgIHRoaXMubWFuaWZlc3RMb2FkaW5nW21hbmlmZXN0VXJsXSA9IGFzeW5jTG9hZFByb2Nlc3MoKS50aGVuKChyZXMpPT5yZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmlmZXN0TG9hZGluZ1ttYW5pZmVzdFVybF07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKEhvc3RJbnN0YW5jZSl7XG4gICAgICAgIHRoaXMubG9hZGluZ0hvc3RTbmFwc2hvdCA9IG51bGw7XG4gICAgICAgIHRoaXMubWFuaWZlc3RDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ob29rcyA9IG5ldyBQbHVnaW5TeXN0ZW0oe1xuICAgICAgICAgICAgYmVmb3JlTG9hZFJlbW90ZVNuYXBzaG90OiBuZXcgQXN5bmNIb29rKCdiZWZvcmVMb2FkUmVtb3RlU25hcHNob3QnKSxcbiAgICAgICAgICAgIGxvYWRTbmFwc2hvdDogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnbG9hZEdsb2JhbFNuYXBzaG90JyksXG4gICAgICAgICAgICBsb2FkUmVtb3RlU25hcHNob3Q6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2xvYWRSZW1vdGVTbmFwc2hvdCcpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hbmlmZXN0TG9hZGluZyA9IHNoYXJlLkdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX01BTklGRVNUX0xPQURJTkdfXztcbiAgICAgICAgdGhpcy5Ib3N0SW5zdGFuY2UgPSBIb3N0SW5zdGFuY2U7XG4gICAgICAgIHRoaXMubG9hZGVySG9vayA9IEhvc3RJbnN0YW5jZS5sb2FkZXJIb29rO1xuICAgIH1cbn1cblxuY2xhc3MgU2hhcmVkSGFuZGxlciB7XG4gICAgLy8gcmVnaXN0ZXIgc2hhcmVkIGluIHNoYXJlU2NvcGVNYXBcbiAgICByZWdpc3RlclNoYXJlZChnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHNoYXJlSW5mb3MsIHNoYXJlZCB9ID0gc2hhcmUuZm9ybWF0U2hhcmVDb25maWdzKGdsb2JhbE9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IE9iamVjdC5rZXlzKHNoYXJlSW5mb3MpO1xuICAgICAgICBzaGFyZWRLZXlzLmZvckVhY2goKHNoYXJlZEtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHMgPSBzaGFyZUluZm9zW3NoYXJlZEtleV07XG4gICAgICAgICAgICBzaGFyZWRWYWxzLmZvckVhY2goKHNoYXJlZFZhbCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpc3RlcmVkU2hhcmVkID0gc2hhcmUuZ2V0UmVnaXN0ZXJlZFNoYXJlKHRoaXMuc2hhcmVTY29wZU1hcCwgc2hhcmVkS2V5LCBzaGFyZWRWYWwsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdpc3RlcmVkU2hhcmVkICYmIHNoYXJlZFZhbCAmJiBzaGFyZWRWYWwubGliKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2hhcmVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBrZ05hbWU6IHNoYXJlZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYjogc2hhcmVkVmFsLmxpYixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogc2hhcmVkVmFsLmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZDogc2hhcmVkVmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdXNlck9wdGlvbnMubmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaGFyZUluZm9zLFxuICAgICAgICAgICAgc2hhcmVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGxvYWRTaGFyZShwa2dOYW1lLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gICAgICAgIC8vIDEuIENoZWNrcyBpZiB0aGUgY3VycmVudGx5IGxvYWRlZCBzaGFyZSBhbHJlYWR5IGV4aXN0cywgaWYgbm90LCBpdCB0aHJvd3MgYW4gZXJyb3JcbiAgICAgICAgLy8gMi4gU2VhcmNoZXMgZ2xvYmFsbHkgZm9yIGEgbWF0Y2hpbmcgc2hhcmUsIGlmIGZvdW5kLCBpdCB1c2VzIGl0IGRpcmVjdGx5XG4gICAgICAgIC8vIDMuIElmIG5vdCBmb3VuZCwgaXQgcmV0cmlldmVzIGl0IGZyb20gdGhlIGN1cnJlbnQgc2hhcmUgYW5kIHN0b3JlcyB0aGUgb2J0YWluZWQgc2hhcmUgZ2xvYmFsbHkuXG4gICAgICAgIGNvbnN0IHNoYXJlSW5mbyA9IHNoYXJlLmdldFRhcmdldFNoYXJlZE9wdGlvbnMoe1xuICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgIGV4dHJhT3B0aW9ucyxcbiAgICAgICAgICAgIHNoYXJlSW5mb3M6IGhvc3Qub3B0aW9ucy5zaGFyZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzaGFyZUluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IHNoYXJlSW5mby5zY29wZSkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc2hhcmVJbmZvLnNjb3BlLm1hcChhc3luYyAoc2hhcmVTY29wZSk9PntcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmluaXRpYWxpemVTaGFyaW5nKHNoYXJlU2NvcGUsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3k6IHNoYXJlSW5mby5zdHJhdGVneVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9hZFNoYXJlUmVzID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuYmVmb3JlTG9hZFNoYXJlLmVtaXQoe1xuICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgIHNoYXJlSW5mbyxcbiAgICAgICAgICAgIHNoYXJlZDogaG9zdC5vcHRpb25zLnNoYXJlZCxcbiAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBzaGFyZUluZm86IHNoYXJlSW5mb1JlcyB9ID0gbG9hZFNoYXJlUmVzO1xuICAgICAgICAvLyBBc3NlcnQgdGhhdCBzaGFyZUluZm9SZXMgZXhpc3RzLCBpZiBub3QsIHRocm93IGFuIGVycm9yXG4gICAgICAgIHNoYXJlLmFzc2VydChzaGFyZUluZm9SZXMsIGBDYW5ub3QgZmluZCAke3BrZ05hbWV9IFNoYXJlIGluIHRoZSAke2hvc3Qub3B0aW9ucy5uYW1lfS4gUGxlYXNlIGVuc3VyZSB0aGF0IHRoZSAke3BrZ05hbWV9IFNoYXJlIHBhcmFtZXRlcnMgaGF2ZSBiZWVuIGluamVjdGVkYCk7XG4gICAgICAgIC8vIFJldHJpZXZlIGZyb20gY2FjaGVcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFNoYXJlZCA9IHNoYXJlLmdldFJlZ2lzdGVyZWRTaGFyZSh0aGlzLnNoYXJlU2NvcGVNYXAsIHBrZ05hbWUsIHNoYXJlSW5mb1JlcywgdGhpcy5ob29rcy5saWZlY3ljbGUucmVzb2x2ZVNoYXJlKTtcbiAgICAgICAgY29uc3QgYWRkVXNlSW4gPSAoc2hhcmVkKT0+e1xuICAgICAgICAgICAgaWYgKCFzaGFyZWQudXNlSW4pIHtcbiAgICAgICAgICAgICAgICBzaGFyZWQudXNlSW4gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoYXJlLmFkZFVuaXF1ZUl0ZW0oc2hhcmVkLnVzZUluLCBob3N0Lm9wdGlvbnMubmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZWdpc3RlcmVkU2hhcmVkICYmIHJlZ2lzdGVyZWRTaGFyZWQubGliKSB7XG4gICAgICAgICAgICBhZGRVc2VJbihyZWdpc3RlcmVkU2hhcmVkKTtcbiAgICAgICAgICAgIHJldHVybiByZWdpc3RlcmVkU2hhcmVkLmxpYjtcbiAgICAgICAgfSBlbHNlIGlmIChyZWdpc3RlcmVkU2hhcmVkICYmIHJlZ2lzdGVyZWRTaGFyZWQubG9hZGluZyAmJiAhcmVnaXN0ZXJlZFNoYXJlZC5sb2FkZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSBhd2FpdCByZWdpc3RlcmVkU2hhcmVkLmxvYWRpbmc7XG4gICAgICAgICAgICByZWdpc3RlcmVkU2hhcmVkLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXJlZ2lzdGVyZWRTaGFyZWQubGliKSB7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZFNoYXJlZC5saWIgPSBmYWN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVXNlSW4ocmVnaXN0ZXJlZFNoYXJlZCk7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWdpc3RlcmVkU2hhcmVkKSB7XG4gICAgICAgICAgICBjb25zdCBhc3luY0xvYWRQcm9jZXNzID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gYXdhaXQgcmVnaXN0ZXJlZFNoYXJlZC5nZXQoKTtcbiAgICAgICAgICAgICAgICBzaGFyZUluZm9SZXMubGliID0gZmFjdG9yeTtcbiAgICAgICAgICAgICAgICBzaGFyZUluZm9SZXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZGRVc2VJbihzaGFyZUluZm9SZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdTaGFyZWQgPSBzaGFyZS5nZXRSZWdpc3RlcmVkU2hhcmUodGhpcy5zaGFyZVNjb3BlTWFwLCBwa2dOYW1lLCBzaGFyZUluZm9SZXMsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdTaGFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ1NoYXJlZC5saWIgPSBmYWN0b3J5O1xuICAgICAgICAgICAgICAgICAgICBnU2hhcmVkLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRpbmcgPSBhc3luY0xvYWRQcm9jZXNzKCk7XG4gICAgICAgICAgICB0aGlzLnNldFNoYXJlZCh7XG4gICAgICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNoYXJlZDogcmVnaXN0ZXJlZFNoYXJlZCxcbiAgICAgICAgICAgICAgICBmcm9tOiBob3N0Lm9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgICAgICBsaWI6IG51bGwsXG4gICAgICAgICAgICAgICAgbG9hZGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChleHRyYU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dHJhT3B0aW9ucy5jdXN0b21TaGFyZUluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhc3luY0xvYWRQcm9jZXNzID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gYXdhaXQgc2hhcmVJbmZvUmVzLmdldCgpO1xuICAgICAgICAgICAgICAgIHNoYXJlSW5mb1Jlcy5saWIgPSBmYWN0b3J5O1xuICAgICAgICAgICAgICAgIHNoYXJlSW5mb1Jlcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkZFVzZUluKHNoYXJlSW5mb1Jlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ1NoYXJlZCA9IHNoYXJlLmdldFJlZ2lzdGVyZWRTaGFyZSh0aGlzLnNoYXJlU2NvcGVNYXAsIHBrZ05hbWUsIHNoYXJlSW5mb1JlcywgdGhpcy5ob29rcy5saWZlY3ljbGUucmVzb2x2ZVNoYXJlKTtcbiAgICAgICAgICAgICAgICBpZiAoZ1NoYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBnU2hhcmVkLmxpYiA9IGZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgICAgIGdTaGFyZWQubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbG9hZGluZyA9IGFzeW5jTG9hZFByb2Nlc3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcmVkKHtcbiAgICAgICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgICAgIGxvYWRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hhcmVkOiBzaGFyZUluZm9SZXMsXG4gICAgICAgICAgICAgICAgZnJvbTogaG9zdC5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgbGliOiBudWxsLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgdGhlIHNoYXJpbmcgc2VxdWVuY2UgKGV4ZWN1dGVkIG9ubHkgb25jZSBwZXIgc2hhcmUgc2NvcGUpLlxuICAgKiBJdCBhY2NlcHRzIG9uZSBhcmd1bWVudCwgdGhlIG5hbWUgb2YgdGhlIHNoYXJlIHNjb3BlLlxuICAgKiBJZiB0aGUgc2hhcmUgc2NvcGUgZG9lcyBub3QgZXhpc3QsIGl0IGNyZWF0ZXMgb25lLlxuICAgKi8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9tZW1iZXItb3JkZXJpbmdcbiAgICBpbml0aWFsaXplU2hhcmluZyhzaGFyZVNjb3BlTmFtZSA9IHNoYXJlLkRFRkFVTFRfU0NPUEUsIGV4dHJhT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGZyb20gPSBleHRyYU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dHJhT3B0aW9ucy5mcm9tO1xuICAgICAgICBjb25zdCBzdHJhdGVneSA9IGV4dHJhT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogZXh0cmFPcHRpb25zLnN0cmF0ZWd5O1xuICAgICAgICBsZXQgaW5pdFNjb3BlID0gZXh0cmFPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBleHRyYU9wdGlvbnMuaW5pdFNjb3BlO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBpZiAoZnJvbSAhPT0gJ2J1aWxkJykge1xuICAgICAgICAgICAgY29uc3QgeyBpbml0VG9rZW5zIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFpbml0U2NvcGUpIGluaXRTY29wZSA9IFtdO1xuICAgICAgICAgICAgbGV0IGluaXRUb2tlbiA9IGluaXRUb2tlbnNbc2hhcmVTY29wZU5hbWVdO1xuICAgICAgICAgICAgaWYgKCFpbml0VG9rZW4pIGluaXRUb2tlbiA9IGluaXRUb2tlbnNbc2hhcmVTY29wZU5hbWVdID0ge1xuICAgICAgICAgICAgICAgIGZyb206IHRoaXMuaG9zdC5uYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGluaXRTY29wZS5pbmRleE9mKGluaXRUb2tlbikgPj0gMCkgcmV0dXJuIHByb21pc2VzO1xuICAgICAgICAgICAgaW5pdFNjb3BlLnB1c2goaW5pdFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaGFyZVNjb3BlID0gdGhpcy5zaGFyZVNjb3BlTWFwO1xuICAgICAgICBjb25zdCBob3N0TmFtZSA9IGhvc3Qub3B0aW9ucy5uYW1lO1xuICAgICAgICAvLyBDcmVhdGVzIGEgbmV3IHNoYXJlIHNjb3BlIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoIXNoYXJlU2NvcGVbc2hhcmVTY29wZU5hbWVdKSB7XG4gICAgICAgICAgICBzaGFyZVNjb3BlW3NoYXJlU2NvcGVOYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4ZWN1dGVzIGFsbCBpbml0aWFsaXphdGlvbiBzbmlwcGV0cyBmcm9tIGFsbCBhY2Nlc3NpYmxlIG1vZHVsZXNcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBzaGFyZVNjb3BlW3NoYXJlU2NvcGVOYW1lXTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXIgPSAobmFtZSwgc2hhcmVkKT0+e1xuICAgICAgICAgICAgdmFyIF9hY3RpdmVWZXJzaW9uX3NoYXJlQ29uZmlnO1xuICAgICAgICAgICAgY29uc3QgeyB2ZXJzaW9uLCBlYWdlciB9ID0gc2hhcmVkO1xuICAgICAgICAgICAgc2NvcGVbbmFtZV0gPSBzY29wZVtuYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb25zID0gc2NvcGVbbmFtZV07XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVWZXJzaW9uID0gdmVyc2lvbnNbdmVyc2lvbl07XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVWZXJzaW9uRWFnZXIgPSBCb29sZWFuKGFjdGl2ZVZlcnNpb24gJiYgKGFjdGl2ZVZlcnNpb24uZWFnZXIgfHwgKChfYWN0aXZlVmVyc2lvbl9zaGFyZUNvbmZpZyA9IGFjdGl2ZVZlcnNpb24uc2hhcmVDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYWN0aXZlVmVyc2lvbl9zaGFyZUNvbmZpZy5lYWdlcikpKTtcbiAgICAgICAgICAgIGlmICghYWN0aXZlVmVyc2lvbiB8fCBhY3RpdmVWZXJzaW9uLnN0cmF0ZWd5ICE9PSAnbG9hZGVkLWZpcnN0JyAmJiAhYWN0aXZlVmVyc2lvbi5sb2FkZWQgJiYgKEJvb2xlYW4oIWVhZ2VyKSAhPT0gIWFjdGl2ZVZlcnNpb25FYWdlciA/IGVhZ2VyIDogaG9zdE5hbWUgPiBhY3RpdmVWZXJzaW9uLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbnNbdmVyc2lvbl0gPSBzaGFyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGluaXRGbiA9IChtb2QpPT5tb2QgJiYgbW9kLmluaXQgJiYgbW9kLmluaXQoc2hhcmVTY29wZVtzaGFyZVNjb3BlTmFtZV0sIGluaXRTY29wZSk7XG4gICAgICAgIGNvbnN0IGluaXRSZW1vdGVNb2R1bGUgPSBhc3luYyAoa2V5KT0+e1xuICAgICAgICAgICAgY29uc3QgeyBtb2R1bGUgfSA9IGF3YWl0IGhvc3QucmVtb3RlSGFuZGxlci5nZXRSZW1vdGVNb2R1bGVBbmRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBpZDoga2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuZ2V0RW50cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IG1vZHVsZS5nZXRFbnRyeSgpO1xuICAgICAgICAgICAgICAgIGlmICghbW9kdWxlLmluaXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBpbml0Rm4oZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUuaW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5rZXlzKGhvc3Qub3B0aW9ucy5zaGFyZWQpLmZvckVhY2goKHNoYXJlTmFtZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZEFyciA9IGhvc3Qub3B0aW9ucy5zaGFyZWRbc2hhcmVOYW1lXTtcbiAgICAgICAgICAgIHNoYXJlZEFyci5mb3JFYWNoKChzaGFyZWQpPT57XG4gICAgICAgICAgICAgICAgaWYgKHNoYXJlZC5zY29wZS5pbmNsdWRlcyhzaGFyZVNjb3BlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXIoc2hhcmVOYW1lLCBzaGFyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogc3RyYXRlZ3k9PT0ndmVyc2lvbi1maXJzdCcgbmVlZCB0byBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmVcbiAgICAgICAgaWYgKGhvc3Qub3B0aW9ucy5zaGFyZVN0cmF0ZWd5ID09PSAndmVyc2lvbi1maXJzdCcgfHwgc3RyYXRlZ3kgPT09ICd2ZXJzaW9uLWZpcnN0Jykge1xuICAgICAgICAgICAgaG9zdC5vcHRpb25zLnJlbW90ZXMuZm9yRWFjaCgocmVtb3RlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdGUuc2hhcmVTY29wZSA9PT0gc2hhcmVTY29wZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChpbml0UmVtb3RlTW9kdWxlKHJlbW90ZS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgIH1cbiAgICAvLyBUaGUgbGliIGZ1bmN0aW9uIHdpbGwgb25seSBiZSBhdmFpbGFibGUgaWYgdGhlIHNoYXJlZCBzZXQgYnkgZWFnZXIgb3IgcnVudGltZSBpbml0IGlzIHNldCBvciB0aGUgc2hhcmVkIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAgLy8gMS4gSWYgdGhlIGxvYWRlZCBzaGFyZWQgYWxyZWFkeSBleGlzdHMgZ2xvYmFsbHksIHRoZW4gaXQgd2lsbCBiZSByZXVzZWRcbiAgICAvLyAyLiBJZiBsaWIgZXhpc3RzIGluIGxvY2FsIHNoYXJlZCwgaXQgd2lsbCBiZSB1c2VkIGRpcmVjdGx5XG4gICAgLy8gMy4gSWYgdGhlIGxvY2FsIGdldCByZXR1cm5zIHNvbWV0aGluZyBvdGhlciB0aGFuIFByb21pc2UsIHRoZW4gaXQgd2lsbCBiZSB1c2VkIGRpcmVjdGx5XG4gICAgbG9hZFNoYXJlU3luYyhwa2dOYW1lLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzaGFyZUluZm8gPSBzaGFyZS5nZXRUYXJnZXRTaGFyZWRPcHRpb25zKHtcbiAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICBleHRyYU9wdGlvbnMsXG4gICAgICAgICAgICBzaGFyZUluZm9zOiBob3N0Lm9wdGlvbnMuc2hhcmVkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2hhcmVJbmZvID09IG51bGwgPyB2b2lkIDAgOiBzaGFyZUluZm8uc2NvcGUpIHtcbiAgICAgICAgICAgIHNoYXJlSW5mby5zY29wZS5mb3JFYWNoKChzaGFyZVNjb3BlKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVNoYXJpbmcoc2hhcmVTY29wZSwge1xuICAgICAgICAgICAgICAgICAgICBzdHJhdGVneTogc2hhcmVJbmZvLnN0cmF0ZWd5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWdpc3RlcmVkU2hhcmVkID0gc2hhcmUuZ2V0UmVnaXN0ZXJlZFNoYXJlKHRoaXMuc2hhcmVTY29wZU1hcCwgcGtnTmFtZSwgc2hhcmVJbmZvLCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5yZXNvbHZlU2hhcmUpO1xuICAgICAgICBjb25zdCBhZGRVc2VJbiA9IChzaGFyZWQpPT57XG4gICAgICAgICAgICBpZiAoIXNoYXJlZC51c2VJbikge1xuICAgICAgICAgICAgICAgIHNoYXJlZC51c2VJbiA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcmUuYWRkVW5pcXVlSXRlbShzaGFyZWQudXNlSW4sIGhvc3Qub3B0aW9ucy5uYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRTaGFyZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVnaXN0ZXJlZFNoYXJlZC5saWIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhZGRVc2VJbihyZWdpc3RlcmVkU2hhcmVkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2lzdGVyZWRTaGFyZWQubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRTaGFyZWQubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2lzdGVyZWRTaGFyZWQuZnJvbSA9PT0gaG9zdC5vcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlSW5mby5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWdpc3RlcmVkU2hhcmVkLmxpYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVnaXN0ZXJlZFNoYXJlZC5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGUgPSByZWdpc3RlcmVkU2hhcmVkLmdldCgpO1xuICAgICAgICAgICAgICAgIGlmICghKG1vZHVsZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFVzZUluKHJlZ2lzdGVyZWRTaGFyZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNoYXJlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogaG9zdC5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWI6IG1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZDogcmVnaXN0ZXJlZFNoYXJlZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXJlSW5mby5saWIpIHtcbiAgICAgICAgICAgIGlmICghc2hhcmVJbmZvLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHNoYXJlSW5mby5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNoYXJlSW5mby5saWI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXJlSW5mby5nZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHNoYXJlSW5mby5nZXQoKTtcbiAgICAgICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgICAgVGhlIGxvYWRTaGFyZVN5bmMgZnVuY3Rpb24gd2FzIHVuYWJsZSB0byBsb2FkICR7cGtnTmFtZX0uIFRoZSAke3BrZ05hbWV9IGNvdWxkIG5vdCBiZSBmb3VuZCBpbiAke2hvc3Qub3B0aW9ucy5uYW1lfS5cbiAgICAgICAgUG9zc2libGUgcmVhc29ucyBmb3IgZmFpbHVyZTogXFxuXG4gICAgICAgIDEuIFRoZSAke3BrZ05hbWV9IHNoYXJlIHdhcyByZWdpc3RlcmVkIHdpdGggdGhlICdnZXQnIGF0dHJpYnV0ZSwgYnV0IGxvYWRTaGFyZSB3YXMgbm90IHVzZWQgYmVmb3JlaGFuZC5cXG5cbiAgICAgICAgMi4gVGhlICR7cGtnTmFtZX0gc2hhcmUgd2FzIG5vdCByZWdpc3RlcmVkIHdpdGggdGhlICdsaWInIGF0dHJpYnV0ZS5cXG5cbiAgICAgIGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcmVJbmZvLmxpYiA9IG1vZHVsZTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcmVkKHtcbiAgICAgICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgICAgIGxvYWRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmcm9tOiBob3N0Lm9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgICAgICBsaWI6IHNoYXJlSW5mby5saWIsXG4gICAgICAgICAgICAgICAgc2hhcmVkOiBzaGFyZUluZm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNoYXJlSW5mby5saWI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgICAgVGhlIGxvYWRTaGFyZVN5bmMgZnVuY3Rpb24gd2FzIHVuYWJsZSB0byBsb2FkICR7cGtnTmFtZX0uIFRoZSAke3BrZ05hbWV9IGNvdWxkIG5vdCBiZSBmb3VuZCBpbiAke2hvc3Qub3B0aW9ucy5uYW1lfS5cbiAgICAgICAgUG9zc2libGUgcmVhc29ucyBmb3IgZmFpbHVyZTogXFxuXG4gICAgICAgIDEuIFRoZSAke3BrZ05hbWV9IHNoYXJlIHdhcyByZWdpc3RlcmVkIHdpdGggdGhlICdnZXQnIGF0dHJpYnV0ZSwgYnV0IGxvYWRTaGFyZSB3YXMgbm90IHVzZWQgYmVmb3JlaGFuZC5cXG5cbiAgICAgICAgMi4gVGhlICR7cGtnTmFtZX0gc2hhcmUgd2FzIG5vdCByZWdpc3RlcmVkIHdpdGggdGhlICdsaWInIGF0dHJpYnV0ZS5cXG5cbiAgICAgIGApO1xuICAgIH1cbiAgICBpbml0U2hhcmVTY29wZU1hcChzY29wZU5hbWUsIHNoYXJlU2NvcGUsIGV4dHJhT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3Njb3BlTmFtZV0gPSBzaGFyZVNjb3BlO1xuICAgICAgICB0aGlzLmhvb2tzLmxpZmVjeWNsZS5pbml0Q29udGFpbmVyU2hhcmVTY29wZU1hcC5lbWl0KHtcbiAgICAgICAgICAgIHNoYXJlU2NvcGUsXG4gICAgICAgICAgICBvcHRpb25zOiBob3N0Lm9wdGlvbnMsXG4gICAgICAgICAgICBvcmlnaW46IGhvc3QsXG4gICAgICAgICAgICBzY29wZU5hbWUsXG4gICAgICAgICAgICBob3N0U2hhcmVTY29wZU1hcDogZXh0cmFPcHRpb25zLmhvc3RTaGFyZVNjb3BlTWFwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRTaGFyZWQoeyBwa2dOYW1lLCBzaGFyZWQsIGZyb20sIGxpYiwgbG9hZGluZywgbG9hZGVkLCBnZXQgfSkge1xuICAgICAgICBjb25zdCB7IHZlcnNpb24sIHNjb3BlID0gJ2RlZmF1bHQnIH0gPSBzaGFyZWQsIHNoYXJlSW5mbyA9IHBvbHlmaWxscy5fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShzaGFyZWQsIFtcbiAgICAgICAgICAgIFwidmVyc2lvblwiLFxuICAgICAgICAgICAgXCJzY29wZVwiXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBzY29wZXMgPSBBcnJheS5pc0FycmF5KHNjb3BlKSA/IHNjb3BlIDogW1xuICAgICAgICAgICAgc2NvcGVcbiAgICAgICAgXTtcbiAgICAgICAgc2NvcGVzLmZvckVhY2goKHNjKT0+e1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlU2NvcGVNYXBbc2NdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3NjXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW3ZlcnNpb25dKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVt2ZXJzaW9uXSA9IHBvbHlmaWxscy5fZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCdcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sIHNoYXJlSW5mbywge1xuICAgICAgICAgICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZCxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVt2ZXJzaW9uXS5nZXQgPSBnZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRTaGFyZWQgPSB0aGlzLnNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW3ZlcnNpb25dO1xuICAgICAgICAgICAgaWYgKGxvYWRpbmcgJiYgIXJlZ2lzdGVyZWRTaGFyZWQubG9hZGluZykge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRTaGFyZWQubG9hZGluZyA9IGxvYWRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2V0R2xvYmFsU2hhcmVTY29wZU1hcChob3N0T3B0aW9ucykge1xuICAgICAgICBjb25zdCBnbG9iYWxTaGFyZVNjb3BlTWFwID0gc2hhcmUuZ2V0R2xvYmFsU2hhcmVTY29wZSgpO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaG9zdE9wdGlvbnMuaWQgfHwgaG9zdE9wdGlvbnMubmFtZTtcbiAgICAgICAgaWYgKGlkZW50aWZpZXIgJiYgIWdsb2JhbFNoYXJlU2NvcGVNYXBbaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGdsb2JhbFNoYXJlU2NvcGVNYXBbaWRlbnRpZmllcl0gPSB0aGlzLnNoYXJlU2NvcGVNYXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoaG9zdCl7XG4gICAgICAgIHRoaXMuaG9va3MgPSBuZXcgUGx1Z2luU3lzdGVtKHtcbiAgICAgICAgICAgIGFmdGVyUmVzb2x2ZTogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnYWZ0ZXJSZXNvbHZlJyksXG4gICAgICAgICAgICBiZWZvcmVMb2FkU2hhcmU6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2JlZm9yZUxvYWRTaGFyZScpLFxuICAgICAgICAgICAgLy8gbm90IHVzZWQgeWV0XG4gICAgICAgICAgICBsb2FkU2hhcmU6IG5ldyBBc3luY0hvb2soKSxcbiAgICAgICAgICAgIHJlc29sdmVTaGFyZTogbmV3IFN5bmNXYXRlcmZhbGxIb29rKCdyZXNvbHZlU2hhcmUnKSxcbiAgICAgICAgICAgIC8vIG1heWJlIHdpbGwgY2hhbmdlLCB0ZW1wb3JhcmlseSBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgICAgICAgIGluaXRDb250YWluZXJTaGFyZVNjb3BlTWFwOiBuZXcgU3luY1dhdGVyZmFsbEhvb2soJ2luaXRDb250YWluZXJTaGFyZVNjb3BlTWFwJylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc2hhcmVTY29wZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLmluaXRUb2tlbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2V0R2xvYmFsU2hhcmVTY29wZU1hcChob3N0Lm9wdGlvbnMpO1xuICAgIH1cbn1cblxuY2xhc3MgUmVtb3RlSGFuZGxlciB7XG4gICAgZm9ybWF0QW5kUmVnaXN0ZXJSZW1vdGUoZ2xvYmFsT3B0aW9ucywgdXNlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXNlclJlbW90ZXMgPSB1c2VyT3B0aW9ucy5yZW1vdGVzIHx8IFtdO1xuICAgICAgICByZXR1cm4gdXNlclJlbW90ZXMucmVkdWNlKChyZXMsIHJlbW90ZSk9PntcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJSZW1vdGUocmVtb3RlLCByZXMsIHtcbiAgICAgICAgICAgICAgICBmb3JjZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwgZ2xvYmFsT3B0aW9ucy5yZW1vdGVzKTtcbiAgICB9XG4gICAgc2V0SWRUb1JlbW90ZU1hcChpZCwgcmVtb3RlTWF0Y2hJbmZvKSB7XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlLCBleHBvc2UgfSA9IHJlbW90ZU1hdGNoSW5mbztcbiAgICAgICAgY29uc3QgeyBuYW1lLCBhbGlhcyB9ID0gcmVtb3RlO1xuICAgICAgICB0aGlzLmlkVG9SZW1vdGVNYXBbaWRdID0ge1xuICAgICAgICAgICAgbmFtZTogcmVtb3RlLm5hbWUsXG4gICAgICAgICAgICBleHBvc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFsaWFzICYmIGlkLnN0YXJ0c1dpdGgobmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkV2l0aEFsaWFzID0gaWQucmVwbGFjZShuYW1lLCBhbGlhcyk7XG4gICAgICAgICAgICB0aGlzLmlkVG9SZW1vdGVNYXBbaWRXaXRoQWxpYXNdID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHJlbW90ZS5uYW1lLFxuICAgICAgICAgICAgICAgIGV4cG9zZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxpYXMgJiYgaWQuc3RhcnRzV2l0aChhbGlhcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkV2l0aE5hbWUgPSBpZC5yZXBsYWNlKGFsaWFzLCBuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuaWRUb1JlbW90ZU1hcFtpZFdpdGhOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiByZW1vdGUubmFtZSxcbiAgICAgICAgICAgICAgICBleHBvc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgIGFzeW5jIGxvYWRSZW1vdGUoaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBsb2FkRmFjdG9yeSA9IHRydWUgfSA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgIGxvYWRGYWN0b3J5OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gMS4gVmFsaWRhdGUgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIHJldHJpZXZlZCBtb2R1bGUuIFRoZXJlIGFyZSB0d28gbW9kdWxlIHJlcXVlc3QgbWV0aG9kczogcGtnTmFtZSArIGV4cG9zZSBhbmQgYWxpYXMgKyBleHBvc2UuXG4gICAgICAgICAgICAvLyAyLiBSZXF1ZXN0IHRoZSBzbmFwc2hvdCBpbmZvcm1hdGlvbiBvZiB0aGUgY3VycmVudCBob3N0IGFuZCBnbG9iYWxseSBzdG9yZSB0aGUgb2J0YWluZWQgc25hcHNob3QgaW5mb3JtYXRpb24uIFRoZSByZXRyaWV2ZWQgbW9kdWxlIGluZm9ybWF0aW9uIGlzIHBhcnRpYWxseSBvZmZsaW5lIGFuZCBwYXJ0aWFsbHkgb25saW5lLiBUaGUgb25saW5lIG1vZHVsZSBpbmZvcm1hdGlvbiB3aWxsIHJldHJpZXZlIHRoZSBtb2R1bGVzIHVzZWQgb25saW5lLlxuICAgICAgICAgICAgLy8gMy4gUmV0cmlldmUgdGhlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9mIHRoZSBjdXJyZW50IG1vZHVsZSBmcm9tIGdsb2JhbCAocmVtb3RlRW50cnkgYWRkcmVzcywgZXhwb3NlIHJlc291cmNlIGFkZHJlc3MpXG4gICAgICAgICAgICAvLyA0LiBBZnRlciByZXRyaWV2aW5nIHJlbW90ZUVudHJ5LCBjYWxsIHRoZSBpbml0IG9mIHRoZSBtb2R1bGUsIGFuZCB0aGVuIHJldHJpZXZlIHRoZSBleHBvcnRlZCBjb250ZW50IG9mIHRoZSBtb2R1bGUgdGhyb3VnaCBnZXRcbiAgICAgICAgICAgIC8vIGlkOiBwa2dOYW1lKEBmZWRlcmF0aW9uL2FwcDEpICsgZXhwb3NlKGJ1dHRvbikgPSBAZmVkZXJhdGlvbi9hcHAxL2J1dHRvblxuICAgICAgICAgICAgLy8gaWQ6IGFsaWFzKGFwcDEpICsgZXhwb3NlKGJ1dHRvbikgPSBhcHAxL2J1dHRvblxuICAgICAgICAgICAgLy8gaWQ6IGFsaWFzKGFwcDEvdXRpbHMpICsgZXhwb3NlKGxvYWRhc2gvc29ydCkgPSBhcHAxL3V0aWxzL2xvYWRhc2gvc29ydFxuICAgICAgICAgICAgY29uc3QgeyBtb2R1bGUsIG1vZHVsZU9wdGlvbnMsIHJlbW90ZU1hdGNoSW5mbyB9ID0gYXdhaXQgdGhpcy5nZXRSZW1vdGVNb2R1bGVBbmRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHBrZ05hbWVPckFsaWFzLCByZW1vdGUsIGV4cG9zZSwgaWQ6IGlkUmVzLCByZW1vdGVTbmFwc2hvdCB9ID0gcmVtb3RlTWF0Y2hJbmZvO1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlT3JGYWN0b3J5ID0gYXdhaXQgbW9kdWxlLmdldChpZFJlcywgZXhwb3NlLCBvcHRpb25zLCByZW1vdGVTbmFwc2hvdCk7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVXcmFwcGVyID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUub25Mb2FkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGlkOiBpZFJlcyxcbiAgICAgICAgICAgICAgICBwa2dOYW1lT3JBbGlhcyxcbiAgICAgICAgICAgICAgICBleHBvc2UsXG4gICAgICAgICAgICAgICAgZXhwb3NlTW9kdWxlOiBsb2FkRmFjdG9yeSA/IG1vZHVsZU9yRmFjdG9yeSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBleHBvc2VNb2R1bGVGYWN0b3J5OiBsb2FkRmFjdG9yeSA/IHVuZGVmaW5lZCA6IG1vZHVsZU9yRmFjdG9yeSxcbiAgICAgICAgICAgICAgICByZW1vdGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbW9kdWxlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtb2R1bGVJbnN0YW5jZTogbW9kdWxlLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNldElkVG9SZW1vdGVNYXAoaWQsIHJlbW90ZU1hdGNoSW5mbyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vZHVsZVdyYXBwZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlV3JhcHBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVPckZhY3Rvcnk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZyb20gPSAncnVudGltZScgfSA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgIGZyb206ICdydW50aW1lJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWxPdmVyID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuZXJyb3JMb2FkUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlOiAnb25Mb2FkJyxcbiAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFmYWlsT3Zlcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhaWxPdmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgYXN5bmMgcHJlbG9hZFJlbW90ZShwcmVsb2FkT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZVByZWxvYWRSZW1vdGUuZW1pdCh7XG4gICAgICAgICAgICBwcmVsb2FkT3BzOiBwcmVsb2FkT3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnM6IGhvc3Qub3B0aW9ucyxcbiAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJlbG9hZE9wcyA9IGZvcm1hdFByZWxvYWRBcmdzKGhvc3Qub3B0aW9ucy5yZW1vdGVzLCBwcmVsb2FkT3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByZWxvYWRPcHMubWFwKGFzeW5jIChvcHMpPT57XG4gICAgICAgICAgICBjb25zdCB7IHJlbW90ZSB9ID0gb3BzO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlSW5mbyA9IGdldFJlbW90ZUluZm8ocmVtb3RlKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90IH0gPSBhd2FpdCBob3N0LnNuYXBzaG90SGFuZGxlci5sb2FkUmVtb3RlU25hcHNob3RJbmZvKHJlbW90ZSk7XG4gICAgICAgICAgICBjb25zdCBhc3NldHMgPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5nZW5lcmF0ZVByZWxvYWRBc3NldHMuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBob3N0LFxuICAgICAgICAgICAgICAgIHByZWxvYWRPcHRpb25zOiBvcHMsXG4gICAgICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgICAgIHJlbW90ZUluZm8sXG4gICAgICAgICAgICAgICAgZ2xvYmFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFhc3NldHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVsb2FkQXNzZXRzKHJlbW90ZUluZm8sIGhvc3QsIGFzc2V0cyk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZW1vdGVzKHJlbW90ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICByZW1vdGVzLmZvckVhY2goKHJlbW90ZSk9PntcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJSZW1vdGUocmVtb3RlLCBob3N0Lm9wdGlvbnMucmVtb3Rlcywge1xuICAgICAgICAgICAgICAgIGZvcmNlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZvcmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlbW90ZU1vZHVsZUFuZE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBsb2FkUmVtb3RlQXJncztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvYWRSZW1vdGVBcmdzID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuYmVmb3JlUmVxdWVzdC5lbWl0KHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBob3N0Lm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBob3N0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvYWRSZW1vdGVBcmdzID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuZXJyb3JMb2FkUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGhvc3Qub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3QsXG4gICAgICAgICAgICAgICAgZnJvbTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGxpZmVjeWNsZTogJ2JlZm9yZVJlcXVlc3QnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghbG9hZFJlbW90ZUFyZ3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlkOiBpZFJlcyB9ID0gbG9hZFJlbW90ZUFyZ3M7XG4gICAgICAgIGNvbnN0IHJlbW90ZVNwbGl0SW5mbyA9IG1hdGNoUmVtb3RlV2l0aE5hbWVBbmRFeHBvc2UoaG9zdC5vcHRpb25zLnJlbW90ZXMsIGlkUmVzKTtcbiAgICAgICAgc2hhcmUuYXNzZXJ0KHJlbW90ZVNwbGl0SW5mbywgYFxuICAgICAgICBVbmFibGUgdG8gbG9jYXRlICR7aWRSZXN9IGluICR7aG9zdC5vcHRpb25zLm5hbWV9LiBQb3RlbnRpYWwgcmVhc29ucyBmb3IgZmFpbHVyZSBpbmNsdWRlOlxcblxuICAgICAgICAxLiAke2lkUmVzfSB3YXMgbm90IGluY2x1ZGVkIGluIHRoZSAncmVtb3RlcycgcGFyYW1ldGVyIG9mICR7aG9zdC5vcHRpb25zLm5hbWUgfHwgJ3RoZSBob3N0J30uXFxuXG4gICAgICAgIDIuICR7aWRSZXN9IGNvdWxkIG5vdCBiZSBmb3VuZCBpbiB0aGUgJ3JlbW90ZXMnIG9mICR7aG9zdC5vcHRpb25zLm5hbWV9IHdpdGggZWl0aGVyICduYW1lJyBvciAnYWxpYXMnIGF0dHJpYnV0ZXMuXG4gICAgICAgIDMuICR7aWRSZXN9IGlzIG5vdCBvbmxpbmUsIGluamVjdGVkLCBvciBsb2FkZWQuXG4gICAgICAgIDQuICR7aWRSZXN9ICBjYW5ub3QgYmUgYWNjZXNzZWQgb24gdGhlIGV4cGVjdGVkLlxuICAgICAgICA1LiBUaGUgJ2JlZm9yZVJlcXVlc3QnIGhvb2sgd2FzIHByb3ZpZGVkIGJ1dCBkaWQgbm90IHJldHVybiB0aGUgY29ycmVjdCAncmVtb3RlSW5mbycgd2hlbiBhdHRlbXB0aW5nIHRvIGxvYWQgJHtpZFJlc30uXG4gICAgICBgKTtcbiAgICAgICAgY29uc3QgeyByZW1vdGU6IHJhd1JlbW90ZSB9ID0gcmVtb3RlU3BsaXRJbmZvO1xuICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gZ2V0UmVtb3RlSW5mbyhyYXdSZW1vdGUpO1xuICAgICAgICBjb25zdCBtYXRjaEluZm8gPSBhd2FpdCBob3N0LnNoYXJlZEhhbmRsZXIuaG9va3MubGlmZWN5Y2xlLmFmdGVyUmVzb2x2ZS5lbWl0KHBvbHlmaWxscy5fZXh0ZW5kcyh7XG4gICAgICAgICAgICBpZDogaWRSZXNcbiAgICAgICAgfSwgcmVtb3RlU3BsaXRJbmZvLCB7XG4gICAgICAgICAgICBvcHRpb25zOiBob3N0Lm9wdGlvbnMsXG4gICAgICAgICAgICBvcmlnaW46IGhvc3QsXG4gICAgICAgICAgICByZW1vdGVJbmZvXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgeyByZW1vdGUsIGV4cG9zZSB9ID0gbWF0Y2hJbmZvO1xuICAgICAgICBzaGFyZS5hc3NlcnQocmVtb3RlICYmIGV4cG9zZSwgYFRoZSAnYmVmb3JlUmVxdWVzdCcgaG9vayB3YXMgZXhlY3V0ZWQsIGJ1dCBpdCBmYWlsZWQgdG8gcmV0dXJuIHRoZSBjb3JyZWN0ICdyZW1vdGUnIGFuZCAnZXhwb3NlJyB2YWx1ZXMgd2hpbGUgbG9hZGluZyAke2lkUmVzfS5gKTtcbiAgICAgICAgbGV0IG1vZHVsZSA9IGhvc3QubW9kdWxlQ2FjaGUuZ2V0KHJlbW90ZS5uYW1lKTtcbiAgICAgICAgY29uc3QgbW9kdWxlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICAgICAgICByZW1vdGVJbmZvXG4gICAgICAgIH07XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgICBtb2R1bGUgPSBuZXcgTW9kdWxlKG1vZHVsZU9wdGlvbnMpO1xuICAgICAgICAgICAgaG9zdC5tb2R1bGVDYWNoZS5zZXQocmVtb3RlLm5hbWUsIG1vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZHVsZSxcbiAgICAgICAgICAgIG1vZHVsZU9wdGlvbnMsXG4gICAgICAgICAgICByZW1vdGVNYXRjaEluZm86IG1hdGNoSW5mb1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlclJlbW90ZShyZW1vdGUsIHRhcmdldFJlbW90ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBub3JtYWxpemVSZW1vdGUgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKHJlbW90ZS5hbGlhcykge1xuICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIGlmIGFsaWFzIGVxdWFscyB0aGUgcHJlZml4IG9mIHJlbW90ZS5uYW1lIGFuZCByZW1vdGUuYWxpYXMsIGlmIHNvLCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIEFzIG11bHRpLWxldmVsIHBhdGggcmVmZXJlbmNlcyBjYW5ub3QgZ3VhcmFudGVlIHVuaXF1ZSBuYW1lcywgYWxpYXMgYmVpbmcgYSBwcmVmaXggb2YgcmVtb3RlLm5hbWUgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmRFcXVhbCA9IHRhcmdldFJlbW90ZXMuZmluZCgoaXRlbSk9PntcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVtX2FsaWFzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3RlLmFsaWFzICYmIChpdGVtLm5hbWUuc3RhcnRzV2l0aChyZW1vdGUuYWxpYXMpIHx8ICgoX2l0ZW1fYWxpYXMgPSBpdGVtLmFsaWFzKSA9PSBudWxsID8gdm9pZCAwIDogX2l0ZW1fYWxpYXMuc3RhcnRzV2l0aChyZW1vdGUuYWxpYXMpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2hhcmUuYXNzZXJ0KCFmaW5kRXF1YWwsIGBUaGUgYWxpYXMgJHtyZW1vdGUuYWxpYXN9IG9mIHJlbW90ZSAke3JlbW90ZS5uYW1lfSBpcyBub3QgYWxsb3dlZCB0byBiZSB0aGUgcHJlZml4IG9mICR7ZmluZEVxdWFsICYmIGZpbmRFcXVhbC5uYW1lfSBuYW1lIG9yIGFsaWFzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHJlbW90ZSBlbnRyeSB0byBhIGNvbXBsZXRlIHBhdGhcbiAgICAgICAgICAgIGlmICgnZW50cnknIGluIHJlbW90ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZGsuaXNCcm93c2VyRW52KCkgJiYgIXJlbW90ZS5lbnRyeS5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlLmVudHJ5ID0gbmV3IFVSTChyZW1vdGUuZW50cnksIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pLmhyZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZW1vdGUuc2hhcmVTY29wZSkge1xuICAgICAgICAgICAgICAgIHJlbW90ZS5zaGFyZVNjb3BlID0gc2hhcmUuREVGQVVMVF9TQ09QRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVtb3RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdGUudHlwZSA9IHNoYXJlLkRFRkFVTFRfUkVNT1RFX1RZUEU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZVJlZ2lzdGVyUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgb3JpZ2luOiBob3N0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZWdpc3RlcmVkUmVtb3RlID0gdGFyZ2V0UmVtb3Rlcy5maW5kKChpdGVtKT0+aXRlbS5uYW1lID09PSByZW1vdGUubmFtZSk7XG4gICAgICAgIGlmICghcmVnaXN0ZXJlZFJlbW90ZSkge1xuICAgICAgICAgICAgbm9ybWFsaXplUmVtb3RlKCk7XG4gICAgICAgICAgICB0YXJnZXRSZW1vdGVzLnB1c2gocmVtb3RlKTtcbiAgICAgICAgICAgIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlZ2lzdGVyUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgYFRoZSByZW1vdGUgXCIke3JlbW90ZS5uYW1lfVwiIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5gLFxuICAgICAgICAgICAgICAgIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZvcmNlKSA/ICdIb3BlIHlvdSBoYXZlIGtub3duIHRoYXQgT1ZFUlJJREUgaXQgbWF5IGhhdmUgc29tZSB1bmV4cGVjdGVkIGVycm9ycycgOiAnSWYgeW91IHdhbnQgdG8gbWVyZ2UgdGhlIHJlbW90ZSwgeW91IGNhbiBzZXQgXCJmb3JjZTogdHJ1ZVwiLidcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5mb3JjZSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByZWdpc3RlcmVkIHJlbW90ZVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVtb3RlKHJlZ2lzdGVyZWRSZW1vdGUpO1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVJlbW90ZSgpO1xuICAgICAgICAgICAgICAgIHRhcmdldFJlbW90ZXMucHVzaChyZW1vdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlZ2lzdGVyUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICByZW1vdGUsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2RrLndhcm4obWVzc2FnZXMuam9pbignICcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVSZW1vdGUocmVtb3RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IHJlbW90ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUluZGV4ID0gaG9zdC5vcHRpb25zLnJlbW90ZXMuZmluZEluZGV4KChpdGVtKT0+aXRlbS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgIGlmIChyZW1vdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBob3N0Lm9wdGlvbnMucmVtb3Rlcy5zcGxpY2UocmVtb3RlSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9hZGVkTW9kdWxlID0gaG9zdC5tb2R1bGVDYWNoZS5nZXQocmVtb3RlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGxvYWRlZE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUluZm8gPSBsb2FkZWRNb2R1bGUucmVtb3RlSW5mbztcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSByZW1vdGVJbmZvLmVudHJ5R2xvYmFsTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsVGhpc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfT2JqZWN0X2dldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfT2JqZWN0X2dldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsVGhpcywga2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9PYmplY3RfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbFRoaXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVFbnRyeVVuaXF1ZUtleSA9IGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KGxvYWRlZE1vZHVsZS5yZW1vdGVJbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcmUuZ2xvYmFsTG9hZGluZ1tyZW1vdGVFbnRyeVVuaXF1ZUtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNoYXJlLmdsb2JhbExvYWRpbmdbcmVtb3RlRW50cnlVbmlxdWVLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBob3N0LnNuYXBzaG90SGFuZGxlci5tYW5pZmVzdENhY2hlLmRlbGV0ZShyZW1vdGVJbmZvLmVudHJ5KTtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgdW5sb2FkZWQgc2hhcmVkIGFuZCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGxldCByZW1vdGVJbnNJZCA9IHJlbW90ZUluZm8uYnVpbGRWZXJzaW9uID8gc2RrLmNvbXBvc2VLZXlXaXRoU2VwYXJhdG9yKHJlbW90ZUluZm8ubmFtZSwgcmVtb3RlSW5mby5idWlsZFZlcnNpb24pIDogcmVtb3RlSW5mby5uYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUluc0luZGV4ID0gZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0lOU1RBTkNFU19fLmZpbmRJbmRleCgoaW5zKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3RlSW5mby5idWlsZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnMub3B0aW9ucy5pZCA9PT0gcmVtb3RlSW5zSWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zLm5hbWUgPT09IHJlbW90ZUluc0lkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZUluc0luZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVJbnMgPSBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX19bcmVtb3RlSW5zSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVJbnNJZCA9IHJlbW90ZUlucy5vcHRpb25zLmlkIHx8IHJlbW90ZUluc0lkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnbG9iYWxTaGFyZVNjb3BlTWFwID0gc2hhcmUuZ2V0R2xvYmFsU2hhcmVTY29wZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNBbGxTaGFyZWROb3RVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZERlbGV0ZUtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZ2xvYmFsU2hhcmVTY29wZU1hcCkuZm9yRWFjaCgoaW5zdElkKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVTY29wZU1hcCA9IGdsb2JhbFNoYXJlU2NvcGVNYXBbaW5zdElkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlU2NvcGVNYXAgJiYgT2JqZWN0LmtleXMoc2hhcmVTY29wZU1hcCkuZm9yRWFjaCgoc2hhcmVTY29wZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZVNjb3BlVmFsID0gc2hhcmVTY29wZU1hcFtzaGFyZVNjb3BlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlVmFsICYmIE9iamVjdC5rZXlzKHNoYXJlU2NvcGVWYWwpLmZvckVhY2goKHNoYXJlTmFtZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkUGtncyA9IHNoYXJlU2NvcGVWYWxbc2hhcmVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkUGtncyAmJiBPYmplY3Qua2V5cyhzaGFyZWRQa2dzKS5mb3JFYWNoKChzaGFyZVZlcnNpb24pPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZWQgPSBzaGFyZWRQa2dzW3NoYXJlVmVyc2lvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkICYmIHR5cGVvZiBzaGFyZWQgPT09ICdvYmplY3QnICYmIHNoYXJlZC5mcm9tID09PSByZW1vdGVJbmZvLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkLmxvYWRlZCB8fCBzaGFyZWQubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWQudXNlSW4gPSBzaGFyZWQudXNlSW4uZmlsdGVyKCh1c2VkSG9zdE5hbWUpPT51c2VkSG9zdE5hbWUgIT09IHJlbW90ZUluZm8ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZWQudXNlSW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FsbFNoYXJlZE5vdFVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWREZWxldGVLZXlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZERlbGV0ZUtleXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVWZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FsbFNoYXJlZE5vdFVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUlucy5zaGFyZVNjb3BlTWFwID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZ2xvYmFsU2hhcmVTY29wZU1hcFtyZW1vdGVJbnNJZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmVlZERlbGV0ZUtleXMuZm9yRWFjaCgoW2luc0lkLCBzaGFyZVNjb3BlLCBzaGFyZU5hbWUsIHNoYXJlVmVyc2lvbl0pPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWRfc2hhcmVTY29wZV9zaGFyZU5hbWUsIF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGUsIF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkID0gZ2xvYmFsU2hhcmVTY29wZU1hcFtpbnNJZF0pID09IG51bGwgPyB0cnVlIDogKF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGUgPSBfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZFtzaGFyZVNjb3BlXSkgPT0gbnVsbCA/IHRydWUgOiAoX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWRfc2hhcmVTY29wZV9zaGFyZU5hbWUgPSBfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZF9zaGFyZVNjb3BlW3NoYXJlTmFtZV0pID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGVfc2hhcmVOYW1lW3NoYXJlVmVyc2lvbl07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX18uc3BsaWNlKHJlbW90ZUluc0luZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBob3N0R2xvYmFsU25hcHNob3QgfSA9IGdldEdsb2JhbFJlbW90ZUluZm8ocmVtb3RlLCBob3N0KTtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdEdsb2JhbFNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUtleSA9IGhvc3RHbG9iYWxTbmFwc2hvdCAmJiAncmVtb3Rlc0luZm8nIGluIGhvc3RHbG9iYWxTbmFwc2hvdCAmJiBob3N0R2xvYmFsU25hcHNob3QucmVtb3Rlc0luZm8gJiYgc2hhcmUuZ2V0SW5mb1dpdGhvdXRUeXBlKGhvc3RHbG9iYWxTbmFwc2hvdC5yZW1vdGVzSW5mbywgcmVtb3RlLm5hbWUpLmtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW90ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhvc3RHbG9iYWxTbmFwc2hvdC5yZW1vdGVzSW5mb1tyZW1vdGVLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLWJvb2xlYW4tY2FzdFxuICAgICAgICAgICAgICAgICAgICAgICAgQm9vbGVhbihzaGFyZS5HbG9iYWwuX19GRURFUkFUSU9OX18uX19NQU5JRkVTVF9MT0FESU5HX19bcmVtb3RlS2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2hhcmUuR2xvYmFsLl9fRkVERVJBVElPTl9fLl9fTUFOSUZFU1RfTE9BRElOR19fW3JlbW90ZUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9zdC5tb2R1bGVDYWNoZS5kZWxldGUocmVtb3RlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZW1vdmVSZW1vdGUgZmFpbDogJywgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihob3N0KXtcbiAgICAgICAgdGhpcy5ob29rcyA9IG5ldyBQbHVnaW5TeXN0ZW0oe1xuICAgICAgICAgICAgYmVmb3JlUmVnaXN0ZXJSZW1vdGU6IG5ldyBTeW5jV2F0ZXJmYWxsSG9vaygnYmVmb3JlUmVnaXN0ZXJSZW1vdGUnKSxcbiAgICAgICAgICAgIHJlZ2lzdGVyUmVtb3RlOiBuZXcgU3luY1dhdGVyZmFsbEhvb2soJ3JlZ2lzdGVyUmVtb3RlJyksXG4gICAgICAgICAgICBiZWZvcmVSZXF1ZXN0OiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKCdiZWZvcmVSZXF1ZXN0JyksXG4gICAgICAgICAgICBvbkxvYWQ6IG5ldyBBc3luY0hvb2soJ29uTG9hZCcpLFxuICAgICAgICAgICAgaGFuZGxlUHJlbG9hZE1vZHVsZTogbmV3IFN5bmNIb29rKCdoYW5kbGVQcmVsb2FkTW9kdWxlJyksXG4gICAgICAgICAgICBlcnJvckxvYWRSZW1vdGU6IG5ldyBBc3luY0hvb2soJ2Vycm9yTG9hZFJlbW90ZScpLFxuICAgICAgICAgICAgYmVmb3JlUHJlbG9hZFJlbW90ZTogbmV3IEFzeW5jSG9vaygnYmVmb3JlUHJlbG9hZFJlbW90ZScpLFxuICAgICAgICAgICAgZ2VuZXJhdGVQcmVsb2FkQXNzZXRzOiBuZXcgQXN5bmNIb29rKCdnZW5lcmF0ZVByZWxvYWRBc3NldHMnKSxcbiAgICAgICAgICAgIC8vIG5vdCB1c2VkIHlldFxuICAgICAgICAgICAgYWZ0ZXJQcmVsb2FkUmVtb3RlOiBuZXcgQXN5bmNIb29rKCksXG4gICAgICAgICAgICBsb2FkRW50cnk6IG5ldyBBc3luY0hvb2soKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5pZFRvUmVtb3RlTWFwID0ge307XG4gICAgfVxufVxuXG5jbGFzcyBGZWRlcmF0aW9uSG9zdCB7XG4gICAgaW5pdE9wdGlvbnModXNlck9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlclBsdWdpbnModXNlck9wdGlvbnMucGx1Z2lucyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmZvcm1hdE9wdGlvbnModGhpcy5vcHRpb25zLCB1c2VyT3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBhc3luYyBsb2FkU2hhcmUocGtnTmFtZSwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXJlZEhhbmRsZXIubG9hZFNoYXJlKHBrZ05hbWUsIGV4dHJhT3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFRoZSBsaWIgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGF2YWlsYWJsZSBpZiB0aGUgc2hhcmVkIHNldCBieSBlYWdlciBvciBydW50aW1lIGluaXQgaXMgc2V0IG9yIHRoZSBzaGFyZWQgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICAvLyAxLiBJZiB0aGUgbG9hZGVkIHNoYXJlZCBhbHJlYWR5IGV4aXN0cyBnbG9iYWxseSwgdGhlbiBpdCB3aWxsIGJlIHJldXNlZFxuICAgIC8vIDIuIElmIGxpYiBleGlzdHMgaW4gbG9jYWwgc2hhcmVkLCBpdCB3aWxsIGJlIHVzZWQgZGlyZWN0bHlcbiAgICAvLyAzLiBJZiB0aGUgbG9jYWwgZ2V0IHJldHVybnMgc29tZXRoaW5nIG90aGVyIHRoYW4gUHJvbWlzZSwgdGhlbiBpdCB3aWxsIGJlIHVzZWQgZGlyZWN0bHlcbiAgICBsb2FkU2hhcmVTeW5jKHBrZ05hbWUsIGV4dHJhT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZWRIYW5kbGVyLmxvYWRTaGFyZVN5bmMocGtnTmFtZSwgZXh0cmFPcHRpb25zKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVNoYXJpbmcoc2hhcmVTY29wZU5hbWUgPSBzaGFyZS5ERUZBVUxUX1NDT1BFLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVkSGFuZGxlci5pbml0aWFsaXplU2hhcmluZyhzaGFyZVNjb3BlTmFtZSwgZXh0cmFPcHRpb25zKTtcbiAgICB9XG4gICAgaW5pdFJhd0NvbnRhaW5lcihuYW1lLCB1cmwsIGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gZ2V0UmVtb3RlSW5mbyh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZW50cnk6IHVybFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gbmV3IE1vZHVsZSh7XG4gICAgICAgICAgICBob3N0OiB0aGlzLFxuICAgICAgICAgICAgcmVtb3RlSW5mb1xuICAgICAgICB9KTtcbiAgICAgICAgbW9kdWxlLnJlbW90ZUVudHJ5RXhwb3J0cyA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5tb2R1bGVDYWNoZS5zZXQobmFtZSwgbW9kdWxlKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgIGFzeW5jIGxvYWRSZW1vdGUoaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlSGFuZGxlci5sb2FkUmVtb3RlKGlkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9tZW1iZXItb3JkZXJpbmdcbiAgICBhc3luYyBwcmVsb2FkUmVtb3RlKHByZWxvYWRPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZUhhbmRsZXIucHJlbG9hZFJlbW90ZShwcmVsb2FkT3B0aW9ucyk7XG4gICAgfVxuICAgIGluaXRTaGFyZVNjb3BlTWFwKHNjb3BlTmFtZSwgc2hhcmVTY29wZSwgZXh0cmFPcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5zaGFyZWRIYW5kbGVyLmluaXRTaGFyZVNjb3BlTWFwKHNjb3BlTmFtZSwgc2hhcmVTY29wZSwgZXh0cmFPcHRpb25zKTtcbiAgICB9XG4gICAgZm9ybWF0T3B0aW9ucyhnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHNoYXJlZCB9ID0gc2hhcmUuZm9ybWF0U2hhcmVDb25maWdzKGdsb2JhbE9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyB1c2VyT3B0aW9uczogdXNlck9wdGlvbnNSZXMsIG9wdGlvbnM6IGdsb2JhbE9wdGlvbnNSZXMgfSA9IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZUluaXQuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW46IHRoaXMsXG4gICAgICAgICAgICB1c2VyT3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnM6IGdsb2JhbE9wdGlvbnMsXG4gICAgICAgICAgICBzaGFyZUluZm86IHNoYXJlZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVtb3RlcyA9IHRoaXMucmVtb3RlSGFuZGxlci5mb3JtYXRBbmRSZWdpc3RlclJlbW90ZShnbG9iYWxPcHRpb25zUmVzLCB1c2VyT3B0aW9uc1Jlcyk7XG4gICAgICAgIGNvbnN0IHsgc2hhcmVkOiBoYW5kbGVkU2hhcmVkIH0gPSB0aGlzLnNoYXJlZEhhbmRsZXIucmVnaXN0ZXJTaGFyZWQoZ2xvYmFsT3B0aW9uc1JlcywgdXNlck9wdGlvbnNSZXMpO1xuICAgICAgICBjb25zdCBwbHVnaW5zID0gW1xuICAgICAgICAgICAgLi4uZ2xvYmFsT3B0aW9uc1Jlcy5wbHVnaW5zXG4gICAgICAgIF07XG4gICAgICAgIGlmICh1c2VyT3B0aW9uc1Jlcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICB1c2VyT3B0aW9uc1Jlcy5wbHVnaW5zLmZvckVhY2goKHBsdWdpbik9PntcbiAgICAgICAgICAgICAgICBpZiAoIXBsdWdpbnMuaW5jbHVkZXMocGx1Z2luKSkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zUmVzID0gcG9seWZpbGxzLl9leHRlbmRzKHt9LCBnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucywge1xuICAgICAgICAgICAgcGx1Z2lucyxcbiAgICAgICAgICAgIHJlbW90ZXMsXG4gICAgICAgICAgICBzaGFyZWQ6IGhhbmRsZWRTaGFyZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaG9va3MubGlmZWN5Y2xlLmluaXQuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW46IHRoaXMsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zUmVzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0aW9uc1JlcztcbiAgICB9XG4gICAgcmVnaXN0ZXJQbHVnaW5zKHBsdWdpbnMpIHtcbiAgICAgICAgY29uc3QgcGx1Z2luUmVzID0gcmVnaXN0ZXJQbHVnaW5zJDEocGx1Z2lucywgW1xuICAgICAgICAgICAgdGhpcy5ob29rcyxcbiAgICAgICAgICAgIHRoaXMucmVtb3RlSGFuZGxlci5ob29rcyxcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkSGFuZGxlci5ob29rcyxcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3RIYW5kbGVyLmhvb2tzLFxuICAgICAgICAgICAgdGhpcy5sb2FkZXJIb29rXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBNZXJnZSBwbHVnaW5cbiAgICAgICAgdGhpcy5vcHRpb25zLnBsdWdpbnMgPSB0aGlzLm9wdGlvbnMucGx1Z2lucy5yZWR1Y2UoKHJlcywgcGx1Z2luKT0+e1xuICAgICAgICAgICAgaWYgKCFwbHVnaW4pIHJldHVybiByZXM7XG4gICAgICAgICAgICBpZiAocmVzICYmICFyZXMuZmluZCgoaXRlbSk9Pml0ZW0ubmFtZSA9PT0gcGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIHBsdWdpblJlcyB8fCBbXSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVtb3RlcyhyZW1vdGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZUhhbmRsZXIucmVnaXN0ZXJSZW1vdGVzKHJlbW90ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih1c2VyT3B0aW9ucyl7XG4gICAgICAgIHRoaXMuaG9va3MgPSBuZXcgUGx1Z2luU3lzdGVtKHtcbiAgICAgICAgICAgIGJlZm9yZUluaXQ6IG5ldyBTeW5jV2F0ZXJmYWxsSG9vaygnYmVmb3JlSW5pdCcpLFxuICAgICAgICAgICAgaW5pdDogbmV3IFN5bmNIb29rKCksXG4gICAgICAgICAgICAvLyBtYXliZSB3aWxsIGNoYW5nZSwgdGVtcG9yYXJpbHkgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICAgICAgICBiZWZvcmVJbml0Q29udGFpbmVyOiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKCdiZWZvcmVJbml0Q29udGFpbmVyJyksXG4gICAgICAgICAgICAvLyBtYXliZSB3aWxsIGNoYW5nZSwgdGVtcG9yYXJpbHkgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICAgICAgICBpbml0Q29udGFpbmVyOiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKCdpbml0Q29udGFpbmVyJylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFwiMC42LjRcIjtcbiAgICAgICAgdGhpcy5tb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sb2FkZXJIb29rID0gbmV3IFBsdWdpblN5c3RlbSh7XG4gICAgICAgICAgICAvLyBGSVhNRTogbWF5IG5vdCBiZSBzdWl0YWJsZSAsIG5vdCBvcGVuIHRvIHRoZSBwdWJsaWMgeWV0XG4gICAgICAgICAgICBnZXRNb2R1bGVJbmZvOiBuZXcgU3luY0hvb2soKSxcbiAgICAgICAgICAgIGNyZWF0ZVNjcmlwdDogbmV3IFN5bmNIb29rKCksXG4gICAgICAgICAgICBjcmVhdGVMaW5rOiBuZXcgU3luY0hvb2soKSxcbiAgICAgICAgICAgIC8vIG9ubHkgd29yayBmb3IgbWFuaWZlc3QgLCBzbyBub3Qgb3BlbiB0byB0aGUgcHVibGljIHlldFxuICAgICAgICAgICAgZmV0Y2g6IG5ldyBBc3luY0hvb2soKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhlIGRldGFpbHMgb2YgdGhlIG9wdGlvbnNcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBvcHRpb25zIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpZDogc2hhcmUuZ2V0QnVpbGRlcklkKCksXG4gICAgICAgICAgICBuYW1lOiB1c2VyT3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIHNuYXBzaG90UGx1Z2luKCksXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVQcmVsb2FkQXNzZXRzUGx1Z2luKClcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICByZW1vdGVzOiBbXSxcbiAgICAgICAgICAgIHNoYXJlZDoge30sXG4gICAgICAgICAgICBpbkJyb3dzZXI6IHNkay5pc0Jyb3dzZXJFbnYoKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWUgPSB1c2VyT3B0aW9ucy5uYW1lO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgdGhpcy5zbmFwc2hvdEhhbmRsZXIgPSBuZXcgU25hcHNob3RIYW5kbGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnNoYXJlZEhhbmRsZXIgPSBuZXcgU2hhcmVkSGFuZGxlcih0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdGVIYW5kbGVyID0gbmV3IFJlbW90ZUhhbmRsZXIodGhpcyk7XG4gICAgICAgIHRoaXMuc2hhcmVTY29wZU1hcCA9IHRoaXMuc2hhcmVkSGFuZGxlci5zaGFyZVNjb3BlTWFwO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUGx1Z2lucyhbXG4gICAgICAgICAgICAuLi5kZWZhdWx0T3B0aW9ucy5wbHVnaW5zLFxuICAgICAgICAgICAgLi4udXNlck9wdGlvbnMucGx1Z2lucyB8fCBbXVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5mb3JtYXRPcHRpb25zKGRlZmF1bHRPcHRpb25zLCB1c2VyT3B0aW9ucyk7XG4gICAgfVxufVxuXG5sZXQgRmVkZXJhdGlvbkluc3RhbmNlID0gbnVsbDtcbmZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgIC8vIFJldHJpZXZlIHRoZSBzYW1lIGluc3RhbmNlIHdpdGggdGhlIHNhbWUgbmFtZVxuICAgIGNvbnN0IGluc3RhbmNlID0gc2hhcmUuZ2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlKG9wdGlvbnMubmFtZSwgb3B0aW9ucy52ZXJzaW9uKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgIC8vIFJldHJpZXZlIGRlYnVnIGNvbnN0cnVjdG9yXG4gICAgICAgIGNvbnN0IEZlZGVyYXRpb25Db25zdHJ1Y3RvciA9IHNoYXJlLmdldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvcigpIHx8IEZlZGVyYXRpb25Ib3N0O1xuICAgICAgICBGZWRlcmF0aW9uSW5zdGFuY2UgPSBuZXcgRmVkZXJhdGlvbkNvbnN0cnVjdG9yKG9wdGlvbnMpO1xuICAgICAgICBzaGFyZS5zZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UoRmVkZXJhdGlvbkluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIEZlZGVyYXRpb25JbnN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZXJnZSBvcHRpb25zXG4gICAgICAgIGluc3RhbmNlLmluaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIUZlZGVyYXRpb25JbnN0YW5jZSkge1xuICAgICAgICAgICAgRmVkZXJhdGlvbkluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvYWRSZW1vdGUoLi4uYXJncykge1xuICAgIHNoYXJlLmFzc2VydChGZWRlcmF0aW9uSW5zdGFuY2UsICdQbGVhc2UgY2FsbCBpbml0IGZpcnN0Jyk7XG4gICAgY29uc3QgbG9hZFJlbW90ZTEgPSBGZWRlcmF0aW9uSW5zdGFuY2UubG9hZFJlbW90ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgIHJldHVybiBsb2FkUmVtb3RlMS5hcHBseShGZWRlcmF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xufVxuZnVuY3Rpb24gbG9hZFNoYXJlKC4uLmFyZ3MpIHtcbiAgICBzaGFyZS5hc3NlcnQoRmVkZXJhdGlvbkluc3RhbmNlLCAnUGxlYXNlIGNhbGwgaW5pdCBmaXJzdCcpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgY29uc3QgbG9hZFNoYXJlMSA9IEZlZGVyYXRpb25JbnN0YW5jZS5sb2FkU2hhcmU7XG4gICAgcmV0dXJuIGxvYWRTaGFyZTEuYXBwbHkoRmVkZXJhdGlvbkluc3RhbmNlLCBhcmdzKTtcbn1cbmZ1bmN0aW9uIGxvYWRTaGFyZVN5bmMoLi4uYXJncykge1xuICAgIHNoYXJlLmFzc2VydChGZWRlcmF0aW9uSW5zdGFuY2UsICdQbGVhc2UgY2FsbCBpbml0IGZpcnN0Jyk7XG4gICAgY29uc3QgbG9hZFNoYXJlU3luYzEgPSBGZWRlcmF0aW9uSW5zdGFuY2UubG9hZFNoYXJlU3luYztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgIHJldHVybiBsb2FkU2hhcmVTeW5jMS5hcHBseShGZWRlcmF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xufVxuZnVuY3Rpb24gcHJlbG9hZFJlbW90ZSguLi5hcmdzKSB7XG4gICAgc2hhcmUuYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgJ1BsZWFzZSBjYWxsIGluaXQgZmlyc3QnKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgIHJldHVybiBGZWRlcmF0aW9uSW5zdGFuY2UucHJlbG9hZFJlbW90ZS5hcHBseShGZWRlcmF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJSZW1vdGVzKC4uLmFyZ3MpIHtcbiAgICBzaGFyZS5hc3NlcnQoRmVkZXJhdGlvbkluc3RhbmNlLCAnUGxlYXNlIGNhbGwgaW5pdCBmaXJzdCcpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIEZlZGVyYXRpb25JbnN0YW5jZS5yZWdpc3RlclJlbW90ZXMuYXBwbHkoRmVkZXJhdGlvbkluc3RhbmNlLCBhcmdzKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgc2hhcmUuYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgJ1BsZWFzZSBjYWxsIGluaXQgZmlyc3QnKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgIHJldHVybiBGZWRlcmF0aW9uSW5zdGFuY2UucmVnaXN0ZXJQbHVnaW5zLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiBnZXRJbnN0YW5jZSgpIHtcbiAgICByZXR1cm4gRmVkZXJhdGlvbkluc3RhbmNlO1xufVxuLy8gSW5qZWN0IGZvciBkZWJ1Z1xuc2hhcmUuc2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yKEZlZGVyYXRpb25Ib3N0KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdsb2FkU2NyaXB0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNkay5sb2FkU2NyaXB0OyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbG9hZFNjcmlwdE5vZGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2RrLmxvYWRTY3JpcHROb2RlOyB9XG59KTtcbmV4cG9ydHMucmVnaXN0ZXJHbG9iYWxQbHVnaW5zID0gc2hhcmUucmVnaXN0ZXJHbG9iYWxQbHVnaW5zO1xuZXhwb3J0cy5GZWRlcmF0aW9uSG9zdCA9IEZlZGVyYXRpb25Ib3N0O1xuZXhwb3J0cy5Nb2R1bGUgPSBNb2R1bGU7XG5leHBvcnRzLmdldEluc3RhbmNlID0gZ2V0SW5zdGFuY2U7XG5leHBvcnRzLmdldFJlbW90ZUVudHJ5ID0gZ2V0UmVtb3RlRW50cnk7XG5leHBvcnRzLmdldFJlbW90ZUluZm8gPSBnZXRSZW1vdGVJbmZvO1xuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9hZFJlbW90ZSA9IGxvYWRSZW1vdGU7XG5leHBvcnRzLmxvYWRTaGFyZSA9IGxvYWRTaGFyZTtcbmV4cG9ydHMubG9hZFNoYXJlU3luYyA9IGxvYWRTaGFyZVN5bmM7XG5leHBvcnRzLnByZWxvYWRSZW1vdGUgPSBwcmVsb2FkUmVtb3RlO1xuZXhwb3J0cy5yZWdpc3RlclBsdWdpbnMgPSByZWdpc3RlclBsdWdpbnM7XG5leHBvcnRzLnJlZ2lzdGVyUmVtb3RlcyA9IHJlZ2lzdGVyUmVtb3RlcztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBvbHlmaWxscyIsInJlcXVpcmUiLCJzZGsiLCJzaGFyZSIsIm1hdGNoUmVtb3RlV2l0aE5hbWVBbmRFeHBvc2UiLCJyZW1vdGVzIiwiaWQiLCJyZW1vdGUiLCJpc05hbWVNYXRjaGVkIiwic3RhcnRzV2l0aCIsIm5hbWUiLCJleHBvc2UiLCJyZXBsYWNlIiwicGtnTmFtZU9yQWxpYXMiLCJpc0FsaWFzTWF0Y2hlZCIsImFsaWFzIiwiZXhwb3NlV2l0aEFsaWFzIiwibWF0Y2hSZW1vdGUiLCJuYW1lT3JBbGlhcyIsInJlZ2lzdGVyUGx1Z2lucyQxIiwicGx1Z2lucyIsImhvb2tJbnN0YW5jZXMiLCJnbG9iYWxQbHVnaW5zIiwiZ2V0R2xvYmFsSG9zdFBsdWdpbnMiLCJsZW5ndGgiLCJmb3JFYWNoIiwicGx1Z2luIiwiZmluZCIsIml0ZW0iLCJwdXNoIiwiaG9va0luc3RhbmNlIiwiYXBwbHlQbHVnaW4iLCJsb2FkRXNtRW50cnkiLCJlbnRyeSIsInJlbW90ZUVudHJ5RXhwb3J0cyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiRnVuY3Rpb24iLCJlIiwibG9hZFN5c3RlbUpzRW50cnkiLCJsb2FkRW50cnlTY3JpcHQiLCJnbG9iYWxOYW1lIiwiY3JlYXRlU2NyaXB0SG9vayIsImVudHJ5RXhwb3J0cyIsImdldFJlbW90ZUVudHJ5RXhwb3J0cyIsImxvYWRTY3JpcHQiLCJhdHRycyIsInVybCIsInJlcyIsImVtaXQiLCJIVE1MU2NyaXB0RWxlbWVudCIsInRoZW4iLCJyZW1vdGVFbnRyeUtleSIsImFzc2VydCIsImNhdGNoIiwibG9hZEVudHJ5RG9tIiwicmVtb3RlSW5mbyIsImVudHJ5R2xvYmFsTmFtZSIsInR5cGUiLCJsb2FkRW50cnlOb2RlIiwibG9hZFNjcmlwdE5vZGUiLCJnZXRSZW1vdGVFbnRyeVVuaXF1ZUtleSIsImNvbXBvc2VLZXlXaXRoU2VwYXJhdG9yIiwiZ2V0UmVtb3RlRW50cnkiLCJvcmlnaW4iLCJ1bmlxdWVLZXkiLCJnbG9iYWxMb2FkaW5nIiwibG9hZEVudHJ5SG9vayIsInJlbW90ZUhhbmRsZXIiLCJob29rcyIsImxpZmVjeWNsZSIsImxvYWRFbnRyeSIsImxpc3RlbmVycyIsInNpemUiLCJsb2FkZXJIb29rIiwiY3JlYXRlU2NyaXB0IiwidW5kZWZpbmVkIiwiaXNCcm93c2VyRW52IiwiZ2V0UmVtb3RlSW5mbyIsIl9leHRlbmRzIiwiREVGQVVMVF9SRU1PVEVfVFlQRSIsInNoYXJlU2NvcGUiLCJERUZBVUxUX1NDT1BFIiwiTW9kdWxlIiwiZ2V0RW50cnkiLCJob3N0Iiwic2FmZVRvU3RyaW5nIiwiZ2V0Iiwib3B0aW9ucyIsInJlbW90ZVNuYXBzaG90IiwibG9hZEZhY3RvcnkiLCJpbml0ZWQiLCJsb2NhbFNoYXJlU2NvcGVNYXAiLCJzaGFyZVNjb3BlTWFwIiwicmVtb3RlU2hhcmVTY29wZSIsImluaXRTY29wZSIsInJlbW90ZUVudHJ5SW5pdE9wdGlvbnMiLCJ2ZXJzaW9uIiwiZW51bWVyYWJsZSIsImluaXRDb250YWluZXJPcHRpb25zIiwiYmVmb3JlSW5pdENvbnRhaW5lciIsImluaXQiLCJjb25zb2xlIiwiZXJyb3IiLCJpbml0Q29udGFpbmVyIiwibGliIiwibW9kdWxlRmFjdG9yeSIsImdldEZNSWQiLCJ3cmFwTW9kdWxlRmFjdG9yeSIsIndyYXBlckZhY3RvcnkiLCJleHBvc2VDb250ZW50IiwiZGVmaW5lTW9kdWxlSWQiLCJpc0V4dGVuc2libGUiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJTeW1ib2wiLCJmb3IiLCJjb25zdHJ1Y3RvciIsIlN5bmNIb29rIiwib24iLCJmbiIsImFkZCIsIm9uY2UiLCJzZWxmIiwid3JhcHBlciIsImFyZ3MiLCJyZW1vdmUiLCJhcHBseSIsImRhdGEiLCJyZXN1bHQiLCJkZWxldGUiLCJyZW1vdmVBbGwiLCJjbGVhciIsIlNldCIsIkFzeW5jSG9vayIsImxzIiwiQXJyYXkiLCJmcm9tIiwiaSIsImNhbGwiLCJwcmV2IiwiY2hlY2tSZXR1cm5EYXRhIiwib3JpZ2luYWxEYXRhIiwicmV0dXJuZWREYXRhIiwiaXNPYmplY3QiLCJrZXkiLCJTeW5jV2F0ZXJmYWxsSG9vayIsInRlbXBEYXRhIiwib25lcnJvciIsIndhcm4iLCJBc3luY1dhdGVyZmFsbEhvb2siLCJwcm9jZXNzRXJyb3IiLCJwcmV2RGF0YSIsIlBsdWdpblN5c3RlbSIsImlzUGxhaW5PYmplY3QiLCJwbHVnaW5OYW1lIiwicmVnaXN0ZXJQbHVnaW5zIiwia2V5cyIsInBsdWdpbkxpZmUiLCJyZW1vdmVQbHVnaW4iLCJpbmhlcml0IiwiaG9va05hbWUiLCJsaWZlY3ljbGVLZXlzIiwiZGVmYXVsdFByZWxvYWRBcmdzIiwicHJlbG9hZENvbmZpZyIsInJlc291cmNlQ2F0ZWdvcnkiLCJkZXBzUmVtb3RlIiwicHJlZmV0Y2hJbnRlcmZhY2UiLCJmb3JtYXRQcmVsb2FkQXJncyIsInByZWxvYWRBcmdzIiwibWFwIiwibm9ybWFsaXplUHJlbG9hZEV4cG9zZXMiLCJleHBvc2VzIiwicHJlbG9hZEFzc2V0cyIsImFzc2V0cyIsInVzZUxpbmtQcmVsb2FkIiwiY3NzQXNzZXRzIiwianNBc3NldHNXaXRob3V0RW50cnkiLCJlbnRyeUFzc2V0cyIsImluQnJvd3NlciIsImFzc2V0IiwibW9kdWxlSW5mbyIsIm1vZHVsZSIsIm1vZHVsZUNhY2hlIiwiZGVmYXVsdEF0dHJzIiwicmVsIiwiYXMiLCJjcm9zc29yaWdpbiIsImNzc1VybCIsImxpbmsiLCJjc3NFbCIsIm5lZWRBdHRhY2giLCJjcmVhdGVMaW5rIiwiY2IiLCJjcmVhdGVMaW5rSG9vayIsIkhUTUxMaW5rRWxlbWVudCIsImRvY3VtZW50IiwiaGVhZCIsImFwcGVuZENoaWxkIiwibmVlZERlbGV0ZUxpbmsiLCJqc1VybCIsImxpbmtFbCIsImZldGNocHJpb3JpdHkiLCJzY3JpcHQiLCJzY3JpcHRFbCIsIm5lZWREZWxldGVTY3JpcHQiLCJhc3NpZ25SZW1vdGVJbmZvIiwicmVtb3RlRW50cnlJbmZvIiwiZ2V0UmVtb3RlRW50cnlJbmZvRnJvbVNuYXBzaG90IiwiZW50cnlVcmwiLCJnZXRSZXNvdXJjZVVybCIsImJ1aWxkVmVyc2lvbiIsInNuYXBzaG90UGx1Z2luIiwiYWZ0ZXJSZXNvbHZlIiwiaXNSZW1vdGVJbmZvV2l0aEVudHJ5IiwiaXNQdXJlUmVtb3RlRW50cnkiLCJnbG9iYWxTbmFwc2hvdCIsInNuYXBzaG90SGFuZGxlciIsImxvYWRSZW1vdGVTbmFwc2hvdEluZm8iLCJwcmVsb2FkT3B0aW9ucyIsImdlbmVyYXRlUHJlbG9hZEFzc2V0cyIsInNwbGl0SWQiLCJzcGxpdEluZm8iLCJzcGxpdCIsInRyYXZlcnNlTW9kdWxlSW5mbyIsInRyYXZlcnNlIiwiaXNSb290IiwibWVtbyIsInNuYXBzaG90VmFsdWUiLCJnZXRJbmZvV2l0aG91dFR5cGUiLCJlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdCIsImlzTWFuaWZlc3RQcm92aWRlciIsInJlbW90ZXNJbmZvIiwicmVtb3RlS2V5cyIsInN1YlJlbW90ZUluZm8iLCJyZW1vdGVWYWx1ZSIsIm1hdGNoZWRWZXJzaW9uIiwianNBc3NldHMiLCJsb2FkZWRTaGFyZWRKc0Fzc2V0cyIsImxvYWRlZFNoYXJlZENzc0Fzc2V0cyIsInJvb3RQcmVsb2FkQ29uZmlnIiwibW9kdWxlSW5mb1NuYXBzaG90IiwiaXNBcnJheSIsImZpbmRQcmVsb2FkQ29uZmlnIiwicmVtb3RlQ29uZmlnIiwicmVtb3RlRW50cnlVcmwiLCJyZW1vdGVFbnRyeVR5cGUiLCJtb2R1bGVBc3NldHNJbmZvIiwibW9kdWxlcyIsIm5vcm1hbGl6ZWRQcmVsb2FkRXhwb3NlcyIsIl9tb2R1bGVJbmZvU25hcHNob3RfbW9kdWxlcyIsInJlZHVjZSIsIm1vZHVsZUFzc2V0SW5mbyIsImluZGV4T2YiLCJtb2R1bGVOYW1lIiwiaGFuZGxlQXNzZXRzIiwiYXNzZXRzUmVzIiwiZmlsdGVyIiwiYXNzZXRzTGVuZ3RoIiwiaW5kZXgiLCJhc3NldHNJbmZvIiwiZXhwb3NlRnVsbFBhdGgiLCJoYW5kbGVQcmVsb2FkTW9kdWxlIiwicHJlbG9hZGVkIiwiZ2V0UHJlbG9hZGVkIiwiY3NzIiwiYXN5bmMiLCJzeW5jIiwianMiLCJzZXRQcmVsb2FkZWQiLCJzaGFyZWQiLCJjb2xsZWN0U2hhcmVkQXNzZXRzIiwic2hhcmVJbmZvIiwic25hcHNob3RTaGFyZWQiLCJyZWdpc3RlcmVkU2hhcmVkIiwiZ2V0UmVnaXN0ZXJlZFNoYXJlIiwic2hhcmVkTmFtZSIsInNoYXJlZEhhbmRsZXIiLCJyZXNvbHZlU2hhcmUiLCJfb3B0aW9uc19zaGFyZWQiLCJzaGFyZUluZm9zIiwic2hhcmVkT3B0aW9ucyIsInMiLCJhcnJheVNoYXJlSW5mbyIsImFycmF5T3B0aW9ucyIsIm5lZWRQcmVsb2FkSnNBc3NldHMiLCJoYXMiLCJuZWVkUHJlbG9hZENzc0Fzc2V0cyIsImdlbmVyYXRlUHJlbG9hZEFzc2V0c1BsdWdpbiIsImdldEdsb2JhbFJlbW90ZUluZm8iLCJob3N0R2xvYmFsU25hcHNob3QiLCJnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8iLCJnbG9iYWxSZW1vdGVJbmZvIiwiZ2V0R2xvYmFsU25hcHNob3QiLCJTbmFwc2hvdEhhbmRsZXIiLCJsb2FkU25hcHNob3QiLCJIb3N0SW5zdGFuY2UiLCJnbG9iYWxSZW1vdGVTbmFwc2hvdCIsImdsb2JhbFNuYXBzaG90UmVzIiwiYmVmb3JlTG9hZFJlbW90ZVNuYXBzaG90IiwiaG9zdFNuYXBzaG90IiwicmVtb3RlRW50cnkiLCJhZGRHbG9iYWxTbmFwc2hvdCIsInNzclJlbW90ZUVudHJ5IiwibW9kdWxlU25hcHNob3QiLCJnZXRNYW5pZmVzdEpzb24iLCJzZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8iLCJyZW1vdGVTbmFwc2hvdFJlcyIsImxvYWRSZW1vdGVTbmFwc2hvdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYW5pZmVzdFVybCIsImV4dHJhT3B0aW9ucyIsImdldE1hbmlmZXN0IiwibWFuaWZlc3RKc29uIiwibWFuaWZlc3RDYWNoZSIsImZldGNoIiwiUmVzcG9uc2UiLCJqc29uIiwibWV0YURhdGEiLCJzZXQiLCJlcnIiLCJtYW5pZmVzdExvYWRpbmciLCJhc3luY0xvYWRQcm9jZXNzIiwiZ2VuZXJhdGVTbmFwc2hvdEZyb21NYW5pZmVzdCIsImxvYWRpbmdIb3N0U25hcHNob3QiLCJNYXAiLCJHbG9iYWwiLCJfX0ZFREVSQVRJT05fXyIsIl9fTUFOSUZFU1RfTE9BRElOR19fIiwiU2hhcmVkSGFuZGxlciIsInJlZ2lzdGVyU2hhcmVkIiwiZ2xvYmFsT3B0aW9ucyIsInVzZXJPcHRpb25zIiwiZm9ybWF0U2hhcmVDb25maWdzIiwic2hhcmVkS2V5cyIsInNoYXJlZEtleSIsInNoYXJlZFZhbHMiLCJzaGFyZWRWYWwiLCJzZXRTaGFyZWQiLCJwa2dOYW1lIiwibG9hZGVkIiwibG9hZFNoYXJlIiwiZ2V0VGFyZ2V0U2hhcmVkT3B0aW9ucyIsInNjb3BlIiwiYWxsIiwiaW5pdGlhbGl6ZVNoYXJpbmciLCJzdHJhdGVneSIsImxvYWRTaGFyZVJlcyIsImJlZm9yZUxvYWRTaGFyZSIsInNoYXJlSW5mb1JlcyIsImFkZFVzZUluIiwidXNlSW4iLCJhZGRVbmlxdWVJdGVtIiwibG9hZGluZyIsImZhY3RvcnkiLCJnU2hhcmVkIiwiY3VzdG9tU2hhcmVJbmZvIiwic2hhcmVTY29wZU5hbWUiLCJwcm9taXNlcyIsImluaXRUb2tlbnMiLCJpbml0VG9rZW4iLCJob3N0TmFtZSIsInJlZ2lzdGVyIiwiX2FjdGl2ZVZlcnNpb25fc2hhcmVDb25maWciLCJlYWdlciIsInZlcnNpb25zIiwiYWN0aXZlVmVyc2lvbiIsImFjdGl2ZVZlcnNpb25FYWdlciIsIkJvb2xlYW4iLCJzaGFyZUNvbmZpZyIsImluaXRGbiIsIm1vZCIsImluaXRSZW1vdGVNb2R1bGUiLCJnZXRSZW1vdGVNb2R1bGVBbmRPcHRpb25zIiwic2hhcmVOYW1lIiwic2hhcmVkQXJyIiwiaW5jbHVkZXMiLCJzaGFyZVN0cmF0ZWd5IiwibG9hZFNoYXJlU3luYyIsIkVycm9yIiwiaW5pdFNoYXJlU2NvcGVNYXAiLCJzY29wZU5hbWUiLCJpbml0Q29udGFpbmVyU2hhcmVTY29wZU1hcCIsImhvc3RTaGFyZVNjb3BlTWFwIiwiX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UiLCJzY29wZXMiLCJzYyIsIl9zZXRHbG9iYWxTaGFyZVNjb3BlTWFwIiwiaG9zdE9wdGlvbnMiLCJnbG9iYWxTaGFyZVNjb3BlTWFwIiwiZ2V0R2xvYmFsU2hhcmVTY29wZSIsImlkZW50aWZpZXIiLCJSZW1vdGVIYW5kbGVyIiwiZm9ybWF0QW5kUmVnaXN0ZXJSZW1vdGUiLCJ1c2VyUmVtb3RlcyIsInJlZ2lzdGVyUmVtb3RlIiwiZm9yY2UiLCJzZXRJZFRvUmVtb3RlTWFwIiwicmVtb3RlTWF0Y2hJbmZvIiwiaWRUb1JlbW90ZU1hcCIsImlkV2l0aEFsaWFzIiwiaWRXaXRoTmFtZSIsImxvYWRSZW1vdGUiLCJtb2R1bGVPcHRpb25zIiwiaWRSZXMiLCJtb2R1bGVPckZhY3RvcnkiLCJtb2R1bGVXcmFwcGVyIiwib25Mb2FkIiwiZXhwb3NlTW9kdWxlIiwiZXhwb3NlTW9kdWxlRmFjdG9yeSIsIm1vZHVsZUluc3RhbmNlIiwiZmFpbE92ZXIiLCJlcnJvckxvYWRSZW1vdGUiLCJwcmVsb2FkUmVtb3RlIiwiYmVmb3JlUHJlbG9hZFJlbW90ZSIsInByZWxvYWRPcHMiLCJvcHMiLCJyZWdpc3RlclJlbW90ZXMiLCJsb2FkUmVtb3RlQXJncyIsImJlZm9yZVJlcXVlc3QiLCJyZW1vdGVTcGxpdEluZm8iLCJyYXdSZW1vdGUiLCJtYXRjaEluZm8iLCJ0YXJnZXRSZW1vdGVzIiwibm9ybWFsaXplUmVtb3RlIiwiZmluZEVxdWFsIiwiX2l0ZW1fYWxpYXMiLCJVUkwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJiZWZvcmVSZWdpc3RlclJlbW90ZSIsInJlZ2lzdGVyZWRSZW1vdGUiLCJtZXNzYWdlcyIsInJlbW92ZVJlbW90ZSIsImpvaW4iLCJyZW1vdGVJbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsImxvYWRlZE1vZHVsZSIsImdsb2JhbFRoaXMiLCJfT2JqZWN0X2dldE93blByb3BlcnR5RGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsInJlbW90ZUVudHJ5VW5pcXVlS2V5IiwicmVtb3RlSW5zSWQiLCJyZW1vdGVJbnNJbmRleCIsIl9fSU5TVEFOQ0VTX18iLCJpbnMiLCJyZW1vdGVJbnMiLCJpc0FsbFNoYXJlZE5vdFVzZWQiLCJuZWVkRGVsZXRlS2V5cyIsImluc3RJZCIsInNoYXJlU2NvcGVWYWwiLCJzaGFyZWRQa2dzIiwic2hhcmVWZXJzaW9uIiwidXNlZEhvc3ROYW1lIiwiaW5zSWQiLCJfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZF9zaGFyZVNjb3BlX3NoYXJlTmFtZSIsIl9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGUiLCJfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZCIsInJlbW90ZUtleSIsImxvZyIsImFmdGVyUHJlbG9hZFJlbW90ZSIsIkZlZGVyYXRpb25Ib3N0IiwiaW5pdE9wdGlvbnMiLCJmb3JtYXRPcHRpb25zIiwiaW5pdFJhd0NvbnRhaW5lciIsImNvbnRhaW5lciIsInVzZXJPcHRpb25zUmVzIiwiZ2xvYmFsT3B0aW9uc1JlcyIsImJlZm9yZUluaXQiLCJoYW5kbGVkU2hhcmVkIiwib3B0aW9uc1JlcyIsInBsdWdpblJlcyIsImdldE1vZHVsZUluZm8iLCJkZWZhdWx0T3B0aW9ucyIsImdldEJ1aWxkZXJJZCIsIkZlZGVyYXRpb25JbnN0YW5jZSIsImluc3RhbmNlIiwiZ2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlIiwiRmVkZXJhdGlvbkNvbnN0cnVjdG9yIiwiZ2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yIiwic2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlIiwibG9hZFJlbW90ZTEiLCJsb2FkU2hhcmUxIiwibG9hZFNoYXJlU3luYzEiLCJnZXRJbnN0YW5jZSIsInNldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvciIsInJlZ2lzdGVyR2xvYmFsUGx1Z2lucyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsY0FBYyxDQUFDQyxTQUFTLGNBQWM7SUFBRUMsT0FBTztBQUFLO0FBRTNELElBQUlDLFlBQVlDLFFBQVE7QUFDeEIsSUFBSUMsTUFBTUQsUUFBUTtBQUNsQixJQUFJRSxRQUFRRixRQUFRO0FBRXBCLHNEQUFzRDtBQUN0RCwyRUFBMkU7QUFDM0UsaURBQWlEO0FBQ2pE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