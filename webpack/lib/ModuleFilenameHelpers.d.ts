export const ALL_LOADERS_RESOURCE: string;
export const REGEXP_ALL_LOADERS_RESOURCE: RegExp;
export const LOADERS_RESOURCE: string;
export const REGEXP_LOADERS_RESOURCE: RegExp;
export const RESOURCE: string;
export const REGEXP_RESOURCE: RegExp;
export const ABSOLUTE_RESOURCE_PATH: string;
export const REGEXP_ABSOLUTE_RESOURCE_PATH: RegExp;
export const RESOURCE_PATH: string;
export const REGEXP_RESOURCE_PATH: RegExp;
export const ALL_LOADERS: string;
export const REGEXP_ALL_LOADERS: RegExp;
export const LOADERS: string;
export const REGEXP_LOADERS: RegExp;
export const QUERY: string;
export const REGEXP_QUERY: RegExp;
export const ID: string;
export const REGEXP_ID: RegExp;
export const HASH: string;
export const REGEXP_HASH: RegExp;
export const NAMESPACE: string;
export const REGEXP_NAMESPACE: RegExp;
/**
 *
 * @param {Module | string} module the module
 * @param {TODO} options options
 * @param {Object} contextInfo context info
 * @param {RequestShortener} contextInfo.requestShortener requestShortener
 * @param {ChunkGraph} contextInfo.chunkGraph chunk graph
 * @param {string | Hash} contextInfo.hashFunction the hash function to use
 * @returns {string} the filename
 */
export function createFilename(
  module: Module | string,
  options: TODO,
  {
    requestShortener,
    chunkGraph,
    hashFunction,
  }: {
    requestShortener: RequestShortener;
    chunkGraph: ChunkGraph;
    hashFunction: string | Hash;
  },
): string;
/**
 * Replaces duplicate items in an array with new values generated by a callback function.
 * The callback function is called with the duplicate item, the index of the duplicate item, and the number of times the item has been replaced.
 * The callback function should return the new value for the duplicate item.
 *
 * @template T
 * @param {T[]} array the array with duplicates to be replaced
 * @param {(duplicateItem: T, duplicateItemIndex: number, numberOfTimesReplaced: number) => T} fn callback function to generate new values for the duplicate items
 * @param {(firstElement:T, nextElement:T) => -1 | 0 | 1} [comparator] optional comparator function to sort the duplicate items
 * @returns {T[]} the array with duplicates replaced
 *
 * @example
 * ```js
 * const array = ["a", "b", "c", "a", "b", "a"];
 * const result = ModuleFilenameHelpers.replaceDuplicates(array, (item, index, count) => `${item}-${count}`);
 * // result: ["a-1", "b-1", "c", "a-2", "b-2", "a-3"]
 * ```
 */
export function replaceDuplicates<T>(
  array: T[],
  fn: (
    duplicateItem: T,
    duplicateItemIndex: number,
    numberOfTimesReplaced: number,
  ) => T,
  comparator?: (firstElement: T, nextElement: T) => -1 | 0 | 1,
): T[];
/**
 * Tests if a string matches a RegExp or an array of RegExp.
 *
 * @param {string} str string to test
 * @param {Matcher} test value which will be used to match against the string
 * @returns {boolean} true, when the RegExp matches
 *
 * @example
 * ```js
 * ModuleFilenameHelpers.matchPart("foo.js", "foo"); // true
 * ModuleFilenameHelpers.matchPart("foo.js", "foo.js"); // true
 * ModuleFilenameHelpers.matchPart("foo.js", "foo."); // false
 * ModuleFilenameHelpers.matchPart("foo.js", "foo*"); // false
 * ModuleFilenameHelpers.matchPart("foo.js", "foo.*"); // true
 * ModuleFilenameHelpers.matchPart("foo.js", /^foo/); // true
 * ModuleFilenameHelpers.matchPart("foo.js", [/^foo/, "bar"]); // true
 * ModuleFilenameHelpers.matchPart("foo.js", [/^foo/, "bar"]); // true
 * ModuleFilenameHelpers.matchPart("foo.js", [/^foo/, /^bar/]); // true
 * ModuleFilenameHelpers.matchPart("foo.js", [/^baz/, /^bar/]); // false
 * ```
 */
export function matchPart(str: string, test: Matcher): boolean;
/**
 * Tests if a string matches a match object. The match object can have the following properties:
 * - `test`: a RegExp or an array of RegExp
 * - `include`: a RegExp or an array of RegExp
 * - `exclude`: a RegExp or an array of RegExp
 *
 * The `test` property is tested first, then `include` and then `exclude`.
 *
 * @param {MatchObject} obj a match object to test against the string
 * @param {string} str string to test against the matching object
 * @returns {boolean} true, when the object matches
 * @example
 * ```js
 * ModuleFilenameHelpers.matchObject({ test: "foo.js" }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ test: /^foo/ }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ test: [/^foo/, "bar"] }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ test: [/^foo/, "bar"] }, "baz.js"); // false
 * ModuleFilenameHelpers.matchObject({ include: "foo.js" }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ include: "foo.js" }, "bar.js"); // false
 * ModuleFilenameHelpers.matchObject({ include: /^foo/ }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ include: [/^foo/, "bar"] }, "foo.js"); // true
 * ModuleFilenameHelpers.matchObject({ include: [/^foo/, "bar"] }, "baz.js"); // false
 * ModuleFilenameHelpers.matchObject({ exclude: "foo.js" }, "foo.js"); // false
 * ModuleFilenameHelpers.matchObject({ exclude: [/^foo/, "bar"] }, "foo.js"); // false
 * ```
 */
export function matchObject(obj: MatchObject, str: string): boolean;
export type ChunkGraph = import('./ChunkGraph');
export type Module = import('./Module');
export type RequestShortener = import('./RequestShortener');
export type Hash = typeof import('./util/Hash');
export type Matcher = string | RegExp | (string | RegExp)[];
export type MatchObject = {
  test?: Matcher;
  include?: Matcher;
  exclude?: Matcher;
};
