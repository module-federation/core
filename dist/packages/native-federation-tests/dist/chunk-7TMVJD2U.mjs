import m from"ansi-colors";import{rm as $}from"fs/promises";import{resolve as S}from"path";import{mergeDeepRight as U,mergeRight as D}from"rambda";import{build as A}from"tsup";import{createUnplugin as R}from"unplugin";var O={testsFolder:"@mf-tests",mocksFolder:"./__mocks__",deleteTestsFolder:!0},w=t=>{let e=t.split("@");return e[e.length-1]},v=(t,e)=>{let o=w(e),r=new URL(o),s=r.pathname.split("/").slice(0,-1).join("/");return r.pathname=`${s}/${t.testsFolder}.zip`,r.href},x=t=>Object.entries(t.moduleFederationConfig.remotes).reduce((e,[o,r])=>(e[o]=v(t,r),e),{}),c=t=>{if(!t.moduleFederationConfig)throw new Error("moduleFederationConfig is required");let e={...O,...t},o=x(e);return{hostOptions:e,mapRemotesToDownload:o}};import{existsSync as h}from"fs";import{join as d}from"path";var y={testsFolder:"@mf-tests",distFolder:"./dist",deleteTestsFolder:!0,additionalBundlerConfig:{}},C=["ts","tsx","js","jsx","mjs"],p=t=>{let e=process.cwd();for(let o of C){let r=d(e,`${t}.${o}`);if(h(r))return r}},T=t=>Object.entries(t.moduleFederationConfig.exposes).reduce((e,[o,r])=>(e[o]=p(r)||p(d(r,"index"))||r,e),{}),a=t=>{if(!t.moduleFederationConfig)throw new Error("moduleFederationConfig is required");let e={...y,...t},o=T(e),r=Object.keys(t.moduleFederationConfig.shared||{}).concat(Object.keys(t.moduleFederationConfig.remotes||{})),s=d(e.distFolder,e.testsFolder);return{remoteOptions:e,externalDeps:r,compiledFilesFolder:s,mapComponentsToExpose:o}};import l from"adm-zip";import b from"ansi-colors";import k from"axios";import{join as f}from"path";var H=t=>f(t.distFolder,`${t.testsFolder}.zip`),u=async(t,e)=>{let o=new l;return o.addLocalFolder(e),o.writeZipPromise(H(t))},j=(t,e)=>o=>{throw console.error(b.red(`Unable to download federated mocks for '${t}' from '${e}' because '${o.message}', skipping...`)),o},g=t=>async([e,o])=>{let r=await k.get(o,{responseType:"arraybuffer"}).catch(j(e,o)),s=f(t.mocksFolder,e);new l(Buffer.from(r.data)).extractAllTo(s,!0)};import{rm as E}from"fs/promises";import{join as q}from"path";var F=async(t,e)=>{let o=e.map(r=>{let s=q(t.mocksFolder,r);return E(s,{recursive:!0,force:!0})});return Promise.allSettled(o)};var ne=R(t=>{let{remoteOptions:e,compiledFilesFolder:o,externalDeps:r,mapComponentsToExpose:s}=a(t);return{name:"native-federation-tests/remote",async writeBundle(){let n=D(e.additionalBundlerConfig,{external:r.map(i=>new RegExp(`^${i}`)),entry:s,outDir:o,silent:!0});try{await A(n),await u(e,o),e.deleteTestsFolder&&await $(o,{recursive:!0,force:!0}),console.log(m.green("Federated mocks created correctly"))}catch(i){console.error(m.red(`Unable to build federated mocks: ${i}`))}},webpack:n=>{n.options.devServer=U(n.options.devServer||{},{static:{directory:S(e.distFolder)}})}}}),ie=R(t=>{let{hostOptions:e,mapRemotesToDownload:o}=c(t);return{name:"native-federation-tests/host",async writeBundle(){e.deleteTestsFolder&&await F(e,Object.keys(o));let r=g(e),s=Object.entries(o).map(r);await Promise.allSettled(s),console.log(m.green("Federated mocks extraction completed"))}}});export{ne as a,ie as b};
