"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var I=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,o)=>(typeof require<"u"?require:e)[o]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var _ansicolors = require('ansi-colors'); var _ansicolors2 = _interopRequireDefault(_ansicolors);var _promises = require('fs/promises');var _path = require('path');var _rambda = require('rambda');var _unplugin = require('unplugin');var U={typesFolder:"@mf-types",deleteTypesFolder:!0},L=t=>{let e=t.split("@");return e[e.length-1]},z=(t,e)=>{let o=L(e),r=new URL(o),s=r.pathname.split("/").slice(0,-1).join("/");return r.pathname=`${s}/${t.typesFolder}.zip`,r.href},W=t=>Object.entries(t.moduleFederationConfig.remotes).reduce((e,[o,r])=>(e[o]=z(t,r),e),{}),T=t=>{if(!t.moduleFederationConfig)throw new Error("moduleFederationConfig is required");let e={...U,...t},o=W(e);return{hostOptions:e,mapRemotesToDownload:o}};var _fs = require('fs');var _typescript = require('typescript'); var _typescript2 = _interopRequireDefault(_typescript);var B={tsConfigPath:"./tsconfig.json",typesFolder:"@mf-types",compiledTypesFolder:"compiled-types",deleteTypesFolder:!0,additionalFilesToCompile:[],compilerInstance:"tsc"},X=({tsConfigPath:t,typesFolder:e,compiledTypesFolder:o})=>{let r=_path.resolve.call(void 0, t),s=_typescript2.default.readConfigFile(r,_typescript2.default.sys.readFile),i=_typescript2.default.parseJsonConfigFileContent(s.config,_typescript2.default.sys,_path.dirname.call(void 0, r)),p=_path.join.call(void 0, i.options.outDir||"dist",e,o);return{...i.options,emitDeclarationOnly:!0,noEmit:!1,declaration:!0,outDir:p}},k=["ts","tsx","vue","svelte"],R=t=>{let e=process.cwd();for(let o of k){let r=_path.join.call(void 0, e,`${t}.${o}`);if(_fs.existsSync.call(void 0, r))return r}},J=t=>Object.entries(t.moduleFederationConfig.exposes).reduce((e,[o,r])=>(e[o]=R(r)||R(_path.join.call(void 0, r,"index"))||r,e),{}),v=t=>{if(!t.moduleFederationConfig)throw new Error("moduleFederationConfig is required");let e={...B,...t},o=J(e);return{tsConfig:X(e),mapComponentsToExpose:o,remoteOptions:e}};var _admzip = require('adm-zip'); var _admzip2 = _interopRequireDefault(_admzip);var _axios = require('axios'); var _axios2 = _interopRequireDefault(_axios);var Q=/^\//,F=".d.ts",Y=t=>{let{line:e}=t.file.getLineAndCharacterOfPosition(t.start);console.error(_ansicolors2.default.red(`TS Error ${t.code}':' ${_typescript2.default.flattenDiagnosticMessageText(t.messageText,_typescript2.default.sys.newLine)}`)),console.error(_ansicolors2.default.red(`         at ${t.file.fileName}:${e+1} typescript.sys.newLine`))},c=(t,e)=>_path.normalize.call(void 0, t.outDir.replace(e.compiledTypesFolder,"")),w=(t,e)=>_path.normalize.call(void 0, t.outDir.replace(e.compiledTypesFolder,"").replace(e.typesFolder,"")),ee=(t,e,o)=>{let r=_typescript2.default.createCompilerHost(e),s=r.writeFile,i=Object.fromEntries(Object.entries(t).map(n=>n.reverse())),p=c(e,o);return r.writeFile=(n,D,f,b,u,j)=>{s(n,D,f,b,u,j);for(let N of u||[]){let y=i[N.fileName];if(y){let g=_path.join.call(void 0, p,`${y}${F}`),A=_path.dirname.call(void 0, g),O=_path.relative.call(void 0, A,n).replace(F,"").replace(Q,"");s(g,`export * from './${O}';
export { default } from './${O}';`,f)}}},r},te=t=>I("vue-tsc").createProgram(t),oe=(t,e)=>{switch(t.compilerInstance){case"vue-tsc":return te(e);case"tsc":default:return _typescript2.default.createProgram(e)}},x=(t,e,o)=>{let r=ee(t,e,o),i={rootNames:[...Object.values(t),...o.additionalFilesToCompile],host:r,options:e},p=oe(o,i),{diagnostics:n=[]}=p.emit();n.forEach(Y)};var ie=(t,e)=>_path.join.call(void 0, t.replace(e.typesFolder,""),`${e.typesFolder}.zip`),$=async(t,e)=>{let o=c(t,e),r=new _admzip2.default;return r.addLocalFolder(o),r.writeZipPromise(ie(o,e))},ne=(t,e)=>o=>{throw console.error(_ansicolors2.default.red(`Unable to download federated types for '${t}' from '${e}' because '${o.message}', skipping...`)),o},H=t=>async([e,o])=>{let r=await _axios2.default.get(o,{responseType:"arraybuffer"}).catch(ne(e,o)),s=_path.join.call(void 0, t.typesFolder,e);new (0, _admzip2.default)(Buffer.from(r.data)).extractAllTo(s,!0)};var je=_unplugin.createUnplugin.call(void 0, t=>{let{remoteOptions:e,tsConfig:o,mapComponentsToExpose:r}=v(t);return{name:"native-federation-typescript/remote",async writeBundle(){try{x(r,o,e),await $(o,e),e.deleteTypesFolder&&await _promises.rm.call(void 0, c(o,e),{recursive:!0,force:!0}),console.log(_ansicolors2.default.green("Federated types created correctly"))}catch(s){console.error(_ansicolors2.default.red(`Unable to compile federated types, ${s}`))}},webpack:s=>{s.options.devServer=_rambda.mergeDeepRight.call(void 0, s.options.devServer||{},{static:{directory:_path.resolve.call(void 0, w(o,e))}})}}}),Ne= exports.b =_unplugin.createUnplugin.call(void 0, t=>{let{hostOptions:e,mapRemotesToDownload:o}=T(t);return{name:"native-federation-typescript/host",async writeBundle(){e.deleteTypesFolder&&await _promises.rm.call(void 0, e.typesFolder,{recursive:!0,force:!0}).catch(i=>console.error(_ansicolors2.default.red(`Unable to remove types folder, ${i}`)));let r=H(e),s=Object.entries(o).map(r);await Promise.allSettled(s),console.log(_ansicolors2.default.green("Federated types extraction completed"))}}});exports.a = je; exports.b = Ne;
