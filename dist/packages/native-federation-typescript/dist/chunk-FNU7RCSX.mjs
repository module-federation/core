var I=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,o)=>(typeof require<"u"?require:e)[o]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});import l from"ansi-colors";import{rm as S}from"fs/promises";import{resolve as pe}from"path";import{mergeDeepRight as ce}from"rambda";import{createUnplugin as q}from"unplugin";var U={typesFolder:"@mf-types",deleteTypesFolder:!0},L=t=>{let e=t.split("@");return e[e.length-1]},z=(t,e)=>{let o=L(e),r=new URL(o),s=r.pathname.split("/").slice(0,-1).join("/");return r.pathname=`${s}/${t.typesFolder}.zip`,r.href},W=t=>Object.entries(t.moduleFederationConfig.remotes).reduce((e,[o,r])=>(e[o]=z(t,r),e),{}),T=t=>{if(!t.moduleFederationConfig)throw new Error("moduleFederationConfig is required");let e={...U,...t},o=W(e);return{hostOptions:e,mapRemotesToDownload:o}};import{existsSync as _}from"fs";import{dirname as Z,join as d,resolve as M}from"path";import m from"typescript";var B={tsConfigPath:"./tsconfig.json",typesFolder:"@mf-types",compiledTypesFolder:"compiled-types",deleteTypesFolder:!0,additionalFilesToCompile:[],compilerInstance:"tsc"},X=({tsConfigPath:t,typesFolder:e,compiledTypesFolder:o})=>{let r=M(t),s=m.readConfigFile(r,m.sys.readFile),i=m.parseJsonConfigFileContent(s.config,m.sys,Z(r)),p=d(i.options.outDir||"dist",e,o);return{...i.options,emitDeclarationOnly:!0,noEmit:!1,declaration:!0,outDir:p}},k=["ts","tsx","vue","svelte"],R=t=>{let e=process.cwd();for(let o of k){let r=d(e,`${t}.${o}`);if(_(r))return r}},J=t=>Object.entries(t.moduleFederationConfig.exposes).reduce((e,[o,r])=>(e[o]=R(r)||R(d(r,"index"))||r,e),{}),v=t=>{if(!t.moduleFederationConfig)throw new Error("moduleFederationConfig is required");let e={...B,...t},o=J(e);return{tsConfig:X(e),mapComponentsToExpose:o,remoteOptions:e}};import E from"adm-zip";import re from"ansi-colors";import se from"axios";import{join as P}from"path";import C from"ansi-colors";import{dirname as V,join as G,normalize as h,relative as K}from"path";import a from"typescript";var Q=/^\//,F=".d.ts",Y=t=>{let{line:e}=t.file.getLineAndCharacterOfPosition(t.start);console.error(C.red(`TS Error ${t.code}':' ${a.flattenDiagnosticMessageText(t.messageText,a.sys.newLine)}`)),console.error(C.red(`         at ${t.file.fileName}:${e+1} typescript.sys.newLine`))},c=(t,e)=>h(t.outDir.replace(e.compiledTypesFolder,"")),w=(t,e)=>h(t.outDir.replace(e.compiledTypesFolder,"").replace(e.typesFolder,"")),ee=(t,e,o)=>{let r=a.createCompilerHost(e),s=r.writeFile,i=Object.fromEntries(Object.entries(t).map(n=>n.reverse())),p=c(e,o);return r.writeFile=(n,D,f,b,u,j)=>{s(n,D,f,b,u,j);for(let N of u||[]){let y=i[N.fileName];if(y){let g=G(p,`${y}${F}`),A=V(g),O=K(A,n).replace(F,"").replace(Q,"");s(g,`export * from './${O}';
export { default } from './${O}';`,f)}}},r},te=t=>I("vue-tsc").createProgram(t),oe=(t,e)=>{switch(t.compilerInstance){case"vue-tsc":return te(e);case"tsc":default:return a.createProgram(e)}},x=(t,e,o)=>{let r=ee(t,e,o),i={rootNames:[...Object.values(t),...o.additionalFilesToCompile],host:r,options:e},p=oe(o,i),{diagnostics:n=[]}=p.emit();n.forEach(Y)};var ie=(t,e)=>P(t.replace(e.typesFolder,""),`${e.typesFolder}.zip`),$=async(t,e)=>{let o=c(t,e),r=new E;return r.addLocalFolder(o),r.writeZipPromise(ie(o,e))},ne=(t,e)=>o=>{throw console.error(re.red(`Unable to download federated types for '${t}' from '${e}' because '${o.message}', skipping...`)),o},H=t=>async([e,o])=>{let r=await se.get(o,{responseType:"arraybuffer"}).catch(ne(e,o)),s=P(t.typesFolder,e);new E(Buffer.from(r.data)).extractAllTo(s,!0)};var je=q(t=>{let{remoteOptions:e,tsConfig:o,mapComponentsToExpose:r}=v(t);return{name:"native-federation-typescript/remote",async writeBundle(){try{x(r,o,e),await $(o,e),e.deleteTypesFolder&&await S(c(o,e),{recursive:!0,force:!0}),console.log(l.green("Federated types created correctly"))}catch(s){console.error(l.red(`Unable to compile federated types, ${s}`))}},webpack:s=>{s.options.devServer=ce(s.options.devServer||{},{static:{directory:pe(w(o,e))}})}}}),Ne=q(t=>{let{hostOptions:e,mapRemotesToDownload:o}=T(t);return{name:"native-federation-typescript/host",async writeBundle(){e.deleteTypesFolder&&await S(e.typesFolder,{recursive:!0,force:!0}).catch(i=>console.error(l.red(`Unable to remove types folder, ${i}`)));let r=H(e),s=Object.entries(o).map(r);await Promise.allSettled(s),console.log(l.green("Federated types extraction completed"))}}});export{je as a,Ne as b};
