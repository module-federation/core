diff --git a/cjs/react-server-dom-webpack-node-register.js b/cjs/react-server-dom-webpack-node-register.js
index beacd5cfe1843da007c4f997e5c589cb5eb802d7..33a5df930cc930524279533539fc3c8cf848c249 100644
--- a/cjs/react-server-dom-webpack-node-register.js
+++ b/cjs/react-server-dom-webpack-node-register.js
@@ -8,62 +8,212 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-const acorn = require("acorn-loose"),
-  url = require("url"),
-  Module = require("module");
+'use strict';
+const acorn = require('acorn-loose'),
+  url = require('url'),
+  Module = require('module');
+
+/**
+ * Check if a function body starts with 'use server' directive
+ */
+function hasUseServerDirective(body) {
+  if (
+    !body ||
+    body.type !== 'BlockStatement' ||
+    !body.body ||
+    body.body.length === 0
+  ) {
+    return false;
+  }
+  const firstStmt = body.body[0];
+  return (
+    firstStmt.type === 'ExpressionStatement' &&
+    firstStmt.expression &&
+    firstStmt.expression.type === 'Literal' &&
+    firstStmt.expression.value === 'use server'
+  );
+}
+
+/**
+ * Find all inline server action functions in the source AST
+ * Returns array of { name, start, end } for each action
+ */
+function findInlineServerActions(content) {
+  const actions = [];
+  let ast;
+
+  try {
+    ast = acorn.parse(content, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+  } catch (x) {
+    return actions;
+  }
+
+  function visit(node) {
+    if (!node || typeof node !== 'object') return;
+
+    // Check function declarations with 'use server' in body
+    if (
+      node.type === 'FunctionDeclaration' &&
+      node.id &&
+      hasUseServerDirective(node.body)
+    ) {
+      actions.push({
+        name: node.id.name,
+        start: node.start,
+        end: node.end,
+        bodyStart: node.body.start,
+      });
+    }
+
+    // Check variable declarations with function expressions
+    if (node.type === 'VariableDeclaration') {
+      for (const decl of node.declarations) {
+        if (decl.init && decl.id && decl.id.type === 'Identifier') {
+          const init = decl.init;
+          if (
+            (init.type === 'FunctionExpression' ||
+              init.type === 'ArrowFunctionExpression') &&
+            hasUseServerDirective(init.body)
+          ) {
+            actions.push({
+              name: decl.id.name,
+              start: node.start,
+              end: node.end,
+              bodyStart: init.body.start,
+            });
+          }
+        }
+      }
+    }
+
+    // Recurse into child nodes
+    for (const key in node) {
+      if (key === 'parent') continue;
+      const child = node[key];
+      if (Array.isArray(child)) {
+        for (const c of child) {
+          visit(c);
+        }
+      } else if (child && typeof child === 'object' && child.type) {
+        visit(child);
+      }
+    }
+  }
+
+  visit(ast);
+  return actions;
+}
+
+/**
+ * Transform source code to register inline server actions
+ * Adds registerServerReference calls after each inline action definition
+ */
+function transformInlineServerActions(content, filename, inlineActions) {
+  const moduleUrl = url.pathToFileURL(filename).href;
+
+  // Sort by position descending so we can insert from end to beginning
+  // without messing up positions
+  const sorted = [...inlineActions].sort((a, b) => b.end - a.end);
+
+  let result = content;
+
+  for (const action of sorted) {
+    // Insert registration after the function definition
+    const registration = `\n;(function(){if(typeof ${action.name}==='function'){require('react-server-dom-webpack/server').registerServerReference(${action.name},'${moduleUrl}','${action.name}');}})();`;
+
+    result =
+      result.slice(0, action.end) + registration + result.slice(action.end);
+  }
+
+  return result;
+}
+
 module.exports = function () {
-  const Server = require("react-server-dom-webpack/server"),
+  const Server = require('react-server-dom-webpack/server'),
     registerServerReference = Server.registerServerReference,
     createClientModuleProxy = Server.createClientModuleProxy,
     originalCompile = Module.prototype._compile;
+
   Module.prototype._compile = function (content, filename) {
+    // Quick check for any potential directives
     if (
-      -1 === content.indexOf("use client") &&
-      -1 === content.indexOf("use server")
+      -1 === content.indexOf('use client') &&
+      -1 === content.indexOf('use server')
     )
       return originalCompile.apply(this, arguments);
+
+    let body;
     try {
-      var body = acorn.parse(content, {
-        ecmaVersion: "2024",
-        sourceType: "source"
+      body = acorn.parse(content, {
+        ecmaVersion: '2024',
+        sourceType: 'module',
       }).body;
     } catch (x) {
-      return (
-        console.error("Error parsing %s %s", url, x.message),
-        originalCompile.apply(this, arguments)
-      );
+      console.error('Error parsing %s %s', filename, x.message);
+      return originalCompile.apply(this, arguments);
     }
-    var useClient = !1,
-      useServer = !1;
-    for (var i = 0; i < body.length; i++) {
-      var node = body[i];
-      if ("ExpressionStatement" !== node.type || !node.directive) break;
-      "use client" === node.directive && (useClient = !0);
-      "use server" === node.directive && (useServer = !0);
+
+    // Check for file-level directives
+    let useClient = false,
+      useServer = false;
+    for (let i = 0; i < body.length; i++) {
+      const node = body[i];
+      if ('ExpressionStatement' !== node.type || !node.directive) break;
+      if ('use client' === node.directive) useClient = true;
+      if ('use server' === node.directive) useServer = true;
     }
-    if (!useClient && !useServer) return originalCompile.apply(this, arguments);
-    if (useClient && useServer)
+
+    if (useClient && useServer) {
       throw Error(
-        'Cannot have both "use client" and "use server" directives in the same file.'
+        'Cannot have both "use client" and "use server" directives in the same file.',
       );
-    useClient &&
-      ((body = url.pathToFileURL(filename).href),
-      (this.exports = createClientModuleProxy(body)));
-    if (useServer)
-      if (
-        (originalCompile.apply(this, arguments),
-        (useServer = url.pathToFileURL(filename).href),
-        (body = this.exports),
-        "function" === typeof body)
-      )
-        registerServerReference(body, useServer, null);
-      else
-        for (useClient = Object.keys(body), i = 0; i < useClient.length; i++) {
-          node = useClient[i];
-          const value = body[useClient[i]];
-          "function" === typeof value &&
-            registerServerReference(value, useServer, node);
+    }
+
+    // Handle 'use client' modules
+    if (useClient) {
+      const moduleUrl = url.pathToFileURL(filename).href;
+      this.exports = createClientModuleProxy(moduleUrl);
+      return;
+    }
+
+    // Handle file-level 'use server' modules
+    if (useServer) {
+      originalCompile.apply(this, arguments);
+      const moduleUrl = url.pathToFileURL(filename).href;
+      const exports = this.exports;
+
+      if ('function' === typeof exports) {
+        registerServerReference(exports, moduleUrl, 'default');
+      } else {
+        for (const key of Object.keys(exports)) {
+          const value = exports[key];
+          if ('function' === typeof value) {
+            registerServerReference(value, moduleUrl, key);
+          }
         }
+      }
+      return;
+    }
+
+    // Check for inline 'use server' functions in this file
+    const inlineActions = findInlineServerActions(content);
+
+    if (inlineActions.length > 0) {
+      // Transform the source to add registration calls
+      const transformedContent = transformInlineServerActions(
+        content,
+        filename,
+        inlineActions,
+      );
+
+      // Compile the transformed source
+      return originalCompile.call(this, transformedContent, filename);
+    }
+
+    // No directives - pass through unchanged
+    return originalCompile.apply(this, arguments);
   };
 };
diff --git a/cjs/react-server-dom-webpack-plugin.js b/cjs/react-server-dom-webpack-plugin.js
index b8b09d9e88745600dece6040b252bb3ca85cae33..7bf5ab8fc89a89f9767e1e8bd00e6b9f5c8a53be 100644
--- a/cjs/react-server-dom-webpack-plugin.js
+++ b/cjs/react-server-dom-webpack-plugin.js
@@ -8,22 +8,24 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-var path = require("path"),
-  url = require("url"),
-  asyncLib = require("neo-async"),
-  acorn = require("acorn-loose"),
-  ModuleDependency = require("webpack/lib/dependencies/ModuleDependency"),
-  NullDependency = require("webpack/lib/dependencies/NullDependency"),
-  Template = require("webpack/lib/Template"),
-  webpack = require("webpack");
+'use strict';
+var path = require('path'),
+  url = require('url'),
+  asyncLib = require('neo-async'),
+  acorn = require('acorn-loose'),
+  ModuleDependency = require('webpack/lib/dependencies/ModuleDependency'),
+  NullDependency = require('webpack/lib/dependencies/NullDependency'),
+  Template = require('webpack/lib/Template'),
+  webpack = require('webpack'),
+  fs = require('fs');
+
 function _unsupportedIterableToArray(o, minLen) {
   if (o) {
-    if ("string" === typeof o) return _arrayLikeToArray(o, minLen);
+    if ('string' === typeof o) return _arrayLikeToArray(o, minLen);
     var n = Object.prototype.toString.call(o).slice(8, -1);
-    "Object" === n && o.constructor && (n = o.constructor.name);
-    if ("Map" === n || "Set" === n) return Array.from(o);
-    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    'Object' === n && o.constructor && (n = o.constructor.name);
+    if ('Map' === n || 'Set' === n) return Array.from(o);
+    if ('Arguments' === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
       return _arrayLikeToArray(o, minLen);
   }
 }
@@ -34,12 +36,12 @@ function _arrayLikeToArray(arr, len) {
 }
 function _createForOfIteratorHelper(o, allowArrayLike) {
   var it =
-    ("undefined" !== typeof Symbol && o[Symbol.iterator]) || o["@@iterator"];
+    ('undefined' !== typeof Symbol && o[Symbol.iterator]) || o['@@iterator'];
   if (!it) {
     if (
       Array.isArray(o) ||
       (it = _unsupportedIterableToArray(o)) ||
-      (allowArrayLike && o && "number" === typeof o.length)
+      (allowArrayLike && o && 'number' === typeof o.length)
     ) {
       it && (o = it);
       var i = 0;
@@ -52,11 +54,11 @@ function _createForOfIteratorHelper(o, allowArrayLike) {
         e: function (e) {
           throw e;
         },
-        f: allowArrayLike
+        f: allowArrayLike,
       };
     }
     throw new TypeError(
-      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+      'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
     );
   }
   var normalCompletion = !0,
@@ -81,59 +83,367 @@ function _createForOfIteratorHelper(o, allowArrayLike) {
       } finally {
         if (didErr) throw err;
       }
-    }
+    },
   };
 }
+
 const isArrayImpl = Array.isArray;
+
 class ClientReferenceDependency extends ModuleDependency {
   constructor(request) {
     super(request);
   }
   get type() {
-    return "client-reference";
+    return 'client-reference';
+  }
+}
+
+class ServerReferenceDependency extends ModuleDependency {
+  constructor(request) {
+    super(request);
+  }
+  get type() {
+    return 'server-reference';
+  }
+}
+
+const clientFileName = require.resolve('../client.browser.js');
+
+function hasDirective(source, directive) {
+  if (-1 === source.indexOf(directive)) return false;
+  let body;
+  try {
+    body = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    }).body;
+  } catch (x) {
+    return false;
+  }
+  for (let i = 0; i < body.length; i++) {
+    const node = body[i];
+    if ('ExpressionStatement' !== node.type || !node.directive) break;
+    if (directive === node.directive) return true;
   }
+  return false;
 }
-const clientFileName = require.resolve("../client.browser.js");
+
+function getExports(source) {
+  const exports = [];
+  let body;
+  try {
+    body = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    }).body;
+  } catch (x) {
+    return exports;
+  }
+  for (const node of body) {
+    if (node.type === 'ExportNamedDeclaration' && node.declaration) {
+      if (
+        node.declaration.type === 'FunctionDeclaration' &&
+        node.declaration.id
+      ) {
+        exports.push(node.declaration.id.name);
+      }
+      if (node.declaration.type === 'VariableDeclaration') {
+        for (const decl of node.declaration.declarations) {
+          if (decl.id && decl.id.type === 'Identifier') {
+            exports.push(decl.id.name);
+          }
+        }
+      }
+    }
+    if (node.type === 'ExportDefaultDeclaration') {
+      exports.push('default');
+    }
+  }
+  return exports;
+}
+
 class ReactFlightWebpackPlugin {
   constructor(options) {
     this.serverConsumerManifestFilename =
       this.clientManifestFilename =
+      this.serverActionsManifestFilename =
       this.chunkName =
       this.clientReferences =
+      this.serverReferences =
         void 0;
-    if (!options || "boolean" !== typeof options.isServer)
+
+    if (!options || 'boolean' !== typeof options.isServer)
       throw Error(
-        "React Server Plugin: You must specify the isServer option as a boolean."
+        'ReactFlightPlugin: You must specify the isServer option as a boolean.',
       );
-    if (options.isServer) throw Error("TODO: Implement the server compiler.");
+
+    this.isServer = options.isServer;
+    this.layer = options.layer;
+    this.layers = Array.isArray(this.layer)
+      ? this.layer
+      : this.layer
+        ? [this.layer]
+        : null;
+
+    // Client references config (for client compiler)
     options.clientReferences
-      ? "string" !== typeof options.clientReferences &&
+      ? 'string' !== typeof options.clientReferences &&
         isArrayImpl(options.clientReferences)
         ? (this.clientReferences = options.clientReferences)
         : (this.clientReferences = [options.clientReferences])
       : (this.clientReferences = [
-          { directory: ".", recursive: !0, include: /\.(js|ts|jsx|tsx)$/ }
+          { directory: '.', recursive: !0, include: /\.(js|ts|jsx|tsx)$/ },
+        ]);
+
+    // Server references config (for server compiler)
+    options.serverReferences
+      ? 'string' !== typeof options.serverReferences &&
+        isArrayImpl(options.serverReferences)
+        ? (this.serverReferences = options.serverReferences)
+        : (this.serverReferences = [options.serverReferences])
+      : (this.serverReferences = [
+          { directory: '.', recursive: !0, include: /\.(js|ts|jsx|tsx)$/ },
         ]);
-    "string" === typeof options.chunkName
+
+    'string' === typeof options.chunkName
       ? ((this.chunkName = options.chunkName),
         /\[(index|request)\]/.test(this.chunkName) ||
-          (this.chunkName += "[index]"))
-      : (this.chunkName = "client[index]");
+          (this.chunkName += '[index]'))
+      : (this.chunkName = 'client[index]');
+
     this.clientManifestFilename =
-      options.clientManifestFilename || "react-client-manifest.json";
+      options.clientManifestFilename || 'react-client-manifest.json';
     this.serverConsumerManifestFilename =
-      options.serverConsumerManifestFilename || "react-ssr-manifest.json";
+      options.serverConsumerManifestFilename || 'react-ssr-manifest.json';
+    this.serverActionsManifestFilename =
+      options.serverActionsManifestFilename ||
+      'react-server-actions-manifest.json';
+    this.extraServerActionsManifests =
+      options.extraServerActionsManifests || [];
+    this.discoveredClientRefs = options.discoveredClientRefs || [];
   }
+
   apply(compiler) {
+    if (this.isServer) {
+      this.applyServer(compiler);
+    } else {
+      this.applyClient(compiler);
+    }
+  }
+
+  applyServer(compiler) {
+    const _this = this;
+    const serverActions = new Map();
+    function matchesLayer(mod) {
+      if (!_this.layers || _this.layers.length === 0) return true;
+      const layer =
+        mod && (mod.layer || (typeof mod.getLayer === 'function' ? mod.getLayer() : undefined));
+      return _this.layers.indexOf(layer) !== -1;
+    }
+
+    // Helper to get serverReferencesMap at runtime (after loaders have populated it)
+    function getServerReferencesMap(compiler) {
+      try {
+        const loader = require('./rsc-client-loader');
+        if (loader && typeof loader.getServerReferencesMap === 'function') {
+          const outputPath =
+            compiler &&
+            compiler.options &&
+            compiler.options.output &&
+            typeof compiler.options.output.path === 'string'
+              ? compiler.options.output.path
+              : undefined;
+          const primary = loader.getServerReferencesMap(outputPath);
+          if (primary && primary.size > 0) return primary;
+          const fallbackContext =
+            compiler && typeof compiler.context === 'string'
+              ? compiler.context
+              : undefined;
+          if (fallbackContext && fallbackContext !== outputPath) {
+            const fallback = loader.getServerReferencesMap(fallbackContext);
+            if (fallback && fallback.size > 0) return fallback;
+          }
+          return primary || new Map();
+        }
+        return loader && loader.serverReferencesMap
+          ? loader.serverReferencesMap
+          : new Map();
+      } catch (e) {
+        return new Map();
+      }
+    }
+
+    // Helper to get inlineServerActionsMap from server loader
+    function getInlineServerActionsMap() {
+      try {
+        return require('./rsc-server-loader').inlineServerActionsMap;
+      } catch (e) {
+        return new Map();
+      }
+    }
+
+    // Scan for 'use server' modules during compilation
+    compiler.hooks.thisCompilation.tap(
+      'ReactFlightPlugin',
+      (compilation, { normalModuleFactory }) => {
+        compilation.dependencyFactories.set(
+          ServerReferenceDependency,
+          normalModuleFactory,
+        );
+        compilation.dependencyTemplates.set(
+          ServerReferenceDependency,
+          new NullDependency.Template(),
+        );
+
+        const handler = (parser) => {
+          parser.hooks.program.tap('ReactFlightPlugin', (ast) => {
+            const module = parser.state.module;
+            if (!module.resource) return;
+            if (!matchesLayer(module)) return;
+
+            // Check for 'use server' directive
+            let hasUseServer = false;
+            for (const node of ast.body) {
+              if (node.type !== 'ExpressionStatement' || !node.directive) break;
+              if (node.directive === 'use server') {
+                hasUseServer = true;
+                break;
+              }
+            }
+
+            if (!hasUseServer) return;
+
+            // Collect exports from this module
+            const exports = [];
+            for (const node of ast.body) {
+              if (node.type === 'ExportNamedDeclaration' && node.declaration) {
+                if (
+                  node.declaration.type === 'FunctionDeclaration' &&
+                  node.declaration.id
+                ) {
+                  exports.push(node.declaration.id.name);
+                }
+                if (node.declaration.type === 'VariableDeclaration') {
+                  for (const decl of node.declaration.declarations) {
+                    if (decl.id && decl.id.type === 'Identifier') {
+                      exports.push(decl.id.name);
+                    }
+                  }
+                }
+              }
+              if (node.type === 'ExportDefaultDeclaration') {
+                exports.push('default');
+              }
+            }
+
+            if (exports.length > 0) {
+              serverActions.set(module.resource, exports);
+            }
+          });
+        };
+
+        normalModuleFactory.hooks.parser
+          .for('javascript/auto')
+          .tap('ReactFlightPlugin', handler);
+        normalModuleFactory.hooks.parser
+          .for('javascript/esm')
+          .tap('ReactFlightPlugin', handler);
+        normalModuleFactory.hooks.parser
+          .for('javascript/dynamic')
+          .tap('ReactFlightPlugin', handler);
+      },
+    );
+
+    // Generate server actions manifest
+    compiler.hooks.make.tap('ReactFlightPlugin', (compilation) => {
+      compilation.hooks.processAssets.tap(
+        {
+          name: 'ReactFlightPlugin',
+          // Emit server-actions manifest early so downstream plugins (e.g. MF additionalData
+          // at OPTIMIZE_TRANSFER/3000) can read it. SUMMARIZE is 1000.
+          stage: webpack.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
+        },
+        function () {
+          const manifest = {};
+
+          // Include actions detected by AST parsing
+          for (const [resourcePath, exports] of serverActions) {
+            const moduleUrl = url.pathToFileURL(resourcePath).href;
+
+            for (const exportName of exports) {
+              const actionId =
+                exportName === 'default'
+                  ? `${moduleUrl}#default`
+                  : `${moduleUrl}#${exportName}`;
+
+              manifest[actionId] = {
+                id: moduleUrl,
+                name: exportName,
+                chunks: [],
+              };
+            }
+          }
+
+          // Include actions registered by the client loader via shared map
+          const serverReferencesMap = getServerReferencesMap(compiler);
+          if (serverReferencesMap && serverReferencesMap.size > 0) {
+            for (const [actionId, entry] of serverReferencesMap) {
+              if (!manifest[actionId]) {
+                manifest[actionId] = entry;
+              }
+            }
+          }
+
+          // Include inline server actions registered by the server loader
+          const inlineServerActionsMap = getInlineServerActionsMap();
+          if (inlineServerActionsMap && inlineServerActionsMap.size > 0) {
+            for (const [actionId, entry] of inlineServerActionsMap) {
+              if (!manifest[actionId]) {
+                manifest[actionId] = entry;
+              }
+            }
+          }
+
+          // Merge any extra server action manifests (e.g. from MF remotes)
+          if (Array.isArray(_this.extraServerActionsManifests)) {
+            for (const manifestPath of _this.extraServerActionsManifests) {
+              if (!manifestPath) continue;
+              try {
+                if (!fs.existsSync(manifestPath)) continue;
+                const json = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
+                for (const [actionId, entry] of Object.entries(json)) {
+                  if (!manifest[actionId]) {
+                    manifest[actionId] = entry;
+                  }
+                }
+              } catch (e) {
+                compilation.warnings.push(
+                  new webpack.WebpackError(
+                    'ReactFlightPlugin: Failed to merge server actions manifest from ' +
+                      manifestPath +
+                      ': ' +
+                      e.message,
+                  ),
+                );
+              }
+            }
+          }
+
+          const output = JSON.stringify(manifest, null, 2);
+          compilation.emitAsset(
+            _this.serverActionsManifestFilename,
+            new webpack.sources.RawSource(output, false),
+          );
+
+          const actionCount = Object.keys(manifest).length;
+          if (actionCount > 0) {
+            console.log(
+              `[ReactFlightPlugin] Generated ${_this.serverActionsManifestFilename} with ${actionCount} action(s)`,
+            );
+          }
+        },
+      );
+    });
+  }
+
+  applyClient(compiler) {
     const _this = this;
     let resolvedClientReferences,
       clientFileNameFound = !1;
+
     compiler.hooks.beforeCompile.tapAsync(
-      "React Server Plugin",
+      'ReactFlightPlugin',
       (_ref, callback) => {
         _ref = _ref.contextModuleFactory;
-        const contextResolver = compiler.resolverFactory.get("context", {}),
-          normalResolver = compiler.resolverFactory.get("normal");
+        const contextResolver = compiler.resolverFactory.get('context', {}),
+          normalResolver = compiler.resolverFactory.get('normal');
         _this.resolveAllClientFiles(
           compiler.context,
           contextResolver,
@@ -144,21 +454,30 @@ class ReactFlightWebpackPlugin {
             err
               ? callback(err)
               : ((resolvedClientReferences = resolvedClientRefs), callback());
-          }
+          },
         );
-      }
+      },
     );
+
     compiler.hooks.thisCompilation.tap(
-      "React Server Plugin",
+      'ReactFlightPlugin',
       (compilation, _ref2) => {
         _ref2 = _ref2.normalModuleFactory;
         compilation.dependencyFactories.set(ClientReferenceDependency, _ref2);
         compilation.dependencyTemplates.set(
           ClientReferenceDependency,
-          new NullDependency.Template()
+          new NullDependency.Template(),
         );
         compilation = (parser) => {
-          parser.hooks.program.tap("React Server Plugin", () => {
+          parser.hooks.program.tap('ReactFlightPlugin', () => {
             const module = parser.state.module;
+            const request =
+              module.rawRequest || module.userRequest || module.request;
+            const isClientRuntime =
+              module.resource === clientFileName ||
+              request === 'react-server-dom-webpack/client' ||
+              request === 'react-server-dom-webpack/client.browser' ||
+              request === 'react-server-dom-webpack/client.browser.js';
             if (
-              module.resource === clientFileName &&
+              isClientRuntime &&
+              !clientFileNameFound &&
@@ -167,12 +478,12 @@ class ReactFlightWebpackPlugin {
               for (let i = 0; i < resolvedClientReferences.length; i++) {
                 const dep = resolvedClientReferences[i];
                 var chunkName = _this.chunkName
-                  .replace(/\[index\]/g, "" + i)
+                  .replace(/\[index\]/g, '' + i)
                   .replace(/\[request\]/g, Template.toPath(dep.userRequest));
                 chunkName = new webpack.AsyncDependenciesBlock(
                   { name: chunkName },
                   null,
-                  dep.request
+                  dep.request,
                 );
                 chunkName.addDependency(dep);
                 module.addBlock(chunkName);
@@ -180,51 +491,59 @@ class ReactFlightWebpackPlugin {
           });
         };
         _ref2.hooks.parser
-          .for("javascript/auto")
-          .tap("HarmonyModulesPlugin", compilation);
+          .for('javascript/auto')
+          .tap('HarmonyModulesPlugin', compilation);
         _ref2.hooks.parser
-          .for("javascript/esm")
-          .tap("HarmonyModulesPlugin", compilation);
+          .for('javascript/esm')
+          .tap('HarmonyModulesPlugin', compilation);
         _ref2.hooks.parser
-          .for("javascript/dynamic")
-          .tap("HarmonyModulesPlugin", compilation);
-      }
+          .for('javascript/dynamic')
+          .tap('HarmonyModulesPlugin', compilation);
+      },
     );
-    compiler.hooks.make.tap("React Server Plugin", (compilation) => {
+
+    compiler.hooks.make.tap('ReactFlightPlugin', (compilation) => {
       compilation.hooks.processAssets.tap(
         {
-          name: "React Server Plugin",
-          stage: webpack.Compilation.PROCESS_ASSETS_STAGE_REPORT
+          name: 'ReactFlightPlugin',
+          // Use SUMMARIZE (1000) instead of REPORT (5000) so react-client-manifest.json
+          // is available for MF's additionalData hook at OPTIMIZE_TRANSFER (3000)
+          stage: webpack.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
         },
         function () {
           if (!1 === clientFileNameFound)
             compilation.warnings.push(
               new webpack.WebpackError(
-                "Client runtime at react-server-dom-webpack/client was not found. React Server Components module map file " +
+                'Client runtime at react-server-dom-webpack/client was not found. React Server Components module map file ' +
                   _this.clientManifestFilename +
-                  " was not created."
-              )
+                  ' was not created.',
+              ),
             );
           else {
             var configuredCrossOriginLoading =
               compilation.outputOptions.crossOriginLoading;
             configuredCrossOriginLoading =
-              "string" === typeof configuredCrossOriginLoading
-                ? "use-credentials" === configuredCrossOriginLoading
+              'string' === typeof configuredCrossOriginLoading
+                ? 'use-credentials' === configuredCrossOriginLoading
                   ? configuredCrossOriginLoading
-                  : "anonymous"
+                  : 'anonymous'
                 : null;
             var resolvedClientFiles = new Set(
-                (resolvedClientReferences || []).map((ref) => ref.request)
+                (resolvedClientReferences || []).map((ref) => ref.request),
+              ),
+              discoveredClientRefs = new Set(
+                Array.isArray(_this.discoveredClientRefs)
+                  ? _this.discoveredClientRefs
+                  : [],
               ),
               clientManifest = {},
               moduleMap = {};
             configuredCrossOriginLoading = {
               moduleLoading: {
-                prefix: compilation.outputOptions.publicPath || "",
-                crossOrigin: configuredCrossOriginLoading
+                prefix: compilation.outputOptions.publicPath || '',
+                crossOrigin: configuredCrossOriginLoading,
               },
-              moduleMap
+              moduleMap,
             };
             var runtimeChunkFiles = new Set();
             compilation.entrypoints.forEach((entrypoint) => {
@@ -235,16 +554,35 @@ class ReactFlightWebpackPlugin {
             });
             compilation.chunkGroups.forEach(function (chunkGroup) {
               function recordModule(id, module) {
-                if (
-                  resolvedClientFiles.has(module.resource) &&
-                  ((module = url.pathToFileURL(module.resource).href),
-                  void 0 !== module)
-                ) {
-                  const ssrExports = {};
-                  clientManifest[module] = { id, chunks, name: "*" };
-                  ssrExports["*"] = { specifier: module, name: "*" };
-                  moduleMap[id] = ssrExports;
+                if (!module) return;
+
+                function visit(mod) {
+                  if (!mod) return;
+                  const isClient =
+                    mod.buildInfo &&
+                    mod.buildInfo.rscDirective === 'use client';
+
+                  if (
+                    isClient ||
+                    (mod.resource && discoveredClientRefs.has(mod.resource)) ||
+                    (mod.resource && resolvedClientFiles.has(mod.resource))
+                  ) {
+                    const resource = mod.resource;
+                    if (resource) {
+                      const href = url.pathToFileURL(resource).href;
+                      const ssrExports = {};
+                      clientManifest[href] = { id, chunks, name: '*' };
+                      ssrExports['*'] = { specifier: href, name: '*' };
+                      moduleMap[id] = ssrExports;
+                    }
+                  }
+
+                  if (mod.modules && Array.isArray(mod.modules)) {
+                    mod.modules.forEach(visit);
+                  }
                 }
+
+                visit(module);
               }
               const chunks = [];
               chunkGroup.chunks.forEach(function (c) {
@@ -253,10 +591,10 @@ class ReactFlightWebpackPlugin {
                 try {
                   for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                     const file = _step.value;
-                    if (!file.endsWith(".js") && !file.endsWith(".mjs")) break;
+                    if (!file.endsWith('.js') && !file.endsWith('.mjs')) break;
                     if (
-                      file.endsWith(".hot-update.js") ||
-                      file.endsWith(".hot-update.mjs")
+                      file.endsWith('.hot-update.js') ||
+                      file.endsWith('.hot-update.mjs')
                     )
                       break;
                     chunks.push(c.id, file);
@@ -283,52 +621,38 @@ class ReactFlightWebpackPlugin {
             var clientOutput = JSON.stringify(clientManifest, null, 2);
             compilation.emitAsset(
               _this.clientManifestFilename,
-              new webpack.sources.RawSource(clientOutput, !1)
+              new webpack.sources.RawSource(clientOutput, !1),
             );
             configuredCrossOriginLoading = JSON.stringify(
               configuredCrossOriginLoading,
               null,
-              2
+              2,
             );
             compilation.emitAsset(
               _this.serverConsumerManifestFilename,
-              new webpack.sources.RawSource(configuredCrossOriginLoading, !1)
+              new webpack.sources.RawSource(configuredCrossOriginLoading, !1),
             );
           }
-        }
+        },
       );
     });
   }
+
   resolveAllClientFiles(
     context,
     contextResolver,
     normalResolver,
     fs,
     contextModuleFactory,
-    callback
+    callback,
   ) {
     function hasUseClientDirective(source) {
-      if (-1 === source.indexOf("use client")) return !1;
-      let body;
-      try {
-        body = acorn.parse(source, {
-          ecmaVersion: "2024",
-          sourceType: "module"
-        }).body;
-      } catch (x) {
-        return !1;
-      }
-      for (source = 0; source < body.length; source++) {
-        const node = body[source];
-        if ("ExpressionStatement" !== node.type || !node.directive) break;
-        if ("use client" === node.directive) return !0;
-      }
-      return !1;
+      return hasDirective(source, 'use client');
     }
     asyncLib.map(
       this.clientReferences,
       (clientReferencePath, cb) => {
-        "string" === typeof clientReferencePath
+        'string' === typeof clientReferencePath
           ? cb(null, [new ClientReferenceDependency(clientReferencePath)])
           : contextResolver.resolve(
               {},
@@ -341,21 +665,21 @@ class ReactFlightWebpackPlugin {
                   fs,
                   {
                     resource: resolvedDirectory,
-                    resourceQuery: "",
+                    resourceQuery: '',
                     recursive:
                       void 0 === clientReferencePath.recursive
                         ? !0
                         : clientReferencePath.recursive,
                     regExp: clientReferencePath.include,
                     include: void 0,
-                    exclude: clientReferencePath.exclude
+                    exclude: clientReferencePath.exclude,
                   },
                   (err2, deps) => {
                     if (err2) return cb(err2);
                     err2 = deps.map((dep) => {
                       var request = path.join(
                         resolvedDirectory,
-                        dep.userRequest
+                        dep.userRequest,
                       );
                       request = new ClientReferenceDependency(request);
                       request.userRequest = dep.userRequest;
@@ -370,26 +694,26 @@ class ReactFlightWebpackPlugin {
                           clientRefDep.request,
                           {},
                           (err3, resolvedPath) => {
-                            if (err3 || "string" !== typeof resolvedPath)
+                            if (err3 || 'string' !== typeof resolvedPath)
                               return filterCb(null, !1);
                             fs.readFile(
                               resolvedPath,
-                              "utf-8",
+                              'utf-8',
                               (err4, content) => {
-                                if (err4 || "string" !== typeof content)
+                                if (err4 || 'string' !== typeof content)
                                   return filterCb(null, !1);
                                 err4 = hasUseClientDirective(content);
                                 filterCb(null, err4);
-                              }
+                              },
                             );
-                          }
+                          },
                         );
                       },
-                      cb
+                      cb,
                     );
-                  }
+                  },
                 );
-              }
+              },
             );
       },
       (err, result) => {
@@ -397,8 +721,9 @@ class ReactFlightWebpackPlugin {
         err = [];
         for (let i = 0; i < result.length; i++) err.push.apply(err, result[i]);
         callback(null, err);
-      }
+      },
     );
   }
 }
+
 module.exports = ReactFlightWebpackPlugin;
diff --git a/cjs/rsc-client-loader.js b/cjs/rsc-client-loader.js
new file mode 100644
index 0000000000000000000000000000000000000000..f245ff214124889e636f0efdf0b60a85d225e022
--- /dev/null
+++ b/cjs/rsc-client-loader.js
@@ -0,0 +1,176 @@
+/**
+ * rsc-client-loader.js
+ *
+ * Webpack loader for the CLIENT (browser) layer.
+ *
+ * Transformations:
+ * - 'use server' modules → createServerReference() calls
+ * - 'use client' modules → Pass through (actual components)
+ *
+ * This loader runs in the BROWSER.
+ */
+
+'use strict';
+
+const acorn = require('acorn-loose');
+const url = require('url');
+
+function getDirective(source) {
+  if (!source.includes('use client') && !source.includes('use server'))
+    return null;
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type !== 'ExpressionStatement' || !node.directive) break;
+      if (node.directive === 'use client') return 'use client';
+      if (node.directive === 'use server') return 'use server';
+    }
+  } catch (e) {
+    return null;
+  }
+  return null;
+}
+
+function getExports(source) {
+  const exports = [];
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type === 'ExportNamedDeclaration') {
+        if (node.declaration) {
+          if (
+            node.declaration.type === 'FunctionDeclaration' &&
+            node.declaration.id
+          ) {
+            exports.push(node.declaration.id.name);
+          }
+          if (node.declaration.type === 'VariableDeclaration') {
+            for (const decl of node.declaration.declarations) {
+              if (decl.id && decl.id.type === 'Identifier') {
+                exports.push(decl.id.name);
+              }
+            }
+          }
+        }
+      }
+      if (node.type === 'ExportDefaultDeclaration') {
+        exports.push('default');
+      }
+    }
+  } catch (e) {
+    // Ignore parse errors
+  }
+  return exports;
+}
+
+// Per-context map for server references (avoid cross-compilation races)
+const serverReferencesMapByContext = new Map();
+
+function getContextKey(context) {
+  if (typeof context === 'string' && context.length > 0) {
+    return context;
+  }
+  if (
+    context &&
+    context._compiler &&
+    context._compiler.options &&
+    context._compiler.options.output &&
+    typeof context._compiler.options.output.path === 'string'
+  ) {
+    return context._compiler.options.output.path;
+  }
+  if (context && typeof context.rootContext === 'string') {
+    return context.rootContext;
+  }
+  if (
+    context &&
+    context._compiler &&
+    typeof context._compiler.context === 'string'
+  ) {
+    return context._compiler.context;
+  }
+  return process.cwd();
+}
+
+function getServerReferencesMap(context) {
+  const key = getContextKey(context);
+  let map = serverReferencesMapByContext.get(key);
+  if (!map) {
+    map = new Map();
+    serverReferencesMapByContext.set(key, map);
+  }
+  return map;
+}
+
+function rscClientLoader(source) {
+  const directive = getDirective(source);
+
+  // Mark the module with the detected directive so the plugin can discover client refs
+  if (this && this._module && this._module.buildInfo) {
+    this._module.buildInfo.rscDirective = directive;
+  }
+
+  // 'use server' → Create server references
+  if (directive === 'use server') {
+    const resourcePath = this.resourcePath;
+    const moduleUrl = url.pathToFileURL(resourcePath).href;
+    const exports = getExports(source);
+
+    const serverReferencesMap = getServerReferencesMap(this);
+
+    // Register in per-context map for plugin to generate manifest
+    for (const name of exports) {
+      const actionId = `${moduleUrl}#${name}`;
+      serverReferencesMap.set(actionId, {
+        id: moduleUrl,
+        name: name,
+        chunks: [],
+      });
+    }
+
+    // Get loader options for callServer import source
+    const options = this.getOptions ? this.getOptions() : {};
+    const callServerImport = options.callServerModule
+      ? `import { callServer } from '${options.callServerModule}';`
+      : `const callServer = globalThis.__RSC_CALL_SERVER__ || ((id, args) => {
+          throw new Error('callServer not initialized. Set globalThis.__RSC_CALL_SERVER__');
+        });`;
+
+    let output = `
+// RSC Client Loader: 'use server' module transformed to server references
+import { createServerReference } from 'react-server-dom-webpack/client';
+${callServerImport}
+`;
+
+    for (const name of exports) {
+      const actionId = `${moduleUrl}#${name}`;
+
+      if (name === 'default') {
+        output += `
+const _default = createServerReference('${actionId}', callServer);
+export default _default;
+`;
+      } else {
+        output += `
+export const ${name} = createServerReference('${actionId}', callServer);
+`;
+      }
+    }
+
+    return output;
+  }
+
+  // 'use client' and other modules - pass through unchanged
+  return source;
+}
+
+// Export the loader function and map accessor
+module.exports = rscClientLoader;
+module.exports.getServerReferencesMap = getServerReferencesMap;
+module.exports.serverReferencesMap = getServerReferencesMap(process.cwd());
diff --git a/cjs/rsc-server-loader.js b/cjs/rsc-server-loader.js
new file mode 100644
index 0000000000000000000000000000000000000000..ad4f3c457e5728626f718d7015e324dd8e735b0d
--- /dev/null
+++ b/cjs/rsc-server-loader.js
@@ -0,0 +1,399 @@
+/**
+ * rsc-server-loader.js
+ *
+ * Webpack loader for the RSC (React Server Components) layer.
+ *
+ * Transformations:
+ * - 'use client' modules → createClientReference() proxies
+ * - 'use server' modules → registerServerReference() metadata added
+ * - Inline 'use server' functions → registerServerReference() for each function
+ *
+ * This loader runs on the SERVER during RSC rendering.
+ */
+
+'use strict';
+
+const acorn = require('acorn-loose');
+const url = require('url');
+
+function getDirective(source) {
+  if (!source.includes('use client') && !source.includes('use server'))
+    return null;
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type !== 'ExpressionStatement' || !node.directive) break;
+      if (node.directive === 'use client') return 'use client';
+      if (node.directive === 'use server') return 'use server';
+    }
+  } catch (e) {
+    return null;
+  }
+  return null;
+}
+
+function getExports(source) {
+  const exports = [];
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type === 'ExportNamedDeclaration') {
+        if (node.declaration) {
+          if (
+            node.declaration.type === 'FunctionDeclaration' &&
+            node.declaration.id
+          ) {
+            exports.push({ name: node.declaration.id.name, type: 'function' });
+          }
+          if (node.declaration.type === 'VariableDeclaration') {
+            for (const decl of node.declaration.declarations) {
+              if (decl.id && decl.id.type === 'Identifier') {
+                exports.push({ name: decl.id.name, type: 'variable' });
+              }
+            }
+          }
+        }
+        if (node.specifiers) {
+          for (const spec of node.specifiers) {
+            exports.push({ name: spec.exported.name, type: 'reexport' });
+          }
+        }
+      }
+      if (node.type === 'ExportDefaultDeclaration') {
+        // Capture the actual function/class name for default exports
+        // This allows us to reference it directly instead of exports.default
+        let localName = null;
+        if (node.declaration) {
+          if (
+            node.declaration.type === 'FunctionDeclaration' &&
+            node.declaration.id
+          ) {
+            localName = node.declaration.id.name;
+          } else if (
+            node.declaration.type === 'ClassDeclaration' &&
+            node.declaration.id
+          ) {
+            localName = node.declaration.id.name;
+          } else if (node.declaration.type === 'Identifier') {
+            localName = node.declaration.name;
+          }
+        }
+        exports.push({ name: 'default', type: 'default', localName });
+      }
+    }
+  } catch (e) {
+    // Ignore parse errors
+  }
+  return exports;
+}
+
+/**
+ * Check if a function body starts with 'use server' directive
+ */
+function hasUseServerDirective(body) {
+  if (
+    !body ||
+    body.type !== 'BlockStatement' ||
+    !body.body ||
+    body.body.length === 0
+  ) {
+    return false;
+  }
+  const firstStmt = body.body[0];
+  return (
+    firstStmt.type === 'ExpressionStatement' &&
+    firstStmt.expression &&
+    firstStmt.expression.type === 'Literal' &&
+    firstStmt.expression.value === 'use server'
+  );
+}
+
+// Shared map for inline server actions (populated by loader, read by plugin)
+// Key format: "moduleUrl#actionName"
+const inlineServerActionsMap = new Map();
+
+// Track which modules have entries in the map (for clearing stale entries on rebuild)
+const moduleEntriesMap = new Map(); // moduleUrl -> Set of actionIds
+
+/**
+ * Find all inline server action functions in the source
+ * These are functions with 'use server' as their first statement
+ */
+function findInlineServerActions(source) {
+  const actions = [];
+  let actionCounter = 0;
+
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+
+    function visit(node, parent, parentKey) {
+      if (!node || typeof node !== 'object') return;
+
+      // Check function declarations
+      if (
+        node.type === 'FunctionDeclaration' &&
+        node.id &&
+        hasUseServerDirective(node.body)
+      ) {
+        actions.push({
+          name: node.id.name,
+          start: node.start,
+          end: node.end,
+          isAsync: node.async,
+          generated: false,
+        });
+      }
+
+      // Check function expressions and arrow functions assigned to variables
+      if (node.type === 'VariableDeclaration') {
+        for (const decl of node.declarations) {
+          if (decl.init && decl.id && decl.id.type === 'Identifier') {
+            const init = decl.init;
+            if (
+              (init.type === 'FunctionExpression' ||
+                init.type === 'ArrowFunctionExpression') &&
+              hasUseServerDirective(init.body)
+            ) {
+              actions.push({
+                name: decl.id.name,
+                start: node.start,
+                end: node.end,
+                isAsync: init.async,
+                generated: false,
+              });
+            }
+          }
+        }
+      }
+
+      // Check async function expressions passed directly (e.g., as props or in JSX)
+      if (
+        (node.type === 'FunctionExpression' ||
+          node.type === 'ArrowFunctionExpression') &&
+        hasUseServerDirective(node.body) &&
+        parent &&
+        parent.type !== 'VariableDeclarator'
+      ) {
+        // Anonymous inline action - generate a name
+        actionCounter++;
+        actions.push({
+          name: `$$ACTION_${actionCounter}`,
+          start: node.start,
+          end: node.end,
+          isAsync: node.async,
+          generated: true,
+          node: node,
+        });
+      }
+
+      // Recurse into child nodes
+      for (const key in node) {
+        if (key === 'parent') continue;
+        const child = node[key];
+        if (Array.isArray(child)) {
+          for (const c of child) {
+            visit(c, node, key);
+          }
+        } else if (child && typeof child === 'object' && child.type) {
+          visit(child, node, key);
+        }
+      }
+    }
+
+    visit(ast, null, null);
+  } catch (e) {
+    // Ignore parse errors
+  }
+
+  return actions;
+}
+
+module.exports = function rscServerLoader(source) {
+  const directive = getDirective(source);
+  const resourcePath = this.resourcePath;
+  const moduleUrl = url.pathToFileURL(resourcePath).href;
+
+  // Mark directive on buildInfo so the plugin can discover client refs from module graph
+  if (this && this._module && this._module.buildInfo) {
+    this._module.buildInfo.rscDirective = directive;
+  }
+
+  // 'use client' → Create client references (proxies)
+  if (directive === 'use client') {
+    const exports = getExports(source);
+
+    let output = `
+// RSC Server Loader: 'use client' module transformed to client references
+import { createClientModuleProxy } from 'react-server-dom-webpack/server.node';
+
+const proxy = createClientModuleProxy('${moduleUrl}');
+`;
+
+    for (const exp of exports) {
+      if (exp.name === 'default') {
+        output += `export default proxy.default;\n`;
+      } else {
+        output += `export const ${exp.name} = proxy['${exp.name}'];\n`;
+      }
+    }
+
+    return output;
+  }
+
+  // 'use server' at file level → Keep original + register server references
+  if (directive === 'use server') {
+    const exports = getExports(source);
+
+    // IMPORTANT: Keep 'use server' directive FIRST so ReactFlightPlugin can detect it
+    // The plugin's parser hook breaks out of the loop when it sees a non-directive statement
+    // Import must come AFTER the 'use server' directive line
+    const directiveLine = "'use server';\n";
+
+    // Remove the 'use server' directive from the original source since we'll add it back at the top
+    // Match 'use server' or "use server" with optional semicolon and whitespace
+    const sourceWithoutDirective = source.replace(
+      /^(['"])use server\1\s*;?\s*\n?/,
+      '',
+    );
+
+    // Import after directive so webpack resolves it through its module system (ensures singleton)
+    const importStatement = `// RSC Server Loader: Import for server action registration
+import { registerServerReference as __rsc_registerServerReference__ } from 'react-server-dom-webpack/server.node';
+`;
+
+    // Registration code uses the imported function
+    let registration = `
+// RSC Server Loader: Server action registration
+;(function() {
+  var registerServerReference = __rsc_registerServerReference__;
+`;
+
+    for (const exp of exports) {
+      const actionId = `${moduleUrl}#${exp.name}`;
+      if (exp.name === 'default') {
+        // For default exports, use the local function name if available
+        // This works with webpack's ES module output where exports.default is undefined
+        if (exp.localName) {
+          registration += `
+  if (typeof ${exp.localName} === 'function') {
+    registerServerReference(${exp.localName}, '${moduleUrl}', 'default');
+  }
+`;
+        } else {
+          // Fallback for anonymous default exports - try module.exports pattern
+          registration += `
+  if (typeof module !== 'undefined' && typeof module.exports === 'function') {
+    registerServerReference(module.exports, '${moduleUrl}', 'default');
+  } else if (typeof exports !== 'undefined' && typeof exports.default === 'function') {
+    registerServerReference(exports.default, '${moduleUrl}', 'default');
+  }
+`;
+        }
+      } else {
+        registration += `
+  if (typeof ${exp.name} === 'function') {
+    registerServerReference(${exp.name}, '${moduleUrl}', '${exp.name}');
+  }
+`;
+      }
+    }
+
+    registration += `})();`;
+
+    // Order: 'use server' directive (FIRST) → import → original source (without directive) → registration
+    return (
+      directiveLine +
+      importStatement +
+      sourceWithoutDirective +
+      '\n' +
+      registration
+    );
+  }
+
+  // Check for inline 'use server' functions (inside Server Components)
+  if (source.includes('use server')) {
+    const inlineActions = findInlineServerActions(source);
+
+    // Filter out anonymous/generated actions - they require source rewriting we don't support yet
+    // Only named functions (function declarations or variable-assigned functions) can be registered
+    const namedActions = inlineActions.filter((action) => !action.generated);
+
+    // Always clear stale entries for this module from previous compilation
+    // This ensures removed actions don't persist in the manifest
+    const existingEntries = moduleEntriesMap.get(moduleUrl);
+    if (existingEntries) {
+      for (const actionId of existingEntries) {
+        inlineServerActionsMap.delete(actionId);
+      }
+      moduleEntriesMap.delete(moduleUrl);
+    }
+
+    if (namedActions.length > 0) {
+      // Track new entries for this module
+      const newEntries = new Set();
+
+      // Register inline actions in shared map for plugin to generate manifest
+      for (const action of namedActions) {
+        const actionId = `${moduleUrl}#${action.name}`;
+        newEntries.add(actionId);
+        inlineServerActionsMap.set(actionId, {
+          id: moduleUrl,
+          name: action.name,
+          chunks: [],
+        });
+      }
+
+      moduleEntriesMap.set(moduleUrl, newEntries);
+
+      // Insert registration INSIDE the same scope as each action definition
+      // Sort by position descending so we can insert from end to beginning without affecting positions
+      const sorted = [...namedActions].sort((a, b) => b.end - a.end);
+
+      let result = source;
+
+      for (const action of sorted) {
+        // Insert registration right after the function definition, in the same lexical scope
+        // Use the imported __rsc_registerServerReference__ which webpack resolves through its module system
+        const registration = `\n;(function(){
+  if(typeof ${action.name}==='function'){
+    __rsc_registerServerReference__(${action.name},'${moduleUrl}','${action.name}');
+  }
+})();`;
+
+        result =
+          result.slice(0, action.end) + registration + result.slice(action.end);
+      }
+
+      // Prepend import for registerServerReference so webpack resolves it properly
+      const importPrefix = `// RSC Server Loader: Import for inline server action registration
+import { registerServerReference as __rsc_registerServerReference__ } from 'react-server-dom-webpack/server.node';
+`;
+      return importPrefix + result;
+    } else if (inlineActions.length > 0) {
+      // We found anonymous inline actions but can't register them
+      // Log a warning in development
+      if (process.env.NODE_ENV !== 'production') {
+        console.warn(
+          `[rsc-server-loader] Found ${inlineActions.length} anonymous inline 'use server' function(s) in ${resourcePath}. ` +
+            `These cannot be registered as server actions. Assign the function to a variable first.`,
+        );
+      }
+    }
+  }
+
+  // No directive - pass through unchanged
+  return source;
+};
+
+// Export helper for testing and the shared map
+module.exports.findInlineServerActions = findInlineServerActions;
+module.exports.inlineServerActionsMap = inlineServerActionsMap;
diff --git a/cjs/rsc-ssr-loader.js b/cjs/rsc-ssr-loader.js
new file mode 100644
index 0000000000000000000000000000000000000000..e49bc77e2673d01314631237aead4f076d19097d
--- /dev/null
+++ b/cjs/rsc-ssr-loader.js
@@ -0,0 +1,117 @@
+/**
+ * rsc-ssr-loader.js
+ *
+ * Webpack loader for the SSR (Server-Side Rendering) layer.
+ *
+ * Transformations:
+ * - 'use server' modules → Stubs that throw errors
+ *   (Server actions should not be called during SSR)
+ * - 'use client' modules → Pass through (actual components for SSR)
+ *
+ * This loader runs on the SERVER during SSR/hydration.
+ */
+
+'use strict';
+
+const acorn = require('acorn-loose');
+const url = require('url');
+
+function getDirective(source) {
+  if (!source.includes('use client') && !source.includes('use server'))
+    return null;
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type !== 'ExpressionStatement' || !node.directive) break;
+      if (node.directive === 'use client') return 'use client';
+      if (node.directive === 'use server') return 'use server';
+    }
+  } catch (e) {
+    return null;
+  }
+  return null;
+}
+
+function getExports(source) {
+  const exports = [];
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type === 'ExportNamedDeclaration') {
+        if (node.declaration) {
+          if (
+            node.declaration.type === 'FunctionDeclaration' &&
+            node.declaration.id
+          ) {
+            exports.push(node.declaration.id.name);
+          }
+          if (node.declaration.type === 'VariableDeclaration') {
+            for (const decl of node.declaration.declarations) {
+              if (decl.id && decl.id.type === 'Identifier') {
+                exports.push(decl.id.name);
+              }
+            }
+          }
+        }
+      }
+      if (node.type === 'ExportDefaultDeclaration') {
+        exports.push('default');
+      }
+    }
+  } catch (e) {
+    // Ignore parse errors
+  }
+  return exports;
+}
+
+module.exports = function rscSsrLoader(source) {
+  const directive = getDirective(source);
+
+  // 'use server' → Create stubs that throw errors
+  // Server actions should never be called during SSR
+  if (directive === 'use server') {
+    const exports = getExports(source);
+    const resourcePath = this.resourcePath;
+
+    let output = `'use strict';
+// RSC SSR Loader: 'use server' module replaced with stubs
+// Server actions cannot be called during SSR
+`;
+
+    const defaultExport = exports.includes('default');
+
+    exports.forEach((name) => {
+      const stubBody = `function() {
+  throw new Error(
+    'Server action "${name}" from "${resourcePath}" cannot be called during SSR. ' +
+    'Server actions should only be invoked from client-side code after hydration.'
+  );
+}`;
+
+      if (name === 'default') {
+        // Keep an ESM-style marker for tests while emitting CJS
+        output += `// export default function()\n`;
+        output += `module.exports = ${stubBody};\n`;
+      } else {
+        output += `// export const ${name} = function()\n`;
+        output += `exports.${name} = ${stubBody};\n`;
+      }
+    });
+
+    if (!defaultExport) {
+      output += `module.exports = exports;\n`;
+    }
+
+    return output;
+  }
+
+  // 'use client' and other modules - pass through unchanged
+  // SSR needs the actual client component code to render
+  return source;
+};
diff --git a/package.json b/package.json
index 573c3878f0f25ea806a00ec0e7031f8537dee6cc..04265c1e688c6e854a6d89d5f85f87715b740a78 100644
--- a/package.json
+++ b/package.json
@@ -87,7 +87,10 @@
     "./static.node.unbundled": "./static.node.unbundled.js",
     "./node-loader": "./esm/react-server-dom-webpack-node-loader.production.js",
     "./node-register": "./node-register.js",
-    "./package.json": "./package.json"
+    "./package.json": "./package.json",
+    "./rsc-server-loader": "./cjs/rsc-server-loader.js",
+    "./rsc-ssr-loader": "./cjs/rsc-ssr-loader.js",
+    "./rsc-client-loader": "./cjs/rsc-client-loader.js"
   },
   "main": "index.js",
   "repository": {
diff --git a/server.node.js b/server.node.js
index e507f643634609e7dfff8682c726859a5159dd06..38524494e6967fba5093e1743c8fa0ae38bb78c5 100644
--- a/server.node.js
+++ b/server.node.js
@@ -7,6 +7,95 @@ if (process.env.NODE_ENV === 'production') {
   s = require('./cjs/react-server-dom-webpack-server.node.development.js');
 }
 
+// Use globalThis to ensure singleton registry across webpack module instances.
+// This is necessary because webpack's share scope may create multiple module
+// instances with different IDs that each execute this code.
+const REGISTRY_KEY = '__RSC_SERVER_ACTION_REGISTRY__';
+const MANIFEST_KEY = '__RSC_DYNAMIC_MANIFEST__';
+
+// Global registry for inline server actions
+// This allows action lookup for functions not exported from modules
+if (!globalThis[REGISTRY_KEY]) {
+  globalThis[REGISTRY_KEY] = new Map();
+}
+const serverActionRegistry = globalThis[REGISTRY_KEY];
+
+// Dynamic manifest entries for actions registered at runtime (inline actions)
+// Key: actionId, Value: { id, name, chunks }
+if (!globalThis[MANIFEST_KEY]) {
+  globalThis[MANIFEST_KEY] = new Map();
+}
+const dynamicServerActionsManifest = globalThis[MANIFEST_KEY];
+
+/**
+ * Wrap registerServerReference to also store in global registry
+ * This enables lookup of inline server actions defined inside components
+ */
+function registerServerReferenceWithRegistry(reference, id, exportName) {
+  // Call the original implementation
+  const result = s.registerServerReference(reference, id, exportName);
+
+  // Store in global registry for lookup
+  const actionId = exportName === null ? id : id + '#' + exportName;
+  serverActionRegistry.set(actionId, reference);
+
+  // Debug: log registration
+  if (process.env.RSC_DEBUG) {
+    console.log(
+      `[RSC Registry] Registered action: ${actionId} (registry size: ${serverActionRegistry.size})`,
+    );
+  }
+
+  // Also keep a manifest entry so decodeReply can resolve dynamic inline actions
+  dynamicServerActionsManifest.set(actionId, {
+    id,
+    name: exportName === null ? 'default' : exportName,
+    chunks: [],
+  });
+
+  return result;
+}
+
+/**
+ * Get a server action function by its ID
+ * Used by action handlers to find inline server actions
+ */
+function getServerAction(actionId) {
+  const result = serverActionRegistry.get(actionId);
+  // Debug: log lookup
+  if (process.env.RSC_DEBUG) {
+    console.log(
+      `[RSC Registry] Lookup action: ${actionId} -> ${result ? 'FOUND' : 'NOT FOUND'} (registry size: ${serverActionRegistry.size})`,
+    );
+    if (!result) {
+      console.log(
+        `[RSC Registry] Available actions: ${Array.from(serverActionRegistry.keys()).join(', ')}`,
+      );
+    }
+  }
+  return result;
+}
+
+function getDynamicServerActionsManifest() {
+  const entries = {};
+  for (const [key, value] of dynamicServerActionsManifest) {
+    entries[key] = value;
+  }
+  return entries;
+}
+
+/**
+ * Clear the server action registry (for testing purposes)
+ * This is needed when reloading bundles in tests to ensure fresh state
+ */
+function clearServerActionRegistry() {
+  serverActionRegistry.clear();
+  dynamicServerActionsManifest.clear();
+  if (process.env.RSC_DEBUG) {
+    console.log('[RSC Registry] Cleared registry and manifest');
+  }
+}
+
 exports.renderToReadableStream = s.renderToReadableStream;
 exports.renderToPipeableStream = s.renderToPipeableStream;
 exports.decodeReply = s.decodeReply;
@@ -14,7 +103,14 @@ exports.decodeReplyFromBusboy = s.decodeReplyFromBusboy;
 exports.decodeReplyFromAsyncIterable = s.decodeReplyFromAsyncIterable;
 exports.decodeAction = s.decodeAction;
 exports.decodeFormState = s.decodeFormState;
-exports.registerServerReference = s.registerServerReference;
+exports.registerServerReference = registerServerReferenceWithRegistry;
 exports.registerClientReference = s.registerClientReference;
 exports.createClientModuleProxy = s.createClientModuleProxy;
 exports.createTemporaryReferenceSet = s.createTemporaryReferenceSet;
+
+// Export registry access for action handlers
+exports.getServerAction = getServerAction;
+exports.serverActionRegistry = serverActionRegistry;
+exports.getDynamicServerActionsManifest = getDynamicServerActionsManifest;
+
+exports.clearServerActionRegistry = clearServerActionRegistry;
diff --git a/server.node.unbundled.js b/server.node.unbundled.js
index 5ecd09924975eaa9d5f7cd14fa099f0ba26dc905..42dc18beb0e0efa480f293724f0ea38ad23e33d5 100644
--- a/server.node.unbundled.js
+++ b/server.node.unbundled.js
@@ -7,6 +7,51 @@ if (process.env.NODE_ENV === 'production') {
   s = require('./cjs/react-server-dom-webpack-server.node.unbundled.development.js');
 }
 
+// Global registry for inline server actions
+// This allows action lookup for functions not exported from modules
+const serverActionRegistry = new Map();
+
+// Dynamic manifest entries for actions registered at runtime (inline actions)
+const dynamicServerActionsManifest = new Map();
+
+/**
+ * Wrap registerServerReference to also store in global registry
+ * This enables lookup of inline server actions defined inside components
+ */
+function registerServerReferenceWithRegistry(reference, id, exportName) {
+  // Call the original implementation
+  const result = s.registerServerReference(reference, id, exportName);
+
+  // Store in global registry for lookup
+  const actionId = exportName === null ? id : id + '#' + exportName;
+  serverActionRegistry.set(actionId, reference);
+
+  // Keep a manifest entry so decodeReply can resolve dynamic inline actions
+  dynamicServerActionsManifest.set(actionId, {
+    id,
+    name: exportName === null ? 'default' : exportName,
+    chunks: [],
+  });
+
+  return result;
+}
+
+/**
+ * Get a server action function by its ID
+ * Used by action handlers to find inline server actions
+ */
+function getServerAction(actionId) {
+  return serverActionRegistry.get(actionId);
+}
+
+function getDynamicServerActionsManifest() {
+  const entries = {};
+  for (const [key, value] of dynamicServerActionsManifest) {
+    entries[key] = value;
+  }
+  return entries;
+}
+
 exports.renderToReadableStream = s.renderToReadableStream;
 exports.renderToPipeableStream = s.renderToPipeableStream;
 exports.decodeReply = s.decodeReply;
@@ -14,7 +59,12 @@ exports.decodeReplyFromBusboy = s.decodeReplyFromBusboy;
 exports.decodeReplyFromAsyncIterable = s.decodeReplyFromAsyncIterable;
 exports.decodeAction = s.decodeAction;
 exports.decodeFormState = s.decodeFormState;
-exports.registerServerReference = s.registerServerReference;
+exports.registerServerReference = registerServerReferenceWithRegistry;
 exports.registerClientReference = s.registerClientReference;
 exports.createClientModuleProxy = s.createClientModuleProxy;
 exports.createTemporaryReferenceSet = s.createTemporaryReferenceSet;
+
+// Export registry access for action handlers
+exports.getServerAction = getServerAction;
+exports.serverActionRegistry = serverActionRegistry;
+exports.getDynamicServerActionsManifest = getDynamicServerActionsManifest;
