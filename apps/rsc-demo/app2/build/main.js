/******/ (() => {
  // webpackBootstrap
  /******/ var __webpack_modules__ = {
    /***/ './node_modules/.federation/entry.cf3c121db0a10666d8c94d6c149b9b19.js':
      /***/ (
        __unused_webpack_module,
        __unused_webpack___webpack_exports__,
        __webpack_require__,
      ) => {
        'use strict';

        // NAMESPACE OBJECT: ../../../packages/runtime/dist/index.esm.js
        var runtime_dist_index_esm_namespaceObject = {};
        __webpack_require__.r(runtime_dist_index_esm_namespaceObject);
        __webpack_require__.d(runtime_dist_index_esm_namespaceObject, {
          Module: () => Module,
          ModuleFederation: () => ModuleFederation,
          createInstance: () => createInstance,
          getInstance: () => getInstance,
          getRemoteEntry: () => getRemoteEntry,
          getRemoteInfo: () => getRemoteInfo,
          init: () => init,
          loadRemote: () => loadRemote,
          loadScript: () => index_esm /* loadScript */.ve,
          loadScriptNode: () => index_esm /* loadScriptNode */.qN,
          loadShare: () => loadShare,
          loadShareSync: () => loadShareSync,
          preloadRemote: () => preloadRemote,
          registerGlobalPlugins: () => registerGlobalPlugins,
          registerPlugins: () => index_esm_registerPlugins,
          registerRemotes: () => registerRemotes,
          registerShared: () => registerShared,
        });

        // EXTERNAL MODULE: ../../../packages/sdk/dist/index.esm.js
        var index_esm = __webpack_require__(
          '(client)/../../../packages/sdk/dist/index.esm.js',
        ); // CONCATENATED MODULE: ../../../packages/error-codes/dist/index.esm.mjs
        const RUNTIME_001 = 'RUNTIME-001';
        const RUNTIME_002 = 'RUNTIME-002';
        const RUNTIME_003 = 'RUNTIME-003';
        const RUNTIME_004 = 'RUNTIME-004';
        const RUNTIME_005 = 'RUNTIME-005';
        const RUNTIME_006 = 'RUNTIME-006';
        const RUNTIME_007 = 'RUNTIME-007';
        const RUNTIME_008 = 'RUNTIME-008';
        const RUNTIME_009 = 'RUNTIME-009';
        const TYPE_001 = 'TYPE-001';
        const BUILD_001 = 'BUILD-001';
        const BUILD_002 = 'BUILD-002';
        const getDocsUrl = (errorCode) => {
          const type = errorCode.split('-')[0].toLowerCase();
          return `View the docs to see how to solve: https://module-federation.io/guide/troubleshooting/${type}#${errorCode.toLowerCase()}`;
        };
        const getShortErrorMsg = (
          errorCode,
          errorDescMap,
          args,
          originalErrorMsg,
        ) => {
          const msg = [`${[errorDescMap[errorCode]]} #${errorCode}`];
          args && msg.push(`args: ${JSON.stringify(args)}`);
          msg.push(getDocsUrl(errorCode));
          originalErrorMsg &&
            msg.push(`Original Error Message:\n ${originalErrorMsg}`);
          return msg.join('\n');
        };
        const runtimeDescMap = {
          [RUNTIME_001]: 'Failed to get remoteEntry exports.',
          [RUNTIME_002]: 'The remote entry interface does not contain "init"',
          [RUNTIME_003]: 'Failed to get manifest.',
          [RUNTIME_004]: 'Failed to locate remote.',
          [RUNTIME_005]:
            'Invalid loadShareSync function call from bundler runtime',
          [RUNTIME_006]: 'Invalid loadShareSync function call from runtime',
          [RUNTIME_007]: 'Failed to get remote snapshot.',
          [RUNTIME_008]: 'Failed to load script resources.',
          [RUNTIME_009]: 'Please call createInstance first.',
        };
        const typeDescMap = {
          [TYPE_001]:
            'Failed to generate type declaration. Execute the below cmd to reproduce and fix the error.',
        };
        const buildDescMap = {
          [BUILD_001]: 'Failed to find expose module.',
          [BUILD_002]: 'PublicPath is required in prod mode.',
        };
        const errorDescMap = {
          ...runtimeDescMap,
          ...typeDescMap,
          ...buildDescMap,
        }; // CONCATENATED MODULE: ../../../packages/runtime-core/dist/index.esm.js

        const LOG_CATEGORY = '[ Federation Runtime ]';
        // FIXME: pre-bundle ?
        const logger = (0, index_esm /* createLogger */.UC)(LOG_CATEGORY);
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        function assert(condition, msg) {
          if (!condition) {
            error(msg);
          }
        }
        function error(msg) {
          if (msg instanceof Error) {
            // Check if the message already starts with the log category to avoid duplication
            if (!msg.message.startsWith(LOG_CATEGORY)) {
              msg.message = `${LOG_CATEGORY}: ${msg.message}`;
            }
            throw msg;
          }
          throw new Error(`${LOG_CATEGORY}: ${msg}`);
        }
        function warn(msg) {
          if (msg instanceof Error) {
            // Check if the message already starts with the log category to avoid duplication
            if (!msg.message.startsWith(LOG_CATEGORY)) {
              msg.message = `${LOG_CATEGORY}: ${msg.message}`;
            }
            logger.warn(msg);
          } else {
            logger.warn(msg);
          }
        }
        function addUniqueItem(arr, item) {
          if (arr.findIndex((name) => name === item) === -1) {
            arr.push(item);
          }
          return arr;
        }
        function getFMId(remoteInfo) {
          if ('version' in remoteInfo && remoteInfo.version) {
            return `${remoteInfo.name}:${remoteInfo.version}`;
          } else if ('entry' in remoteInfo && remoteInfo.entry) {
            return `${remoteInfo.name}:${remoteInfo.entry}`;
          } else {
            return `${remoteInfo.name}`;
          }
        }
        function isRemoteInfoWithEntry(remote) {
          return typeof remote.entry !== 'undefined';
        }
        function isPureRemoteEntry(remote) {
          return !remote.entry.includes('.json');
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        async function safeWrapper(callback, disableWarn) {
          try {
            const res = await callback();
            return res;
          } catch (e) {
            !disableWarn && warn(e);
            return;
          }
        }
        function isObject(val) {
          return val && typeof val === 'object';
        }
        const objectToString = Object.prototype.toString;
        // eslint-disable-next-line @typescript-eslint/ban-types
        function isPlainObject(val) {
          return objectToString.call(val) === '[object Object]';
        }
        function isStaticResourcesEqual(url1, url2) {
          const REG_EXP = /^(https?:)?\/\//i;
          // Transform url1 and url2 into relative paths
          const relativeUrl1 = url1.replace(REG_EXP, '').replace(/\/$/, '');
          const relativeUrl2 = url2.replace(REG_EXP, '').replace(/\/$/, '');
          // Check if the relative paths are identical
          return relativeUrl1 === relativeUrl2;
        }
        function arrayOptions(options) {
          return Array.isArray(options) ? options : [options];
        }
        function getRemoteEntryInfoFromSnapshot(snapshot) {
          const defaultRemoteEntryInfo = {
            url: '',
            type: 'global',
            globalName: '',
          };
          if (
            (0, index_esm /* isBrowserEnv */.kP)() ||
            (0, index_esm /* isReactNativeEnv */.WB)() ||
            !('ssrRemoteEntry' in snapshot)
          ) {
            return 'remoteEntry' in snapshot
              ? {
                  url: snapshot.remoteEntry,
                  type: snapshot.remoteEntryType,
                  globalName: snapshot.globalName,
                }
              : defaultRemoteEntryInfo;
          }
          if ('ssrRemoteEntry' in snapshot && snapshot.ssrRemoteEntry) {
            return {
              url: snapshot.ssrRemoteEntry || defaultRemoteEntryInfo.url,
              type: snapshot.ssrRemoteEntryType || defaultRemoteEntryInfo.type,
              globalName: snapshot.globalName,
            };
          }
          return 'remoteEntry' in snapshot
            ? {
                url: snapshot.remoteEntry,
                type: snapshot.remoteEntryType,
                globalName: snapshot.globalName,
              }
            : defaultRemoteEntryInfo;
        }
        const processModuleAlias = (name, subPath) => {
          // @host/ ./button -> @host/button
          let moduleName;
          if (name.endsWith('/')) {
            moduleName = name.slice(0, -1);
          } else {
            moduleName = name;
          }
          if (subPath.startsWith('.')) {
            subPath = subPath.slice(1);
          }
          moduleName = moduleName + subPath;
          return moduleName;
        };
        const CurrentGlobal =
          typeof globalThis === 'object' ? globalThis : window;
        const nativeGlobal = (() => {
          try {
            // get real window (incase of sandbox)
            return document.defaultView;
          } catch {
            // node env
            return CurrentGlobal;
          }
        })();
        const Global = nativeGlobal;
        function definePropertyGlobalVal(target, key, val) {
          Object.defineProperty(target, key, {
            value: val,
            configurable: false,
            writable: true,
          });
        }
        function includeOwnProperty(target, key) {
          return Object.hasOwnProperty.call(target, key);
        }
        // This section is to prevent encapsulation by certain microfrontend frameworks. Due to reuse policies, sandbox escapes.
        // The sandbox in the microfrontend does not replicate the value of 'configurable'.
        // If there is no loading content on the global object, this section defines the loading object.
        if (
          !includeOwnProperty(CurrentGlobal, '__GLOBAL_LOADING_REMOTE_ENTRY__')
        ) {
          definePropertyGlobalVal(
            CurrentGlobal,
            '__GLOBAL_LOADING_REMOTE_ENTRY__',
            {},
          );
        }
        const globalLoading = CurrentGlobal.__GLOBAL_LOADING_REMOTE_ENTRY__;
        function setGlobalDefaultVal(target) {
          if (
            includeOwnProperty(target, '__VMOK__') &&
            !includeOwnProperty(target, '__FEDERATION__')
          ) {
            definePropertyGlobalVal(target, '__FEDERATION__', target.__VMOK__);
          }
          if (!includeOwnProperty(target, '__FEDERATION__')) {
            definePropertyGlobalVal(target, '__FEDERATION__', {
              __GLOBAL_PLUGIN__: [],
              __INSTANCES__: [],
              moduleInfo: {},
              __SHARE__: {},
              __MANIFEST_LOADING__: {},
              __PRELOADED_MAP__: new Map(),
            });
            definePropertyGlobalVal(target, '__VMOK__', target.__FEDERATION__);
          }
          target.__FEDERATION__.__GLOBAL_PLUGIN__ ??= [];
          target.__FEDERATION__.__INSTANCES__ ??= [];
          target.__FEDERATION__.moduleInfo ??= {};
          target.__FEDERATION__.__SHARE__ ??= {};
          target.__FEDERATION__.__MANIFEST_LOADING__ ??= {};
          target.__FEDERATION__.__PRELOADED_MAP__ ??= new Map();
        }
        setGlobalDefaultVal(CurrentGlobal);
        setGlobalDefaultVal(nativeGlobal);
        function resetFederationGlobalInfo() {
          CurrentGlobal.__FEDERATION__.__GLOBAL_PLUGIN__ = [];
          CurrentGlobal.__FEDERATION__.__INSTANCES__ = [];
          CurrentGlobal.__FEDERATION__.moduleInfo = {};
          CurrentGlobal.__FEDERATION__.__SHARE__ = {};
          CurrentGlobal.__FEDERATION__.__MANIFEST_LOADING__ = {};
          Object.keys(globalLoading).forEach((key) => {
            delete globalLoading[key];
          });
        }
        function setGlobalFederationInstance(FederationInstance) {
          CurrentGlobal.__FEDERATION__.__INSTANCES__.push(FederationInstance);
        }
        function getGlobalFederationConstructor() {
          return CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR__;
        }
        function setGlobalFederationConstructor(
          FederationConstructor,
          isDebug = (0, index_esm /* isDebugMode */.Au)(),
        ) {
          if (isDebug) {
            CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR__ =
              FederationConstructor;
            CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ =
              '0.24.1';
          }
        }
        // eslint-disable-next-line @typescript-eslint/ban-types
        function getInfoWithoutType(target, key) {
          if (typeof key === 'string') {
            const keyRes = target[key];
            if (keyRes) {
              return {
                value: target[key],
                key: key,
              };
            } else {
              const targetKeys = Object.keys(target);
              for (const targetKey of targetKeys) {
                const [targetTypeOrName, _] = targetKey.split(':');
                const nKey = `${targetTypeOrName}:${key}`;
                const typeWithKeyRes = target[nKey];
                if (typeWithKeyRes) {
                  return {
                    value: typeWithKeyRes,
                    key: nKey,
                  };
                }
              }
              return {
                value: undefined,
                key: key,
              };
            }
          } else {
            throw new Error('key must be string');
          }
        }
        const getGlobalSnapshot = () => nativeGlobal.__FEDERATION__.moduleInfo;
        const getTargetSnapshotInfoByModuleInfo = (moduleInfo, snapshot) => {
          // Check if the remote is included in the hostSnapshot
          const moduleKey = getFMId(moduleInfo);
          const getModuleInfo = getInfoWithoutType(snapshot, moduleKey).value;
          // The remoteSnapshot might not include a version
          if (
            getModuleInfo &&
            !getModuleInfo.version &&
            'version' in moduleInfo &&
            moduleInfo['version']
          ) {
            getModuleInfo.version = moduleInfo['version'];
          }
          if (getModuleInfo) {
            return getModuleInfo;
          }
          // If the remote is not included in the hostSnapshot, deploy a micro app snapshot
          if ('version' in moduleInfo && moduleInfo['version']) {
            const { version, ...resModuleInfo } = moduleInfo;
            const moduleKeyWithoutVersion = getFMId(resModuleInfo);
            const getModuleInfoWithoutVersion = getInfoWithoutType(
              nativeGlobal.__FEDERATION__.moduleInfo,
              moduleKeyWithoutVersion,
            ).value;
            if (getModuleInfoWithoutVersion?.version === version) {
              return getModuleInfoWithoutVersion;
            }
          }
          return;
        };
        const getGlobalSnapshotInfoByModuleInfo = (moduleInfo) =>
          getTargetSnapshotInfoByModuleInfo(
            moduleInfo,
            nativeGlobal.__FEDERATION__.moduleInfo,
          );
        const setGlobalSnapshotInfoByModuleInfo = (
          remoteInfo,
          moduleDetailInfo,
        ) => {
          const moduleKey = getFMId(remoteInfo);
          nativeGlobal.__FEDERATION__.moduleInfo[moduleKey] = moduleDetailInfo;
          return nativeGlobal.__FEDERATION__.moduleInfo;
        };
        const addGlobalSnapshot = (moduleInfos) => {
          nativeGlobal.__FEDERATION__.moduleInfo = {
            ...nativeGlobal.__FEDERATION__.moduleInfo,
            ...moduleInfos,
          };
          return () => {
            const keys = Object.keys(moduleInfos);
            for (const key of keys) {
              delete nativeGlobal.__FEDERATION__.moduleInfo[key];
            }
          };
        };
        const getRemoteEntryExports = (name, globalName) => {
          const remoteEntryKey = globalName || `__FEDERATION_${name}:custom__`;
          const entryExports = CurrentGlobal[remoteEntryKey];
          return {
            remoteEntryKey,
            entryExports,
          };
        };
        // This function is used to register global plugins.
        // It iterates over the provided plugins and checks if they are already registered.
        // If a plugin is not registered, it is added to the global plugins.
        // If a plugin is already registered, a warning message is logged.
        const registerGlobalPlugins = (plugins) => {
          const { __GLOBAL_PLUGIN__ } = nativeGlobal.__FEDERATION__;
          plugins.forEach((plugin) => {
            if (
              __GLOBAL_PLUGIN__.findIndex((p) => p.name === plugin.name) === -1
            ) {
              __GLOBAL_PLUGIN__.push(plugin);
            } else {
              warn(`The plugin ${plugin.name} has been registered.`);
            }
          });
        };
        const getGlobalHostPlugins = () =>
          nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__;
        const getPreloaded = (id) =>
          CurrentGlobal.__FEDERATION__.__PRELOADED_MAP__.get(id);
        const setPreloaded = (id) =>
          CurrentGlobal.__FEDERATION__.__PRELOADED_MAP__.set(id, true);
        const DEFAULT_SCOPE = 'default';
        const DEFAULT_REMOTE_TYPE = 'global';

        // fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
        // those constants are based on https://www.rubydoc.info/gems/semantic_range/3.0.0/SemanticRange#BUILDIDENTIFIER-constant
        // Copyright (c)
        // vite-plugin-federation is licensed under Mulan PSL v2.
        // You can use this software according to the terms and conditions of the Mulan PSL v2.
        // You may obtain a copy of Mulan PSL v2 at:
        //      http://license.coscl.org.cn/MulanPSL2
        // THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
        // See the Mulan PSL v2 for more details.
        const buildIdentifier = '[0-9A-Za-z-]+';
        const build = `(?:\\+(${buildIdentifier}(?:\\.${buildIdentifier})*))`;
        const numericIdentifier = '0|[1-9]\\d*';
        const numericIdentifierLoose = '[0-9]+';
        const nonNumericIdentifier = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
        const preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`;
        const preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\.${preReleaseIdentifierLoose})*))`;
        const preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`;
        const preRelease = `(?:-(${preReleaseIdentifier}(?:\\.${preReleaseIdentifier})*))`;
        const xRangeIdentifier = `${numericIdentifier}|x|X|\\*`;
        const xRangePlain = `[v=\\s]*(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`;
        const hyphenRange = `^\\s*(${xRangePlain})\\s+-\\s+(${xRangePlain})\\s*$`;
        const mainVersionLoose = `(${numericIdentifierLoose})\\.(${numericIdentifierLoose})\\.(${numericIdentifierLoose})`;
        const loosePlain = `[v=\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`;
        const gtlt = '((?:<|>)?=?)';
        const comparatorTrim = `(\\s*)${gtlt}\\s*(${loosePlain}|${xRangePlain})`;
        const loneTilde = '(?:~>?)';
        const tildeTrim = `(\\s*)${loneTilde}\\s+`;
        const loneCaret = '(?:\\^)';
        const caretTrim = `(\\s*)${loneCaret}\\s+`;
        const star = '(<|>)?=?\\s*\\*';
        const caret = `^${loneCaret}${xRangePlain}$`;
        const mainVersion = `(${numericIdentifier})\\.(${numericIdentifier})\\.(${numericIdentifier})`;
        const fullPlain = `v?${mainVersion}${preRelease}?${build}?`;
        const tilde = `^${loneTilde}${xRangePlain}$`;
        const xRange = `^${gtlt}\\s*${xRangePlain}$`;
        const comparator = `^${gtlt}\\s*(${fullPlain})$|^$`;
        // copy from semver package
        const gte0 = '^\\s*>=\\s*0.0.0\\s*$';

        // fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
        // Copyright (c)
        // vite-plugin-federation is licensed under Mulan PSL v2.
        // You can use this software according to the terms and conditions of the Mulan PSL v2.
        // You may obtain a copy of Mulan PSL v2 at:
        //      http://license.coscl.org.cn/MulanPSL2
        // THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
        // See the Mulan PSL v2 for more details.
        function parseRegex(source) {
          return new RegExp(source);
        }
        function isXVersion(version) {
          return !version || version.toLowerCase() === 'x' || version === '*';
        }
        function pipe(...fns) {
          return (x) => fns.reduce((v, f) => f(v), x);
        }
        function extractComparator(comparatorString) {
          return comparatorString.match(parseRegex(comparator));
        }
        function combineVersion(major, minor, patch, preRelease) {
          const mainVersion = `${major}.${minor}.${patch}`;
          if (preRelease) {
            return `${mainVersion}-${preRelease}`;
          }
          return mainVersion;
        }

        // fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
        // Copyright (c)
        // vite-plugin-federation is licensed under Mulan PSL v2.
        // You can use this software according to the terms and conditions of the Mulan PSL v2.
        // You may obtain a copy of Mulan PSL v2 at:
        //      http://license.coscl.org.cn/MulanPSL2
        // THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
        // See the Mulan PSL v2 for more details.
        function parseHyphen(range) {
          return range.replace(
            parseRegex(hyphenRange),
            (
              _range,
              from,
              fromMajor,
              fromMinor,
              fromPatch,
              _fromPreRelease,
              _fromBuild,
              to,
              toMajor,
              toMinor,
              toPatch,
              toPreRelease,
            ) => {
              if (isXVersion(fromMajor)) {
                from = '';
              } else if (isXVersion(fromMinor)) {
                from = `>=${fromMajor}.0.0`;
              } else if (isXVersion(fromPatch)) {
                from = `>=${fromMajor}.${fromMinor}.0`;
              } else {
                from = `>=${from}`;
              }
              if (isXVersion(toMajor)) {
                to = '';
              } else if (isXVersion(toMinor)) {
                to = `<${Number(toMajor) + 1}.0.0-0`;
              } else if (isXVersion(toPatch)) {
                to = `<${toMajor}.${Number(toMinor) + 1}.0-0`;
              } else if (toPreRelease) {
                to = `<=${toMajor}.${toMinor}.${toPatch}-${toPreRelease}`;
              } else {
                to = `<=${to}`;
              }
              return `${from} ${to}`.trim();
            },
          );
        }
        function parseComparatorTrim(range) {
          return range.replace(parseRegex(comparatorTrim), '$1$2$3');
        }
        function parseTildeTrim(range) {
          return range.replace(parseRegex(tildeTrim), '$1~');
        }
        function parseCaretTrim(range) {
          return range.replace(parseRegex(caretTrim), '$1^');
        }
        function parseCarets(range) {
          return range
            .trim()
            .split(/\s+/)
            .map((rangeVersion) =>
              rangeVersion.replace(
                parseRegex(caret),
                (_, major, minor, patch, preRelease) => {
                  if (isXVersion(major)) {
                    return '';
                  } else if (isXVersion(minor)) {
                    return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;
                  } else if (isXVersion(patch)) {
                    if (major === '0') {
                      return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;
                    } else {
                      return `>=${major}.${minor}.0 <${Number(major) + 1}.0.0-0`;
                    }
                  } else if (preRelease) {
                    if (major === '0') {
                      if (minor === '0') {
                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${minor}.${Number(patch) + 1}-0`;
                      } else {
                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;
                      }
                    } else {
                      return `>=${major}.${minor}.${patch}-${preRelease} <${Number(major) + 1}.0.0-0`;
                    }
                  } else {
                    if (major === '0') {
                      if (minor === '0') {
                        return `>=${major}.${minor}.${patch} <${major}.${minor}.${Number(patch) + 1}-0`;
                      } else {
                        return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;
                      }
                    }
                    return `>=${major}.${minor}.${patch} <${Number(major) + 1}.0.0-0`;
                  }
                },
              ),
            )
            .join(' ');
        }
        function parseTildes(range) {
          return range
            .trim()
            .split(/\s+/)
            .map((rangeVersion) =>
              rangeVersion.replace(
                parseRegex(tilde),
                (_, major, minor, patch, preRelease) => {
                  if (isXVersion(major)) {
                    return '';
                  } else if (isXVersion(minor)) {
                    return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;
                  } else if (isXVersion(patch)) {
                    return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;
                  } else if (preRelease) {
                    return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;
                  }
                  return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;
                },
              ),
            )
            .join(' ');
        }
        function parseXRanges(range) {
          return range
            .split(/\s+/)
            .map((rangeVersion) =>
              rangeVersion
                .trim()
                .replace(
                  parseRegex(xRange),
                  (ret, gtlt, major, minor, patch, preRelease) => {
                    const isXMajor = isXVersion(major);
                    const isXMinor = isXMajor || isXVersion(minor);
                    const isXPatch = isXMinor || isXVersion(patch);
                    if (gtlt === '=' && isXPatch) {
                      gtlt = '';
                    }
                    preRelease = '';
                    if (isXMajor) {
                      if (gtlt === '>' || gtlt === '<') {
                        // nothing is allowed
                        return '<0.0.0-0';
                      } else {
                        // nothing is forbidden
                        return '*';
                      }
                    } else if (gtlt && isXPatch) {
                      // replace X with 0
                      if (isXMinor) {
                        minor = 0;
                      }
                      patch = 0;
                      if (gtlt === '>') {
                        // >1 => >=2.0.0
                        // >1.2 => >=1.3.0
                        gtlt = '>=';
                        if (isXMinor) {
                          major = Number(major) + 1;
                          minor = 0;
                          patch = 0;
                        } else {
                          minor = Number(minor) + 1;
                          patch = 0;
                        }
                      } else if (gtlt === '<=') {
                        // <=0.7.x is actually <0.8.0, since any 0.7.x should pass
                        // Similarly, <=7.x is actually <8.0.0, etc.
                        gtlt = '<';
                        if (isXMinor) {
                          major = Number(major) + 1;
                        } else {
                          minor = Number(minor) + 1;
                        }
                      }
                      if (gtlt === '<') {
                        preRelease = '-0';
                      }
                      return `${gtlt + major}.${minor}.${patch}${preRelease}`;
                    } else if (isXMinor) {
                      return `>=${major}.0.0${preRelease} <${Number(major) + 1}.0.0-0`;
                    } else if (isXPatch) {
                      return `>=${major}.${minor}.0${preRelease} <${major}.${Number(minor) + 1}.0-0`;
                    }
                    return ret;
                  },
                ),
            )
            .join(' ');
        }
        function parseStar(range) {
          return range.trim().replace(parseRegex(star), '');
        }
        function parseGTE0(comparatorString) {
          return comparatorString.trim().replace(parseRegex(gte0), '');
        }

        // fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
        // Copyright (c)
        // vite-plugin-federation is licensed under Mulan PSL v2.
        // You can use this software according to the terms and conditions of the Mulan PSL v2.
        // You may obtain a copy of Mulan PSL v2 at:
        //      http://license.coscl.org.cn/MulanPSL2
        // THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
        // See the Mulan PSL v2 for more details.
        function compareAtom(rangeAtom, versionAtom) {
          rangeAtom = Number(rangeAtom) || rangeAtom;
          versionAtom = Number(versionAtom) || versionAtom;
          if (rangeAtom > versionAtom) {
            return 1;
          }
          if (rangeAtom === versionAtom) {
            return 0;
          }
          return -1;
        }
        function comparePreRelease(rangeAtom, versionAtom) {
          const { preRelease: rangePreRelease } = rangeAtom;
          const { preRelease: versionPreRelease } = versionAtom;
          if (rangePreRelease === undefined && Boolean(versionPreRelease)) {
            return 1;
          }
          if (Boolean(rangePreRelease) && versionPreRelease === undefined) {
            return -1;
          }
          if (
            rangePreRelease === undefined &&
            versionPreRelease === undefined
          ) {
            return 0;
          }
          for (let i = 0, n = rangePreRelease.length; i <= n; i++) {
            const rangeElement = rangePreRelease[i];
            const versionElement = versionPreRelease[i];
            if (rangeElement === versionElement) {
              continue;
            }
            if (rangeElement === undefined && versionElement === undefined) {
              return 0;
            }
            if (!rangeElement) {
              return 1;
            }
            if (!versionElement) {
              return -1;
            }
            return compareAtom(rangeElement, versionElement);
          }
          return 0;
        }
        function compareVersion(rangeAtom, versionAtom) {
          return (
            compareAtom(rangeAtom.major, versionAtom.major) ||
            compareAtom(rangeAtom.minor, versionAtom.minor) ||
            compareAtom(rangeAtom.patch, versionAtom.patch) ||
            comparePreRelease(rangeAtom, versionAtom)
          );
        }
        function eq(rangeAtom, versionAtom) {
          return rangeAtom.version === versionAtom.version;
        }
        function compare(rangeAtom, versionAtom) {
          switch (rangeAtom.operator) {
            case '':
            case '=':
              return eq(rangeAtom, versionAtom);
            case '>':
              return compareVersion(rangeAtom, versionAtom) < 0;
            case '>=':
              return (
                eq(rangeAtom, versionAtom) ||
                compareVersion(rangeAtom, versionAtom) < 0
              );
            case '<':
              return compareVersion(rangeAtom, versionAtom) > 0;
            case '<=':
              return (
                eq(rangeAtom, versionAtom) ||
                compareVersion(rangeAtom, versionAtom) > 0
              );
            case undefined: {
              // mean * or x -> all versions
              return true;
            }
            default:
              return false;
          }
        }

        // fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
        // Copyright (c)
        // vite-plugin-federation is licensed under Mulan PSL v2.
        // You can use this software according to the terms and conditions of the Mulan PSL v2.
        // You may obtain a copy of Mulan PSL v2 at:
        //      http://license.coscl.org.cn/MulanPSL2
        // THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
        // See the Mulan PSL v2 for more details.
        function parseComparatorString(range) {
          return pipe(
            // handle caret
            // ^ --> * (any, kinda silly)
            // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
            // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
            // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
            // ^1.2.3 --> >=1.2.3 <2.0.0-0
            // ^1.2.0 --> >=1.2.0 <2.0.0-0
            parseCarets,
            // handle tilde
            // ~, ~> --> * (any, kinda silly)
            // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
            // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
            // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
            // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
            // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
            parseTildes,
            parseXRanges,
            parseStar,
          )(range);
        }
        function parseRange(range) {
          return pipe(
            // handle hyphenRange
            // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
            parseHyphen,
            // handle trim comparator
            // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
            parseComparatorTrim,
            // handle trim tilde
            // `~ 1.2.3` => `~1.2.3`
            parseTildeTrim,
            // handle trim caret
            // `^ 1.2.3` => `^1.2.3`
            parseCaretTrim,
          )(range.trim())
            .split(/\s+/)
            .join(' ');
        }
        function satisfy(version, range) {
          if (!version) {
            return false;
          }
          // Extract version details once
          const extractedVersion = extractComparator(version);
          if (!extractedVersion) {
            // If the version string is invalid, it can't satisfy any range
            return false;
          }
          const [
            ,
            versionOperator,
            ,
            versionMajor,
            versionMinor,
            versionPatch,
            versionPreRelease,
          ] = extractedVersion;
          const versionAtom = {
            operator: versionOperator,
            version: combineVersion(
              versionMajor,
              versionMinor,
              versionPatch,
              versionPreRelease,
            ),
            // exclude build atom
            major: versionMajor,
            minor: versionMinor,
            patch: versionPatch,
            preRelease: versionPreRelease?.split('.'),
          };
          // Split the range by || to handle OR conditions
          const orRanges = range.split('||');
          for (const orRange of orRanges) {
            const trimmedOrRange = orRange.trim();
            if (!trimmedOrRange) {
              // An empty range string signifies wildcard *, satisfy any valid version
              // (We already checked if the version itself is valid)
              return true;
            }
            // Handle simple wildcards explicitly before complex parsing
            if (trimmedOrRange === '*' || trimmedOrRange === 'x') {
              return true;
            }
            try {
              // Apply existing parsing logic to the current OR sub-range
              const parsedSubRange = parseRange(trimmedOrRange); // Handles hyphens, trims etc.
              // Check if the result of initial parsing is empty, which can happen
              // for some wildcard cases handled by parseRange/parseComparatorString.
              // E.g. `parseStar` used in `parseComparatorString` returns ''.
              if (!parsedSubRange.trim()) {
                // If parsing results in empty string, treat as wildcard match
                return true;
              }
              const parsedComparatorString = parsedSubRange
                .split(' ')
                .map((rangeVersion) => parseComparatorString(rangeVersion)) // Expands ^, ~
                .join(' ');
              // Check again if the comparator string became empty after specific parsing like ^ or ~
              if (!parsedComparatorString.trim()) {
                return true;
              }
              // Split the sub-range by space for implicit AND conditions
              const comparators = parsedComparatorString
                .split(/\s+/)
                .map((comparator) => parseGTE0(comparator))
                // Filter out empty strings that might result from multiple spaces
                .filter(Boolean);
              // If a sub-range becomes empty after parsing (e.g., invalid characters),
              // it cannot be satisfied. This check might be redundant now but kept for safety.
              if (comparators.length === 0) {
                continue;
              }
              let subRangeSatisfied = true;
              for (const comparator of comparators) {
                const extractedComparator = extractComparator(comparator);
                // If any part of the AND sub-range is invalid, the sub-range is not satisfied
                if (!extractedComparator) {
                  subRangeSatisfied = false;
                  break;
                }
                const [
                  ,
                  rangeOperator,
                  ,
                  rangeMajor,
                  rangeMinor,
                  rangePatch,
                  rangePreRelease,
                ] = extractedComparator;
                const rangeAtom = {
                  operator: rangeOperator,
                  version: combineVersion(
                    rangeMajor,
                    rangeMinor,
                    rangePatch,
                    rangePreRelease,
                  ),
                  major: rangeMajor,
                  minor: rangeMinor,
                  patch: rangePatch,
                  preRelease: rangePreRelease?.split('.'),
                };
                // Check if the version satisfies this specific comparator in the AND chain
                if (!compare(rangeAtom, versionAtom)) {
                  subRangeSatisfied = false; // This part of the AND condition failed
                  break; // No need to check further comparators in this sub-range
                }
              }
              // If all AND conditions within this OR sub-range were met, the overall range is satisfied
              if (subRangeSatisfied) {
                return true;
              }
            } catch (e) {
              // Log error and treat this sub-range as unsatisfied
              console.error(
                `[semver] Error processing range part "${trimmedOrRange}":`,
                e,
              );
              continue;
            }
          }
          // If none of the OR sub-ranges were satisfied
          return false;
        }
        function formatShare(shareArgs, from, name, shareStrategy) {
          let get;
          if ('get' in shareArgs) {
            // eslint-disable-next-line prefer-destructuring
            get = shareArgs.get;
          } else if ('lib' in shareArgs) {
            get = () => Promise.resolve(shareArgs.lib);
          } else {
            get = () =>
              Promise.resolve(() => {
                throw new Error(`Can not get shared '${name}'!`);
              });
          }
          if (shareArgs.shareConfig?.eager && shareArgs.treeShaking) {
            throw new Error(
              'Can not set "eager:true" and "treeShaking" at the same time!',
            );
          }
          return {
            deps: [],
            useIn: [],
            from,
            loading: null,
            ...shareArgs,
            shareConfig: {
              requiredVersion: `^${shareArgs.version}`,
              singleton: false,
              eager: false,
              strictVersion: false,
              ...shareArgs.shareConfig,
            },
            get,
            loaded: shareArgs?.loaded || 'lib' in shareArgs ? true : undefined,
            version: shareArgs.version ?? '0',
            scope: Array.isArray(shareArgs.scope)
              ? shareArgs.scope
              : [shareArgs.scope ?? 'default'],
            strategy: (shareArgs.strategy ?? shareStrategy) || 'version-first',
            treeShaking: shareArgs.treeShaking
              ? {
                  ...shareArgs.treeShaking,
                  mode: shareArgs.treeShaking.mode ?? 'server-calc',
                  status:
                    shareArgs.treeShaking.status ??
                    1 /* TreeShakingStatus.UNKNOWN */,
                  useIn: [],
                }
              : undefined,
          };
        }
        function formatShareConfigs(prevOptions, newOptions) {
          const shareArgs = newOptions.shared || {};
          const from = newOptions.name;
          const newShareInfos = Object.keys(shareArgs).reduce(
            (res, pkgName) => {
              const arrayShareArgs = arrayOptions(shareArgs[pkgName]);
              res[pkgName] = res[pkgName] || [];
              arrayShareArgs.forEach((shareConfig) => {
                res[pkgName].push(
                  formatShare(
                    shareConfig,
                    from,
                    pkgName,
                    newOptions.shareStrategy,
                  ),
                );
              });
              return res;
            },
            {},
          );
          const allShareInfos = {
            ...prevOptions.shared,
          };
          Object.keys(newShareInfos).forEach((shareKey) => {
            if (!allShareInfos[shareKey]) {
              allShareInfos[shareKey] = newShareInfos[shareKey];
            } else {
              newShareInfos[shareKey].forEach((newUserSharedOptions) => {
                const isSameVersion = allShareInfos[shareKey].find(
                  (sharedVal) =>
                    sharedVal.version === newUserSharedOptions.version,
                );
                if (!isSameVersion) {
                  allShareInfos[shareKey].push(newUserSharedOptions);
                }
              });
            }
          });
          return {
            allShareInfos,
            newShareInfos,
          };
        }
        function shouldUseTreeShaking(treeShaking, usedExports) {
          if (!treeShaking) {
            return false;
          }
          const { status, mode } = treeShaking;
          if (status === 0 /* TreeShakingStatus.NO_USE */) {
            return false;
          }
          if (status === 2 /* TreeShakingStatus.CALCULATED */) {
            return true;
          }
          if (mode === 'runtime-infer') {
            if (!usedExports) {
              return true;
            }
            return isMatchUsedExports(treeShaking, usedExports);
          }
          return false;
        }
        /**
         * compare version a and b, return true if a is less than b
         */
        function versionLt(a, b) {
          const transformInvalidVersion = (version) => {
            const isNumberVersion = !Number.isNaN(Number(version));
            if (isNumberVersion) {
              const splitArr = version.split('.');
              let validVersion = version;
              for (let i = 0; i < 3 - splitArr.length; i++) {
                validVersion += '.0';
              }
              return validVersion;
            }
            return version;
          };
          if (
            satisfy(
              transformInvalidVersion(a),
              `<=${transformInvalidVersion(b)}`,
            )
          ) {
            return true;
          } else {
            return false;
          }
        }
        const findVersion = (shareVersionMap, cb) => {
          const callback =
            cb ||
            function (prev, cur) {
              return versionLt(prev, cur);
            };
          return Object.keys(shareVersionMap).reduce((prev, cur) => {
            if (!prev) {
              return cur;
            }
            if (callback(prev, cur)) {
              return cur;
            }
            // default version is '0' https://github.com/webpack/webpack/blob/main/lib/sharing/ProvideSharedModule.js#L136
            if (prev === '0') {
              return cur;
            }
            return prev;
          }, 0);
        };
        const isLoaded = (shared) => {
          return Boolean(shared.loaded) || typeof shared.lib === 'function';
        };
        const isLoading = (shared) => {
          return Boolean(shared.loading);
        };
        const isMatchUsedExports = (treeShaking, usedExports) => {
          if (!treeShaking || !usedExports) {
            return false;
          }
          const { usedExports: treeShakingUsedExports } = treeShaking;
          if (!treeShakingUsedExports) {
            return false;
          }
          if (usedExports.every((e) => treeShakingUsedExports.includes(e))) {
            return true;
          }
          return false;
        };
        function findSingletonVersionOrderByVersion(
          shareScopeMap,
          scope,
          pkgName,
          treeShaking,
        ) {
          const versions = shareScopeMap[scope][pkgName];
          let version = '';
          let useTreesShaking = shouldUseTreeShaking(treeShaking);
          // return false means use prev version
          const callback = function (prev, cur) {
            if (useTreesShaking) {
              if (!versions[prev].treeShaking) {
                return true;
              }
              if (!versions[cur].treeShaking) {
                return false;
              }
              return (
                !isLoaded(versions[prev].treeShaking) && versionLt(prev, cur)
              );
            }
            return !isLoaded(versions[prev]) && versionLt(prev, cur);
          };
          if (useTreesShaking) {
            version = findVersion(shareScopeMap[scope][pkgName], callback);
            if (version) {
              return {
                version,
                useTreesShaking,
              };
            }
            useTreesShaking = false;
          }
          return {
            version: findVersion(shareScopeMap[scope][pkgName], callback),
            useTreesShaking,
          };
        }
        const isLoadingOrLoaded = (shared) => {
          return isLoaded(shared) || isLoading(shared);
        };
        function findSingletonVersionOrderByLoaded(
          shareScopeMap,
          scope,
          pkgName,
          treeShaking,
        ) {
          const versions = shareScopeMap[scope][pkgName];
          let version = '';
          let useTreesShaking = shouldUseTreeShaking(treeShaking);
          // return false means use prev version
          const callback = function (prev, cur) {
            if (useTreesShaking) {
              if (!versions[prev].treeShaking) {
                return true;
              }
              if (!versions[cur].treeShaking) {
                return false;
              }
              if (isLoadingOrLoaded(versions[cur].treeShaking)) {
                if (isLoadingOrLoaded(versions[prev].treeShaking)) {
                  return Boolean(versionLt(prev, cur));
                } else {
                  return true;
                }
              }
              if (isLoadingOrLoaded(versions[prev].treeShaking)) {
                return false;
              }
            }
            if (isLoadingOrLoaded(versions[cur])) {
              if (isLoadingOrLoaded(versions[prev])) {
                return Boolean(versionLt(prev, cur));
              } else {
                return true;
              }
            }
            if (isLoadingOrLoaded(versions[prev])) {
              return false;
            }
            return versionLt(prev, cur);
          };
          if (useTreesShaking) {
            version = findVersion(shareScopeMap[scope][pkgName], callback);
            if (version) {
              return {
                version,
                useTreesShaking,
              };
            }
            useTreesShaking = false;
          }
          return {
            version: findVersion(shareScopeMap[scope][pkgName], callback),
            useTreesShaking,
          };
        }
        function getFindShareFunction(strategy) {
          if (strategy === 'loaded-first') {
            return findSingletonVersionOrderByLoaded;
          }
          return findSingletonVersionOrderByVersion;
        }
        function getRegisteredShare(
          localShareScopeMap,
          pkgName,
          shareInfo,
          resolveShare,
        ) {
          if (!localShareScopeMap) {
            return;
          }
          const {
            shareConfig,
            scope = DEFAULT_SCOPE,
            strategy,
            treeShaking,
          } = shareInfo;
          const scopes = Array.isArray(scope) ? scope : [scope];
          for (const sc of scopes) {
            if (
              shareConfig &&
              localShareScopeMap[sc] &&
              localShareScopeMap[sc][pkgName]
            ) {
              const { requiredVersion } = shareConfig;
              const findShareFunction = getFindShareFunction(strategy);
              const { version: maxOrSingletonVersion, useTreesShaking } =
                findShareFunction(localShareScopeMap, sc, pkgName, treeShaking);
              const defaultResolver = () => {
                const shared =
                  localShareScopeMap[sc][pkgName][maxOrSingletonVersion];
                if (shareConfig.singleton) {
                  if (
                    typeof requiredVersion === 'string' &&
                    !satisfy(maxOrSingletonVersion, requiredVersion)
                  ) {
                    const msg = `Version ${maxOrSingletonVersion} from ${maxOrSingletonVersion && shared.from} of shared singleton module ${pkgName} does not satisfy the requirement of ${shareInfo.from} which needs ${requiredVersion})`;
                    if (shareConfig.strictVersion) {
                      error(msg);
                    } else {
                      warn(msg);
                    }
                  }
                  return {
                    shared,
                    useTreesShaking,
                  };
                } else {
                  if (requiredVersion === false || requiredVersion === '*') {
                    return {
                      shared,
                      useTreesShaking,
                    };
                  }
                  if (satisfy(maxOrSingletonVersion, requiredVersion)) {
                    return {
                      shared,
                      useTreesShaking,
                    };
                  }
                  const _usedTreeShaking = shouldUseTreeShaking(treeShaking);
                  if (_usedTreeShaking) {
                    for (const [versionKey, versionValue] of Object.entries(
                      localShareScopeMap[sc][pkgName],
                    )) {
                      if (
                        !shouldUseTreeShaking(
                          versionValue.treeShaking,
                          treeShaking?.usedExports,
                        )
                      ) {
                        continue;
                      }
                      if (satisfy(versionKey, requiredVersion)) {
                        return {
                          shared: versionValue,
                          useTreesShaking: _usedTreeShaking,
                        };
                      }
                    }
                  }
                  for (const [versionKey, versionValue] of Object.entries(
                    localShareScopeMap[sc][pkgName],
                  )) {
                    if (satisfy(versionKey, requiredVersion)) {
                      return {
                        shared: versionValue,
                        useTreesShaking: false,
                      };
                    }
                  }
                }
                return;
              };
              const params = {
                shareScopeMap: localShareScopeMap,
                scope: sc,
                pkgName,
                version: maxOrSingletonVersion,
                GlobalFederation: Global.__FEDERATION__,
                shareInfo,
                resolver: defaultResolver,
              };
              const resolveShared = resolveShare.emit(params) || params;
              return resolveShared.resolver();
            }
          }
        }
        function getGlobalShareScope() {
          return Global.__FEDERATION__.__SHARE__;
        }
        function getTargetSharedOptions(options) {
          const { pkgName, extraOptions, shareInfos } = options;
          const defaultResolver = (sharedOptions) => {
            if (!sharedOptions) {
              return undefined;
            }
            const shareVersionMap = {};
            sharedOptions.forEach((shared) => {
              shareVersionMap[shared.version] = shared;
            });
            const callback = function (prev, cur) {
              return (
                // TODO: consider multiple treeShaking shared scenes
                !isLoaded(shareVersionMap[prev]) && versionLt(prev, cur)
              );
            };
            const maxVersion = findVersion(shareVersionMap, callback);
            return shareVersionMap[maxVersion];
          };
          const resolver = extraOptions?.resolver ?? defaultResolver;
          const isPlainObject = (val) => {
            return (
              val !== null && typeof val === 'object' && !Array.isArray(val)
            );
          };
          const merge = (...sources) => {
            const out = {};
            for (const src of sources) {
              if (!src) continue;
              for (const [key, value] of Object.entries(src)) {
                const prev = out[key];
                if (isPlainObject(prev) && isPlainObject(value)) {
                  out[key] = merge(prev, value);
                } else if (value !== undefined) {
                  out[key] = value;
                }
              }
            }
            return out;
          };
          return merge(
            resolver(shareInfos[pkgName]),
            extraOptions?.customShareInfo,
          );
        }
        const addUseIn = (shared, from) => {
          if (!shared.useIn) {
            shared.useIn = [];
          }
          addUniqueItem(shared.useIn, from);
        };
        function directShare(shared, useTreesShaking) {
          if (useTreesShaking && shared.treeShaking) {
            return shared.treeShaking;
          }
          return shared;
        }
        function getBuilderId() {
          //@ts-ignore
          return true
            ? //@ts-ignore
              'app2:0.0.0'
            : 0;
        }

        // Function to match a remote with its name and expose
        // id: pkgName(@federation/app1) + expose(button) = @federation/app1/button
        // id: alias(app1) + expose(button) = app1/button
        // id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort
        function matchRemoteWithNameAndExpose(remotes, id) {
          for (const remote of remotes) {
            // match pkgName
            const isNameMatched = id.startsWith(remote.name);
            let expose = id.replace(remote.name, '');
            if (isNameMatched) {
              if (expose.startsWith('/')) {
                const pkgNameOrAlias = remote.name;
                expose = `.${expose}`;
                return {
                  pkgNameOrAlias,
                  expose,
                  remote,
                };
              } else if (expose === '') {
                return {
                  pkgNameOrAlias: remote.name,
                  expose: '.',
                  remote,
                };
              }
            }
            // match alias
            const isAliasMatched = remote.alias && id.startsWith(remote.alias);
            let exposeWithAlias = remote.alias && id.replace(remote.alias, '');
            if (remote.alias && isAliasMatched) {
              if (exposeWithAlias && exposeWithAlias.startsWith('/')) {
                const pkgNameOrAlias = remote.alias;
                exposeWithAlias = `.${exposeWithAlias}`;
                return {
                  pkgNameOrAlias,
                  expose: exposeWithAlias,
                  remote,
                };
              } else if (exposeWithAlias === '') {
                return {
                  pkgNameOrAlias: remote.alias,
                  expose: '.',
                  remote,
                };
              }
            }
          }
          return;
        }
        // Function to match a remote with its name or alias
        function matchRemote(remotes, nameOrAlias) {
          for (const remote of remotes) {
            const isNameMatched = nameOrAlias === remote.name;
            if (isNameMatched) {
              return remote;
            }
            const isAliasMatched = remote.alias && nameOrAlias === remote.alias;
            if (isAliasMatched) {
              return remote;
            }
          }
          return;
        }
        function registerPlugins(plugins, instance) {
          const globalPlugins = getGlobalHostPlugins();
          const hookInstances = [
            instance.hooks,
            instance.remoteHandler.hooks,
            instance.sharedHandler.hooks,
            instance.snapshotHandler.hooks,
            instance.loaderHook,
            instance.bridgeHook,
          ];
          // Incorporate global plugins
          if (globalPlugins.length > 0) {
            globalPlugins.forEach((plugin) => {
              if (plugins?.find((item) => item.name !== plugin.name)) {
                plugins.push(plugin);
              }
            });
          }
          if (plugins && plugins.length > 0) {
            plugins.forEach((plugin) => {
              hookInstances.forEach((hookInstance) => {
                hookInstance.applyPlugin(plugin, instance);
              });
            });
          }
          return plugins;
        }
        const importCallback = '.then(callbacks[0]).catch(callbacks[1])';
        async function loadEsmEntry({ entry, remoteEntryExports }) {
          return new Promise((resolve, reject) => {
            try {
              if (!remoteEntryExports) {
                if (typeof FEDERATION_ALLOW_NEW_FUNCTION !== 'undefined') {
                  new Function(
                    'callbacks',
                    `import("${entry}")${importCallback}`,
                  )([resolve, reject]);
                } else {
                  import(/* webpackIgnore: true */ /* @vite-ignore */ entry)
                    .then(resolve)
                    .catch(reject);
                }
              } else {
                resolve(remoteEntryExports);
              }
            } catch (e) {
              reject(e);
            }
          });
        }
        async function loadSystemJsEntry({ entry, remoteEntryExports }) {
          return new Promise((resolve, reject) => {
            try {
              if (!remoteEntryExports) {
                //@ts-ignore
                if (false) {
                } else {
                  new Function(
                    'callbacks',
                    `System.import("${entry}")${importCallback}`,
                  )([resolve, reject]);
                }
              } else {
                resolve(remoteEntryExports);
              }
            } catch (e) {
              reject(e);
            }
          });
        }
        function handleRemoteEntryLoaded(name, globalName, entry) {
          const { remoteEntryKey, entryExports } = getRemoteEntryExports(
            name,
            globalName,
          );
          assert(
            entryExports,
            getShortErrorMsg(RUNTIME_001, runtimeDescMap, {
              remoteName: name,
              remoteEntryUrl: entry,
              remoteEntryKey,
            }),
          );
          return entryExports;
        }
        async function loadEntryScript({
          name,
          globalName,
          entry,
          loaderHook,
          getEntryUrl,
        }) {
          const { entryExports: remoteEntryExports } = getRemoteEntryExports(
            name,
            globalName,
          );
          if (remoteEntryExports) {
            return remoteEntryExports;
          }
          // if getEntryUrl is passed, use the getEntryUrl to get the entry url
          const url = getEntryUrl ? getEntryUrl(entry) : entry;
          return (0, index_esm /* loadScript */.ve)(url, {
            attrs: {},
            createScriptHook: (url, attrs) => {
              const res = loaderHook.lifecycle.createScript.emit({
                url,
                attrs,
              });
              if (!res) return;
              if (res instanceof HTMLScriptElement) {
                return res;
              }
              if ('script' in res || 'timeout' in res) {
                return res;
              }
              return;
            },
          })
            .then(() => {
              return handleRemoteEntryLoaded(name, globalName, entry);
            })
            .catch((e) => {
              assert(
                undefined,
                getShortErrorMsg(RUNTIME_008, runtimeDescMap, {
                  remoteName: name,
                  resourceUrl: entry,
                }),
              );
              throw e;
            });
        }
        async function loadEntryDom({
          remoteInfo,
          remoteEntryExports,
          loaderHook,
          getEntryUrl,
        }) {
          const { entry, entryGlobalName: globalName, name, type } = remoteInfo;
          switch (type) {
            case 'esm':
            case 'module':
              return loadEsmEntry({
                entry,
                remoteEntryExports,
              });
            case 'system':
              return loadSystemJsEntry({
                entry,
                remoteEntryExports,
              });
            default:
              return loadEntryScript({
                entry,
                globalName,
                name,
                loaderHook,
                getEntryUrl,
              });
          }
        }
        async function loadEntryNode({ remoteInfo, loaderHook }) {
          const { entry, entryGlobalName: globalName, name, type } = remoteInfo;
          const { entryExports: remoteEntryExports } = getRemoteEntryExports(
            name,
            globalName,
          );
          if (remoteEntryExports) {
            return remoteEntryExports;
          }
          return (0, index_esm /* loadScriptNode */.qN)(entry, {
            attrs: {
              name,
              globalName,
              type,
            },
            loaderHook: {
              createScriptHook: (url, attrs = {}) => {
                const res = loaderHook.lifecycle.createScript.emit({
                  url,
                  attrs,
                });
                if (!res) return;
                if ('url' in res) {
                  return res;
                }
                return;
              },
            },
          })
            .then(() => {
              return handleRemoteEntryLoaded(name, globalName, entry);
            })
            .catch((e) => {
              throw e;
            });
        }
        function getRemoteEntryUniqueKey(remoteInfo) {
          const { entry, name } = remoteInfo;
          return (0, index_esm /* composeKeyWithSeparator */.M8)(name, entry);
        }
        async function getRemoteEntry(params) {
          const {
            origin,
            remoteEntryExports,
            remoteInfo,
            getEntryUrl,
            _inErrorHandling = false,
          } = params;
          const uniqueKey = getRemoteEntryUniqueKey(remoteInfo);
          if (remoteEntryExports) {
            return remoteEntryExports;
          }
          if (!globalLoading[uniqueKey]) {
            const loadEntryHook =
              origin.remoteHandler.hooks.lifecycle.loadEntry;
            const loaderHook = origin.loaderHook;
            globalLoading[uniqueKey] = loadEntryHook
              .emit({
                loaderHook,
                remoteInfo,
                remoteEntryExports,
              })
              .then((res) => {
                if (res) {
                  return res;
                }
                // Use ENV_TARGET if defined, otherwise fallback to isBrowserEnv, must keep this
                const isWebEnvironment =
                  typeof ENV_TARGET !== 'undefined'
                    ? ENV_TARGET === 'web'
                    : (0, index_esm /* isBrowserEnv */.kP)();
                return isWebEnvironment
                  ? loadEntryDom({
                      remoteInfo,
                      remoteEntryExports,
                      loaderHook,
                      getEntryUrl,
                    })
                  : loadEntryNode({
                      remoteInfo,
                      loaderHook,
                    });
              })
              .catch(async (err) => {
                const uniqueKey = getRemoteEntryUniqueKey(remoteInfo);
                const isScriptLoadError =
                  err instanceof Error && err.message.includes(RUNTIME_008);
                if (isScriptLoadError && !_inErrorHandling) {
                  const wrappedGetRemoteEntry = (params) => {
                    return getRemoteEntry({
                      ...params,
                      _inErrorHandling: true,
                    });
                  };
                  const RemoteEntryExports =
                    await origin.loaderHook.lifecycle.loadEntryError.emit({
                      getRemoteEntry: wrappedGetRemoteEntry,
                      origin,
                      remoteInfo: remoteInfo,
                      remoteEntryExports,
                      globalLoading,
                      uniqueKey,
                    });
                  if (RemoteEntryExports) {
                    return RemoteEntryExports;
                  }
                }
                throw err;
              });
          }
          return globalLoading[uniqueKey];
        }
        function getRemoteInfo(remote) {
          return {
            ...remote,
            entry: 'entry' in remote ? remote.entry : '',
            type: remote.type || DEFAULT_REMOTE_TYPE,
            entryGlobalName: remote.entryGlobalName || remote.name,
            shareScope: remote.shareScope || DEFAULT_SCOPE,
          };
        }
        function defaultPreloadArgs(preloadConfig) {
          return {
            resourceCategory: 'sync',
            share: true,
            depsRemote: true,
            prefetchInterface: false,
            ...preloadConfig,
          };
        }
        function formatPreloadArgs(remotes, preloadArgs) {
          return preloadArgs.map((args) => {
            const remoteInfo = matchRemote(remotes, args.nameOrAlias);
            assert(
              remoteInfo,
              `Unable to preload ${args.nameOrAlias} as it is not included in ${
                !remoteInfo &&
                (0, index_esm /* safeToString */.pv)({
                  remoteInfo,
                  remotes,
                })
              }`,
            );
            return {
              remote: remoteInfo,
              preloadConfig: defaultPreloadArgs(args),
            };
          });
        }
        function normalizePreloadExposes(exposes) {
          if (!exposes) {
            return [];
          }
          return exposes.map((expose) => {
            if (expose === '.') {
              return expose;
            }
            if (expose.startsWith('./')) {
              return expose.replace('./', '');
            }
            return expose;
          });
        }
        function preloadAssets(
          remoteInfo,
          host,
          assets,
          // It is used to distinguish preload from load remote parallel loading
          useLinkPreload = true,
        ) {
          const { cssAssets, jsAssetsWithoutEntry, entryAssets } = assets;
          if (host.options.inBrowser) {
            entryAssets.forEach((asset) => {
              const { moduleInfo } = asset;
              const module = host.moduleCache.get(remoteInfo.name);
              if (module) {
                getRemoteEntry({
                  origin: host,
                  remoteInfo: moduleInfo,
                  remoteEntryExports: module.remoteEntryExports,
                });
              } else {
                getRemoteEntry({
                  origin: host,
                  remoteInfo: moduleInfo,
                  remoteEntryExports: undefined,
                });
              }
            });
            if (useLinkPreload) {
              const defaultAttrs = {
                rel: 'preload',
                as: 'style',
              };
              cssAssets.forEach((cssUrl) => {
                const { link: cssEl, needAttach } = (0,
                index_esm /* createLink */.EW)({
                  url: cssUrl,
                  cb: () => {
                    // noop
                  },
                  attrs: defaultAttrs,
                  createLinkHook: (url, attrs) => {
                    const res = host.loaderHook.lifecycle.createLink.emit({
                      url,
                      attrs,
                    });
                    if (res instanceof HTMLLinkElement) {
                      return res;
                    }
                    return;
                  },
                });
                needAttach && document.head.appendChild(cssEl);
              });
            } else {
              const defaultAttrs = {
                rel: 'stylesheet',
                type: 'text/css',
              };
              cssAssets.forEach((cssUrl) => {
                const { link: cssEl, needAttach } = (0,
                index_esm /* createLink */.EW)({
                  url: cssUrl,
                  cb: () => {
                    // noop
                  },
                  attrs: defaultAttrs,
                  createLinkHook: (url, attrs) => {
                    const res = host.loaderHook.lifecycle.createLink.emit({
                      url,
                      attrs,
                    });
                    if (res instanceof HTMLLinkElement) {
                      return res;
                    }
                    return;
                  },
                  needDeleteLink: false,
                });
                needAttach && document.head.appendChild(cssEl);
              });
            }
            if (useLinkPreload) {
              const defaultAttrs = {
                rel: 'preload',
                as: 'script',
              };
              jsAssetsWithoutEntry.forEach((jsUrl) => {
                const { link: linkEl, needAttach } = (0,
                index_esm /* createLink */.EW)({
                  url: jsUrl,
                  cb: () => {
                    // noop
                  },
                  attrs: defaultAttrs,
                  createLinkHook: (url, attrs) => {
                    const res = host.loaderHook.lifecycle.createLink.emit({
                      url,
                      attrs,
                    });
                    if (res instanceof HTMLLinkElement) {
                      return res;
                    }
                    return;
                  },
                });
                needAttach && document.head.appendChild(linkEl);
              });
            } else {
              const defaultAttrs = {
                fetchpriority: 'high',
                type:
                  remoteInfo?.type === 'module' ? 'module' : 'text/javascript',
              };
              jsAssetsWithoutEntry.forEach((jsUrl) => {
                const { script: scriptEl, needAttach } = (0,
                index_esm /* createScript */.hT)({
                  url: jsUrl,
                  cb: () => {
                    // noop
                  },
                  attrs: defaultAttrs,
                  createScriptHook: (url, attrs) => {
                    const res = host.loaderHook.lifecycle.createScript.emit({
                      url,
                      attrs,
                    });
                    if (res instanceof HTMLScriptElement) {
                      return res;
                    }
                    return;
                  },
                  needDeleteScript: true,
                });
                needAttach && document.head.appendChild(scriptEl);
              });
            }
          }
        }
        const ShareUtils = {
          getRegisteredShare,
          getGlobalShareScope,
        };
        const GlobalUtils = {
          Global,
          nativeGlobal,
          resetFederationGlobalInfo,
          setGlobalFederationInstance,
          getGlobalFederationConstructor,
          setGlobalFederationConstructor,
          getInfoWithoutType,
          getGlobalSnapshot,
          getTargetSnapshotInfoByModuleInfo,
          getGlobalSnapshotInfoByModuleInfo,
          setGlobalSnapshotInfoByModuleInfo,
          addGlobalSnapshot,
          getRemoteEntryExports,
          registerGlobalPlugins,
          getGlobalHostPlugins,
          getPreloaded,
          setPreloaded,
        };
        var helpers = {
          global: GlobalUtils,
          share: ShareUtils,
          utils: {
            matchRemoteWithNameAndExpose,
            preloadAssets,
            getRemoteInfo,
          },
        };
        function createRemoteEntryInitOptions(remoteInfo, hostShareScopeMap) {
          const localShareScopeMap = hostShareScopeMap;
          const shareScopeKeys = Array.isArray(remoteInfo.shareScope)
            ? remoteInfo.shareScope
            : [remoteInfo.shareScope];
          if (!shareScopeKeys.length) {
            shareScopeKeys.push('default');
          }
          shareScopeKeys.forEach((shareScopeKey) => {
            if (!localShareScopeMap[shareScopeKey]) {
              localShareScopeMap[shareScopeKey] = {};
            }
          });
          const remoteEntryInitOptions = {
            version: remoteInfo.version || '',
            shareScopeKeys: Array.isArray(remoteInfo.shareScope)
              ? shareScopeKeys
              : remoteInfo.shareScope || 'default',
          };
          // Help to find host instance
          Object.defineProperty(remoteEntryInitOptions, 'shareScopeMap', {
            value: localShareScopeMap,
            // remoteEntryInitOptions will be traversed and assigned during container init, ,so this attribute is not allowed to be traversed
            enumerable: false,
          });
          // TODO: compate legacy init params, should use shareScopeMap if exist
          const shareScope = localShareScopeMap[shareScopeKeys[0]];
          const initScope = [];
          return {
            remoteEntryInitOptions,
            shareScope,
            initScope,
          };
        }
        class Module {
          constructor({ remoteInfo, host }) {
            this.inited = false;
            this.initing = false;
            this.lib = undefined;
            this.remoteInfo = remoteInfo;
            this.host = host;
          }
          async getEntry() {
            if (this.remoteEntryExports) {
              return this.remoteEntryExports;
            }
            const remoteEntryExports = await getRemoteEntry({
              origin: this.host,
              remoteInfo: this.remoteInfo,
              remoteEntryExports: this.remoteEntryExports,
            });
            assert(
              remoteEntryExports,
              `remoteEntryExports is undefined \n ${(0, index_esm /* safeToString */.pv)(this.remoteInfo)}`,
            );
            this.remoteEntryExports = remoteEntryExports;
            return this.remoteEntryExports;
          }
          // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
          async init(id, remoteSnapshot) {
            // Get remoteEntry.js
            const remoteEntryExports = await this.getEntry();
            if (!this.inited && !this.initing) {
              this.initing = true;
              const { remoteEntryInitOptions, shareScope, initScope } =
                createRemoteEntryInitOptions(
                  this.remoteInfo,
                  this.host.shareScopeMap,
                );
              const initContainerOptions =
                await this.host.hooks.lifecycle.beforeInitContainer.emit({
                  shareScope,
                  // @ts-ignore shareScopeMap will be set by Object.defineProperty
                  remoteEntryInitOptions,
                  initScope,
                  remoteInfo: this.remoteInfo,
                  origin: this.host,
                });
              if (typeof remoteEntryExports?.init === 'undefined') {
                error(
                  getShortErrorMsg(RUNTIME_002, runtimeDescMap, {
                    hostName: this.host.name,
                    remoteName: this.remoteInfo.name,
                    remoteEntryUrl: this.remoteInfo.entry,
                    remoteEntryKey: this.remoteInfo.entryGlobalName,
                  }),
                );
              }
              await remoteEntryExports.init(
                initContainerOptions.shareScope,
                initContainerOptions.initScope,
                initContainerOptions.remoteEntryInitOptions,
              );
              await this.host.hooks.lifecycle.initContainer.emit({
                ...initContainerOptions,
                id,
                remoteSnapshot,
                remoteEntryExports,
              });
              this.inited = true;
            }
            return remoteEntryExports;
          }
          // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
          async get(id, expose, options, remoteSnapshot) {
            const { loadFactory = true } = options || {
              loadFactory: true,
            };
            const remoteEntryExports = await this.init(id, remoteSnapshot);
            this.lib = remoteEntryExports;
            let moduleFactory;
            moduleFactory =
              await this.host.loaderHook.lifecycle.getModuleFactory.emit({
                remoteEntryExports,
                expose,
                moduleInfo: this.remoteInfo,
              });
            // get exposeGetter
            if (!moduleFactory) {
              moduleFactory = await remoteEntryExports.get(expose);
            }
            assert(
              moduleFactory,
              `${getFMId(this.remoteInfo)} remote don't export ${expose}.`,
            );
            // keep symbol for module name always one format
            const symbolName = processModuleAlias(this.remoteInfo.name, expose);
            const wrapModuleFactory = this.wraperFactory(
              moduleFactory,
              symbolName,
            );
            if (!loadFactory) {
              return wrapModuleFactory;
            }
            const exposeContent = await wrapModuleFactory();
            return exposeContent;
          }
          wraperFactory(moduleFactory, id) {
            function defineModuleId(res, id) {
              if (
                res &&
                typeof res === 'object' &&
                Object.isExtensible(res) &&
                !Object.getOwnPropertyDescriptor(
                  res,
                  Symbol.for('mf_module_id'),
                )
              ) {
                Object.defineProperty(res, Symbol.for('mf_module_id'), {
                  value: id,
                  enumerable: false,
                });
              }
            }
            if (moduleFactory instanceof Promise) {
              return async () => {
                const res = await moduleFactory();
                // This parameter is used for bridge debugging
                defineModuleId(res, id);
                return res;
              };
            } else {
              return () => {
                const res = moduleFactory();
                // This parameter is used for bridge debugging
                defineModuleId(res, id);
                return res;
              };
            }
          }
        }
        class SyncHook {
          constructor(type) {
            this.type = '';
            this.listeners = new Set();
            if (type) {
              this.type = type;
            }
          }
          on(fn) {
            if (typeof fn === 'function') {
              this.listeners.add(fn);
            }
          }
          once(fn) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const self = this;
            this.on(function wrapper(...args) {
              self.remove(wrapper);
              // eslint-disable-next-line prefer-spread
              return fn.apply(null, args);
            });
          }
          emit(...data) {
            let result;
            if (this.listeners.size > 0) {
              // eslint-disable-next-line prefer-spread
              this.listeners.forEach((fn) => {
                result = fn(...data);
              });
            }
            return result;
          }
          remove(fn) {
            this.listeners.delete(fn);
          }
          removeAll() {
            this.listeners.clear();
          }
        }
        class AsyncHook extends SyncHook {
          emit(...data) {
            let result;
            const ls = Array.from(this.listeners);
            if (ls.length > 0) {
              let i = 0;
              const call = (prev) => {
                if (prev === false) {
                  return false; // Abort process
                } else if (i < ls.length) {
                  return Promise.resolve(ls[i++].apply(null, data)).then(call);
                } else {
                  return prev;
                }
              };
              result = call();
            }
            return Promise.resolve(result);
          }
        }

        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        function checkReturnData(originalData, returnedData) {
          if (!isObject(returnedData)) {
            return false;
          }
          if (originalData !== returnedData) {
            // eslint-disable-next-line no-restricted-syntax
            for (const key in originalData) {
              if (!(key in returnedData)) {
                return false;
              }
            }
          }
          return true;
        }
        class SyncWaterfallHook extends SyncHook {
          constructor(type) {
            super();
            this.onerror = error;
            this.type = type;
          }
          emit(data) {
            if (!isObject(data)) {
              error(
                `The data for the "${this.type}" hook should be an object.`,
              );
            }
            for (const fn of this.listeners) {
              try {
                const tempData = fn(data);
                if (checkReturnData(data, tempData)) {
                  data = tempData;
                } else {
                  this.onerror(
                    `A plugin returned an unacceptable value for the "${this.type}" type.`,
                  );
                  break;
                }
              } catch (e) {
                warn(e);
                this.onerror(e);
              }
            }
            return data;
          }
        }
        class AsyncWaterfallHook extends SyncHook {
          constructor(type) {
            super();
            this.onerror = error;
            this.type = type;
          }
          emit(data) {
            if (!isObject(data)) {
              error(
                `The response data for the "${this.type}" hook must be an object.`,
              );
            }
            const ls = Array.from(this.listeners);
            if (ls.length > 0) {
              let i = 0;
              const processError = (e) => {
                warn(e);
                this.onerror(e);
                return data;
              };
              const call = (prevData) => {
                if (checkReturnData(data, prevData)) {
                  data = prevData;
                  if (i < ls.length) {
                    try {
                      return Promise.resolve(ls[i++](data)).then(
                        call,
                        processError,
                      );
                    } catch (e) {
                      return processError(e);
                    }
                  }
                } else {
                  this.onerror(
                    `A plugin returned an incorrect value for the "${this.type}" type.`,
                  );
                }
                return data;
              };
              return Promise.resolve(call(data));
            }
            return Promise.resolve(data);
          }
        }
        class PluginSystem {
          constructor(lifecycle) {
            this.registerPlugins = {};
            this.lifecycle = lifecycle;
            this.lifecycleKeys = Object.keys(lifecycle);
          }
          applyPlugin(plugin, instance) {
            assert(isPlainObject(plugin), 'Plugin configuration is invalid.');
            // The plugin's name is mandatory and must be unique
            const pluginName = plugin.name;
            assert(pluginName, 'A name must be provided by the plugin.');
            if (!this.registerPlugins[pluginName]) {
              this.registerPlugins[pluginName] = plugin;
              plugin.apply?.(instance);
              Object.keys(this.lifecycle).forEach((key) => {
                const pluginLife = plugin[key];
                if (pluginLife) {
                  this.lifecycle[key].on(pluginLife);
                }
              });
            }
          }
          removePlugin(pluginName) {
            assert(pluginName, 'A name is required.');
            const plugin = this.registerPlugins[pluginName];
            assert(plugin, `The plugin "${pluginName}" is not registered.`);
            Object.keys(plugin).forEach((key) => {
              if (key !== 'name') {
                this.lifecycle[key].remove(plugin[key]);
              }
            });
          }
        }
        function assignRemoteInfo(remoteInfo, remoteSnapshot) {
          const remoteEntryInfo =
            getRemoteEntryInfoFromSnapshot(remoteSnapshot);
          if (!remoteEntryInfo.url) {
            error(
              `The attribute remoteEntry of ${remoteInfo.name} must not be undefined.`,
            );
          }
          let entryUrl = (0, index_esm /* getResourceUrl */.vM)(
            remoteSnapshot,
            remoteEntryInfo.url,
          );
          if (
            !(0, index_esm /* isBrowserEnv */.kP)() &&
            !entryUrl.startsWith('http')
          ) {
            entryUrl = `https:${entryUrl}`;
          }
          remoteInfo.type = remoteEntryInfo.type;
          remoteInfo.entryGlobalName = remoteEntryInfo.globalName;
          remoteInfo.entry = entryUrl;
          remoteInfo.version = remoteSnapshot.version;
          remoteInfo.buildVersion = remoteSnapshot.buildVersion;
        }
        function snapshotPlugin() {
          return {
            name: 'snapshot-plugin',
            async afterResolve(args) {
              const { remote, pkgNameOrAlias, expose, origin, remoteInfo, id } =
                args;
              if (
                !isRemoteInfoWithEntry(remote) ||
                !isPureRemoteEntry(remote)
              ) {
                const { remoteSnapshot, globalSnapshot } =
                  await origin.snapshotHandler.loadRemoteSnapshotInfo({
                    moduleInfo: remote,
                    id,
                  });
                assignRemoteInfo(remoteInfo, remoteSnapshot);
                // preloading assets
                const preloadOptions = {
                  remote,
                  preloadConfig: {
                    nameOrAlias: pkgNameOrAlias,
                    exposes: [expose],
                    resourceCategory: 'sync',
                    share: false,
                    depsRemote: false,
                  },
                };
                const assets =
                  await origin.remoteHandler.hooks.lifecycle.generatePreloadAssets.emit(
                    {
                      origin,
                      preloadOptions,
                      remoteInfo,
                      remote,
                      remoteSnapshot,
                      globalSnapshot,
                    },
                  );
                if (assets) {
                  preloadAssets(remoteInfo, origin, assets, false);
                }
                return {
                  ...args,
                  remoteSnapshot,
                };
              }
              return args;
            },
          };
        }

        // name
        // name:version
        function splitId(id) {
          const splitInfo = id.split(':');
          if (splitInfo.length === 1) {
            return {
              name: splitInfo[0],
              version: undefined,
            };
          } else if (splitInfo.length === 2) {
            return {
              name: splitInfo[0],
              version: splitInfo[1],
            };
          } else {
            return {
              name: splitInfo[1],
              version: splitInfo[2],
            };
          }
        }
        // Traverse all nodes in moduleInfo and traverse the entire snapshot
        function traverseModuleInfo(
          globalSnapshot,
          remoteInfo,
          traverse,
          isRoot,
          memo = {},
          remoteSnapshot,
        ) {
          const id = getFMId(remoteInfo);
          const { value: snapshotValue } = getInfoWithoutType(
            globalSnapshot,
            id,
          );
          const effectiveRemoteSnapshot = remoteSnapshot || snapshotValue;
          if (
            effectiveRemoteSnapshot &&
            !(0, index_esm /* isManifestProvider */.xw)(effectiveRemoteSnapshot)
          ) {
            traverse(effectiveRemoteSnapshot, remoteInfo, isRoot);
            if (effectiveRemoteSnapshot.remotesInfo) {
              const remoteKeys = Object.keys(
                effectiveRemoteSnapshot.remotesInfo,
              );
              for (const key of remoteKeys) {
                if (memo[key]) {
                  continue;
                }
                memo[key] = true;
                const subRemoteInfo = splitId(key);
                const remoteValue = effectiveRemoteSnapshot.remotesInfo[key];
                traverseModuleInfo(
                  globalSnapshot,
                  {
                    name: subRemoteInfo.name,
                    version: remoteValue.matchedVersion,
                  },
                  traverse,
                  false,
                  memo,
                  undefined,
                );
              }
            }
          }
        }
        const isExisted = (type, url) => {
          return document.querySelector(
            `${type}[${type === 'link' ? 'href' : 'src'}="${url}"]`,
          );
        };
        // eslint-disable-next-line max-lines-per-function
        function generatePreloadAssets(
          origin,
          preloadOptions,
          remote,
          globalSnapshot,
          remoteSnapshot,
        ) {
          const cssAssets = [];
          const jsAssets = [];
          const entryAssets = [];
          const loadedSharedJsAssets = new Set();
          const loadedSharedCssAssets = new Set();
          const { options } = origin;
          const { preloadConfig: rootPreloadConfig } = preloadOptions;
          const { depsRemote } = rootPreloadConfig;
          const memo = {};
          traverseModuleInfo(
            globalSnapshot,
            remote,
            (moduleInfoSnapshot, remoteInfo, isRoot) => {
              let preloadConfig;
              if (isRoot) {
                preloadConfig = rootPreloadConfig;
              } else {
                if (Array.isArray(depsRemote)) {
                  // eslint-disable-next-line array-callback-return
                  const findPreloadConfig = depsRemote.find((remoteConfig) => {
                    if (
                      remoteConfig.nameOrAlias === remoteInfo.name ||
                      remoteConfig.nameOrAlias === remoteInfo.alias
                    ) {
                      return true;
                    }
                    return false;
                  });
                  if (!findPreloadConfig) {
                    return;
                  }
                  preloadConfig = defaultPreloadArgs(findPreloadConfig);
                } else if (depsRemote === true) {
                  preloadConfig = rootPreloadConfig;
                } else {
                  return;
                }
              }
              const remoteEntryUrl = (0, index_esm /* getResourceUrl */.vM)(
                moduleInfoSnapshot,
                getRemoteEntryInfoFromSnapshot(moduleInfoSnapshot).url,
              );
              if (remoteEntryUrl) {
                entryAssets.push({
                  name: remoteInfo.name,
                  moduleInfo: {
                    name: remoteInfo.name,
                    entry: remoteEntryUrl,
                    type:
                      'remoteEntryType' in moduleInfoSnapshot
                        ? moduleInfoSnapshot.remoteEntryType
                        : 'global',
                    entryGlobalName:
                      'globalName' in moduleInfoSnapshot
                        ? moduleInfoSnapshot.globalName
                        : remoteInfo.name,
                    shareScope: '',
                    version:
                      'version' in moduleInfoSnapshot
                        ? moduleInfoSnapshot.version
                        : undefined,
                  },
                  url: remoteEntryUrl,
                });
              }
              let moduleAssetsInfo =
                'modules' in moduleInfoSnapshot
                  ? moduleInfoSnapshot.modules
                  : [];
              const normalizedPreloadExposes = normalizePreloadExposes(
                preloadConfig.exposes,
              );
              if (
                normalizedPreloadExposes.length &&
                'modules' in moduleInfoSnapshot
              ) {
                moduleAssetsInfo = moduleInfoSnapshot?.modules?.reduce(
                  (assets, moduleAssetInfo) => {
                    if (
                      normalizedPreloadExposes?.indexOf(
                        moduleAssetInfo.moduleName,
                      ) !== -1
                    ) {
                      assets.push(moduleAssetInfo);
                    }
                    return assets;
                  },
                  [],
                );
              }
              function handleAssets(assets) {
                const assetsRes = assets.map((asset) =>
                  (0, index_esm /* getResourceUrl */.vM)(
                    moduleInfoSnapshot,
                    asset,
                  ),
                );
                if (preloadConfig.filter) {
                  return assetsRes.filter(preloadConfig.filter);
                }
                return assetsRes;
              }
              if (moduleAssetsInfo) {
                const assetsLength = moduleAssetsInfo.length;
                for (let index = 0; index < assetsLength; index++) {
                  const assetsInfo = moduleAssetsInfo[index];
                  const exposeFullPath = `${remoteInfo.name}/${assetsInfo.moduleName}`;
                  origin.remoteHandler.hooks.lifecycle.handlePreloadModule.emit(
                    {
                      id:
                        assetsInfo.moduleName === '.'
                          ? remoteInfo.name
                          : exposeFullPath,
                      name: remoteInfo.name,
                      remoteSnapshot: moduleInfoSnapshot,
                      preloadConfig,
                      remote: remoteInfo,
                      origin,
                    },
                  );
                  const preloaded = getPreloaded(exposeFullPath);
                  if (preloaded) {
                    continue;
                  }
                  if (preloadConfig.resourceCategory === 'all') {
                    cssAssets.push(
                      ...handleAssets(assetsInfo.assets.css.async),
                    );
                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.async));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));
                    // eslint-disable-next-line no-constant-condition
                  } else if ((preloadConfig.resourceCategory = 'sync')) {
                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));
                  }
                  setPreloaded(exposeFullPath);
                }
              }
            },
            true,
            memo,
            remoteSnapshot,
          );
          if (remoteSnapshot.shared && remoteSnapshot.shared.length > 0) {
            const collectSharedAssets = (shareInfo, snapshotShared) => {
              const { shared: registeredShared } =
                getRegisteredShare(
                  origin.shareScopeMap,
                  snapshotShared.sharedName,
                  shareInfo,
                  origin.sharedHandler.hooks.lifecycle.resolveShare,
                ) || {};
              // If the global share does not exist, or the lib function does not exist, it means that the shared has not been loaded yet and can be preloaded.
              if (
                registeredShared &&
                typeof registeredShared.lib === 'function'
              ) {
                snapshotShared.assets.js.sync.forEach((asset) => {
                  loadedSharedJsAssets.add(asset);
                });
                snapshotShared.assets.css.sync.forEach((asset) => {
                  loadedSharedCssAssets.add(asset);
                });
              }
            };
            remoteSnapshot.shared.forEach((shared) => {
              const shareInfos = options.shared?.[shared.sharedName];
              if (!shareInfos) {
                return;
              }
              // if no version, preload all shared
              const sharedOptions = shared.version
                ? shareInfos.find((s) => s.version === shared.version)
                : shareInfos;
              if (!sharedOptions) {
                return;
              }
              const arrayShareInfo = arrayOptions(sharedOptions);
              arrayShareInfo.forEach((s) => {
                collectSharedAssets(s, shared);
              });
            });
          }
          const needPreloadJsAssets = jsAssets.filter(
            (asset) =>
              !loadedSharedJsAssets.has(asset) && !isExisted('script', asset),
          );
          const needPreloadCssAssets = cssAssets.filter(
            (asset) =>
              !loadedSharedCssAssets.has(asset) && !isExisted('link', asset),
          );
          return {
            cssAssets: needPreloadCssAssets,
            jsAssetsWithoutEntry: needPreloadJsAssets,
            entryAssets: entryAssets.filter(
              (entry) => !isExisted('script', entry.url),
            ),
          };
        }
        const generatePreloadAssetsPlugin = function () {
          return {
            name: 'generate-preload-assets-plugin',
            async generatePreloadAssets(args) {
              const {
                origin,
                preloadOptions,
                remoteInfo,
                remote,
                globalSnapshot,
                remoteSnapshot,
              } = args;
              if (!(0, index_esm /* isBrowserEnv */.kP)()) {
                return {
                  cssAssets: [],
                  jsAssetsWithoutEntry: [],
                  entryAssets: [],
                };
              }
              if (isRemoteInfoWithEntry(remote) && isPureRemoteEntry(remote)) {
                return {
                  cssAssets: [],
                  jsAssetsWithoutEntry: [],
                  entryAssets: [
                    {
                      name: remote.name,
                      url: remote.entry,
                      moduleInfo: {
                        name: remoteInfo.name,
                        entry: remote.entry,
                        type: remoteInfo.type || 'global',
                        entryGlobalName: '',
                        shareScope: '',
                      },
                    },
                  ],
                };
              }
              assignRemoteInfo(remoteInfo, remoteSnapshot);
              const assets = generatePreloadAssets(
                origin,
                preloadOptions,
                remoteInfo,
                globalSnapshot,
                remoteSnapshot,
              );
              return assets;
            },
          };
        };
        function getGlobalRemoteInfo(moduleInfo, origin) {
          const hostGlobalSnapshot = getGlobalSnapshotInfoByModuleInfo({
            name: origin.name,
            version: origin.options.version,
          });
          // get remote detail info from global
          const globalRemoteInfo =
            hostGlobalSnapshot &&
            'remotesInfo' in hostGlobalSnapshot &&
            hostGlobalSnapshot.remotesInfo &&
            getInfoWithoutType(hostGlobalSnapshot.remotesInfo, moduleInfo.name)
              .value;
          if (globalRemoteInfo && globalRemoteInfo.matchedVersion) {
            return {
              hostGlobalSnapshot,
              globalSnapshot: getGlobalSnapshot(),
              remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
                name: moduleInfo.name,
                version: globalRemoteInfo.matchedVersion,
              }),
            };
          }
          return {
            hostGlobalSnapshot: undefined,
            globalSnapshot: getGlobalSnapshot(),
            remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
              name: moduleInfo.name,
              version: 'version' in moduleInfo ? moduleInfo.version : undefined,
            }),
          };
        }
        class SnapshotHandler {
          constructor(HostInstance) {
            this.loadingHostSnapshot = null;
            this.manifestCache = new Map();
            this.hooks = new PluginSystem({
              beforeLoadRemoteSnapshot: new AsyncHook(
                'beforeLoadRemoteSnapshot',
              ),
              loadSnapshot: new AsyncWaterfallHook('loadGlobalSnapshot'),
              loadRemoteSnapshot: new AsyncWaterfallHook('loadRemoteSnapshot'),
              afterLoadSnapshot: new AsyncWaterfallHook('afterLoadSnapshot'),
            });
            this.manifestLoading = Global.__FEDERATION__.__MANIFEST_LOADING__;
            this.HostInstance = HostInstance;
            this.loaderHook = HostInstance.loaderHook;
          }
          // eslint-disable-next-line max-lines-per-function
          async loadRemoteSnapshotInfo({ moduleInfo, id, expose }) {
            const { options } = this.HostInstance;
            await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({
              options,
              moduleInfo,
            });
            let hostSnapshot = getGlobalSnapshotInfoByModuleInfo({
              name: this.HostInstance.options.name,
              version: this.HostInstance.options.version,
            });
            if (!hostSnapshot) {
              hostSnapshot = {
                version: this.HostInstance.options.version || '',
                remoteEntry: '',
                remotesInfo: {},
              };
              addGlobalSnapshot({
                [this.HostInstance.options.name]: hostSnapshot,
              });
            }
            // In dynamic loadRemote scenarios, incomplete remotesInfo delivery may occur. In such cases, the remotesInfo in the host needs to be completed in the snapshot at runtime.
            // This ensures the snapshot's integrity and helps the chrome plugin correctly identify all producer modules, ensuring that proxyable producer modules will not be missing.
            if (
              hostSnapshot &&
              'remotesInfo' in hostSnapshot &&
              !getInfoWithoutType(hostSnapshot.remotesInfo, moduleInfo.name)
                .value
            ) {
              if ('version' in moduleInfo || 'entry' in moduleInfo) {
                hostSnapshot.remotesInfo = {
                  ...hostSnapshot?.remotesInfo,
                  [moduleInfo.name]: {
                    matchedVersion:
                      'version' in moduleInfo
                        ? moduleInfo.version
                        : moduleInfo.entry,
                  },
                };
              }
            }
            const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } =
              this.getGlobalRemoteInfo(moduleInfo);
            const {
              remoteSnapshot: globalRemoteSnapshot,
              globalSnapshot: globalSnapshotRes,
            } = await this.hooks.lifecycle.loadSnapshot.emit({
              options,
              moduleInfo,
              hostGlobalSnapshot,
              remoteSnapshot,
              globalSnapshot,
            });
            let mSnapshot;
            let gSnapshot;
            // global snapshot includes manifest or module info includes manifest
            if (globalRemoteSnapshot) {
              if (
                (0, index_esm /* isManifestProvider */.xw)(globalRemoteSnapshot)
              ) {
                const remoteEntry = (0, index_esm /* isBrowserEnv */.kP)()
                  ? globalRemoteSnapshot.remoteEntry
                  : globalRemoteSnapshot.ssrRemoteEntry ||
                    globalRemoteSnapshot.remoteEntry ||
                    '';
                const moduleSnapshot = await this.getManifestJson(
                  remoteEntry,
                  moduleInfo,
                  {},
                );
                // eslint-disable-next-line @typescript-eslint/no-shadow
                const globalSnapshotRes = setGlobalSnapshotInfoByModuleInfo(
                  {
                    ...moduleInfo,
                    // The global remote may be overridden
                    // Therefore, set the snapshot key to the global address of the actual request
                    entry: remoteEntry,
                  },
                  moduleSnapshot,
                );
                mSnapshot = moduleSnapshot;
                gSnapshot = globalSnapshotRes;
              } else {
                const { remoteSnapshot: remoteSnapshotRes } =
                  await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                    options: this.HostInstance.options,
                    moduleInfo,
                    remoteSnapshot: globalRemoteSnapshot,
                    from: 'global',
                  });
                mSnapshot = remoteSnapshotRes;
                gSnapshot = globalSnapshotRes;
              }
            } else {
              if (isRemoteInfoWithEntry(moduleInfo)) {
                // get from manifest.json and merge remote info from remote server
                const moduleSnapshot = await this.getManifestJson(
                  moduleInfo.entry,
                  moduleInfo,
                  {},
                );
                // eslint-disable-next-line @typescript-eslint/no-shadow
                const globalSnapshotRes = setGlobalSnapshotInfoByModuleInfo(
                  moduleInfo,
                  moduleSnapshot,
                );
                const { remoteSnapshot: remoteSnapshotRes } =
                  await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                    options: this.HostInstance.options,
                    moduleInfo,
                    remoteSnapshot: moduleSnapshot,
                    from: 'global',
                  });
                mSnapshot = remoteSnapshotRes;
                gSnapshot = globalSnapshotRes;
              } else {
                error(
                  getShortErrorMsg(RUNTIME_007, runtimeDescMap, {
                    hostName: moduleInfo.name,
                    hostVersion: moduleInfo.version,
                    globalSnapshot: JSON.stringify(globalSnapshotRes),
                  }),
                );
              }
            }
            await this.hooks.lifecycle.afterLoadSnapshot.emit({
              id,
              host: this.HostInstance,
              options,
              moduleInfo,
              remoteSnapshot: mSnapshot,
            });
            return {
              remoteSnapshot: mSnapshot,
              globalSnapshot: gSnapshot,
            };
          }
          getGlobalRemoteInfo(moduleInfo) {
            return getGlobalRemoteInfo(moduleInfo, this.HostInstance);
          }
          async getManifestJson(manifestUrl, moduleInfo, extraOptions) {
            const getManifest = async () => {
              let manifestJson = this.manifestCache.get(manifestUrl);
              if (manifestJson) {
                return manifestJson;
              }
              try {
                let res = await this.loaderHook.lifecycle.fetch.emit(
                  manifestUrl,
                  {},
                );
                if (!res || !(res instanceof Response)) {
                  res = await fetch(manifestUrl, {});
                }
                manifestJson = await res.json();
              } catch (err) {
                manifestJson =
                  await this.HostInstance.remoteHandler.hooks.lifecycle.errorLoadRemote.emit(
                    {
                      id: manifestUrl,
                      error: err,
                      from: 'runtime',
                      lifecycle: 'afterResolve',
                      origin: this.HostInstance,
                    },
                  );
                if (!manifestJson) {
                  delete this.manifestLoading[manifestUrl];
                  error(
                    getShortErrorMsg(
                      RUNTIME_003,
                      runtimeDescMap,
                      {
                        manifestUrl,
                        moduleName: moduleInfo.name,
                        hostName: this.HostInstance.options.name,
                      },
                      `${err}`,
                    ),
                  );
                }
              }
              assert(
                manifestJson.metaData &&
                  manifestJson.exposes &&
                  manifestJson.shared,
                `${manifestUrl} is not a federation manifest`,
              );
              this.manifestCache.set(manifestUrl, manifestJson);
              return manifestJson;
            };
            const asyncLoadProcess = async () => {
              const manifestJson = await getManifest();
              const remoteSnapshot = (0,
              index_esm /* generateSnapshotFromManifest */.S5)(manifestJson, {
                version: manifestUrl,
              });
              const { remoteSnapshot: remoteSnapshotRes } =
                await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                  options: this.HostInstance.options,
                  moduleInfo,
                  manifestJson,
                  remoteSnapshot,
                  manifestUrl,
                  from: 'manifest',
                });
              return remoteSnapshotRes;
            };
            if (!this.manifestLoading[manifestUrl]) {
              this.manifestLoading[manifestUrl] = asyncLoadProcess().then(
                (res) => res,
              );
            }
            return this.manifestLoading[manifestUrl];
          }
        }
        class SharedHandler {
          constructor(host) {
            this.hooks = new PluginSystem({
              beforeRegisterShare: new SyncWaterfallHook('beforeRegisterShare'),
              afterResolve: new AsyncWaterfallHook('afterResolve'),
              beforeLoadShare: new AsyncWaterfallHook('beforeLoadShare'),
              // not used yet
              loadShare: new AsyncHook(),
              resolveShare: new SyncWaterfallHook('resolveShare'),
              // maybe will change, temporarily for internal use only
              initContainerShareScopeMap: new SyncWaterfallHook(
                'initContainerShareScopeMap',
              ),
            });
            this.host = host;
            this.shareScopeMap = {};
            this.initTokens = {};
            this._setGlobalShareScopeMap(host.options);
          }
          // register shared in shareScopeMap
          registerShared(globalOptions, userOptions) {
            const { newShareInfos, allShareInfos } = formatShareConfigs(
              globalOptions,
              userOptions,
            );
            const sharedKeys = Object.keys(newShareInfos);
            sharedKeys.forEach((sharedKey) => {
              const sharedVals = newShareInfos[sharedKey];
              sharedVals.forEach((sharedVal) => {
                sharedVal.scope.forEach((sc) => {
                  this.hooks.lifecycle.beforeRegisterShare.emit({
                    origin: this.host,
                    pkgName: sharedKey,
                    shared: sharedVal,
                  });
                  const registeredShared = this.shareScopeMap[sc]?.[sharedKey];
                  if (!registeredShared) {
                    this.setShared({
                      pkgName: sharedKey,
                      lib: sharedVal.lib,
                      get: sharedVal.get,
                      loaded: sharedVal.loaded || Boolean(sharedVal.lib),
                      shared: sharedVal,
                      from: userOptions.name,
                    });
                  }
                });
              });
            });
            return {
              newShareInfos,
              allShareInfos,
            };
          }
          async loadShare(pkgName, extraOptions) {
            const { host } = this;
            // This function performs the following steps:
            // 1. Checks if the currently loaded share already exists, if not, it throws an error
            // 2. Searches globally for a matching share, if found, it uses it directly
            // 3. If not found, it retrieves it from the current share and stores the obtained share globally.
            const shareOptions = getTargetSharedOptions({
              pkgName,
              extraOptions,
              shareInfos: host.options.shared,
            });
            if (shareOptions?.scope) {
              await Promise.all(
                shareOptions.scope.map(async (shareScope) => {
                  await Promise.all(
                    this.initializeSharing(shareScope, {
                      strategy: shareOptions.strategy,
                    }),
                  );
                  return;
                }),
              );
            }
            const loadShareRes =
              await this.hooks.lifecycle.beforeLoadShare.emit({
                pkgName,
                shareInfo: shareOptions,
                shared: host.options.shared,
                origin: host,
              });
            const { shareInfo: shareOptionsRes } = loadShareRes;
            // Assert that shareInfoRes exists, if not, throw an error
            assert(
              shareOptionsRes,
              `Cannot find ${pkgName} Share in the ${host.options.name}. Please ensure that the ${pkgName} Share parameters have been injected`,
            );
            const { shared: registeredShared, useTreesShaking } =
              getRegisteredShare(
                this.shareScopeMap,
                pkgName,
                shareOptionsRes,
                this.hooks.lifecycle.resolveShare,
              ) || {};
            if (registeredShared) {
              const targetShared = directShare(
                registeredShared,
                useTreesShaking,
              );
              if (targetShared.lib) {
                addUseIn(targetShared, host.options.name);
                return targetShared.lib;
              } else if (targetShared.loading && !targetShared.loaded) {
                const factory = await targetShared.loading;
                targetShared.loaded = true;
                if (!targetShared.lib) {
                  targetShared.lib = factory;
                }
                addUseIn(targetShared, host.options.name);
                return factory;
              } else {
                const asyncLoadProcess = async () => {
                  const factory = await targetShared.get();
                  addUseIn(targetShared, host.options.name);
                  targetShared.loaded = true;
                  targetShared.lib = factory;
                  return factory;
                };
                const loading = asyncLoadProcess();
                this.setShared({
                  pkgName,
                  loaded: false,
                  shared: registeredShared,
                  from: host.options.name,
                  lib: null,
                  loading,
                  treeShaking: useTreesShaking ? targetShared : undefined,
                });
                return loading;
              }
            } else {
              if (extraOptions?.customShareInfo) {
                return false;
              }
              const _useTreeShaking = shouldUseTreeShaking(
                shareOptionsRes.treeShaking,
              );
              const targetShared = directShare(
                shareOptionsRes,
                _useTreeShaking,
              );
              const asyncLoadProcess = async () => {
                const factory = await targetShared.get();
                targetShared.lib = factory;
                targetShared.loaded = true;
                addUseIn(targetShared, host.options.name);
                const { shared: gShared, useTreesShaking: gUseTreeShaking } =
                  getRegisteredShare(
                    this.shareScopeMap,
                    pkgName,
                    shareOptionsRes,
                    this.hooks.lifecycle.resolveShare,
                  ) || {};
                if (gShared) {
                  const targetGShared = directShare(gShared, gUseTreeShaking);
                  targetGShared.lib = factory;
                  targetGShared.loaded = true;
                  gShared.from = shareOptionsRes.from;
                }
                return factory;
              };
              const loading = asyncLoadProcess();
              this.setShared({
                pkgName,
                loaded: false,
                shared: shareOptionsRes,
                from: host.options.name,
                lib: null,
                loading,
                treeShaking: _useTreeShaking ? targetShared : undefined,
              });
              return loading;
            }
          }
          /**
           * This function initializes the sharing sequence (executed only once per share scope).
           * It accepts one argument, the name of the share scope.
           * If the share scope does not exist, it creates one.
           */
          // eslint-disable-next-line @typescript-eslint/member-ordering
          initializeSharing(shareScopeName = DEFAULT_SCOPE, extraOptions) {
            const { host } = this;
            const from = extraOptions?.from;
            const strategy = extraOptions?.strategy;
            let initScope = extraOptions?.initScope;
            const promises = [];
            if (from !== 'build') {
              const { initTokens } = this;
              if (!initScope) initScope = [];
              let initToken = initTokens[shareScopeName];
              if (!initToken)
                initToken = initTokens[shareScopeName] = {
                  from: this.host.name,
                };
              if (initScope.indexOf(initToken) >= 0) return promises;
              initScope.push(initToken);
            }
            const shareScope = this.shareScopeMap;
            const hostName = host.options.name;
            // Creates a new share scope if necessary
            if (!shareScope[shareScopeName]) {
              shareScope[shareScopeName] = {};
            }
            // Executes all initialization snippets from all accessible modules
            const scope = shareScope[shareScopeName];
            const register = (name, shared) => {
              const { version, eager } = shared;
              scope[name] = scope[name] || {};
              const versions = scope[name];
              const activeVersion =
                versions[version] && directShare(versions[version]);
              const activeVersionEager = Boolean(
                activeVersion &&
                  (('eager' in activeVersion && activeVersion.eager) ||
                    ('shareConfig' in activeVersion &&
                      activeVersion.shareConfig?.eager)),
              );
              if (
                !activeVersion ||
                (activeVersion.strategy !== 'loaded-first' &&
                  !activeVersion.loaded &&
                  (Boolean(!eager) !== !activeVersionEager
                    ? eager
                    : hostName > versions[version].from))
              ) {
                versions[version] = shared;
              }
            };
            const initRemoteModule = async (key) => {
              const { module } =
                await host.remoteHandler.getRemoteModuleAndOptions({
                  id: key,
                });
              let remoteEntryExports = undefined;
              try {
                remoteEntryExports = await module.getEntry();
              } catch (error) {
                remoteEntryExports =
                  await host.remoteHandler.hooks.lifecycle.errorLoadRemote.emit(
                    {
                      id: key,
                      error,
                      from: 'runtime',
                      lifecycle: 'beforeLoadShare',
                      origin: host,
                    },
                  );
              } finally {
                if (remoteEntryExports?.init) {
                  module.remoteEntryExports = remoteEntryExports;
                  await module.init();
                }
              }
            };
            Object.keys(host.options.shared).forEach((shareName) => {
              const sharedArr = host.options.shared[shareName];
              sharedArr.forEach((shared) => {
                if (shared.scope.includes(shareScopeName)) {
                  register(shareName, shared);
                }
              });
            });
            // TODO: strategy==='version-first' need to be removed in the future
            if (
              host.options.shareStrategy === 'version-first' ||
              strategy === 'version-first'
            ) {
              host.options.remotes.forEach((remote) => {
                if (remote.shareScope === shareScopeName) {
                  promises.push(initRemoteModule(remote.name));
                }
              });
            }
            return promises;
          }
          // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.
          // 1. If the loaded shared already exists globally, then it will be reused
          // 2. If lib exists in local shared, it will be used directly
          // 3. If the local get returns something other than Promise, then it will be used directly
          loadShareSync(pkgName, extraOptions) {
            const { host } = this;
            const shareOptions = getTargetSharedOptions({
              pkgName,
              extraOptions,
              shareInfos: host.options.shared,
            });
            if (shareOptions?.scope) {
              shareOptions.scope.forEach((shareScope) => {
                this.initializeSharing(shareScope, {
                  strategy: shareOptions.strategy,
                });
              });
            }
            const { shared: registeredShared, useTreesShaking } =
              getRegisteredShare(
                this.shareScopeMap,
                pkgName,
                shareOptions,
                this.hooks.lifecycle.resolveShare,
              ) || {};
            if (registeredShared) {
              if (typeof registeredShared.lib === 'function') {
                addUseIn(registeredShared, host.options.name);
                if (!registeredShared.loaded) {
                  registeredShared.loaded = true;
                  if (registeredShared.from === host.options.name) {
                    shareOptions.loaded = true;
                  }
                }
                return registeredShared.lib;
              }
              if (typeof registeredShared.get === 'function') {
                const module = registeredShared.get();
                if (!(module instanceof Promise)) {
                  addUseIn(registeredShared, host.options.name);
                  this.setShared({
                    pkgName,
                    loaded: true,
                    from: host.options.name,
                    lib: module,
                    shared: registeredShared,
                  });
                  return module;
                }
              }
            }
            if (shareOptions.lib) {
              if (!shareOptions.loaded) {
                shareOptions.loaded = true;
              }
              return shareOptions.lib;
            }
            if (shareOptions.get) {
              const module = shareOptions.get();
              if (module instanceof Promise) {
                const errorCode =
                  extraOptions?.from === 'build' ? RUNTIME_005 : RUNTIME_006;
                throw new Error(
                  getShortErrorMsg(errorCode, runtimeDescMap, {
                    hostName: host.options.name,
                    sharedPkgName: pkgName,
                  }),
                );
              }
              shareOptions.lib = module;
              this.setShared({
                pkgName,
                loaded: true,
                from: host.options.name,
                lib: shareOptions.lib,
                shared: shareOptions,
              });
              return shareOptions.lib;
            }
            throw new Error(
              getShortErrorMsg(RUNTIME_006, runtimeDescMap, {
                hostName: host.options.name,
                sharedPkgName: pkgName,
              }),
            );
          }
          initShareScopeMap(scopeName, shareScope, extraOptions = {}) {
            const { host } = this;
            this.shareScopeMap[scopeName] = shareScope;
            this.hooks.lifecycle.initContainerShareScopeMap.emit({
              shareScope,
              options: host.options,
              origin: host,
              scopeName,
              hostShareScopeMap: extraOptions.hostShareScopeMap,
            });
          }
          setShared({
            pkgName,
            shared,
            from,
            lib,
            loading,
            loaded,
            get,
            treeShaking,
          }) {
            const { version, scope = 'default', ...shareInfo } = shared;
            const scopes = Array.isArray(scope) ? scope : [scope];
            const mergeAttrs = (shared) => {
              const merge = (s, key, val) => {
                if (val && !s[key]) {
                  s[key] = val;
                }
              };
              const targetShared = treeShaking ? shared.treeShaking : shared;
              merge(targetShared, 'loaded', loaded);
              merge(targetShared, 'loading', loading);
              merge(targetShared, 'get', get);
            };
            scopes.forEach((sc) => {
              if (!this.shareScopeMap[sc]) {
                this.shareScopeMap[sc] = {};
              }
              if (!this.shareScopeMap[sc][pkgName]) {
                this.shareScopeMap[sc][pkgName] = {};
              }
              if (!this.shareScopeMap[sc][pkgName][version]) {
                this.shareScopeMap[sc][pkgName][version] = {
                  version,
                  scope: [sc],
                  ...shareInfo,
                  lib,
                };
              }
              const registeredShared = this.shareScopeMap[sc][pkgName][version];
              mergeAttrs(registeredShared);
              if (from && registeredShared.from !== from) {
                registeredShared.from = from;
              }
            });
          }
          _setGlobalShareScopeMap(hostOptions) {
            const globalShareScopeMap = getGlobalShareScope();
            const identifier = hostOptions.id || hostOptions.name;
            if (identifier && !globalShareScopeMap[identifier]) {
              globalShareScopeMap[identifier] = this.shareScopeMap;
            }
          }
        }
        class RemoteHandler {
          constructor(host) {
            this.hooks = new PluginSystem({
              beforeRegisterRemote: new SyncWaterfallHook(
                'beforeRegisterRemote',
              ),
              registerRemote: new SyncWaterfallHook('registerRemote'),
              beforeRequest: new AsyncWaterfallHook('beforeRequest'),
              onLoad: new AsyncHook('onLoad'),
              handlePreloadModule: new SyncHook('handlePreloadModule'),
              errorLoadRemote: new AsyncHook('errorLoadRemote'),
              beforePreloadRemote: new AsyncHook('beforePreloadRemote'),
              generatePreloadAssets: new AsyncHook('generatePreloadAssets'),
              // not used yet
              afterPreloadRemote: new AsyncHook(),
              // TODO: Move to loaderHook
              loadEntry: new AsyncHook(),
            });
            this.host = host;
            this.idToRemoteMap = {};
          }
          formatAndRegisterRemote(globalOptions, userOptions) {
            const userRemotes = userOptions.remotes || [];
            return userRemotes.reduce((res, remote) => {
              this.registerRemote(remote, res, {
                force: false,
              });
              return res;
            }, globalOptions.remotes);
          }
          setIdToRemoteMap(id, remoteMatchInfo) {
            const { remote, expose } = remoteMatchInfo;
            const { name, alias } = remote;
            this.idToRemoteMap[id] = {
              name: remote.name,
              expose,
            };
            if (alias && id.startsWith(name)) {
              const idWithAlias = id.replace(name, alias);
              this.idToRemoteMap[idWithAlias] = {
                name: remote.name,
                expose,
              };
              return;
            }
            if (alias && id.startsWith(alias)) {
              const idWithName = id.replace(alias, name);
              this.idToRemoteMap[idWithName] = {
                name: remote.name,
                expose,
              };
            }
          }
          // eslint-disable-next-line max-lines-per-function
          // eslint-disable-next-line @typescript-eslint/member-ordering
          async loadRemote(id, options) {
            const { host } = this;
            try {
              const { loadFactory = true } = options || {
                loadFactory: true,
              };
              // 1. Validate the parameters of the retrieved module. There are two module request methods: pkgName + expose and alias + expose.
              // 2. Request the snapshot information of the current host and globally store the obtained snapshot information. The retrieved module information is partially offline and partially online. The online module information will retrieve the modules used online.
              // 3. Retrieve the detailed information of the current module from global (remoteEntry address, expose resource address)
              // 4. After retrieving remoteEntry, call the init of the module, and then retrieve the exported content of the module through get
              // id: pkgName(@federation/app1) + expose(button) = @federation/app1/button
              // id: alias(app1) + expose(button) = app1/button
              // id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort
              const { module, moduleOptions, remoteMatchInfo } =
                await this.getRemoteModuleAndOptions({
                  id,
                });
              const {
                pkgNameOrAlias,
                remote,
                expose,
                id: idRes,
                remoteSnapshot,
              } = remoteMatchInfo;
              const moduleOrFactory = await module.get(
                idRes,
                expose,
                options,
                remoteSnapshot,
              );
              const moduleWrapper = await this.hooks.lifecycle.onLoad.emit({
                id: idRes,
                pkgNameOrAlias,
                expose,
                exposeModule: loadFactory ? moduleOrFactory : undefined,
                exposeModuleFactory: loadFactory ? undefined : moduleOrFactory,
                remote,
                options: moduleOptions,
                moduleInstance: module,
                origin: host,
              });
              this.setIdToRemoteMap(id, remoteMatchInfo);
              if (typeof moduleWrapper === 'function') {
                return moduleWrapper;
              }
              return moduleOrFactory;
            } catch (error) {
              const { from = 'runtime' } = options || {
                from: 'runtime',
              };
              const failOver = await this.hooks.lifecycle.errorLoadRemote.emit({
                id,
                error,
                from,
                lifecycle: 'onLoad',
                origin: host,
              });
              if (!failOver) {
                throw error;
              }
              return failOver;
            }
          }
          // eslint-disable-next-line @typescript-eslint/member-ordering
          async preloadRemote(preloadOptions) {
            const { host } = this;
            await this.hooks.lifecycle.beforePreloadRemote.emit({
              preloadOps: preloadOptions,
              options: host.options,
              origin: host,
            });
            const preloadOps = formatPreloadArgs(
              host.options.remotes,
              preloadOptions,
            );
            await Promise.all(
              preloadOps.map(async (ops) => {
                const { remote } = ops;
                const remoteInfo = getRemoteInfo(remote);
                const { globalSnapshot, remoteSnapshot } =
                  await host.snapshotHandler.loadRemoteSnapshotInfo({
                    moduleInfo: remote,
                  });
                const assets =
                  await this.hooks.lifecycle.generatePreloadAssets.emit({
                    origin: host,
                    preloadOptions: ops,
                    remote,
                    remoteInfo,
                    globalSnapshot,
                    remoteSnapshot,
                  });
                if (!assets) {
                  return;
                }
                preloadAssets(remoteInfo, host, assets);
              }),
            );
          }
          registerRemotes(remotes, options) {
            const { host } = this;
            remotes.forEach((remote) => {
              this.registerRemote(remote, host.options.remotes, {
                force: options?.force,
              });
            });
          }
          async getRemoteModuleAndOptions(options) {
            const { host } = this;
            const { id } = options;
            let loadRemoteArgs;
            try {
              loadRemoteArgs = await this.hooks.lifecycle.beforeRequest.emit({
                id,
                options: host.options,
                origin: host,
              });
            } catch (error) {
              loadRemoteArgs = await this.hooks.lifecycle.errorLoadRemote.emit({
                id,
                options: host.options,
                origin: host,
                from: 'runtime',
                error,
                lifecycle: 'beforeRequest',
              });
              if (!loadRemoteArgs) {
                throw error;
              }
            }
            const { id: idRes } = loadRemoteArgs;
            const remoteSplitInfo = matchRemoteWithNameAndExpose(
              host.options.remotes,
              idRes,
            );
            assert(
              remoteSplitInfo,
              getShortErrorMsg(RUNTIME_004, runtimeDescMap, {
                hostName: host.options.name,
                requestId: idRes,
              }),
            );
            const { remote: rawRemote } = remoteSplitInfo;
            const remoteInfo = getRemoteInfo(rawRemote);
            const matchInfo =
              await host.sharedHandler.hooks.lifecycle.afterResolve.emit({
                id: idRes,
                ...remoteSplitInfo,
                options: host.options,
                origin: host,
                remoteInfo,
              });
            const { remote, expose } = matchInfo;
            assert(
              remote && expose,
              `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${idRes}.`,
            );
            let module = host.moduleCache.get(remote.name);
            const moduleOptions = {
              host: host,
              remoteInfo,
            };
            if (!module) {
              module = new Module(moduleOptions);
              host.moduleCache.set(remote.name, module);
            }
            return {
              module,
              moduleOptions,
              remoteMatchInfo: matchInfo,
            };
          }
          registerRemote(remote, targetRemotes, options) {
            const { host } = this;
            const normalizeRemote = () => {
              if (remote.alias) {
                // Validate if alias equals the prefix of remote.name and remote.alias, if so, throw an error
                // As multi-level path references cannot guarantee unique names, alias being a prefix of remote.name is not supported
                const findEqual = targetRemotes.find(
                  (item) =>
                    remote.alias &&
                    (item.name.startsWith(remote.alias) ||
                      item.alias?.startsWith(remote.alias)),
                );
                assert(
                  !findEqual,
                  `The alias ${remote.alias} of remote ${remote.name} is not allowed to be the prefix of ${findEqual && findEqual.name} name or alias`,
                );
              }
              // Set the remote entry to a complete path
              if ('entry' in remote) {
                if (
                  (0, index_esm /* isBrowserEnv */.kP)() &&
                  !remote.entry.startsWith('http')
                ) {
                  remote.entry = new URL(
                    remote.entry,
                    window.location.origin,
                  ).href;
                }
              }
              if (!remote.shareScope) {
                remote.shareScope = DEFAULT_SCOPE;
              }
              if (!remote.type) {
                remote.type = DEFAULT_REMOTE_TYPE;
              }
            };
            this.hooks.lifecycle.beforeRegisterRemote.emit({
              remote,
              origin: host,
            });
            const registeredRemote = targetRemotes.find(
              (item) => item.name === remote.name,
            );
            if (!registeredRemote) {
              normalizeRemote();
              targetRemotes.push(remote);
              this.hooks.lifecycle.registerRemote.emit({
                remote,
                origin: host,
              });
            } else {
              const messages = [
                `The remote "${remote.name}" is already registered.`,
                'Please note that overriding it may cause unexpected errors.',
              ];
              if (options?.force) {
                // remove registered remote
                this.removeRemote(registeredRemote);
                normalizeRemote();
                targetRemotes.push(remote);
                this.hooks.lifecycle.registerRemote.emit({
                  remote,
                  origin: host,
                });
                (0, index_esm /* warn */.ZK)(messages.join(' '));
              }
            }
          }
          removeRemote(remote) {
            try {
              const { host } = this;
              const { name } = remote;
              const remoteIndex = host.options.remotes.findIndex(
                (item) => item.name === name,
              );
              if (remoteIndex !== -1) {
                host.options.remotes.splice(remoteIndex, 1);
              }
              const loadedModule = host.moduleCache.get(remote.name);
              if (loadedModule) {
                const remoteInfo = loadedModule.remoteInfo;
                const key = remoteInfo.entryGlobalName;
                if (CurrentGlobal[key]) {
                  if (
                    Object.getOwnPropertyDescriptor(CurrentGlobal, key)
                      ?.configurable
                  ) {
                    delete CurrentGlobal[key];
                  } else {
                    // @ts-ignore
                    CurrentGlobal[key] = undefined;
                  }
                }
                const remoteEntryUniqueKey = getRemoteEntryUniqueKey(
                  loadedModule.remoteInfo,
                );
                if (globalLoading[remoteEntryUniqueKey]) {
                  delete globalLoading[remoteEntryUniqueKey];
                }
                host.snapshotHandler.manifestCache.delete(remoteInfo.entry);
                // delete unloaded shared and instance
                let remoteInsId = remoteInfo.buildVersion
                  ? (0, index_esm /* composeKeyWithSeparator */.M8)(
                      remoteInfo.name,
                      remoteInfo.buildVersion,
                    )
                  : remoteInfo.name;
                const remoteInsIndex =
                  CurrentGlobal.__FEDERATION__.__INSTANCES__.findIndex(
                    (ins) => {
                      if (remoteInfo.buildVersion) {
                        return ins.options.id === remoteInsId;
                      } else {
                        return ins.name === remoteInsId;
                      }
                    },
                  );
                if (remoteInsIndex !== -1) {
                  const remoteIns =
                    CurrentGlobal.__FEDERATION__.__INSTANCES__[remoteInsIndex];
                  remoteInsId = remoteIns.options.id || remoteInsId;
                  const globalShareScopeMap = getGlobalShareScope();
                  let isAllSharedNotUsed = true;
                  const needDeleteKeys = [];
                  Object.keys(globalShareScopeMap).forEach((instId) => {
                    const shareScopeMap = globalShareScopeMap[instId];
                    shareScopeMap &&
                      Object.keys(shareScopeMap).forEach((shareScope) => {
                        const shareScopeVal = shareScopeMap[shareScope];
                        shareScopeVal &&
                          Object.keys(shareScopeVal).forEach((shareName) => {
                            const sharedPkgs = shareScopeVal[shareName];
                            sharedPkgs &&
                              Object.keys(sharedPkgs).forEach(
                                (shareVersion) => {
                                  const shared = sharedPkgs[shareVersion];
                                  if (
                                    shared &&
                                    typeof shared === 'object' &&
                                    shared.from === remoteInfo.name
                                  ) {
                                    if (shared.loaded || shared.loading) {
                                      shared.useIn = shared.useIn.filter(
                                        (usedHostName) =>
                                          usedHostName !== remoteInfo.name,
                                      );
                                      if (shared.useIn.length) {
                                        isAllSharedNotUsed = false;
                                      } else {
                                        needDeleteKeys.push([
                                          instId,
                                          shareScope,
                                          shareName,
                                          shareVersion,
                                        ]);
                                      }
                                    } else {
                                      needDeleteKeys.push([
                                        instId,
                                        shareScope,
                                        shareName,
                                        shareVersion,
                                      ]);
                                    }
                                  }
                                },
                              );
                          });
                      });
                  });
                  if (isAllSharedNotUsed) {
                    remoteIns.shareScopeMap = {};
                    delete globalShareScopeMap[remoteInsId];
                  }
                  needDeleteKeys.forEach(
                    ([insId, shareScope, shareName, shareVersion]) => {
                      delete globalShareScopeMap[insId]?.[shareScope]?.[
                        shareName
                      ]?.[shareVersion];
                    },
                  );
                  CurrentGlobal.__FEDERATION__.__INSTANCES__.splice(
                    remoteInsIndex,
                    1,
                  );
                }
                const { hostGlobalSnapshot } = getGlobalRemoteInfo(
                  remote,
                  host,
                );
                if (hostGlobalSnapshot) {
                  const remoteKey =
                    hostGlobalSnapshot &&
                    'remotesInfo' in hostGlobalSnapshot &&
                    hostGlobalSnapshot.remotesInfo &&
                    getInfoWithoutType(
                      hostGlobalSnapshot.remotesInfo,
                      remote.name,
                    ).key;
                  if (remoteKey) {
                    delete hostGlobalSnapshot.remotesInfo[remoteKey];
                    if (
                      //eslint-disable-next-line no-extra-boolean-cast
                      Boolean(
                        Global.__FEDERATION__.__MANIFEST_LOADING__[remoteKey],
                      )
                    ) {
                      delete Global.__FEDERATION__.__MANIFEST_LOADING__[
                        remoteKey
                      ];
                    }
                  }
                }
                host.moduleCache.delete(remote.name);
              }
            } catch (err) {
              logger.log('removeRemote fail: ', err);
            }
          }
        }
        const USE_SNAPSHOT = true ? !false : 0; // Default to true (use snapshot) when not explicitly defined
        class ModuleFederation {
          constructor(userOptions) {
            this.hooks = new PluginSystem({
              beforeInit: new SyncWaterfallHook('beforeInit'),
              init: new SyncHook(),
              // maybe will change, temporarily for internal use only
              beforeInitContainer: new AsyncWaterfallHook(
                'beforeInitContainer',
              ),
              // maybe will change, temporarily for internal use only
              initContainer: new AsyncWaterfallHook('initContainer'),
            });
            this.version = '0.24.1';
            this.moduleCache = new Map();
            this.loaderHook = new PluginSystem({
              // FIXME: may not be suitable , not open to the public yet
              getModuleInfo: new SyncHook(),
              createScript: new SyncHook(),
              createLink: new SyncHook(),
              fetch: new AsyncHook(),
              loadEntryError: new AsyncHook(),
              getModuleFactory: new AsyncHook(),
            });
            this.bridgeHook = new PluginSystem({
              beforeBridgeRender: new SyncHook(),
              afterBridgeRender: new SyncHook(),
              beforeBridgeDestroy: new SyncHook(),
              afterBridgeDestroy: new SyncHook(),
            });
            const plugins = USE_SNAPSHOT
              ? [snapshotPlugin(), generatePreloadAssetsPlugin()]
              : [];
            // TODO: Validate the details of the options
            // Initialize options with default values
            const defaultOptions = {
              id: getBuilderId(),
              name: userOptions.name,
              plugins,
              remotes: [],
              shared: {},
              inBrowser: (0, index_esm /* isBrowserEnv */.kP)(),
            };
            this.name = userOptions.name;
            this.options = defaultOptions;
            this.snapshotHandler = new SnapshotHandler(this);
            this.sharedHandler = new SharedHandler(this);
            this.remoteHandler = new RemoteHandler(this);
            this.shareScopeMap = this.sharedHandler.shareScopeMap;
            this.registerPlugins([
              ...defaultOptions.plugins,
              ...(userOptions.plugins || []),
            ]);
            this.options = this.formatOptions(defaultOptions, userOptions);
          }
          initOptions(userOptions) {
            this.registerPlugins(userOptions.plugins);
            const options = this.formatOptions(this.options, userOptions);
            this.options = options;
            return options;
          }
          async loadShare(pkgName, extraOptions) {
            return this.sharedHandler.loadShare(pkgName, extraOptions);
          }
          // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.
          // 1. If the loaded shared already exists globally, then it will be reused
          // 2. If lib exists in local shared, it will be used directly
          // 3. If the local get returns something other than Promise, then it will be used directly
          loadShareSync(pkgName, extraOptions) {
            return this.sharedHandler.loadShareSync(pkgName, extraOptions);
          }
          initializeSharing(shareScopeName = DEFAULT_SCOPE, extraOptions) {
            return this.sharedHandler.initializeSharing(
              shareScopeName,
              extraOptions,
            );
          }
          initRawContainer(name, url, container) {
            const remoteInfo = getRemoteInfo({
              name,
              entry: url,
            });
            const module = new Module({
              host: this,
              remoteInfo,
            });
            module.remoteEntryExports = container;
            this.moduleCache.set(name, module);
            return module;
          }
          // eslint-disable-next-line max-lines-per-function
          // eslint-disable-next-line @typescript-eslint/member-ordering
          async loadRemote(id, options) {
            return this.remoteHandler.loadRemote(id, options);
          }
          // eslint-disable-next-line @typescript-eslint/member-ordering
          async preloadRemote(preloadOptions) {
            return this.remoteHandler.preloadRemote(preloadOptions);
          }
          initShareScopeMap(scopeName, shareScope, extraOptions = {}) {
            this.sharedHandler.initShareScopeMap(
              scopeName,
              shareScope,
              extraOptions,
            );
          }
          formatOptions(globalOptions, userOptions) {
            const { allShareInfos: shared } = formatShareConfigs(
              globalOptions,
              userOptions,
            );
            const { userOptions: userOptionsRes, options: globalOptionsRes } =
              this.hooks.lifecycle.beforeInit.emit({
                origin: this,
                userOptions,
                options: globalOptions,
                shareInfo: shared,
              });
            const remotes = this.remoteHandler.formatAndRegisterRemote(
              globalOptionsRes,
              userOptionsRes,
            );
            const { allShareInfos } = this.sharedHandler.registerShared(
              globalOptionsRes,
              userOptionsRes,
            );
            const plugins = [...globalOptionsRes.plugins];
            if (userOptionsRes.plugins) {
              userOptionsRes.plugins.forEach((plugin) => {
                if (!plugins.includes(plugin)) {
                  plugins.push(plugin);
                }
              });
            }
            const optionsRes = {
              ...globalOptions,
              ...userOptions,
              plugins,
              remotes,
              shared: allShareInfos,
            };
            this.hooks.lifecycle.init.emit({
              origin: this,
              options: optionsRes,
            });
            return optionsRes;
          }
          registerPlugins(plugins) {
            const pluginRes = registerPlugins(plugins, this);
            // Merge plugin
            this.options.plugins = this.options.plugins.reduce(
              (res, plugin) => {
                if (!plugin) return res;
                if (res && !res.find((item) => item.name === plugin.name)) {
                  res.push(plugin);
                }
                return res;
              },
              pluginRes || [],
            );
          }
          registerRemotes(remotes, options) {
            return this.remoteHandler.registerRemotes(remotes, options);
          }
          registerShared(shared) {
            this.sharedHandler.registerShared(this.options, {
              ...this.options,
              shared,
            });
          }
        }
        var index = /*#__PURE__*/ Object.freeze({
          __proto__: null,
        }); // CONCATENATED MODULE: ../../../packages/runtime/dist/utils.esm.js

        // injected by bundler, so it can not use runtime-core stuff
        function utils_esm_getBuilderId() {
          //@ts-ignore
          return true
            ? //@ts-ignore
              'app2:0.0.0'
            : 0;
        }
        function getGlobalFederationInstance(name, version) {
          const buildId = utils_esm_getBuilderId();
          return CurrentGlobal.__FEDERATION__.__INSTANCES__.find(
            (GMInstance) => {
              if (buildId && GMInstance.options.id === buildId) {
                return true;
              }
              if (
                GMInstance.options.name === name &&
                !GMInstance.options.version &&
                !version
              ) {
                return true;
              }
              if (
                GMInstance.options.name === name &&
                version &&
                GMInstance.options.version === version
              ) {
                return true;
              }
              return false;
            },
          );
        } // CONCATENATED MODULE: ../../../packages/runtime/dist/index.esm.js

        function createInstance(options) {
          // Retrieve debug constructor
          const ModuleFederationConstructor =
            getGlobalFederationConstructor() || ModuleFederation;
          const instance = new ModuleFederationConstructor(options);
          setGlobalFederationInstance(instance);
          return instance;
        }
        let FederationInstance = null;
        /**
         * @deprecated Use createInstance or getInstance instead
         */
        function init(options) {
          // Retrieve the same instance with the same name
          const instance = getGlobalFederationInstance(
            options.name,
            options.version,
          );
          if (!instance) {
            FederationInstance = createInstance(options);
            return FederationInstance;
          } else {
            // Merge options
            instance.initOptions(options);
            if (!FederationInstance) {
              FederationInstance = instance;
            }
            return instance;
          }
        }
        function loadRemote(...args) {
          assert(
            FederationInstance,
            getShortErrorMsg(RUNTIME_009, runtimeDescMap),
          );
          const loadRemote = FederationInstance.loadRemote;
          // eslint-disable-next-line prefer-spread
          return loadRemote.apply(FederationInstance, args);
        }
        function loadShare(...args) {
          assert(
            FederationInstance,
            getShortErrorMsg(RUNTIME_009, runtimeDescMap),
          );
          // eslint-disable-next-line prefer-spread
          const loadShare = FederationInstance.loadShare;
          return loadShare.apply(FederationInstance, args);
        }
        function loadShareSync(...args) {
          assert(
            FederationInstance,
            getShortErrorMsg(RUNTIME_009, runtimeDescMap),
          );
          const loadShareSync = FederationInstance.loadShareSync;
          // eslint-disable-next-line prefer-spread
          return loadShareSync.apply(FederationInstance, args);
        }
        function preloadRemote(...args) {
          assert(
            FederationInstance,
            getShortErrorMsg(RUNTIME_009, runtimeDescMap),
          );
          // eslint-disable-next-line prefer-spread
          return FederationInstance.preloadRemote.apply(
            FederationInstance,
            args,
          );
        }
        function registerRemotes(...args) {
          assert(
            FederationInstance,
            getShortErrorMsg(RUNTIME_009, runtimeDescMap),
          );
          // eslint-disable-next-line prefer-spread
          return FederationInstance.registerRemotes.apply(
            FederationInstance,
            args,
          );
        }
        function index_esm_registerPlugins(...args) {
          assert(
            FederationInstance,
            getShortErrorMsg(RUNTIME_009, runtimeDescMap),
          );
          // eslint-disable-next-line prefer-spread
          return FederationInstance.registerPlugins.apply(
            FederationInstance,
            args,
          );
        }
        function getInstance() {
          return FederationInstance;
        }
        function registerShared(...args) {
          assert(
            FederationInstance,
            getShortErrorMsg(RUNTIME_009, runtimeDescMap),
          );
          // eslint-disable-next-line prefer-spread
          return FederationInstance.registerShared.apply(
            FederationInstance,
            args,
          );
        }
        // Inject for debug
        setGlobalFederationConstructor(ModuleFederation); // CONCATENATED MODULE: ../../../packages/webpack-bundler-runtime/dist/constant.esm.js

        const FEDERATION_SUPPORTED_TYPES = ['script']; // CONCATENATED MODULE: ../../../packages/runtime/dist/helpers.esm.js

        var helpers_esm_helpers = {
          ...helpers,
          global: {
            ...helpers.global,
            getGlobalFederationInstance: getGlobalFederationInstance,
          },
        }; // CONCATENATED MODULE: ../../../packages/webpack-bundler-runtime/dist/index.esm.js

        function attachShareScopeMap(webpackRequire) {
          if (
            !webpackRequire.S ||
            webpackRequire.federation.hasAttachShareScopeMap ||
            !webpackRequire.federation.instance ||
            !webpackRequire.federation.instance.shareScopeMap
          ) {
            return;
          }
          webpackRequire.S = webpackRequire.federation.instance.shareScopeMap;
          webpackRequire.federation.hasAttachShareScopeMap = true;
        }
        function updateConsumeOptions(options) {
          const { webpackRequire, moduleToHandlerMapping } = options;
          const { consumesLoadingData, initializeSharingData } = webpackRequire;
          const { sharedFallback, bundlerRuntime, libraryType } =
            webpackRequire.federation;
          if (consumesLoadingData && !consumesLoadingData._updated) {
            const {
              moduleIdToConsumeDataMapping:
                updatedModuleIdToConsumeDataMapping = {},
              initialConsumes: updatedInitialConsumes = [],
              chunkMapping: updatedChunkMapping = {},
            } = consumesLoadingData;
            Object.entries(updatedModuleIdToConsumeDataMapping).forEach(
              ([id, data]) => {
                if (!moduleToHandlerMapping[id]) {
                  moduleToHandlerMapping[id] = {
                    // @ts-ignore
                    getter: sharedFallback
                      ? bundlerRuntime?.getSharedFallbackGetter({
                          shareKey: data.shareKey,
                          factory: data.fallback,
                          webpackRequire,
                          libraryType,
                        })
                      : data.fallback,
                    treeShakingGetter: sharedFallback
                      ? data.fallback
                      : undefined,
                    shareInfo: {
                      shareConfig: {
                        requiredVersion: data.requiredVersion,
                        strictVersion: data.strictVersion,
                        singleton: data.singleton,
                        eager: data.eager,
                        layer: data.layer,
                      },
                      scope: Array.isArray(data.shareScope)
                        ? data.shareScope
                        : [data.shareScope || 'default'],
                      treeShaking: sharedFallback
                        ? {
                            get: data.fallback,
                            mode: data.treeShakingMode,
                          }
                        : undefined,
                    },
                    shareKey: data.shareKey,
                  };
                }
              },
            );
            if ('initialConsumes' in options) {
              const { initialConsumes = [] } = options;
              updatedInitialConsumes.forEach((id) => {
                if (!initialConsumes.includes(id)) {
                  initialConsumes.push(id);
                }
              });
            }
            if ('chunkMapping' in options) {
              const { chunkMapping = {} } = options;
              Object.entries(updatedChunkMapping).forEach(
                ([id, chunkModules]) => {
                  if (!chunkMapping[id]) {
                    chunkMapping[id] = [];
                  }
                  chunkModules.forEach((moduleId) => {
                    if (!chunkMapping[id].includes(moduleId)) {
                      chunkMapping[id].push(moduleId);
                    }
                  });
                },
              );
            }
            consumesLoadingData._updated = 1;
          }
          if (initializeSharingData && !initializeSharingData._updated) {
            const { federation } = webpackRequire;
            if (
              !federation.instance ||
              !initializeSharingData.scopeToSharingDataMapping
            ) {
              return;
            }
            const shared = {};
            for (let [scope, stages] of Object.entries(
              initializeSharingData.scopeToSharingDataMapping,
            )) {
              for (let stage of stages) {
                if (typeof stage === 'object' && stage !== null) {
                  const {
                    name,
                    version,
                    factory,
                    eager,
                    singleton,
                    requiredVersion,
                    strictVersion,
                  } = stage;
                  const shareConfig = {
                    requiredVersion: `^${version}`,
                  };
                  const isValidValue = function (val) {
                    return typeof val !== 'undefined';
                  };
                  if (isValidValue(singleton)) {
                    shareConfig.singleton = singleton;
                  }
                  if (isValidValue(requiredVersion)) {
                    shareConfig.requiredVersion = requiredVersion;
                  }
                  if (isValidValue(eager)) {
                    shareConfig.eager = eager;
                  }
                  if (isValidValue(strictVersion)) {
                    shareConfig.strictVersion = strictVersion;
                  }
                  const options = {
                    version,
                    scope: [scope],
                    shareConfig,
                    get: factory,
                  };
                  if (shared[name]) {
                    shared[name].push(options);
                  } else {
                    shared[name] = [options];
                  }
                }
              }
            }
            federation.instance.registerShared(shared);
            initializeSharingData._updated = 1;
          }
        }
        function updateRemoteOptions(options) {
          const {
            webpackRequire,
            idToExternalAndNameMapping = {},
            idToRemoteMap = {},
            chunkMapping = {},
          } = options;
          const { remotesLoadingData } = webpackRequire;
          const remoteInfos =
            webpackRequire.federation?.bundlerRuntimeOptions?.remotes
              ?.remoteInfos;
          if (
            !remotesLoadingData ||
            remotesLoadingData._updated ||
            !remoteInfos
          ) {
            return;
          }
          const {
            chunkMapping: updatedChunkMapping,
            moduleIdToRemoteDataMapping,
          } = remotesLoadingData;
          if (!updatedChunkMapping || !moduleIdToRemoteDataMapping) {
            return;
          }
          for (let [moduleId, data] of Object.entries(
            moduleIdToRemoteDataMapping,
          )) {
            if (!idToExternalAndNameMapping[moduleId]) {
              idToExternalAndNameMapping[moduleId] = [
                data.shareScope,
                data.name,
                data.externalModuleId,
              ];
            }
            if (!idToRemoteMap[moduleId] && remoteInfos[data.remoteName]) {
              const items = remoteInfos[data.remoteName];
              idToRemoteMap[moduleId] ||= [];
              items.forEach((item) => {
                if (!idToRemoteMap[moduleId].includes(item)) {
                  idToRemoteMap[moduleId].push(item);
                }
              });
            }
          }
          if (chunkMapping) {
            Object.entries(updatedChunkMapping).forEach(
              ([id, chunkModules]) => {
                if (!chunkMapping[id]) {
                  chunkMapping[id] = [];
                }
                chunkModules.forEach((moduleId) => {
                  if (!chunkMapping[id].includes(moduleId)) {
                    chunkMapping[id].push(moduleId);
                  }
                });
              },
            );
          }
          remotesLoadingData._updated = 1;
        }
        function remotes(options) {
          updateRemoteOptions(options);
          const {
            chunkId,
            promises,
            webpackRequire,
            chunkMapping,
            idToExternalAndNameMapping,
            idToRemoteMap,
          } = options;
          attachShareScopeMap(webpackRequire);
          if (webpackRequire.o(chunkMapping, chunkId)) {
            chunkMapping[chunkId].forEach((id) => {
              let getScope = webpackRequire.R;
              if (!getScope) {
                getScope = [];
              }
              const data = idToExternalAndNameMapping[id];
              const remoteInfos = idToRemoteMap[id] || [];
              // @ts-ignore seems not work
              if (getScope.indexOf(data) >= 0) {
                return;
              }
              // @ts-ignore seems not work
              getScope.push(data);
              if (data.p) {
                return promises.push(data.p);
              }
              const onError = (error) => {
                if (!error) {
                  error = new Error('Container missing');
                }
                if (typeof error.message === 'string') {
                  error.message += `\nwhile loading "${data[1]}" from ${data[2]}`;
                }
                webpackRequire.m[id] = () => {
                  throw error;
                };
                data.p = 0;
              };
              const handleFunction = (fn, arg1, arg2, d, next, first) => {
                try {
                  const promise = fn(arg1, arg2);
                  if (promise && promise.then) {
                    const p = promise.then(
                      (result) => next(result, d),
                      onError,
                    );
                    if (first) {
                      promises.push((data.p = p));
                    } else {
                      return p;
                    }
                  } else {
                    return next(promise, d, first);
                  }
                } catch (error) {
                  onError(error);
                }
              };
              const onExternal = (external, _, first) =>
                external
                  ? handleFunction(
                      webpackRequire.I,
                      data[0],
                      0,
                      external,
                      onInitialized,
                      first,
                    )
                  : onError();
              // eslint-disable-next-line no-var
              var onInitialized = (_, external, first) =>
                handleFunction(
                  external.get,
                  data[1],
                  getScope,
                  0,
                  onFactory,
                  first,
                );
              // eslint-disable-next-line no-var
              var onFactory = (factory) => {
                data.p = 1;
                webpackRequire.m[id] = (module) => {
                  module.exports = factory();
                };
              };
              const onRemoteLoaded = () => {
                try {
                  const remoteName = (0, index_esm /* decodeName */.cP)(
                    remoteInfos[0].name,
                    index_esm /* ENCODE_NAME_PREFIX */.Xz,
                  );
                  const remoteModuleName = remoteName + data[1].slice(1);
                  const instance = webpackRequire.federation.instance;
                  const loadRemote = () =>
                    webpackRequire.federation.instance.loadRemote(
                      remoteModuleName,
                      {
                        loadFactory: false,
                        from: 'build',
                      },
                    );
                  if (instance.options.shareStrategy === 'version-first') {
                    return Promise.all(
                      instance.sharedHandler.initializeSharing(data[0]),
                    ).then(() => {
                      return loadRemote();
                    });
                  }
                  return loadRemote();
                } catch (error) {
                  onError(error);
                }
              };
              const useRuntimeLoad =
                remoteInfos.length === 1 &&
                FEDERATION_SUPPORTED_TYPES.includes(
                  remoteInfos[0].externalType,
                ) &&
                remoteInfos[0].name;
              if (useRuntimeLoad) {
                handleFunction(onRemoteLoaded, data[2], 0, 0, onFactory, 1);
              } else {
                handleFunction(webpackRequire, data[2], 0, 0, onExternal, 1);
              }
            });
          }
        }
        function getUsedExports(webpackRequire, sharedName) {
          const usedExports = webpackRequire.federation.usedExports;
          if (!usedExports) {
            return;
          }
          return usedExports[sharedName];
        }
        function consumes(options) {
          updateConsumeOptions(options);
          const {
            chunkId,
            promises,
            installedModules,
            webpackRequire,
            chunkMapping,
            moduleToHandlerMapping,
          } = options;
          attachShareScopeMap(webpackRequire);
          if (webpackRequire.o(chunkMapping, chunkId)) {
            chunkMapping[chunkId].forEach((id) => {
              if (webpackRequire.o(installedModules, id)) {
                return promises.push(installedModules[id]);
              }
              const onFactory = (factory) => {
                installedModules[id] = 0;
                webpackRequire.m[id] = (module) => {
                  delete webpackRequire.c[id];
                  const result = factory();
                  // Add layer property from shareConfig if available
                  const { shareInfo } = moduleToHandlerMapping[id];
                  if (
                    shareInfo?.shareConfig?.layer &&
                    result &&
                    typeof result === 'object'
                  ) {
                    try {
                      // Only set layer if it's not already defined or if it's undefined
                      if (
                        !result.hasOwnProperty('layer') ||
                        result.layer === undefined
                      ) {
                        result.layer = shareInfo.shareConfig.layer;
                      }
                    } catch (e) {
                      // Ignore if layer property is read-only
                    }
                  }
                  module.exports = result;
                };
              };
              const onError = (error) => {
                delete installedModules[id];
                webpackRequire.m[id] = (module) => {
                  delete webpackRequire.c[id];
                  throw error;
                };
              };
              try {
                const federationInstance = webpackRequire.federation.instance;
                if (!federationInstance) {
                  throw new Error('Federation instance not found!');
                }
                const { shareKey, getter, shareInfo, treeShakingGetter } =
                  moduleToHandlerMapping[id];
                const usedExports = getUsedExports(webpackRequire, shareKey);
                const customShareInfo = {
                  ...shareInfo,
                };
                if (usedExports) {
                  customShareInfo.treeShaking = {
                    usedExports,
                    useIn: [federationInstance.options.name],
                  };
                }
                const promise = federationInstance
                  .loadShare(shareKey, {
                    customShareInfo,
                  })
                  .then((factory) => {
                    if (factory === false) {
                      return treeShakingGetter?.() || getter();
                    }
                    return factory;
                  });
                if (promise.then) {
                  promises.push(
                    (installedModules[id] = promise
                      .then(onFactory)
                      .catch(onError)),
                  );
                } else {
                  // @ts-ignore maintain previous logic
                  onFactory(promise);
                }
              } catch (e) {
                onError(e);
              }
            });
          }
        }
        function initializeSharing({
          shareScopeName,
          webpackRequire,
          initPromises,
          initTokens,
          initScope,
        }) {
          const shareScopeKeys = Array.isArray(shareScopeName)
            ? shareScopeName
            : [shareScopeName];
          var initializeSharingPromises = [];
          var _initializeSharing = function (shareScopeKey) {
            if (!initScope) initScope = [];
            const mfInstance = webpackRequire.federation.instance;
            // handling circular init calls
            var initToken = initTokens[shareScopeKey];
            if (!initToken)
              initToken = initTokens[shareScopeKey] = {
                from: mfInstance.name,
              };
            if (initScope.indexOf(initToken) >= 0) return;
            initScope.push(initToken);
            const promise = initPromises[shareScopeKey];
            if (promise) return promise;
            var warn = (msg) =>
              typeof console !== 'undefined' &&
              console.warn &&
              console.warn(msg);
            var initExternal = (id) => {
              var handleError = (err) =>
                warn('Initialization of sharing external failed: ' + err);
              try {
                var module = webpackRequire(id);
                if (!module) return;
                var initFn = (module) =>
                  module &&
                  module.init &&
                  // @ts-ignore compat legacy mf shared behavior
                  module.init(webpackRequire.S[shareScopeKey], initScope, {
                    shareScopeMap: webpackRequire.S || {},
                    shareScopeKeys: shareScopeName,
                  });
                if (module.then)
                  return promises.push(module.then(initFn, handleError));
                var initResult = initFn(module);
                // @ts-ignore
                if (
                  initResult &&
                  typeof initResult !== 'boolean' &&
                  initResult.then
                )
                  // @ts-ignore
                  return promises.push(initResult['catch'](handleError));
              } catch (err) {
                handleError(err);
              }
            };
            const promises = mfInstance.initializeSharing(shareScopeKey, {
              strategy: mfInstance.options.shareStrategy,
              initScope,
              from: 'build',
            });
            attachShareScopeMap(webpackRequire);
            const bundlerRuntimeRemotesOptions =
              webpackRequire.federation.bundlerRuntimeOptions.remotes;
            if (bundlerRuntimeRemotesOptions) {
              Object.keys(bundlerRuntimeRemotesOptions.idToRemoteMap).forEach(
                (moduleId) => {
                  const info =
                    bundlerRuntimeRemotesOptions.idToRemoteMap[moduleId];
                  const externalModuleId =
                    bundlerRuntimeRemotesOptions.idToExternalAndNameMapping[
                      moduleId
                    ][2];
                  if (info.length > 1) {
                    initExternal(externalModuleId);
                  } else if (info.length === 1) {
                    const remoteInfo = info[0];
                    if (
                      !FEDERATION_SUPPORTED_TYPES.includes(
                        remoteInfo.externalType,
                      )
                    ) {
                      initExternal(externalModuleId);
                    }
                  }
                },
              );
            }
            if (!promises.length) {
              return (initPromises[shareScopeKey] = true);
            }
            return (initPromises[shareScopeKey] = Promise.all(promises).then(
              () => (initPromises[shareScopeKey] = true),
            ));
          };
          shareScopeKeys.forEach((key) => {
            initializeSharingPromises.push(_initializeSharing(key));
          });
          return Promise.all(initializeSharingPromises).then(() => true);
        }
        function handleInitialConsumes(options) {
          const {
            moduleId,
            moduleToHandlerMapping,
            webpackRequire,
            asyncLoad,
          } = options;
          const federationInstance = webpackRequire.federation.instance;
          if (!federationInstance) {
            throw new Error('Federation instance not found!');
          }
          const { shareKey, shareInfo } = moduleToHandlerMapping[moduleId];
          try {
            const usedExports = getUsedExports(webpackRequire, shareKey);
            const customShareInfo = {
              ...shareInfo,
            };
            if (usedExports) {
              customShareInfo.treeShaking = {
                usedExports,
                useIn: [federationInstance.options.name],
              };
            }
            if (asyncLoad) {
              return federationInstance.loadShare(shareKey, {
                customShareInfo,
              });
            }
            return federationInstance.loadShareSync(shareKey, {
              customShareInfo,
            });
          } catch (err) {
            console.error(
              'loadShareSync failed! The function should not be called unless you set "eager:true". If you do not set it, and encounter this issue, you can check whether an async boundary is implemented.',
            );
            console.error('The original error message is as follows: ');
            throw err;
          }
        }
        function installInitialConsumes(options) {
          updateConsumeOptions(options);
          const {
            moduleToHandlerMapping,
            webpackRequire,
            installedModules,
            initialConsumes,
            asyncLoad,
          } = options;
          const factoryIdSets = [];
          initialConsumes.forEach((id) => {
            const factoryGetter = () =>
              handleInitialConsumes({
                moduleId: id,
                moduleToHandlerMapping,
                webpackRequire,
                asyncLoad,
              });
            factoryIdSets.push([id, factoryGetter]);
          });
          const setModule = (id, factoryGetter) => {
            webpackRequire.m[id] = (module) => {
              // Handle scenario when module is used synchronously
              installedModules[id] = 0;
              delete webpackRequire.c[id];
              const factory = factoryGetter();
              if (typeof factory !== 'function') {
                throw new Error(
                  `Shared module is not available for eager consumption: ${id}`,
                );
              }
              const result = factory();
              // Add layer property from shareConfig if available
              const { shareInfo } = moduleToHandlerMapping[id];
              if (
                shareInfo?.shareConfig?.layer &&
                result &&
                typeof result === 'object'
              ) {
                try {
                  // Only set layer if it's not already defined or if it's undefined
                  if (
                    !result.hasOwnProperty('layer') ||
                    result.layer === undefined
                  ) {
                    result.layer = shareInfo.shareConfig.layer;
                  }
                } catch (e) {
                  // Ignore if layer property is read-only
                }
              }
              module.exports = result;
            };
          };
          if (asyncLoad) {
            return Promise.all(
              factoryIdSets.map(async ([id, factoryGetter]) => {
                const result = await factoryGetter();
                setModule(id, () => result);
              }),
            );
          }
          factoryIdSets.forEach(([id, factoryGetter]) => {
            setModule(id, factoryGetter);
          });
        }
        function initContainerEntry(options) {
          const {
            webpackRequire,
            shareScope,
            initScope,
            shareScopeKey,
            remoteEntryInitOptions,
          } = options;
          if (!webpackRequire.S) return;
          if (
            !webpackRequire.federation ||
            !webpackRequire.federation.instance ||
            !webpackRequire.federation.initOptions
          )
            return;
          const federationInstance = webpackRequire.federation.instance;
          federationInstance.initOptions({
            name: webpackRequire.federation.initOptions.name,
            remotes: [],
            ...remoteEntryInitOptions,
          });
          const hostShareScopeKeys = remoteEntryInitOptions?.shareScopeKeys;
          const hostShareScopeMap = remoteEntryInitOptions?.shareScopeMap;
          // host: 'default' remote: 'default'  remote['default'] = hostShareScopeMap['default']
          // host: ['default', 'scope1'] remote: 'default'  remote['default'] = hostShareScopeMap['default']; remote['scope1'] = hostShareScopeMap['scop1']
          // host: 'default' remote: ['default','scope1']  remote['default'] = hostShareScopeMap['default']; remote['scope1'] = hostShareScopeMap['scope1'] = {}
          // host: ['scope1','default'] remote: ['scope1','scope2'] => remote['scope1'] = hostShareScopeMap['scope1']; remote['scope2'] = hostShareScopeMap['scope2'] = {};
          if (!shareScopeKey || typeof shareScopeKey === 'string') {
            const key = shareScopeKey || 'default';
            if (Array.isArray(hostShareScopeKeys)) {
              // const sc = hostShareScopeMap![key];
              // if (!sc) {
              //   throw new Error('shareScopeKey is not exist in hostShareScopeMap');
              // }
              // federationInstance.initShareScopeMap(key, sc, {
              //   hostShareScopeMap: remoteEntryInitOptions?.shareScopeMap || {},
              // });
              hostShareScopeKeys.forEach((hostKey) => {
                if (!hostShareScopeMap[hostKey]) {
                  hostShareScopeMap[hostKey] = {};
                }
                const sc = hostShareScopeMap[hostKey];
                federationInstance.initShareScopeMap(hostKey, sc, {
                  hostShareScopeMap:
                    remoteEntryInitOptions?.shareScopeMap || {},
                });
              });
            } else {
              federationInstance.initShareScopeMap(key, shareScope, {
                hostShareScopeMap: remoteEntryInitOptions?.shareScopeMap || {},
              });
            }
          } else {
            shareScopeKey.forEach((key) => {
              if (!hostShareScopeKeys || !hostShareScopeMap) {
                federationInstance.initShareScopeMap(key, shareScope, {
                  hostShareScopeMap:
                    remoteEntryInitOptions?.shareScopeMap || {},
                });
                return;
              }
              if (!hostShareScopeMap[key]) {
                hostShareScopeMap[key] = {};
              }
              const sc = hostShareScopeMap[key];
              federationInstance.initShareScopeMap(key, sc, {
                hostShareScopeMap: remoteEntryInitOptions?.shareScopeMap || {},
              });
            });
          }
          if (webpackRequire.federation.attachShareScopeMap) {
            webpackRequire.federation.attachShareScopeMap(webpackRequire);
          }
          if (typeof webpackRequire.federation.prefetch === 'function') {
            webpackRequire.federation.prefetch();
          }
          if (!Array.isArray(shareScopeKey)) {
            // @ts-ignore
            return webpackRequire.I(shareScopeKey || 'default', initScope);
          }
          var proxyInitializeSharing = Boolean(
            webpackRequire.federation.initOptions.shared,
          );
          if (proxyInitializeSharing) {
            // @ts-ignore
            return webpackRequire.I(shareScopeKey, initScope);
          }
          // @ts-ignore
          return Promise.all(
            shareScopeKey.map((key) => {
              // @ts-ignore
              return webpackRequire.I(key, initScope);
            }),
          ).then(() => true);
        }
        function index_esm_init({ webpackRequire }) {
          const {
            initOptions,
            runtime,
            sharedFallback,
            bundlerRuntime,
            libraryType,
          } = webpackRequire.federation;
          if (!initOptions) {
            throw new Error('initOptions is required!');
          }
          const treeShakingSharePlugin = function () {
            return {
              name: 'tree-shake-plugin',
              beforeInit(args) {
                const {
                  userOptions,
                  origin,
                  options: registeredOptions,
                } = args;
                const version =
                  userOptions.version || registeredOptions.version;
                if (!sharedFallback) {
                  return args;
                }
                const currentShared = userOptions.shared || {};
                const shared = [];
                Object.keys(currentShared).forEach((sharedName) => {
                  const sharedArgs = Array.isArray(currentShared[sharedName])
                    ? currentShared[sharedName]
                    : [currentShared[sharedName]];
                  sharedArgs.forEach((sharedArg) => {
                    shared.push([sharedName, sharedArg]);
                    if ('get' in sharedArg) {
                      sharedArg.treeShaking ||= {};
                      sharedArg.treeShaking.get = sharedArg.get;
                      sharedArg.get = bundlerRuntime.getSharedFallbackGetter({
                        shareKey: sharedName,
                        factory: sharedArg.get,
                        webpackRequire,
                        libraryType,
                        version: sharedArg.version,
                      });
                    }
                  });
                });
                // read snapshot to override re-shake getter
                const hostGlobalSnapshot =
                  helpers_esm_helpers.global.getGlobalSnapshotInfoByModuleInfo({
                    name: origin.name,
                    version: version,
                  });
                if (!hostGlobalSnapshot || !('shared' in hostGlobalSnapshot)) {
                  return args;
                }
                Object.keys(registeredOptions.shared || {}).forEach(
                  (pkgName) => {
                    const sharedInfo = registeredOptions.shared[pkgName];
                    sharedInfo.forEach((sharedArg) => {
                      shared.push([pkgName, sharedArg]);
                    });
                  },
                );
                const patchShared = (pkgName, shared) => {
                  const shareSnapshot = hostGlobalSnapshot.shared.find(
                    (item) => item.sharedName === pkgName,
                  );
                  if (!shareSnapshot) {
                    return;
                  }
                  const { treeShaking } = shared;
                  if (!treeShaking) {
                    return;
                  }
                  const {
                    secondarySharedTreeShakingName,
                    secondarySharedTreeShakingEntry,
                    treeShakingStatus,
                  } = shareSnapshot;
                  if (treeShaking.status === treeShakingStatus) {
                    return;
                  }
                  treeShaking.status = treeShakingStatus;
                  if (
                    secondarySharedTreeShakingEntry &&
                    libraryType &&
                    secondarySharedTreeShakingName
                  ) {
                    treeShaking.get = async () => {
                      const shareEntry = await getRemoteEntry({
                        origin,
                        remoteInfo: {
                          name: secondarySharedTreeShakingName,
                          entry: secondarySharedTreeShakingEntry,
                          type: libraryType,
                          entryGlobalName: secondarySharedTreeShakingName,
                          // current not used
                          shareScope: 'default',
                        },
                      });
                      // TODO: add errorLoad hook ?
                      // @ts-ignore
                      await shareEntry.init(
                        origin,
                        // @ts-ignore
                        __webpack_require__.federation.bundlerRuntime,
                      );
                      // @ts-ignore
                      const getter = shareEntry.get();
                      return getter;
                    };
                  }
                };
                shared.forEach(([pkgName, sharedArg]) => {
                  patchShared(pkgName, sharedArg);
                });
                return args;
              },
            };
          };
          initOptions.plugins ||= [];
          initOptions.plugins.push(treeShakingSharePlugin());
          return runtime.init(initOptions);
        }
        const getSharedFallbackGetter = ({
          shareKey,
          factory,
          version,
          webpackRequire,
          libraryType = 'global',
        }) => {
          const { runtime, instance, bundlerRuntime, sharedFallback } =
            webpackRequire.federation;
          if (!sharedFallback) {
            return factory;
          }
          // { react: [  [ react/19.0.0/index.js , 19.0.0, react_global_name, var ]  ] }
          const fallbackItems = sharedFallback[shareKey];
          if (!fallbackItems) {
            return factory;
          }
          const fallbackItem = version
            ? fallbackItems.find((item) => item[1] === version)
            : fallbackItems[0];
          if (!fallbackItem) {
            throw new Error(
              `No fallback item found for shareKey: ${shareKey} and version: ${version}`,
            );
          }
          return () =>
            runtime
              .getRemoteEntry({
                origin: webpackRequire.federation.instance,
                remoteInfo: {
                  name: fallbackItem[2],
                  entry: `${webpackRequire.p}${fallbackItem[0]}`,
                  type: libraryType,
                  entryGlobalName: fallbackItem[2],
                  // current not used
                  shareScope: 'default',
                },
              })
              // @ts-ignore
              .then((shareEntry) => {
                if (!shareEntry) {
                  throw new Error(
                    `Failed to load fallback entry for shareKey: ${shareKey} and version: ${version}`,
                  );
                }
                return (
                  shareEntry
                    // @ts-ignore
                    .init(webpackRequire.federation.instance, bundlerRuntime)
                    // @ts-ignore
                    .then(() => shareEntry.get())
                );
              });
        };
        const federation = {
          runtime: runtime_dist_index_esm_namespaceObject,
          instance: undefined,
          initOptions: undefined,
          bundlerRuntime: {
            remotes,
            consumes,
            I: initializeSharing,
            S: {},
            installInitialConsumes,
            initContainerEntry,
            init: index_esm_init,
            getSharedFallbackGetter,
          },
          attachShareScopeMap,
          bundlerRuntimeOptions: {},
        }; // CONCATENATED MODULE: ./node_modules/.federation/entry.cf3c121db0a10666d8c94d6c149b9b19.js

        if (!__webpack_require__.federation.runtime) {
          var prevFederation = __webpack_require__.federation;
          __webpack_require__.federation = {};
          for (var key in federation) {
            __webpack_require__.federation[key] = federation[key];
          }
          for (var key in prevFederation) {
            __webpack_require__.federation[key] = prevFederation[key];
          }
        }
        if (!__webpack_require__.federation.instance) {
          __webpack_require__.federation.instance =
            __webpack_require__.federation.bundlerRuntime.init({
              webpackRequire: __webpack_require__,
            });
          if (__webpack_require__.federation.attachShareScopeMap) {
            __webpack_require__.federation.attachShareScopeMap(
              __webpack_require__,
            );
          }
          if (__webpack_require__.federation.installInitialConsumes) {
            __webpack_require__.federation.installInitialConsumes();
          }

          if (
            !__webpack_require__.federation.isMFRemote &&
            __webpack_require__.federation.prefetch
          ) {
            __webpack_require__.federation.prefetch();
          }
        }

        /***/
      },

    /***/ 'webpack/container/reference/app1': /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__,
    ) => {
      'use strict';
      var __webpack_error__ = new Error();
      module.exports = new Promise((resolve, reject) => {
        if (typeof app1 !== 'undefined') return resolve();
        __webpack_require__.l(
          'http://localhost:4101/remoteEntry.client.js',
          (event) => {
            if (typeof app1 !== 'undefined') return resolve();
            var errorType =
              event && (event.type === 'load' ? 'missing' : event.type);
            var realSrc = event && event.target && event.target.src;
            __webpack_error__.message =
              'Loading script failed.\n(' + errorType + ': ' + realSrc + ')';
            __webpack_error__.name = 'ScriptExternalLoadError';
            __webpack_error__.type = errorType;
            __webpack_error__.request = realSrc;
            reject(__webpack_error__);
          },
          'app1',
        );
      }).then(() => app1);

      /***/
    },

    /***/ '(client)/./src/server-actions.js': /***/ (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      'use strict';
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */ __webpack_require__.d(__webpack_exports__, {
        /* harmony export */ getCount: () => /* binding */ getCount,
        /* harmony export */ incrementCount: () => /* binding */ incrementCount,
        /* harmony export */
      });
      /* harmony import */ var _module_federation_react_server_dom_webpack_client__WEBPACK_IMPORTED_MODULE_0__ =
        __webpack_require__(
          '(client)/../../../packages/react-server-dom-webpack/client.browser.js',
        );
      // RSC Client Loader: 'use server' module transformed to server references

      const callServer =
        globalThis.__RSC_CALL_SERVER__ ||
        ((id, args) => {
          throw new Error(
            'callServer not initialized. Set globalThis.__RSC_CALL_SERVER__',
          );
        });
      const incrementCount = (0,
      _module_federation_react_server_dom_webpack_client__WEBPACK_IMPORTED_MODULE_0__.createServerReference)(
        'file:///Users/bytedance/dev/core/apps/rsc-demo/app2/src/server-actions.js#incrementCount',
        callServer,
      );
      const getCount = (0,
      _module_federation_react_server_dom_webpack_client__WEBPACK_IMPORTED_MODULE_0__.createServerReference)(
        'file:///Users/bytedance/dev/core/apps/rsc-demo/app2/src/server-actions.js#getCount',
        callServer,
      );

      /***/
    },

    /***/ '(client)/./src/test-default-action.js': /***/ (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      'use strict';
      __webpack_require__.r(__webpack_exports__);
      /* harmony import */ var _module_federation_react_server_dom_webpack_client__WEBPACK_IMPORTED_MODULE_0__ =
        __webpack_require__(
          '(client)/../../../packages/react-server-dom-webpack/client.browser.js',
        );
      // RSC Client Loader: 'use server' module transformed to server references

      const callServer =
        globalThis.__RSC_CALL_SERVER__ ||
        ((id, args) => {
          throw new Error(
            'callServer not initialized. Set globalThis.__RSC_CALL_SERVER__',
          );
        });
      const _default = (0,
      _module_federation_react_server_dom_webpack_client__WEBPACK_IMPORTED_MODULE_0__.createServerReference)(
        'file:///Users/bytedance/dev/core/apps/rsc-demo/app2/src/test-default-action.js#default',
        callServer,
      );
      /* harmony default export */ __webpack_exports__['default'] = _default;

      /***/
    },

    /***/ '(client)/../framework/framework/bootstrap.js': /***/ (
      __unused_webpack_module,
      __unused_webpack___webpack_exports__,
      __webpack_require__,
    ) => {
      'use strict';
      /* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_0__ =
        __webpack_require__(
          '(client)/../../../../../Library/pnpm/store/v10/links/@/react-dom/19.2.0/09f8862f9cadb2790b70b94ddb646e94427b7be0ff242c2c964e8bf83ca4dd56/node_modules/react-dom/client.js',
        );
      /* harmony import */ var react_error_boundary__WEBPACK_IMPORTED_MODULE_3__ =
        __webpack_require__(
          '(client)/../../../../../Library/pnpm/store/v10/links/@/react-error-boundary/3.1.4/d1b3100cfa3d9ab2d5020950bb3761d8ad5e329381f1fcdff9729b00d15faa13/node_modules/react-error-boundary/dist/react-error-boundary.umd.js',
        );
      /* harmony import */ var react_error_boundary__WEBPACK_IMPORTED_MODULE_3___default =
        /*#__PURE__*/ __webpack_require__.n(
          react_error_boundary__WEBPACK_IMPORTED_MODULE_3__,
        );
      /* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_1__ =
        __webpack_require__('(client)/../framework/framework/router.js');
      /* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ =
        __webpack_require__(
          '(client)/../../../../../Library/pnpm/store/v10/links/@/react/19.2.0/a910955293fe48a2a8c542eb50a81385a2511b7ebc74d2fcc17e522c4b3a2f32/node_modules/react/jsx-runtime.js',
        );
      /**
       * Shared client bootstrap for the RSC notes apps.
       *
       * This is imported directly by both app1 and app2 so the boot logic
       * stays in one place.
       */

      // Set up global callServer for server action references
      // This is used by the server-action-client-loader transformation

      globalThis.__RSC_CALL_SERVER__ =
        _router__WEBPACK_IMPORTED_MODULE_1__.callServer;
      const rootElement = document.getElementById('root');

      // Check if we have SSR data embedded in the page
      const rscDataElement = document.getElementById('__RSC_DATA__');
      if (rscDataElement && rootElement && rootElement.children.length > 0) {
        // Hydration path: SSR'd HTML exists, hydrate from embedded RSC data
        try {
          const rscData = JSON.parse(rscDataElement.textContent);
          (0, _router__WEBPACK_IMPORTED_MODULE_1__.initFromSSR)(rscData);
          (0, react_dom_client__WEBPACK_IMPORTED_MODULE_0__.hydrateRoot)(
            rootElement,
            /*#__PURE__*/ (0,
            react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Root, {}),
          );
        } catch (error) {
          console.error(
            'Hydration failed, falling back to client render:',
            error,
          );
          const root = (0,
          react_dom_client__WEBPACK_IMPORTED_MODULE_0__.createRoot)(
            rootElement,
          );
          root.render(
            /*#__PURE__*/ (0,
            react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Root, {}),
          );
        }
      } else if (rootElement) {
        // Client-only path: no SSR, render from scratch
        const root = (0,
        react_dom_client__WEBPACK_IMPORTED_MODULE_0__.createRoot)(rootElement);
        root.render(
          /*#__PURE__*/ (0, react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(
            Root,
            {},
          ),
        );
      }
      function Root() {
        return /*#__PURE__*/ (0,
        react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(
          react_error_boundary__WEBPACK_IMPORTED_MODULE_3__.ErrorBoundary,
          {
            FallbackComponent: Error,
            children: /*#__PURE__*/ (0,
            react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(
              _router__WEBPACK_IMPORTED_MODULE_1__.Router,
              {},
            ),
          },
        );
      }
      function Error({ error }) {
        return /*#__PURE__*/ (0,
        react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)('div', {
          children: [
            /*#__PURE__*/ (0,
            react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)('h1', {
              children: 'Application Error',
            }),
            /*#__PURE__*/ (0,
            react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)('pre', {
              style: {
                whiteSpace: 'pre-wrap',
              },
              children: error.stack,
            }),
          ],
        });
      }

      /***/
    },

    /***/ '(client)/../framework/framework/router.js': /***/ (
      __unused_webpack_module,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      'use strict';
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */ __webpack_require__.d(__webpack_exports__, {
        /* harmony export */ Router: () => /* binding */ Router,
        /* harmony export */ callServer: () => /* binding */ callServer,
        /* harmony export */ initFromSSR: () => /* binding */ initFromSSR,
        /* harmony export */ useMutation: () => /* binding */ useMutation,
        /* harmony export */ useRouter: () => /* binding */ useRouter,
        /* harmony export */
      });
      /* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ =
        __webpack_require__(
          '(client)/webpack/sharing/consume/client/react/react',
        );
      /* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default =
        /*#__PURE__*/ __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
      /* harmony import */ var _module_federation_react_server_dom_webpack_client__WEBPACK_IMPORTED_MODULE_1__ =
        __webpack_require__(
          '(client)/../../../packages/react-server-dom-webpack/client.browser.js',
        );
      /* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ =
        __webpack_require__(
          '(client)/../../../../../Library/pnpm/store/v10/links/@/react/19.2.0/a910955293fe48a2a8c542eb50a81385a2511b7ebc74d2fcc17e522c4b3a2f32/node_modules/react/jsx-runtime.js',
        );
      /**
       * Shared router implementation for the RSC notes apps.
       *
       * This is imported directly by both app1 and app2 so that navigation,
       * callServer, and SSR integration stay in sync.
       */

      ('use client');

      // RSC Action header (must match server)

      const RSC_ACTION_HEADER = 'rsc-action';
      async function callServer(actionId, args) {
        const body = await (0,
        _module_federation_react_server_dom_webpack_client__WEBPACK_IMPORTED_MODULE_1__.encodeReply)(
          args,
        );
        const response = await fetch('/react', {
          method: 'POST',
          headers: {
            Accept: 'text/x-component',
            [RSC_ACTION_HEADER]: actionId,
          },
          body,
        });
        if (!response.ok) {
          throw new Error(`Server action failed: ${await response.text()}`);
        }
        const resultHeader = response.headers.get('X-Action-Result');
        const actionResult = resultHeader
          ? JSON.parse(resultHeader)
          : undefined;
        return actionResult;
      }
      const RouterContext = /*#__PURE__*/ (0,
      react__WEBPACK_IMPORTED_MODULE_0__.createContext)();
      const initialCache = new Map();
      function initFromSSR(rscData) {
        const initialLocation = {
          selectedId: null,
          isEditing: false,
          searchText: '',
        };
        const locationKey = JSON.stringify(initialLocation);
        const encoder = new TextEncoder();
        const stream = new ReadableStream({
          start(controller) {
            controller.enqueue(encoder.encode(rscData));
            controller.close();
          },
        });
        const content = (0,
        _module_federation_react_server_dom_webpack_client__WEBPACK_IMPORTED_MODULE_1__.createFromReadableStream)(
          stream,
        );
        initialCache.set(locationKey, content);
      }
      function Router() {
        const [cache, setCache] = (0,
        react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialCache);
        const [location, setLocation] = (0,
        react__WEBPACK_IMPORTED_MODULE_0__.useState)({
          selectedId: null,
          isEditing: false,
          searchText: '',
        });
        const locationKey = JSON.stringify(location);
        let content = cache.get(locationKey);
        if (!content) {
          content = (0,
          _module_federation_react_server_dom_webpack_client__WEBPACK_IMPORTED_MODULE_1__.createFromFetch)(
            fetch('/react?location=' + encodeURIComponent(locationKey)),
          );
          cache.set(locationKey, content);
        }
        function refresh(response) {
          (0, react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(() => {
            const nextCache = new Map();
            if (response != null) {
              const locationKey = response.headers.get('X-Location');
              const nextLocation = JSON.parse(locationKey);
              const nextContent = (0,
              _module_federation_react_server_dom_webpack_client__WEBPACK_IMPORTED_MODULE_1__.createFromReadableStream)(
                response.body,
              );
              nextCache.set(locationKey, nextContent);
              navigate(nextLocation);
            }
            setCache(nextCache);
          });
        }
        function navigate(nextLocation) {
          (0, react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(() => {
            setLocation((loc) => ({
              ...loc,
              ...nextLocation,
            }));
          });
        }
        return /*#__PURE__*/ (0,
        react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(
          RouterContext.Provider,
          {
            value: {
              location,
              navigate,
              refresh,
            },
            children: (0, react__WEBPACK_IMPORTED_MODULE_0__.use)(content),
          },
        );
      }
      function useRouter() {
        const context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(
          RouterContext,
        );
        if (!context) {
          return {
            location: {
              selectedId: null,
              isEditing: false,
              searchText: '',
            },
            navigate: () => {},
            refresh: () => {},
          };
        }
        return context;
      }
      function useMutation({ endpoint, method }) {
        const { refresh } = useRouter();
        const [isSaving, setIsSaving] = (0,
        react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
        const [didError, setDidError] = (0,
        react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
        const [error, setError] = (0,
        react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);
        if (didError) {
          throw error;
        }
        async function performMutation(payload, requestedLocation) {
          setIsSaving(true);
          try {
            const response = await fetch(
              `${endpoint}?location=${encodeURIComponent(JSON.stringify(requestedLocation))}`,
              {
                method,
                body: JSON.stringify(payload),
                headers: {
                  'Content-Type': 'application/json',
                },
              },
            );
            if (!response.ok) {
              throw new Error(await response.text());
            }
            refresh(response);
          } catch (e) {
            setDidError(true);
            setError(e);
          } finally {
            setIsSaving(false);
          }
        }
        return [isSaving, performMutation];
      }

      /***/
    },

    /***/ '(client)/../../../packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.production.js':
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        /**
         * @license React
         * react-server-dom-webpack-client.browser.production.js
         *
         * Copyright (c) Meta Platforms, Inc. and affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var ReactDOM = __webpack_require__(
            '(client)/webpack/sharing/consume/client/react-dom/react-dom',
          ),
          decoderOptions = {
            stream: !0,
          };
        function resolveClientReference(bundlerConfig, metadata) {
          if (bundlerConfig) {
            var moduleExports = bundlerConfig[metadata[0]];
            if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))
              moduleExports = bundlerConfig.name;
            else {
              bundlerConfig = moduleExports && moduleExports['*'];
              if (!bundlerConfig)
                throw Error(
                  'Could not find the module "' +
                    metadata[0] +
                    '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.',
                );
              moduleExports = metadata[2];
            }
            return 4 === metadata.length
              ? [bundlerConfig.id, bundlerConfig.chunks, moduleExports, 1]
              : [bundlerConfig.id, bundlerConfig.chunks, moduleExports];
          }
          return metadata;
        }
        function resolveServerReference(bundlerConfig, id) {
          var name = '',
            resolvedModuleData = bundlerConfig[id];
          if (resolvedModuleData) name = resolvedModuleData.name;
          else {
            var idx = id.lastIndexOf('#');
            -1 !== idx &&
              ((name = id.slice(idx + 1)),
              (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
            if (!resolvedModuleData)
              throw Error(
                'Could not find the module "' +
                  id +
                  '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
              );
          }
          return resolvedModuleData.async
            ? [resolvedModuleData.id, resolvedModuleData.chunks, name, 1]
            : [resolvedModuleData.id, resolvedModuleData.chunks, name];
        }
        var chunkCache = new Map();
        function requireAsyncModule(id) {
          var promise = __webpack_require__(id);
          if (
            'function' !== typeof promise.then ||
            'fulfilled' === promise.status
          )
            return null;
          promise.then(
            function (value) {
              promise.status = 'fulfilled';
              promise.value = value;
            },
            function (reason) {
              promise.status = 'rejected';
              promise.reason = reason;
            },
          );
          return promise;
        }
        function ignoreReject() {}
        function preloadModule(metadata) {
          for (
            var chunks = metadata[1], promises = [], i = 0;
            i < chunks.length;

          ) {
            var chunkId = chunks[i++],
              chunkFilename = chunks[i++],
              entry = chunkCache.get(chunkId);
            void 0 === entry
              ? (chunkMap.set(chunkId, chunkFilename),
                (chunkFilename = __webpack_require__.e(chunkId)),
                promises.push(chunkFilename),
                (entry = chunkCache.set.bind(chunkCache, chunkId, null)),
                chunkFilename.then(entry, ignoreReject),
                chunkCache.set(chunkId, chunkFilename))
              : null !== entry && promises.push(entry);
          }
          return 4 === metadata.length
            ? 0 === promises.length
              ? requireAsyncModule(metadata[0])
              : Promise.all(promises).then(function () {
                  return requireAsyncModule(metadata[0]);
                })
            : 0 < promises.length
              ? Promise.all(promises)
              : null;
        }
        function requireModule(metadata) {
          var moduleExports = __webpack_require__(metadata[0]);
          if (4 === metadata.length && 'function' === typeof moduleExports.then)
            if ('fulfilled' === moduleExports.status)
              moduleExports = moduleExports.value;
            else throw moduleExports.reason;
          return '*' === metadata[2]
            ? moduleExports
            : '' === metadata[2]
              ? moduleExports.__esModule
                ? moduleExports.default
                : moduleExports
              : moduleExports[metadata[2]];
        }
        var chunkMap = new Map(),
          webpackGetChunkFilename = __webpack_require__.u;
        __webpack_require__.u = function (chunkId) {
          var flightChunk = chunkMap.get(chunkId);
          return void 0 !== flightChunk
            ? flightChunk
            : webpackGetChunkFilename(chunkId);
        };
        var ReactDOMSharedInternals =
            ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
          REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
          REACT_LAZY_TYPE = Symbol.for('react.lazy'),
          MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || 'object' !== typeof maybeIterable)
            return null;
          maybeIterable =
            (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
            maybeIterable['@@iterator'];
          return 'function' === typeof maybeIterable ? maybeIterable : null;
        }
        var ASYNC_ITERATOR = Symbol.asyncIterator,
          isArrayImpl = Array.isArray,
          getPrototypeOf = Object.getPrototypeOf,
          ObjectPrototype = Object.prototype,
          knownServerReferences = new WeakMap();
        function serializeNumber(number) {
          return Number.isFinite(number)
            ? 0 === number && -Infinity === 1 / number
              ? '$-0'
              : number
            : Infinity === number
              ? '$Infinity'
              : -Infinity === number
                ? '$-Infinity'
                : '$NaN';
        }
        function processReply(
          root,
          formFieldPrefix,
          temporaryReferences,
          resolve,
          reject,
        ) {
          function serializeTypedArray(tag, typedArray) {
            typedArray = new Blob([
              new Uint8Array(
                typedArray.buffer,
                typedArray.byteOffset,
                typedArray.byteLength,
              ),
            ]);
            var blobId = nextPartId++;
            null === formData && (formData = new FormData());
            formData.append(formFieldPrefix + blobId, typedArray);
            return '$' + tag + blobId.toString(16);
          }
          function serializeBinaryReader(reader) {
            function progress(entry) {
              entry.done
                ? ((entry = nextPartId++),
                  data.append(formFieldPrefix + entry, new Blob(buffer)),
                  data.append(
                    formFieldPrefix + streamId,
                    '"$o' + entry.toString(16) + '"',
                  ),
                  data.append(formFieldPrefix + streamId, 'C'),
                  pendingParts--,
                  0 === pendingParts && resolve(data))
                : (buffer.push(entry.value),
                  reader.read(new Uint8Array(1024)).then(progress, reject));
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++,
              buffer = [];
            reader.read(new Uint8Array(1024)).then(progress, reject);
            return '$r' + streamId.toString(16);
          }
          function serializeReader(reader) {
            function progress(entry) {
              if (entry.done)
                data.append(formFieldPrefix + streamId, 'C'),
                  pendingParts--,
                  0 === pendingParts && resolve(data);
              else
                try {
                  var partJSON = JSON.stringify(entry.value, resolveToJSON);
                  data.append(formFieldPrefix + streamId, partJSON);
                  reader.read().then(progress, reject);
                } catch (x) {
                  reject(x);
                }
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++;
            reader.read().then(progress, reject);
            return '$R' + streamId.toString(16);
          }
          function serializeReadableStream(stream) {
            try {
              var binaryReader = stream.getReader({
                mode: 'byob',
              });
            } catch (x) {
              return serializeReader(stream.getReader());
            }
            return serializeBinaryReader(binaryReader);
          }
          function serializeAsyncIterable(iterable, iterator) {
            function progress(entry) {
              if (entry.done) {
                if (void 0 === entry.value)
                  data.append(formFieldPrefix + streamId, 'C');
                else
                  try {
                    var partJSON = JSON.stringify(entry.value, resolveToJSON);
                    data.append(formFieldPrefix + streamId, 'C' + partJSON);
                  } catch (x) {
                    reject(x);
                    return;
                  }
                pendingParts--;
                0 === pendingParts && resolve(data);
              } else
                try {
                  var partJSON$21 = JSON.stringify(entry.value, resolveToJSON);
                  data.append(formFieldPrefix + streamId, partJSON$21);
                  iterator.next().then(progress, reject);
                } catch (x$22) {
                  reject(x$22);
                }
            }
            null === formData && (formData = new FormData());
            var data = formData;
            pendingParts++;
            var streamId = nextPartId++;
            iterable = iterable === iterator;
            iterator.next().then(progress, reject);
            return '$' + (iterable ? 'x' : 'X') + streamId.toString(16);
          }
          function resolveToJSON(key, value) {
            if (null === value) return null;
            if ('object' === typeof value) {
              switch (value.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  if (
                    void 0 !== temporaryReferences &&
                    -1 === key.indexOf(':')
                  ) {
                    var parentReference = writtenObjects.get(this);
                    if (void 0 !== parentReference)
                      return (
                        temporaryReferences.set(
                          parentReference + ':' + key,
                          value,
                        ),
                        '$T'
                      );
                  }
                  throw Error(
                    'React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.',
                  );
                case REACT_LAZY_TYPE:
                  parentReference = value._payload;
                  var init = value._init;
                  null === formData && (formData = new FormData());
                  pendingParts++;
                  try {
                    var resolvedModel = init(parentReference),
                      lazyId = nextPartId++,
                      partJSON = serializeModel(resolvedModel, lazyId);
                    formData.append(formFieldPrefix + lazyId, partJSON);
                    return '$' + lazyId.toString(16);
                  } catch (x) {
                    if (
                      'object' === typeof x &&
                      null !== x &&
                      'function' === typeof x.then
                    ) {
                      pendingParts++;
                      var lazyId$23 = nextPartId++;
                      parentReference = function () {
                        try {
                          var partJSON$24 = serializeModel(value, lazyId$23),
                            data$25 = formData;
                          data$25.append(
                            formFieldPrefix + lazyId$23,
                            partJSON$24,
                          );
                          pendingParts--;
                          0 === pendingParts && resolve(data$25);
                        } catch (reason) {
                          reject(reason);
                        }
                      };
                      x.then(parentReference, parentReference);
                      return '$' + lazyId$23.toString(16);
                    }
                    reject(x);
                    return null;
                  } finally {
                    pendingParts--;
                  }
              }
              if ('function' === typeof value.then) {
                null === formData && (formData = new FormData());
                pendingParts++;
                var promiseId = nextPartId++;
                value.then(function (partValue) {
                  try {
                    var partJSON$27 = serializeModel(partValue, promiseId);
                    partValue = formData;
                    partValue.append(formFieldPrefix + promiseId, partJSON$27);
                    pendingParts--;
                    0 === pendingParts && resolve(partValue);
                  } catch (reason) {
                    reject(reason);
                  }
                }, reject);
                return '$@' + promiseId.toString(16);
              }
              parentReference = writtenObjects.get(value);
              if (void 0 !== parentReference) {
                if (modelRoot === value) modelRoot = null;
                else return parentReference;
              } else
                -1 === key.indexOf(':') &&
                  ((parentReference = writtenObjects.get(this)),
                  void 0 !== parentReference &&
                    ((key = parentReference + ':' + key),
                    writtenObjects.set(value, key),
                    void 0 !== temporaryReferences &&
                      temporaryReferences.set(key, value)));
              if (isArrayImpl(value)) return value;
              if (value instanceof FormData) {
                null === formData && (formData = new FormData());
                var data$31 = formData;
                key = nextPartId++;
                var prefix = formFieldPrefix + key + '_';
                value.forEach(function (originalValue, originalKey) {
                  data$31.append(prefix + originalKey, originalValue);
                });
                return '$K' + key.toString(16);
              }
              if (value instanceof Map)
                return (
                  (key = nextPartId++),
                  (parentReference = serializeModel(Array.from(value), key)),
                  null === formData && (formData = new FormData()),
                  formData.append(formFieldPrefix + key, parentReference),
                  '$Q' + key.toString(16)
                );
              if (value instanceof Set)
                return (
                  (key = nextPartId++),
                  (parentReference = serializeModel(Array.from(value), key)),
                  null === formData && (formData = new FormData()),
                  formData.append(formFieldPrefix + key, parentReference),
                  '$W' + key.toString(16)
                );
              if (value instanceof ArrayBuffer)
                return (
                  (key = new Blob([value])),
                  (parentReference = nextPartId++),
                  null === formData && (formData = new FormData()),
                  formData.append(formFieldPrefix + parentReference, key),
                  '$A' + parentReference.toString(16)
                );
              if (value instanceof Int8Array)
                return serializeTypedArray('O', value);
              if (value instanceof Uint8Array)
                return serializeTypedArray('o', value);
              if (value instanceof Uint8ClampedArray)
                return serializeTypedArray('U', value);
              if (value instanceof Int16Array)
                return serializeTypedArray('S', value);
              if (value instanceof Uint16Array)
                return serializeTypedArray('s', value);
              if (value instanceof Int32Array)
                return serializeTypedArray('L', value);
              if (value instanceof Uint32Array)
                return serializeTypedArray('l', value);
              if (value instanceof Float32Array)
                return serializeTypedArray('G', value);
              if (value instanceof Float64Array)
                return serializeTypedArray('g', value);
              if (value instanceof BigInt64Array)
                return serializeTypedArray('M', value);
              if (value instanceof BigUint64Array)
                return serializeTypedArray('m', value);
              if (value instanceof DataView)
                return serializeTypedArray('V', value);
              if ('function' === typeof Blob && value instanceof Blob)
                return (
                  null === formData && (formData = new FormData()),
                  (key = nextPartId++),
                  formData.append(formFieldPrefix + key, value),
                  '$B' + key.toString(16)
                );
              if ((key = getIteratorFn(value)))
                return (
                  (parentReference = key.call(value)),
                  parentReference === value
                    ? ((key = nextPartId++),
                      (parentReference = serializeModel(
                        Array.from(parentReference),
                        key,
                      )),
                      null === formData && (formData = new FormData()),
                      formData.append(formFieldPrefix + key, parentReference),
                      '$i' + key.toString(16))
                    : Array.from(parentReference)
                );
              if (
                'function' === typeof ReadableStream &&
                value instanceof ReadableStream
              )
                return serializeReadableStream(value);
              key = value[ASYNC_ITERATOR];
              if ('function' === typeof key)
                return serializeAsyncIterable(value, key.call(value));
              key = getPrototypeOf(value);
              if (
                key !== ObjectPrototype &&
                (null === key || null !== getPrototypeOf(key))
              ) {
                if (void 0 === temporaryReferences)
                  throw Error(
                    'Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.',
                  );
                return '$T';
              }
              return value;
            }
            if ('string' === typeof value) {
              if ('Z' === value[value.length - 1] && this[key] instanceof Date)
                return '$D' + value;
              key = '$' === value[0] ? '$' + value : value;
              return key;
            }
            if ('boolean' === typeof value) return value;
            if ('number' === typeof value) return serializeNumber(value);
            if ('undefined' === typeof value) return '$undefined';
            if ('function' === typeof value) {
              parentReference = knownServerReferences.get(value);
              if (void 0 !== parentReference)
                return (
                  (key = JSON.stringify(
                    {
                      id: parentReference.id,
                      bound: parentReference.bound,
                    },
                    resolveToJSON,
                  )),
                  null === formData && (formData = new FormData()),
                  (parentReference = nextPartId++),
                  formData.set(formFieldPrefix + parentReference, key),
                  '$F' + parentReference.toString(16)
                );
              if (
                void 0 !== temporaryReferences &&
                -1 === key.indexOf(':') &&
                ((parentReference = writtenObjects.get(this)),
                void 0 !== parentReference)
              )
                return (
                  temporaryReferences.set(parentReference + ':' + key, value),
                  '$T'
                );
              throw Error(
                'Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.',
              );
            }
            if ('symbol' === typeof value) {
              if (
                void 0 !== temporaryReferences &&
                -1 === key.indexOf(':') &&
                ((parentReference = writtenObjects.get(this)),
                void 0 !== parentReference)
              )
                return (
                  temporaryReferences.set(parentReference + ':' + key, value),
                  '$T'
                );
              throw Error(
                'Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.',
              );
            }
            if ('bigint' === typeof value) return '$n' + value.toString(10);
            throw Error(
              'Type ' +
                typeof value +
                ' is not supported as an argument to a Server Function.',
            );
          }
          function serializeModel(model, id) {
            'object' === typeof model &&
              null !== model &&
              ((id = '$' + id.toString(16)),
              writtenObjects.set(model, id),
              void 0 !== temporaryReferences &&
                temporaryReferences.set(id, model));
            modelRoot = model;
            return JSON.stringify(model, resolveToJSON);
          }
          var nextPartId = 1,
            pendingParts = 0,
            formData = null,
            writtenObjects = new WeakMap(),
            modelRoot = root,
            json = serializeModel(root, 0);
          null === formData
            ? resolve(json)
            : (formData.set(formFieldPrefix + '0', json),
              0 === pendingParts && resolve(formData));
          return function () {
            0 < pendingParts &&
              ((pendingParts = 0),
              null === formData ? resolve(json) : resolve(formData));
          };
        }
        function registerBoundServerReference(reference, id, bound) {
          knownServerReferences.has(reference) ||
            knownServerReferences.set(reference, {
              id: id,
              originalBind: reference.bind,
              bound: bound,
            });
        }
        function createBoundServerReference(metaData, callServer) {
          function action() {
            var args = Array.prototype.slice.call(arguments);
            return bound
              ? 'fulfilled' === bound.status
                ? callServer(id, bound.value.concat(args))
                : Promise.resolve(bound).then(function (boundArgs) {
                    return callServer(id, boundArgs.concat(args));
                  })
              : callServer(id, args);
          }
          var id = metaData.id,
            bound = metaData.bound;
          registerBoundServerReference(action, id, bound);
          return action;
        }
        function ReactPromise(status, value, reason) {
          this.status = status;
          this.value = value;
          this.reason = reason;
        }
        ReactPromise.prototype = Object.create(Promise.prototype);
        ReactPromise.prototype.then = function (resolve, reject) {
          switch (this.status) {
            case 'resolved_model':
              initializeModelChunk(this);
              break;
            case 'resolved_module':
              initializeModuleChunk(this);
          }
          switch (this.status) {
            case 'fulfilled':
              'function' === typeof resolve && resolve(this.value);
              break;
            case 'pending':
            case 'blocked':
              'function' === typeof resolve &&
                (null === this.value && (this.value = []),
                this.value.push(resolve));
              'function' === typeof reject &&
                (null === this.reason && (this.reason = []),
                this.reason.push(reject));
              break;
            case 'halted':
              break;
            default:
              'function' === typeof reject && reject(this.reason);
          }
        };
        function readChunk(chunk) {
          switch (chunk.status) {
            case 'resolved_model':
              initializeModelChunk(chunk);
              break;
            case 'resolved_module':
              initializeModuleChunk(chunk);
          }
          switch (chunk.status) {
            case 'fulfilled':
              return chunk.value;
            case 'pending':
            case 'blocked':
            case 'halted':
              throw chunk;
            default:
              throw chunk.reason;
          }
        }
        function wakeChunk(listeners, value) {
          for (var i = 0; i < listeners.length; i++) {
            var listener = listeners[i];
            'function' === typeof listener
              ? listener(value)
              : fulfillReference(listener, value);
          }
        }
        function rejectChunk(listeners, error) {
          for (var i = 0; i < listeners.length; i++) {
            var listener = listeners[i];
            'function' === typeof listener
              ? listener(error)
              : rejectReference(listener, error);
          }
        }
        function resolveBlockedCycle(resolvedChunk, reference) {
          var referencedChunk = reference.handler.chunk;
          if (null === referencedChunk) return null;
          if (referencedChunk === resolvedChunk) return reference.handler;
          reference = referencedChunk.value;
          if (null !== reference)
            for (
              referencedChunk = 0;
              referencedChunk < reference.length;
              referencedChunk++
            ) {
              var listener = reference[referencedChunk];
              if (
                'function' !== typeof listener &&
                ((listener = resolveBlockedCycle(resolvedChunk, listener)),
                null !== listener)
              )
                return listener;
            }
          return null;
        }
        function wakeChunkIfInitialized(
          chunk,
          resolveListeners,
          rejectListeners,
        ) {
          switch (chunk.status) {
            case 'fulfilled':
              wakeChunk(resolveListeners, chunk.value);
              break;
            case 'blocked':
              for (var i = 0; i < resolveListeners.length; i++) {
                var listener = resolveListeners[i];
                if ('function' !== typeof listener) {
                  var cyclicHandler = resolveBlockedCycle(chunk, listener);
                  null !== cyclicHandler &&
                    (fulfillReference(listener, cyclicHandler.value),
                    resolveListeners.splice(i, 1),
                    i--,
                    null !== rejectListeners &&
                      ((listener = rejectListeners.indexOf(listener)),
                      -1 !== listener && rejectListeners.splice(listener, 1)));
                }
              }
            case 'pending':
              if (chunk.value)
                for (i = 0; i < resolveListeners.length; i++)
                  chunk.value.push(resolveListeners[i]);
              else chunk.value = resolveListeners;
              if (chunk.reason) {
                if (rejectListeners)
                  for (
                    resolveListeners = 0;
                    resolveListeners < rejectListeners.length;
                    resolveListeners++
                  )
                    chunk.reason.push(rejectListeners[resolveListeners]);
              } else chunk.reason = rejectListeners;
              break;
            case 'rejected':
              rejectListeners && rejectChunk(rejectListeners, chunk.reason);
          }
        }
        function triggerErrorOnChunk(response, chunk, error) {
          'pending' !== chunk.status && 'blocked' !== chunk.status
            ? chunk.reason.error(error)
            : ((response = chunk.reason),
              (chunk.status = 'rejected'),
              (chunk.reason = error),
              null !== response && rejectChunk(response, error));
        }
        function createResolvedIteratorResultChunk(response, value, done) {
          return new ReactPromise(
            'resolved_model',
            (done ? '{"done":true,"value":' : '{"done":false,"value":') +
              value +
              '}',
            response,
          );
        }
        function resolveIteratorResultChunk(response, chunk, value, done) {
          resolveModelChunk(
            response,
            chunk,
            (done ? '{"done":true,"value":' : '{"done":false,"value":') +
              value +
              '}',
          );
        }
        function resolveModelChunk(response, chunk, value) {
          if ('pending' !== chunk.status) chunk.reason.enqueueModel(value);
          else {
            var resolveListeners = chunk.value,
              rejectListeners = chunk.reason;
            chunk.status = 'resolved_model';
            chunk.value = value;
            chunk.reason = response;
            null !== resolveListeners &&
              (initializeModelChunk(chunk),
              wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
          }
        }
        function resolveModuleChunk(response, chunk, value) {
          if ('pending' === chunk.status || 'blocked' === chunk.status) {
            response = chunk.value;
            var rejectListeners = chunk.reason;
            chunk.status = 'resolved_module';
            chunk.value = value;
            null !== response &&
              (initializeModuleChunk(chunk),
              wakeChunkIfInitialized(chunk, response, rejectListeners));
          }
        }
        var initializingHandler = null;
        function initializeModelChunk(chunk) {
          var prevHandler = initializingHandler;
          initializingHandler = null;
          var resolvedModel = chunk.value,
            response = chunk.reason;
          chunk.status = 'blocked';
          chunk.value = null;
          chunk.reason = null;
          try {
            var value = JSON.parse(resolvedModel, response._fromJSON),
              resolveListeners = chunk.value;
            if (null !== resolveListeners)
              for (
                chunk.value = null, chunk.reason = null, resolvedModel = 0;
                resolvedModel < resolveListeners.length;
                resolvedModel++
              ) {
                var listener = resolveListeners[resolvedModel];
                'function' === typeof listener
                  ? listener(value)
                  : fulfillReference(listener, value, chunk);
              }
            if (null !== initializingHandler) {
              if (initializingHandler.errored) throw initializingHandler.reason;
              if (0 < initializingHandler.deps) {
                initializingHandler.value = value;
                initializingHandler.chunk = chunk;
                return;
              }
            }
            chunk.status = 'fulfilled';
            chunk.value = value;
          } catch (error) {
            (chunk.status = 'rejected'), (chunk.reason = error);
          } finally {
            initializingHandler = prevHandler;
          }
        }
        function initializeModuleChunk(chunk) {
          try {
            var value = requireModule(chunk.value);
            chunk.status = 'fulfilled';
            chunk.value = value;
          } catch (error) {
            (chunk.status = 'rejected'), (chunk.reason = error);
          }
        }
        function reportGlobalError(weakResponse, error) {
          weakResponse._closed = !0;
          weakResponse._closedReason = error;
          weakResponse._chunks.forEach(function (chunk) {
            'pending' === chunk.status &&
              triggerErrorOnChunk(weakResponse, chunk, error);
          });
        }
        function createLazyChunkWrapper(chunk) {
          return {
            $$typeof: REACT_LAZY_TYPE,
            _payload: chunk,
            _init: readChunk,
          };
        }
        function getChunk(response, id) {
          var chunks = response._chunks,
            chunk = chunks.get(id);
          chunk ||
            ((chunk = response._closed
              ? new ReactPromise('rejected', null, response._closedReason)
              : new ReactPromise('pending', null, null)),
            chunks.set(id, chunk));
          return chunk;
        }
        function fulfillReference(reference, value) {
          for (
            var response = reference.response,
              handler = reference.handler,
              parentObject = reference.parentObject,
              key = reference.key,
              map = reference.map,
              path = reference.path,
              i = 1;
            i < path.length;
            i++
          ) {
            for (
              ;
              'object' === typeof value &&
              null !== value &&
              value.$$typeof === REACT_LAZY_TYPE;

            )
              if (((value = value._payload), value === handler.chunk))
                value = handler.value;
              else {
                switch (value.status) {
                  case 'resolved_model':
                    initializeModelChunk(value);
                    break;
                  case 'resolved_module':
                    initializeModuleChunk(value);
                }
                switch (value.status) {
                  case 'fulfilled':
                    value = value.value;
                    continue;
                  case 'blocked':
                    var cyclicHandler = resolveBlockedCycle(value, reference);
                    if (null !== cyclicHandler) {
                      value = cyclicHandler.value;
                      continue;
                    }
                  case 'pending':
                    path.splice(0, i - 1);
                    null === value.value
                      ? (value.value = [reference])
                      : value.value.push(reference);
                    null === value.reason
                      ? (value.reason = [reference])
                      : value.reason.push(reference);
                    return;
                  case 'halted':
                    return;
                  default:
                    rejectReference(reference, value.reason);
                    return;
                }
              }
            value = value[path[i]];
          }
          for (
            ;
            'object' === typeof value &&
            null !== value &&
            value.$$typeof === REACT_LAZY_TYPE;

          )
            if (((reference = value._payload), reference === handler.chunk))
              value = handler.value;
            else {
              switch (reference.status) {
                case 'resolved_model':
                  initializeModelChunk(reference);
                  break;
                case 'resolved_module':
                  initializeModuleChunk(reference);
              }
              switch (reference.status) {
                case 'fulfilled':
                  value = reference.value;
                  continue;
              }
              break;
            }
          response = map(response, value, parentObject, key);
          parentObject[key] = response;
          '' === key && null === handler.value && (handler.value = response);
          if (
            parentObject[0] === REACT_ELEMENT_TYPE &&
            'object' === typeof handler.value &&
            null !== handler.value &&
            handler.value.$$typeof === REACT_ELEMENT_TYPE
          )
            switch (((parentObject = handler.value), key)) {
              case '3':
                parentObject.props = response;
            }
          handler.deps--;
          0 === handler.deps &&
            ((key = handler.chunk),
            null !== key &&
              'blocked' === key.status &&
              ((parentObject = key.value),
              (key.status = 'fulfilled'),
              (key.value = handler.value),
              (key.reason = handler.reason),
              null !== parentObject && wakeChunk(parentObject, handler.value)));
        }
        function rejectReference(reference, error) {
          var handler = reference.handler;
          reference = reference.response;
          handler.errored ||
            ((handler.errored = !0),
            (handler.value = null),
            (handler.reason = error),
            (handler = handler.chunk),
            null !== handler &&
              'blocked' === handler.status &&
              triggerErrorOnChunk(reference, handler, error));
        }
        function waitForReference(
          referencedChunk,
          parentObject,
          key,
          response,
          map,
          path,
        ) {
          if (initializingHandler) {
            var handler = initializingHandler;
            handler.deps++;
          } else
            handler = initializingHandler = {
              parent: null,
              chunk: null,
              value: null,
              reason: null,
              deps: 1,
              errored: !1,
            };
          parentObject = {
            response: response,
            handler: handler,
            parentObject: parentObject,
            key: key,
            map: map,
            path: path,
          };
          null === referencedChunk.value
            ? (referencedChunk.value = [parentObject])
            : referencedChunk.value.push(parentObject);
          null === referencedChunk.reason
            ? (referencedChunk.reason = [parentObject])
            : referencedChunk.reason.push(parentObject);
          return null;
        }
        function loadServerReference(response, metaData, parentObject, key) {
          if (!response._serverReferenceConfig)
            return createBoundServerReference(metaData, response._callServer);
          var serverReference = resolveServerReference(
              response._serverReferenceConfig,
              metaData.id,
            ),
            promise = preloadModule(serverReference);
          if (promise)
            metaData.bound &&
              (promise = Promise.all([promise, metaData.bound]));
          else if (metaData.bound) promise = Promise.resolve(metaData.bound);
          else
            return (
              (promise = requireModule(serverReference)),
              registerBoundServerReference(
                promise,
                metaData.id,
                metaData.bound,
              ),
              promise
            );
          if (initializingHandler) {
            var handler = initializingHandler;
            handler.deps++;
          } else
            handler = initializingHandler = {
              parent: null,
              chunk: null,
              value: null,
              reason: null,
              deps: 1,
              errored: !1,
            };
          promise.then(
            function () {
              var resolvedValue = requireModule(serverReference);
              if (metaData.bound) {
                var boundArgs = metaData.bound.value.slice(0);
                boundArgs.unshift(null);
                resolvedValue = resolvedValue.bind.apply(
                  resolvedValue,
                  boundArgs,
                );
              }
              registerBoundServerReference(
                resolvedValue,
                metaData.id,
                metaData.bound,
              );
              parentObject[key] = resolvedValue;
              '' === key &&
                null === handler.value &&
                (handler.value = resolvedValue);
              if (
                parentObject[0] === REACT_ELEMENT_TYPE &&
                'object' === typeof handler.value &&
                null !== handler.value &&
                handler.value.$$typeof === REACT_ELEMENT_TYPE
              )
                switch (((boundArgs = handler.value), key)) {
                  case '3':
                    boundArgs.props = resolvedValue;
                }
              handler.deps--;
              0 === handler.deps &&
                ((resolvedValue = handler.chunk),
                null !== resolvedValue &&
                  'blocked' === resolvedValue.status &&
                  ((boundArgs = resolvedValue.value),
                  (resolvedValue.status = 'fulfilled'),
                  (resolvedValue.value = handler.value),
                  null !== boundArgs && wakeChunk(boundArgs, handler.value)));
            },
            function (error) {
              if (!handler.errored) {
                handler.errored = !0;
                handler.value = null;
                handler.reason = error;
                var chunk = handler.chunk;
                null !== chunk &&
                  'blocked' === chunk.status &&
                  triggerErrorOnChunk(response, chunk, error);
              }
            },
          );
          return null;
        }
        function getOutlinedModel(response, reference, parentObject, key, map) {
          reference = reference.split(':');
          var id = parseInt(reference[0], 16);
          id = getChunk(response, id);
          switch (id.status) {
            case 'resolved_model':
              initializeModelChunk(id);
              break;
            case 'resolved_module':
              initializeModuleChunk(id);
          }
          switch (id.status) {
            case 'fulfilled':
              id = id.value;
              for (var i = 1; i < reference.length; i++) {
                for (
                  ;
                  'object' === typeof id &&
                  null !== id &&
                  id.$$typeof === REACT_LAZY_TYPE;

                ) {
                  id = id._payload;
                  switch (id.status) {
                    case 'resolved_model':
                      initializeModelChunk(id);
                      break;
                    case 'resolved_module':
                      initializeModuleChunk(id);
                  }
                  switch (id.status) {
                    case 'fulfilled':
                      id = id.value;
                      break;
                    case 'blocked':
                    case 'pending':
                      return waitForReference(
                        id,
                        parentObject,
                        key,
                        response,
                        map,
                        reference.slice(i - 1),
                      );
                    case 'halted':
                      return (
                        initializingHandler
                          ? ((response = initializingHandler), response.deps++)
                          : (initializingHandler = {
                              parent: null,
                              chunk: null,
                              value: null,
                              reason: null,
                              deps: 1,
                              errored: !1,
                            }),
                        null
                      );
                    default:
                      return (
                        initializingHandler
                          ? ((initializingHandler.errored = !0),
                            (initializingHandler.value = null),
                            (initializingHandler.reason = id.reason))
                          : (initializingHandler = {
                              parent: null,
                              chunk: null,
                              value: null,
                              reason: id.reason,
                              deps: 0,
                              errored: !0,
                            }),
                        null
                      );
                  }
                }
                id = id[reference[i]];
              }
              for (
                ;
                'object' === typeof id &&
                null !== id &&
                id.$$typeof === REACT_LAZY_TYPE;

              ) {
                reference = id._payload;
                switch (reference.status) {
                  case 'resolved_model':
                    initializeModelChunk(reference);
                    break;
                  case 'resolved_module':
                    initializeModuleChunk(reference);
                }
                switch (reference.status) {
                  case 'fulfilled':
                    id = reference.value;
                    continue;
                }
                break;
              }
              return map(response, id, parentObject, key);
            case 'pending':
            case 'blocked':
              return waitForReference(
                id,
                parentObject,
                key,
                response,
                map,
                reference,
              );
            case 'halted':
              return (
                initializingHandler
                  ? ((response = initializingHandler), response.deps++)
                  : (initializingHandler = {
                      parent: null,
                      chunk: null,
                      value: null,
                      reason: null,
                      deps: 1,
                      errored: !1,
                    }),
                null
              );
            default:
              return (
                initializingHandler
                  ? ((initializingHandler.errored = !0),
                    (initializingHandler.value = null),
                    (initializingHandler.reason = id.reason))
                  : (initializingHandler = {
                      parent: null,
                      chunk: null,
                      value: null,
                      reason: id.reason,
                      deps: 0,
                      errored: !0,
                    }),
                null
              );
          }
        }
        function createMap(response, model) {
          return new Map(model);
        }
        function createSet(response, model) {
          return new Set(model);
        }
        function createBlob(response, model) {
          return new Blob(model.slice(1), {
            type: model[0],
          });
        }
        function createFormData(response, model) {
          response = new FormData();
          for (var i = 0; i < model.length; i++)
            response.append(model[i][0], model[i][1]);
          return response;
        }
        function extractIterator(response, model) {
          return model[Symbol.iterator]();
        }
        function createModel(response, model) {
          return model;
        }
        function parseModelString(response, parentObject, key, value) {
          if ('$' === value[0]) {
            if ('$' === value)
              return (
                null !== initializingHandler &&
                  '0' === key &&
                  (initializingHandler = {
                    parent: initializingHandler,
                    chunk: null,
                    value: null,
                    reason: null,
                    deps: 0,
                    errored: !1,
                  }),
                REACT_ELEMENT_TYPE
              );
            switch (value[1]) {
              case '$':
                return value.slice(1);
              case 'L':
                return (
                  (parentObject = parseInt(value.slice(2), 16)),
                  (response = getChunk(response, parentObject)),
                  createLazyChunkWrapper(response)
                );
              case '@':
                return (
                  (parentObject = parseInt(value.slice(2), 16)),
                  getChunk(response, parentObject)
                );
              case 'S':
                return Symbol.for(value.slice(2));
              case 'F':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(
                    response,
                    value,
                    parentObject,
                    key,
                    loadServerReference,
                  )
                );
              case 'T':
                parentObject = '$' + value.slice(2);
                response = response._tempRefs;
                if (null == response)
                  throw Error(
                    'Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.',
                  );
                return response.get(parentObject);
              case 'Q':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(
                    response,
                    value,
                    parentObject,
                    key,
                    createMap,
                  )
                );
              case 'W':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(
                    response,
                    value,
                    parentObject,
                    key,
                    createSet,
                  )
                );
              case 'B':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(
                    response,
                    value,
                    parentObject,
                    key,
                    createBlob,
                  )
                );
              case 'K':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(
                    response,
                    value,
                    parentObject,
                    key,
                    createFormData,
                  )
                );
              case 'Z':
                return resolveErrorProd();
              case 'i':
                return (
                  (value = value.slice(2)),
                  getOutlinedModel(
                    response,
                    value,
                    parentObject,
                    key,
                    extractIterator,
                  )
                );
              case 'I':
                return Infinity;
              case '-':
                return '$-0' === value ? -0 : -Infinity;
              case 'N':
                return NaN;
              case 'u':
                return;
              case 'D':
                return new Date(Date.parse(value.slice(2)));
              case 'n':
                return BigInt(value.slice(2));
              default:
                return (
                  (value = value.slice(1)),
                  getOutlinedModel(
                    response,
                    value,
                    parentObject,
                    key,
                    createModel,
                  )
                );
            }
          }
          return value;
        }
        function missingCall() {
          throw Error(
            'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.',
          );
        }
        function ResponseInstance(
          bundlerConfig,
          serverReferenceConfig,
          moduleLoading,
          callServer,
          encodeFormAction,
          nonce,
          temporaryReferences,
        ) {
          var chunks = new Map();
          this._bundlerConfig = bundlerConfig;
          this._serverReferenceConfig = serverReferenceConfig;
          this._moduleLoading = moduleLoading;
          this._callServer = void 0 !== callServer ? callServer : missingCall;
          this._encodeFormAction = encodeFormAction;
          this._nonce = nonce;
          this._chunks = chunks;
          this._stringDecoder = new TextDecoder();
          this._fromJSON = null;
          this._closed = !1;
          this._closedReason = null;
          this._tempRefs = temporaryReferences;
          this._fromJSON = createFromJSONCallback(this);
        }
        function resolveBuffer(response, id, buffer) {
          response = response._chunks;
          var chunk = response.get(id);
          chunk && 'pending' !== chunk.status
            ? chunk.reason.enqueueValue(buffer)
            : ((buffer = new ReactPromise('fulfilled', buffer, null)),
              response.set(id, buffer));
        }
        function resolveModule(response, id, model) {
          var chunks = response._chunks,
            chunk = chunks.get(id);
          model = JSON.parse(model, response._fromJSON);
          var clientReference = resolveClientReference(
            response._bundlerConfig,
            model,
          );
          if ((model = preloadModule(clientReference))) {
            if (chunk) {
              var blockedChunk = chunk;
              blockedChunk.status = 'blocked';
            } else
              (blockedChunk = new ReactPromise('blocked', null, null)),
                chunks.set(id, blockedChunk);
            model.then(
              function () {
                return resolveModuleChunk(
                  response,
                  blockedChunk,
                  clientReference,
                );
              },
              function (error) {
                return triggerErrorOnChunk(response, blockedChunk, error);
              },
            );
          } else
            chunk
              ? resolveModuleChunk(response, chunk, clientReference)
              : ((chunk = new ReactPromise(
                  'resolved_module',
                  clientReference,
                  null,
                )),
                chunks.set(id, chunk));
        }
        function resolveStream(response, id, stream, controller) {
          response = response._chunks;
          var chunk = response.get(id);
          chunk
            ? 'pending' === chunk.status &&
              ((id = chunk.value),
              (chunk.status = 'fulfilled'),
              (chunk.value = stream),
              (chunk.reason = controller),
              null !== id && wakeChunk(id, chunk.value))
            : ((stream = new ReactPromise('fulfilled', stream, controller)),
              response.set(id, stream));
        }
        function startReadableStream(response, id, type) {
          var controller = null;
          type = new ReadableStream({
            type: type,
            start: function (c) {
              controller = c;
            },
          });
          var previousBlockedChunk = null;
          resolveStream(response, id, type, {
            enqueueValue: function (value) {
              null === previousBlockedChunk
                ? controller.enqueue(value)
                : previousBlockedChunk.then(function () {
                    controller.enqueue(value);
                  });
            },
            enqueueModel: function (json) {
              if (null === previousBlockedChunk) {
                var chunk = new ReactPromise('resolved_model', json, response);
                initializeModelChunk(chunk);
                'fulfilled' === chunk.status
                  ? controller.enqueue(chunk.value)
                  : (chunk.then(
                      function (v) {
                        return controller.enqueue(v);
                      },
                      function (e) {
                        return controller.error(e);
                      },
                    ),
                    (previousBlockedChunk = chunk));
              } else {
                chunk = previousBlockedChunk;
                var chunk$54 = new ReactPromise('pending', null, null);
                chunk$54.then(
                  function (v) {
                    return controller.enqueue(v);
                  },
                  function (e) {
                    return controller.error(e);
                  },
                );
                previousBlockedChunk = chunk$54;
                chunk.then(function () {
                  previousBlockedChunk === chunk$54 &&
                    (previousBlockedChunk = null);
                  resolveModelChunk(response, chunk$54, json);
                });
              }
            },
            close: function () {
              if (null === previousBlockedChunk) controller.close();
              else {
                var blockedChunk = previousBlockedChunk;
                previousBlockedChunk = null;
                blockedChunk.then(function () {
                  return controller.close();
                });
              }
            },
            error: function (error) {
              if (null === previousBlockedChunk) controller.error(error);
              else {
                var blockedChunk = previousBlockedChunk;
                previousBlockedChunk = null;
                blockedChunk.then(function () {
                  return controller.error(error);
                });
              }
            },
          });
        }
        function asyncIterator() {
          return this;
        }
        function createIterator(next) {
          next = {
            next: next,
          };
          next[ASYNC_ITERATOR] = asyncIterator;
          return next;
        }
        function startAsyncIterable(response, id, iterator) {
          var buffer = [],
            closed = !1,
            nextWriteIndex = 0,
            iterable = {};
          iterable[ASYNC_ITERATOR] = function () {
            var nextReadIndex = 0;
            return createIterator(function (arg) {
              if (void 0 !== arg)
                throw Error(
                  'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
                );
              if (nextReadIndex === buffer.length) {
                if (closed)
                  return new ReactPromise(
                    'fulfilled',
                    {
                      done: !0,
                      value: void 0,
                    },
                    null,
                  );
                buffer[nextReadIndex] = new ReactPromise('pending', null, null);
              }
              return buffer[nextReadIndex++];
            });
          };
          resolveStream(
            response,
            id,
            iterator ? iterable[ASYNC_ITERATOR]() : iterable,
            {
              enqueueValue: function (value) {
                if (nextWriteIndex === buffer.length)
                  buffer[nextWriteIndex] = new ReactPromise(
                    'fulfilled',
                    {
                      done: !1,
                      value: value,
                    },
                    null,
                  );
                else {
                  var chunk = buffer[nextWriteIndex],
                    resolveListeners = chunk.value,
                    rejectListeners = chunk.reason;
                  chunk.status = 'fulfilled';
                  chunk.value = {
                    done: !1,
                    value: value,
                  };
                  null !== resolveListeners &&
                    wakeChunkIfInitialized(
                      chunk,
                      resolveListeners,
                      rejectListeners,
                    );
                }
                nextWriteIndex++;
              },
              enqueueModel: function (value) {
                nextWriteIndex === buffer.length
                  ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                      response,
                      value,
                      !1,
                    ))
                  : resolveIteratorResultChunk(
                      response,
                      buffer[nextWriteIndex],
                      value,
                      !1,
                    );
                nextWriteIndex++;
              },
              close: function (value) {
                closed = !0;
                nextWriteIndex === buffer.length
                  ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                      response,
                      value,
                      !0,
                    ))
                  : resolveIteratorResultChunk(
                      response,
                      buffer[nextWriteIndex],
                      value,
                      !0,
                    );
                for (nextWriteIndex++; nextWriteIndex < buffer.length; )
                  resolveIteratorResultChunk(
                    response,
                    buffer[nextWriteIndex++],
                    '"$undefined"',
                    !0,
                  );
              },
              error: function (error) {
                closed = !0;
                for (
                  nextWriteIndex === buffer.length &&
                  (buffer[nextWriteIndex] = new ReactPromise(
                    'pending',
                    null,
                    null,
                  ));
                  nextWriteIndex < buffer.length;

                )
                  triggerErrorOnChunk(
                    response,
                    buffer[nextWriteIndex++],
                    error,
                  );
              },
            },
          );
        }
        function resolveErrorProd() {
          var error = Error(
            'An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.',
          );
          error.stack = 'Error: ' + error.message;
          return error;
        }
        function mergeBuffer(buffer, lastChunk) {
          for (
            var l = buffer.length, byteLength = lastChunk.length, i = 0;
            i < l;
            i++
          )
            byteLength += buffer[i].byteLength;
          byteLength = new Uint8Array(byteLength);
          for (var i$55 = (i = 0); i$55 < l; i$55++) {
            var chunk = buffer[i$55];
            byteLength.set(chunk, i);
            i += chunk.byteLength;
          }
          byteLength.set(lastChunk, i);
          return byteLength;
        }
        function resolveTypedArray(
          response,
          id,
          buffer,
          lastChunk,
          constructor,
          bytesPerElement,
        ) {
          buffer =
            0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
              ? lastChunk
              : mergeBuffer(buffer, lastChunk);
          constructor = new constructor(
            buffer.buffer,
            buffer.byteOffset,
            buffer.byteLength / bytesPerElement,
          );
          resolveBuffer(response, id, constructor);
        }
        function processFullBinaryRow(
          response,
          streamState,
          id,
          tag,
          buffer,
          chunk,
        ) {
          switch (tag) {
            case 65:
              resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);
              return;
            case 79:
              resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);
              return;
            case 111:
              resolveBuffer(
                response,
                id,
                0 === buffer.length ? chunk : mergeBuffer(buffer, chunk),
              );
              return;
            case 85:
              resolveTypedArray(
                response,
                id,
                buffer,
                chunk,
                Uint8ClampedArray,
                1,
              );
              return;
            case 83:
              resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);
              return;
            case 115:
              resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);
              return;
            case 76:
              resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);
              return;
            case 108:
              resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);
              return;
            case 71:
              resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);
              return;
            case 103:
              resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);
              return;
            case 77:
              resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);
              return;
            case 109:
              resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);
              return;
            case 86:
              resolveTypedArray(response, id, buffer, chunk, DataView, 1);
              return;
          }
          streamState = response._stringDecoder;
          for (var row = '', i = 0; i < buffer.length; i++)
            row += streamState.decode(buffer[i], decoderOptions);
          buffer = row += streamState.decode(chunk);
          switch (tag) {
            case 73:
              resolveModule(response, id, buffer);
              break;
            case 72:
              id = buffer[0];
              buffer = buffer.slice(1);
              response = JSON.parse(buffer, response._fromJSON);
              buffer = ReactDOMSharedInternals.d;
              switch (id) {
                case 'D':
                  buffer.D(response);
                  break;
                case 'C':
                  'string' === typeof response
                    ? buffer.C(response)
                    : buffer.C(response[0], response[1]);
                  break;
                case 'L':
                  id = response[0];
                  tag = response[1];
                  3 === response.length
                    ? buffer.L(id, tag, response[2])
                    : buffer.L(id, tag);
                  break;
                case 'm':
                  'string' === typeof response
                    ? buffer.m(response)
                    : buffer.m(response[0], response[1]);
                  break;
                case 'X':
                  'string' === typeof response
                    ? buffer.X(response)
                    : buffer.X(response[0], response[1]);
                  break;
                case 'S':
                  'string' === typeof response
                    ? buffer.S(response)
                    : buffer.S(
                        response[0],
                        0 === response[1] ? void 0 : response[1],
                        3 === response.length ? response[2] : void 0,
                      );
                  break;
                case 'M':
                  'string' === typeof response
                    ? buffer.M(response)
                    : buffer.M(response[0], response[1]);
              }
              break;
            case 69:
              tag = response._chunks;
              chunk = tag.get(id);
              buffer = JSON.parse(buffer);
              streamState = resolveErrorProd();
              streamState.digest = buffer.digest;
              chunk
                ? triggerErrorOnChunk(response, chunk, streamState)
                : ((response = new ReactPromise('rejected', null, streamState)),
                  tag.set(id, response));
              break;
            case 84:
              response = response._chunks;
              (tag = response.get(id)) && 'pending' !== tag.status
                ? tag.reason.enqueueValue(buffer)
                : ((buffer = new ReactPromise('fulfilled', buffer, null)),
                  response.set(id, buffer));
              break;
            case 78:
            case 68:
            case 74:
            case 87:
              throw Error(
                'Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client.',
              );
            case 82:
              startReadableStream(response, id, void 0);
              break;
            case 114:
              startReadableStream(response, id, 'bytes');
              break;
            case 88:
              startAsyncIterable(response, id, !1);
              break;
            case 120:
              startAsyncIterable(response, id, !0);
              break;
            case 67:
              (id = response._chunks.get(id)) &&
                'fulfilled' === id.status &&
                id.reason.close('' === buffer ? '"$undefined"' : buffer);
              break;
            default:
              (tag = response._chunks),
                (chunk = tag.get(id))
                  ? resolveModelChunk(response, chunk, buffer)
                  : ((response = new ReactPromise(
                      'resolved_model',
                      buffer,
                      response,
                    )),
                    tag.set(id, response));
          }
        }
        function createFromJSONCallback(response) {
          return function (key, value) {
            if ('string' === typeof value)
              return parseModelString(response, this, key, value);
            if ('object' === typeof value && null !== value) {
              if (value[0] === REACT_ELEMENT_TYPE) {
                if (
                  ((key = {
                    $$typeof: REACT_ELEMENT_TYPE,
                    type: value[1],
                    key: value[2],
                    ref: null,
                    props: value[3],
                  }),
                  null !== initializingHandler)
                )
                  if (
                    ((value = initializingHandler),
                    (initializingHandler = value.parent),
                    value.errored)
                  )
                    (key = new ReactPromise('rejected', null, value.reason)),
                      (key = createLazyChunkWrapper(key));
                  else if (0 < value.deps) {
                    var blockedChunk = new ReactPromise('blocked', null, null);
                    value.value = key;
                    value.chunk = blockedChunk;
                    key = createLazyChunkWrapper(blockedChunk);
                  }
              } else key = value;
              return key;
            }
            return value;
          };
        }
        function close(weakResponse) {
          reportGlobalError(weakResponse, Error('Connection closed.'));
        }
        function createResponseFromOptions(options) {
          return new ResponseInstance(
            null,
            null,
            null,
            options && options.callServer ? options.callServer : void 0,
            void 0,
            void 0,
            options && options.temporaryReferences
              ? options.temporaryReferences
              : void 0,
          );
        }
        function startReadingFromStream(response, stream, onDone) {
          function progress(_ref2) {
            var value = _ref2.value;
            if (_ref2.done) return onDone();
            var i = 0,
              rowState = streamState._rowState;
            _ref2 = streamState._rowID;
            for (
              var rowTag = streamState._rowTag,
                rowLength = streamState._rowLength,
                buffer = streamState._buffer,
                chunkLength = value.length;
              i < chunkLength;

            ) {
              var lastIdx = -1;
              switch (rowState) {
                case 0:
                  lastIdx = value[i++];
                  58 === lastIdx
                    ? (rowState = 1)
                    : (_ref2 =
                        (_ref2 << 4) |
                        (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
                  continue;
                case 1:
                  rowState = value[i];
                  84 === rowState ||
                  65 === rowState ||
                  79 === rowState ||
                  111 === rowState ||
                  85 === rowState ||
                  83 === rowState ||
                  115 === rowState ||
                  76 === rowState ||
                  108 === rowState ||
                  71 === rowState ||
                  103 === rowState ||
                  77 === rowState ||
                  109 === rowState ||
                  86 === rowState
                    ? ((rowTag = rowState), (rowState = 2), i++)
                    : (64 < rowState && 91 > rowState) ||
                        35 === rowState ||
                        114 === rowState ||
                        120 === rowState
                      ? ((rowTag = rowState), (rowState = 3), i++)
                      : ((rowTag = 0), (rowState = 3));
                  continue;
                case 2:
                  lastIdx = value[i++];
                  44 === lastIdx
                    ? (rowState = 4)
                    : (rowLength =
                        (rowLength << 4) |
                        (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
                  continue;
                case 3:
                  lastIdx = value.indexOf(10, i);
                  break;
                case 4:
                  (lastIdx = i + rowLength),
                    lastIdx > value.length && (lastIdx = -1);
              }
              var offset = value.byteOffset + i;
              if (-1 < lastIdx)
                (rowLength = new Uint8Array(value.buffer, offset, lastIdx - i)),
                  processFullBinaryRow(
                    response,
                    streamState,
                    _ref2,
                    rowTag,
                    buffer,
                    rowLength,
                  ),
                  (i = lastIdx),
                  3 === rowState && i++,
                  (rowLength = _ref2 = rowTag = rowState = 0),
                  (buffer.length = 0);
              else {
                value = new Uint8Array(
                  value.buffer,
                  offset,
                  value.byteLength - i,
                );
                buffer.push(value);
                rowLength -= value.byteLength;
                break;
              }
            }
            streamState._rowState = rowState;
            streamState._rowID = _ref2;
            streamState._rowTag = rowTag;
            streamState._rowLength = rowLength;
            return reader.read().then(progress).catch(error);
          }
          function error(e) {
            reportGlobalError(response, e);
          }
          var streamState = {
              _rowState: 0,
              _rowID: 0,
              _rowTag: 0,
              _rowLength: 0,
              _buffer: [],
            },
            reader = stream.getReader();
          reader.read().then(progress).catch(error);
        }
        exports.createFromFetch = function (promiseForResponse, options) {
          var response = createResponseFromOptions(options);
          promiseForResponse.then(
            function (r) {
              startReadingFromStream(
                response,
                r.body,
                close.bind(null, response),
              );
            },
            function (e) {
              reportGlobalError(response, e);
            },
          );
          return getChunk(response, 0);
        };
        exports.createFromReadableStream = function (stream, options) {
          options = createResponseFromOptions(options);
          startReadingFromStream(options, stream, close.bind(null, options));
          return getChunk(options, 0);
        };
        exports.createServerReference = function (id, callServer) {
          function action() {
            var args = Array.prototype.slice.call(arguments);
            return callServer(id, args);
          }
          registerBoundServerReference(action, id, null);
          return action;
        };
        exports.createTemporaryReferenceSet = function () {
          return new Map();
        };
        exports.encodeReply = function (value, options) {
          return new Promise(function (resolve, reject) {
            var abort = processReply(
              value,
              '',
              options && options.temporaryReferences
                ? options.temporaryReferences
                : void 0,
              resolve,
              reject,
            );
            if (options && options.signal) {
              var signal = options.signal;
              if (signal.aborted) abort(signal.reason);
              else {
                var listener = function () {
                  abort(signal.reason);
                  signal.removeEventListener('abort', listener);
                };
                signal.addEventListener('abort', listener);
              }
            }
          });
        };
        exports.registerServerReference = function (reference, id) {
          registerBoundServerReference(reference, id, null);
          return reference;
        };

        /***/
      },

    /***/ '(client)/../../../packages/react-server-dom-webpack/client.browser.js':
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        if (true) {
          module.exports = __webpack_require__(
            '(client)/../../../packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.production.js',
          );
        } else {
        }

        /***/
      },

    /***/ '(client)/../../../../../Library/pnpm/store/v10/links/@/react-dom/19.2.0/09f8862f9cadb2790b70b94ddb646e94427b7be0ff242c2c964e8bf83ca4dd56/node_modules/react-dom/cjs/react-dom-client.production.js':
      /***/ (__unused_webpack_module, exports, __webpack_require__) => {
        'use strict';
        var __webpack_unused_export__;
        /**
         * @license React
         * react-dom-client.production.js
         *
         * Copyright (c) Meta Platforms, Inc. and affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        /*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

        var Scheduler = __webpack_require__(
            '(client)/../../../../../Library/pnpm/store/v10/links/@/scheduler/0.27.0/769e30ccb12382a7627d59e00e6d36ba15663a7c35f2c65f3934708e0b0ff464/node_modules/scheduler/index.js',
          ),
          React = __webpack_require__(
            '(client)/webpack/sharing/consume/client/react/react',
          ),
          ReactDOM = __webpack_require__(
            '(client)/webpack/sharing/consume/client/react-dom/react-dom',
          );
        function formatProdErrorMessage(code) {
          var url = 'https://react.dev/errors/' + code;
          if (1 < arguments.length) {
            url += '?args[]=' + encodeURIComponent(arguments[1]);
            for (var i = 2; i < arguments.length; i++)
              url += '&args[]=' + encodeURIComponent(arguments[i]);
          }
          return (
            'Minified React error #' +
            code +
            '; visit ' +
            url +
            ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
          );
        }
        function isValidContainer(node) {
          return !(
            !node ||
            (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
          );
        }
        function getNearestMountedFiber(fiber) {
          var node = fiber,
            nearestMounted = fiber;
          if (fiber.alternate) for (; node.return; ) node = node.return;
          else {
            fiber = node;
            do
              (node = fiber),
                0 !== (node.flags & 4098) && (nearestMounted = node.return),
                (fiber = node.return);
            while (fiber);
          }
          return 3 === node.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            null === suspenseState &&
              ((fiber = fiber.alternate),
              null !== fiber && (suspenseState = fiber.memoizedState));
            if (null !== suspenseState) return suspenseState.dehydrated;
          }
          return null;
        }
        function getActivityInstanceFromFiber(fiber) {
          if (31 === fiber.tag) {
            var activityState = fiber.memoizedState;
            null === activityState &&
              ((fiber = fiber.alternate),
              null !== fiber && (activityState = fiber.memoizedState));
            if (null !== activityState) return activityState.dehydrated;
          }
          return null;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber)
            throw Error(formatProdErrorMessage(188));
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            alternate = getNearestMountedFiber(fiber);
            if (null === alternate) throw Error(formatProdErrorMessage(188));
            return alternate !== fiber ? null : fiber;
          }
          for (var a = fiber, b = alternate; ; ) {
            var parentA = a.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
              b = parentA.return;
              if (null !== b) {
                a = b;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              for (parentB = parentA.child; parentB; ) {
                if (parentB === a) return assertIsMounted(parentA), fiber;
                if (parentB === b) return assertIsMounted(parentA), alternate;
                parentB = parentB.sibling;
              }
              throw Error(formatProdErrorMessage(188));
            }
            if (a.return !== b.return) (a = parentA), (b = parentB);
            else {
              for (var didFindChild = !1, child$0 = parentA.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = !0;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (child$0 === b) {
                  didFindChild = !0;
                  b = parentA;
                  a = parentB;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) {
                for (child$0 = parentB.child; child$0; ) {
                  if (child$0 === a) {
                    didFindChild = !0;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (child$0 === b) {
                    didFindChild = !0;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  child$0 = child$0.sibling;
                }
                if (!didFindChild) throw Error(formatProdErrorMessage(189));
              }
            }
            if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
          }
          if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
          return a.stateNode.current === a ? fiber : alternate;
        }
        function findCurrentHostFiberImpl(node) {
          var tag = node.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
          for (node = node.child; null !== node; ) {
            tag = findCurrentHostFiberImpl(node);
            if (null !== tag) return tag;
            node = node.sibling;
          }
          return null;
        }
        var assign = Object.assign,
          REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element'),
          REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
          REACT_PORTAL_TYPE = Symbol.for('react.portal'),
          REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
          REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode'),
          REACT_PROFILER_TYPE = Symbol.for('react.profiler'),
          REACT_CONSUMER_TYPE = Symbol.for('react.consumer'),
          REACT_CONTEXT_TYPE = Symbol.for('react.context'),
          REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
          REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
          REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
          REACT_MEMO_TYPE = Symbol.for('react.memo'),
          REACT_LAZY_TYPE = Symbol.for('react.lazy');
        Symbol.for('react.scope');
        var REACT_ACTIVITY_TYPE = Symbol.for('react.activity');
        Symbol.for('react.legacy_hidden');
        Symbol.for('react.tracing_marker');
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
        Symbol.for('react.view_transition');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || 'object' !== typeof maybeIterable)
            return null;
          maybeIterable =
            (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
            maybeIterable['@@iterator'];
          return 'function' === typeof maybeIterable ? maybeIterable : null;
        }
        var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ('function' === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE
              ? null
              : type.displayName || type.name || null;
          if ('string' === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return 'Fragment';
            case REACT_PROFILER_TYPE:
              return 'Profiler';
            case REACT_STRICT_MODE_TYPE:
              return 'StrictMode';
            case REACT_SUSPENSE_TYPE:
              return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
              return 'SuspenseList';
            case REACT_ACTIVITY_TYPE:
              return 'Activity';
          }
          if ('object' === typeof type)
            switch (type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return 'Portal';
              case REACT_CONTEXT_TYPE:
                return type.displayName || 'Context';
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || 'Context') + '.Consumer';
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type ||
                  ((type = innerType.displayName || innerType.name || ''),
                  (type =
                    '' !== type ? 'ForwardRef(' + type + ')' : 'ForwardRef'));
                return type;
              case REACT_MEMO_TYPE:
                return (
                  (innerType = type.displayName || null),
                  null !== innerType
                    ? innerType
                    : getComponentNameFromType(type.type) || 'Memo'
                );
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {}
            }
          return null;
        }
        var isArrayImpl = Array.isArray,
          ReactSharedInternals =
            React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
          ReactDOMSharedInternals =
            ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
          sharedNotPendingObject = {
            pending: !1,
            data: null,
            method: null,
            action: null,
          },
          valueStack = [],
          index = -1;
        function createCursor(defaultValue) {
          return { current: defaultValue };
        }
        function pop(cursor) {
          0 > index ||
            ((cursor.current = valueStack[index]),
            (valueStack[index] = null),
            index--);
        }
        function push(cursor, value) {
          index++;
          valueStack[index] = cursor.current;
          cursor.current = value;
        }
        var contextStackCursor = createCursor(null),
          contextFiberStackCursor = createCursor(null),
          rootInstanceStackCursor = createCursor(null),
          hostTransitionProviderCursor = createCursor(null);
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance);
          push(contextFiberStackCursor, fiber);
          push(contextStackCursor, null);
          switch (nextRootInstance.nodeType) {
            case 9:
            case 11:
              fiber = (fiber = nextRootInstance.documentElement)
                ? (fiber = fiber.namespaceURI)
                  ? getOwnHostContext(fiber)
                  : 0
                : 0;
              break;
            default:
              if (
                ((fiber = nextRootInstance.tagName),
                (nextRootInstance = nextRootInstance.namespaceURI))
              )
                (nextRootInstance = getOwnHostContext(nextRootInstance)),
                  (fiber = getChildHostContextProd(nextRootInstance, fiber));
              else
                switch (fiber) {
                  case 'svg':
                    fiber = 1;
                    break;
                  case 'math':
                    fiber = 2;
                    break;
                  default:
                    fiber = 0;
                }
          }
          pop(contextStackCursor);
          push(contextStackCursor, fiber);
        }
        function popHostContainer() {
          pop(contextStackCursor);
          pop(contextFiberStackCursor);
          pop(rootInstanceStackCursor);
        }
        function pushHostContext(fiber) {
          null !== fiber.memoizedState &&
            push(hostTransitionProviderCursor, fiber);
          var context = contextStackCursor.current;
          var JSCompiler_inline_result = getChildHostContextProd(
            context,
            fiber.type,
          );
          context !== JSCompiler_inline_result &&
            (push(contextFiberStackCursor, fiber),
            push(contextStackCursor, JSCompiler_inline_result));
        }
        function popHostContext(fiber) {
          contextFiberStackCursor.current === fiber &&
            (pop(contextStackCursor), pop(contextFiberStackCursor));
          hostTransitionProviderCursor.current === fiber &&
            (pop(hostTransitionProviderCursor),
            (HostTransitionContext._currentValue = sharedNotPendingObject));
        }
        var prefix, suffix;
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = (match && match[1]) || '';
              suffix =
                -1 < x.stack.indexOf('\n    at')
                  ? ' (<anonymous>)'
                  : -1 < x.stack.indexOf('@')
                    ? '@unknown:0:0'
                    : '';
            }
          return '\n' + prefix + name + suffix;
        }
        var reentry = !1;
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return '';
          reentry = !0;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function () {
                try {
                  if (construct) {
                    var Fake = function () {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, 'props', {
                      set: function () {
                        throw Error();
                      },
                    });
                    if ('object' === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x) {
                        var control = x;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$1) {
                        control = x$1;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$2) {
                      control = x$2;
                    }
                    (Fake = fn()) &&
                      'function' === typeof Fake.catch &&
                      Fake.catch(function () {});
                  }
                } catch (sample) {
                  if (sample && control && 'string' === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              },
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName =
              'DetermineComponentFrameRoot';
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              'name',
            );
            namePropDescriptor &&
              namePropDescriptor.configurable &&
              Object.defineProperty(
                RunInRootFrame.DetermineComponentFrameRoot,
                'name',
                { value: 'DetermineComponentFrameRoot' },
              );
            var _RunInRootFrame$Deter =
                RunInRootFrame.DetermineComponentFrameRoot(),
              sampleStack = _RunInRootFrame$Deter[0],
              controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split('\n'),
                controlLines = controlStack.split('\n');
              for (
                namePropDescriptor = RunInRootFrame = 0;
                RunInRootFrame < sampleLines.length &&
                !sampleLines[RunInRootFrame].includes(
                  'DetermineComponentFrameRoot',
                );

              )
                RunInRootFrame++;
              for (
                ;
                namePropDescriptor < controlLines.length &&
                !controlLines[namePropDescriptor].includes(
                  'DetermineComponentFrameRoot',
                );

              )
                namePropDescriptor++;
              if (
                RunInRootFrame === sampleLines.length ||
                namePropDescriptor === controlLines.length
              )
                for (
                  RunInRootFrame = sampleLines.length - 1,
                    namePropDescriptor = controlLines.length - 1;
                  1 <= RunInRootFrame &&
                  0 <= namePropDescriptor &&
                  sampleLines[RunInRootFrame] !==
                    controlLines[namePropDescriptor];

                )
                  namePropDescriptor--;
              for (
                ;
                1 <= RunInRootFrame && 0 <= namePropDescriptor;
                RunInRootFrame--, namePropDescriptor--
              )
                if (
                  sampleLines[RunInRootFrame] !==
                  controlLines[namePropDescriptor]
                ) {
                  if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                    do
                      if (
                        (RunInRootFrame--,
                        namePropDescriptor--,
                        0 > namePropDescriptor ||
                          sampleLines[RunInRootFrame] !==
                            controlLines[namePropDescriptor])
                      ) {
                        var frame =
                          '\n' +
                          sampleLines[RunInRootFrame].replace(
                            ' at new ',
                            ' at ',
                          );
                        fn.displayName &&
                          frame.includes('<anonymous>') &&
                          (frame = frame.replace(
                            '<anonymous>',
                            fn.displayName,
                          ));
                        return frame;
                      }
                    while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                  }
                  break;
                }
            }
          } finally {
            (reentry = !1),
              (Error.prepareStackTrace = previousPrepareStackTrace);
          }
          return (previousPrepareStackTrace = fn
            ? fn.displayName || fn.name
            : '')
            ? describeBuiltInComponentFrame(previousPrepareStackTrace)
            : '';
        }
        function describeFiber(fiber, childFiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return describeBuiltInComponentFrame(fiber.type);
            case 16:
              return describeBuiltInComponentFrame('Lazy');
            case 13:
              return fiber.child !== childFiber && null !== childFiber
                ? describeBuiltInComponentFrame('Suspense Fallback')
                : describeBuiltInComponentFrame('Suspense');
            case 19:
              return describeBuiltInComponentFrame('SuspenseList');
            case 0:
            case 15:
              return describeNativeComponentFrame(fiber.type, !1);
            case 11:
              return describeNativeComponentFrame(fiber.type.render, !1);
            case 1:
              return describeNativeComponentFrame(fiber.type, !0);
            case 31:
              return describeBuiltInComponentFrame('Activity');
            default:
              return '';
          }
        }
        function getStackByFiberInDevAndProd(workInProgress) {
          try {
            var info = '',
              previous = null;
            do
              (info += describeFiber(workInProgress, previous)),
                (previous = workInProgress),
                (workInProgress = workInProgress.return);
            while (workInProgress);
            return info;
          } catch (x) {
            return '\nError generating stack: ' + x.message + '\n' + x.stack;
          }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty,
          scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
          cancelCallback$1 = Scheduler.unstable_cancelCallback,
          shouldYield = Scheduler.unstable_shouldYield,
          requestPaint = Scheduler.unstable_requestPaint,
          now = Scheduler.unstable_now,
          getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
          ImmediatePriority = Scheduler.unstable_ImmediatePriority,
          UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
          NormalPriority$1 = Scheduler.unstable_NormalPriority,
          LowPriority = Scheduler.unstable_LowPriority,
          IdlePriority = Scheduler.unstable_IdlePriority,
          log$1 = Scheduler.log,
          unstable_setDisableYieldValue =
            Scheduler.unstable_setDisableYieldValue,
          rendererID = null,
          injectedHook = null;
        function setIsStrictModeForDevtools(newIsStrictMode) {
          'function' === typeof log$1 &&
            unstable_setDisableYieldValue(newIsStrictMode);
          if (injectedHook && 'function' === typeof injectedHook.setStrictMode)
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {}
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
          log = Math.log,
          LN2 = Math.LN2;
        function clz32Fallback(x) {
          x >>>= 0;
          return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
        }
        var nextTransitionUpdateLane = 256,
          nextTransitionDeferredLane = 262144,
          nextRetryLane = 4194304;
        function getHighestPriorityLanes(lanes) {
          var pendingSyncLanes = lanes & 42;
          if (0 !== pendingSyncLanes) return pendingSyncLanes;
          switch (lanes & -lanes) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
              return 128;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
              return lanes & 261888;
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return lanes & 3932160;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return lanes & 62914560;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return lanes;
          }
        }
        function getNextLanes(root, wipLanes, rootHasPendingCommit) {
          var pendingLanes = root.pendingLanes;
          if (0 === pendingLanes) return 0;
          var nextLanes = 0,
            suspendedLanes = root.suspendedLanes,
            pingedLanes = root.pingedLanes;
          root = root.warmLanes;
          var nonIdlePendingLanes = pendingLanes & 134217727;
          0 !== nonIdlePendingLanes
            ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
              0 !== pendingLanes
                ? (nextLanes = getHighestPriorityLanes(pendingLanes))
                : ((pingedLanes &= nonIdlePendingLanes),
                  0 !== pingedLanes
                    ? (nextLanes = getHighestPriorityLanes(pingedLanes))
                    : rootHasPendingCommit ||
                      ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
                      0 !== rootHasPendingCommit &&
                        (nextLanes =
                          getHighestPriorityLanes(rootHasPendingCommit)))))
            : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
              0 !== nonIdlePendingLanes
                ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
                : 0 !== pingedLanes
                  ? (nextLanes = getHighestPriorityLanes(pingedLanes))
                  : rootHasPendingCommit ||
                    ((rootHasPendingCommit = pendingLanes & ~root),
                    0 !== rootHasPendingCommit &&
                      (nextLanes =
                        getHighestPriorityLanes(rootHasPendingCommit))));
          return 0 === nextLanes
            ? 0
            : 0 !== wipLanes &&
                wipLanes !== nextLanes &&
                0 === (wipLanes & suspendedLanes) &&
                ((suspendedLanes = nextLanes & -nextLanes),
                (rootHasPendingCommit = wipLanes & -wipLanes),
                suspendedLanes >= rootHasPendingCommit ||
                  (32 === suspendedLanes &&
                    0 !== (rootHasPendingCommit & 4194048)))
              ? wipLanes
              : nextLanes;
        }
        function checkIfRootIsPrerendering(root, renderLanes) {
          return (
            0 ===
            (root.pendingLanes &
              ~(root.suspendedLanes & ~root.pingedLanes) &
              renderLanes)
          );
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case 1:
            case 2:
            case 4:
            case 8:
            case 64:
              return currentTime + 250;
            case 16:
            case 32:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return currentTime + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return -1;
          }
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
          return lane;
        }
        function createLaneMap(initial) {
          for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
          return laneMap;
        }
        function markRootUpdated$1(root, updateLane) {
          root.pendingLanes |= updateLane;
          268435456 !== updateLane &&
            ((root.suspendedLanes = 0),
            (root.pingedLanes = 0),
            (root.warmLanes = 0));
        }
        function markRootFinished(
          root,
          finishedLanes,
          remainingLanes,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
        ) {
          var previouslyPendingLanes = root.pendingLanes;
          root.pendingLanes = remainingLanes;
          root.suspendedLanes = 0;
          root.pingedLanes = 0;
          root.warmLanes = 0;
          root.expiredLanes &= remainingLanes;
          root.entangledLanes &= remainingLanes;
          root.errorRecoveryDisabledLanes &= remainingLanes;
          root.shellSuspendCounter = 0;
          var entanglements = root.entanglements,
            expirationTimes = root.expirationTimes,
            hiddenUpdates = root.hiddenUpdates;
          for (
            remainingLanes = previouslyPendingLanes & ~remainingLanes;
            0 < remainingLanes;

          ) {
            var index$7 = 31 - clz32(remainingLanes),
              lane = 1 << index$7;
            entanglements[index$7] = 0;
            expirationTimes[index$7] = -1;
            var hiddenUpdatesForLane = hiddenUpdates[index$7];
            if (null !== hiddenUpdatesForLane)
              for (
                hiddenUpdates[index$7] = null, index$7 = 0;
                index$7 < hiddenUpdatesForLane.length;
                index$7++
              ) {
                var update = hiddenUpdatesForLane[index$7];
                null !== update && (update.lane &= -536870913);
              }
            remainingLanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
          0 !== suspendedRetryLanes &&
            0 === updatedLanes &&
            0 !== root.tag &&
            (root.suspendedLanes |=
              suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
        }
        function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
          root.pendingLanes |= spawnedLane;
          root.suspendedLanes &= ~spawnedLane;
          var spawnedLaneIndex = 31 - clz32(spawnedLane);
          root.entangledLanes |= spawnedLane;
          root.entanglements[spawnedLaneIndex] =
            root.entanglements[spawnedLaneIndex] |
            1073741824 |
            (entangledLanes & 261930);
        }
        function markRootEntangled(root, entangledLanes) {
          var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
          for (root = root.entanglements; rootEntangledLanes; ) {
            var index$8 = 31 - clz32(rootEntangledLanes),
              lane = 1 << index$8;
            (lane & entangledLanes) | (root[index$8] & entangledLanes) &&
              (root[index$8] |= entangledLanes);
            rootEntangledLanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root, renderLanes) {
          var renderLane = renderLanes & -renderLanes;
          renderLane =
            0 !== (renderLane & 42)
              ? 1
              : getBumpedLaneForHydrationByLane(renderLane);
          return 0 !== (renderLane & (root.suspendedLanes | renderLanes))
            ? 0
            : renderLane;
        }
        function getBumpedLaneForHydrationByLane(lane) {
          switch (lane) {
            case 2:
              lane = 1;
              break;
            case 8:
              lane = 4;
              break;
            case 32:
              lane = 16;
              break;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              lane = 128;
              break;
            case 268435456:
              lane = 134217728;
              break;
            default:
              lane = 0;
          }
          return lane;
        }
        function lanesToEventPriority(lanes) {
          lanes &= -lanes;
          return 2 < lanes
            ? 8 < lanes
              ? 0 !== (lanes & 134217727)
                ? 32
                : 268435456
              : 8
            : 2;
        }
        function resolveUpdatePriority() {
          var updatePriority = ReactDOMSharedInternals.p;
          if (0 !== updatePriority) return updatePriority;
          updatePriority = window.event;
          return void 0 === updatePriority
            ? 32
            : getEventPriority(updatePriority.type);
        }
        function runWithPriority(priority, fn) {
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            return (ReactDOMSharedInternals.p = priority), fn();
          } finally {
            ReactDOMSharedInternals.p = previousPriority;
          }
        }
        var randomKey = Math.random().toString(36).slice(2),
          internalInstanceKey = '__reactFiber$' + randomKey,
          internalPropsKey = '__reactProps$' + randomKey,
          internalContainerInstanceKey = '__reactContainer$' + randomKey,
          internalEventHandlersKey = '__reactEvents$' + randomKey,
          internalEventHandlerListenersKey = '__reactListeners$' + randomKey,
          internalEventHandlesSetKey = '__reactHandles$' + randomKey,
          internalRootNodeResourcesKey = '__reactResources$' + randomKey,
          internalHoistableMarker = '__reactMarker$' + randomKey;
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) return targetInst;
          for (var parentNode = targetNode.parentNode; parentNode; ) {
            if (
              (targetInst =
                parentNode[internalContainerInstanceKey] ||
                parentNode[internalInstanceKey])
            ) {
              parentNode = targetInst.alternate;
              if (
                null !== targetInst.child ||
                (null !== parentNode && null !== parentNode.child)
              )
                for (
                  targetNode = getParentHydrationBoundary(targetNode);
                  null !== targetNode;

                ) {
                  if ((parentNode = targetNode[internalInstanceKey]))
                    return parentNode;
                  targetNode = getParentHydrationBoundary(targetNode);
                }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          if (
            (node =
              node[internalInstanceKey] || node[internalContainerInstanceKey])
          ) {
            var tag = node.tag;
            if (
              5 === tag ||
              6 === tag ||
              13 === tag ||
              31 === tag ||
              26 === tag ||
              27 === tag ||
              3 === tag
            )
              return node;
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          var tag = inst.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
            return inst.stateNode;
          throw Error(formatProdErrorMessage(33));
        }
        function getResourcesFromRoot(root) {
          var resources = root[internalRootNodeResourcesKey];
          resources ||
            (resources = root[internalRootNodeResourcesKey] =
              { hoistableStyles: new Map(), hoistableScripts: new Map() });
          return resources;
        }
        function markNodeAsHoistable(node) {
          node[internalHoistableMarker] = !0;
        }
        var allNativeEvents = new Set(),
          registrationNameDependencies = {};
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + 'Capture', dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          registrationNameDependencies[registrationName] = dependencies;
          for (
            registrationName = 0;
            registrationName < dependencies.length;
            registrationName++
          )
            allNativeEvents.add(dependencies[registrationName]);
        }
        var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
            '^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$',
          ),
          illegalAttributeNameCache = {},
          validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
            return !0;
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
            return !1;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return (validatedAttributeNameCache[attributeName] = !0);
          illegalAttributeNameCache[attributeName] = !0;
          return !1;
        }
        function setValueForAttribute(node, name, value) {
          if (isAttributeNameSafe(name))
            if (null === value) node.removeAttribute(name);
            else {
              switch (typeof value) {
                case 'undefined':
                case 'function':
                case 'symbol':
                  node.removeAttribute(name);
                  return;
                case 'boolean':
                  var prefix$10 = name.toLowerCase().slice(0, 5);
                  if ('data-' !== prefix$10 && 'aria-' !== prefix$10) {
                    node.removeAttribute(name);
                    return;
                  }
              }
              node.setAttribute(name, '' + value);
            }
        }
        function setValueForKnownAttribute(node, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case 'undefined':
              case 'function':
              case 'symbol':
              case 'boolean':
                node.removeAttribute(name);
                return;
            }
            node.setAttribute(name, '' + value);
          }
        }
        function setValueForNamespacedAttribute(node, namespace, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case 'undefined':
              case 'function':
              case 'symbol':
              case 'boolean':
                node.removeAttribute(name);
                return;
            }
            node.setAttributeNS(namespace, name, '' + value);
          }
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case 'bigint':
            case 'boolean':
            case 'number':
            case 'string':
            case 'undefined':
              return value;
            case 'object':
              return value;
            default:
              return '';
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          return (
            (elem = elem.nodeName) &&
            'input' === elem.toLowerCase() &&
            ('checkbox' === type || 'radio' === type)
          );
        }
        function trackValueOnNode(node, valueField, currentValue) {
          var descriptor = Object.getOwnPropertyDescriptor(
            node.constructor.prototype,
            valueField,
          );
          if (
            !node.hasOwnProperty(valueField) &&
            'undefined' !== typeof descriptor &&
            'function' === typeof descriptor.get &&
            'function' === typeof descriptor.set
          ) {
            var get = descriptor.get,
              set = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: !0,
              get: function () {
                return get.call(this);
              },
              set: function (value) {
                currentValue = '' + value;
                set.call(this, value);
              },
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable,
            });
            return {
              getValue: function () {
                return currentValue;
              },
              setValue: function (value) {
                currentValue = '' + value;
              },
              stopTracking: function () {
                node._valueTracker = null;
                delete node[valueField];
              },
            };
          }
        }
        function track(node) {
          if (!node._valueTracker) {
            var valueField = isCheckable(node) ? 'checked' : 'value';
            node._valueTracker = trackValueOnNode(
              node,
              valueField,
              '' + node[valueField],
            );
          }
        }
        function updateValueIfChanged(node) {
          if (!node) return !1;
          var tracker = node._valueTracker;
          if (!tracker) return !0;
          var lastValue = tracker.getValue();
          var value = '';
          node &&
            (value = isCheckable(node)
              ? node.checked
                ? 'true'
                : 'false'
              : node.value);
          node = value;
          return node !== lastValue ? (tracker.setValue(node), !0) : !1;
        }
        function getActiveElement(doc) {
          doc = doc || ('undefined' !== typeof document ? document : void 0);
          if ('undefined' === typeof doc) return null;
          try {
            return doc.activeElement || doc.body;
          } catch (e) {
            return doc.body;
          }
        }
        var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
          return value.replace(
            escapeSelectorAttributeValueInsideDoubleQuotesRegex,
            function (ch) {
              return '\\' + ch.charCodeAt(0).toString(16) + ' ';
            },
          );
        }
        function updateInput(
          element,
          value,
          defaultValue,
          lastDefaultValue,
          checked,
          defaultChecked,
          type,
          name,
        ) {
          element.name = '';
          null != type &&
          'function' !== typeof type &&
          'symbol' !== typeof type &&
          'boolean' !== typeof type
            ? (element.type = type)
            : element.removeAttribute('type');
          if (null != value)
            if ('number' === type) {
              if (
                (0 === value && '' === element.value) ||
                element.value != value
              )
                element.value = '' + getToStringValue(value);
            } else
              element.value !== '' + getToStringValue(value) &&
                (element.value = '' + getToStringValue(value));
          else
            ('submit' !== type && 'reset' !== type) ||
              element.removeAttribute('value');
          null != value
            ? setDefaultValue(element, type, getToStringValue(value))
            : null != defaultValue
              ? setDefaultValue(element, type, getToStringValue(defaultValue))
              : null != lastDefaultValue && element.removeAttribute('value');
          null == checked &&
            null != defaultChecked &&
            (element.defaultChecked = !!defaultChecked);
          null != checked &&
            (element.checked =
              checked &&
              'function' !== typeof checked &&
              'symbol' !== typeof checked);
          null != name &&
          'function' !== typeof name &&
          'symbol' !== typeof name &&
          'boolean' !== typeof name
            ? (element.name = '' + getToStringValue(name))
            : element.removeAttribute('name');
        }
        function initInput(
          element,
          value,
          defaultValue,
          checked,
          defaultChecked,
          type,
          name,
          isHydrating,
        ) {
          null != type &&
            'function' !== typeof type &&
            'symbol' !== typeof type &&
            'boolean' !== typeof type &&
            (element.type = type);
          if (null != value || null != defaultValue) {
            if (
              !(
                ('submit' !== type && 'reset' !== type) ||
                (void 0 !== value && null !== value)
              )
            ) {
              track(element);
              return;
            }
            defaultValue =
              null != defaultValue ? '' + getToStringValue(defaultValue) : '';
            value = null != value ? '' + getToStringValue(value) : defaultValue;
            isHydrating || value === element.value || (element.value = value);
            element.defaultValue = value;
          }
          checked = null != checked ? checked : defaultChecked;
          checked =
            'function' !== typeof checked &&
            'symbol' !== typeof checked &&
            !!checked;
          element.checked = isHydrating ? element.checked : !!checked;
          element.defaultChecked = !!checked;
          null != name &&
            'function' !== typeof name &&
            'symbol' !== typeof name &&
            'boolean' !== typeof name &&
            (element.name = name);
          track(element);
        }
        function setDefaultValue(node, type, value) {
          ('number' === type &&
            getActiveElement(node.ownerDocument) === node) ||
            node.defaultValue === '' + value ||
            (node.defaultValue = '' + value);
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          node = node.options;
          if (multiple) {
            multiple = {};
            for (var i = 0; i < propValue.length; i++)
              multiple['$' + propValue[i]] = !0;
            for (propValue = 0; propValue < node.length; propValue++)
              (i = multiple.hasOwnProperty('$' + node[propValue].value)),
                node[propValue].selected !== i &&
                  (node[propValue].selected = i),
                i &&
                  setDefaultSelected &&
                  (node[propValue].defaultSelected = !0);
          } else {
            propValue = '' + getToStringValue(propValue);
            multiple = null;
            for (i = 0; i < node.length; i++) {
              if (node[i].value === propValue) {
                node[i].selected = !0;
                setDefaultSelected && (node[i].defaultSelected = !0);
                return;
              }
              null !== multiple || node[i].disabled || (multiple = node[i]);
            }
            null !== multiple && (multiple.selected = !0);
          }
        }
        function updateTextarea(element, value, defaultValue) {
          if (
            null != value &&
            ((value = '' + getToStringValue(value)),
            value !== element.value && (element.value = value),
            null == defaultValue)
          ) {
            element.defaultValue !== value && (element.defaultValue = value);
            return;
          }
          element.defaultValue =
            null != defaultValue ? '' + getToStringValue(defaultValue) : '';
        }
        function initTextarea(element, value, defaultValue, children) {
          if (null == value) {
            if (null != children) {
              if (null != defaultValue) throw Error(formatProdErrorMessage(92));
              if (isArrayImpl(children)) {
                if (1 < children.length)
                  throw Error(formatProdErrorMessage(93));
                children = children[0];
              }
              defaultValue = children;
            }
            null == defaultValue && (defaultValue = '');
            value = defaultValue;
          }
          defaultValue = getToStringValue(value);
          element.defaultValue = defaultValue;
          children = element.textContent;
          children === defaultValue &&
            '' !== children &&
            null !== children &&
            (element.value = children);
          track(element);
        }
        function setTextContent(node, text) {
          if (text) {
            var firstChild = node.firstChild;
            if (
              firstChild &&
              firstChild === node.lastChild &&
              3 === firstChild.nodeType
            ) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node.textContent = text;
        }
        var unitlessNumbers = new Set(
          'animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp'.split(
            ' ',
          ),
        );
        function setValueForStyle(style, styleName, value) {
          var isCustomProperty = 0 === styleName.indexOf('--');
          null == value || 'boolean' === typeof value || '' === value
            ? isCustomProperty
              ? style.setProperty(styleName, '')
              : 'float' === styleName
                ? (style.cssFloat = '')
                : (style[styleName] = '')
            : isCustomProperty
              ? style.setProperty(styleName, value)
              : 'number' !== typeof value ||
                  0 === value ||
                  unitlessNumbers.has(styleName)
                ? 'float' === styleName
                  ? (style.cssFloat = value)
                  : (style[styleName] = ('' + value).trim())
                : (style[styleName] = value + 'px');
        }
        function setValueForStyles(node, styles, prevStyles) {
          if (null != styles && 'object' !== typeof styles)
            throw Error(formatProdErrorMessage(62));
          node = node.style;
          if (null != prevStyles) {
            for (var styleName in prevStyles)
              !prevStyles.hasOwnProperty(styleName) ||
                (null != styles && styles.hasOwnProperty(styleName)) ||
                (0 === styleName.indexOf('--')
                  ? node.setProperty(styleName, '')
                  : 'float' === styleName
                    ? (node.cssFloat = '')
                    : (node[styleName] = ''));
            for (var styleName$16 in styles)
              (styleName = styles[styleName$16]),
                styles.hasOwnProperty(styleName$16) &&
                  prevStyles[styleName$16] !== styleName &&
                  setValueForStyle(node, styleName$16, styleName);
          } else
            for (var styleName$17 in styles)
              styles.hasOwnProperty(styleName$17) &&
                setValueForStyle(node, styleName$17, styles[styleName$17]);
        }
        function isCustomElement(tagName) {
          if (-1 === tagName.indexOf('-')) return !1;
          switch (tagName) {
            case 'annotation-xml':
            case 'color-profile':
            case 'font-face':
            case 'font-face-src':
            case 'font-face-uri':
            case 'font-face-format':
            case 'font-face-name':
            case 'missing-glyph':
              return !1;
            default:
              return !0;
          }
        }
        var aliases = new Map([
            ['acceptCharset', 'accept-charset'],
            ['htmlFor', 'for'],
            ['httpEquiv', 'http-equiv'],
            ['crossOrigin', 'crossorigin'],
            ['accentHeight', 'accent-height'],
            ['alignmentBaseline', 'alignment-baseline'],
            ['arabicForm', 'arabic-form'],
            ['baselineShift', 'baseline-shift'],
            ['capHeight', 'cap-height'],
            ['clipPath', 'clip-path'],
            ['clipRule', 'clip-rule'],
            ['colorInterpolation', 'color-interpolation'],
            ['colorInterpolationFilters', 'color-interpolation-filters'],
            ['colorProfile', 'color-profile'],
            ['colorRendering', 'color-rendering'],
            ['dominantBaseline', 'dominant-baseline'],
            ['enableBackground', 'enable-background'],
            ['fillOpacity', 'fill-opacity'],
            ['fillRule', 'fill-rule'],
            ['floodColor', 'flood-color'],
            ['floodOpacity', 'flood-opacity'],
            ['fontFamily', 'font-family'],
            ['fontSize', 'font-size'],
            ['fontSizeAdjust', 'font-size-adjust'],
            ['fontStretch', 'font-stretch'],
            ['fontStyle', 'font-style'],
            ['fontVariant', 'font-variant'],
            ['fontWeight', 'font-weight'],
            ['glyphName', 'glyph-name'],
            ['glyphOrientationHorizontal', 'glyph-orientation-horizontal'],
            ['glyphOrientationVertical', 'glyph-orientation-vertical'],
            ['horizAdvX', 'horiz-adv-x'],
            ['horizOriginX', 'horiz-origin-x'],
            ['imageRendering', 'image-rendering'],
            ['letterSpacing', 'letter-spacing'],
            ['lightingColor', 'lighting-color'],
            ['markerEnd', 'marker-end'],
            ['markerMid', 'marker-mid'],
            ['markerStart', 'marker-start'],
            ['overlinePosition', 'overline-position'],
            ['overlineThickness', 'overline-thickness'],
            ['paintOrder', 'paint-order'],
            ['panose-1', 'panose-1'],
            ['pointerEvents', 'pointer-events'],
            ['renderingIntent', 'rendering-intent'],
            ['shapeRendering', 'shape-rendering'],
            ['stopColor', 'stop-color'],
            ['stopOpacity', 'stop-opacity'],
            ['strikethroughPosition', 'strikethrough-position'],
            ['strikethroughThickness', 'strikethrough-thickness'],
            ['strokeDasharray', 'stroke-dasharray'],
            ['strokeDashoffset', 'stroke-dashoffset'],
            ['strokeLinecap', 'stroke-linecap'],
            ['strokeLinejoin', 'stroke-linejoin'],
            ['strokeMiterlimit', 'stroke-miterlimit'],
            ['strokeOpacity', 'stroke-opacity'],
            ['strokeWidth', 'stroke-width'],
            ['textAnchor', 'text-anchor'],
            ['textDecoration', 'text-decoration'],
            ['textRendering', 'text-rendering'],
            ['transformOrigin', 'transform-origin'],
            ['underlinePosition', 'underline-position'],
            ['underlineThickness', 'underline-thickness'],
            ['unicodeBidi', 'unicode-bidi'],
            ['unicodeRange', 'unicode-range'],
            ['unitsPerEm', 'units-per-em'],
            ['vAlphabetic', 'v-alphabetic'],
            ['vHanging', 'v-hanging'],
            ['vIdeographic', 'v-ideographic'],
            ['vMathematical', 'v-mathematical'],
            ['vectorEffect', 'vector-effect'],
            ['vertAdvY', 'vert-adv-y'],
            ['vertOriginX', 'vert-origin-x'],
            ['vertOriginY', 'vert-origin-y'],
            ['wordSpacing', 'word-spacing'],
            ['writingMode', 'writing-mode'],
            ['xmlnsXlink', 'xmlns:xlink'],
            ['xHeight', 'x-height'],
          ]),
          isJavaScriptProtocol =
            /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
        function sanitizeURL(url) {
          return isJavaScriptProtocol.test('' + url)
            ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
            : url;
        }
        function noop$1() {}
        var currentReplayingEvent = null;
        function getEventTarget(nativeEvent) {
          nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
          nativeEvent.correspondingUseElement &&
            (nativeEvent = nativeEvent.correspondingUseElement);
          return 3 === nativeEvent.nodeType
            ? nativeEvent.parentNode
            : nativeEvent;
        }
        var restoreTarget = null,
          restoreQueue = null;
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (internalInstance && (target = internalInstance.stateNode)) {
            var props = target[internalPropsKey] || null;
            a: switch (
              ((target = internalInstance.stateNode), internalInstance.type)
            ) {
              case 'input':
                updateInput(
                  target,
                  props.value,
                  props.defaultValue,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name,
                );
                internalInstance = props.name;
                if ('radio' === props.type && null != internalInstance) {
                  for (props = target; props.parentNode; )
                    props = props.parentNode;
                  props = props.querySelectorAll(
                    'input[name="' +
                      escapeSelectorAttributeValueInsideDoubleQuotes(
                        '' + internalInstance,
                      ) +
                      '"][type="radio"]',
                  );
                  for (
                    internalInstance = 0;
                    internalInstance < props.length;
                    internalInstance++
                  ) {
                    var otherNode = props[internalInstance];
                    if (
                      otherNode !== target &&
                      otherNode.form === target.form
                    ) {
                      var otherProps = otherNode[internalPropsKey] || null;
                      if (!otherProps) throw Error(formatProdErrorMessage(90));
                      updateInput(
                        otherNode,
                        otherProps.value,
                        otherProps.defaultValue,
                        otherProps.defaultValue,
                        otherProps.checked,
                        otherProps.defaultChecked,
                        otherProps.type,
                        otherProps.name,
                      );
                    }
                  }
                  for (
                    internalInstance = 0;
                    internalInstance < props.length;
                    internalInstance++
                  )
                    (otherNode = props[internalInstance]),
                      otherNode.form === target.form &&
                        updateValueIfChanged(otherNode);
                }
                break a;
              case 'textarea':
                updateTextarea(target, props.value, props.defaultValue);
                break a;
              case 'select':
                (internalInstance = props.value),
                  null != internalInstance &&
                    updateOptions(
                      target,
                      !!props.multiple,
                      internalInstance,
                      !1,
                    );
            }
          }
        }
        var isInsideEventHandler = !1;
        function batchedUpdates$1(fn, a, b) {
          if (isInsideEventHandler) return fn(a, b);
          isInsideEventHandler = !0;
          try {
            var JSCompiler_inline_result = fn(a);
            return JSCompiler_inline_result;
          } finally {
            if (
              ((isInsideEventHandler = !1),
              null !== restoreTarget || null !== restoreQueue)
            )
              if (
                (flushSyncWork$1(),
                restoreTarget &&
                  ((a = restoreTarget),
                  (fn = restoreQueue),
                  (restoreQueue = restoreTarget = null),
                  restoreStateOfTarget(a),
                  fn))
              )
                for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (null === stateNode) return null;
          var props = stateNode[internalPropsKey] || null;
          if (null === props) return null;
          stateNode = props[registrationName];
          a: switch (registrationName) {
            case 'onClick':
            case 'onClickCapture':
            case 'onDoubleClick':
            case 'onDoubleClickCapture':
            case 'onMouseDown':
            case 'onMouseDownCapture':
            case 'onMouseMove':
            case 'onMouseMoveCapture':
            case 'onMouseUp':
            case 'onMouseUpCapture':
            case 'onMouseEnter':
              (props = !props.disabled) ||
                ((inst = inst.type),
                (props = !(
                  'button' === inst ||
                  'input' === inst ||
                  'select' === inst ||
                  'textarea' === inst
                )));
              inst = !props;
              break a;
            default:
              inst = !1;
          }
          if (inst) return null;
          if (stateNode && 'function' !== typeof stateNode)
            throw Error(
              formatProdErrorMessage(231, registrationName, typeof stateNode),
            );
          return stateNode;
        }
        var canUseDOM = !(
            'undefined' === typeof window ||
            'undefined' === typeof window.document ||
            'undefined' === typeof window.document.createElement
          ),
          passiveBrowserEventsSupported = !1;
        if (canUseDOM)
          try {
            var options = {};
            Object.defineProperty(options, 'passive', {
              get: function () {
                passiveBrowserEventsSupported = !0;
              },
            });
            window.addEventListener('test', options, options);
            window.removeEventListener('test', options, options);
          } catch (e) {
            passiveBrowserEventsSupported = !1;
          }
        var root = null,
          startText = null,
          fallbackText = null;
        function getData() {
          if (fallbackText) return fallbackText;
          var start,
            startValue = startText,
            startLength = startValue.length,
            end,
            endValue = 'value' in root ? root.value : root.textContent,
            endLength = endValue.length;
          for (
            start = 0;
            start < startLength && startValue[start] === endValue[start];
            start++
          );
          var minEnd = startLength - start;
          for (
            end = 1;
            end <= minEnd &&
            startValue[startLength - end] === endValue[endLength - end];
            end++
          );
          return (fallbackText = endValue.slice(
            start,
            1 < end ? 1 - end : void 0,
          ));
        }
        function getEventCharCode(nativeEvent) {
          var keyCode = nativeEvent.keyCode;
          'charCode' in nativeEvent
            ? ((nativeEvent = nativeEvent.charCode),
              0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
            : (nativeEvent = keyCode);
          10 === nativeEvent && (nativeEvent = 13);
          return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
        }
        function functionThatReturnsTrue() {
          return !0;
        }
        function functionThatReturnsFalse() {
          return !1;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(
            reactName,
            reactEventType,
            targetInst,
            nativeEvent,
            nativeEventTarget,
          ) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var propName in Interface)
              Interface.hasOwnProperty(propName) &&
                ((reactName = Interface[propName]),
                (this[propName] = reactName
                  ? reactName(nativeEvent)
                  : nativeEvent[propName]));
            this.isDefaultPrevented = (
              null != nativeEvent.defaultPrevented
                ? nativeEvent.defaultPrevented
                : !1 === nativeEvent.returnValue
            )
              ? functionThatReturnsTrue
              : functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign(SyntheticBaseEvent.prototype, {
            preventDefault: function () {
              this.defaultPrevented = !0;
              var event = this.nativeEvent;
              event &&
                (event.preventDefault
                  ? event.preventDefault()
                  : 'unknown' !== typeof event.returnValue &&
                    (event.returnValue = !1),
                (this.isDefaultPrevented = functionThatReturnsTrue));
            },
            stopPropagation: function () {
              var event = this.nativeEvent;
              event &&
                (event.stopPropagation
                  ? event.stopPropagation()
                  : 'unknown' !== typeof event.cancelBubble &&
                    (event.cancelBubble = !0),
                (this.isPropagationStopped = functionThatReturnsTrue));
            },
            persist: function () {},
            isPersistent: functionThatReturnsTrue,
          });
          return SyntheticBaseEvent;
        }
        var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function (event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0,
          },
          SyntheticEvent = createSyntheticEvent(EventInterface),
          UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
          SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
          lastMovementX,
          lastMovementY,
          lastMouseEvent,
          MouseEventInterface = assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function (event) {
              return void 0 === event.relatedTarget
                ? event.fromElement === event.srcElement
                  ? event.toElement
                  : event.fromElement
                : event.relatedTarget;
            },
            movementX: function (event) {
              if ('movementX' in event) return event.movementX;
              event !== lastMouseEvent &&
                (lastMouseEvent && 'mousemove' === event.type
                  ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
                    (lastMovementY = event.screenY - lastMouseEvent.screenY))
                  : (lastMovementY = lastMovementX = 0),
                (lastMouseEvent = event));
              return lastMovementX;
            },
            movementY: function (event) {
              return 'movementY' in event ? event.movementY : lastMovementY;
            },
          }),
          SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
          DragEventInterface = assign({}, MouseEventInterface, {
            dataTransfer: 0,
          }),
          SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
          FocusEventInterface = assign({}, UIEventInterface, {
            relatedTarget: 0,
          }),
          SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
          AnimationEventInterface = assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0,
          }),
          SyntheticAnimationEvent = createSyntheticEvent(
            AnimationEventInterface,
          ),
          ClipboardEventInterface = assign({}, EventInterface, {
            clipboardData: function (event) {
              return 'clipboardData' in event
                ? event.clipboardData
                : window.clipboardData;
            },
          }),
          SyntheticClipboardEvent = createSyntheticEvent(
            ClipboardEventInterface,
          ),
          CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
          SyntheticCompositionEvent = createSyntheticEvent(
            CompositionEventInterface,
          ),
          normalizeKey = {
            Esc: 'Escape',
            Spacebar: ' ',
            Left: 'ArrowLeft',
            Up: 'ArrowUp',
            Right: 'ArrowRight',
            Down: 'ArrowDown',
            Del: 'Delete',
            Win: 'OS',
            Menu: 'ContextMenu',
            Apps: 'ContextMenu',
            Scroll: 'ScrollLock',
            MozPrintableKey: 'Unidentified',
          },
          translateToKey = {
            8: 'Backspace',
            9: 'Tab',
            12: 'Clear',
            13: 'Enter',
            16: 'Shift',
            17: 'Control',
            18: 'Alt',
            19: 'Pause',
            20: 'CapsLock',
            27: 'Escape',
            32: ' ',
            33: 'PageUp',
            34: 'PageDown',
            35: 'End',
            36: 'Home',
            37: 'ArrowLeft',
            38: 'ArrowUp',
            39: 'ArrowRight',
            40: 'ArrowDown',
            45: 'Insert',
            46: 'Delete',
            112: 'F1',
            113: 'F2',
            114: 'F3',
            115: 'F4',
            116: 'F5',
            117: 'F6',
            118: 'F7',
            119: 'F8',
            120: 'F9',
            121: 'F10',
            122: 'F11',
            123: 'F12',
            144: 'NumLock',
            145: 'ScrollLock',
            224: 'Meta',
          },
          modifierKeyToProp = {
            Alt: 'altKey',
            Control: 'ctrlKey',
            Meta: 'metaKey',
            Shift: 'shiftKey',
          };
        function modifierStateGetter(keyArg) {
          var nativeEvent = this.nativeEvent;
          return nativeEvent.getModifierState
            ? nativeEvent.getModifierState(keyArg)
            : (keyArg = modifierKeyToProp[keyArg])
              ? !!nativeEvent[keyArg]
              : !1;
        }
        function getEventModifierState() {
          return modifierStateGetter;
        }
        var KeyboardEventInterface = assign({}, UIEventInterface, {
            key: function (nativeEvent) {
              if (nativeEvent.key) {
                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                if ('Unidentified' !== key) return key;
              }
              return 'keypress' === nativeEvent.type
                ? ((nativeEvent = getEventCharCode(nativeEvent)),
                  13 === nativeEvent
                    ? 'Enter'
                    : String.fromCharCode(nativeEvent))
                : 'keydown' === nativeEvent.type || 'keyup' === nativeEvent.type
                  ? translateToKey[nativeEvent.keyCode] || 'Unidentified'
                  : '';
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            charCode: function (event) {
              return 'keypress' === event.type ? getEventCharCode(event) : 0;
            },
            keyCode: function (event) {
              return 'keydown' === event.type || 'keyup' === event.type
                ? event.keyCode
                : 0;
            },
            which: function (event) {
              return 'keypress' === event.type
                ? getEventCharCode(event)
                : 'keydown' === event.type || 'keyup' === event.type
                  ? event.keyCode
                  : 0;
            },
          }),
          SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
          PointerEventInterface = assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0,
          }),
          SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
          TouchEventInterface = assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState,
          }),
          SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
          TransitionEventInterface = assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0,
          }),
          SyntheticTransitionEvent = createSyntheticEvent(
            TransitionEventInterface,
          ),
          WheelEventInterface = assign({}, MouseEventInterface, {
            deltaX: function (event) {
              return 'deltaX' in event
                ? event.deltaX
                : 'wheelDeltaX' in event
                  ? -event.wheelDeltaX
                  : 0;
            },
            deltaY: function (event) {
              return 'deltaY' in event
                ? event.deltaY
                : 'wheelDeltaY' in event
                  ? -event.wheelDeltaY
                  : 'wheelDelta' in event
                    ? -event.wheelDelta
                    : 0;
            },
            deltaZ: 0,
            deltaMode: 0,
          }),
          SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
          ToggleEventInterface = assign({}, EventInterface, {
            newState: 0,
            oldState: 0,
          }),
          SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
          END_KEYCODES = [9, 13, 27, 32],
          canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window,
          documentMode = null;
        canUseDOM &&
          'documentMode' in document &&
          (documentMode = document.documentMode);
        var canUseTextInputEvent =
            canUseDOM && 'TextEvent' in window && !documentMode,
          useFallbackCompositionData =
            canUseDOM &&
            (!canUseCompositionEvent ||
              (documentMode && 8 < documentMode && 11 >= documentMode)),
          SPACEBAR_CHAR = String.fromCharCode(32),
          hasSpaceKeypress = !1;
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case 'keyup':
              return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case 'keydown':
              return 229 !== nativeEvent.keyCode;
            case 'keypress':
            case 'mousedown':
            case 'focusout':
              return !0;
            default:
              return !1;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          nativeEvent = nativeEvent.detail;
          return 'object' === typeof nativeEvent && 'data' in nativeEvent
            ? nativeEvent.data
            : null;
        }
        var isComposing = !1;
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case 'compositionend':
              return getDataFromCustomEvent(nativeEvent);
            case 'keypress':
              if (32 !== nativeEvent.which) return null;
              hasSpaceKeypress = !0;
              return SPACEBAR_CHAR;
            case 'textInput':
              return (
                (domEventName = nativeEvent.data),
                domEventName === SPACEBAR_CHAR && hasSpaceKeypress
                  ? null
                  : domEventName
              );
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing)
            return 'compositionend' === domEventName ||
              (!canUseCompositionEvent &&
                isFallbackCompositionEnd(domEventName, nativeEvent))
              ? ((domEventName = getData()),
                (fallbackText = startText = root = null),
                (isComposing = !1),
                domEventName)
              : null;
          switch (domEventName) {
            case 'paste':
              return null;
            case 'keypress':
              if (
                !(
                  nativeEvent.ctrlKey ||
                  nativeEvent.altKey ||
                  nativeEvent.metaKey
                ) ||
                (nativeEvent.ctrlKey && nativeEvent.altKey)
              ) {
                if (nativeEvent.char && 1 < nativeEvent.char.length)
                  return nativeEvent.char;
                if (nativeEvent.which)
                  return String.fromCharCode(nativeEvent.which);
              }
              return null;
            case 'compositionend':
              return useFallbackCompositionData && 'ko' !== nativeEvent.locale
                ? null
                : nativeEvent.data;
            default:
              return null;
          }
        }
        var supportedInputTypes = {
          color: !0,
          date: !0,
          datetime: !0,
          'datetime-local': !0,
          email: !0,
          month: !0,
          number: !0,
          password: !0,
          range: !0,
          search: !0,
          tel: !0,
          text: !0,
          time: !0,
          url: !0,
          week: !0,
        };
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return 'input' === nodeName
            ? !!supportedInputTypes[elem.type]
            : 'textarea' === nodeName
              ? !0
              : !1;
        }
        function createAndAccumulateChangeEvent(
          dispatchQueue,
          inst,
          nativeEvent,
          target,
        ) {
          restoreTarget
            ? restoreQueue
              ? restoreQueue.push(target)
              : (restoreQueue = [target])
            : (restoreTarget = target);
          inst = accumulateTwoPhaseListeners(inst, 'onChange');
          0 < inst.length &&
            ((nativeEvent = new SyntheticEvent(
              'onChange',
              'change',
              null,
              nativeEvent,
              target,
            )),
            dispatchQueue.push({ event: nativeEvent, listeners: inst }));
        }
        var activeElement$1 = null,
          activeElementInst$1 = null;
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) return targetInst;
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if ('change' === domEventName) return targetInst;
        }
        var isInputEventSupported = !1;
        if (canUseDOM) {
          var JSCompiler_inline_result$jscomp$286;
          if (canUseDOM) {
            var isSupported$jscomp$inline_427 = 'oninput' in document;
            if (!isSupported$jscomp$inline_427) {
              var element$jscomp$inline_428 = document.createElement('div');
              element$jscomp$inline_428.setAttribute('oninput', 'return;');
              isSupported$jscomp$inline_427 =
                'function' === typeof element$jscomp$inline_428.oninput;
            }
            JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
          } else JSCompiler_inline_result$jscomp$286 = !1;
          isInputEventSupported =
            JSCompiler_inline_result$jscomp$286 &&
            (!document.documentMode || 9 < document.documentMode);
        }
        function stopWatchingForValueChange() {
          activeElement$1 &&
            (activeElement$1.detachEvent(
              'onpropertychange',
              handlePropertyChange,
            ),
            (activeElementInst$1 = activeElement$1 = null));
        }
        function handlePropertyChange(nativeEvent) {
          if (
            'value' === nativeEvent.propertyName &&
            getInstIfValueChanged(activeElementInst$1)
          ) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(
              dispatchQueue,
              activeElementInst$1,
              nativeEvent,
              getEventTarget(nativeEvent),
            );
            batchedUpdates$1(runEventInBatch, dispatchQueue);
          }
        }
        function handleEventsForInputEventPolyfill(
          domEventName,
          target,
          targetInst,
        ) {
          'focusin' === domEventName
            ? (stopWatchingForValueChange(),
              (activeElement$1 = target),
              (activeElementInst$1 = targetInst),
              activeElement$1.attachEvent(
                'onpropertychange',
                handlePropertyChange,
              ))
            : 'focusout' === domEventName && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(domEventName) {
          if (
            'selectionchange' === domEventName ||
            'keyup' === domEventName ||
            'keydown' === domEventName
          )
            return getInstIfValueChanged(activeElementInst$1);
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if ('click' === domEventName)
            return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if ('input' === domEventName || 'change' === domEventName)
            return getInstIfValueChanged(targetInst);
        }
        function is(x, y) {
          return (
            (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y)
          );
        }
        var objectIs = 'function' === typeof Object.is ? Object.is : is;
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) return !0;
          if (
            'object' !== typeof objA ||
            null === objA ||
            'object' !== typeof objB ||
            null === objB
          )
            return !1;
          var keysA = Object.keys(objA),
            keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return !1;
          for (keysB = 0; keysB < keysA.length; keysB++) {
            var currentKey = keysA[keysB];
            if (
              !hasOwnProperty.call(objB, currentKey) ||
              !objectIs(objA[currentKey], objB[currentKey])
            )
              return !1;
          }
          return !0;
        }
        function getLeafNode(node) {
          for (; node && node.firstChild; ) node = node.firstChild;
          return node;
        }
        function getNodeForCharacterOffset(root, offset) {
          var node = getLeafNode(root);
          root = 0;
          for (var nodeEnd; node; ) {
            if (3 === node.nodeType) {
              nodeEnd = root + node.textContent.length;
              if (root <= offset && nodeEnd >= offset)
                return { node: node, offset: offset - root };
              root = nodeEnd;
            }
            a: {
              for (; node; ) {
                if (node.nextSibling) {
                  node = node.nextSibling;
                  break a;
                }
                node = node.parentNode;
              }
              node = void 0;
            }
            node = getLeafNode(node);
          }
        }
        function containsNode(outerNode, innerNode) {
          return outerNode && innerNode
            ? outerNode === innerNode
              ? !0
              : outerNode && 3 === outerNode.nodeType
                ? !1
                : innerNode && 3 === innerNode.nodeType
                  ? containsNode(outerNode, innerNode.parentNode)
                  : 'contains' in outerNode
                    ? outerNode.contains(innerNode)
                    : outerNode.compareDocumentPosition
                      ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
                      : !1
            : !1;
        }
        function getActiveElementDeep(containerInfo) {
          containerInfo =
            null != containerInfo &&
            null != containerInfo.ownerDocument &&
            null != containerInfo.ownerDocument.defaultView
              ? containerInfo.ownerDocument.defaultView
              : window;
          for (
            var element = getActiveElement(containerInfo.document);
            element instanceof containerInfo.HTMLIFrameElement;

          ) {
            try {
              var JSCompiler_inline_result =
                'string' === typeof element.contentWindow.location.href;
            } catch (err) {
              JSCompiler_inline_result = !1;
            }
            if (JSCompiler_inline_result) containerInfo = element.contentWindow;
            else break;
            element = getActiveElement(containerInfo.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return (
            nodeName &&
            (('input' === nodeName &&
              ('text' === elem.type ||
                'search' === elem.type ||
                'tel' === elem.type ||
                'url' === elem.type ||
                'password' === elem.type)) ||
              'textarea' === nodeName ||
              'true' === elem.contentEditable)
          );
        }
        var skipSelectionChangeEvent =
            canUseDOM &&
            'documentMode' in document &&
            11 >= document.documentMode,
          activeElement = null,
          activeElementInst = null,
          lastSelection = null,
          mouseDown = !1;
        function constructSelectEvent(
          dispatchQueue,
          nativeEvent,
          nativeEventTarget,
        ) {
          var doc =
            nativeEventTarget.window === nativeEventTarget
              ? nativeEventTarget.document
              : 9 === nativeEventTarget.nodeType
                ? nativeEventTarget
                : nativeEventTarget.ownerDocument;
          mouseDown ||
            null == activeElement ||
            activeElement !== getActiveElement(doc) ||
            ((doc = activeElement),
            'selectionStart' in doc && hasSelectionCapabilities(doc)
              ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
              : ((doc = (
                  (doc.ownerDocument && doc.ownerDocument.defaultView) ||
                  window
                ).getSelection()),
                (doc = {
                  anchorNode: doc.anchorNode,
                  anchorOffset: doc.anchorOffset,
                  focusNode: doc.focusNode,
                  focusOffset: doc.focusOffset,
                })),
            (lastSelection && shallowEqual(lastSelection, doc)) ||
              ((lastSelection = doc),
              (doc = accumulateTwoPhaseListeners(
                activeElementInst,
                'onSelect',
              )),
              0 < doc.length &&
                ((nativeEvent = new SyntheticEvent(
                  'onSelect',
                  'select',
                  null,
                  nativeEvent,
                  nativeEventTarget,
                )),
                dispatchQueue.push({ event: nativeEvent, listeners: doc }),
                (nativeEvent.target = activeElement))));
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes = {};
          prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes['Webkit' + styleProp] = 'webkit' + eventName;
          prefixes['Moz' + styleProp] = 'moz' + eventName;
          return prefixes;
        }
        var vendorPrefixes = {
            animationend: makePrefixMap('Animation', 'AnimationEnd'),
            animationiteration: makePrefixMap(
              'Animation',
              'AnimationIteration',
            ),
            animationstart: makePrefixMap('Animation', 'AnimationStart'),
            transitionrun: makePrefixMap('Transition', 'TransitionRun'),
            transitionstart: makePrefixMap('Transition', 'TransitionStart'),
            transitioncancel: makePrefixMap('Transition', 'TransitionCancel'),
            transitionend: makePrefixMap('Transition', 'TransitionEnd'),
          },
          prefixedEventNames = {},
          style = {};
        canUseDOM &&
          ((style = document.createElement('div').style),
          'AnimationEvent' in window ||
            (delete vendorPrefixes.animationend.animation,
            delete vendorPrefixes.animationiteration.animation,
            delete vendorPrefixes.animationstart.animation),
          'TransitionEvent' in window ||
            delete vendorPrefixes.transitionend.transition);
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName])
            return prefixedEventNames[eventName];
          if (!vendorPrefixes[eventName]) return eventName;
          var prefixMap = vendorPrefixes[eventName],
            styleProp;
          for (styleProp in prefixMap)
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
              return (prefixedEventNames[eventName] = prefixMap[styleProp]);
          return eventName;
        }
        var ANIMATION_END = getVendorPrefixedEventName('animationend'),
          ANIMATION_ITERATION =
            getVendorPrefixedEventName('animationiteration'),
          ANIMATION_START = getVendorPrefixedEventName('animationstart'),
          TRANSITION_RUN = getVendorPrefixedEventName('transitionrun'),
          TRANSITION_START = getVendorPrefixedEventName('transitionstart'),
          TRANSITION_CANCEL = getVendorPrefixedEventName('transitioncancel'),
          TRANSITION_END = getVendorPrefixedEventName('transitionend'),
          topLevelEventsToReactNames = new Map(),
          simpleEventPluginEvents =
            'abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
              ' ',
            );
        simpleEventPluginEvents.push('scrollEnd');
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        var reportGlobalError =
            'function' === typeof reportError
              ? reportError
              : function (error) {
                  if (
                    'object' === typeof window &&
                    'function' === typeof window.ErrorEvent
                  ) {
                    var event = new window.ErrorEvent('error', {
                      bubbles: !0,
                      cancelable: !0,
                      message:
                        'object' === typeof error &&
                        null !== error &&
                        'string' === typeof error.message
                          ? String(error.message)
                          : String(error),
                      error: error,
                    });
                    if (!window.dispatchEvent(event)) return;
                  } else if (
                    'object' === typeof process &&
                    'function' === typeof process.emit
                  ) {
                    process.emit('uncaughtException', error);
                    return;
                  }
                  console.error(error);
                },
          concurrentQueues = [],
          concurrentQueuesIndex = 0,
          concurrentlyUpdatedLanes = 0;
        function finishQueueingConcurrentUpdates() {
          for (
            var endIndex = concurrentQueuesIndex,
              i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
            i < endIndex;

          ) {
            var fiber = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var queue = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var update = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var lane = concurrentQueues[i];
            concurrentQueues[i++] = null;
            if (null !== queue && null !== update) {
              var pending = queue.pending;
              null === pending
                ? (update.next = update)
                : ((update.next = pending.next), (pending.next = update));
              queue.pending = update;
            }
            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
          }
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
          concurrentQueues[concurrentQueuesIndex++] = fiber;
          concurrentQueues[concurrentQueuesIndex++] = queue;
          concurrentQueues[concurrentQueuesIndex++] = update;
          concurrentQueues[concurrentQueuesIndex++] = lane;
          concurrentlyUpdatedLanes |= lane;
          fiber.lanes |= lane;
          fiber = fiber.alternate;
          null !== fiber && (fiber.lanes |= lane);
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          enqueueUpdate$1(fiber, queue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          enqueueUpdate$1(fiber, null, null, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
          sourceFiber.lanes |= lane;
          var alternate = sourceFiber.alternate;
          null !== alternate && (alternate.lanes |= lane);
          for (
            var isHidden = !1, parent = sourceFiber.return;
            null !== parent;

          )
            (parent.childLanes |= lane),
              (alternate = parent.alternate),
              null !== alternate && (alternate.childLanes |= lane),
              22 === parent.tag &&
                ((sourceFiber = parent.stateNode),
                null === sourceFiber ||
                  sourceFiber._visibility & 1 ||
                  (isHidden = !0)),
              (sourceFiber = parent),
              (parent = parent.return);
          return 3 === sourceFiber.tag
            ? ((parent = sourceFiber.stateNode),
              isHidden &&
                null !== update &&
                ((isHidden = 31 - clz32(lane)),
                (sourceFiber = parent.hiddenUpdates),
                (alternate = sourceFiber[isHidden]),
                null === alternate
                  ? (sourceFiber[isHidden] = [update])
                  : alternate.push(update),
                (update.lane = lane | 536870912)),
              parent)
            : null;
        }
        function getRootForUpdatedFiber(sourceFiber) {
          if (50 < nestedUpdateCount)
            throw (
              ((nestedUpdateCount = 0),
              (rootWithNestedUpdates = null),
              Error(formatProdErrorMessage(185)))
            );
          for (var parent = sourceFiber.return; null !== parent; )
            (sourceFiber = parent), (parent = sourceFiber.return);
          return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
        }
        var emptyContextObject = {};
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.sibling =
            this.child =
            this.return =
            this.stateNode =
            this.type =
            this.elementType =
              null;
          this.index = 0;
          this.refCleanup = this.ref = null;
          this.pendingProps = pendingProps;
          this.dependencies =
            this.memoizedState =
            this.updateQueue =
            this.memoizedProps =
              null;
          this.mode = mode;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
        }
        function createFiberImplClass(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        }
        function shouldConstruct(Component) {
          Component = Component.prototype;
          return !(!Component || !Component.isReactComponent);
        }
        function createWorkInProgress(current, pendingProps) {
          var workInProgress = current.alternate;
          null === workInProgress
            ? ((workInProgress = createFiberImplClass(
                current.tag,
                pendingProps,
                current.key,
                current.mode,
              )),
              (workInProgress.elementType = current.elementType),
              (workInProgress.type = current.type),
              (workInProgress.stateNode = current.stateNode),
              (workInProgress.alternate = current),
              (current.alternate = workInProgress))
            : ((workInProgress.pendingProps = pendingProps),
              (workInProgress.type = current.type),
              (workInProgress.flags = 0),
              (workInProgress.subtreeFlags = 0),
              (workInProgress.deletions = null));
          workInProgress.flags = current.flags & 65011712;
          workInProgress.childLanes = current.childLanes;
          workInProgress.lanes = current.lanes;
          workInProgress.child = current.child;
          workInProgress.memoizedProps = current.memoizedProps;
          workInProgress.memoizedState = current.memoizedState;
          workInProgress.updateQueue = current.updateQueue;
          pendingProps = current.dependencies;
          workInProgress.dependencies =
            null === pendingProps
              ? null
              : {
                  lanes: pendingProps.lanes,
                  firstContext: pendingProps.firstContext,
                };
          workInProgress.sibling = current.sibling;
          workInProgress.index = current.index;
          workInProgress.ref = current.ref;
          workInProgress.refCleanup = current.refCleanup;
          return workInProgress;
        }
        function resetWorkInProgress(workInProgress, renderLanes) {
          workInProgress.flags &= 65011714;
          var current = workInProgress.alternate;
          null === current
            ? ((workInProgress.childLanes = 0),
              (workInProgress.lanes = renderLanes),
              (workInProgress.child = null),
              (workInProgress.subtreeFlags = 0),
              (workInProgress.memoizedProps = null),
              (workInProgress.memoizedState = null),
              (workInProgress.updateQueue = null),
              (workInProgress.dependencies = null),
              (workInProgress.stateNode = null))
            : ((workInProgress.childLanes = current.childLanes),
              (workInProgress.lanes = current.lanes),
              (workInProgress.child = current.child),
              (workInProgress.subtreeFlags = 0),
              (workInProgress.deletions = null),
              (workInProgress.memoizedProps = current.memoizedProps),
              (workInProgress.memoizedState = current.memoizedState),
              (workInProgress.updateQueue = current.updateQueue),
              (workInProgress.type = current.type),
              (renderLanes = current.dependencies),
              (workInProgress.dependencies =
                null === renderLanes
                  ? null
                  : {
                      lanes: renderLanes.lanes,
                      firstContext: renderLanes.firstContext,
                    }));
          return workInProgress;
        }
        function createFiberFromTypeAndProps(
          type,
          key,
          pendingProps,
          owner,
          mode,
          lanes,
        ) {
          var fiberTag = 0;
          owner = type;
          if ('function' === typeof type)
            shouldConstruct(type) && (fiberTag = 1);
          else if ('string' === typeof type)
            fiberTag = isHostHoistableType(
              type,
              pendingProps,
              contextStackCursor.current,
            )
              ? 26
              : 'html' === type || 'head' === type || 'body' === type
                ? 27
                : 5;
          else
            a: switch (type) {
              case REACT_ACTIVITY_TYPE:
                return (
                  (type = createFiberImplClass(31, pendingProps, key, mode)),
                  (type.elementType = REACT_ACTIVITY_TYPE),
                  (type.lanes = lanes),
                  type
                );
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(
                  pendingProps.children,
                  mode,
                  lanes,
                  key,
                );
              case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= 24;
                break;
              case REACT_PROFILER_TYPE:
                return (
                  (type = createFiberImplClass(
                    12,
                    pendingProps,
                    key,
                    mode | 2,
                  )),
                  (type.elementType = REACT_PROFILER_TYPE),
                  (type.lanes = lanes),
                  type
                );
              case REACT_SUSPENSE_TYPE:
                return (
                  (type = createFiberImplClass(13, pendingProps, key, mode)),
                  (type.elementType = REACT_SUSPENSE_TYPE),
                  (type.lanes = lanes),
                  type
                );
              case REACT_SUSPENSE_LIST_TYPE:
                return (
                  (type = createFiberImplClass(19, pendingProps, key, mode)),
                  (type.elementType = REACT_SUSPENSE_LIST_TYPE),
                  (type.lanes = lanes),
                  type
                );
              default:
                if ('object' === typeof type && null !== type)
                  switch (type.$$typeof) {
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 10;
                      break a;
                    case REACT_CONSUMER_TYPE:
                      fiberTag = 9;
                      break a;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = 11;
                      break a;
                    case REACT_MEMO_TYPE:
                      fiberTag = 14;
                      break a;
                    case REACT_LAZY_TYPE:
                      fiberTag = 16;
                      owner = null;
                      break a;
                  }
                fiberTag = 29;
                pendingProps = Error(
                  formatProdErrorMessage(
                    130,
                    null === type ? 'null' : typeof type,
                    '',
                  ),
                );
                owner = null;
            }
          key = createFiberImplClass(fiberTag, pendingProps, key, mode);
          key.elementType = type;
          key.type = owner;
          key.lanes = lanes;
          return key;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          elements = createFiberImplClass(7, elements, key, mode);
          elements.lanes = lanes;
          return elements;
        }
        function createFiberFromText(content, mode, lanes) {
          content = createFiberImplClass(6, content, null, mode);
          content.lanes = lanes;
          return content;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiberImplClass(18, null, null, 0);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          mode = createFiberImplClass(
            4,
            null !== portal.children ? portal.children : [],
            portal.key,
            mode,
          );
          mode.lanes = lanes;
          mode.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation,
          };
          return mode;
        }
        var CapturedStacks = new WeakMap();
        function createCapturedValueAtFiber(value, source) {
          if ('object' === typeof value && null !== value) {
            var existing = CapturedStacks.get(value);
            if (void 0 !== existing) return existing;
            source = {
              value: value,
              source: source,
              stack: getStackByFiberInDevAndProd(source),
            };
            CapturedStacks.set(value, source);
            return source;
          }
          return {
            value: value,
            source: source,
            stack: getStackByFiberInDevAndProd(source),
          };
        }
        var forkStack = [],
          forkStackIndex = 0,
          treeForkProvider = null,
          treeForkCount = 0,
          idStack = [],
          idStackIndex = 0,
          treeContextProvider = null,
          treeContextId = 1,
          treeContextOverflow = '';
        function pushTreeFork(workInProgress, totalChildren) {
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress, totalChildren, index) {
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress;
          var baseIdWithLeadingBit = treeContextId;
          workInProgress = treeContextOverflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index += 1;
          var length = 32 - clz32(totalChildren) + baseLength;
          if (30 < length) {
            var numberOfOverflowBits = baseLength - (baseLength % 5);
            length = (
              baseIdWithLeadingBit &
              ((1 << numberOfOverflowBits) - 1)
            ).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            treeContextId =
              (1 << (32 - clz32(totalChildren) + baseLength)) |
              (index << baseLength) |
              baseIdWithLeadingBit;
            treeContextOverflow = length + workInProgress;
          } else
            (treeContextId =
              (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
              (treeContextOverflow = workInProgress);
        }
        function pushMaterializedTreeId(workInProgress) {
          null !== workInProgress.return &&
            (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
        }
        function popTreeContext(workInProgress) {
          for (; workInProgress === treeForkProvider; )
            (treeForkProvider = forkStack[--forkStackIndex]),
              (forkStack[forkStackIndex] = null),
              (treeForkCount = forkStack[--forkStackIndex]),
              (forkStack[forkStackIndex] = null);
          for (; workInProgress === treeContextProvider; )
            (treeContextProvider = idStack[--idStackIndex]),
              (idStack[idStackIndex] = null),
              (treeContextOverflow = idStack[--idStackIndex]),
              (idStack[idStackIndex] = null),
              (treeContextId = idStack[--idStackIndex]),
              (idStack[idStackIndex] = null);
        }
        function restoreSuspendedTreeContext(workInProgress, suspendedContext) {
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress;
        }
        var hydrationParentFiber = null,
          nextHydratableInstance = null,
          isHydrating = !1,
          hydrationErrors = null,
          rootOrSingletonContext = !1,
          HydrationMismatchException = Error(formatProdErrorMessage(519));
        function throwOnHydrationMismatch(fiber) {
          var error = Error(
            formatProdErrorMessage(
              418,
              1 < arguments.length && void 0 !== arguments[1] && arguments[1]
                ? 'text'
                : 'HTML',
              '',
            ),
          );
          queueHydrationError(createCapturedValueAtFiber(error, fiber));
          throw HydrationMismatchException;
        }
        function prepareToHydrateHostInstance(fiber) {
          var instance = fiber.stateNode,
            type = fiber.type,
            props = fiber.memoizedProps;
          instance[internalInstanceKey] = fiber;
          instance[internalPropsKey] = props;
          switch (type) {
            case 'dialog':
              listenToNonDelegatedEvent('cancel', instance);
              listenToNonDelegatedEvent('close', instance);
              break;
            case 'iframe':
            case 'object':
            case 'embed':
              listenToNonDelegatedEvent('load', instance);
              break;
            case 'video':
            case 'audio':
              for (type = 0; type < mediaEventTypes.length; type++)
                listenToNonDelegatedEvent(mediaEventTypes[type], instance);
              break;
            case 'source':
              listenToNonDelegatedEvent('error', instance);
              break;
            case 'img':
            case 'image':
            case 'link':
              listenToNonDelegatedEvent('error', instance);
              listenToNonDelegatedEvent('load', instance);
              break;
            case 'details':
              listenToNonDelegatedEvent('toggle', instance);
              break;
            case 'input':
              listenToNonDelegatedEvent('invalid', instance);
              initInput(
                instance,
                props.value,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name,
                !0,
              );
              break;
            case 'select':
              listenToNonDelegatedEvent('invalid', instance);
              break;
            case 'textarea':
              listenToNonDelegatedEvent('invalid', instance),
                initTextarea(
                  instance,
                  props.value,
                  props.defaultValue,
                  props.children,
                );
          }
          type = props.children;
          ('string' !== typeof type &&
            'number' !== typeof type &&
            'bigint' !== typeof type) ||
          instance.textContent === '' + type ||
          !0 === props.suppressHydrationWarning ||
          checkForUnmatchedText(instance.textContent, type)
            ? (null != props.popover &&
                (listenToNonDelegatedEvent('beforetoggle', instance),
                listenToNonDelegatedEvent('toggle', instance)),
              null != props.onScroll &&
                listenToNonDelegatedEvent('scroll', instance),
              null != props.onScrollEnd &&
                listenToNonDelegatedEvent('scrollend', instance),
              null != props.onClick && (instance.onclick = noop$1),
              (instance = !0))
            : (instance = !1);
          instance || throwOnHydrationMismatch(fiber, !0);
        }
        function popToNextHostParent(fiber) {
          for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
            switch (hydrationParentFiber.tag) {
              case 5:
              case 31:
              case 13:
                rootOrSingletonContext = !1;
                return;
              case 27:
              case 3:
                rootOrSingletonContext = !0;
                return;
              default:
                hydrationParentFiber = hydrationParentFiber.return;
            }
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) return !1;
          if (!isHydrating)
            return popToNextHostParent(fiber), (isHydrating = !0), !1;
          var tag = fiber.tag,
            JSCompiler_temp;
          if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
            if ((JSCompiler_temp = 5 === tag))
              (JSCompiler_temp = fiber.type),
                (JSCompiler_temp =
                  !(
                    'form' !== JSCompiler_temp && 'button' !== JSCompiler_temp
                  ) || shouldSetTextContent(fiber.type, fiber.memoizedProps));
            JSCompiler_temp = !JSCompiler_temp;
          }
          JSCompiler_temp &&
            nextHydratableInstance &&
            throwOnHydrationMismatch(fiber);
          popToNextHostParent(fiber);
          if (13 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber) throw Error(formatProdErrorMessage(317));
            nextHydratableInstance =
              getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else if (31 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber) throw Error(formatProdErrorMessage(317));
            nextHydratableInstance =
              getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else
            27 === tag
              ? ((tag = nextHydratableInstance),
                isSingletonScope(fiber.type)
                  ? ((fiber = previousHydratableOnEnteringScopedSingleton),
                    (previousHydratableOnEnteringScopedSingleton = null),
                    (nextHydratableInstance = fiber))
                  : (nextHydratableInstance = tag))
              : (nextHydratableInstance = hydrationParentFiber
                  ? getNextHydratable(fiber.stateNode.nextSibling)
                  : null);
          return !0;
        }
        function resetHydrationState() {
          nextHydratableInstance = hydrationParentFiber = null;
          isHydrating = !1;
        }
        function upgradeHydrationErrorsToRecoverable() {
          var queuedErrors = hydrationErrors;
          null !== queuedErrors &&
            (null === workInProgressRootRecoverableErrors
              ? (workInProgressRootRecoverableErrors = queuedErrors)
              : workInProgressRootRecoverableErrors.push.apply(
                  workInProgressRootRecoverableErrors,
                  queuedErrors,
                ),
            (hydrationErrors = null));
          return queuedErrors;
        }
        function queueHydrationError(error) {
          null === hydrationErrors
            ? (hydrationErrors = [error])
            : hydrationErrors.push(error);
        }
        var valueCursor = createCursor(null),
          currentlyRenderingFiber$1 = null,
          lastContextDependency = null;
        function pushProvider(providerFiber, context, nextValue) {
          push(valueCursor, context._currentValue);
          context._currentValue = nextValue;
        }
        function popProvider(context) {
          context._currentValue = valueCursor.current;
          pop(valueCursor);
        }
        function scheduleContextWorkOnParentPath(
          parent,
          renderLanes,
          propagationRoot,
        ) {
          for (; null !== parent; ) {
            var alternate = parent.alternate;
            (parent.childLanes & renderLanes) !== renderLanes
              ? ((parent.childLanes |= renderLanes),
                null !== alternate && (alternate.childLanes |= renderLanes))
              : null !== alternate &&
                (alternate.childLanes & renderLanes) !== renderLanes &&
                (alternate.childLanes |= renderLanes);
            if (parent === propagationRoot) break;
            parent = parent.return;
          }
        }
        function propagateContextChanges(
          workInProgress,
          contexts,
          renderLanes,
          forcePropagateEntireTree,
        ) {
          var fiber = workInProgress.child;
          null !== fiber && (fiber.return = workInProgress);
          for (; null !== fiber; ) {
            var list = fiber.dependencies;
            if (null !== list) {
              var nextFiber = fiber.child;
              list = list.firstContext;
              a: for (; null !== list; ) {
                var dependency = list;
                list = fiber;
                for (var i = 0; i < contexts.length; i++)
                  if (dependency.context === contexts[i]) {
                    list.lanes |= renderLanes;
                    dependency = list.alternate;
                    null !== dependency && (dependency.lanes |= renderLanes);
                    scheduleContextWorkOnParentPath(
                      list.return,
                      renderLanes,
                      workInProgress,
                    );
                    forcePropagateEntireTree || (nextFiber = null);
                    break a;
                  }
                list = dependency.next;
              }
            } else if (18 === fiber.tag) {
              nextFiber = fiber.return;
              if (null === nextFiber) throw Error(formatProdErrorMessage(341));
              nextFiber.lanes |= renderLanes;
              list = nextFiber.alternate;
              null !== list && (list.lanes |= renderLanes);
              scheduleContextWorkOnParentPath(
                nextFiber,
                renderLanes,
                workInProgress,
              );
              nextFiber = null;
            } else nextFiber = fiber.child;
            if (null !== nextFiber) nextFiber.return = fiber;
            else
              for (nextFiber = fiber; null !== nextFiber; ) {
                if (nextFiber === workInProgress) {
                  nextFiber = null;
                  break;
                }
                fiber = nextFiber.sibling;
                if (null !== fiber) {
                  fiber.return = nextFiber.return;
                  nextFiber = fiber;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            fiber = nextFiber;
          }
        }
        function propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          forcePropagateEntireTree,
        ) {
          current = null;
          for (
            var parent = workInProgress, isInsidePropagationBailout = !1;
            null !== parent;

          ) {
            if (!isInsidePropagationBailout)
              if (0 !== (parent.flags & 524288))
                isInsidePropagationBailout = !0;
              else if (0 !== (parent.flags & 262144)) break;
            if (10 === parent.tag) {
              var currentParent = parent.alternate;
              if (null === currentParent)
                throw Error(formatProdErrorMessage(387));
              currentParent = currentParent.memoizedProps;
              if (null !== currentParent) {
                var context = parent.type;
                objectIs(parent.pendingProps.value, currentParent.value) ||
                  (null !== current
                    ? current.push(context)
                    : (current = [context]));
              }
            } else if (parent === hostTransitionProviderCursor.current) {
              currentParent = parent.alternate;
              if (null === currentParent)
                throw Error(formatProdErrorMessage(387));
              currentParent.memoizedState.memoizedState !==
                parent.memoizedState.memoizedState &&
                (null !== current
                  ? current.push(HostTransitionContext)
                  : (current = [HostTransitionContext]));
            }
            parent = parent.return;
          }
          null !== current &&
            propagateContextChanges(
              workInProgress,
              current,
              renderLanes,
              forcePropagateEntireTree,
            );
          workInProgress.flags |= 262144;
        }
        function checkIfContextChanged(currentDependencies) {
          for (
            currentDependencies = currentDependencies.firstContext;
            null !== currentDependencies;

          ) {
            if (
              !objectIs(
                currentDependencies.context._currentValue,
                currentDependencies.memoizedValue,
              )
            )
              return !0;
            currentDependencies = currentDependencies.next;
          }
          return !1;
        }
        function prepareToReadContext(workInProgress) {
          currentlyRenderingFiber$1 = workInProgress;
          lastContextDependency = null;
          workInProgress = workInProgress.dependencies;
          null !== workInProgress && (workInProgress.firstContext = null);
        }
        function readContext(context) {
          return readContextForConsumer(currentlyRenderingFiber$1, context);
        }
        function readContextDuringReconciliation(consumer, context) {
          null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
          return readContextForConsumer(consumer, context);
        }
        function readContextForConsumer(consumer, context) {
          var value = context._currentValue;
          context = { context: context, memoizedValue: value, next: null };
          if (null === lastContextDependency) {
            if (null === consumer) throw Error(formatProdErrorMessage(308));
            lastContextDependency = context;
            consumer.dependencies = { lanes: 0, firstContext: context };
            consumer.flags |= 524288;
          } else lastContextDependency = lastContextDependency.next = context;
          return value;
        }
        var AbortControllerLocal =
            'undefined' !== typeof AbortController
              ? AbortController
              : function () {
                  var listeners = [],
                    signal = (this.signal = {
                      aborted: !1,
                      addEventListener: function (type, listener) {
                        listeners.push(listener);
                      },
                    });
                  this.abort = function () {
                    signal.aborted = !0;
                    listeners.forEach(function (listener) {
                      return listener();
                    });
                  };
                },
          scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
          NormalPriority = Scheduler.unstable_NormalPriority,
          CacheContext = {
            $$typeof: REACT_CONTEXT_TYPE,
            Consumer: null,
            Provider: null,
            _currentValue: null,
            _currentValue2: null,
            _threadCount: 0,
          };
        function createCache() {
          return {
            controller: new AbortControllerLocal(),
            data: new Map(),
            refCount: 0,
          };
        }
        function releaseCache(cache) {
          cache.refCount--;
          0 === cache.refCount &&
            scheduleCallback$2(NormalPriority, function () {
              cache.controller.abort();
            });
        }
        var currentEntangledListeners = null,
          currentEntangledPendingCount = 0,
          currentEntangledLane = 0,
          currentEntangledActionThenable = null;
        function entangleAsyncAction(transition, thenable) {
          if (null === currentEntangledListeners) {
            var entangledListeners = (currentEntangledListeners = []);
            currentEntangledPendingCount = 0;
            currentEntangledLane = requestTransitionLane();
            currentEntangledActionThenable = {
              status: 'pending',
              value: void 0,
              then: function (resolve) {
                entangledListeners.push(resolve);
              },
            };
          }
          currentEntangledPendingCount++;
          thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
          return thenable;
        }
        function pingEngtangledActionScope() {
          if (
            0 === --currentEntangledPendingCount &&
            null !== currentEntangledListeners
          ) {
            null !== currentEntangledActionThenable &&
              (currentEntangledActionThenable.status = 'fulfilled');
            var listeners = currentEntangledListeners;
            currentEntangledListeners = null;
            currentEntangledLane = 0;
            currentEntangledActionThenable = null;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
          }
        }
        function chainThenableValue(thenable, result) {
          var listeners = [],
            thenableWithOverride = {
              status: 'pending',
              value: null,
              reason: null,
              then: function (resolve) {
                listeners.push(resolve);
              },
            };
          thenable.then(
            function () {
              thenableWithOverride.status = 'fulfilled';
              thenableWithOverride.value = result;
              for (var i = 0; i < listeners.length; i++)
                (0, listeners[i])(result);
            },
            function (error) {
              thenableWithOverride.status = 'rejected';
              thenableWithOverride.reason = error;
              for (error = 0; error < listeners.length; error++)
                (0, listeners[error])(void 0);
            },
          );
          return thenableWithOverride;
        }
        var prevOnStartTransitionFinish = ReactSharedInternals.S;
        ReactSharedInternals.S = function (transition, returnValue) {
          globalMostRecentTransitionTime = now();
          'object' === typeof returnValue &&
            null !== returnValue &&
            'function' === typeof returnValue.then &&
            entangleAsyncAction(transition, returnValue);
          null !== prevOnStartTransitionFinish &&
            prevOnStartTransitionFinish(transition, returnValue);
        };
        var resumedCache = createCursor(null);
        function peekCacheFromPool() {
          var cacheResumedFromPreviousRender = resumedCache.current;
          return null !== cacheResumedFromPreviousRender
            ? cacheResumedFromPreviousRender
            : workInProgressRoot.pooledCache;
        }
        function pushTransition(offscreenWorkInProgress, prevCachePool) {
          null === prevCachePool
            ? push(resumedCache, resumedCache.current)
            : push(resumedCache, prevCachePool.pool);
        }
        function getSuspendedCache() {
          var cacheFromPool = peekCacheFromPool();
          return null === cacheFromPool
            ? null
            : { parent: CacheContext._currentValue, pool: cacheFromPool };
        }
        var SuspenseException = Error(formatProdErrorMessage(460)),
          SuspenseyCommitException = Error(formatProdErrorMessage(474)),
          SuspenseActionException = Error(formatProdErrorMessage(542)),
          noopSuspenseyCommitThenable = { then: function () {} };
        function isThenableResolved(thenable) {
          thenable = thenable.status;
          return 'fulfilled' === thenable || 'rejected' === thenable;
        }
        function trackUsedThenable(thenableState, thenable, index) {
          index = thenableState[index];
          void 0 === index
            ? thenableState.push(thenable)
            : index !== thenable &&
              (thenable.then(noop$1, noop$1), (thenable = index));
          switch (thenable.status) {
            case 'fulfilled':
              return thenable.value;
            case 'rejected':
              throw (
                ((thenableState = thenable.reason),
                checkIfUseWrappedInAsyncCatch(thenableState),
                thenableState)
              );
            default:
              if ('string' === typeof thenable.status)
                thenable.then(noop$1, noop$1);
              else {
                thenableState = workInProgressRoot;
                if (
                  null !== thenableState &&
                  100 < thenableState.shellSuspendCounter
                )
                  throw Error(formatProdErrorMessage(482));
                thenableState = thenable;
                thenableState.status = 'pending';
                thenableState.then(
                  function (fulfilledValue) {
                    if ('pending' === thenable.status) {
                      var fulfilledThenable = thenable;
                      fulfilledThenable.status = 'fulfilled';
                      fulfilledThenable.value = fulfilledValue;
                    }
                  },
                  function (error) {
                    if ('pending' === thenable.status) {
                      var rejectedThenable = thenable;
                      rejectedThenable.status = 'rejected';
                      rejectedThenable.reason = error;
                    }
                  },
                );
              }
              switch (thenable.status) {
                case 'fulfilled':
                  return thenable.value;
                case 'rejected':
                  throw (
                    ((thenableState = thenable.reason),
                    checkIfUseWrappedInAsyncCatch(thenableState),
                    thenableState)
                  );
              }
              suspendedThenable = thenable;
              throw SuspenseException;
          }
        }
        function resolveLazy(lazyType) {
          try {
            var init = lazyType._init;
            return init(lazyType._payload);
          } catch (x) {
            if (
              null !== x &&
              'object' === typeof x &&
              'function' === typeof x.then
            )
              throw ((suspendedThenable = x), SuspenseException);
            throw x;
          }
        }
        var suspendedThenable = null;
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(formatProdErrorMessage(459));
          var thenable = suspendedThenable;
          suspendedThenable = null;
          return thenable;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
          if (
            rejectedReason === SuspenseException ||
            rejectedReason === SuspenseActionException
          )
            throw Error(formatProdErrorMessage(483));
        }
        var thenableState$1 = null,
          thenableIndexCounter$1 = 0;
        function unwrapThenable(thenable) {
          var index = thenableIndexCounter$1;
          thenableIndexCounter$1 += 1;
          null === thenableState$1 && (thenableState$1 = []);
          return trackUsedThenable(thenableState$1, thenable, index);
        }
        function coerceRef(workInProgress, element) {
          element = element.props.ref;
          workInProgress.ref = void 0 !== element ? element : null;
        }
        function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
          if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
            throw Error(formatProdErrorMessage(525));
          returnFiber = Object.prototype.toString.call(newChild);
          throw Error(
            formatProdErrorMessage(
              31,
              '[object Object]' === returnFiber
                ? 'object with keys {' + Object.keys(newChild).join(', ') + '}'
                : returnFiber,
            ),
          );
        }
        function createChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
              var deletions = returnFiber.deletions;
              null === deletions
                ? ((returnFiber.deletions = [childToDelete]),
                  (returnFiber.flags |= 16))
                : deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for (; null !== currentFirstChild; )
              deleteChild(returnFiber, currentFirstChild),
                (currentFirstChild = currentFirstChild.sibling);
            return null;
          }
          function mapRemainingChildren(currentFirstChild) {
            for (var existingChildren = new Map(); null !== currentFirstChild; )
              null !== currentFirstChild.key
                ? existingChildren.set(currentFirstChild.key, currentFirstChild)
                : existingChildren.set(
                    currentFirstChild.index,
                    currentFirstChild,
                  ),
                (currentFirstChild = currentFirstChild.sibling);
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            fiber = createWorkInProgress(fiber, pendingProps);
            fiber.index = 0;
            fiber.sibling = null;
            return fiber;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects)
              return (newFiber.flags |= 1048576), lastPlacedIndex;
            newIndex = newFiber.alternate;
            if (null !== newIndex)
              return (
                (newIndex = newIndex.index),
                newIndex < lastPlacedIndex
                  ? ((newFiber.flags |= 67108866), lastPlacedIndex)
                  : newIndex
              );
            newFiber.flags |= 67108866;
            return lastPlacedIndex;
          }
          function placeSingleChild(newFiber) {
            shouldTrackSideEffects &&
              null === newFiber.alternate &&
              (newFiber.flags |= 67108866);
            return newFiber;
          }
          function updateTextNode(returnFiber, current, textContent, lanes) {
            if (null === current || 6 !== current.tag)
              return (
                (current = createFiberFromText(
                  textContent,
                  returnFiber.mode,
                  lanes,
                )),
                (current.return = returnFiber),
                current
              );
            current = useFiber(current, textContent);
            current.return = returnFiber;
            return current;
          }
          function updateElement(returnFiber, current, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE)
              return updateFragment(
                returnFiber,
                current,
                element.props.children,
                lanes,
                element.key,
              );
            if (
              null !== current &&
              (current.elementType === elementType ||
                ('object' === typeof elementType &&
                  null !== elementType &&
                  elementType.$$typeof === REACT_LAZY_TYPE &&
                  resolveLazy(elementType) === current.type))
            )
              return (
                (current = useFiber(current, element.props)),
                coerceRef(current, element),
                (current.return = returnFiber),
                current
              );
            current = createFiberFromTypeAndProps(
              element.type,
              element.key,
              element.props,
              null,
              returnFiber.mode,
              lanes,
            );
            coerceRef(current, element);
            current.return = returnFiber;
            return current;
          }
          function updatePortal(returnFiber, current, portal, lanes) {
            if (
              null === current ||
              4 !== current.tag ||
              current.stateNode.containerInfo !== portal.containerInfo ||
              current.stateNode.implementation !== portal.implementation
            )
              return (
                (current = createFiberFromPortal(
                  portal,
                  returnFiber.mode,
                  lanes,
                )),
                (current.return = returnFiber),
                current
              );
            current = useFiber(current, portal.children || []);
            current.return = returnFiber;
            return current;
          }
          function updateFragment(returnFiber, current, fragment, lanes, key) {
            if (null === current || 7 !== current.tag)
              return (
                (current = createFiberFromFragment(
                  fragment,
                  returnFiber.mode,
                  lanes,
                  key,
                )),
                (current.return = returnFiber),
                current
              );
            current = useFiber(current, fragment);
            current.return = returnFiber;
            return current;
          }
          function createChild(returnFiber, newChild, lanes) {
            if (
              ('string' === typeof newChild && '' !== newChild) ||
              'number' === typeof newChild ||
              'bigint' === typeof newChild
            )
              return (
                (newChild = createFiberFromText(
                  '' + newChild,
                  returnFiber.mode,
                  lanes,
                )),
                (newChild.return = returnFiber),
                newChild
              );
            if ('object' === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return (
                    (lanes = createFiberFromTypeAndProps(
                      newChild.type,
                      newChild.key,
                      newChild.props,
                      null,
                      returnFiber.mode,
                      lanes,
                    )),
                    coerceRef(lanes, newChild),
                    (lanes.return = returnFiber),
                    lanes
                  );
                case REACT_PORTAL_TYPE:
                  return (
                    (newChild = createFiberFromPortal(
                      newChild,
                      returnFiber.mode,
                      lanes,
                    )),
                    (newChild.return = returnFiber),
                    newChild
                  );
                case REACT_LAZY_TYPE:
                  return (
                    (newChild = resolveLazy(newChild)),
                    createChild(returnFiber, newChild, lanes)
                  );
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return (
                  (newChild = createFiberFromFragment(
                    newChild,
                    returnFiber.mode,
                    lanes,
                    null,
                  )),
                  (newChild.return = returnFiber),
                  newChild
                );
              if ('function' === typeof newChild.then)
                return createChild(
                  returnFiber,
                  unwrapThenable(newChild),
                  lanes,
                );
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return createChild(
                  returnFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes,
                );
              throwOnInvalidObjectTypeImpl(returnFiber, newChild);
            }
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if (
              ('string' === typeof newChild && '' !== newChild) ||
              'number' === typeof newChild ||
              'bigint' === typeof newChild
            )
              return null !== key
                ? null
                : updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
            if ('object' === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newChild.key === key
                    ? updateElement(returnFiber, oldFiber, newChild, lanes)
                    : null;
                case REACT_PORTAL_TYPE:
                  return newChild.key === key
                    ? updatePortal(returnFiber, oldFiber, newChild, lanes)
                    : null;
                case REACT_LAZY_TYPE:
                  return (
                    (newChild = resolveLazy(newChild)),
                    updateSlot(returnFiber, oldFiber, newChild, lanes)
                  );
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return null !== key
                  ? null
                  : updateFragment(
                      returnFiber,
                      oldFiber,
                      newChild,
                      lanes,
                      null,
                    );
              if ('function' === typeof newChild.then)
                return updateSlot(
                  returnFiber,
                  oldFiber,
                  unwrapThenable(newChild),
                  lanes,
                );
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateSlot(
                  returnFiber,
                  oldFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes,
                );
              throwOnInvalidObjectTypeImpl(returnFiber, newChild);
            }
            return null;
          }
          function updateFromMap(
            existingChildren,
            returnFiber,
            newIdx,
            newChild,
            lanes,
          ) {
            if (
              ('string' === typeof newChild && '' !== newChild) ||
              'number' === typeof newChild ||
              'bigint' === typeof newChild
            )
              return (
                (existingChildren = existingChildren.get(newIdx) || null),
                updateTextNode(
                  returnFiber,
                  existingChildren,
                  '' + newChild,
                  lanes,
                )
              );
            if ('object' === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return (
                    (existingChildren =
                      existingChildren.get(
                        null === newChild.key ? newIdx : newChild.key,
                      ) || null),
                    updateElement(
                      returnFiber,
                      existingChildren,
                      newChild,
                      lanes,
                    )
                  );
                case REACT_PORTAL_TYPE:
                  return (
                    (existingChildren =
                      existingChildren.get(
                        null === newChild.key ? newIdx : newChild.key,
                      ) || null),
                    updatePortal(returnFiber, existingChildren, newChild, lanes)
                  );
                case REACT_LAZY_TYPE:
                  return (
                    (newChild = resolveLazy(newChild)),
                    updateFromMap(
                      existingChildren,
                      returnFiber,
                      newIdx,
                      newChild,
                      lanes,
                    )
                  );
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return (
                  (existingChildren = existingChildren.get(newIdx) || null),
                  updateFragment(
                    returnFiber,
                    existingChildren,
                    newChild,
                    lanes,
                    null,
                  )
                );
              if ('function' === typeof newChild.then)
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  unwrapThenable(newChild),
                  lanes,
                );
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes,
                );
              throwOnInvalidObjectTypeImpl(returnFiber, newChild);
            }
            return null;
          }
          function reconcileChildrenArray(
            returnFiber,
            currentFirstChild,
            newChildren,
            lanes,
          ) {
            for (
              var resultingFirstChild = null,
                previousNewFiber = null,
                oldFiber = currentFirstChild,
                newIdx = (currentFirstChild = 0),
                nextOldFiber = null;
              null !== oldFiber && newIdx < newChildren.length;
              newIdx++
            ) {
              oldFiber.index > newIdx
                ? ((nextOldFiber = oldFiber), (oldFiber = null))
                : (nextOldFiber = oldFiber.sibling);
              var newFiber = updateSlot(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                lanes,
              );
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              shouldTrackSideEffects &&
                oldFiber &&
                null === newFiber.alternate &&
                deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(
                newFiber,
                currentFirstChild,
                newIdx,
              );
              null === previousNewFiber
                ? (resultingFirstChild = newFiber)
                : (previousNewFiber.sibling = newFiber);
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length)
              return (
                deleteRemainingChildren(returnFiber, oldFiber),
                isHydrating && pushTreeFork(returnFiber, newIdx),
                resultingFirstChild
              );
            if (null === oldFiber) {
              for (; newIdx < newChildren.length; newIdx++)
                (oldFiber = createChild(
                  returnFiber,
                  newChildren[newIdx],
                  lanes,
                )),
                  null !== oldFiber &&
                    ((currentFirstChild = placeChild(
                      oldFiber,
                      currentFirstChild,
                      newIdx,
                    )),
                    null === previousNewFiber
                      ? (resultingFirstChild = oldFiber)
                      : (previousNewFiber.sibling = oldFiber),
                    (previousNewFiber = oldFiber));
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (
              oldFiber = mapRemainingChildren(oldFiber);
              newIdx < newChildren.length;
              newIdx++
            )
              (nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                newChildren[newIdx],
                lanes,
              )),
                null !== nextOldFiber &&
                  (shouldTrackSideEffects &&
                    null !== nextOldFiber.alternate &&
                    oldFiber.delete(
                      null === nextOldFiber.key ? newIdx : nextOldFiber.key,
                    ),
                  (currentFirstChild = placeChild(
                    nextOldFiber,
                    currentFirstChild,
                    newIdx,
                  )),
                  null === previousNewFiber
                    ? (resultingFirstChild = nextOldFiber)
                    : (previousNewFiber.sibling = nextOldFiber),
                  (previousNewFiber = nextOldFiber));
            shouldTrackSideEffects &&
              oldFiber.forEach(function (child) {
                return deleteChild(returnFiber, child);
              });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(
            returnFiber,
            currentFirstChild,
            newChildren,
            lanes,
          ) {
            if (null == newChildren) throw Error(formatProdErrorMessage(151));
            for (
              var resultingFirstChild = null,
                previousNewFiber = null,
                oldFiber = currentFirstChild,
                newIdx = (currentFirstChild = 0),
                nextOldFiber = null,
                step = newChildren.next();
              null !== oldFiber && !step.done;
              newIdx++, step = newChildren.next()
            ) {
              oldFiber.index > newIdx
                ? ((nextOldFiber = oldFiber), (oldFiber = null))
                : (nextOldFiber = oldFiber.sibling);
              var newFiber = updateSlot(
                returnFiber,
                oldFiber,
                step.value,
                lanes,
              );
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              shouldTrackSideEffects &&
                oldFiber &&
                null === newFiber.alternate &&
                deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(
                newFiber,
                currentFirstChild,
                newIdx,
              );
              null === previousNewFiber
                ? (resultingFirstChild = newFiber)
                : (previousNewFiber.sibling = newFiber);
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done)
              return (
                deleteRemainingChildren(returnFiber, oldFiber),
                isHydrating && pushTreeFork(returnFiber, newIdx),
                resultingFirstChild
              );
            if (null === oldFiber) {
              for (; !step.done; newIdx++, step = newChildren.next())
                (step = createChild(returnFiber, step.value, lanes)),
                  null !== step &&
                    ((currentFirstChild = placeChild(
                      step,
                      currentFirstChild,
                      newIdx,
                    )),
                    null === previousNewFiber
                      ? (resultingFirstChild = step)
                      : (previousNewFiber.sibling = step),
                    (previousNewFiber = step));
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (
              oldFiber = mapRemainingChildren(oldFiber);
              !step.done;
              newIdx++, step = newChildren.next()
            )
              (step = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                step.value,
                lanes,
              )),
                null !== step &&
                  (shouldTrackSideEffects &&
                    null !== step.alternate &&
                    oldFiber.delete(null === step.key ? newIdx : step.key),
                  (currentFirstChild = placeChild(
                    step,
                    currentFirstChild,
                    newIdx,
                  )),
                  null === previousNewFiber
                    ? (resultingFirstChild = step)
                    : (previousNewFiber.sibling = step),
                  (previousNewFiber = step));
            shouldTrackSideEffects &&
              oldFiber.forEach(function (child) {
                return deleteChild(returnFiber, child);
              });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ) {
            'object' === typeof newChild &&
              null !== newChild &&
              newChild.type === REACT_FRAGMENT_TYPE &&
              null === newChild.key &&
              (newChild = newChild.props.children);
            if ('object' === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  a: {
                    for (var key = newChild.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === key) {
                        key = newChild.type;
                        if (key === REACT_FRAGMENT_TYPE) {
                          if (7 === currentFirstChild.tag) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling,
                            );
                            lanes = useFiber(
                              currentFirstChild,
                              newChild.props.children,
                            );
                            lanes.return = returnFiber;
                            returnFiber = lanes;
                            break a;
                          }
                        } else if (
                          currentFirstChild.elementType === key ||
                          ('object' === typeof key &&
                            null !== key &&
                            key.$$typeof === REACT_LAZY_TYPE &&
                            resolveLazy(key) === currentFirstChild.type)
                        ) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling,
                          );
                          lanes = useFiber(currentFirstChild, newChild.props);
                          coerceRef(lanes, newChild);
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      } else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    newChild.type === REACT_FRAGMENT_TYPE
                      ? ((lanes = createFiberFromFragment(
                          newChild.props.children,
                          returnFiber.mode,
                          lanes,
                          newChild.key,
                        )),
                        (lanes.return = returnFiber),
                        (returnFiber = lanes))
                      : ((lanes = createFiberFromTypeAndProps(
                          newChild.type,
                          newChild.key,
                          newChild.props,
                          null,
                          returnFiber.mode,
                          lanes,
                        )),
                        coerceRef(lanes, newChild),
                        (lanes.return = returnFiber),
                        (returnFiber = lanes));
                  }
                  return placeSingleChild(returnFiber);
                case REACT_PORTAL_TYPE:
                  a: {
                    for (key = newChild.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === key)
                        if (
                          4 === currentFirstChild.tag &&
                          currentFirstChild.stateNode.containerInfo ===
                            newChild.containerInfo &&
                          currentFirstChild.stateNode.implementation ===
                            newChild.implementation
                        ) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling,
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.children || [],
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        } else {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild,
                          );
                          break;
                        }
                      else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    lanes = createFiberFromPortal(
                      newChild,
                      returnFiber.mode,
                      lanes,
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                  }
                  return placeSingleChild(returnFiber);
                case REACT_LAZY_TYPE:
                  return (
                    (newChild = resolveLazy(newChild)),
                    reconcileChildFibersImpl(
                      returnFiber,
                      currentFirstChild,
                      newChild,
                      lanes,
                    )
                  );
              }
              if (isArrayImpl(newChild))
                return reconcileChildrenArray(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes,
                );
              if (getIteratorFn(newChild)) {
                key = getIteratorFn(newChild);
                if ('function' !== typeof key)
                  throw Error(formatProdErrorMessage(150));
                newChild = key.call(newChild);
                return reconcileChildrenIterator(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes,
                );
              }
              if ('function' === typeof newChild.then)
                return reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  unwrapThenable(newChild),
                  lanes,
                );
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes,
                );
              throwOnInvalidObjectTypeImpl(returnFiber, newChild);
            }
            return ('string' === typeof newChild && '' !== newChild) ||
              'number' === typeof newChild ||
              'bigint' === typeof newChild
              ? ((newChild = '' + newChild),
                null !== currentFirstChild && 6 === currentFirstChild.tag
                  ? (deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling,
                    ),
                    (lanes = useFiber(currentFirstChild, newChild)),
                    (lanes.return = returnFiber),
                    (returnFiber = lanes))
                  : (deleteRemainingChildren(returnFiber, currentFirstChild),
                    (lanes = createFiberFromText(
                      newChild,
                      returnFiber.mode,
                      lanes,
                    )),
                    (lanes.return = returnFiber),
                    (returnFiber = lanes)),
                placeSingleChild(returnFiber))
              : deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return function (returnFiber, currentFirstChild, newChild, lanes) {
            try {
              thenableIndexCounter$1 = 0;
              var firstChildFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes,
              );
              thenableState$1 = null;
              return firstChildFiber;
            } catch (x) {
              if (x === SuspenseException || x === SuspenseActionException)
                throw x;
              var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
              fiber.lanes = lanes;
              fiber.return = returnFiber;
              return fiber;
            } finally {
            }
          };
        }
        var reconcileChildFibers = createChildReconciler(!0),
          mountChildFibers = createChildReconciler(!1),
          hasForceUpdate = !1;
        function initializeUpdateQueue(fiber) {
          fiber.updateQueue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, lanes: 0, hiddenCallbacks: null },
            callbacks: null,
          };
        }
        function cloneUpdateQueue(current, workInProgress) {
          current = current.updateQueue;
          workInProgress.updateQueue === current &&
            (workInProgress.updateQueue = {
              baseState: current.baseState,
              firstBaseUpdate: current.firstBaseUpdate,
              lastBaseUpdate: current.lastBaseUpdate,
              shared: current.shared,
              callbacks: null,
            });
        }
        function createUpdate(lane) {
          return {
            lane: lane,
            tag: 0,
            payload: null,
            callback: null,
            next: null,
          };
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (null === updateQueue) return null;
          updateQueue = updateQueue.shared;
          if (0 !== (executionContext & 2)) {
            var pending = updateQueue.pending;
            null === pending
              ? (update.next = update)
              : ((update.next = pending.next), (pending.next = update));
            updateQueue.pending = update;
            update = getRootForUpdatedFiber(fiber);
            markUpdateLaneFromFiberToRoot(fiber, null, lane);
            return update;
          }
          enqueueUpdate$1(fiber, updateQueue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function entangleTransitions(root, fiber, lane) {
          fiber = fiber.updateQueue;
          if (
            null !== fiber &&
            ((fiber = fiber.shared), 0 !== (lane & 4194048))
          ) {
            var queueLanes = fiber.lanes;
            queueLanes &= root.pendingLanes;
            lane |= queueLanes;
            fiber.lanes = lane;
            markRootEntangled(root, lane);
          }
        }
        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
          var queue = workInProgress.updateQueue,
            current = workInProgress.alternate;
          if (
            null !== current &&
            ((current = current.updateQueue), queue === current)
          ) {
            var newFirst = null,
              newLast = null;
            queue = queue.firstBaseUpdate;
            if (null !== queue) {
              do {
                var clone = {
                  lane: queue.lane,
                  tag: queue.tag,
                  payload: queue.payload,
                  callback: null,
                  next: null,
                };
                null === newLast
                  ? (newFirst = newLast = clone)
                  : (newLast = newLast.next = clone);
                queue = queue.next;
              } while (null !== queue);
              null === newLast
                ? (newFirst = newLast = capturedUpdate)
                : (newLast = newLast.next = capturedUpdate);
            } else newFirst = newLast = capturedUpdate;
            queue = {
              baseState: current.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: current.shared,
              callbacks: current.callbacks,
            };
            workInProgress.updateQueue = queue;
            return;
          }
          workInProgress = queue.lastBaseUpdate;
          null === workInProgress
            ? (queue.firstBaseUpdate = capturedUpdate)
            : (workInProgress.next = capturedUpdate);
          queue.lastBaseUpdate = capturedUpdate;
        }
        var didReadFromEntangledAsyncAction = !1;
        function suspendIfUpdateReadFromEntangledAsyncAction() {
          if (didReadFromEntangledAsyncAction) {
            var entangledActionThenable = currentEntangledActionThenable;
            if (null !== entangledActionThenable) throw entangledActionThenable;
          }
        }
        function processUpdateQueue(
          workInProgress$jscomp$0,
          props,
          instance$jscomp$0,
          renderLanes,
        ) {
          didReadFromEntangledAsyncAction = !1;
          var queue = workInProgress$jscomp$0.updateQueue;
          hasForceUpdate = !1;
          var firstBaseUpdate = queue.firstBaseUpdate,
            lastBaseUpdate = queue.lastBaseUpdate,
            pendingQueue = queue.shared.pending;
          if (null !== pendingQueue) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue,
              firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            null === lastBaseUpdate
              ? (firstBaseUpdate = firstPendingUpdate)
              : (lastBaseUpdate.next = firstPendingUpdate);
            lastBaseUpdate = lastPendingUpdate;
            var current = workInProgress$jscomp$0.alternate;
            null !== current &&
              ((current = current.updateQueue),
              (pendingQueue = current.lastBaseUpdate),
              pendingQueue !== lastBaseUpdate &&
                (null === pendingQueue
                  ? (current.firstBaseUpdate = firstPendingUpdate)
                  : (pendingQueue.next = firstPendingUpdate),
                (current.lastBaseUpdate = lastPendingUpdate)));
          }
          if (null !== firstBaseUpdate) {
            var newState = queue.baseState;
            lastBaseUpdate = 0;
            current = firstPendingUpdate = lastPendingUpdate = null;
            pendingQueue = firstBaseUpdate;
            do {
              var updateLane = pendingQueue.lane & -536870913,
                isHiddenUpdate = updateLane !== pendingQueue.lane;
              if (
                isHiddenUpdate
                  ? (workInProgressRootRenderLanes & updateLane) === updateLane
                  : (renderLanes & updateLane) === updateLane
              ) {
                0 !== updateLane &&
                  updateLane === currentEntangledLane &&
                  (didReadFromEntangledAsyncAction = !0);
                null !== current &&
                  (current = current.next =
                    {
                      lane: 0,
                      tag: pendingQueue.tag,
                      payload: pendingQueue.payload,
                      callback: null,
                      next: null,
                    });
                a: {
                  var workInProgress = workInProgress$jscomp$0,
                    update = pendingQueue;
                  updateLane = props;
                  var instance = instance$jscomp$0;
                  switch (update.tag) {
                    case 1:
                      workInProgress = update.payload;
                      if ('function' === typeof workInProgress) {
                        newState = workInProgress.call(
                          instance,
                          newState,
                          updateLane,
                        );
                        break a;
                      }
                      newState = workInProgress;
                      break a;
                    case 3:
                      workInProgress.flags =
                        (workInProgress.flags & -65537) | 128;
                    case 0:
                      workInProgress = update.payload;
                      updateLane =
                        'function' === typeof workInProgress
                          ? workInProgress.call(instance, newState, updateLane)
                          : workInProgress;
                      if (null === updateLane || void 0 === updateLane) break a;
                      newState = assign({}, newState, updateLane);
                      break a;
                    case 2:
                      hasForceUpdate = !0;
                  }
                }
                updateLane = pendingQueue.callback;
                null !== updateLane &&
                  ((workInProgress$jscomp$0.flags |= 64),
                  isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
                  (isHiddenUpdate = queue.callbacks),
                  null === isHiddenUpdate
                    ? (queue.callbacks = [updateLane])
                    : isHiddenUpdate.push(updateLane));
              } else
                (isHiddenUpdate = {
                  lane: updateLane,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: pendingQueue.callback,
                  next: null,
                }),
                  null === current
                    ? ((firstPendingUpdate = current = isHiddenUpdate),
                      (lastPendingUpdate = newState))
                    : (current = current.next = isHiddenUpdate),
                  (lastBaseUpdate |= updateLane);
              pendingQueue = pendingQueue.next;
              if (null === pendingQueue)
                if (
                  ((pendingQueue = queue.shared.pending), null === pendingQueue)
                )
                  break;
                else
                  (isHiddenUpdate = pendingQueue),
                    (pendingQueue = isHiddenUpdate.next),
                    (isHiddenUpdate.next = null),
                    (queue.lastBaseUpdate = isHiddenUpdate),
                    (queue.shared.pending = null);
            } while (1);
            null === current && (lastPendingUpdate = newState);
            queue.baseState = lastPendingUpdate;
            queue.firstBaseUpdate = firstPendingUpdate;
            queue.lastBaseUpdate = current;
            null === firstBaseUpdate && (queue.shared.lanes = 0);
            workInProgressRootSkippedLanes |= lastBaseUpdate;
            workInProgress$jscomp$0.lanes = lastBaseUpdate;
            workInProgress$jscomp$0.memoizedState = newState;
          }
        }
        function callCallback(callback, context) {
          if ('function' !== typeof callback)
            throw Error(formatProdErrorMessage(191, callback));
          callback.call(context);
        }
        function commitCallbacks(updateQueue, context) {
          var callbacks = updateQueue.callbacks;
          if (null !== callbacks)
            for (
              updateQueue.callbacks = null, updateQueue = 0;
              updateQueue < callbacks.length;
              updateQueue++
            )
              callCallback(callbacks[updateQueue], context);
        }
        var currentTreeHiddenStackCursor = createCursor(null),
          prevEntangledRenderLanesCursor = createCursor(0);
        function pushHiddenContext(fiber, context) {
          fiber = entangledRenderLanes;
          push(prevEntangledRenderLanesCursor, fiber);
          push(currentTreeHiddenStackCursor, context);
          entangledRenderLanes = fiber | context.baseLanes;
        }
        function reuseHiddenContextOnStack() {
          push(prevEntangledRenderLanesCursor, entangledRenderLanes);
          push(
            currentTreeHiddenStackCursor,
            currentTreeHiddenStackCursor.current,
          );
        }
        function popHiddenContext() {
          entangledRenderLanes = prevEntangledRenderLanesCursor.current;
          pop(currentTreeHiddenStackCursor);
          pop(prevEntangledRenderLanesCursor);
        }
        var suspenseHandlerStackCursor = createCursor(null),
          shellBoundary = null;
        function pushPrimaryTreeSuspenseHandler(handler) {
          var current = handler.alternate;
          push(suspenseStackCursor, suspenseStackCursor.current & 1);
          push(suspenseHandlerStackCursor, handler);
          null === shellBoundary &&
            (null === current || null !== currentTreeHiddenStackCursor.current
              ? (shellBoundary = handler)
              : null !== current.memoizedState && (shellBoundary = handler));
        }
        function pushDehydratedActivitySuspenseHandler(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current);
          push(suspenseHandlerStackCursor, fiber);
          null === shellBoundary && (shellBoundary = fiber);
        }
        function pushOffscreenSuspenseHandler(fiber) {
          22 === fiber.tag
            ? (push(suspenseStackCursor, suspenseStackCursor.current),
              push(suspenseHandlerStackCursor, fiber),
              null === shellBoundary && (shellBoundary = fiber))
            : reuseSuspenseHandlerOnStack(fiber);
        }
        function reuseSuspenseHandlerOnStack() {
          push(suspenseStackCursor, suspenseStackCursor.current);
          push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
        }
        function popSuspenseHandler(fiber) {
          pop(suspenseHandlerStackCursor);
          shellBoundary === fiber && (shellBoundary = null);
          pop(suspenseStackCursor);
        }
        var suspenseStackCursor = createCursor(0);
        function findFirstSuspended(row) {
          for (var node = row; null !== node; ) {
            if (13 === node.tag) {
              var state = node.memoizedState;
              if (
                null !== state &&
                ((state = state.dehydrated),
                null === state ||
                  isSuspenseInstancePending(state) ||
                  isSuspenseInstanceFallback(state))
              )
                return node;
            } else if (
              19 === node.tag &&
              ('forwards' === node.memoizedProps.revealOrder ||
                'backwards' === node.memoizedProps.revealOrder ||
                'unstable_legacy-backwards' ===
                  node.memoizedProps.revealOrder ||
                'together' === node.memoizedProps.revealOrder)
            ) {
              if (0 !== (node.flags & 128)) return node;
            } else if (null !== node.child) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === row) return null;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        var renderLanes = 0,
          currentlyRenderingFiber = null,
          currentHook = null,
          workInProgressHook = null,
          didScheduleRenderPhaseUpdate = !1,
          didScheduleRenderPhaseUpdateDuringThisPass = !1,
          shouldDoubleInvokeUserFnsInHooksDEV = !1,
          localIdCounter = 0,
          thenableIndexCounter = 0,
          thenableState = null,
          globalClientIdCounter = 0;
        function throwInvalidHookError() {
          throw Error(formatProdErrorMessage(321));
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (null === prevDeps) return !1;
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
            if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
          return !0;
        }
        function renderWithHooks(
          current,
          workInProgress,
          Component,
          props,
          secondArg,
          nextRenderLanes,
        ) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber = workInProgress;
          workInProgress.memoizedState = null;
          workInProgress.updateQueue = null;
          workInProgress.lanes = 0;
          ReactSharedInternals.H =
            null === current || null === current.memoizedState
              ? HooksDispatcherOnMount
              : HooksDispatcherOnUpdate;
          shouldDoubleInvokeUserFnsInHooksDEV = !1;
          nextRenderLanes = Component(props, secondArg);
          shouldDoubleInvokeUserFnsInHooksDEV = !1;
          didScheduleRenderPhaseUpdateDuringThisPass &&
            (nextRenderLanes = renderWithHooksAgain(
              workInProgress,
              Component,
              props,
              secondArg,
            ));
          finishRenderingHooks(current);
          return nextRenderLanes;
        }
        function finishRenderingHooks(current) {
          ReactSharedInternals.H = ContextOnlyDispatcher;
          var didRenderTooFewHooks =
            null !== currentHook && null !== currentHook.next;
          renderLanes = 0;
          workInProgressHook = currentHook = currentlyRenderingFiber = null;
          didScheduleRenderPhaseUpdate = !1;
          thenableIndexCounter = 0;
          thenableState = null;
          if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
          null === current ||
            didReceiveUpdate ||
            ((current = current.dependencies),
            null !== current &&
              checkIfContextChanged(current) &&
              (didReceiveUpdate = !0));
        }
        function renderWithHooksAgain(
          workInProgress,
          Component,
          props,
          secondArg,
        ) {
          currentlyRenderingFiber = workInProgress;
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass &&
              (thenableState = null);
            thenableIndexCounter = 0;
            didScheduleRenderPhaseUpdateDuringThisPass = !1;
            if (25 <= numberOfReRenders)
              throw Error(formatProdErrorMessage(301));
            numberOfReRenders += 1;
            workInProgressHook = currentHook = null;
            if (null != workInProgress.updateQueue) {
              var children = workInProgress.updateQueue;
              children.lastEffect = null;
              children.events = null;
              children.stores = null;
              null != children.memoCache && (children.memoCache.index = 0);
            }
            ReactSharedInternals.H = HooksDispatcherOnRerender;
            children = Component(props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
          return children;
        }
        function TransitionAwareHostComponent() {
          var dispatcher = ReactSharedInternals.H,
            maybeThenable = dispatcher.useState()[0];
          maybeThenable =
            'function' === typeof maybeThenable.then
              ? useThenable(maybeThenable)
              : maybeThenable;
          dispatcher = dispatcher.useState()[0];
          (null !== currentHook ? currentHook.memoizedState : null) !==
            dispatcher && (currentlyRenderingFiber.flags |= 1024);
          return maybeThenable;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = 0 !== localIdCounter;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current, workInProgress, lanes) {
          workInProgress.updateQueue = current.updateQueue;
          workInProgress.flags &= -2053;
          current.lanes &= ~lanes;
        }
        function resetHooksOnUnwind(workInProgress) {
          if (didScheduleRenderPhaseUpdate) {
            for (
              workInProgress = workInProgress.memoizedState;
              null !== workInProgress;

            ) {
              var queue = workInProgress.queue;
              null !== queue && (queue.pending = null);
              workInProgress = workInProgress.next;
            }
            didScheduleRenderPhaseUpdate = !1;
          }
          renderLanes = 0;
          workInProgressHook = currentHook = currentlyRenderingFiber = null;
          didScheduleRenderPhaseUpdateDuringThisPass = !1;
          thenableIndexCounter = localIdCounter = 0;
          thenableState = null;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null,
          };
          null === workInProgressHook
            ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
                hook)
            : (workInProgressHook = workInProgressHook.next = hook);
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          if (null === currentHook) {
            var nextCurrentHook = currentlyRenderingFiber.alternate;
            nextCurrentHook =
              null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
          } else nextCurrentHook = currentHook.next;
          var nextWorkInProgressHook =
            null === workInProgressHook
              ? currentlyRenderingFiber.memoizedState
              : workInProgressHook.next;
          if (null !== nextWorkInProgressHook)
            (workInProgressHook = nextWorkInProgressHook),
              (currentHook = nextCurrentHook);
          else {
            if (null === nextCurrentHook) {
              if (null === currentlyRenderingFiber.alternate)
                throw Error(formatProdErrorMessage(467));
              throw Error(formatProdErrorMessage(310));
            }
            currentHook = nextCurrentHook;
            nextCurrentHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null,
            };
            null === workInProgressHook
              ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
                  nextCurrentHook)
              : (workInProgressHook = workInProgressHook.next =
                  nextCurrentHook);
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null,
          };
        }
        function useThenable(thenable) {
          var index = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = []);
          thenable = trackUsedThenable(thenableState, thenable, index);
          index = currentlyRenderingFiber;
          null ===
            (null === workInProgressHook
              ? index.memoizedState
              : workInProgressHook.next) &&
            ((index = index.alternate),
            (ReactSharedInternals.H =
              null === index || null === index.memoizedState
                ? HooksDispatcherOnMount
                : HooksDispatcherOnUpdate));
          return thenable;
        }
        function use(usable) {
          if (null !== usable && 'object' === typeof usable) {
            if ('function' === typeof usable.then) return useThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE)
              return readContext(usable);
          }
          throw Error(formatProdErrorMessage(438, String(usable)));
        }
        function useMemoCache(size) {
          var memoCache = null,
            updateQueue = currentlyRenderingFiber.updateQueue;
          null !== updateQueue && (memoCache = updateQueue.memoCache);
          if (null == memoCache) {
            var current = currentlyRenderingFiber.alternate;
            null !== current &&
              ((current = current.updateQueue),
              null !== current &&
                ((current = current.memoCache),
                null != current &&
                  (memoCache = {
                    data: current.data.map(function (array) {
                      return array.slice();
                    }),
                    index: 0,
                  })));
          }
          null == memoCache && (memoCache = { data: [], index: 0 });
          null === updateQueue &&
            ((updateQueue = createFunctionComponentUpdateQueue()),
            (currentlyRenderingFiber.updateQueue = updateQueue));
          updateQueue.memoCache = memoCache;
          updateQueue = memoCache.data[memoCache.index];
          if (void 0 === updateQueue)
            for (
              updateQueue = memoCache.data[memoCache.index] = Array(size),
                current = 0;
              current < size;
              current++
            )
              updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
          memoCache.index++;
          return updateQueue;
        }
        function basicStateReducer(state, action) {
          return 'function' === typeof action ? action(state) : action;
        }
        function updateReducer(reducer) {
          var hook = updateWorkInProgressHook();
          return updateReducerImpl(hook, currentHook, reducer);
        }
        function updateReducerImpl(hook, current, reducer) {
          var queue = hook.queue;
          if (null === queue) throw Error(formatProdErrorMessage(311));
          queue.lastRenderedReducer = reducer;
          var baseQueue = hook.baseQueue,
            pendingQueue = queue.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next;
              baseQueue.next = pendingQueue.next;
              pendingQueue.next = baseFirst;
            }
            current.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          pendingQueue = hook.baseState;
          if (null === baseQueue) hook.memoizedState = pendingQueue;
          else {
            current = baseQueue.next;
            var newBaseQueueFirst = (baseFirst = null),
              newBaseQueueLast = null,
              update = current,
              didReadFromEntangledAsyncAction$60 = !1;
            do {
              var updateLane = update.lane & -536870913;
              if (
                updateLane !== update.lane
                  ? (workInProgressRootRenderLanes & updateLane) === updateLane
                  : (renderLanes & updateLane) === updateLane
              ) {
                var revertLane = update.revertLane;
                if (0 === revertLane)
                  null !== newBaseQueueLast &&
                    (newBaseQueueLast = newBaseQueueLast.next =
                      {
                        lane: 0,
                        revertLane: 0,
                        gesture: null,
                        action: update.action,
                        hasEagerState: update.hasEagerState,
                        eagerState: update.eagerState,
                        next: null,
                      }),
                    updateLane === currentEntangledLane &&
                      (didReadFromEntangledAsyncAction$60 = !0);
                else if ((renderLanes & revertLane) === revertLane) {
                  update = update.next;
                  revertLane === currentEntangledLane &&
                    (didReadFromEntangledAsyncAction$60 = !0);
                  continue;
                } else
                  (updateLane = {
                    lane: 0,
                    revertLane: update.revertLane,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null,
                  }),
                    null === newBaseQueueLast
                      ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
                        (baseFirst = pendingQueue))
                      : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
                    (currentlyRenderingFiber.lanes |= revertLane),
                    (workInProgressRootSkippedLanes |= revertLane);
                updateLane = update.action;
                shouldDoubleInvokeUserFnsInHooksDEV &&
                  reducer(pendingQueue, updateLane);
                pendingQueue = update.hasEagerState
                  ? update.eagerState
                  : reducer(pendingQueue, updateLane);
              } else
                (revertLane = {
                  lane: updateLane,
                  revertLane: update.revertLane,
                  gesture: update.gesture,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null,
                }),
                  null === newBaseQueueLast
                    ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
                      (baseFirst = pendingQueue))
                    : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
                  (currentlyRenderingFiber.lanes |= updateLane),
                  (workInProgressRootSkippedLanes |= updateLane);
              update = update.next;
            } while (null !== update && update !== current);
            null === newBaseQueueLast
              ? (baseFirst = pendingQueue)
              : (newBaseQueueLast.next = newBaseQueueFirst);
            if (
              !objectIs(pendingQueue, hook.memoizedState) &&
              ((didReceiveUpdate = !0),
              didReadFromEntangledAsyncAction$60 &&
                ((reducer = currentEntangledActionThenable), null !== reducer))
            )
              throw reducer;
            hook.memoizedState = pendingQueue;
            hook.baseState = baseFirst;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = pendingQueue;
          }
          null === baseQueue && (queue.lanes = 0);
          return [hook.memoizedState, queue.dispatch];
        }
        function rerenderReducer(reducer) {
          var hook = updateWorkInProgressHook(),
            queue = hook.queue;
          if (null === queue) throw Error(formatProdErrorMessage(311));
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch,
            lastRenderPhaseUpdate = queue.pending,
            newState = hook.memoizedState;
          if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
            do
              (newState = reducer(newState, update.action)),
                (update = update.next);
            while (update !== lastRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
            hook.memoizedState = newState;
            null === hook.baseQueue && (hook.baseState = newState);
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot,
        ) {
          var fiber = currentlyRenderingFiber,
            hook = updateWorkInProgressHook(),
            isHydrating$jscomp$0 = isHydrating;
          if (isHydrating$jscomp$0) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else getServerSnapshot = getSnapshot();
          var snapshotChanged = !objectIs(
            (currentHook || hook).memoizedState,
            getServerSnapshot,
          );
          snapshotChanged &&
            ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));
          hook = hook.queue;
          updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
            subscribe,
          ]);
          if (
            hook.getSnapshot !== getSnapshot ||
            snapshotChanged ||
            (null !== workInProgressHook &&
              workInProgressHook.memoizedState.tag & 1)
          ) {
            fiber.flags |= 2048;
            pushSimpleEffect(
              9,
              { destroy: void 0 },
              updateStoreInstance.bind(
                null,
                fiber,
                hook,
                getServerSnapshot,
                getSnapshot,
              ),
              null,
            );
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            isHydrating$jscomp$0 ||
              0 !== (renderLanes & 127) ||
              pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          return getServerSnapshot;
        }
        function pushStoreConsistencyCheck(
          fiber,
          getSnapshot,
          renderedSnapshot,
        ) {
          fiber.flags |= 16384;
          fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
          getSnapshot = currentlyRenderingFiber.updateQueue;
          null === getSnapshot
            ? ((getSnapshot = createFunctionComponentUpdateQueue()),
              (currentlyRenderingFiber.updateQueue = getSnapshot),
              (getSnapshot.stores = [fiber]))
            : ((renderedSnapshot = getSnapshot.stores),
              null === renderedSnapshot
                ? (getSnapshot.stores = [fiber])
                : renderedSnapshot.push(fiber));
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        }
        function subscribeToStore(fiber, inst, subscribe) {
          return subscribe(function () {
            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
          });
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return !0;
          }
        }
        function forceStoreRerender(fiber) {
          var root = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root && scheduleUpdateOnFiber(root, fiber, 2);
        }
        function mountStateImpl(initialState) {
          var hook = mountWorkInProgressHook();
          if ('function' === typeof initialState) {
            var initialStateInitializer = initialState;
            initialState = initialStateInitializer();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(!0);
              try {
                initialStateInitializer();
              } finally {
                setIsStrictModeForDevtools(!1);
              }
            }
          }
          hook.memoizedState = hook.baseState = initialState;
          hook.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState,
          };
          return hook;
        }
        function updateOptimisticImpl(hook, current, passthrough, reducer) {
          hook.baseState = passthrough;
          return updateReducerImpl(
            hook,
            currentHook,
            'function' === typeof reducer ? reducer : basicStateReducer,
          );
        }
        function dispatchActionState(
          fiber,
          actionQueue,
          setPendingState,
          setState,
          payload,
        ) {
          if (isRenderPhaseUpdate(fiber))
            throw Error(formatProdErrorMessage(485));
          fiber = actionQueue.action;
          if (null !== fiber) {
            var actionNode = {
              payload: payload,
              action: fiber,
              next: null,
              isTransition: !0,
              status: 'pending',
              value: null,
              reason: null,
              listeners: [],
              then: function (listener) {
                actionNode.listeners.push(listener);
              },
            };
            null !== ReactSharedInternals.T
              ? setPendingState(!0)
              : (actionNode.isTransition = !1);
            setState(actionNode);
            setPendingState = actionQueue.pending;
            null === setPendingState
              ? ((actionNode.next = actionQueue.pending = actionNode),
                runActionStateAction(actionQueue, actionNode))
              : ((actionNode.next = setPendingState.next),
                (actionQueue.pending = setPendingState.next = actionNode));
          }
        }
        function runActionStateAction(actionQueue, node) {
          var action = node.action,
            payload = node.payload,
            prevState = actionQueue.state;
          if (node.isTransition) {
            var prevTransition = ReactSharedInternals.T,
              currentTransition = {};
            ReactSharedInternals.T = currentTransition;
            try {
              var returnValue = action(prevState, payload),
                onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish &&
                onStartTransitionFinish(currentTransition, returnValue);
              handleActionReturnValue(actionQueue, node, returnValue);
            } catch (error) {
              onActionError(actionQueue, node, error);
            } finally {
              null !== prevTransition &&
                null !== currentTransition.types &&
                (prevTransition.types = currentTransition.types),
                (ReactSharedInternals.T = prevTransition);
            }
          } else
            try {
              (prevTransition = action(prevState, payload)),
                handleActionReturnValue(actionQueue, node, prevTransition);
            } catch (error$66) {
              onActionError(actionQueue, node, error$66);
            }
        }
        function handleActionReturnValue(actionQueue, node, returnValue) {
          null !== returnValue &&
          'object' === typeof returnValue &&
          'function' === typeof returnValue.then
            ? returnValue.then(
                function (nextState) {
                  onActionSuccess(actionQueue, node, nextState);
                },
                function (error) {
                  return onActionError(actionQueue, node, error);
                },
              )
            : onActionSuccess(actionQueue, node, returnValue);
        }
        function onActionSuccess(actionQueue, actionNode, nextState) {
          actionNode.status = 'fulfilled';
          actionNode.value = nextState;
          notifyActionListeners(actionNode);
          actionQueue.state = nextState;
          actionNode = actionQueue.pending;
          null !== actionNode &&
            ((nextState = actionNode.next),
            nextState === actionNode
              ? (actionQueue.pending = null)
              : ((nextState = nextState.next),
                (actionNode.next = nextState),
                runActionStateAction(actionQueue, nextState)));
        }
        function onActionError(actionQueue, actionNode, error) {
          var last = actionQueue.pending;
          actionQueue.pending = null;
          if (null !== last) {
            last = last.next;
            do
              (actionNode.status = 'rejected'),
                (actionNode.reason = error),
                notifyActionListeners(actionNode),
                (actionNode = actionNode.next);
            while (actionNode !== last);
          }
          actionQueue.action = null;
        }
        function notifyActionListeners(actionNode) {
          actionNode = actionNode.listeners;
          for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
        }
        function actionStateReducer(oldState, newState) {
          return newState;
        }
        function mountActionState(action, initialStateProp) {
          if (isHydrating) {
            var ssrFormState = workInProgressRoot.formState;
            if (null !== ssrFormState) {
              a: {
                var JSCompiler_inline_result = currentlyRenderingFiber;
                if (isHydrating) {
                  if (nextHydratableInstance) {
                    b: {
                      var JSCompiler_inline_result$jscomp$0 =
                        nextHydratableInstance;
                      for (
                        var inRootOrSingleton = rootOrSingletonContext;
                        8 !== JSCompiler_inline_result$jscomp$0.nodeType;

                      ) {
                        if (!inRootOrSingleton) {
                          JSCompiler_inline_result$jscomp$0 = null;
                          break b;
                        }
                        JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                          JSCompiler_inline_result$jscomp$0.nextSibling,
                        );
                        if (null === JSCompiler_inline_result$jscomp$0) {
                          JSCompiler_inline_result$jscomp$0 = null;
                          break b;
                        }
                      }
                      inRootOrSingleton =
                        JSCompiler_inline_result$jscomp$0.data;
                      JSCompiler_inline_result$jscomp$0 =
                        'F!' === inRootOrSingleton || 'F' === inRootOrSingleton
                          ? JSCompiler_inline_result$jscomp$0
                          : null;
                    }
                    if (JSCompiler_inline_result$jscomp$0) {
                      nextHydratableInstance = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling,
                      );
                      JSCompiler_inline_result =
                        'F!' === JSCompiler_inline_result$jscomp$0.data;
                      break a;
                    }
                  }
                  throwOnHydrationMismatch(JSCompiler_inline_result);
                }
                JSCompiler_inline_result = !1;
              }
              JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
            }
          }
          ssrFormState = mountWorkInProgressHook();
          ssrFormState.memoizedState = ssrFormState.baseState =
            initialStateProp;
          JSCompiler_inline_result = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: actionStateReducer,
            lastRenderedState: initialStateProp,
          };
          ssrFormState.queue = JSCompiler_inline_result;
          ssrFormState = dispatchSetState.bind(
            null,
            currentlyRenderingFiber,
            JSCompiler_inline_result,
          );
          JSCompiler_inline_result.dispatch = ssrFormState;
          JSCompiler_inline_result = mountStateImpl(!1);
          inRootOrSingleton = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            !1,
            JSCompiler_inline_result.queue,
          );
          JSCompiler_inline_result = mountWorkInProgressHook();
          JSCompiler_inline_result$jscomp$0 = {
            state: initialStateProp,
            dispatch: null,
            action: action,
            pending: null,
          };
          JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
          ssrFormState = dispatchActionState.bind(
            null,
            currentlyRenderingFiber,
            JSCompiler_inline_result$jscomp$0,
            inRootOrSingleton,
            ssrFormState,
          );
          JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
          JSCompiler_inline_result.memoizedState = action;
          return [initialStateProp, ssrFormState, !1];
        }
        function updateActionState(action) {
          var stateHook = updateWorkInProgressHook();
          return updateActionStateImpl(stateHook, currentHook, action);
        }
        function updateActionStateImpl(stateHook, currentStateHook, action) {
          currentStateHook = updateReducerImpl(
            stateHook,
            currentStateHook,
            actionStateReducer,
          )[0];
          stateHook = updateReducer(basicStateReducer)[0];
          if (
            'object' === typeof currentStateHook &&
            null !== currentStateHook &&
            'function' === typeof currentStateHook.then
          )
            try {
              var state = useThenable(currentStateHook);
            } catch (x) {
              if (x === SuspenseException) throw SuspenseActionException;
              throw x;
            }
          else state = currentStateHook;
          currentStateHook = updateWorkInProgressHook();
          var actionQueue = currentStateHook.queue,
            dispatch = actionQueue.dispatch;
          action !== currentStateHook.memoizedState &&
            ((currentlyRenderingFiber.flags |= 2048),
            pushSimpleEffect(
              9,
              { destroy: void 0 },
              actionStateActionEffect.bind(null, actionQueue, action),
              null,
            ));
          return [state, dispatch, stateHook];
        }
        function actionStateActionEffect(actionQueue, action) {
          actionQueue.action = action;
        }
        function rerenderActionState(action) {
          var stateHook = updateWorkInProgressHook(),
            currentStateHook = currentHook;
          if (null !== currentStateHook)
            return updateActionStateImpl(stateHook, currentStateHook, action);
          updateWorkInProgressHook();
          stateHook = stateHook.memoizedState;
          currentStateHook = updateWorkInProgressHook();
          var dispatch = currentStateHook.queue.dispatch;
          currentStateHook.memoizedState = action;
          return [stateHook, dispatch, !1];
        }
        function pushSimpleEffect(tag, inst, create, deps) {
          tag = {
            tag: tag,
            create: create,
            deps: deps,
            inst: inst,
            next: null,
          };
          inst = currentlyRenderingFiber.updateQueue;
          null === inst &&
            ((inst = createFunctionComponentUpdateQueue()),
            (currentlyRenderingFiber.updateQueue = inst));
          create = inst.lastEffect;
          null === create
            ? (inst.lastEffect = tag.next = tag)
            : ((deps = create.next),
              (create.next = tag),
              (tag.next = deps),
              (inst.lastEffect = tag));
          return tag;
        }
        function updateRef() {
          return updateWorkInProgressHook().memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = mountWorkInProgressHook();
          currentlyRenderingFiber.flags |= fiberFlags;
          hook.memoizedState = pushSimpleEffect(
            1 | hookFlags,
            { destroy: void 0 },
            create,
            void 0 === deps ? null : deps,
          );
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var inst = hook.memoizedState.inst;
          null !== currentHook &&
          null !== deps &&
          areHookInputsEqual(deps, currentHook.memoizedState.deps)
            ? (hook.memoizedState = pushSimpleEffect(
                hookFlags,
                inst,
                create,
                deps,
              ))
            : ((currentlyRenderingFiber.flags |= fiberFlags),
              (hook.memoizedState = pushSimpleEffect(
                1 | hookFlags,
                inst,
                create,
                deps,
              )));
        }
        function mountEffect(create, deps) {
          mountEffectImpl(8390656, 8, create, deps);
        }
        function updateEffect(create, deps) {
          updateEffectImpl(2048, 8, create, deps);
        }
        function useEffectEventImpl(payload) {
          currentlyRenderingFiber.flags |= 4;
          var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
          if (null === componentUpdateQueue)
            (componentUpdateQueue = createFunctionComponentUpdateQueue()),
              (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
              (componentUpdateQueue.events = [payload]);
          else {
            var events = componentUpdateQueue.events;
            null === events
              ? (componentUpdateQueue.events = [payload])
              : events.push(payload);
          }
        }
        function updateEvent(callback) {
          var ref = updateWorkInProgressHook().memoizedState;
          useEffectEventImpl({ ref: ref, nextImpl: callback });
          return function () {
            if (0 !== (executionContext & 2))
              throw Error(formatProdErrorMessage(440));
            return ref.impl.apply(void 0, arguments);
          };
        }
        function updateInsertionEffect(create, deps) {
          return updateEffectImpl(4, 2, create, deps);
        }
        function updateLayoutEffect(create, deps) {
          return updateEffectImpl(4, 4, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if ('function' === typeof ref) {
            create = create();
            var refCleanup = ref(create);
            return function () {
              'function' === typeof refCleanup ? refCleanup() : ref(null);
            };
          }
          if (null !== ref && void 0 !== ref)
            return (
              (create = create()),
              (ref.current = create),
              function () {
                ref.current = null;
              }
            );
        }
        function updateImperativeHandle(ref, create, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          updateEffectImpl(
            4,
            4,
            imperativeHandleEffect.bind(null, create, ref),
            deps,
          );
        }
        function mountDebugValue() {}
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          hook.memoizedState = [callback, deps];
          return callback;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          prevState = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(!0);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
          hook.memoizedState = [prevState, deps];
          return prevState;
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
          if (
            void 0 === initialValue ||
            (0 !== (renderLanes & 1073741824) &&
              0 === (workInProgressRootRenderLanes & 261930))
          )
            return (hook.memoizedState = value);
          hook.memoizedState = initialValue;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return initialValue;
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
          if (objectIs(value, prevValue)) return value;
          if (null !== currentTreeHiddenStackCursor.current)
            return (
              (hook = mountDeferredValueImpl(hook, value, initialValue)),
              objectIs(hook, prevValue) || (didReceiveUpdate = !0),
              hook
            );
          if (
            0 === (renderLanes & 42) ||
            (0 !== (renderLanes & 1073741824) &&
              0 === (workInProgressRootRenderLanes & 261930))
          )
            return (didReceiveUpdate = !0), (hook.memoizedState = value);
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return prevValue;
        }
        function startTransition(
          fiber,
          queue,
          pendingState,
          finishedState,
          callback,
        ) {
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p =
            0 !== previousPriority && 8 > previousPriority
              ? previousPriority
              : 8;
          var prevTransition = ReactSharedInternals.T,
            currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          dispatchOptimisticSetState(fiber, !1, queue, pendingState);
          try {
            var returnValue = callback(),
              onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish &&
              onStartTransitionFinish(currentTransition, returnValue);
            if (
              null !== returnValue &&
              'object' === typeof returnValue &&
              'function' === typeof returnValue.then
            ) {
              var thenableForFinishedState = chainThenableValue(
                returnValue,
                finishedState,
              );
              dispatchSetStateInternal(
                fiber,
                queue,
                thenableForFinishedState,
                requestUpdateLane(fiber),
              );
            } else
              dispatchSetStateInternal(
                fiber,
                queue,
                finishedState,
                requestUpdateLane(fiber),
              );
          } catch (error) {
            dispatchSetStateInternal(
              fiber,
              queue,
              { then: function () {}, status: 'rejected', reason: error },
              requestUpdateLane(),
            );
          } finally {
            (ReactDOMSharedInternals.p = previousPriority),
              null !== prevTransition &&
                null !== currentTransition.types &&
                (prevTransition.types = currentTransition.types),
              (ReactSharedInternals.T = prevTransition);
          }
        }
        function noop() {}
        function startHostTransition(
          formFiber,
          pendingState,
          action,
          formData,
        ) {
          if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
          var queue = ensureFormComponentIsStateful(formFiber).queue;
          startTransition(
            formFiber,
            queue,
            pendingState,
            sharedNotPendingObject,
            null === action
              ? noop
              : function () {
                  requestFormReset$1(formFiber);
                  return action(formData);
                },
          );
        }
        function ensureFormComponentIsStateful(formFiber) {
          var existingStateHook = formFiber.memoizedState;
          if (null !== existingStateHook) return existingStateHook;
          existingStateHook = {
            memoizedState: sharedNotPendingObject,
            baseState: sharedNotPendingObject,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: sharedNotPendingObject,
            },
            next: null,
          };
          var initialResetState = {};
          existingStateHook.next = {
            memoizedState: initialResetState,
            baseState: initialResetState,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialResetState,
            },
            next: null,
          };
          formFiber.memoizedState = existingStateHook;
          formFiber = formFiber.alternate;
          null !== formFiber && (formFiber.memoizedState = existingStateHook);
          return existingStateHook;
        }
        function requestFormReset$1(formFiber) {
          var stateHook = ensureFormComponentIsStateful(formFiber);
          null === stateHook.next &&
            (stateHook = formFiber.alternate.memoizedState);
          dispatchSetStateInternal(
            formFiber,
            stateHook.next.queue,
            {},
            requestUpdateLane(),
          );
        }
        function useHostTransitionStatus() {
          return readContext(HostTransitionContext);
        }
        function updateId() {
          return updateWorkInProgressHook().memoizedState;
        }
        function updateRefresh() {
          return updateWorkInProgressHook().memoizedState;
        }
        function refreshCache(fiber) {
          for (var provider = fiber.return; null !== provider; ) {
            switch (provider.tag) {
              case 24:
              case 3:
                var lane = requestUpdateLane();
                fiber = createUpdate(lane);
                var root$69 = enqueueUpdate(provider, fiber, lane);
                null !== root$69 &&
                  (scheduleUpdateOnFiber(root$69, provider, lane),
                  entangleTransitions(root$69, provider, lane));
                provider = { cache: createCache() };
                fiber.payload = provider;
                return;
            }
            provider = provider.return;
          }
        }
        function dispatchReducerAction(fiber, queue, action) {
          var lane = requestUpdateLane();
          action = {
            lane: lane,
            revertLane: 0,
            gesture: null,
            action: action,
            hasEagerState: !1,
            eagerState: null,
            next: null,
          };
          isRenderPhaseUpdate(fiber)
            ? enqueueRenderPhaseUpdate(queue, action)
            : ((action = enqueueConcurrentHookUpdate(
                fiber,
                queue,
                action,
                lane,
              )),
              null !== action &&
                (scheduleUpdateOnFiber(action, fiber, lane),
                entangleTransitionUpdate(action, queue, lane)));
        }
        function dispatchSetState(fiber, queue, action) {
          var lane = requestUpdateLane();
          dispatchSetStateInternal(fiber, queue, action, lane);
        }
        function dispatchSetStateInternal(fiber, queue, action, lane) {
          var update = {
            lane: lane,
            revertLane: 0,
            gesture: null,
            action: action,
            hasEagerState: !1,
            eagerState: null,
            next: null,
          };
          if (isRenderPhaseUpdate(fiber))
            enqueueRenderPhaseUpdate(queue, update);
          else {
            var alternate = fiber.alternate;
            if (
              0 === fiber.lanes &&
              (null === alternate || 0 === alternate.lanes) &&
              ((alternate = queue.lastRenderedReducer), null !== alternate)
            )
              try {
                var currentState = queue.lastRenderedState,
                  eagerState = alternate(currentState, action);
                update.hasEagerState = !0;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState))
                  return (
                    enqueueUpdate$1(fiber, queue, update, 0),
                    null === workInProgressRoot &&
                      finishQueueingConcurrentUpdates(),
                    !1
                  );
              } catch (error) {
              } finally {
              }
            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (null !== action)
              return (
                scheduleUpdateOnFiber(action, fiber, lane),
                entangleTransitionUpdate(action, queue, lane),
                !0
              );
          }
          return !1;
        }
        function dispatchOptimisticSetState(
          fiber,
          throwIfDuringRender,
          queue,
          action,
        ) {
          action = {
            lane: 2,
            revertLane: requestTransitionLane(),
            gesture: null,
            action: action,
            hasEagerState: !1,
            eagerState: null,
            next: null,
          };
          if (isRenderPhaseUpdate(fiber)) {
            if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
          } else
            (throwIfDuringRender = enqueueConcurrentHookUpdate(
              fiber,
              queue,
              action,
              2,
            )),
              null !== throwIfDuringRender &&
                scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return (
            fiber === currentlyRenderingFiber ||
            (null !== alternate && alternate === currentlyRenderingFiber)
          );
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass =
            didScheduleRenderPhaseUpdate = !0;
          var pending = queue.pending;
          null === pending
            ? (update.next = update)
            : ((update.next = pending.next), (pending.next = update));
          queue.pending = update;
        }
        function entangleTransitionUpdate(root, queue, lane) {
          if (0 !== (lane & 4194048)) {
            var queueLanes = queue.lanes;
            queueLanes &= root.pendingLanes;
            lane |= queueLanes;
            queue.lanes = lane;
            markRootEntangled(root, lane);
          }
        }
        var ContextOnlyDispatcher = {
          readContext: readContext,
          use: use,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          useHostTransitionStatus: throwInvalidHookError,
          useFormState: throwInvalidHookError,
          useActionState: throwInvalidHookError,
          useOptimistic: throwInvalidHookError,
          useMemoCache: throwInvalidHookError,
          useCacheRefresh: throwInvalidHookError,
        };
        ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
        var HooksDispatcherOnMount = {
            readContext: readContext,
            use: use,
            useCallback: function (callback, deps) {
              mountWorkInProgressHook().memoizedState = [
                callback,
                void 0 === deps ? null : deps,
              ];
              return callback;
            },
            useContext: readContext,
            useEffect: mountEffect,
            useImperativeHandle: function (ref, create, deps) {
              deps =
                null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
              mountEffectImpl(
                4194308,
                4,
                imperativeHandleEffect.bind(null, create, ref),
                deps,
              );
            },
            useLayoutEffect: function (create, deps) {
              return mountEffectImpl(4194308, 4, create, deps);
            },
            useInsertionEffect: function (create, deps) {
              mountEffectImpl(4, 2, create, deps);
            },
            useMemo: function (nextCreate, deps) {
              var hook = mountWorkInProgressHook();
              deps = void 0 === deps ? null : deps;
              var nextValue = nextCreate();
              if (shouldDoubleInvokeUserFnsInHooksDEV) {
                setIsStrictModeForDevtools(!0);
                try {
                  nextCreate();
                } finally {
                  setIsStrictModeForDevtools(!1);
                }
              }
              hook.memoizedState = [nextValue, deps];
              return nextValue;
            },
            useReducer: function (reducer, initialArg, init) {
              var hook = mountWorkInProgressHook();
              if (void 0 !== init) {
                var initialState = init(initialArg);
                if (shouldDoubleInvokeUserFnsInHooksDEV) {
                  setIsStrictModeForDevtools(!0);
                  try {
                    init(initialArg);
                  } finally {
                    setIsStrictModeForDevtools(!1);
                  }
                }
              } else initialState = initialArg;
              hook.memoizedState = hook.baseState = initialState;
              reducer = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: reducer,
                lastRenderedState: initialState,
              };
              hook.queue = reducer;
              reducer = reducer.dispatch = dispatchReducerAction.bind(
                null,
                currentlyRenderingFiber,
                reducer,
              );
              return [hook.memoizedState, reducer];
            },
            useRef: function (initialValue) {
              var hook = mountWorkInProgressHook();
              initialValue = { current: initialValue };
              return (hook.memoizedState = initialValue);
            },
            useState: function (initialState) {
              initialState = mountStateImpl(initialState);
              var queue = initialState.queue,
                dispatch = dispatchSetState.bind(
                  null,
                  currentlyRenderingFiber,
                  queue,
                );
              queue.dispatch = dispatch;
              return [initialState.memoizedState, dispatch];
            },
            useDebugValue: mountDebugValue,
            useDeferredValue: function (value, initialValue) {
              var hook = mountWorkInProgressHook();
              return mountDeferredValueImpl(hook, value, initialValue);
            },
            useTransition: function () {
              var stateHook = mountStateImpl(!1);
              stateHook = startTransition.bind(
                null,
                currentlyRenderingFiber,
                stateHook.queue,
                !0,
                !1,
              );
              mountWorkInProgressHook().memoizedState = stateHook;
              return [!1, stateHook];
            },
            useSyncExternalStore: function (
              subscribe,
              getSnapshot,
              getServerSnapshot,
            ) {
              var fiber = currentlyRenderingFiber,
                hook = mountWorkInProgressHook();
              if (isHydrating) {
                if (void 0 === getServerSnapshot)
                  throw Error(formatProdErrorMessage(407));
                getServerSnapshot = getServerSnapshot();
              } else {
                getServerSnapshot = getSnapshot();
                if (null === workInProgressRoot)
                  throw Error(formatProdErrorMessage(349));
                0 !== (workInProgressRootRenderLanes & 127) ||
                  pushStoreConsistencyCheck(
                    fiber,
                    getSnapshot,
                    getServerSnapshot,
                  );
              }
              hook.memoizedState = getServerSnapshot;
              var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
              hook.queue = inst;
              mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
                subscribe,
              ]);
              fiber.flags |= 2048;
              pushSimpleEffect(
                9,
                { destroy: void 0 },
                updateStoreInstance.bind(
                  null,
                  fiber,
                  inst,
                  getServerSnapshot,
                  getSnapshot,
                ),
                null,
              );
              return getServerSnapshot;
            },
            useId: function () {
              var hook = mountWorkInProgressHook(),
                identifierPrefix = workInProgressRoot.identifierPrefix;
              if (isHydrating) {
                var JSCompiler_inline_result = treeContextOverflow;
                var idWithLeadingBit = treeContextId;
                JSCompiler_inline_result =
                  (
                    idWithLeadingBit &
                    ~(1 << (32 - clz32(idWithLeadingBit) - 1))
                  ).toString(32) + JSCompiler_inline_result;
                identifierPrefix =
                  '_' + identifierPrefix + 'R_' + JSCompiler_inline_result;
                JSCompiler_inline_result = localIdCounter++;
                0 < JSCompiler_inline_result &&
                  (identifierPrefix +=
                    'H' + JSCompiler_inline_result.toString(32));
                identifierPrefix += '_';
              } else
                (JSCompiler_inline_result = globalClientIdCounter++),
                  (identifierPrefix =
                    '_' +
                    identifierPrefix +
                    'r_' +
                    JSCompiler_inline_result.toString(32) +
                    '_');
              return (hook.memoizedState = identifierPrefix);
            },
            useHostTransitionStatus: useHostTransitionStatus,
            useFormState: mountActionState,
            useActionState: mountActionState,
            useOptimistic: function (passthrough) {
              var hook = mountWorkInProgressHook();
              hook.memoizedState = hook.baseState = passthrough;
              var queue = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null,
              };
              hook.queue = queue;
              hook = dispatchOptimisticSetState.bind(
                null,
                currentlyRenderingFiber,
                !0,
                queue,
              );
              queue.dispatch = hook;
              return [passthrough, hook];
            },
            useMemoCache: useMemoCache,
            useCacheRefresh: function () {
              return (mountWorkInProgressHook().memoizedState =
                refreshCache.bind(null, currentlyRenderingFiber));
            },
            useEffectEvent: function (callback) {
              var hook = mountWorkInProgressHook(),
                ref = { impl: callback };
              hook.memoizedState = ref;
              return function () {
                if (0 !== (executionContext & 2))
                  throw Error(formatProdErrorMessage(440));
                return ref.impl.apply(void 0, arguments);
              };
            },
          },
          HooksDispatcherOnUpdate = {
            readContext: readContext,
            use: use,
            useCallback: updateCallback,
            useContext: readContext,
            useEffect: updateEffect,
            useImperativeHandle: updateImperativeHandle,
            useInsertionEffect: updateInsertionEffect,
            useLayoutEffect: updateLayoutEffect,
            useMemo: updateMemo,
            useReducer: updateReducer,
            useRef: updateRef,
            useState: function () {
              return updateReducer(basicStateReducer);
            },
            useDebugValue: mountDebugValue,
            useDeferredValue: function (value, initialValue) {
              var hook = updateWorkInProgressHook();
              return updateDeferredValueImpl(
                hook,
                currentHook.memoizedState,
                value,
                initialValue,
              );
            },
            useTransition: function () {
              var booleanOrThenable = updateReducer(basicStateReducer)[0],
                start = updateWorkInProgressHook().memoizedState;
              return [
                'boolean' === typeof booleanOrThenable
                  ? booleanOrThenable
                  : useThenable(booleanOrThenable),
                start,
              ];
            },
            useSyncExternalStore: updateSyncExternalStore,
            useId: updateId,
            useHostTransitionStatus: useHostTransitionStatus,
            useFormState: updateActionState,
            useActionState: updateActionState,
            useOptimistic: function (passthrough, reducer) {
              var hook = updateWorkInProgressHook();
              return updateOptimisticImpl(
                hook,
                currentHook,
                passthrough,
                reducer,
              );
            },
            useMemoCache: useMemoCache,
            useCacheRefresh: updateRefresh,
          };
        HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
        var HooksDispatcherOnRerender = {
          readContext: readContext,
          use: use,
          useCallback: updateCallback,
          useContext: readContext,
          useEffect: updateEffect,
          useImperativeHandle: updateImperativeHandle,
          useInsertionEffect: updateInsertionEffect,
          useLayoutEffect: updateLayoutEffect,
          useMemo: updateMemo,
          useReducer: rerenderReducer,
          useRef: updateRef,
          useState: function () {
            return rerenderReducer(basicStateReducer);
          },
          useDebugValue: mountDebugValue,
          useDeferredValue: function (value, initialValue) {
            var hook = updateWorkInProgressHook();
            return null === currentHook
              ? mountDeferredValueImpl(hook, value, initialValue)
              : updateDeferredValueImpl(
                  hook,
                  currentHook.memoizedState,
                  value,
                  initialValue,
                );
          },
          useTransition: function () {
            var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
              start = updateWorkInProgressHook().memoizedState;
            return [
              'boolean' === typeof booleanOrThenable
                ? booleanOrThenable
                : useThenable(booleanOrThenable),
              start,
            ];
          },
          useSyncExternalStore: updateSyncExternalStore,
          useId: updateId,
          useHostTransitionStatus: useHostTransitionStatus,
          useFormState: rerenderActionState,
          useActionState: rerenderActionState,
          useOptimistic: function (passthrough, reducer) {
            var hook = updateWorkInProgressHook();
            if (null !== currentHook)
              return updateOptimisticImpl(
                hook,
                currentHook,
                passthrough,
                reducer,
              );
            hook.baseState = passthrough;
            return [passthrough, hook.queue.dispatch];
          },
          useMemoCache: useMemoCache,
          useCacheRefresh: updateRefresh,
        };
        HooksDispatcherOnRerender.useEffectEvent = updateEvent;
        function applyDerivedStateFromProps(
          workInProgress,
          ctor,
          getDerivedStateFromProps,
          nextProps,
        ) {
          ctor = workInProgress.memoizedState;
          getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
          getDerivedStateFromProps =
            null === getDerivedStateFromProps ||
            void 0 === getDerivedStateFromProps
              ? ctor
              : assign({}, ctor, getDerivedStateFromProps);
          workInProgress.memoizedState = getDerivedStateFromProps;
          0 === workInProgress.lanes &&
            (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
        }
        var classComponentUpdater = {
          enqueueSetState: function (inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(),
              update = createUpdate(lane);
            update.payload = payload;
            void 0 !== callback &&
              null !== callback &&
              (update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload &&
              (scheduleUpdateOnFiber(payload, inst, lane),
              entangleTransitions(payload, inst, lane));
          },
          enqueueReplaceState: function (inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(),
              update = createUpdate(lane);
            update.tag = 1;
            update.payload = payload;
            void 0 !== callback &&
              null !== callback &&
              (update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload &&
              (scheduleUpdateOnFiber(payload, inst, lane),
              entangleTransitions(payload, inst, lane));
          },
          enqueueForceUpdate: function (inst, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(),
              update = createUpdate(lane);
            update.tag = 2;
            void 0 !== callback &&
              null !== callback &&
              (update.callback = callback);
            callback = enqueueUpdate(inst, update, lane);
            null !== callback &&
              (scheduleUpdateOnFiber(callback, inst, lane),
              entangleTransitions(callback, inst, lane));
          },
        };
        function checkShouldComponentUpdate(
          workInProgress,
          ctor,
          oldProps,
          newProps,
          oldState,
          newState,
          nextContext,
        ) {
          workInProgress = workInProgress.stateNode;
          return 'function' === typeof workInProgress.shouldComponentUpdate
            ? workInProgress.shouldComponentUpdate(
                newProps,
                newState,
                nextContext,
              )
            : ctor.prototype && ctor.prototype.isPureReactComponent
              ? !shallowEqual(oldProps, newProps) ||
                !shallowEqual(oldState, newState)
              : !0;
        }
        function callComponentWillReceiveProps(
          workInProgress,
          instance,
          newProps,
          nextContext,
        ) {
          workInProgress = instance.state;
          'function' === typeof instance.componentWillReceiveProps &&
            instance.componentWillReceiveProps(newProps, nextContext);
          'function' === typeof instance.UNSAFE_componentWillReceiveProps &&
            instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          instance.state !== workInProgress &&
            classComponentUpdater.enqueueReplaceState(
              instance,
              instance.state,
              null,
            );
        }
        function resolveClassComponentProps(Component, baseProps) {
          var newProps = baseProps;
          if ('ref' in baseProps) {
            newProps = {};
            for (var propName in baseProps)
              'ref' !== propName && (newProps[propName] = baseProps[propName]);
          }
          if ((Component = Component.defaultProps)) {
            newProps === baseProps && (newProps = assign({}, newProps));
            for (var propName$73 in Component)
              void 0 === newProps[propName$73] &&
                (newProps[propName$73] = Component[propName$73]);
          }
          return newProps;
        }
        function defaultOnUncaughtError(error) {
          reportGlobalError(error);
        }
        function defaultOnCaughtError(error) {
          console.error(error);
        }
        function defaultOnRecoverableError(error) {
          reportGlobalError(error);
        }
        function logUncaughtError(root, errorInfo) {
          try {
            var onUncaughtError = root.onUncaughtError;
            onUncaughtError(errorInfo.value, {
              componentStack: errorInfo.stack,
            });
          } catch (e$74) {
            setTimeout(function () {
              throw e$74;
            });
          }
        }
        function logCaughtError(root, boundary, errorInfo) {
          try {
            var onCaughtError = root.onCaughtError;
            onCaughtError(errorInfo.value, {
              componentStack: errorInfo.stack,
              errorBoundary: 1 === boundary.tag ? boundary.stateNode : null,
            });
          } catch (e$75) {
            setTimeout(function () {
              throw e$75;
            });
          }
        }
        function createRootErrorUpdate(root, errorInfo, lane) {
          lane = createUpdate(lane);
          lane.tag = 3;
          lane.payload = { element: null };
          lane.callback = function () {
            logUncaughtError(root, errorInfo);
          };
          return lane;
        }
        function createClassErrorUpdate(lane) {
          lane = createUpdate(lane);
          lane.tag = 3;
          return lane;
        }
        function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if ('function' === typeof getDerivedStateFromError) {
            var error = errorInfo.value;
            update.payload = function () {
              return getDerivedStateFromError(error);
            };
            update.callback = function () {
              logCaughtError(root, fiber, errorInfo);
            };
          }
          var inst = fiber.stateNode;
          null !== inst &&
            'function' === typeof inst.componentDidCatch &&
            (update.callback = function () {
              logCaughtError(root, fiber, errorInfo);
              'function' !== typeof getDerivedStateFromError &&
                (null === legacyErrorBoundariesThatAlreadyFailed
                  ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
                  : legacyErrorBoundariesThatAlreadyFailed.add(this));
              var stack = errorInfo.stack;
              this.componentDidCatch(errorInfo.value, {
                componentStack: null !== stack ? stack : '',
              });
            });
        }
        function throwException(
          root,
          returnFiber,
          sourceFiber,
          value,
          rootRenderLanes,
        ) {
          sourceFiber.flags |= 32768;
          if (
            null !== value &&
            'object' === typeof value &&
            'function' === typeof value.then
          ) {
            returnFiber = sourceFiber.alternate;
            null !== returnFiber &&
              propagateParentContextChanges(
                returnFiber,
                sourceFiber,
                rootRenderLanes,
                !0,
              );
            sourceFiber = suspenseHandlerStackCursor.current;
            if (null !== sourceFiber) {
              switch (sourceFiber.tag) {
                case 31:
                case 13:
                  return (
                    null === shellBoundary
                      ? renderDidSuspendDelayIfPossible()
                      : null === sourceFiber.alternate &&
                        0 === workInProgressRootExitStatus &&
                        (workInProgressRootExitStatus = 3),
                    (sourceFiber.flags &= -257),
                    (sourceFiber.flags |= 65536),
                    (sourceFiber.lanes = rootRenderLanes),
                    value === noopSuspenseyCommitThenable
                      ? (sourceFiber.flags |= 16384)
                      : ((returnFiber = sourceFiber.updateQueue),
                        null === returnFiber
                          ? (sourceFiber.updateQueue = new Set([value]))
                          : returnFiber.add(value),
                        attachPingListener(root, value, rootRenderLanes)),
                    !1
                  );
                case 22:
                  return (
                    (sourceFiber.flags |= 65536),
                    value === noopSuspenseyCommitThenable
                      ? (sourceFiber.flags |= 16384)
                      : ((returnFiber = sourceFiber.updateQueue),
                        null === returnFiber
                          ? ((returnFiber = {
                              transitions: null,
                              markerInstances: null,
                              retryQueue: new Set([value]),
                            }),
                            (sourceFiber.updateQueue = returnFiber))
                          : ((sourceFiber = returnFiber.retryQueue),
                            null === sourceFiber
                              ? (returnFiber.retryQueue = new Set([value]))
                              : sourceFiber.add(value)),
                        attachPingListener(root, value, rootRenderLanes)),
                    !1
                  );
              }
              throw Error(formatProdErrorMessage(435, sourceFiber.tag));
            }
            attachPingListener(root, value, rootRenderLanes);
            renderDidSuspendDelayIfPossible();
            return !1;
          }
          if (isHydrating)
            return (
              (returnFiber = suspenseHandlerStackCursor.current),
              null !== returnFiber
                ? (0 === (returnFiber.flags & 65536) &&
                    (returnFiber.flags |= 256),
                  (returnFiber.flags |= 65536),
                  (returnFiber.lanes = rootRenderLanes),
                  value !== HydrationMismatchException &&
                    ((root = Error(formatProdErrorMessage(422), {
                      cause: value,
                    })),
                    queueHydrationError(
                      createCapturedValueAtFiber(root, sourceFiber),
                    )))
                : (value !== HydrationMismatchException &&
                    ((returnFiber = Error(formatProdErrorMessage(423), {
                      cause: value,
                    })),
                    queueHydrationError(
                      createCapturedValueAtFiber(returnFiber, sourceFiber),
                    )),
                  (root = root.current.alternate),
                  (root.flags |= 65536),
                  (rootRenderLanes &= -rootRenderLanes),
                  (root.lanes |= rootRenderLanes),
                  (value = createCapturedValueAtFiber(value, sourceFiber)),
                  (rootRenderLanes = createRootErrorUpdate(
                    root.stateNode,
                    value,
                    rootRenderLanes,
                  )),
                  enqueueCapturedUpdate(root, rootRenderLanes),
                  4 !== workInProgressRootExitStatus &&
                    (workInProgressRootExitStatus = 2)),
              !1
            );
          var wrapperError = Error(formatProdErrorMessage(520), {
            cause: value,
          });
          wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
          null === workInProgressRootConcurrentErrors
            ? (workInProgressRootConcurrentErrors = [wrapperError])
            : workInProgressRootConcurrentErrors.push(wrapperError);
          4 !== workInProgressRootExitStatus &&
            (workInProgressRootExitStatus = 2);
          if (null === returnFiber) return !0;
          value = createCapturedValueAtFiber(value, sourceFiber);
          sourceFiber = returnFiber;
          do {
            switch (sourceFiber.tag) {
              case 3:
                return (
                  (sourceFiber.flags |= 65536),
                  (root = rootRenderLanes & -rootRenderLanes),
                  (sourceFiber.lanes |= root),
                  (root = createRootErrorUpdate(
                    sourceFiber.stateNode,
                    value,
                    root,
                  )),
                  enqueueCapturedUpdate(sourceFiber, root),
                  !1
                );
              case 1:
                if (
                  ((returnFiber = sourceFiber.type),
                  (wrapperError = sourceFiber.stateNode),
                  0 === (sourceFiber.flags & 128) &&
                    ('function' ===
                      typeof returnFiber.getDerivedStateFromError ||
                      (null !== wrapperError &&
                        'function' === typeof wrapperError.componentDidCatch &&
                        (null === legacyErrorBoundariesThatAlreadyFailed ||
                          !legacyErrorBoundariesThatAlreadyFailed.has(
                            wrapperError,
                          )))))
                )
                  return (
                    (sourceFiber.flags |= 65536),
                    (rootRenderLanes &= -rootRenderLanes),
                    (sourceFiber.lanes |= rootRenderLanes),
                    (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
                    initializeClassErrorUpdate(
                      rootRenderLanes,
                      root,
                      sourceFiber,
                      value,
                    ),
                    enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
                    !1
                  );
            }
            sourceFiber = sourceFiber.return;
          } while (null !== sourceFiber);
          return !1;
        }
        var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
          didReceiveUpdate = !1;
        function reconcileChildren(
          current,
          workInProgress,
          nextChildren,
          renderLanes,
        ) {
          workInProgress.child =
            null === current
              ? mountChildFibers(
                  workInProgress,
                  null,
                  nextChildren,
                  renderLanes,
                )
              : reconcileChildFibers(
                  workInProgress,
                  current.child,
                  nextChildren,
                  renderLanes,
                );
        }
        function updateForwardRef(
          current,
          workInProgress,
          Component,
          nextProps,
          renderLanes,
        ) {
          Component = Component.render;
          var ref = workInProgress.ref;
          if ('ref' in nextProps) {
            var propsWithoutRef = {};
            for (var key in nextProps)
              'ref' !== key && (propsWithoutRef[key] = nextProps[key]);
          } else propsWithoutRef = nextProps;
          prepareToReadContext(workInProgress);
          nextProps = renderWithHooks(
            current,
            workInProgress,
            Component,
            propsWithoutRef,
            ref,
            renderLanes,
          );
          key = checkDidRenderIdHook();
          if (null !== current && !didReceiveUpdate)
            return (
              bailoutHooks(current, workInProgress, renderLanes),
              bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
            );
          isHydrating && key && pushMaterializedTreeId(workInProgress);
          workInProgress.flags |= 1;
          reconcileChildren(current, workInProgress, nextProps, renderLanes);
          return workInProgress.child;
        }
        function updateMemoComponent(
          current,
          workInProgress,
          Component,
          nextProps,
          renderLanes,
        ) {
          if (null === current) {
            var type = Component.type;
            if (
              'function' === typeof type &&
              !shouldConstruct(type) &&
              void 0 === type.defaultProps &&
              null === Component.compare
            )
              return (
                (workInProgress.tag = 15),
                (workInProgress.type = type),
                updateSimpleMemoComponent(
                  current,
                  workInProgress,
                  type,
                  nextProps,
                  renderLanes,
                )
              );
            current = createFiberFromTypeAndProps(
              Component.type,
              null,
              nextProps,
              workInProgress,
              workInProgress.mode,
              renderLanes,
            );
            current.ref = workInProgress.ref;
            current.return = workInProgress;
            return (workInProgress.child = current);
          }
          type = current.child;
          if (!checkScheduledUpdateOrContext(current, renderLanes)) {
            var prevProps = type.memoizedProps;
            Component = Component.compare;
            Component = null !== Component ? Component : shallowEqual;
            if (
              Component(prevProps, nextProps) &&
              current.ref === workInProgress.ref
            )
              return bailoutOnAlreadyFinishedWork(
                current,
                workInProgress,
                renderLanes,
              );
          }
          workInProgress.flags |= 1;
          current = createWorkInProgress(type, nextProps);
          current.ref = workInProgress.ref;
          current.return = workInProgress;
          return (workInProgress.child = current);
        }
        function updateSimpleMemoComponent(
          current,
          workInProgress,
          Component,
          nextProps,
          renderLanes,
        ) {
          if (null !== current) {
            var prevProps = current.memoizedProps;
            if (
              shallowEqual(prevProps, nextProps) &&
              current.ref === workInProgress.ref
            )
              if (
                ((didReceiveUpdate = !1),
                (workInProgress.pendingProps = nextProps = prevProps),
                checkScheduledUpdateOrContext(current, renderLanes))
              )
                0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
              else
                return (
                  (workInProgress.lanes = current.lanes),
                  bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress,
                    renderLanes,
                  )
                );
          }
          return updateFunctionComponent(
            current,
            workInProgress,
            Component,
            nextProps,
            renderLanes,
          );
        }
        function updateOffscreenComponent(
          current,
          workInProgress,
          renderLanes,
          nextProps,
        ) {
          var nextChildren = nextProps.children,
            prevState = null !== current ? current.memoizedState : null;
          null === current &&
            null === workInProgress.stateNode &&
            (workInProgress.stateNode = {
              _visibility: 1,
              _pendingMarkers: null,
              _retryCache: null,
              _transitions: null,
            });
          if ('hidden' === nextProps.mode) {
            if (0 !== (workInProgress.flags & 128)) {
              prevState =
                null !== prevState
                  ? prevState.baseLanes | renderLanes
                  : renderLanes;
              if (null !== current) {
                nextProps = workInProgress.child = current.child;
                for (nextChildren = 0; null !== nextProps; )
                  (nextChildren =
                    nextChildren | nextProps.lanes | nextProps.childLanes),
                    (nextProps = nextProps.sibling);
                nextProps = nextChildren & ~prevState;
              } else (nextProps = 0), (workInProgress.child = null);
              return deferHiddenOffscreenComponent(
                current,
                workInProgress,
                prevState,
                renderLanes,
                nextProps,
              );
            }
            if (0 !== (renderLanes & 536870912))
              (workInProgress.memoizedState = {
                baseLanes: 0,
                cachePool: null,
              }),
                null !== current &&
                  pushTransition(
                    workInProgress,
                    null !== prevState ? prevState.cachePool : null,
                  ),
                null !== prevState
                  ? pushHiddenContext(workInProgress, prevState)
                  : reuseHiddenContextOnStack(),
                pushOffscreenSuspenseHandler(workInProgress);
            else
              return (
                (nextProps = workInProgress.lanes = 536870912),
                deferHiddenOffscreenComponent(
                  current,
                  workInProgress,
                  null !== prevState
                    ? prevState.baseLanes | renderLanes
                    : renderLanes,
                  renderLanes,
                  nextProps,
                )
              );
          } else
            null !== prevState
              ? (pushTransition(workInProgress, prevState.cachePool),
                pushHiddenContext(workInProgress, prevState),
                reuseSuspenseHandlerOnStack(workInProgress),
                (workInProgress.memoizedState = null))
              : (null !== current && pushTransition(workInProgress, null),
                reuseHiddenContextOnStack(),
                reuseSuspenseHandlerOnStack(workInProgress));
          reconcileChildren(current, workInProgress, nextChildren, renderLanes);
          return workInProgress.child;
        }
        function bailoutOffscreenComponent(current, workInProgress) {
          (null !== current && 22 === current.tag) ||
            null !== workInProgress.stateNode ||
            (workInProgress.stateNode = {
              _visibility: 1,
              _pendingMarkers: null,
              _retryCache: null,
              _transitions: null,
            });
          return workInProgress.sibling;
        }
        function deferHiddenOffscreenComponent(
          current,
          workInProgress,
          nextBaseLanes,
          renderLanes,
          remainingChildLanes,
        ) {
          var JSCompiler_inline_result = peekCacheFromPool();
          JSCompiler_inline_result =
            null === JSCompiler_inline_result
              ? null
              : {
                  parent: CacheContext._currentValue,
                  pool: JSCompiler_inline_result,
                };
          workInProgress.memoizedState = {
            baseLanes: nextBaseLanes,
            cachePool: JSCompiler_inline_result,
          };
          null !== current && pushTransition(workInProgress, null);
          reuseHiddenContextOnStack();
          pushOffscreenSuspenseHandler(workInProgress);
          null !== current &&
            propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              !0,
            );
          workInProgress.childLanes = remainingChildLanes;
          return null;
        }
        function mountActivityChildren(workInProgress, nextProps) {
          nextProps = mountWorkInProgressOffscreenFiber(
            { mode: nextProps.mode, children: nextProps.children },
            workInProgress.mode,
          );
          nextProps.ref = workInProgress.ref;
          workInProgress.child = nextProps;
          nextProps.return = workInProgress;
          return nextProps;
        }
        function retryActivityComponentWithoutHydrating(
          current,
          workInProgress,
          renderLanes,
        ) {
          reconcileChildFibers(
            workInProgress,
            current.child,
            null,
            renderLanes,
          );
          current = mountActivityChildren(
            workInProgress,
            workInProgress.pendingProps,
          );
          current.flags |= 2;
          popSuspenseHandler(workInProgress);
          workInProgress.memoizedState = null;
          return current;
        }
        function updateActivityComponent(current, workInProgress, renderLanes) {
          var nextProps = workInProgress.pendingProps,
            didSuspend = 0 !== (workInProgress.flags & 128);
          workInProgress.flags &= -129;
          if (null === current) {
            if (isHydrating) {
              if ('hidden' === nextProps.mode)
                return (
                  (current = mountActivityChildren(workInProgress, nextProps)),
                  (workInProgress.lanes = 536870912),
                  bailoutOffscreenComponent(null, current)
                );
              pushDehydratedActivitySuspenseHandler(workInProgress);
              (current = nextHydratableInstance)
                ? ((current = canHydrateHydrationBoundary(
                    current,
                    rootOrSingletonContext,
                  )),
                  (current =
                    null !== current && '&' === current.data ? current : null),
                  null !== current &&
                    ((workInProgress.memoizedState = {
                      dehydrated: current,
                      treeContext:
                        null !== treeContextProvider
                          ? { id: treeContextId, overflow: treeContextOverflow }
                          : null,
                      retryLane: 536870912,
                      hydrationErrors: null,
                    }),
                    (renderLanes = createFiberFromDehydratedFragment(current)),
                    (renderLanes.return = workInProgress),
                    (workInProgress.child = renderLanes),
                    (hydrationParentFiber = workInProgress),
                    (nextHydratableInstance = null)))
                : (current = null);
              if (null === current)
                throw throwOnHydrationMismatch(workInProgress);
              workInProgress.lanes = 536870912;
              return null;
            }
            return mountActivityChildren(workInProgress, nextProps);
          }
          var prevState = current.memoizedState;
          if (null !== prevState) {
            var dehydrated = prevState.dehydrated;
            pushDehydratedActivitySuspenseHandler(workInProgress);
            if (didSuspend)
              if (workInProgress.flags & 256)
                (workInProgress.flags &= -257),
                  (workInProgress = retryActivityComponentWithoutHydrating(
                    current,
                    workInProgress,
                    renderLanes,
                  ));
              else if (null !== workInProgress.memoizedState)
                (workInProgress.child = current.child),
                  (workInProgress.flags |= 128),
                  (workInProgress = null);
              else throw Error(formatProdErrorMessage(558));
            else if (
              (didReceiveUpdate ||
                propagateParentContextChanges(
                  current,
                  workInProgress,
                  renderLanes,
                  !1,
                ),
              (didSuspend = 0 !== (renderLanes & current.childLanes)),
              didReceiveUpdate || didSuspend)
            ) {
              nextProps = workInProgressRoot;
              if (
                null !== nextProps &&
                ((dehydrated = getBumpedLaneForHydration(
                  nextProps,
                  renderLanes,
                )),
                0 !== dehydrated && dehydrated !== prevState.retryLane)
              )
                throw (
                  ((prevState.retryLane = dehydrated),
                  enqueueConcurrentRenderForLane(current, dehydrated),
                  scheduleUpdateOnFiber(nextProps, current, dehydrated),
                  SelectiveHydrationException)
                );
              renderDidSuspendDelayIfPossible();
              workInProgress = retryActivityComponentWithoutHydrating(
                current,
                workInProgress,
                renderLanes,
              );
            } else
              (current = prevState.treeContext),
                (nextHydratableInstance = getNextHydratable(
                  dehydrated.nextSibling,
                )),
                (hydrationParentFiber = workInProgress),
                (isHydrating = !0),
                (hydrationErrors = null),
                (rootOrSingletonContext = !1),
                null !== current &&
                  restoreSuspendedTreeContext(workInProgress, current),
                (workInProgress = mountActivityChildren(
                  workInProgress,
                  nextProps,
                )),
                (workInProgress.flags |= 4096);
            return workInProgress;
          }
          current = createWorkInProgress(current.child, {
            mode: nextProps.mode,
            children: nextProps.children,
          });
          current.ref = workInProgress.ref;
          workInProgress.child = current;
          current.return = workInProgress;
          return current;
        }
        function markRef(current, workInProgress) {
          var ref = workInProgress.ref;
          if (null === ref)
            null !== current &&
              null !== current.ref &&
              (workInProgress.flags |= 4194816);
          else {
            if ('function' !== typeof ref && 'object' !== typeof ref)
              throw Error(formatProdErrorMessage(284));
            if (null === current || current.ref !== ref)
              workInProgress.flags |= 4194816;
          }
        }
        function updateFunctionComponent(
          current,
          workInProgress,
          Component,
          nextProps,
          renderLanes,
        ) {
          prepareToReadContext(workInProgress);
          Component = renderWithHooks(
            current,
            workInProgress,
            Component,
            nextProps,
            void 0,
            renderLanes,
          );
          nextProps = checkDidRenderIdHook();
          if (null !== current && !didReceiveUpdate)
            return (
              bailoutHooks(current, workInProgress, renderLanes),
              bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
            );
          isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
          workInProgress.flags |= 1;
          reconcileChildren(current, workInProgress, Component, renderLanes);
          return workInProgress.child;
        }
        function replayFunctionComponent(
          current,
          workInProgress,
          nextProps,
          Component,
          secondArg,
          renderLanes,
        ) {
          prepareToReadContext(workInProgress);
          workInProgress.updateQueue = null;
          nextProps = renderWithHooksAgain(
            workInProgress,
            Component,
            nextProps,
            secondArg,
          );
          finishRenderingHooks(current);
          Component = checkDidRenderIdHook();
          if (null !== current && !didReceiveUpdate)
            return (
              bailoutHooks(current, workInProgress, renderLanes),
              bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
            );
          isHydrating && Component && pushMaterializedTreeId(workInProgress);
          workInProgress.flags |= 1;
          reconcileChildren(current, workInProgress, nextProps, renderLanes);
          return workInProgress.child;
        }
        function updateClassComponent(
          current,
          workInProgress,
          Component,
          nextProps,
          renderLanes,
        ) {
          prepareToReadContext(workInProgress);
          if (null === workInProgress.stateNode) {
            var context = emptyContextObject,
              contextType = Component.contextType;
            'object' === typeof contextType &&
              null !== contextType &&
              (context = readContext(contextType));
            context = new Component(nextProps, context);
            workInProgress.memoizedState =
              null !== context.state && void 0 !== context.state
                ? context.state
                : null;
            context.updater = classComponentUpdater;
            workInProgress.stateNode = context;
            context._reactInternals = workInProgress;
            context = workInProgress.stateNode;
            context.props = nextProps;
            context.state = workInProgress.memoizedState;
            context.refs = {};
            initializeUpdateQueue(workInProgress);
            contextType = Component.contextType;
            context.context =
              'object' === typeof contextType && null !== contextType
                ? readContext(contextType)
                : emptyContextObject;
            context.state = workInProgress.memoizedState;
            contextType = Component.getDerivedStateFromProps;
            'function' === typeof contextType &&
              (applyDerivedStateFromProps(
                workInProgress,
                Component,
                contextType,
                nextProps,
              ),
              (context.state = workInProgress.memoizedState));
            'function' === typeof Component.getDerivedStateFromProps ||
              'function' === typeof context.getSnapshotBeforeUpdate ||
              ('function' !== typeof context.UNSAFE_componentWillMount &&
                'function' !== typeof context.componentWillMount) ||
              ((contextType = context.state),
              'function' === typeof context.componentWillMount &&
                context.componentWillMount(),
              'function' === typeof context.UNSAFE_componentWillMount &&
                context.UNSAFE_componentWillMount(),
              contextType !== context.state &&
                classComponentUpdater.enqueueReplaceState(
                  context,
                  context.state,
                  null,
                ),
              processUpdateQueue(
                workInProgress,
                nextProps,
                context,
                renderLanes,
              ),
              suspendIfUpdateReadFromEntangledAsyncAction(),
              (context.state = workInProgress.memoizedState));
            'function' === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308);
            nextProps = !0;
          } else if (null === current) {
            context = workInProgress.stateNode;
            var unresolvedOldProps = workInProgress.memoizedProps,
              oldProps = resolveClassComponentProps(
                Component,
                unresolvedOldProps,
              );
            context.props = oldProps;
            var oldContext = context.context,
              contextType$jscomp$0 = Component.contextType;
            contextType = emptyContextObject;
            'object' === typeof contextType$jscomp$0 &&
              null !== contextType$jscomp$0 &&
              (contextType = readContext(contextType$jscomp$0));
            var getDerivedStateFromProps = Component.getDerivedStateFromProps;
            contextType$jscomp$0 =
              'function' === typeof getDerivedStateFromProps ||
              'function' === typeof context.getSnapshotBeforeUpdate;
            unresolvedOldProps =
              workInProgress.pendingProps !== unresolvedOldProps;
            contextType$jscomp$0 ||
              ('function' !== typeof context.UNSAFE_componentWillReceiveProps &&
                'function' !== typeof context.componentWillReceiveProps) ||
              ((unresolvedOldProps || oldContext !== contextType) &&
                callComponentWillReceiveProps(
                  workInProgress,
                  context,
                  nextProps,
                  contextType,
                ));
            hasForceUpdate = !1;
            var oldState = workInProgress.memoizedState;
            context.state = oldState;
            processUpdateQueue(workInProgress, nextProps, context, renderLanes);
            suspendIfUpdateReadFromEntangledAsyncAction();
            oldContext = workInProgress.memoizedState;
            unresolvedOldProps || oldState !== oldContext || hasForceUpdate
              ? ('function' === typeof getDerivedStateFromProps &&
                  (applyDerivedStateFromProps(
                    workInProgress,
                    Component,
                    getDerivedStateFromProps,
                    nextProps,
                  ),
                  (oldContext = workInProgress.memoizedState)),
                (oldProps =
                  hasForceUpdate ||
                  checkShouldComponentUpdate(
                    workInProgress,
                    Component,
                    oldProps,
                    nextProps,
                    oldState,
                    oldContext,
                    contextType,
                  ))
                  ? (contextType$jscomp$0 ||
                      ('function' !==
                        typeof context.UNSAFE_componentWillMount &&
                        'function' !== typeof context.componentWillMount) ||
                      ('function' === typeof context.componentWillMount &&
                        context.componentWillMount(),
                      'function' === typeof context.UNSAFE_componentWillMount &&
                        context.UNSAFE_componentWillMount()),
                    'function' === typeof context.componentDidMount &&
                      (workInProgress.flags |= 4194308))
                  : ('function' === typeof context.componentDidMount &&
                      (workInProgress.flags |= 4194308),
                    (workInProgress.memoizedProps = nextProps),
                    (workInProgress.memoizedState = oldContext)),
                (context.props = nextProps),
                (context.state = oldContext),
                (context.context = contextType),
                (nextProps = oldProps))
              : ('function' === typeof context.componentDidMount &&
                  (workInProgress.flags |= 4194308),
                (nextProps = !1));
          } else {
            context = workInProgress.stateNode;
            cloneUpdateQueue(current, workInProgress);
            contextType = workInProgress.memoizedProps;
            contextType$jscomp$0 = resolveClassComponentProps(
              Component,
              contextType,
            );
            context.props = contextType$jscomp$0;
            getDerivedStateFromProps = workInProgress.pendingProps;
            oldState = context.context;
            oldContext = Component.contextType;
            oldProps = emptyContextObject;
            'object' === typeof oldContext &&
              null !== oldContext &&
              (oldProps = readContext(oldContext));
            unresolvedOldProps = Component.getDerivedStateFromProps;
            (oldContext =
              'function' === typeof unresolvedOldProps ||
              'function' === typeof context.getSnapshotBeforeUpdate) ||
              ('function' !== typeof context.UNSAFE_componentWillReceiveProps &&
                'function' !== typeof context.componentWillReceiveProps) ||
              ((contextType !== getDerivedStateFromProps ||
                oldState !== oldProps) &&
                callComponentWillReceiveProps(
                  workInProgress,
                  context,
                  nextProps,
                  oldProps,
                ));
            hasForceUpdate = !1;
            oldState = workInProgress.memoizedState;
            context.state = oldState;
            processUpdateQueue(workInProgress, nextProps, context, renderLanes);
            suspendIfUpdateReadFromEntangledAsyncAction();
            var newState = workInProgress.memoizedState;
            contextType !== getDerivedStateFromProps ||
            oldState !== newState ||
            hasForceUpdate ||
            (null !== current &&
              null !== current.dependencies &&
              checkIfContextChanged(current.dependencies))
              ? ('function' === typeof unresolvedOldProps &&
                  (applyDerivedStateFromProps(
                    workInProgress,
                    Component,
                    unresolvedOldProps,
                    nextProps,
                  ),
                  (newState = workInProgress.memoizedState)),
                (contextType$jscomp$0 =
                  hasForceUpdate ||
                  checkShouldComponentUpdate(
                    workInProgress,
                    Component,
                    contextType$jscomp$0,
                    nextProps,
                    oldState,
                    newState,
                    oldProps,
                  ) ||
                  (null !== current &&
                    null !== current.dependencies &&
                    checkIfContextChanged(current.dependencies)))
                  ? (oldContext ||
                      ('function' !==
                        typeof context.UNSAFE_componentWillUpdate &&
                        'function' !== typeof context.componentWillUpdate) ||
                      ('function' === typeof context.componentWillUpdate &&
                        context.componentWillUpdate(
                          nextProps,
                          newState,
                          oldProps,
                        ),
                      'function' ===
                        typeof context.UNSAFE_componentWillUpdate &&
                        context.UNSAFE_componentWillUpdate(
                          nextProps,
                          newState,
                          oldProps,
                        )),
                    'function' === typeof context.componentDidUpdate &&
                      (workInProgress.flags |= 4),
                    'function' === typeof context.getSnapshotBeforeUpdate &&
                      (workInProgress.flags |= 1024))
                  : ('function' !== typeof context.componentDidUpdate ||
                      (contextType === current.memoizedProps &&
                        oldState === current.memoizedState) ||
                      (workInProgress.flags |= 4),
                    'function' !== typeof context.getSnapshotBeforeUpdate ||
                      (contextType === current.memoizedProps &&
                        oldState === current.memoizedState) ||
                      (workInProgress.flags |= 1024),
                    (workInProgress.memoizedProps = nextProps),
                    (workInProgress.memoizedState = newState)),
                (context.props = nextProps),
                (context.state = newState),
                (context.context = oldProps),
                (nextProps = contextType$jscomp$0))
              : ('function' !== typeof context.componentDidUpdate ||
                  (contextType === current.memoizedProps &&
                    oldState === current.memoizedState) ||
                  (workInProgress.flags |= 4),
                'function' !== typeof context.getSnapshotBeforeUpdate ||
                  (contextType === current.memoizedProps &&
                    oldState === current.memoizedState) ||
                  (workInProgress.flags |= 1024),
                (nextProps = !1));
          }
          context = nextProps;
          markRef(current, workInProgress);
          nextProps = 0 !== (workInProgress.flags & 128);
          context || nextProps
            ? ((context = workInProgress.stateNode),
              (Component =
                nextProps &&
                'function' !== typeof Component.getDerivedStateFromError
                  ? null
                  : context.render()),
              (workInProgress.flags |= 1),
              null !== current && nextProps
                ? ((workInProgress.child = reconcileChildFibers(
                    workInProgress,
                    current.child,
                    null,
                    renderLanes,
                  )),
                  (workInProgress.child = reconcileChildFibers(
                    workInProgress,
                    null,
                    Component,
                    renderLanes,
                  )))
                : reconcileChildren(
                    current,
                    workInProgress,
                    Component,
                    renderLanes,
                  ),
              (workInProgress.memoizedState = context.state),
              (current = workInProgress.child))
            : (current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress,
                renderLanes,
              ));
          return current;
        }
        function mountHostRootWithoutHydrating(
          current,
          workInProgress,
          nextChildren,
          renderLanes,
        ) {
          resetHydrationState();
          workInProgress.flags |= 256;
          reconcileChildren(current, workInProgress, nextChildren, renderLanes);
          return workInProgress.child;
        }
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0,
          hydrationErrors: null,
        };
        function mountSuspenseOffscreenState(renderLanes) {
          return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
        }
        function getRemainingWorkInPrimaryTree(
          current,
          primaryTreeDidDefer,
          renderLanes,
        ) {
          current = null !== current ? current.childLanes & ~renderLanes : 0;
          primaryTreeDidDefer && (current |= workInProgressDeferredLane);
          return current;
        }
        function updateSuspenseComponent(current, workInProgress, renderLanes) {
          var nextProps = workInProgress.pendingProps,
            showFallback = !1,
            didSuspend = 0 !== (workInProgress.flags & 128),
            JSCompiler_temp;
          (JSCompiler_temp = didSuspend) ||
            (JSCompiler_temp =
              null !== current && null === current.memoizedState
                ? !1
                : 0 !== (suspenseStackCursor.current & 2));
          JSCompiler_temp &&
            ((showFallback = !0), (workInProgress.flags &= -129));
          JSCompiler_temp = 0 !== (workInProgress.flags & 32);
          workInProgress.flags &= -33;
          if (null === current) {
            if (isHydrating) {
              showFallback
                ? pushPrimaryTreeSuspenseHandler(workInProgress)
                : reuseSuspenseHandlerOnStack(workInProgress);
              (current = nextHydratableInstance)
                ? ((current = canHydrateHydrationBoundary(
                    current,
                    rootOrSingletonContext,
                  )),
                  (current =
                    null !== current && '&' !== current.data ? current : null),
                  null !== current &&
                    ((workInProgress.memoizedState = {
                      dehydrated: current,
                      treeContext:
                        null !== treeContextProvider
                          ? { id: treeContextId, overflow: treeContextOverflow }
                          : null,
                      retryLane: 536870912,
                      hydrationErrors: null,
                    }),
                    (renderLanes = createFiberFromDehydratedFragment(current)),
                    (renderLanes.return = workInProgress),
                    (workInProgress.child = renderLanes),
                    (hydrationParentFiber = workInProgress),
                    (nextHydratableInstance = null)))
                : (current = null);
              if (null === current)
                throw throwOnHydrationMismatch(workInProgress);
              isSuspenseInstanceFallback(current)
                ? (workInProgress.lanes = 32)
                : (workInProgress.lanes = 536870912);
              return null;
            }
            var nextPrimaryChildren = nextProps.children;
            nextProps = nextProps.fallback;
            if (showFallback)
              return (
                reuseSuspenseHandlerOnStack(workInProgress),
                (showFallback = workInProgress.mode),
                (nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
                  { mode: 'hidden', children: nextPrimaryChildren },
                  showFallback,
                )),
                (nextProps = createFiberFromFragment(
                  nextProps,
                  showFallback,
                  renderLanes,
                  null,
                )),
                (nextPrimaryChildren.return = workInProgress),
                (nextProps.return = workInProgress),
                (nextPrimaryChildren.sibling = nextProps),
                (workInProgress.child = nextPrimaryChildren),
                (nextProps = workInProgress.child),
                (nextProps.memoizedState =
                  mountSuspenseOffscreenState(renderLanes)),
                (nextProps.childLanes = getRemainingWorkInPrimaryTree(
                  current,
                  JSCompiler_temp,
                  renderLanes,
                )),
                (workInProgress.memoizedState = SUSPENDED_MARKER),
                bailoutOffscreenComponent(null, nextProps)
              );
            pushPrimaryTreeSuspenseHandler(workInProgress);
            return mountSuspensePrimaryChildren(
              workInProgress,
              nextPrimaryChildren,
            );
          }
          var prevState = current.memoizedState;
          if (
            null !== prevState &&
            ((nextPrimaryChildren = prevState.dehydrated),
            null !== nextPrimaryChildren)
          ) {
            if (didSuspend)
              workInProgress.flags & 256
                ? (pushPrimaryTreeSuspenseHandler(workInProgress),
                  (workInProgress.flags &= -257),
                  (workInProgress = retrySuspenseComponentWithoutHydrating(
                    current,
                    workInProgress,
                    renderLanes,
                  )))
                : null !== workInProgress.memoizedState
                  ? (reuseSuspenseHandlerOnStack(workInProgress),
                    (workInProgress.child = current.child),
                    (workInProgress.flags |= 128),
                    (workInProgress = null))
                  : (reuseSuspenseHandlerOnStack(workInProgress),
                    (nextPrimaryChildren = nextProps.fallback),
                    (showFallback = workInProgress.mode),
                    (nextProps = mountWorkInProgressOffscreenFiber(
                      { mode: 'visible', children: nextProps.children },
                      showFallback,
                    )),
                    (nextPrimaryChildren = createFiberFromFragment(
                      nextPrimaryChildren,
                      showFallback,
                      renderLanes,
                      null,
                    )),
                    (nextPrimaryChildren.flags |= 2),
                    (nextProps.return = workInProgress),
                    (nextPrimaryChildren.return = workInProgress),
                    (nextProps.sibling = nextPrimaryChildren),
                    (workInProgress.child = nextProps),
                    reconcileChildFibers(
                      workInProgress,
                      current.child,
                      null,
                      renderLanes,
                    ),
                    (nextProps = workInProgress.child),
                    (nextProps.memoizedState =
                      mountSuspenseOffscreenState(renderLanes)),
                    (nextProps.childLanes = getRemainingWorkInPrimaryTree(
                      current,
                      JSCompiler_temp,
                      renderLanes,
                    )),
                    (workInProgress.memoizedState = SUSPENDED_MARKER),
                    (workInProgress = bailoutOffscreenComponent(
                      null,
                      nextProps,
                    )));
            else if (
              (pushPrimaryTreeSuspenseHandler(workInProgress),
              isSuspenseInstanceFallback(nextPrimaryChildren))
            ) {
              JSCompiler_temp =
                nextPrimaryChildren.nextSibling &&
                nextPrimaryChildren.nextSibling.dataset;
              if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
              JSCompiler_temp = digest;
              nextProps = Error(formatProdErrorMessage(419));
              nextProps.stack = '';
              nextProps.digest = JSCompiler_temp;
              queueHydrationError({
                value: nextProps,
                source: null,
                stack: null,
              });
              workInProgress = retrySuspenseComponentWithoutHydrating(
                current,
                workInProgress,
                renderLanes,
              );
            } else if (
              (didReceiveUpdate ||
                propagateParentContextChanges(
                  current,
                  workInProgress,
                  renderLanes,
                  !1,
                ),
              (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
              didReceiveUpdate || JSCompiler_temp)
            ) {
              JSCompiler_temp = workInProgressRoot;
              if (
                null !== JSCompiler_temp &&
                ((nextProps = getBumpedLaneForHydration(
                  JSCompiler_temp,
                  renderLanes,
                )),
                0 !== nextProps && nextProps !== prevState.retryLane)
              )
                throw (
                  ((prevState.retryLane = nextProps),
                  enqueueConcurrentRenderForLane(current, nextProps),
                  scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
                  SelectiveHydrationException)
                );
              isSuspenseInstancePending(nextPrimaryChildren) ||
                renderDidSuspendDelayIfPossible();
              workInProgress = retrySuspenseComponentWithoutHydrating(
                current,
                workInProgress,
                renderLanes,
              );
            } else
              isSuspenseInstancePending(nextPrimaryChildren)
                ? ((workInProgress.flags |= 192),
                  (workInProgress.child = current.child),
                  (workInProgress = null))
                : ((current = prevState.treeContext),
                  (nextHydratableInstance = getNextHydratable(
                    nextPrimaryChildren.nextSibling,
                  )),
                  (hydrationParentFiber = workInProgress),
                  (isHydrating = !0),
                  (hydrationErrors = null),
                  (rootOrSingletonContext = !1),
                  null !== current &&
                    restoreSuspendedTreeContext(workInProgress, current),
                  (workInProgress = mountSuspensePrimaryChildren(
                    workInProgress,
                    nextProps.children,
                  )),
                  (workInProgress.flags |= 4096));
            return workInProgress;
          }
          if (showFallback)
            return (
              reuseSuspenseHandlerOnStack(workInProgress),
              (nextPrimaryChildren = nextProps.fallback),
              (showFallback = workInProgress.mode),
              (prevState = current.child),
              (digest = prevState.sibling),
              (nextProps = createWorkInProgress(prevState, {
                mode: 'hidden',
                children: nextProps.children,
              })),
              (nextProps.subtreeFlags = prevState.subtreeFlags & 65011712),
              null !== digest
                ? (nextPrimaryChildren = createWorkInProgress(
                    digest,
                    nextPrimaryChildren,
                  ))
                : ((nextPrimaryChildren = createFiberFromFragment(
                    nextPrimaryChildren,
                    showFallback,
                    renderLanes,
                    null,
                  )),
                  (nextPrimaryChildren.flags |= 2)),
              (nextPrimaryChildren.return = workInProgress),
              (nextProps.return = workInProgress),
              (nextProps.sibling = nextPrimaryChildren),
              (workInProgress.child = nextProps),
              bailoutOffscreenComponent(null, nextProps),
              (nextProps = workInProgress.child),
              (nextPrimaryChildren = current.child.memoizedState),
              null === nextPrimaryChildren
                ? (nextPrimaryChildren =
                    mountSuspenseOffscreenState(renderLanes))
                : ((showFallback = nextPrimaryChildren.cachePool),
                  null !== showFallback
                    ? ((prevState = CacheContext._currentValue),
                      (showFallback =
                        showFallback.parent !== prevState
                          ? { parent: prevState, pool: prevState }
                          : showFallback))
                    : (showFallback = getSuspendedCache()),
                  (nextPrimaryChildren = {
                    baseLanes: nextPrimaryChildren.baseLanes | renderLanes,
                    cachePool: showFallback,
                  })),
              (nextProps.memoizedState = nextPrimaryChildren),
              (nextProps.childLanes = getRemainingWorkInPrimaryTree(
                current,
                JSCompiler_temp,
                renderLanes,
              )),
              (workInProgress.memoizedState = SUSPENDED_MARKER),
              bailoutOffscreenComponent(current.child, nextProps)
            );
          pushPrimaryTreeSuspenseHandler(workInProgress);
          renderLanes = current.child;
          current = renderLanes.sibling;
          renderLanes = createWorkInProgress(renderLanes, {
            mode: 'visible',
            children: nextProps.children,
          });
          renderLanes.return = workInProgress;
          renderLanes.sibling = null;
          null !== current &&
            ((JSCompiler_temp = workInProgress.deletions),
            null === JSCompiler_temp
              ? ((workInProgress.deletions = [current]),
                (workInProgress.flags |= 16))
              : JSCompiler_temp.push(current));
          workInProgress.child = renderLanes;
          workInProgress.memoizedState = null;
          return renderLanes;
        }
        function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
          primaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: 'visible', children: primaryChildren },
            workInProgress.mode,
          );
          primaryChildren.return = workInProgress;
          return (workInProgress.child = primaryChildren);
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
          offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
          offscreenProps.lanes = 0;
          return offscreenProps;
        }
        function retrySuspenseComponentWithoutHydrating(
          current,
          workInProgress,
          renderLanes,
        ) {
          reconcileChildFibers(
            workInProgress,
            current.child,
            null,
            renderLanes,
          );
          current = mountSuspensePrimaryChildren(
            workInProgress,
            workInProgress.pendingProps.children,
          );
          current.flags |= 2;
          workInProgress.memoizedState = null;
          return current;
        }
        function scheduleSuspenseWorkOnFiber(
          fiber,
          renderLanes,
          propagationRoot,
        ) {
          fiber.lanes |= renderLanes;
          var alternate = fiber.alternate;
          null !== alternate && (alternate.lanes |= renderLanes);
          scheduleContextWorkOnParentPath(
            fiber.return,
            renderLanes,
            propagationRoot,
          );
        }
        function initSuspenseListRenderState(
          workInProgress,
          isBackwards,
          tail,
          lastContentRow,
          tailMode,
          treeForkCount,
        ) {
          var renderState = workInProgress.memoizedState;
          null === renderState
            ? (workInProgress.memoizedState = {
                isBackwards: isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail: tail,
                tailMode: tailMode,
                treeForkCount: treeForkCount,
              })
            : ((renderState.isBackwards = isBackwards),
              (renderState.rendering = null),
              (renderState.renderingStartTime = 0),
              (renderState.last = lastContentRow),
              (renderState.tail = tail),
              (renderState.tailMode = tailMode),
              (renderState.treeForkCount = treeForkCount));
        }
        function updateSuspenseListComponent(
          current,
          workInProgress,
          renderLanes,
        ) {
          var nextProps = workInProgress.pendingProps,
            revealOrder = nextProps.revealOrder,
            tailMode = nextProps.tail;
          nextProps = nextProps.children;
          var suspenseContext = suspenseStackCursor.current,
            shouldForceFallback = 0 !== (suspenseContext & 2);
          shouldForceFallback
            ? ((suspenseContext = (suspenseContext & 1) | 2),
              (workInProgress.flags |= 128))
            : (suspenseContext &= 1);
          push(suspenseStackCursor, suspenseContext);
          reconcileChildren(current, workInProgress, nextProps, renderLanes);
          nextProps = isHydrating ? treeForkCount : 0;
          if (
            !shouldForceFallback &&
            null !== current &&
            0 !== (current.flags & 128)
          )
            a: for (current = workInProgress.child; null !== current; ) {
              if (13 === current.tag)
                null !== current.memoizedState &&
                  scheduleSuspenseWorkOnFiber(
                    current,
                    renderLanes,
                    workInProgress,
                  );
              else if (19 === current.tag)
                scheduleSuspenseWorkOnFiber(
                  current,
                  renderLanes,
                  workInProgress,
                );
              else if (null !== current.child) {
                current.child.return = current;
                current = current.child;
                continue;
              }
              if (current === workInProgress) break a;
              for (; null === current.sibling; ) {
                if (
                  null === current.return ||
                  current.return === workInProgress
                )
                  break a;
                current = current.return;
              }
              current.sibling.return = current.return;
              current = current.sibling;
            }
          switch (revealOrder) {
            case 'forwards':
              renderLanes = workInProgress.child;
              for (revealOrder = null; null !== renderLanes; )
                (current = renderLanes.alternate),
                  null !== current &&
                    null === findFirstSuspended(current) &&
                    (revealOrder = renderLanes),
                  (renderLanes = renderLanes.sibling);
              renderLanes = revealOrder;
              null === renderLanes
                ? ((revealOrder = workInProgress.child),
                  (workInProgress.child = null))
                : ((revealOrder = renderLanes.sibling),
                  (renderLanes.sibling = null));
              initSuspenseListRenderState(
                workInProgress,
                !1,
                revealOrder,
                renderLanes,
                tailMode,
                nextProps,
              );
              break;
            case 'backwards':
            case 'unstable_legacy-backwards':
              renderLanes = null;
              revealOrder = workInProgress.child;
              for (workInProgress.child = null; null !== revealOrder; ) {
                current = revealOrder.alternate;
                if (null !== current && null === findFirstSuspended(current)) {
                  workInProgress.child = revealOrder;
                  break;
                }
                current = revealOrder.sibling;
                revealOrder.sibling = renderLanes;
                renderLanes = revealOrder;
                revealOrder = current;
              }
              initSuspenseListRenderState(
                workInProgress,
                !0,
                renderLanes,
                null,
                tailMode,
                nextProps,
              );
              break;
            case 'together':
              initSuspenseListRenderState(
                workInProgress,
                !1,
                null,
                null,
                void 0,
                nextProps,
              );
              break;
            default:
              workInProgress.memoizedState = null;
          }
          return workInProgress.child;
        }
        function bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderLanes,
        ) {
          null !== current &&
            (workInProgress.dependencies = current.dependencies);
          workInProgressRootSkippedLanes |= workInProgress.lanes;
          if (0 === (renderLanes & workInProgress.childLanes))
            if (null !== current) {
              if (
                (propagateParentContextChanges(
                  current,
                  workInProgress,
                  renderLanes,
                  !1,
                ),
                0 === (renderLanes & workInProgress.childLanes))
              )
                return null;
            } else return null;
          if (null !== current && workInProgress.child !== current.child)
            throw Error(formatProdErrorMessage(153));
          if (null !== workInProgress.child) {
            current = workInProgress.child;
            renderLanes = createWorkInProgress(current, current.pendingProps);
            workInProgress.child = renderLanes;
            for (
              renderLanes.return = workInProgress;
              null !== current.sibling;

            )
              (current = current.sibling),
                (renderLanes = renderLanes.sibling =
                  createWorkInProgress(current, current.pendingProps)),
                (renderLanes.return = workInProgress);
            renderLanes.sibling = null;
          }
          return workInProgress.child;
        }
        function checkScheduledUpdateOrContext(current, renderLanes) {
          if (0 !== (current.lanes & renderLanes)) return !0;
          current = current.dependencies;
          return null !== current && checkIfContextChanged(current) ? !0 : !1;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes,
        ) {
          switch (workInProgress.tag) {
            case 3:
              pushHostContainer(
                workInProgress,
                workInProgress.stateNode.containerInfo,
              );
              pushProvider(
                workInProgress,
                CacheContext,
                current.memoizedState.cache,
              );
              resetHydrationState();
              break;
            case 27:
            case 5:
              pushHostContext(workInProgress);
              break;
            case 4:
              pushHostContainer(
                workInProgress,
                workInProgress.stateNode.containerInfo,
              );
              break;
            case 10:
              pushProvider(
                workInProgress,
                workInProgress.type,
                workInProgress.memoizedProps.value,
              );
              break;
            case 31:
              if (null !== workInProgress.memoizedState)
                return (
                  (workInProgress.flags |= 128),
                  pushDehydratedActivitySuspenseHandler(workInProgress),
                  null
                );
              break;
            case 13:
              var state$102 = workInProgress.memoizedState;
              if (null !== state$102) {
                if (null !== state$102.dehydrated)
                  return (
                    pushPrimaryTreeSuspenseHandler(workInProgress),
                    (workInProgress.flags |= 128),
                    null
                  );
                if (0 !== (renderLanes & workInProgress.child.childLanes))
                  return updateSuspenseComponent(
                    current,
                    workInProgress,
                    renderLanes,
                  );
                pushPrimaryTreeSuspenseHandler(workInProgress);
                current = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress,
                  renderLanes,
                );
                return null !== current ? current.sibling : null;
              }
              pushPrimaryTreeSuspenseHandler(workInProgress);
              break;
            case 19:
              var didSuspendBefore = 0 !== (current.flags & 128);
              state$102 = 0 !== (renderLanes & workInProgress.childLanes);
              state$102 ||
                (propagateParentContextChanges(
                  current,
                  workInProgress,
                  renderLanes,
                  !1,
                ),
                (state$102 = 0 !== (renderLanes & workInProgress.childLanes)));
              if (didSuspendBefore) {
                if (state$102)
                  return updateSuspenseListComponent(
                    current,
                    workInProgress,
                    renderLanes,
                  );
                workInProgress.flags |= 128;
              }
              didSuspendBefore = workInProgress.memoizedState;
              null !== didSuspendBefore &&
                ((didSuspendBefore.rendering = null),
                (didSuspendBefore.tail = null),
                (didSuspendBefore.lastEffect = null));
              push(suspenseStackCursor, suspenseStackCursor.current);
              if (state$102) break;
              else return null;
            case 22:
              return (
                (workInProgress.lanes = 0),
                updateOffscreenComponent(
                  current,
                  workInProgress,
                  renderLanes,
                  workInProgress.pendingProps,
                )
              );
            case 24:
              pushProvider(
                workInProgress,
                CacheContext,
                current.memoizedState.cache,
              );
          }
          return bailoutOnAlreadyFinishedWork(
            current,
            workInProgress,
            renderLanes,
          );
        }
        function beginWork(current, workInProgress, renderLanes) {
          if (null !== current)
            if (current.memoizedProps !== workInProgress.pendingProps)
              didReceiveUpdate = !0;
            else {
              if (
                !checkScheduledUpdateOrContext(current, renderLanes) &&
                0 === (workInProgress.flags & 128)
              )
                return (
                  (didReceiveUpdate = !1),
                  attemptEarlyBailoutIfNoScheduledUpdate(
                    current,
                    workInProgress,
                    renderLanes,
                  )
                );
              didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
            }
          else
            (didReceiveUpdate = !1),
              isHydrating &&
                0 !== (workInProgress.flags & 1048576) &&
                pushTreeId(workInProgress, treeForkCount, workInProgress.index);
          workInProgress.lanes = 0;
          switch (workInProgress.tag) {
            case 16:
              a: {
                var props = workInProgress.pendingProps;
                current = resolveLazy(workInProgress.elementType);
                workInProgress.type = current;
                if ('function' === typeof current)
                  shouldConstruct(current)
                    ? ((props = resolveClassComponentProps(current, props)),
                      (workInProgress.tag = 1),
                      (workInProgress = updateClassComponent(
                        null,
                        workInProgress,
                        current,
                        props,
                        renderLanes,
                      )))
                    : ((workInProgress.tag = 0),
                      (workInProgress = updateFunctionComponent(
                        null,
                        workInProgress,
                        current,
                        props,
                        renderLanes,
                      )));
                else {
                  if (void 0 !== current && null !== current) {
                    var $$typeof = current.$$typeof;
                    if ($$typeof === REACT_FORWARD_REF_TYPE) {
                      workInProgress.tag = 11;
                      workInProgress = updateForwardRef(
                        null,
                        workInProgress,
                        current,
                        props,
                        renderLanes,
                      );
                      break a;
                    } else if ($$typeof === REACT_MEMO_TYPE) {
                      workInProgress.tag = 14;
                      workInProgress = updateMemoComponent(
                        null,
                        workInProgress,
                        current,
                        props,
                        renderLanes,
                      );
                      break a;
                    }
                  }
                  workInProgress = getComponentNameFromType(current) || current;
                  throw Error(formatProdErrorMessage(306, workInProgress, ''));
                }
              }
              return workInProgress;
            case 0:
              return updateFunctionComponent(
                current,
                workInProgress,
                workInProgress.type,
                workInProgress.pendingProps,
                renderLanes,
              );
            case 1:
              return (
                (props = workInProgress.type),
                ($$typeof = resolveClassComponentProps(
                  props,
                  workInProgress.pendingProps,
                )),
                updateClassComponent(
                  current,
                  workInProgress,
                  props,
                  $$typeof,
                  renderLanes,
                )
              );
            case 3:
              a: {
                pushHostContainer(
                  workInProgress,
                  workInProgress.stateNode.containerInfo,
                );
                if (null === current) throw Error(formatProdErrorMessage(387));
                props = workInProgress.pendingProps;
                var prevState = workInProgress.memoizedState;
                $$typeof = prevState.element;
                cloneUpdateQueue(current, workInProgress);
                processUpdateQueue(workInProgress, props, null, renderLanes);
                var nextState = workInProgress.memoizedState;
                props = nextState.cache;
                pushProvider(workInProgress, CacheContext, props);
                props !== prevState.cache &&
                  propagateContextChanges(
                    workInProgress,
                    [CacheContext],
                    renderLanes,
                    !0,
                  );
                suspendIfUpdateReadFromEntangledAsyncAction();
                props = nextState.element;
                if (prevState.isDehydrated)
                  if (
                    ((prevState = {
                      element: props,
                      isDehydrated: !1,
                      cache: nextState.cache,
                    }),
                    (workInProgress.updateQueue.baseState = prevState),
                    (workInProgress.memoizedState = prevState),
                    workInProgress.flags & 256)
                  ) {
                    workInProgress = mountHostRootWithoutHydrating(
                      current,
                      workInProgress,
                      props,
                      renderLanes,
                    );
                    break a;
                  } else if (props !== $$typeof) {
                    $$typeof = createCapturedValueAtFiber(
                      Error(formatProdErrorMessage(424)),
                      workInProgress,
                    );
                    queueHydrationError($$typeof);
                    workInProgress = mountHostRootWithoutHydrating(
                      current,
                      workInProgress,
                      props,
                      renderLanes,
                    );
                    break a;
                  } else {
                    current = workInProgress.stateNode.containerInfo;
                    switch (current.nodeType) {
                      case 9:
                        current = current.body;
                        break;
                      default:
                        current =
                          'HTML' === current.nodeName
                            ? current.ownerDocument.body
                            : current;
                    }
                    nextHydratableInstance = getNextHydratable(
                      current.firstChild,
                    );
                    hydrationParentFiber = workInProgress;
                    isHydrating = !0;
                    hydrationErrors = null;
                    rootOrSingletonContext = !0;
                    renderLanes = mountChildFibers(
                      workInProgress,
                      null,
                      props,
                      renderLanes,
                    );
                    for (workInProgress.child = renderLanes; renderLanes; )
                      (renderLanes.flags = (renderLanes.flags & -3) | 4096),
                        (renderLanes = renderLanes.sibling);
                  }
                else {
                  resetHydrationState();
                  if (props === $$typeof) {
                    workInProgress = bailoutOnAlreadyFinishedWork(
                      current,
                      workInProgress,
                      renderLanes,
                    );
                    break a;
                  }
                  reconcileChildren(
                    current,
                    workInProgress,
                    props,
                    renderLanes,
                  );
                }
                workInProgress = workInProgress.child;
              }
              return workInProgress;
            case 26:
              return (
                markRef(current, workInProgress),
                null === current
                  ? (renderLanes = getResource(
                      workInProgress.type,
                      null,
                      workInProgress.pendingProps,
                      null,
                    ))
                    ? (workInProgress.memoizedState = renderLanes)
                    : isHydrating ||
                      ((renderLanes = workInProgress.type),
                      (current = workInProgress.pendingProps),
                      (props = getOwnerDocumentFromRootContainer(
                        rootInstanceStackCursor.current,
                      ).createElement(renderLanes)),
                      (props[internalInstanceKey] = workInProgress),
                      (props[internalPropsKey] = current),
                      setInitialProperties(props, renderLanes, current),
                      markNodeAsHoistable(props),
                      (workInProgress.stateNode = props))
                  : (workInProgress.memoizedState = getResource(
                      workInProgress.type,
                      current.memoizedProps,
                      workInProgress.pendingProps,
                      current.memoizedState,
                    )),
                null
              );
            case 27:
              return (
                pushHostContext(workInProgress),
                null === current &&
                  isHydrating &&
                  ((props = workInProgress.stateNode =
                    resolveSingletonInstance(
                      workInProgress.type,
                      workInProgress.pendingProps,
                      rootInstanceStackCursor.current,
                    )),
                  (hydrationParentFiber = workInProgress),
                  (rootOrSingletonContext = !0),
                  ($$typeof = nextHydratableInstance),
                  isSingletonScope(workInProgress.type)
                    ? ((previousHydratableOnEnteringScopedSingleton = $$typeof),
                      (nextHydratableInstance = getNextHydratable(
                        props.firstChild,
                      )))
                    : (nextHydratableInstance = $$typeof)),
                reconcileChildren(
                  current,
                  workInProgress,
                  workInProgress.pendingProps.children,
                  renderLanes,
                ),
                markRef(current, workInProgress),
                null === current && (workInProgress.flags |= 4194304),
                workInProgress.child
              );
            case 5:
              if (null === current && isHydrating) {
                if (($$typeof = props = nextHydratableInstance))
                  (props = canHydrateInstance(
                    props,
                    workInProgress.type,
                    workInProgress.pendingProps,
                    rootOrSingletonContext,
                  )),
                    null !== props
                      ? ((workInProgress.stateNode = props),
                        (hydrationParentFiber = workInProgress),
                        (nextHydratableInstance = getNextHydratable(
                          props.firstChild,
                        )),
                        (rootOrSingletonContext = !1),
                        ($$typeof = !0))
                      : ($$typeof = !1);
                $$typeof || throwOnHydrationMismatch(workInProgress);
              }
              pushHostContext(workInProgress);
              $$typeof = workInProgress.type;
              prevState = workInProgress.pendingProps;
              nextState = null !== current ? current.memoizedProps : null;
              props = prevState.children;
              shouldSetTextContent($$typeof, prevState)
                ? (props = null)
                : null !== nextState &&
                  shouldSetTextContent($$typeof, nextState) &&
                  (workInProgress.flags |= 32);
              null !== workInProgress.memoizedState &&
                (($$typeof = renderWithHooks(
                  current,
                  workInProgress,
                  TransitionAwareHostComponent,
                  null,
                  null,
                  renderLanes,
                )),
                (HostTransitionContext._currentValue = $$typeof));
              markRef(current, workInProgress);
              reconcileChildren(current, workInProgress, props, renderLanes);
              return workInProgress.child;
            case 6:
              if (null === current && isHydrating) {
                if ((current = renderLanes = nextHydratableInstance))
                  (renderLanes = canHydrateTextInstance(
                    renderLanes,
                    workInProgress.pendingProps,
                    rootOrSingletonContext,
                  )),
                    null !== renderLanes
                      ? ((workInProgress.stateNode = renderLanes),
                        (hydrationParentFiber = workInProgress),
                        (nextHydratableInstance = null),
                        (current = !0))
                      : (current = !1);
                current || throwOnHydrationMismatch(workInProgress);
              }
              return null;
            case 13:
              return updateSuspenseComponent(
                current,
                workInProgress,
                renderLanes,
              );
            case 4:
              return (
                pushHostContainer(
                  workInProgress,
                  workInProgress.stateNode.containerInfo,
                ),
                (props = workInProgress.pendingProps),
                null === current
                  ? (workInProgress.child = reconcileChildFibers(
                      workInProgress,
                      null,
                      props,
                      renderLanes,
                    ))
                  : reconcileChildren(
                      current,
                      workInProgress,
                      props,
                      renderLanes,
                    ),
                workInProgress.child
              );
            case 11:
              return updateForwardRef(
                current,
                workInProgress,
                workInProgress.type,
                workInProgress.pendingProps,
                renderLanes,
              );
            case 7:
              return (
                reconcileChildren(
                  current,
                  workInProgress,
                  workInProgress.pendingProps,
                  renderLanes,
                ),
                workInProgress.child
              );
            case 8:
              return (
                reconcileChildren(
                  current,
                  workInProgress,
                  workInProgress.pendingProps.children,
                  renderLanes,
                ),
                workInProgress.child
              );
            case 12:
              return (
                reconcileChildren(
                  current,
                  workInProgress,
                  workInProgress.pendingProps.children,
                  renderLanes,
                ),
                workInProgress.child
              );
            case 10:
              return (
                (props = workInProgress.pendingProps),
                pushProvider(workInProgress, workInProgress.type, props.value),
                reconcileChildren(
                  current,
                  workInProgress,
                  props.children,
                  renderLanes,
                ),
                workInProgress.child
              );
            case 9:
              return (
                ($$typeof = workInProgress.type._context),
                (props = workInProgress.pendingProps.children),
                prepareToReadContext(workInProgress),
                ($$typeof = readContext($$typeof)),
                (props = props($$typeof)),
                (workInProgress.flags |= 1),
                reconcileChildren(current, workInProgress, props, renderLanes),
                workInProgress.child
              );
            case 14:
              return updateMemoComponent(
                current,
                workInProgress,
                workInProgress.type,
                workInProgress.pendingProps,
                renderLanes,
              );
            case 15:
              return updateSimpleMemoComponent(
                current,
                workInProgress,
                workInProgress.type,
                workInProgress.pendingProps,
                renderLanes,
              );
            case 19:
              return updateSuspenseListComponent(
                current,
                workInProgress,
                renderLanes,
              );
            case 31:
              return updateActivityComponent(
                current,
                workInProgress,
                renderLanes,
              );
            case 22:
              return updateOffscreenComponent(
                current,
                workInProgress,
                renderLanes,
                workInProgress.pendingProps,
              );
            case 24:
              return (
                prepareToReadContext(workInProgress),
                (props = readContext(CacheContext)),
                null === current
                  ? (($$typeof = peekCacheFromPool()),
                    null === $$typeof &&
                      (($$typeof = workInProgressRoot),
                      (prevState = createCache()),
                      ($$typeof.pooledCache = prevState),
                      prevState.refCount++,
                      null !== prevState &&
                        ($$typeof.pooledCacheLanes |= renderLanes),
                      ($$typeof = prevState)),
                    (workInProgress.memoizedState = {
                      parent: props,
                      cache: $$typeof,
                    }),
                    initializeUpdateQueue(workInProgress),
                    pushProvider(workInProgress, CacheContext, $$typeof))
                  : (0 !== (current.lanes & renderLanes) &&
                      (cloneUpdateQueue(current, workInProgress),
                      processUpdateQueue(
                        workInProgress,
                        null,
                        null,
                        renderLanes,
                      ),
                      suspendIfUpdateReadFromEntangledAsyncAction()),
                    ($$typeof = current.memoizedState),
                    (prevState = workInProgress.memoizedState),
                    $$typeof.parent !== props
                      ? (($$typeof = { parent: props, cache: props }),
                        (workInProgress.memoizedState = $$typeof),
                        0 === workInProgress.lanes &&
                          (workInProgress.memoizedState =
                            workInProgress.updateQueue.baseState =
                              $$typeof),
                        pushProvider(workInProgress, CacheContext, props))
                      : ((props = prevState.cache),
                        pushProvider(workInProgress, CacheContext, props),
                        props !== $$typeof.cache &&
                          propagateContextChanges(
                            workInProgress,
                            [CacheContext],
                            renderLanes,
                            !0,
                          ))),
                reconcileChildren(
                  current,
                  workInProgress,
                  workInProgress.pendingProps.children,
                  renderLanes,
                ),
                workInProgress.child
              );
            case 29:
              throw workInProgress.pendingProps;
          }
          throw Error(formatProdErrorMessage(156, workInProgress.tag));
        }
        function markUpdate(workInProgress) {
          workInProgress.flags |= 4;
        }
        function preloadInstanceAndSuspendIfNeeded(
          workInProgress,
          type,
          oldProps,
          newProps,
          renderLanes,
        ) {
          if ((type = 0 !== (workInProgress.mode & 32))) type = !1;
          if (type) {
            if (
              ((workInProgress.flags |= 16777216),
              (renderLanes & 335544128) === renderLanes)
            )
              if (workInProgress.stateNode.complete)
                workInProgress.flags |= 8192;
              else if (shouldRemainOnPreviousScreen())
                workInProgress.flags |= 8192;
              else
                throw (
                  ((suspendedThenable = noopSuspenseyCommitThenable),
                  SuspenseyCommitException)
                );
          } else workInProgress.flags &= -16777217;
        }
        function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
          if (
            'stylesheet' !== resource.type ||
            0 !== (resource.state.loading & 4)
          )
            workInProgress.flags &= -16777217;
          else if (
            ((workInProgress.flags |= 16777216), !preloadResource(resource))
          )
            if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
            else
              throw (
                ((suspendedThenable = noopSuspenseyCommitThenable),
                SuspenseyCommitException)
              );
        }
        function scheduleRetryEffect(workInProgress, retryQueue) {
          null !== retryQueue && (workInProgress.flags |= 4);
          workInProgress.flags & 16384 &&
            ((retryQueue =
              22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
            (workInProgress.lanes |= retryQueue),
            (workInProgressSuspendedRetryLanes |= retryQueue));
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (!isHydrating)
            switch (renderState.tailMode) {
              case 'hidden':
                hasRenderedATailFallback = renderState.tail;
                for (
                  var lastTailNode = null;
                  null !== hasRenderedATailFallback;

                )
                  null !== hasRenderedATailFallback.alternate &&
                    (lastTailNode = hasRenderedATailFallback),
                    (hasRenderedATailFallback =
                      hasRenderedATailFallback.sibling);
                null === lastTailNode
                  ? (renderState.tail = null)
                  : (lastTailNode.sibling = null);
                break;
              case 'collapsed':
                lastTailNode = renderState.tail;
                for (var lastTailNode$106 = null; null !== lastTailNode; )
                  null !== lastTailNode.alternate &&
                    (lastTailNode$106 = lastTailNode),
                    (lastTailNode = lastTailNode.sibling);
                null === lastTailNode$106
                  ? hasRenderedATailFallback || null === renderState.tail
                    ? (renderState.tail = null)
                    : (renderState.tail.sibling = null)
                  : (lastTailNode$106.sibling = null);
            }
        }
        function bubbleProperties(completedWork) {
          var didBailout =
              null !== completedWork.alternate &&
              completedWork.alternate.child === completedWork.child,
            newChildLanes = 0,
            subtreeFlags = 0;
          if (didBailout)
            for (var child$107 = completedWork.child; null !== child$107; )
              (newChildLanes |= child$107.lanes | child$107.childLanes),
                (subtreeFlags |= child$107.subtreeFlags & 65011712),
                (subtreeFlags |= child$107.flags & 65011712),
                (child$107.return = completedWork),
                (child$107 = child$107.sibling);
          else
            for (child$107 = completedWork.child; null !== child$107; )
              (newChildLanes |= child$107.lanes | child$107.childLanes),
                (subtreeFlags |= child$107.subtreeFlags),
                (subtreeFlags |= child$107.flags),
                (child$107.return = completedWork),
                (child$107 = child$107.sibling);
          completedWork.subtreeFlags |= subtreeFlags;
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeWork(current, workInProgress, renderLanes) {
          var newProps = workInProgress.pendingProps;
          popTreeContext(workInProgress);
          switch (workInProgress.tag) {
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return bubbleProperties(workInProgress), null;
            case 1:
              return bubbleProperties(workInProgress), null;
            case 3:
              renderLanes = workInProgress.stateNode;
              newProps = null;
              null !== current && (newProps = current.memoizedState.cache);
              workInProgress.memoizedState.cache !== newProps &&
                (workInProgress.flags |= 2048);
              popProvider(CacheContext);
              popHostContainer();
              renderLanes.pendingContext &&
                ((renderLanes.context = renderLanes.pendingContext),
                (renderLanes.pendingContext = null));
              if (null === current || null === current.child)
                popHydrationState(workInProgress)
                  ? markUpdate(workInProgress)
                  : null === current ||
                    (current.memoizedState.isDehydrated &&
                      0 === (workInProgress.flags & 256)) ||
                    ((workInProgress.flags |= 1024),
                    upgradeHydrationErrorsToRecoverable());
              bubbleProperties(workInProgress);
              return null;
            case 26:
              var type = workInProgress.type,
                nextResource = workInProgress.memoizedState;
              null === current
                ? (markUpdate(workInProgress),
                  null !== nextResource
                    ? (bubbleProperties(workInProgress),
                      preloadResourceAndSuspendIfNeeded(
                        workInProgress,
                        nextResource,
                      ))
                    : (bubbleProperties(workInProgress),
                      preloadInstanceAndSuspendIfNeeded(
                        workInProgress,
                        type,
                        null,
                        newProps,
                        renderLanes,
                      )))
                : nextResource
                  ? nextResource !== current.memoizedState
                    ? (markUpdate(workInProgress),
                      bubbleProperties(workInProgress),
                      preloadResourceAndSuspendIfNeeded(
                        workInProgress,
                        nextResource,
                      ))
                    : (bubbleProperties(workInProgress),
                      (workInProgress.flags &= -16777217))
                  : ((current = current.memoizedProps),
                    current !== newProps && markUpdate(workInProgress),
                    bubbleProperties(workInProgress),
                    preloadInstanceAndSuspendIfNeeded(
                      workInProgress,
                      type,
                      current,
                      newProps,
                      renderLanes,
                    ));
              return null;
            case 27:
              popHostContext(workInProgress);
              renderLanes = rootInstanceStackCursor.current;
              type = workInProgress.type;
              if (null !== current && null != workInProgress.stateNode)
                current.memoizedProps !== newProps &&
                  markUpdate(workInProgress);
              else {
                if (!newProps) {
                  if (null === workInProgress.stateNode)
                    throw Error(formatProdErrorMessage(166));
                  bubbleProperties(workInProgress);
                  return null;
                }
                current = contextStackCursor.current;
                popHydrationState(workInProgress)
                  ? prepareToHydrateHostInstance(workInProgress, current)
                  : ((current = resolveSingletonInstance(
                      type,
                      newProps,
                      renderLanes,
                    )),
                    (workInProgress.stateNode = current),
                    markUpdate(workInProgress));
              }
              bubbleProperties(workInProgress);
              return null;
            case 5:
              popHostContext(workInProgress);
              type = workInProgress.type;
              if (null !== current && null != workInProgress.stateNode)
                current.memoizedProps !== newProps &&
                  markUpdate(workInProgress);
              else {
                if (!newProps) {
                  if (null === workInProgress.stateNode)
                    throw Error(formatProdErrorMessage(166));
                  bubbleProperties(workInProgress);
                  return null;
                }
                nextResource = contextStackCursor.current;
                if (popHydrationState(workInProgress))
                  prepareToHydrateHostInstance(workInProgress, nextResource);
                else {
                  var ownerDocument = getOwnerDocumentFromRootContainer(
                    rootInstanceStackCursor.current,
                  );
                  switch (nextResource) {
                    case 1:
                      nextResource = ownerDocument.createElementNS(
                        'http://www.w3.org/2000/svg',
                        type,
                      );
                      break;
                    case 2:
                      nextResource = ownerDocument.createElementNS(
                        'http://www.w3.org/1998/Math/MathML',
                        type,
                      );
                      break;
                    default:
                      switch (type) {
                        case 'svg':
                          nextResource = ownerDocument.createElementNS(
                            'http://www.w3.org/2000/svg',
                            type,
                          );
                          break;
                        case 'math':
                          nextResource = ownerDocument.createElementNS(
                            'http://www.w3.org/1998/Math/MathML',
                            type,
                          );
                          break;
                        case 'script':
                          nextResource = ownerDocument.createElement('div');
                          nextResource.innerHTML = '<script>\x3c/script>';
                          nextResource = nextResource.removeChild(
                            nextResource.firstChild,
                          );
                          break;
                        case 'select':
                          nextResource =
                            'string' === typeof newProps.is
                              ? ownerDocument.createElement('select', {
                                  is: newProps.is,
                                })
                              : ownerDocument.createElement('select');
                          newProps.multiple
                            ? (nextResource.multiple = !0)
                            : newProps.size &&
                              (nextResource.size = newProps.size);
                          break;
                        default:
                          nextResource =
                            'string' === typeof newProps.is
                              ? ownerDocument.createElement(type, {
                                  is: newProps.is,
                                })
                              : ownerDocument.createElement(type);
                      }
                  }
                  nextResource[internalInstanceKey] = workInProgress;
                  nextResource[internalPropsKey] = newProps;
                  a: for (
                    ownerDocument = workInProgress.child;
                    null !== ownerDocument;

                  ) {
                    if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                      nextResource.appendChild(ownerDocument.stateNode);
                    else if (
                      4 !== ownerDocument.tag &&
                      27 !== ownerDocument.tag &&
                      null !== ownerDocument.child
                    ) {
                      ownerDocument.child.return = ownerDocument;
                      ownerDocument = ownerDocument.child;
                      continue;
                    }
                    if (ownerDocument === workInProgress) break a;
                    for (; null === ownerDocument.sibling; ) {
                      if (
                        null === ownerDocument.return ||
                        ownerDocument.return === workInProgress
                      )
                        break a;
                      ownerDocument = ownerDocument.return;
                    }
                    ownerDocument.sibling.return = ownerDocument.return;
                    ownerDocument = ownerDocument.sibling;
                  }
                  workInProgress.stateNode = nextResource;
                  a: switch (
                    (setInitialProperties(nextResource, type, newProps), type)
                  ) {
                    case 'button':
                    case 'input':
                    case 'select':
                    case 'textarea':
                      newProps = !!newProps.autoFocus;
                      break a;
                    case 'img':
                      newProps = !0;
                      break a;
                    default:
                      newProps = !1;
                  }
                  newProps && markUpdate(workInProgress);
                }
              }
              bubbleProperties(workInProgress);
              preloadInstanceAndSuspendIfNeeded(
                workInProgress,
                workInProgress.type,
                null === current ? null : current.memoizedProps,
                workInProgress.pendingProps,
                renderLanes,
              );
              return null;
            case 6:
              if (current && null != workInProgress.stateNode)
                current.memoizedProps !== newProps &&
                  markUpdate(workInProgress);
              else {
                if (
                  'string' !== typeof newProps &&
                  null === workInProgress.stateNode
                )
                  throw Error(formatProdErrorMessage(166));
                current = rootInstanceStackCursor.current;
                if (popHydrationState(workInProgress)) {
                  current = workInProgress.stateNode;
                  renderLanes = workInProgress.memoizedProps;
                  newProps = null;
                  type = hydrationParentFiber;
                  if (null !== type)
                    switch (type.tag) {
                      case 27:
                      case 5:
                        newProps = type.memoizedProps;
                    }
                  current[internalInstanceKey] = workInProgress;
                  current =
                    current.nodeValue === renderLanes ||
                    (null !== newProps &&
                      !0 === newProps.suppressHydrationWarning) ||
                    checkForUnmatchedText(current.nodeValue, renderLanes)
                      ? !0
                      : !1;
                  current || throwOnHydrationMismatch(workInProgress, !0);
                } else
                  (current =
                    getOwnerDocumentFromRootContainer(current).createTextNode(
                      newProps,
                    )),
                    (current[internalInstanceKey] = workInProgress),
                    (workInProgress.stateNode = current);
              }
              bubbleProperties(workInProgress);
              return null;
            case 31:
              renderLanes = workInProgress.memoizedState;
              if (null === current || null !== current.memoizedState) {
                newProps = popHydrationState(workInProgress);
                if (null !== renderLanes) {
                  if (null === current) {
                    if (!newProps) throw Error(formatProdErrorMessage(318));
                    current = workInProgress.memoizedState;
                    current = null !== current ? current.dehydrated : null;
                    if (!current) throw Error(formatProdErrorMessage(557));
                    current[internalInstanceKey] = workInProgress;
                  } else
                    resetHydrationState(),
                      0 === (workInProgress.flags & 128) &&
                        (workInProgress.memoizedState = null),
                      (workInProgress.flags |= 4);
                  bubbleProperties(workInProgress);
                  current = !1;
                } else
                  (renderLanes = upgradeHydrationErrorsToRecoverable()),
                    null !== current &&
                      null !== current.memoizedState &&
                      (current.memoizedState.hydrationErrors = renderLanes),
                    (current = !0);
                if (!current) {
                  if (workInProgress.flags & 256)
                    return popSuspenseHandler(workInProgress), workInProgress;
                  popSuspenseHandler(workInProgress);
                  return null;
                }
                if (0 !== (workInProgress.flags & 128))
                  throw Error(formatProdErrorMessage(558));
              }
              bubbleProperties(workInProgress);
              return null;
            case 13:
              newProps = workInProgress.memoizedState;
              if (
                null === current ||
                (null !== current.memoizedState &&
                  null !== current.memoizedState.dehydrated)
              ) {
                type = popHydrationState(workInProgress);
                if (null !== newProps && null !== newProps.dehydrated) {
                  if (null === current) {
                    if (!type) throw Error(formatProdErrorMessage(318));
                    type = workInProgress.memoizedState;
                    type = null !== type ? type.dehydrated : null;
                    if (!type) throw Error(formatProdErrorMessage(317));
                    type[internalInstanceKey] = workInProgress;
                  } else
                    resetHydrationState(),
                      0 === (workInProgress.flags & 128) &&
                        (workInProgress.memoizedState = null),
                      (workInProgress.flags |= 4);
                  bubbleProperties(workInProgress);
                  type = !1;
                } else
                  (type = upgradeHydrationErrorsToRecoverable()),
                    null !== current &&
                      null !== current.memoizedState &&
                      (current.memoizedState.hydrationErrors = type),
                    (type = !0);
                if (!type) {
                  if (workInProgress.flags & 256)
                    return popSuspenseHandler(workInProgress), workInProgress;
                  popSuspenseHandler(workInProgress);
                  return null;
                }
              }
              popSuspenseHandler(workInProgress);
              if (0 !== (workInProgress.flags & 128))
                return (workInProgress.lanes = renderLanes), workInProgress;
              renderLanes = null !== newProps;
              current = null !== current && null !== current.memoizedState;
              renderLanes &&
                ((newProps = workInProgress.child),
                (type = null),
                null !== newProps.alternate &&
                  null !== newProps.alternate.memoizedState &&
                  null !== newProps.alternate.memoizedState.cachePool &&
                  (type = newProps.alternate.memoizedState.cachePool.pool),
                (nextResource = null),
                null !== newProps.memoizedState &&
                  null !== newProps.memoizedState.cachePool &&
                  (nextResource = newProps.memoizedState.cachePool.pool),
                nextResource !== type && (newProps.flags |= 2048));
              renderLanes !== current &&
                renderLanes &&
                (workInProgress.child.flags |= 8192);
              scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
              bubbleProperties(workInProgress);
              return null;
            case 4:
              return (
                popHostContainer(),
                null === current &&
                  listenToAllSupportedEvents(
                    workInProgress.stateNode.containerInfo,
                  ),
                bubbleProperties(workInProgress),
                null
              );
            case 10:
              return (
                popProvider(workInProgress.type),
                bubbleProperties(workInProgress),
                null
              );
            case 19:
              pop(suspenseStackCursor);
              newProps = workInProgress.memoizedState;
              if (null === newProps)
                return bubbleProperties(workInProgress), null;
              type = 0 !== (workInProgress.flags & 128);
              nextResource = newProps.rendering;
              if (null === nextResource)
                if (type) cutOffTailIfNeeded(newProps, !1);
                else {
                  if (
                    0 !== workInProgressRootExitStatus ||
                    (null !== current && 0 !== (current.flags & 128))
                  )
                    for (current = workInProgress.child; null !== current; ) {
                      nextResource = findFirstSuspended(current);
                      if (null !== nextResource) {
                        workInProgress.flags |= 128;
                        cutOffTailIfNeeded(newProps, !1);
                        current = nextResource.updateQueue;
                        workInProgress.updateQueue = current;
                        scheduleRetryEffect(workInProgress, current);
                        workInProgress.subtreeFlags = 0;
                        current = renderLanes;
                        for (
                          renderLanes = workInProgress.child;
                          null !== renderLanes;

                        )
                          resetWorkInProgress(renderLanes, current),
                            (renderLanes = renderLanes.sibling);
                        push(
                          suspenseStackCursor,
                          (suspenseStackCursor.current & 1) | 2,
                        );
                        isHydrating &&
                          pushTreeFork(workInProgress, newProps.treeForkCount);
                        return workInProgress.child;
                      }
                      current = current.sibling;
                    }
                  null !== newProps.tail &&
                    now() > workInProgressRootRenderTargetTime &&
                    ((workInProgress.flags |= 128),
                    (type = !0),
                    cutOffTailIfNeeded(newProps, !1),
                    (workInProgress.lanes = 4194304));
                }
              else {
                if (!type)
                  if (
                    ((current = findFirstSuspended(nextResource)),
                    null !== current)
                  ) {
                    if (
                      ((workInProgress.flags |= 128),
                      (type = !0),
                      (current = current.updateQueue),
                      (workInProgress.updateQueue = current),
                      scheduleRetryEffect(workInProgress, current),
                      cutOffTailIfNeeded(newProps, !0),
                      null === newProps.tail &&
                        'hidden' === newProps.tailMode &&
                        !nextResource.alternate &&
                        !isHydrating)
                    )
                      return bubbleProperties(workInProgress), null;
                  } else
                    2 * now() - newProps.renderingStartTime >
                      workInProgressRootRenderTargetTime &&
                      536870912 !== renderLanes &&
                      ((workInProgress.flags |= 128),
                      (type = !0),
                      cutOffTailIfNeeded(newProps, !1),
                      (workInProgress.lanes = 4194304));
                newProps.isBackwards
                  ? ((nextResource.sibling = workInProgress.child),
                    (workInProgress.child = nextResource))
                  : ((current = newProps.last),
                    null !== current
                      ? (current.sibling = nextResource)
                      : (workInProgress.child = nextResource),
                    (newProps.last = nextResource));
              }
              if (null !== newProps.tail)
                return (
                  (current = newProps.tail),
                  (newProps.rendering = current),
                  (newProps.tail = current.sibling),
                  (newProps.renderingStartTime = now()),
                  (current.sibling = null),
                  (renderLanes = suspenseStackCursor.current),
                  push(
                    suspenseStackCursor,
                    type ? (renderLanes & 1) | 2 : renderLanes & 1,
                  ),
                  isHydrating &&
                    pushTreeFork(workInProgress, newProps.treeForkCount),
                  current
                );
              bubbleProperties(workInProgress);
              return null;
            case 22:
            case 23:
              return (
                popSuspenseHandler(workInProgress),
                popHiddenContext(),
                (newProps = null !== workInProgress.memoizedState),
                null !== current
                  ? (null !== current.memoizedState) !== newProps &&
                    (workInProgress.flags |= 8192)
                  : newProps && (workInProgress.flags |= 8192),
                newProps
                  ? 0 !== (renderLanes & 536870912) &&
                    0 === (workInProgress.flags & 128) &&
                    (bubbleProperties(workInProgress),
                    workInProgress.subtreeFlags & 6 &&
                      (workInProgress.flags |= 8192))
                  : bubbleProperties(workInProgress),
                (renderLanes = workInProgress.updateQueue),
                null !== renderLanes &&
                  scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
                (renderLanes = null),
                null !== current &&
                  null !== current.memoizedState &&
                  null !== current.memoizedState.cachePool &&
                  (renderLanes = current.memoizedState.cachePool.pool),
                (newProps = null),
                null !== workInProgress.memoizedState &&
                  null !== workInProgress.memoizedState.cachePool &&
                  (newProps = workInProgress.memoizedState.cachePool.pool),
                newProps !== renderLanes && (workInProgress.flags |= 2048),
                null !== current && pop(resumedCache),
                null
              );
            case 24:
              return (
                (renderLanes = null),
                null !== current && (renderLanes = current.memoizedState.cache),
                workInProgress.memoizedState.cache !== renderLanes &&
                  (workInProgress.flags |= 2048),
                popProvider(CacheContext),
                bubbleProperties(workInProgress),
                null
              );
            case 25:
              return null;
            case 30:
              return null;
          }
          throw Error(formatProdErrorMessage(156, workInProgress.tag));
        }
        function unwindWork(current, workInProgress) {
          popTreeContext(workInProgress);
          switch (workInProgress.tag) {
            case 1:
              return (
                (current = workInProgress.flags),
                current & 65536
                  ? ((workInProgress.flags = (current & -65537) | 128),
                    workInProgress)
                  : null
              );
            case 3:
              return (
                popProvider(CacheContext),
                popHostContainer(),
                (current = workInProgress.flags),
                0 !== (current & 65536) && 0 === (current & 128)
                  ? ((workInProgress.flags = (current & -65537) | 128),
                    workInProgress)
                  : null
              );
            case 26:
            case 27:
            case 5:
              return popHostContext(workInProgress), null;
            case 31:
              if (null !== workInProgress.memoizedState) {
                popSuspenseHandler(workInProgress);
                if (null === workInProgress.alternate)
                  throw Error(formatProdErrorMessage(340));
                resetHydrationState();
              }
              current = workInProgress.flags;
              return current & 65536
                ? ((workInProgress.flags = (current & -65537) | 128),
                  workInProgress)
                : null;
            case 13:
              popSuspenseHandler(workInProgress);
              current = workInProgress.memoizedState;
              if (null !== current && null !== current.dehydrated) {
                if (null === workInProgress.alternate)
                  throw Error(formatProdErrorMessage(340));
                resetHydrationState();
              }
              current = workInProgress.flags;
              return current & 65536
                ? ((workInProgress.flags = (current & -65537) | 128),
                  workInProgress)
                : null;
            case 19:
              return pop(suspenseStackCursor), null;
            case 4:
              return popHostContainer(), null;
            case 10:
              return popProvider(workInProgress.type), null;
            case 22:
            case 23:
              return (
                popSuspenseHandler(workInProgress),
                popHiddenContext(),
                null !== current && pop(resumedCache),
                (current = workInProgress.flags),
                current & 65536
                  ? ((workInProgress.flags = (current & -65537) | 128),
                    workInProgress)
                  : null
              );
            case 24:
              return popProvider(CacheContext), null;
            case 25:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current, interruptedWork) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case 3:
              popProvider(CacheContext);
              popHostContainer();
              break;
            case 26:
            case 27:
            case 5:
              popHostContext(interruptedWork);
              break;
            case 4:
              popHostContainer();
              break;
            case 31:
              null !== interruptedWork.memoizedState &&
                popSuspenseHandler(interruptedWork);
              break;
            case 13:
              popSuspenseHandler(interruptedWork);
              break;
            case 19:
              pop(suspenseStackCursor);
              break;
            case 10:
              popProvider(interruptedWork.type);
              break;
            case 22:
            case 23:
              popSuspenseHandler(interruptedWork);
              popHiddenContext();
              null !== current && pop(resumedCache);
              break;
            case 24:
              popProvider(CacheContext);
          }
        }
        function commitHookEffectListMount(flags, finishedWork) {
          try {
            var updateQueue = finishedWork.updateQueue,
              lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags) {
                  lastEffect = void 0;
                  var create = updateQueue.create,
                    inst = updateQueue.inst;
                  lastEffect = create();
                  inst.destroy = lastEffect;
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookEffectListUnmount(
          flags,
          finishedWork,
          nearestMountedAncestor$jscomp$0,
        ) {
          try {
            var updateQueue = finishedWork.updateQueue,
              lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags) {
                  var inst = updateQueue.inst,
                    destroy = inst.destroy;
                  if (void 0 !== destroy) {
                    inst.destroy = void 0;
                    lastEffect = finishedWork;
                    var nearestMountedAncestor =
                        nearestMountedAncestor$jscomp$0,
                      destroy_ = destroy;
                    try {
                      destroy_();
                    } catch (error) {
                      captureCommitPhaseError(
                        lastEffect,
                        nearestMountedAncestor,
                        error,
                      );
                    }
                  }
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitClassCallbacks(finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          if (null !== updateQueue) {
            var instance = finishedWork.stateNode;
            try {
              commitCallbacks(updateQueue, instance);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function safelyCallComponentWillUnmount(
          current,
          nearestMountedAncestor,
          instance,
        ) {
          instance.props = resolveClassComponentProps(
            current.type,
            current.memoizedProps,
          );
          instance.state = current.memoizedState;
          try {
            instance.componentWillUnmount();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
        function safelyAttachRef(current, nearestMountedAncestor) {
          try {
            var ref = current.ref;
            if (null !== ref) {
              switch (current.tag) {
                case 26:
                case 27:
                case 5:
                  var instanceToUse = current.stateNode;
                  break;
                case 30:
                  instanceToUse = current.stateNode;
                  break;
                default:
                  instanceToUse = current.stateNode;
              }
              'function' === typeof ref
                ? (current.refCleanup = ref(instanceToUse))
                : (ref.current = instanceToUse);
            }
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
        function safelyDetachRef(current, nearestMountedAncestor) {
          var ref = current.ref,
            refCleanup = current.refCleanup;
          if (null !== ref)
            if ('function' === typeof refCleanup)
              try {
                refCleanup();
              } catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
              } finally {
                (current.refCleanup = null),
                  (current = current.alternate),
                  null != current && (current.refCleanup = null);
              }
            else if ('function' === typeof ref)
              try {
                ref(null);
              } catch (error$140) {
                captureCommitPhaseError(
                  current,
                  nearestMountedAncestor,
                  error$140,
                );
              }
            else ref.current = null;
        }
        function commitHostMount(finishedWork) {
          var type = finishedWork.type,
            props = finishedWork.memoizedProps,
            instance = finishedWork.stateNode;
          try {
            a: switch (type) {
              case 'button':
              case 'input':
              case 'select':
              case 'textarea':
                props.autoFocus && instance.focus();
                break a;
              case 'img':
                props.src
                  ? (instance.src = props.src)
                  : props.srcSet && (instance.srcset = props.srcSet);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHostUpdate(finishedWork, newProps, oldProps) {
          try {
            var domElement = finishedWork.stateNode;
            updateProperties(domElement, finishedWork.type, oldProps, newProps);
            domElement[internalPropsKey] = newProps;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHostParent(fiber) {
          return (
            5 === fiber.tag ||
            3 === fiber.tag ||
            26 === fiber.tag ||
            (27 === fiber.tag && isSingletonScope(fiber.type)) ||
            4 === fiber.tag
          );
        }
        function getHostSibling(fiber) {
          a: for (;;) {
            for (; null === fiber.sibling; ) {
              if (null === fiber.return || isHostParent(fiber.return))
                return null;
              fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for (
              fiber = fiber.sibling;
              5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;

            ) {
              if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
              if (fiber.flags & 2) continue a;
              if (null === fiber.child || 4 === fiber.tag) continue a;
              else (fiber.child.return = fiber), (fiber = fiber.child);
            }
            if (!(fiber.flags & 2)) return fiber.stateNode;
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(
          node,
          before,
          parent,
        ) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            (node = node.stateNode),
              before
                ? (9 === parent.nodeType
                    ? parent.body
                    : 'HTML' === parent.nodeName
                      ? parent.ownerDocument.body
                      : parent
                  ).insertBefore(node, before)
                : ((before =
                    9 === parent.nodeType
                      ? parent.body
                      : 'HTML' === parent.nodeName
                        ? parent.ownerDocument.body
                        : parent),
                  before.appendChild(node),
                  (parent = parent._reactRootContainer),
                  (null !== parent && void 0 !== parent) ||
                    null !== before.onclick ||
                    (before.onclick = noop$1));
          else if (
            4 !== tag &&
            (27 === tag &&
              isSingletonScope(node.type) &&
              ((parent = node.stateNode), (before = null)),
            (node = node.child),
            null !== node)
          )
            for (
              insertOrAppendPlacementNodeIntoContainer(node, before, parent),
                node = node.sibling;
              null !== node;

            )
              insertOrAppendPlacementNodeIntoContainer(node, before, parent),
                (node = node.sibling);
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            (node = node.stateNode),
              before
                ? parent.insertBefore(node, before)
                : parent.appendChild(node);
          else if (
            4 !== tag &&
            (27 === tag &&
              isSingletonScope(node.type) &&
              (parent = node.stateNode),
            (node = node.child),
            null !== node)
          )
            for (
              insertOrAppendPlacementNode(node, before, parent),
                node = node.sibling;
              null !== node;

            )
              insertOrAppendPlacementNode(node, before, parent),
                (node = node.sibling);
        }
        function commitHostSingletonAcquisition(finishedWork) {
          var singleton = finishedWork.stateNode,
            props = finishedWork.memoizedProps;
          try {
            for (
              var type = finishedWork.type, attributes = singleton.attributes;
              attributes.length;

            )
              singleton.removeAttributeNode(attributes[0]);
            setInitialProperties(singleton, type, props);
            singleton[internalInstanceKey] = finishedWork;
            singleton[internalPropsKey] = props;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        var offscreenSubtreeIsHidden = !1,
          offscreenSubtreeWasHidden = !1,
          needsFormReset = !1,
          PossiblyWeakSet = 'function' === typeof WeakSet ? WeakSet : Set,
          nextEffect = null;
        function commitBeforeMutationEffects(root, firstChild) {
          root = root.containerInfo;
          eventsEnabled = _enabled;
          root = getActiveElementDeep(root);
          if (hasSelectionCapabilities(root)) {
            if ('selectionStart' in root)
              var JSCompiler_temp = {
                start: root.selectionStart,
                end: root.selectionEnd,
              };
            else
              a: {
                JSCompiler_temp =
                  ((JSCompiler_temp = root.ownerDocument) &&
                    JSCompiler_temp.defaultView) ||
                  window;
                var selection =
                  JSCompiler_temp.getSelection &&
                  JSCompiler_temp.getSelection();
                if (selection && 0 !== selection.rangeCount) {
                  JSCompiler_temp = selection.anchorNode;
                  var anchorOffset = selection.anchorOffset,
                    focusNode = selection.focusNode;
                  selection = selection.focusOffset;
                  try {
                    JSCompiler_temp.nodeType, focusNode.nodeType;
                  } catch (e$20) {
                    JSCompiler_temp = null;
                    break a;
                  }
                  var length = 0,
                    start = -1,
                    end = -1,
                    indexWithinAnchor = 0,
                    indexWithinFocus = 0,
                    node = root,
                    parentNode = null;
                  b: for (;;) {
                    for (var next; ; ) {
                      node !== JSCompiler_temp ||
                        (0 !== anchorOffset && 3 !== node.nodeType) ||
                        (start = length + anchorOffset);
                      node !== focusNode ||
                        (0 !== selection && 3 !== node.nodeType) ||
                        (end = length + selection);
                      3 === node.nodeType && (length += node.nodeValue.length);
                      if (null === (next = node.firstChild)) break;
                      parentNode = node;
                      node = next;
                    }
                    for (;;) {
                      if (node === root) break b;
                      parentNode === JSCompiler_temp &&
                        ++indexWithinAnchor === anchorOffset &&
                        (start = length);
                      parentNode === focusNode &&
                        ++indexWithinFocus === selection &&
                        (end = length);
                      if (null !== (next = node.nextSibling)) break;
                      node = parentNode;
                      parentNode = node.parentNode;
                    }
                    node = next;
                  }
                  JSCompiler_temp =
                    -1 === start || -1 === end
                      ? null
                      : { start: start, end: end };
                } else JSCompiler_temp = null;
              }
            JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
          } else JSCompiler_temp = null;
          selectionInformation = {
            focusedElem: root,
            selectionRange: JSCompiler_temp,
          };
          _enabled = !1;
          for (nextEffect = firstChild; null !== nextEffect; )
            if (
              ((firstChild = nextEffect),
              (root = firstChild.child),
              0 !== (firstChild.subtreeFlags & 1028) && null !== root)
            )
              (root.return = firstChild), (nextEffect = root);
            else
              for (; null !== nextEffect; ) {
                firstChild = nextEffect;
                focusNode = firstChild.alternate;
                root = firstChild.flags;
                switch (firstChild.tag) {
                  case 0:
                    if (
                      0 !== (root & 4) &&
                      ((root = firstChild.updateQueue),
                      (root = null !== root ? root.events : null),
                      null !== root)
                    )
                      for (
                        JSCompiler_temp = 0;
                        JSCompiler_temp < root.length;
                        JSCompiler_temp++
                      )
                        (anchorOffset = root[JSCompiler_temp]),
                          (anchorOffset.ref.impl = anchorOffset.nextImpl);
                    break;
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (0 !== (root & 1024) && null !== focusNode) {
                      root = void 0;
                      JSCompiler_temp = firstChild;
                      anchorOffset = focusNode.memoizedProps;
                      focusNode = focusNode.memoizedState;
                      selection = JSCompiler_temp.stateNode;
                      try {
                        var resolvedPrevProps = resolveClassComponentProps(
                          JSCompiler_temp.type,
                          anchorOffset,
                        );
                        root = selection.getSnapshotBeforeUpdate(
                          resolvedPrevProps,
                          focusNode,
                        );
                        selection.__reactInternalSnapshotBeforeUpdate = root;
                      } catch (error) {
                        captureCommitPhaseError(
                          JSCompiler_temp,
                          JSCompiler_temp.return,
                          error,
                        );
                      }
                    }
                    break;
                  case 3:
                    if (0 !== (root & 1024))
                      if (
                        ((root = firstChild.stateNode.containerInfo),
                        (JSCompiler_temp = root.nodeType),
                        9 === JSCompiler_temp)
                      )
                        clearContainerSparingly(root);
                      else if (1 === JSCompiler_temp)
                        switch (root.nodeName) {
                          case 'HEAD':
                          case 'HTML':
                          case 'BODY':
                            clearContainerSparingly(root);
                            break;
                          default:
                            root.textContent = '';
                        }
                    break;
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    if (0 !== (root & 1024))
                      throw Error(formatProdErrorMessage(163));
                }
                root = firstChild.sibling;
                if (null !== root) {
                  root.return = firstChild.return;
                  nextEffect = root;
                  break;
                }
                nextEffect = firstChild.return;
              }
        }
        function commitLayoutEffectOnFiber(
          finishedRoot,
          current,
          finishedWork,
        ) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitHookEffectListMount(5, finishedWork);
              break;
            case 1:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 4)
                if (((finishedRoot = finishedWork.stateNode), null === current))
                  try {
                    finishedRoot.componentDidMount();
                  } catch (error) {
                    captureCommitPhaseError(
                      finishedWork,
                      finishedWork.return,
                      error,
                    );
                  }
                else {
                  var prevProps = resolveClassComponentProps(
                    finishedWork.type,
                    current.memoizedProps,
                  );
                  current = current.memoizedState;
                  try {
                    finishedRoot.componentDidUpdate(
                      prevProps,
                      current,
                      finishedRoot.__reactInternalSnapshotBeforeUpdate,
                    );
                  } catch (error$139) {
                    captureCommitPhaseError(
                      finishedWork,
                      finishedWork.return,
                      error$139,
                    );
                  }
                }
              flags & 64 && commitClassCallbacks(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 3:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (
                flags & 64 &&
                ((finishedRoot = finishedWork.updateQueue),
                null !== finishedRoot)
              ) {
                current = null;
                if (null !== finishedWork.child)
                  switch (finishedWork.child.tag) {
                    case 27:
                    case 5:
                      current = finishedWork.child.stateNode;
                      break;
                    case 1:
                      current = finishedWork.child.stateNode;
                  }
                try {
                  commitCallbacks(finishedRoot, current);
                } catch (error) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error,
                  );
                }
              }
              break;
            case 27:
              null === current &&
                flags & 4 &&
                commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              null === current && flags & 4 && commitHostMount(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              break;
            case 31:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 &&
                commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 &&
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              flags & 64 &&
                ((finishedRoot = finishedWork.memoizedState),
                null !== finishedRoot &&
                  ((finishedRoot = finishedRoot.dehydrated),
                  null !== finishedRoot &&
                    ((finishedWork = retryDehydratedSuspenseBoundary.bind(
                      null,
                      finishedWork,
                    )),
                    registerSuspenseInstanceRetry(
                      finishedRoot,
                      finishedWork,
                    ))));
              break;
            case 22:
              flags =
                null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
              if (!flags) {
                current =
                  (null !== current && null !== current.memoizedState) ||
                  offscreenSubtreeWasHidden;
                prevProps = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = flags;
                (offscreenSubtreeWasHidden = current) &&
                !prevOffscreenSubtreeWasHidden
                  ? recursivelyTraverseReappearLayoutEffects(
                      finishedRoot,
                      finishedWork,
                      0 !== (finishedWork.subtreeFlags & 8772),
                    )
                  : recursivelyTraverseLayoutEffects(
                      finishedRoot,
                      finishedWork,
                    );
                offscreenSubtreeIsHidden = prevProps;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              }
              break;
            case 30:
              break;
            default:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          }
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          null !== alternate &&
            ((fiber.alternate = null), detachFiberAfterEffects(alternate));
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          5 === fiber.tag &&
            ((alternate = fiber.stateNode),
            null !== alternate && detachDeletedInstance(alternate));
          fiber.stateNode = null;
          fiber.return = null;
          fiber.dependencies = null;
          fiber.memoizedProps = null;
          fiber.memoizedState = null;
          fiber.pendingProps = null;
          fiber.stateNode = null;
          fiber.updateQueue = null;
        }
        var hostParent = null,
          hostParentIsContainer = !1;
        function recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          parent,
        ) {
          for (parent = parent.child; null !== parent; )
            commitDeletionEffectsOnFiber(
              finishedRoot,
              nearestMountedAncestor,
              parent,
            ),
              (parent = parent.sibling);
        }
        function commitDeletionEffectsOnFiber(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber,
        ) {
          if (
            injectedHook &&
            'function' === typeof injectedHook.onCommitFiberUnmount
          )
            try {
              injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
            } catch (err) {}
          switch (deletedFiber.tag) {
            case 26:
              offscreenSubtreeWasHidden ||
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber,
              );
              deletedFiber.memoizedState
                ? deletedFiber.memoizedState.count--
                : deletedFiber.stateNode &&
                  ((deletedFiber = deletedFiber.stateNode),
                  deletedFiber.parentNode.removeChild(deletedFiber));
              break;
            case 27:
              offscreenSubtreeWasHidden ||
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent,
                prevHostParentIsContainer = hostParentIsContainer;
              isSingletonScope(deletedFiber.type) &&
                ((hostParent = deletedFiber.stateNode),
                (hostParentIsContainer = !1));
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber,
              );
              releaseSingletonInstance(deletedFiber.stateNode);
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 5:
              offscreenSubtreeWasHidden ||
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
            case 6:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber,
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    (9 === hostParent.nodeType
                      ? hostParent.body
                      : 'HTML' === hostParent.nodeName
                        ? hostParent.ownerDocument.body
                        : hostParent
                    ).removeChild(deletedFiber.stateNode);
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error,
                    );
                  }
                else
                  try {
                    hostParent.removeChild(deletedFiber.stateNode);
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error,
                    );
                  }
              break;
            case 18:
              null !== hostParent &&
                (hostParentIsContainer
                  ? ((finishedRoot = hostParent),
                    clearHydrationBoundary(
                      9 === finishedRoot.nodeType
                        ? finishedRoot.body
                        : 'HTML' === finishedRoot.nodeName
                          ? finishedRoot.ownerDocument.body
                          : finishedRoot,
                      deletedFiber.stateNode,
                    ),
                    retryIfBlockedOn(finishedRoot))
                  : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
              break;
            case 4:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = !0;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber,
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(
                2,
                deletedFiber,
                nearestMountedAncestor,
              );
              offscreenSubtreeWasHidden ||
                commitHookEffectListUnmount(
                  4,
                  deletedFiber,
                  nearestMountedAncestor,
                );
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber,
              );
              break;
            case 1:
              offscreenSubtreeWasHidden ||
                (safelyDetachRef(deletedFiber, nearestMountedAncestor),
                (prevHostParent = deletedFiber.stateNode),
                'function' === typeof prevHostParent.componentWillUnmount &&
                  safelyCallComponentWillUnmount(
                    deletedFiber,
                    nearestMountedAncestor,
                    prevHostParent,
                  ));
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber,
              );
              break;
            case 21:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber,
              );
              break;
            case 22:
              offscreenSubtreeWasHidden =
                (prevHostParent = offscreenSubtreeWasHidden) ||
                null !== deletedFiber.memoizedState;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber,
              );
              offscreenSubtreeWasHidden = prevHostParent;
              break;
            default:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber,
              );
          }
        }
        function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
          if (
            null === finishedWork.memoizedState &&
            ((finishedRoot = finishedWork.alternate),
            null !== finishedRoot &&
              ((finishedRoot = finishedRoot.memoizedState),
              null !== finishedRoot))
          ) {
            finishedRoot = finishedRoot.dehydrated;
            try {
              retryIfBlockedOn(finishedRoot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          if (
            null === finishedWork.memoizedState &&
            ((finishedRoot = finishedWork.alternate),
            null !== finishedRoot &&
              ((finishedRoot = finishedRoot.memoizedState),
              null !== finishedRoot &&
                ((finishedRoot = finishedRoot.dehydrated),
                null !== finishedRoot)))
          )
            try {
              retryIfBlockedOn(finishedRoot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function getRetryCache(finishedWork) {
          switch (finishedWork.tag) {
            case 31:
            case 13:
            case 19:
              var retryCache = finishedWork.stateNode;
              null === retryCache &&
                (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
              return retryCache;
            case 22:
              return (
                (finishedWork = finishedWork.stateNode),
                (retryCache = finishedWork._retryCache),
                null === retryCache &&
                  (retryCache = finishedWork._retryCache =
                    new PossiblyWeakSet()),
                retryCache
              );
            default:
              throw Error(formatProdErrorMessage(435, finishedWork.tag));
          }
        }
        function attachSuspenseRetryListeners(finishedWork, wakeables) {
          var retryCache = getRetryCache(finishedWork);
          wakeables.forEach(function (wakeable) {
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              var retry = resolveRetryWakeable.bind(
                null,
                finishedWork,
                wakeable,
              );
              wakeable.then(retry, retry);
            }
          });
        }
        function recursivelyTraverseMutationEffects(
          root$jscomp$0,
          parentFiber,
        ) {
          var deletions = parentFiber.deletions;
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i],
                root = root$jscomp$0,
                returnFiber = parentFiber,
                parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (isSingletonScope(parent.type)) {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = !1;
                      break a;
                    }
                    break;
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = !1;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = !0;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent) throw Error(formatProdErrorMessage(160));
              commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
              hostParent = null;
              hostParentIsContainer = !1;
              root = childToDelete.alternate;
              null !== root && (root.return = null);
              childToDelete.return = null;
            }
          if (parentFiber.subtreeFlags & 13886)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
                (parentFiber = parentFiber.sibling);
        }
        var currentHoistableRoot = null;
        function commitMutationEffectsOnFiber(finishedWork, root) {
          var current = finishedWork.alternate,
            flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 &&
                (commitHookEffectListUnmount(
                  3,
                  finishedWork,
                  finishedWork.return,
                ),
                commitHookEffectListMount(3, finishedWork),
                commitHookEffectListUnmount(
                  5,
                  finishedWork,
                  finishedWork.return,
                ));
              break;
            case 1:
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 &&
                (offscreenSubtreeWasHidden ||
                  null === current ||
                  safelyDetachRef(current, current.return));
              flags & 64 &&
                offscreenSubtreeIsHidden &&
                ((finishedWork = finishedWork.updateQueue),
                null !== finishedWork &&
                  ((flags = finishedWork.callbacks),
                  null !== flags &&
                    ((current = finishedWork.shared.hiddenCallbacks),
                    (finishedWork.shared.hiddenCallbacks =
                      null === current ? flags : current.concat(flags)))));
              break;
            case 26:
              var hoistableRoot = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 &&
                (offscreenSubtreeWasHidden ||
                  null === current ||
                  safelyDetachRef(current, current.return));
              if (flags & 4) {
                var currentResource =
                  null !== current ? current.memoizedState : null;
                flags = finishedWork.memoizedState;
                if (null === current)
                  if (null === flags)
                    if (null === finishedWork.stateNode) {
                      a: {
                        flags = finishedWork.type;
                        current = finishedWork.memoizedProps;
                        hoistableRoot =
                          hoistableRoot.ownerDocument || hoistableRoot;
                        b: switch (flags) {
                          case 'title':
                            currentResource =
                              hoistableRoot.getElementsByTagName('title')[0];
                            if (
                              !currentResource ||
                              currentResource[internalHoistableMarker] ||
                              currentResource[internalInstanceKey] ||
                              'http://www.w3.org/2000/svg' ===
                                currentResource.namespaceURI ||
                              currentResource.hasAttribute('itemprop')
                            )
                              (currentResource =
                                hoistableRoot.createElement(flags)),
                                hoistableRoot.head.insertBefore(
                                  currentResource,
                                  hoistableRoot.querySelector('head > title'),
                                );
                            setInitialProperties(
                              currentResource,
                              flags,
                              current,
                            );
                            currentResource[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(currentResource);
                            flags = currentResource;
                            break a;
                          case 'link':
                            var maybeNodes = getHydratableHoistableCache(
                              'link',
                              'href',
                              hoistableRoot,
                            ).get(flags + (current.href || ''));
                            if (maybeNodes)
                              for (var i = 0; i < maybeNodes.length; i++)
                                if (
                                  ((currentResource = maybeNodes[i]),
                                  currentResource.getAttribute('href') ===
                                    (null == current.href || '' === current.href
                                      ? null
                                      : current.href) &&
                                    currentResource.getAttribute('rel') ===
                                      (null == current.rel
                                        ? null
                                        : current.rel) &&
                                    currentResource.getAttribute('title') ===
                                      (null == current.title
                                        ? null
                                        : current.title) &&
                                    currentResource.getAttribute(
                                      'crossorigin',
                                    ) ===
                                      (null == current.crossOrigin
                                        ? null
                                        : current.crossOrigin))
                                ) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            currentResource =
                              hoistableRoot.createElement(flags);
                            setInitialProperties(
                              currentResource,
                              flags,
                              current,
                            );
                            hoistableRoot.head.appendChild(currentResource);
                            break;
                          case 'meta':
                            if (
                              (maybeNodes = getHydratableHoistableCache(
                                'meta',
                                'content',
                                hoistableRoot,
                              ).get(flags + (current.content || '')))
                            )
                              for (i = 0; i < maybeNodes.length; i++)
                                if (
                                  ((currentResource = maybeNodes[i]),
                                  currentResource.getAttribute('content') ===
                                    (null == current.content
                                      ? null
                                      : '' + current.content) &&
                                    currentResource.getAttribute('name') ===
                                      (null == current.name
                                        ? null
                                        : current.name) &&
                                    currentResource.getAttribute('property') ===
                                      (null == current.property
                                        ? null
                                        : current.property) &&
                                    currentResource.getAttribute(
                                      'http-equiv',
                                    ) ===
                                      (null == current.httpEquiv
                                        ? null
                                        : current.httpEquiv) &&
                                    currentResource.getAttribute('charset') ===
                                      (null == current.charSet
                                        ? null
                                        : current.charSet))
                                ) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            currentResource =
                              hoistableRoot.createElement(flags);
                            setInitialProperties(
                              currentResource,
                              flags,
                              current,
                            );
                            hoistableRoot.head.appendChild(currentResource);
                            break;
                          default:
                            throw Error(formatProdErrorMessage(468, flags));
                        }
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                      }
                      finishedWork.stateNode = flags;
                    } else
                      mountHoistable(
                        hoistableRoot,
                        finishedWork.type,
                        finishedWork.stateNode,
                      );
                  else
                    finishedWork.stateNode = acquireResource(
                      hoistableRoot,
                      flags,
                      finishedWork.memoizedProps,
                    );
                else
                  currentResource !== flags
                    ? (null === currentResource
                        ? null !== current.stateNode &&
                          ((current = current.stateNode),
                          current.parentNode.removeChild(current))
                        : currentResource.count--,
                      null === flags
                        ? mountHoistable(
                            hoistableRoot,
                            finishedWork.type,
                            finishedWork.stateNode,
                          )
                        : acquireResource(
                            hoistableRoot,
                            flags,
                            finishedWork.memoizedProps,
                          ))
                    : null === flags &&
                      null !== finishedWork.stateNode &&
                      commitHostUpdate(
                        finishedWork,
                        finishedWork.memoizedProps,
                        current.memoizedProps,
                      );
              }
              break;
            case 27:
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 &&
                (offscreenSubtreeWasHidden ||
                  null === current ||
                  safelyDetachRef(current, current.return));
              null !== current &&
                flags & 4 &&
                commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps,
                );
              break;
            case 5:
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 &&
                (offscreenSubtreeWasHidden ||
                  null === current ||
                  safelyDetachRef(current, current.return));
              if (finishedWork.flags & 32) {
                hoistableRoot = finishedWork.stateNode;
                try {
                  setTextContent(hoistableRoot, '');
                } catch (error) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error,
                  );
                }
              }
              flags & 4 &&
                null != finishedWork.stateNode &&
                ((hoistableRoot = finishedWork.memoizedProps),
                commitHostUpdate(
                  finishedWork,
                  hoistableRoot,
                  null !== current ? current.memoizedProps : hoistableRoot,
                ));
              flags & 1024 && (needsFormReset = !0);
              break;
            case 6:
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & 4) {
                if (null === finishedWork.stateNode)
                  throw Error(formatProdErrorMessage(162));
                flags = finishedWork.memoizedProps;
                current = finishedWork.stateNode;
                try {
                  current.nodeValue = flags;
                } catch (error) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error,
                  );
                }
              }
              break;
            case 3:
              tagCaches = null;
              hoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(root.containerInfo);
              recursivelyTraverseMutationEffects(root, finishedWork);
              currentHoistableRoot = hoistableRoot;
              commitReconciliationEffects(finishedWork);
              if (
                flags & 4 &&
                null !== current &&
                current.memoizedState.isDehydrated
              )
                try {
                  retryIfBlockedOn(root.containerInfo);
                } catch (error) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error,
                  );
                }
              needsFormReset &&
                ((needsFormReset = !1), recursivelyResetForms(finishedWork));
              break;
            case 4:
              flags = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                finishedWork.stateNode.containerInfo,
              );
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              currentHoistableRoot = flags;
              break;
            case 12:
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              break;
            case 31:
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 &&
                ((flags = finishedWork.updateQueue),
                null !== flags &&
                  ((finishedWork.updateQueue = null),
                  attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 13:
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.child.flags & 8192 &&
                (null !== finishedWork.memoizedState) !==
                  (null !== current && null !== current.memoizedState) &&
                (globalMostRecentFallbackTime = now());
              flags & 4 &&
                ((flags = finishedWork.updateQueue),
                null !== flags &&
                  ((finishedWork.updateQueue = null),
                  attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 22:
              hoistableRoot = null !== finishedWork.memoizedState;
              var wasHidden =
                  null !== current && null !== current.memoizedState,
                prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
                prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden =
                prevOffscreenSubtreeIsHidden || hoistableRoot;
              offscreenSubtreeWasHidden =
                prevOffscreenSubtreeWasHidden || wasHidden;
              recursivelyTraverseMutationEffects(root, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              commitReconciliationEffects(finishedWork);
              if (flags & 8192)
                a: for (
                  root = finishedWork.stateNode,
                    root._visibility = hoistableRoot
                      ? root._visibility & -2
                      : root._visibility | 1,
                    hoistableRoot &&
                      (null === current ||
                        wasHidden ||
                        offscreenSubtreeIsHidden ||
                        offscreenSubtreeWasHidden ||
                        recursivelyTraverseDisappearLayoutEffects(
                          finishedWork,
                        )),
                    current = null,
                    root = finishedWork;
                  ;

                ) {
                  if (5 === root.tag || 26 === root.tag) {
                    if (null === current) {
                      wasHidden = current = root;
                      try {
                        if (
                          ((currentResource = wasHidden.stateNode),
                          hoistableRoot)
                        )
                          (maybeNodes = currentResource.style),
                            'function' === typeof maybeNodes.setProperty
                              ? maybeNodes.setProperty(
                                  'display',
                                  'none',
                                  'important',
                                )
                              : (maybeNodes.display = 'none');
                        else {
                          i = wasHidden.stateNode;
                          var styleProp = wasHidden.memoizedProps.style,
                            display =
                              void 0 !== styleProp &&
                              null !== styleProp &&
                              styleProp.hasOwnProperty('display')
                                ? styleProp.display
                                : null;
                          i.style.display =
                            null == display || 'boolean' === typeof display
                              ? ''
                              : ('' + display).trim();
                        }
                      } catch (error) {
                        captureCommitPhaseError(
                          wasHidden,
                          wasHidden.return,
                          error,
                        );
                      }
                    }
                  } else if (6 === root.tag) {
                    if (null === current) {
                      wasHidden = root;
                      try {
                        wasHidden.stateNode.nodeValue = hoistableRoot
                          ? ''
                          : wasHidden.memoizedProps;
                      } catch (error) {
                        captureCommitPhaseError(
                          wasHidden,
                          wasHidden.return,
                          error,
                        );
                      }
                    }
                  } else if (18 === root.tag) {
                    if (null === current) {
                      wasHidden = root;
                      try {
                        var instance = wasHidden.stateNode;
                        hoistableRoot
                          ? hideOrUnhideDehydratedBoundary(instance, !0)
                          : hideOrUnhideDehydratedBoundary(
                              wasHidden.stateNode,
                              !1,
                            );
                      } catch (error) {
                        captureCommitPhaseError(
                          wasHidden,
                          wasHidden.return,
                          error,
                        );
                      }
                    }
                  } else if (
                    ((22 !== root.tag && 23 !== root.tag) ||
                      null === root.memoizedState ||
                      root === finishedWork) &&
                    null !== root.child
                  ) {
                    root.child.return = root;
                    root = root.child;
                    continue;
                  }
                  if (root === finishedWork) break a;
                  for (; null === root.sibling; ) {
                    if (null === root.return || root.return === finishedWork)
                      break a;
                    current === root && (current = null);
                    root = root.return;
                  }
                  current === root && (current = null);
                  root.sibling.return = root.return;
                  root = root.sibling;
                }
              flags & 4 &&
                ((flags = finishedWork.updateQueue),
                null !== flags &&
                  ((current = flags.retryQueue),
                  null !== current &&
                    ((flags.retryQueue = null),
                    attachSuspenseRetryListeners(finishedWork, current))));
              break;
            case 19:
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 &&
                ((flags = finishedWork.updateQueue),
                null !== flags &&
                  ((finishedWork.updateQueue = null),
                  attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 30:
              break;
            case 21:
              break;
            default:
              recursivelyTraverseMutationEffects(root, finishedWork),
                commitReconciliationEffects(finishedWork);
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & 2) {
            try {
              for (
                var hostParentFiber, parentFiber = finishedWork.return;
                null !== parentFiber;

              ) {
                if (isHostParent(parentFiber)) {
                  hostParentFiber = parentFiber;
                  break;
                }
                parentFiber = parentFiber.return;
              }
              if (null == hostParentFiber)
                throw Error(formatProdErrorMessage(160));
              switch (hostParentFiber.tag) {
                case 27:
                  var parent = hostParentFiber.stateNode,
                    before = getHostSibling(finishedWork);
                  insertOrAppendPlacementNode(finishedWork, before, parent);
                  break;
                case 5:
                  var parent$141 = hostParentFiber.stateNode;
                  hostParentFiber.flags & 32 &&
                    (setTextContent(parent$141, ''),
                    (hostParentFiber.flags &= -33));
                  var before$142 = getHostSibling(finishedWork);
                  insertOrAppendPlacementNode(
                    finishedWork,
                    before$142,
                    parent$141,
                  );
                  break;
                case 3:
                case 4:
                  var parent$143 = hostParentFiber.stateNode.containerInfo,
                    before$144 = getHostSibling(finishedWork);
                  insertOrAppendPlacementNodeIntoContainer(
                    finishedWork,
                    before$144,
                    parent$143,
                  );
                  break;
                default:
                  throw Error(formatProdErrorMessage(161));
              }
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
            finishedWork.flags &= -3;
          }
          flags & 4096 && (finishedWork.flags &= -4097);
        }
        function recursivelyResetForms(parentFiber) {
          if (parentFiber.subtreeFlags & 1024)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var fiber = parentFiber;
              recursivelyResetForms(fiber);
              5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseLayoutEffects(root, parentFiber) {
          if (parentFiber.subtreeFlags & 8772)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitLayoutEffectOnFiber(
                root,
                parentFiber.alternate,
                parentFiber,
              ),
                (parentFiber = parentFiber.sibling);
        }
        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedWork = parentFiber;
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                commitHookEffectListUnmount(
                  4,
                  finishedWork,
                  finishedWork.return,
                );
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
              case 1:
                safelyDetachRef(finishedWork, finishedWork.return);
                var instance = finishedWork.stateNode;
                'function' === typeof instance.componentWillUnmount &&
                  safelyCallComponentWillUnmount(
                    finishedWork,
                    finishedWork.return,
                    instance,
                  );
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
              case 27:
                releaseSingletonInstance(finishedWork.stateNode);
              case 26:
              case 5:
                safelyDetachRef(finishedWork, finishedWork.return);
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
              case 22:
                null === finishedWork.memoizedState &&
                  recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
              case 30:
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
              default:
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
        }
        function recursivelyTraverseReappearLayoutEffects(
          finishedRoot$jscomp$0,
          parentFiber,
          includeWorkInProgressEffects,
        ) {
          includeWorkInProgressEffects =
            includeWorkInProgressEffects &&
            0 !== (parentFiber.subtreeFlags & 8772);
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var current = parentFiber.alternate,
              finishedRoot = finishedRoot$jscomp$0,
              finishedWork = parentFiber,
              flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 15:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects,
                );
                commitHookEffectListMount(4, finishedWork);
                break;
              case 1:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects,
                );
                current = finishedWork;
                finishedRoot = current.stateNode;
                if ('function' === typeof finishedRoot.componentDidMount)
                  try {
                    finishedRoot.componentDidMount();
                  } catch (error) {
                    captureCommitPhaseError(current, current.return, error);
                  }
                current = finishedWork;
                finishedRoot = current.updateQueue;
                if (null !== finishedRoot) {
                  var instance = current.stateNode;
                  try {
                    var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                    if (null !== hiddenCallbacks)
                      for (
                        finishedRoot.shared.hiddenCallbacks = null,
                          finishedRoot = 0;
                        finishedRoot < hiddenCallbacks.length;
                        finishedRoot++
                      )
                        callCallback(hiddenCallbacks[finishedRoot], instance);
                  } catch (error) {
                    captureCommitPhaseError(current, current.return, error);
                  }
                }
                includeWorkInProgressEffects &&
                  flags & 64 &&
                  commitClassCallbacks(finishedWork);
                safelyAttachRef(finishedWork, finishedWork.return);
                break;
              case 27:
                commitHostSingletonAcquisition(finishedWork);
              case 26:
              case 5:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects,
                );
                includeWorkInProgressEffects &&
                  null === current &&
                  flags & 4 &&
                  commitHostMount(finishedWork);
                safelyAttachRef(finishedWork, finishedWork.return);
                break;
              case 12:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects,
                );
                break;
              case 31:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects,
                );
                includeWorkInProgressEffects &&
                  flags & 4 &&
                  commitActivityHydrationCallbacks(finishedRoot, finishedWork);
                break;
              case 13:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects,
                );
                includeWorkInProgressEffects &&
                  flags & 4 &&
                  commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                break;
              case 22:
                null === finishedWork.memoizedState &&
                  recursivelyTraverseReappearLayoutEffects(
                    finishedRoot,
                    finishedWork,
                    includeWorkInProgressEffects,
                  );
                safelyAttachRef(finishedWork, finishedWork.return);
                break;
              case 30:
                break;
              default:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects,
                );
            }
            parentFiber = parentFiber.sibling;
          }
        }
        function commitOffscreenPassiveMountEffects(current, finishedWork) {
          var previousCache = null;
          null !== current &&
            null !== current.memoizedState &&
            null !== current.memoizedState.cachePool &&
            (previousCache = current.memoizedState.cachePool.pool);
          current = null;
          null !== finishedWork.memoizedState &&
            null !== finishedWork.memoizedState.cachePool &&
            (current = finishedWork.memoizedState.cachePool.pool);
          current !== previousCache &&
            (null != current && current.refCount++,
            null != previousCache && releaseCache(previousCache));
        }
        function commitCachePassiveMountEffect(current, finishedWork) {
          current = null;
          null !== finishedWork.alternate &&
            (current = finishedWork.alternate.memoizedState.cache);
          finishedWork = finishedWork.memoizedState.cache;
          finishedWork !== current &&
            (finishedWork.refCount++, null != current && releaseCache(current));
        }
        function recursivelyTraversePassiveMountEffects(
          root,
          parentFiber,
          committedLanes,
          committedTransitions,
        ) {
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveMountOnFiber(
                root,
                parentFiber,
                committedLanes,
                committedTransitions,
              ),
                (parentFiber = parentFiber.sibling);
        }
        function commitPassiveMountOnFiber(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
        ) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
              );
              flags & 2048 && commitHookEffectListMount(9, finishedWork);
              break;
            case 1:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
              );
              break;
            case 3:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
              );
              flags & 2048 &&
                ((finishedRoot = null),
                null !== finishedWork.alternate &&
                  (finishedRoot = finishedWork.alternate.memoizedState.cache),
                (finishedWork = finishedWork.memoizedState.cache),
                finishedWork !== finishedRoot &&
                  (finishedWork.refCount++,
                  null != finishedRoot && releaseCache(finishedRoot)));
              break;
            case 12:
              if (flags & 2048) {
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                );
                finishedRoot = finishedWork.stateNode;
                try {
                  var _finishedWork$memoize2 = finishedWork.memoizedProps,
                    id = _finishedWork$memoize2.id,
                    onPostCommit = _finishedWork$memoize2.onPostCommit;
                  'function' === typeof onPostCommit &&
                    onPostCommit(
                      id,
                      null === finishedWork.alternate ? 'mount' : 'update',
                      finishedRoot.passiveEffectDuration,
                      -0,
                    );
                } catch (error) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error,
                  );
                }
              } else
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                );
              break;
            case 31:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
              );
              break;
            case 13:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
              );
              break;
            case 23:
              break;
            case 22:
              _finishedWork$memoize2 = finishedWork.stateNode;
              id = finishedWork.alternate;
              null !== finishedWork.memoizedState
                ? _finishedWork$memoize2._visibility & 2
                  ? recursivelyTraversePassiveMountEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions,
                    )
                  : recursivelyTraverseAtomicPassiveEffects(
                      finishedRoot,
                      finishedWork,
                    )
                : _finishedWork$memoize2._visibility & 2
                  ? recursivelyTraversePassiveMountEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions,
                    )
                  : ((_finishedWork$memoize2._visibility |= 2),
                    recursivelyTraverseReconnectPassiveEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions,
                      0 !== (finishedWork.subtreeFlags & 10256) || !1,
                    ));
              flags & 2048 &&
                commitOffscreenPassiveMountEffects(id, finishedWork);
              break;
            case 24:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
              );
              flags & 2048 &&
                commitCachePassiveMountEffect(
                  finishedWork.alternate,
                  finishedWork,
                );
              break;
            default:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
              );
          }
        }
        function recursivelyTraverseReconnectPassiveEffects(
          finishedRoot$jscomp$0,
          parentFiber,
          committedLanes$jscomp$0,
          committedTransitions$jscomp$0,
          includeWorkInProgressEffects,
        ) {
          includeWorkInProgressEffects =
            includeWorkInProgressEffects &&
            (0 !== (parentFiber.subtreeFlags & 10256) || !1);
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0,
              finishedWork = parentFiber,
              committedLanes = committedLanes$jscomp$0,
              committedTransitions = committedTransitions$jscomp$0,
              flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 15:
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects,
                );
                commitHookEffectListMount(8, finishedWork);
                break;
              case 23:
                break;
              case 22:
                var instance = finishedWork.stateNode;
                null !== finishedWork.memoizedState
                  ? instance._visibility & 2
                    ? recursivelyTraverseReconnectPassiveEffects(
                        finishedRoot,
                        finishedWork,
                        committedLanes,
                        committedTransitions,
                        includeWorkInProgressEffects,
                      )
                    : recursivelyTraverseAtomicPassiveEffects(
                        finishedRoot,
                        finishedWork,
                      )
                  : ((instance._visibility |= 2),
                    recursivelyTraverseReconnectPassiveEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions,
                      includeWorkInProgressEffects,
                    ));
                includeWorkInProgressEffects &&
                  flags & 2048 &&
                  commitOffscreenPassiveMountEffects(
                    finishedWork.alternate,
                    finishedWork,
                  );
                break;
              case 24:
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects,
                );
                includeWorkInProgressEffects &&
                  flags & 2048 &&
                  commitCachePassiveMountEffect(
                    finishedWork.alternate,
                    finishedWork,
                  );
                break;
              default:
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects,
                );
            }
            parentFiber = parentFiber.sibling;
          }
        }
        function recursivelyTraverseAtomicPassiveEffects(
          finishedRoot$jscomp$0,
          parentFiber,
        ) {
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var finishedRoot = finishedRoot$jscomp$0,
                finishedWork = parentFiber,
                flags = finishedWork.flags;
              switch (finishedWork.tag) {
                case 22:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork,
                  );
                  flags & 2048 &&
                    commitOffscreenPassiveMountEffects(
                      finishedWork.alternate,
                      finishedWork,
                    );
                  break;
                case 24:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork,
                  );
                  flags & 2048 &&
                    commitCachePassiveMountEffect(
                      finishedWork.alternate,
                      finishedWork,
                    );
                  break;
                default:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork,
                  );
              }
              parentFiber = parentFiber.sibling;
            }
        }
        var suspenseyCommitFlag = 8192;
        function recursivelyAccumulateSuspenseyCommit(
          parentFiber,
          committedLanes,
          suspendedState,
        ) {
          if (parentFiber.subtreeFlags & suspenseyCommitFlag)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              accumulateSuspenseyCommitOnFiber(
                parentFiber,
                committedLanes,
                suspendedState,
              ),
                (parentFiber = parentFiber.sibling);
        }
        function accumulateSuspenseyCommitOnFiber(
          fiber,
          committedLanes,
          suspendedState,
        ) {
          switch (fiber.tag) {
            case 26:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState,
              );
              fiber.flags & suspenseyCommitFlag &&
                null !== fiber.memoizedState &&
                suspendResource(
                  suspendedState,
                  currentHoistableRoot,
                  fiber.memoizedState,
                  fiber.memoizedProps,
                );
              break;
            case 5:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState,
              );
              break;
            case 3:
            case 4:
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo,
              );
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState,
              );
              currentHoistableRoot = previousHoistableRoot;
              break;
            case 22:
              null === fiber.memoizedState &&
                ((previousHoistableRoot = fiber.alternate),
                null !== previousHoistableRoot &&
                null !== previousHoistableRoot.memoizedState
                  ? ((previousHoistableRoot = suspenseyCommitFlag),
                    (suspenseyCommitFlag = 16777216),
                    recursivelyAccumulateSuspenseyCommit(
                      fiber,
                      committedLanes,
                      suspendedState,
                    ),
                    (suspenseyCommitFlag = previousHoistableRoot))
                  : recursivelyAccumulateSuspenseyCommit(
                      fiber,
                      committedLanes,
                      suspendedState,
                    ));
              break;
            default:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState,
              );
          }
        }
        function detachAlternateSiblings(parentFiber) {
          var previousFiber = parentFiber.alternate;
          if (
            null !== previousFiber &&
            ((parentFiber = previousFiber.child), null !== parentFiber)
          ) {
            previousFiber.child = null;
            do
              (previousFiber = parentFiber.sibling),
                (parentFiber.sibling = null),
                (parentFiber = previousFiber);
            while (null !== parentFiber);
          }
        }
        function recursivelyTraversePassiveUnmountEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber,
                );
              }
            detachAlternateSiblings(parentFiber);
          }
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveUnmountOnFiber(parentFiber),
                (parentFiber = parentFiber.sibling);
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.flags & 2048 &&
                commitHookEffectListUnmount(
                  9,
                  finishedWork,
                  finishedWork.return,
                );
              break;
            case 3:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            case 12:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            case 22:
              var instance = finishedWork.stateNode;
              null !== finishedWork.memoizedState &&
              instance._visibility & 2 &&
              (null === finishedWork.return || 13 !== finishedWork.return.tag)
                ? ((instance._visibility &= -3),
                  recursivelyTraverseDisconnectPassiveEffects(finishedWork))
                : recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            default:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
          }
        }
        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber,
                );
              }
            detachAlternateSiblings(parentFiber);
          }
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            deletions = parentFiber;
            switch (deletions.tag) {
              case 0:
              case 11:
              case 15:
                commitHookEffectListUnmount(8, deletions, deletions.return);
                recursivelyTraverseDisconnectPassiveEffects(deletions);
                break;
              case 22:
                i = deletions.stateNode;
                i._visibility & 2 &&
                  ((i._visibility &= -3),
                  recursivelyTraverseDisconnectPassiveEffects(deletions));
                break;
              default:
                recursivelyTraverseDisconnectPassiveEffects(deletions);
            }
            parentFiber = parentFiber.sibling;
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          deletedSubtreeRoot,
          nearestMountedAncestor,
        ) {
          for (; null !== nextEffect; ) {
            var fiber = nextEffect;
            switch (fiber.tag) {
              case 0:
              case 11:
              case 15:
                commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
                break;
              case 23:
              case 22:
                if (
                  null !== fiber.memoizedState &&
                  null !== fiber.memoizedState.cachePool
                ) {
                  var cache = fiber.memoizedState.cachePool.pool;
                  null != cache && cache.refCount++;
                }
                break;
              case 24:
                releaseCache(fiber.memoizedState.cache);
            }
            cache = fiber.child;
            if (null !== cache) (cache.return = fiber), (nextEffect = cache);
            else
              a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                cache = nextEffect;
                var sibling = cache.sibling,
                  returnFiber = cache.return;
                detachFiberAfterEffects(cache);
                if (cache === fiber) {
                  nextEffect = null;
                  break a;
                }
                if (null !== sibling) {
                  sibling.return = returnFiber;
                  nextEffect = sibling;
                  break a;
                }
                nextEffect = returnFiber;
              }
          }
        }
        var DefaultAsyncDispatcher = {
            getCacheForType: function (resourceType) {
              var cache = readContext(CacheContext),
                cacheForType = cache.data.get(resourceType);
              void 0 === cacheForType &&
                ((cacheForType = resourceType()),
                cache.data.set(resourceType, cacheForType));
              return cacheForType;
            },
            cacheSignal: function () {
              return readContext(CacheContext).controller.signal;
            },
          },
          PossiblyWeakMap = 'function' === typeof WeakMap ? WeakMap : Map,
          executionContext = 0,
          workInProgressRoot = null,
          workInProgress = null,
          workInProgressRootRenderLanes = 0,
          workInProgressSuspendedReason = 0,
          workInProgressThrownValue = null,
          workInProgressRootDidSkipSuspendedSiblings = !1,
          workInProgressRootIsPrerendering = !1,
          workInProgressRootDidAttachPingListener = !1,
          entangledRenderLanes = 0,
          workInProgressRootExitStatus = 0,
          workInProgressRootSkippedLanes = 0,
          workInProgressRootInterleavedUpdatedLanes = 0,
          workInProgressRootPingedLanes = 0,
          workInProgressDeferredLane = 0,
          workInProgressSuspendedRetryLanes = 0,
          workInProgressRootConcurrentErrors = null,
          workInProgressRootRecoverableErrors = null,
          workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
          globalMostRecentFallbackTime = 0,
          globalMostRecentTransitionTime = 0,
          workInProgressRootRenderTargetTime = Infinity,
          workInProgressTransitions = null,
          legacyErrorBoundariesThatAlreadyFailed = null,
          pendingEffectsStatus = 0,
          pendingEffectsRoot = null,
          pendingFinishedWork = null,
          pendingEffectsLanes = 0,
          pendingEffectsRemainingLanes = 0,
          pendingPassiveTransitions = null,
          pendingRecoverableErrors = null,
          nestedUpdateCount = 0,
          rootWithNestedUpdates = null;
        function requestUpdateLane() {
          return 0 !== (executionContext & 2) &&
            0 !== workInProgressRootRenderLanes
            ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes
            : null !== ReactSharedInternals.T
              ? requestTransitionLane()
              : resolveUpdatePriority();
        }
        function requestDeferredLane() {
          if (0 === workInProgressDeferredLane)
            if (
              0 === (workInProgressRootRenderLanes & 536870912) ||
              isHydrating
            ) {
              var lane = nextTransitionDeferredLane;
              nextTransitionDeferredLane <<= 1;
              0 === (nextTransitionDeferredLane & 3932160) &&
                (nextTransitionDeferredLane = 262144);
              workInProgressDeferredLane = lane;
            } else workInProgressDeferredLane = 536870912;
          lane = suspenseHandlerStackCursor.current;
          null !== lane && (lane.flags |= 32);
          return workInProgressDeferredLane;
        }
        function scheduleUpdateOnFiber(root, fiber, lane) {
          if (
            (root === workInProgressRoot &&
              (2 === workInProgressSuspendedReason ||
                9 === workInProgressSuspendedReason)) ||
            null !== root.cancelPendingCommit
          )
            prepareFreshStack(root, 0),
              markRootSuspended(
                root,
                workInProgressRootRenderLanes,
                workInProgressDeferredLane,
                !1,
              );
          markRootUpdated$1(root, lane);
          if (0 === (executionContext & 2) || root !== workInProgressRoot)
            root === workInProgressRoot &&
              (0 === (executionContext & 2) &&
                (workInProgressRootInterleavedUpdatedLanes |= lane),
              4 === workInProgressRootExitStatus &&
                markRootSuspended(
                  root,
                  workInProgressRootRenderLanes,
                  workInProgressDeferredLane,
                  !1,
                )),
              ensureRootIsScheduled(root);
        }
        function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
          if (0 !== (executionContext & 6))
            throw Error(formatProdErrorMessage(327));
          var shouldTimeSlice =
              (!forceSync &&
                0 === (lanes & 127) &&
                0 === (lanes & root$jscomp$0.expiredLanes)) ||
              checkIfRootIsPrerendering(root$jscomp$0, lanes),
            exitStatus = shouldTimeSlice
              ? renderRootConcurrent(root$jscomp$0, lanes)
              : renderRootSync(root$jscomp$0, lanes, !0),
            renderWasConcurrent = shouldTimeSlice;
          do {
            if (0 === exitStatus) {
              workInProgressRootIsPrerendering &&
                !shouldTimeSlice &&
                markRootSuspended(root$jscomp$0, lanes, 0, !1);
              break;
            } else {
              forceSync = root$jscomp$0.current.alternate;
              if (
                renderWasConcurrent &&
                !isRenderConsistentWithExternalStores(forceSync)
              ) {
                exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
                renderWasConcurrent = !1;
                continue;
              }
              if (2 === exitStatus) {
                renderWasConcurrent = lanes;
                if (
                  root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent
                )
                  var JSCompiler_inline_result = 0;
                else
                  (JSCompiler_inline_result =
                    root$jscomp$0.pendingLanes & -536870913),
                    (JSCompiler_inline_result =
                      0 !== JSCompiler_inline_result
                        ? JSCompiler_inline_result
                        : JSCompiler_inline_result & 536870912
                          ? 536870912
                          : 0);
                if (0 !== JSCompiler_inline_result) {
                  lanes = JSCompiler_inline_result;
                  a: {
                    var root = root$jscomp$0;
                    exitStatus = workInProgressRootConcurrentErrors;
                    var wasRootDehydrated =
                      root.current.memoizedState.isDehydrated;
                    wasRootDehydrated &&
                      (prepareFreshStack(
                        root,
                        JSCompiler_inline_result,
                      ).flags |= 256);
                    JSCompiler_inline_result = renderRootSync(
                      root,
                      JSCompiler_inline_result,
                      !1,
                    );
                    if (2 !== JSCompiler_inline_result) {
                      if (
                        workInProgressRootDidAttachPingListener &&
                        !wasRootDehydrated
                      ) {
                        root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                        workInProgressRootInterleavedUpdatedLanes |=
                          renderWasConcurrent;
                        exitStatus = 4;
                        break a;
                      }
                      renderWasConcurrent = workInProgressRootRecoverableErrors;
                      workInProgressRootRecoverableErrors = exitStatus;
                      null !== renderWasConcurrent &&
                        (null === workInProgressRootRecoverableErrors
                          ? (workInProgressRootRecoverableErrors =
                              renderWasConcurrent)
                          : workInProgressRootRecoverableErrors.push.apply(
                              workInProgressRootRecoverableErrors,
                              renderWasConcurrent,
                            ));
                    }
                    exitStatus = JSCompiler_inline_result;
                  }
                  renderWasConcurrent = !1;
                  if (2 !== exitStatus) continue;
                }
              }
              if (1 === exitStatus) {
                prepareFreshStack(root$jscomp$0, 0);
                markRootSuspended(root$jscomp$0, lanes, 0, !0);
                break;
              }
              a: {
                shouldTimeSlice = root$jscomp$0;
                renderWasConcurrent = exitStatus;
                switch (renderWasConcurrent) {
                  case 0:
                  case 1:
                    throw Error(formatProdErrorMessage(345));
                  case 4:
                    if ((lanes & 4194048) !== lanes) break;
                  case 6:
                    markRootSuspended(
                      shouldTimeSlice,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings,
                    );
                    break a;
                  case 2:
                    workInProgressRootRecoverableErrors = null;
                    break;
                  case 3:
                  case 5:
                    break;
                  default:
                    throw Error(formatProdErrorMessage(329));
                }
                if (
                  (lanes & 62914560) === lanes &&
                  ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
                  10 < exitStatus)
                ) {
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings,
                  );
                  if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
                  pendingEffectsLanes = lanes;
                  shouldTimeSlice.timeoutHandle = scheduleTimeout(
                    commitRootWhenReady.bind(
                      null,
                      shouldTimeSlice,
                      forceSync,
                      workInProgressRootRecoverableErrors,
                      workInProgressTransitions,
                      workInProgressRootDidIncludeRecursiveRenderUpdate,
                      lanes,
                      workInProgressDeferredLane,
                      workInProgressRootInterleavedUpdatedLanes,
                      workInProgressSuspendedRetryLanes,
                      workInProgressRootDidSkipSuspendedSiblings,
                      renderWasConcurrent,
                      'Throttled',
                      -0,
                      0,
                    ),
                    exitStatus,
                  );
                  break a;
                }
                commitRootWhenReady(
                  shouldTimeSlice,
                  forceSync,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  renderWasConcurrent,
                  null,
                  -0,
                  0,
                );
              }
            }
            break;
          } while (1);
          ensureRootIsScheduled(root$jscomp$0);
        }
        function commitRootWhenReady(
          root,
          finishedWork,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          lanes,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
          didSkipSuspendedSiblings,
          exitStatus,
          suspendedCommitReason,
          completedRenderStartTime,
          completedRenderEndTime,
        ) {
          root.timeoutHandle = -1;
          suspendedCommitReason = finishedWork.subtreeFlags;
          if (
            suspendedCommitReason & 8192 ||
            16785408 === (suspendedCommitReason & 16785408)
          ) {
            suspendedCommitReason = {
              stylesheets: null,
              count: 0,
              imgCount: 0,
              imgBytes: 0,
              suspenseyImages: [],
              waitingForImages: !0,
              waitingForViewTransition: !1,
              unsuspend: noop$1,
            };
            accumulateSuspenseyCommitOnFiber(
              finishedWork,
              lanes,
              suspendedCommitReason,
            );
            var timeoutOffset =
              (lanes & 62914560) === lanes
                ? globalMostRecentFallbackTime - now()
                : (lanes & 4194048) === lanes
                  ? globalMostRecentTransitionTime - now()
                  : 0;
            timeoutOffset = waitForCommitToBeReady(
              suspendedCommitReason,
              timeoutOffset,
            );
            if (null !== timeoutOffset) {
              pendingEffectsLanes = lanes;
              root.cancelPendingCommit = timeoutOffset(
                commitRoot.bind(
                  null,
                  root,
                  finishedWork,
                  lanes,
                  recoverableErrors,
                  transitions,
                  didIncludeRenderPhaseUpdate,
                  spawnedLane,
                  updatedLanes,
                  suspendedRetryLanes,
                  exitStatus,
                  suspendedCommitReason,
                  null,
                  completedRenderStartTime,
                  completedRenderEndTime,
                ),
              );
              markRootSuspended(
                root,
                lanes,
                spawnedLane,
                !didSkipSuspendedSiblings,
              );
              return;
            }
          }
          commitRoot(
            root,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
          );
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          for (var node = finishedWork; ; ) {
            var tag = node.tag;
            if (
              (0 === tag || 11 === tag || 15 === tag) &&
              node.flags & 16384 &&
              ((tag = node.updateQueue),
              null !== tag && ((tag = tag.stores), null !== tag))
            )
              for (var i = 0; i < tag.length; i++) {
                var check = tag[i],
                  getSnapshot = check.getSnapshot;
                check = check.value;
                try {
                  if (!objectIs(getSnapshot(), check)) return !1;
                } catch (error) {
                  return !1;
                }
              }
            tag = node.child;
            if (node.subtreeFlags & 16384 && null !== tag)
              (tag.return = node), (node = tag);
            else {
              if (node === finishedWork) break;
              for (; null === node.sibling; ) {
                if (null === node.return || node.return === finishedWork)
                  return !0;
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return !0;
        }
        function markRootSuspended(
          root,
          suspendedLanes,
          spawnedLane,
          didAttemptEntireTree,
        ) {
          suspendedLanes &= ~workInProgressRootPingedLanes;
          suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
          root.suspendedLanes |= suspendedLanes;
          root.pingedLanes &= ~suspendedLanes;
          didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
          didAttemptEntireTree = root.expirationTimes;
          for (var lanes = suspendedLanes; 0 < lanes; ) {
            var index$6 = 31 - clz32(lanes),
              lane = 1 << index$6;
            didAttemptEntireTree[index$6] = -1;
            lanes &= ~lane;
          }
          0 !== spawnedLane &&
            markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
        }
        function flushSyncWork$1() {
          return 0 === (executionContext & 6)
            ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)
            : !0;
        }
        function resetWorkInProgressStack() {
          if (null !== workInProgress) {
            if (0 === workInProgressSuspendedReason)
              var interruptedWork = workInProgress.return;
            else
              (interruptedWork = workInProgress),
                (lastContextDependency = currentlyRenderingFiber$1 = null),
                resetHooksOnUnwind(interruptedWork),
                (thenableState$1 = null),
                (thenableIndexCounter$1 = 0),
                (interruptedWork = workInProgress);
            for (; null !== interruptedWork; )
              unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
                (interruptedWork = interruptedWork.return);
            workInProgress = null;
          }
        }
        function prepareFreshStack(root, lanes) {
          var timeoutHandle = root.timeoutHandle;
          -1 !== timeoutHandle &&
            ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
          timeoutHandle = root.cancelPendingCommit;
          null !== timeoutHandle &&
            ((root.cancelPendingCommit = null), timeoutHandle());
          pendingEffectsLanes = 0;
          resetWorkInProgressStack();
          workInProgressRoot = root;
          workInProgress = timeoutHandle = createWorkInProgress(
            root.current,
            null,
          );
          workInProgressRootRenderLanes = lanes;
          workInProgressSuspendedReason = 0;
          workInProgressThrownValue = null;
          workInProgressRootDidSkipSuspendedSiblings = !1;
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
            root,
            lanes,
          );
          workInProgressRootDidAttachPingListener = !1;
          workInProgressSuspendedRetryLanes =
            workInProgressDeferredLane =
            workInProgressRootPingedLanes =
            workInProgressRootInterleavedUpdatedLanes =
            workInProgressRootSkippedLanes =
            workInProgressRootExitStatus =
              0;
          workInProgressRootRecoverableErrors =
            workInProgressRootConcurrentErrors = null;
          workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
          0 !== (lanes & 8) && (lanes |= lanes & 32);
          var allEntangledLanes = root.entangledLanes;
          if (0 !== allEntangledLanes)
            for (
              root = root.entanglements, allEntangledLanes &= lanes;
              0 < allEntangledLanes;

            ) {
              var index$4 = 31 - clz32(allEntangledLanes),
                lane = 1 << index$4;
              lanes |= root[index$4];
              allEntangledLanes &= ~lane;
            }
          entangledRenderLanes = lanes;
          finishQueueingConcurrentUpdates();
          return timeoutHandle;
        }
        function handleThrow(root, thrownValue) {
          currentlyRenderingFiber = null;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          thrownValue === SuspenseException ||
          thrownValue === SuspenseActionException
            ? ((thrownValue = getSuspendedThenable()),
              (workInProgressSuspendedReason = 3))
            : thrownValue === SuspenseyCommitException
              ? ((thrownValue = getSuspendedThenable()),
                (workInProgressSuspendedReason = 4))
              : (workInProgressSuspendedReason =
                  thrownValue === SelectiveHydrationException
                    ? 8
                    : null !== thrownValue &&
                        'object' === typeof thrownValue &&
                        'function' === typeof thrownValue.then
                      ? 6
                      : 1);
          workInProgressThrownValue = thrownValue;
          null === workInProgress &&
            ((workInProgressRootExitStatus = 1),
            logUncaughtError(
              root,
              createCapturedValueAtFiber(thrownValue, root.current),
            ));
        }
        function shouldRemainOnPreviousScreen() {
          var handler = suspenseHandlerStackCursor.current;
          return null === handler
            ? !0
            : (workInProgressRootRenderLanes & 4194048) ===
                workInProgressRootRenderLanes
              ? null === shellBoundary
                ? !0
                : !1
              : (workInProgressRootRenderLanes & 62914560) ===
                    workInProgressRootRenderLanes ||
                  0 !== (workInProgressRootRenderLanes & 536870912)
                ? handler === shellBoundary
                : !1;
        }
        function pushDispatcher() {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          return null === prevDispatcher
            ? ContextOnlyDispatcher
            : prevDispatcher;
        }
        function pushAsyncDispatcher() {
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          return prevAsyncDispatcher;
        }
        function renderDidSuspendDelayIfPossible() {
          workInProgressRootExitStatus = 4;
          workInProgressRootDidSkipSuspendedSiblings ||
            ((workInProgressRootRenderLanes & 4194048) !==
              workInProgressRootRenderLanes &&
              null !== suspenseHandlerStackCursor.current) ||
            (workInProgressRootIsPrerendering = !0);
          (0 === (workInProgressRootSkippedLanes & 134217727) &&
            0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
            null === workInProgressRoot ||
            markRootSuspended(
              workInProgressRoot,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              !1,
            );
        }
        function renderRootSync(root, lanes, shouldYieldForPrerendering) {
          var prevExecutionContext = executionContext;
          executionContext |= 2;
          var prevDispatcher = pushDispatcher(),
            prevAsyncDispatcher = pushAsyncDispatcher();
          if (
            workInProgressRoot !== root ||
            workInProgressRootRenderLanes !== lanes
          )
            (workInProgressTransitions = null), prepareFreshStack(root, lanes);
          lanes = !1;
          var exitStatus = workInProgressRootExitStatus;
          a: do
            try {
              if (
                0 !== workInProgressSuspendedReason &&
                null !== workInProgress
              ) {
                var unitOfWork = workInProgress,
                  thrownValue = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                  case 8:
                    resetWorkInProgressStack();
                    exitStatus = 6;
                    break a;
                  case 3:
                  case 2:
                  case 9:
                  case 6:
                    null === suspenseHandlerStackCursor.current && (lanes = !0);
                    var reason = workInProgressSuspendedReason;
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root,
                      unitOfWork,
                      thrownValue,
                      reason,
                    );
                    if (
                      shouldYieldForPrerendering &&
                      workInProgressRootIsPrerendering
                    ) {
                      exitStatus = 0;
                      break a;
                    }
                    break;
                  default:
                    (reason = workInProgressSuspendedReason),
                      (workInProgressSuspendedReason = 0),
                      (workInProgressThrownValue = null),
                      throwAndUnwindWorkLoop(
                        root,
                        unitOfWork,
                        thrownValue,
                        reason,
                      );
                }
              }
              workLoopSync();
              exitStatus = workInProgressRootExitStatus;
              break;
            } catch (thrownValue$165) {
              handleThrow(root, thrownValue$165);
            }
          while (1);
          lanes && root.shellSuspendCounter++;
          lastContextDependency = currentlyRenderingFiber$1 = null;
          executionContext = prevExecutionContext;
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          null === workInProgress &&
            ((workInProgressRoot = null),
            (workInProgressRootRenderLanes = 0),
            finishQueueingConcurrentUpdates());
          return exitStatus;
        }
        function workLoopSync() {
          for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
        }
        function renderRootConcurrent(root, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= 2;
          var prevDispatcher = pushDispatcher(),
            prevAsyncDispatcher = pushAsyncDispatcher();
          workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
            ? ((workInProgressTransitions = null),
              (workInProgressRootRenderTargetTime = now() + 500),
              prepareFreshStack(root, lanes))
            : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
                root,
                lanes,
              ));
          a: do
            try {
              if (
                0 !== workInProgressSuspendedReason &&
                null !== workInProgress
              ) {
                lanes = workInProgress;
                var thrownValue = workInProgressThrownValue;
                b: switch (workInProgressSuspendedReason) {
                  case 1:
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
                    break;
                  case 2:
                  case 9:
                    if (isThenableResolved(thrownValue)) {
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function () {
                      (2 !== workInProgressSuspendedReason &&
                        9 !== workInProgressSuspendedReason) ||
                        workInProgressRoot !== root ||
                        (workInProgressSuspendedReason = 7);
                      ensureRootIsScheduled(root);
                    };
                    thrownValue.then(lanes, lanes);
                    break a;
                  case 3:
                    workInProgressSuspendedReason = 7;
                    break a;
                  case 4:
                    workInProgressSuspendedReason = 5;
                    break a;
                  case 7:
                    isThenableResolved(thrownValue)
                      ? ((workInProgressSuspendedReason = 0),
                        (workInProgressThrownValue = null),
                        replaySuspendedUnitOfWork(lanes))
                      : ((workInProgressSuspendedReason = 0),
                        (workInProgressThrownValue = null),
                        throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
                    break;
                  case 5:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress;
                        if (
                          resource
                            ? preloadResource(resource)
                            : hostFiber.stateNode.complete
                        ) {
                          workInProgressSuspendedReason = 0;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (null !== sibling) workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            null !== returnFiber
                              ? ((workInProgress = returnFiber),
                                completeUnitOfWork(returnFiber))
                              : (workInProgress = null);
                          }
                          break b;
                        }
                    }
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
                    break;
                  case 6:
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
                    break;
                  case 8:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = 6;
                    break a;
                  default:
                    throw Error(formatProdErrorMessage(462));
                }
              }
              workLoopConcurrentByScheduler();
              break;
            } catch (thrownValue$167) {
              handleThrow(root, thrownValue$167);
            }
          while (1);
          lastContextDependency = currentlyRenderingFiber$1 = null;
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          executionContext = prevExecutionContext;
          if (null !== workInProgress) return 0;
          workInProgressRoot = null;
          workInProgressRootRenderLanes = 0;
          finishQueueingConcurrentUpdates();
          return workInProgressRootExitStatus;
        }
        function workLoopConcurrentByScheduler() {
          for (; null !== workInProgress && !shouldYield(); )
            performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
          var next = beginWork(
            unitOfWork.alternate,
            unitOfWork,
            entangledRenderLanes,
          );
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === next
            ? completeUnitOfWork(unitOfWork)
            : (workInProgress = next);
        }
        function replaySuspendedUnitOfWork(unitOfWork) {
          var next = unitOfWork;
          var current = next.alternate;
          switch (next.tag) {
            case 15:
            case 0:
              next = replayFunctionComponent(
                current,
                next,
                next.pendingProps,
                next.type,
                void 0,
                workInProgressRootRenderLanes,
              );
              break;
            case 11:
              next = replayFunctionComponent(
                current,
                next,
                next.pendingProps,
                next.type.render,
                next.ref,
                workInProgressRootRenderLanes,
              );
              break;
            case 5:
              resetHooksOnUnwind(next);
            default:
              unwindInterruptedWork(current, next),
                (next = workInProgress =
                  resetWorkInProgress(next, entangledRenderLanes)),
                (next = beginWork(current, next, entangledRenderLanes));
          }
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === next
            ? completeUnitOfWork(unitOfWork)
            : (workInProgress = next);
        }
        function throwAndUnwindWorkLoop(
          root,
          unitOfWork,
          thrownValue,
          suspendedReason,
        ) {
          lastContextDependency = currentlyRenderingFiber$1 = null;
          resetHooksOnUnwind(unitOfWork);
          thenableState$1 = null;
          thenableIndexCounter$1 = 0;
          var returnFiber = unitOfWork.return;
          try {
            if (
              throwException(
                root,
                returnFiber,
                unitOfWork,
                thrownValue,
                workInProgressRootRenderLanes,
              )
            ) {
              workInProgressRootExitStatus = 1;
              logUncaughtError(
                root,
                createCapturedValueAtFiber(thrownValue, root.current),
              );
              workInProgress = null;
              return;
            }
          } catch (error) {
            if (null !== returnFiber)
              throw ((workInProgress = returnFiber), error);
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root,
              createCapturedValueAtFiber(thrownValue, root.current),
            );
            workInProgress = null;
            return;
          }
          if (unitOfWork.flags & 32768) {
            if (isHydrating || 1 === suspendedReason) root = !0;
            else if (
              workInProgressRootIsPrerendering ||
              0 !== (workInProgressRootRenderLanes & 536870912)
            )
              root = !1;
            else if (
              ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
              2 === suspendedReason ||
                9 === suspendedReason ||
                3 === suspendedReason ||
                6 === suspendedReason)
            )
              (suspendedReason = suspenseHandlerStackCursor.current),
                null !== suspendedReason &&
                  13 === suspendedReason.tag &&
                  (suspendedReason.flags |= 16384);
            unwindUnitOfWork(unitOfWork, root);
          } else completeUnitOfWork(unitOfWork);
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            if (0 !== (completedWork.flags & 32768)) {
              unwindUnitOfWork(
                completedWork,
                workInProgressRootDidSkipSuspendedSiblings,
              );
              return;
            }
            unitOfWork = completedWork.return;
            var next = completeWork(
              completedWork.alternate,
              completedWork,
              entangledRenderLanes,
            );
            if (null !== next) {
              workInProgress = next;
              return;
            }
            completedWork = completedWork.sibling;
            if (null !== completedWork) {
              workInProgress = completedWork;
              return;
            }
            workInProgress = completedWork = unitOfWork;
          } while (null !== completedWork);
          0 === workInProgressRootExitStatus &&
            (workInProgressRootExitStatus = 5);
        }
        function unwindUnitOfWork(unitOfWork, skipSiblings) {
          do {
            var next = unwindWork(unitOfWork.alternate, unitOfWork);
            if (null !== next) {
              next.flags &= 32767;
              workInProgress = next;
              return;
            }
            next = unitOfWork.return;
            null !== next &&
              ((next.flags |= 32768),
              (next.subtreeFlags = 0),
              (next.deletions = null));
            if (
              !skipSiblings &&
              ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
            ) {
              workInProgress = unitOfWork;
              return;
            }
            workInProgress = unitOfWork = next;
          } while (null !== unitOfWork);
          workInProgressRootExitStatus = 6;
          workInProgress = null;
        }
        function commitRoot(
          root,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
        ) {
          root.cancelPendingCommit = null;
          do flushPendingEffects();
          while (0 !== pendingEffectsStatus);
          if (0 !== (executionContext & 6))
            throw Error(formatProdErrorMessage(327));
          if (null !== finishedWork) {
            if (finishedWork === root.current)
              throw Error(formatProdErrorMessage(177));
            didIncludeRenderPhaseUpdate =
              finishedWork.lanes | finishedWork.childLanes;
            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
            markRootFinished(
              root,
              lanes,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
            );
            root === workInProgressRoot &&
              ((workInProgress = workInProgressRoot = null),
              (workInProgressRootRenderLanes = 0));
            pendingFinishedWork = finishedWork;
            pendingEffectsRoot = root;
            pendingEffectsLanes = lanes;
            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
            pendingPassiveTransitions = transitions;
            pendingRecoverableErrors = recoverableErrors;
            0 !== (finishedWork.subtreeFlags & 10256) ||
            0 !== (finishedWork.flags & 10256)
              ? ((root.callbackNode = null),
                (root.callbackPriority = 0),
                scheduleCallback$1(NormalPriority$1, function () {
                  flushPassiveEffects();
                  return null;
                }))
              : ((root.callbackNode = null), (root.callbackPriority = 0));
            recoverableErrors = 0 !== (finishedWork.flags & 13878);
            if (
              0 !== (finishedWork.subtreeFlags & 13878) ||
              recoverableErrors
            ) {
              recoverableErrors = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              transitions = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = 2;
              spawnedLane = executionContext;
              executionContext |= 4;
              try {
                commitBeforeMutationEffects(root, finishedWork, lanes);
              } finally {
                (executionContext = spawnedLane),
                  (ReactDOMSharedInternals.p = transitions),
                  (ReactSharedInternals.T = recoverableErrors);
              }
            }
            pendingEffectsStatus = 1;
            flushMutationEffects();
            flushLayoutEffects();
            flushSpawnedWork();
          }
        }
        function flushMutationEffects() {
          if (1 === pendingEffectsStatus) {
            pendingEffectsStatus = 0;
            var root = pendingEffectsRoot,
              finishedWork = pendingFinishedWork,
              rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
            if (
              0 !== (finishedWork.subtreeFlags & 13878) ||
              rootMutationHasEffect
            ) {
              rootMutationHasEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = 2;
              var prevExecutionContext = executionContext;
              executionContext |= 4;
              try {
                commitMutationEffectsOnFiber(finishedWork, root);
                var priorSelectionInformation = selectionInformation,
                  curFocusedElem = getActiveElementDeep(root.containerInfo),
                  priorFocusedElem = priorSelectionInformation.focusedElem,
                  priorSelectionRange =
                    priorSelectionInformation.selectionRange;
                if (
                  curFocusedElem !== priorFocusedElem &&
                  priorFocusedElem &&
                  priorFocusedElem.ownerDocument &&
                  containsNode(
                    priorFocusedElem.ownerDocument.documentElement,
                    priorFocusedElem,
                  )
                ) {
                  if (
                    null !== priorSelectionRange &&
                    hasSelectionCapabilities(priorFocusedElem)
                  ) {
                    var start = priorSelectionRange.start,
                      end = priorSelectionRange.end;
                    void 0 === end && (end = start);
                    if ('selectionStart' in priorFocusedElem)
                      (priorFocusedElem.selectionStart = start),
                        (priorFocusedElem.selectionEnd = Math.min(
                          end,
                          priorFocusedElem.value.length,
                        ));
                    else {
                      var doc = priorFocusedElem.ownerDocument || document,
                        win = (doc && doc.defaultView) || window;
                      if (win.getSelection) {
                        var selection = win.getSelection(),
                          length = priorFocusedElem.textContent.length,
                          start$jscomp$0 = Math.min(
                            priorSelectionRange.start,
                            length,
                          ),
                          end$jscomp$0 =
                            void 0 === priorSelectionRange.end
                              ? start$jscomp$0
                              : Math.min(priorSelectionRange.end, length);
                        !selection.extend &&
                          start$jscomp$0 > end$jscomp$0 &&
                          ((curFocusedElem = end$jscomp$0),
                          (end$jscomp$0 = start$jscomp$0),
                          (start$jscomp$0 = curFocusedElem));
                        var startMarker = getNodeForCharacterOffset(
                            priorFocusedElem,
                            start$jscomp$0,
                          ),
                          endMarker = getNodeForCharacterOffset(
                            priorFocusedElem,
                            end$jscomp$0,
                          );
                        if (
                          startMarker &&
                          endMarker &&
                          (1 !== selection.rangeCount ||
                            selection.anchorNode !== startMarker.node ||
                            selection.anchorOffset !== startMarker.offset ||
                            selection.focusNode !== endMarker.node ||
                            selection.focusOffset !== endMarker.offset)
                        ) {
                          var range = doc.createRange();
                          range.setStart(startMarker.node, startMarker.offset);
                          selection.removeAllRanges();
                          start$jscomp$0 > end$jscomp$0
                            ? (selection.addRange(range),
                              selection.extend(
                                endMarker.node,
                                endMarker.offset,
                              ))
                            : (range.setEnd(endMarker.node, endMarker.offset),
                              selection.addRange(range));
                        }
                      }
                    }
                  }
                  doc = [];
                  for (
                    selection = priorFocusedElem;
                    (selection = selection.parentNode);

                  )
                    1 === selection.nodeType &&
                      doc.push({
                        element: selection,
                        left: selection.scrollLeft,
                        top: selection.scrollTop,
                      });
                  'function' === typeof priorFocusedElem.focus &&
                    priorFocusedElem.focus();
                  for (
                    priorFocusedElem = 0;
                    priorFocusedElem < doc.length;
                    priorFocusedElem++
                  ) {
                    var info = doc[priorFocusedElem];
                    info.element.scrollLeft = info.left;
                    info.element.scrollTop = info.top;
                  }
                }
                _enabled = !!eventsEnabled;
                selectionInformation = eventsEnabled = null;
              } finally {
                (executionContext = prevExecutionContext),
                  (ReactDOMSharedInternals.p = previousPriority),
                  (ReactSharedInternals.T = rootMutationHasEffect);
              }
            }
            root.current = finishedWork;
            pendingEffectsStatus = 2;
          }
        }
        function flushLayoutEffects() {
          if (2 === pendingEffectsStatus) {
            pendingEffectsStatus = 0;
            var root = pendingEffectsRoot,
              finishedWork = pendingFinishedWork,
              rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
            if (
              0 !== (finishedWork.subtreeFlags & 8772) ||
              rootHasLayoutEffect
            ) {
              rootHasLayoutEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = 2;
              var prevExecutionContext = executionContext;
              executionContext |= 4;
              try {
                commitLayoutEffectOnFiber(
                  root,
                  finishedWork.alternate,
                  finishedWork,
                );
              } finally {
                (executionContext = prevExecutionContext),
                  (ReactDOMSharedInternals.p = previousPriority),
                  (ReactSharedInternals.T = rootHasLayoutEffect);
              }
            }
            pendingEffectsStatus = 3;
          }
        }
        function flushSpawnedWork() {
          if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
            pendingEffectsStatus = 0;
            requestPaint();
            var root = pendingEffectsRoot,
              finishedWork = pendingFinishedWork,
              lanes = pendingEffectsLanes,
              recoverableErrors = pendingRecoverableErrors;
            0 !== (finishedWork.subtreeFlags & 10256) ||
            0 !== (finishedWork.flags & 10256)
              ? (pendingEffectsStatus = 5)
              : ((pendingEffectsStatus = 0),
                (pendingFinishedWork = pendingEffectsRoot = null),
                releaseRootPooledCache(root, root.pendingLanes));
            var remainingLanes = root.pendingLanes;
            0 === remainingLanes &&
              (legacyErrorBoundariesThatAlreadyFailed = null);
            lanesToEventPriority(lanes);
            finishedWork = finishedWork.stateNode;
            if (
              injectedHook &&
              'function' === typeof injectedHook.onCommitFiberRoot
            )
              try {
                injectedHook.onCommitFiberRoot(
                  rendererID,
                  finishedWork,
                  void 0,
                  128 === (finishedWork.current.flags & 128),
                );
              } catch (err) {}
            if (null !== recoverableErrors) {
              finishedWork = ReactSharedInternals.T;
              remainingLanes = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = 2;
              ReactSharedInternals.T = null;
              try {
                for (
                  var onRecoverableError = root.onRecoverableError, i = 0;
                  i < recoverableErrors.length;
                  i++
                ) {
                  var recoverableError = recoverableErrors[i];
                  onRecoverableError(recoverableError.value, {
                    componentStack: recoverableError.stack,
                  });
                }
              } finally {
                (ReactSharedInternals.T = finishedWork),
                  (ReactDOMSharedInternals.p = remainingLanes);
              }
            }
            0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
            ensureRootIsScheduled(root);
            remainingLanes = root.pendingLanes;
            0 !== (lanes & 261930) && 0 !== (remainingLanes & 42)
              ? root === rootWithNestedUpdates
                ? nestedUpdateCount++
                : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
              : (nestedUpdateCount = 0);
            flushSyncWorkAcrossRoots_impl(0, !1);
          }
        }
        function releaseRootPooledCache(root, remainingLanes) {
          0 === (root.pooledCacheLanes &= remainingLanes) &&
            ((remainingLanes = root.pooledCache),
            null != remainingLanes &&
              ((root.pooledCache = null), releaseCache(remainingLanes)));
        }
        function flushPendingEffects() {
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
          return flushPassiveEffects();
        }
        function flushPassiveEffects() {
          if (5 !== pendingEffectsStatus) return !1;
          var root = pendingEffectsRoot,
            remainingLanes = pendingEffectsRemainingLanes;
          pendingEffectsRemainingLanes = 0;
          var renderPriority = lanesToEventPriority(pendingEffectsLanes),
            prevTransition = ReactSharedInternals.T,
            previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p =
              32 > renderPriority ? 32 : renderPriority;
            ReactSharedInternals.T = null;
            renderPriority = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root$jscomp$0 = pendingEffectsRoot,
              lanes = pendingEffectsLanes;
            pendingEffectsStatus = 0;
            pendingFinishedWork = pendingEffectsRoot = null;
            pendingEffectsLanes = 0;
            if (0 !== (executionContext & 6))
              throw Error(formatProdErrorMessage(331));
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            commitPassiveUnmountOnFiber(root$jscomp$0.current);
            commitPassiveMountOnFiber(
              root$jscomp$0,
              root$jscomp$0.current,
              lanes,
              renderPriority,
            );
            executionContext = prevExecutionContext;
            flushSyncWorkAcrossRoots_impl(0, !1);
            if (
              injectedHook &&
              'function' === typeof injectedHook.onPostCommitFiberRoot
            )
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
              } catch (err) {}
            return !0;
          } finally {
            (ReactDOMSharedInternals.p = previousPriority),
              (ReactSharedInternals.T = prevTransition),
              releaseRootPooledCache(root, remainingLanes);
          }
        }
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          sourceFiber = createRootErrorUpdate(
            rootFiber.stateNode,
            sourceFiber,
            2,
          );
          rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
          null !== rootFiber &&
            (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
        }
        function captureCommitPhaseError(
          sourceFiber,
          nearestMountedAncestor,
          error,
        ) {
          if (3 === sourceFiber.tag)
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
          else
            for (; null !== nearestMountedAncestor; ) {
              if (3 === nearestMountedAncestor.tag) {
                captureCommitPhaseErrorOnRoot(
                  nearestMountedAncestor,
                  sourceFiber,
                  error,
                );
                break;
              } else if (1 === nearestMountedAncestor.tag) {
                var instance = nearestMountedAncestor.stateNode;
                if (
                  'function' ===
                    typeof nearestMountedAncestor.type
                      .getDerivedStateFromError ||
                  ('function' === typeof instance.componentDidCatch &&
                    (null === legacyErrorBoundariesThatAlreadyFailed ||
                      !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
                ) {
                  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                  error = createClassErrorUpdate(2);
                  instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                  null !== instance &&
                    (initializeClassErrorUpdate(
                      error,
                      instance,
                      nearestMountedAncestor,
                      sourceFiber,
                    ),
                    markRootUpdated$1(instance, 2),
                    ensureRootIsScheduled(instance));
                  break;
                }
              }
              nearestMountedAncestor = nearestMountedAncestor.return;
            }
        }
        function attachPingListener(root, wakeable, lanes) {
          var pingCache = root.pingCache;
          if (null === pingCache) {
            pingCache = root.pingCache = new PossiblyWeakMap();
            var threadIDs = new Set();
            pingCache.set(wakeable, threadIDs);
          } else
            (threadIDs = pingCache.get(wakeable)),
              void 0 === threadIDs &&
                ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
          threadIDs.has(lanes) ||
            ((workInProgressRootDidAttachPingListener = !0),
            threadIDs.add(lanes),
            (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
            wakeable.then(root, root));
        }
        function pingSuspendedRoot(root, wakeable, pingedLanes) {
          var pingCache = root.pingCache;
          null !== pingCache && pingCache.delete(wakeable);
          root.pingedLanes |= root.suspendedLanes & pingedLanes;
          root.warmLanes &= ~pingedLanes;
          workInProgressRoot === root &&
            (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
            (4 === workInProgressRootExitStatus ||
            (3 === workInProgressRootExitStatus &&
              (workInProgressRootRenderLanes & 62914560) ===
                workInProgressRootRenderLanes &&
              300 > now() - globalMostRecentFallbackTime)
              ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
              : (workInProgressRootPingedLanes |= pingedLanes),
            workInProgressSuspendedRetryLanes ===
              workInProgressRootRenderLanes &&
              (workInProgressSuspendedRetryLanes = 0));
          ensureRootIsScheduled(root);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          0 === retryLane && (retryLane = claimNextRetryLane());
          boundaryFiber = enqueueConcurrentRenderForLane(
            boundaryFiber,
            retryLane,
          );
          null !== boundaryFiber &&
            (markRootUpdated$1(boundaryFiber, retryLane),
            ensureRootIsScheduled(boundaryFiber));
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState,
            retryLane = 0;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = 0;
          switch (boundaryFiber.tag) {
            case 31:
            case 13:
              var retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              null !== suspenseState && (retryLane = suspenseState.retryLane);
              break;
            case 19:
              retryCache = boundaryFiber.stateNode;
              break;
            case 22:
              retryCache = boundaryFiber.stateNode._retryCache;
              break;
            default:
              throw Error(formatProdErrorMessage(314));
          }
          null !== retryCache && retryCache.delete(wakeable);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function scheduleCallback$1(priorityLevel, callback) {
          return scheduleCallback$3(priorityLevel, callback);
        }
        var firstScheduledRoot = null,
          lastScheduledRoot = null,
          didScheduleMicrotask = !1,
          mightHavePendingSyncWork = !1,
          isFlushingWork = !1,
          currentEventTransitionLane = 0;
        function ensureRootIsScheduled(root) {
          root !== lastScheduledRoot &&
            null === root.next &&
            (null === lastScheduledRoot
              ? (firstScheduledRoot = lastScheduledRoot = root)
              : (lastScheduledRoot = lastScheduledRoot.next = root));
          mightHavePendingSyncWork = !0;
          didScheduleMicrotask ||
            ((didScheduleMicrotask = !0), scheduleImmediateRootScheduleTask());
        }
        function flushSyncWorkAcrossRoots_impl(
          syncTransitionLanes,
          onlyLegacy,
        ) {
          if (!isFlushingWork && mightHavePendingSyncWork) {
            isFlushingWork = !0;
            do {
              var didPerformSomeWork = !1;
              for (var root$170 = firstScheduledRoot; null !== root$170; ) {
                if (!onlyLegacy)
                  if (0 !== syncTransitionLanes) {
                    var pendingLanes = root$170.pendingLanes;
                    if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                    else {
                      var suspendedLanes = root$170.suspendedLanes,
                        pingedLanes = root$170.pingedLanes;
                      JSCompiler_inline_result =
                        (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
                      JSCompiler_inline_result &=
                        pendingLanes & ~(suspendedLanes & ~pingedLanes);
                      JSCompiler_inline_result =
                        JSCompiler_inline_result & 201326741
                          ? (JSCompiler_inline_result & 201326741) | 1
                          : JSCompiler_inline_result
                            ? JSCompiler_inline_result | 2
                            : 0;
                    }
                    0 !== JSCompiler_inline_result &&
                      ((didPerformSomeWork = !0),
                      performSyncWorkOnRoot(
                        root$170,
                        JSCompiler_inline_result,
                      ));
                  } else
                    (JSCompiler_inline_result = workInProgressRootRenderLanes),
                      (JSCompiler_inline_result = getNextLanes(
                        root$170,
                        root$170 === workInProgressRoot
                          ? JSCompiler_inline_result
                          : 0,
                        null !== root$170.cancelPendingCommit ||
                          -1 !== root$170.timeoutHandle,
                      )),
                      0 === (JSCompiler_inline_result & 3) ||
                        checkIfRootIsPrerendering(
                          root$170,
                          JSCompiler_inline_result,
                        ) ||
                        ((didPerformSomeWork = !0),
                        performSyncWorkOnRoot(
                          root$170,
                          JSCompiler_inline_result,
                        ));
                root$170 = root$170.next;
              }
            } while (didPerformSomeWork);
            isFlushingWork = !1;
          }
        }
        function processRootScheduleInImmediateTask() {
          processRootScheduleInMicrotask();
        }
        function processRootScheduleInMicrotask() {
          mightHavePendingSyncWork = didScheduleMicrotask = !1;
          var syncTransitionLanes = 0;
          0 !== currentEventTransitionLane &&
            shouldAttemptEagerTransition() &&
            (syncTransitionLanes = currentEventTransitionLane);
          for (
            var currentTime = now(), prev = null, root = firstScheduledRoot;
            null !== root;

          ) {
            var next = root.next,
              nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
            if (0 === nextLanes)
              (root.next = null),
                null === prev
                  ? (firstScheduledRoot = next)
                  : (prev.next = next),
                null === next && (lastScheduledRoot = prev);
            else if (
              ((prev = root),
              0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            )
              mightHavePendingSyncWork = !0;
            root = next;
          }
          (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus) ||
            flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
          0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
        }
        function scheduleTaskForRootDuringMicrotask(root, currentTime) {
          for (
            var suspendedLanes = root.suspendedLanes,
              pingedLanes = root.pingedLanes,
              expirationTimes = root.expirationTimes,
              lanes = root.pendingLanes & -62914561;
            0 < lanes;

          ) {
            var index$5 = 31 - clz32(lanes),
              lane = 1 << index$5,
              expirationTime = expirationTimes[index$5];
            if (-1 === expirationTime) {
              if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                expirationTimes[index$5] = computeExpirationTime(
                  lane,
                  currentTime,
                );
            } else expirationTime <= currentTime && (root.expiredLanes |= lane);
            lanes &= ~lane;
          }
          currentTime = workInProgressRoot;
          suspendedLanes = workInProgressRootRenderLanes;
          suspendedLanes = getNextLanes(
            root,
            root === currentTime ? suspendedLanes : 0,
            null !== root.cancelPendingCommit || -1 !== root.timeoutHandle,
          );
          pingedLanes = root.callbackNode;
          if (
            0 === suspendedLanes ||
            (root === currentTime &&
              (2 === workInProgressSuspendedReason ||
                9 === workInProgressSuspendedReason)) ||
            null !== root.cancelPendingCommit
          )
            return (
              null !== pingedLanes &&
                null !== pingedLanes &&
                cancelCallback$1(pingedLanes),
              (root.callbackNode = null),
              (root.callbackPriority = 0)
            );
          if (
            0 === (suspendedLanes & 3) ||
            checkIfRootIsPrerendering(root, suspendedLanes)
          ) {
            currentTime = suspendedLanes & -suspendedLanes;
            if (currentTime === root.callbackPriority) return currentTime;
            null !== pingedLanes && cancelCallback$1(pingedLanes);
            switch (lanesToEventPriority(suspendedLanes)) {
              case 2:
              case 8:
                suspendedLanes = UserBlockingPriority;
                break;
              case 32:
                suspendedLanes = NormalPriority$1;
                break;
              case 268435456:
                suspendedLanes = IdlePriority;
                break;
              default:
                suspendedLanes = NormalPriority$1;
            }
            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
            suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
            root.callbackPriority = currentTime;
            root.callbackNode = suspendedLanes;
            return currentTime;
          }
          null !== pingedLanes &&
            null !== pingedLanes &&
            cancelCallback$1(pingedLanes);
          root.callbackPriority = 2;
          root.callbackNode = null;
          return 2;
        }
        function performWorkOnRootViaSchedulerTask(root, didTimeout) {
          if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
            return (
              (root.callbackNode = null), (root.callbackPriority = 0), null
            );
          var originalCallbackNode = root.callbackNode;
          if (
            flushPendingEffects() &&
            root.callbackNode !== originalCallbackNode
          )
            return null;
          var workInProgressRootRenderLanes$jscomp$0 =
            workInProgressRootRenderLanes;
          workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
            root,
            root === workInProgressRoot
              ? workInProgressRootRenderLanes$jscomp$0
              : 0,
            null !== root.cancelPendingCommit || -1 !== root.timeoutHandle,
          );
          if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
          performWorkOnRoot(
            root,
            workInProgressRootRenderLanes$jscomp$0,
            didTimeout,
          );
          scheduleTaskForRootDuringMicrotask(root, now());
          return null != root.callbackNode &&
            root.callbackNode === originalCallbackNode
            ? performWorkOnRootViaSchedulerTask.bind(null, root)
            : null;
        }
        function performSyncWorkOnRoot(root, lanes) {
          if (flushPendingEffects()) return null;
          performWorkOnRoot(root, lanes, !0);
        }
        function scheduleImmediateRootScheduleTask() {
          scheduleMicrotask(function () {
            0 !== (executionContext & 6)
              ? scheduleCallback$3(
                  ImmediatePriority,
                  processRootScheduleInImmediateTask,
                )
              : processRootScheduleInMicrotask();
          });
        }
        function requestTransitionLane() {
          if (0 === currentEventTransitionLane) {
            var actionScopeLane = currentEntangledLane;
            0 === actionScopeLane &&
              ((actionScopeLane = nextTransitionUpdateLane),
              (nextTransitionUpdateLane <<= 1),
              0 === (nextTransitionUpdateLane & 261888) &&
                (nextTransitionUpdateLane = 256));
            currentEventTransitionLane = actionScopeLane;
          }
          return currentEventTransitionLane;
        }
        function coerceFormActionProp(actionProp) {
          return null == actionProp ||
            'symbol' === typeof actionProp ||
            'boolean' === typeof actionProp
            ? null
            : 'function' === typeof actionProp
              ? actionProp
              : sanitizeURL('' + actionProp);
        }
        function createFormDataWithSubmitter(form, submitter) {
          var temp = submitter.ownerDocument.createElement('input');
          temp.name = submitter.name;
          temp.value = submitter.value;
          form.id && temp.setAttribute('form', form.id);
          submitter.parentNode.insertBefore(temp, submitter);
          form = new FormData(form);
          temp.parentNode.removeChild(temp);
          return form;
        }
        function extractEvents$1(
          dispatchQueue,
          domEventName,
          maybeTargetInst,
          nativeEvent,
          nativeEventTarget,
        ) {
          if (
            'submit' === domEventName &&
            maybeTargetInst &&
            maybeTargetInst.stateNode === nativeEventTarget
          ) {
            var action = coerceFormActionProp(
                (nativeEventTarget[internalPropsKey] || null).action,
              ),
              submitter = nativeEvent.submitter;
            submitter &&
              ((domEventName = (domEventName =
                submitter[internalPropsKey] || null)
                ? coerceFormActionProp(domEventName.formAction)
                : submitter.getAttribute('formAction')),
              null !== domEventName &&
                ((action = domEventName), (submitter = null)));
            var event = new SyntheticEvent(
              'action',
              'action',
              null,
              nativeEvent,
              nativeEventTarget,
            );
            dispatchQueue.push({
              event: event,
              listeners: [
                {
                  instance: null,
                  listener: function () {
                    if (nativeEvent.defaultPrevented) {
                      if (0 !== currentEventTransitionLane) {
                        var formData = submitter
                          ? createFormDataWithSubmitter(
                              nativeEventTarget,
                              submitter,
                            )
                          : new FormData(nativeEventTarget);
                        startHostTransition(
                          maybeTargetInst,
                          {
                            pending: !0,
                            data: formData,
                            method: nativeEventTarget.method,
                            action: action,
                          },
                          null,
                          formData,
                        );
                      }
                    } else
                      'function' === typeof action &&
                        (event.preventDefault(),
                        (formData = submitter
                          ? createFormDataWithSubmitter(
                              nativeEventTarget,
                              submitter,
                            )
                          : new FormData(nativeEventTarget)),
                        startHostTransition(
                          maybeTargetInst,
                          {
                            pending: !0,
                            data: formData,
                            method: nativeEventTarget.method,
                            action: action,
                          },
                          action,
                          formData,
                        ));
                  },
                  currentTarget: nativeEventTarget,
                },
              ],
            });
          }
        }
        for (
          var i$jscomp$inline_1577 = 0;
          i$jscomp$inline_1577 < simpleEventPluginEvents.length;
          i$jscomp$inline_1577++
        ) {
          var eventName$jscomp$inline_1578 =
              simpleEventPluginEvents[i$jscomp$inline_1577],
            domEventName$jscomp$inline_1579 =
              eventName$jscomp$inline_1578.toLowerCase(),
            capitalizedEvent$jscomp$inline_1580 =
              eventName$jscomp$inline_1578[0].toUpperCase() +
              eventName$jscomp$inline_1578.slice(1);
          registerSimpleEvent(
            domEventName$jscomp$inline_1579,
            'on' + capitalizedEvent$jscomp$inline_1580,
          );
        }
        registerSimpleEvent(ANIMATION_END, 'onAnimationEnd');
        registerSimpleEvent(ANIMATION_ITERATION, 'onAnimationIteration');
        registerSimpleEvent(ANIMATION_START, 'onAnimationStart');
        registerSimpleEvent('dblclick', 'onDoubleClick');
        registerSimpleEvent('focusin', 'onFocus');
        registerSimpleEvent('focusout', 'onBlur');
        registerSimpleEvent(TRANSITION_RUN, 'onTransitionRun');
        registerSimpleEvent(TRANSITION_START, 'onTransitionStart');
        registerSimpleEvent(TRANSITION_CANCEL, 'onTransitionCancel');
        registerSimpleEvent(TRANSITION_END, 'onTransitionEnd');
        registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover']);
        registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover']);
        registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover']);
        registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover']);
        registerTwoPhaseEvent(
          'onChange',
          'change click focusin focusout input keydown keyup selectionchange'.split(
            ' ',
          ),
        );
        registerTwoPhaseEvent(
          'onSelect',
          'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(
            ' ',
          ),
        );
        registerTwoPhaseEvent('onBeforeInput', [
          'compositionend',
          'keypress',
          'textInput',
          'paste',
        ]);
        registerTwoPhaseEvent(
          'onCompositionEnd',
          'compositionend focusout keydown keypress keyup mousedown'.split(' '),
        );
        registerTwoPhaseEvent(
          'onCompositionStart',
          'compositionstart focusout keydown keypress keyup mousedown'.split(
            ' ',
          ),
        );
        registerTwoPhaseEvent(
          'onCompositionUpdate',
          'compositionupdate focusout keydown keypress keyup mousedown'.split(
            ' ',
          ),
        );
        var mediaEventTypes =
            'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
              ' ',
            ),
          nonDelegatedEvents = new Set(
            'beforetoggle cancel close invalid load scroll scrollend toggle'
              .split(' ')
              .concat(mediaEventTypes),
          );
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          eventSystemFlags = 0 !== (eventSystemFlags & 4);
          for (var i = 0; i < dispatchQueue.length; i++) {
            var _dispatchQueue$i = dispatchQueue[i],
              event = _dispatchQueue$i.event;
            _dispatchQueue$i = _dispatchQueue$i.listeners;
            a: {
              var previousInstance = void 0;
              if (eventSystemFlags)
                for (
                  var i$jscomp$0 = _dispatchQueue$i.length - 1;
                  0 <= i$jscomp$0;
                  i$jscomp$0--
                ) {
                  var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
                    instance = _dispatchListeners$i.instance,
                    currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (
                    instance !== previousInstance &&
                    event.isPropagationStopped()
                  )
                    break a;
                  previousInstance = _dispatchListeners$i;
                  event.currentTarget = currentTarget;
                  try {
                    previousInstance(event);
                  } catch (error) {
                    reportGlobalError(error);
                  }
                  event.currentTarget = null;
                  previousInstance = instance;
                }
              else
                for (
                  i$jscomp$0 = 0;
                  i$jscomp$0 < _dispatchQueue$i.length;
                  i$jscomp$0++
                ) {
                  _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                  instance = _dispatchListeners$i.instance;
                  currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (
                    instance !== previousInstance &&
                    event.isPropagationStopped()
                  )
                    break a;
                  previousInstance = _dispatchListeners$i;
                  event.currentTarget = currentTarget;
                  try {
                    previousInstance(event);
                  } catch (error) {
                    reportGlobalError(error);
                  }
                  event.currentTarget = null;
                  previousInstance = instance;
                }
            }
          }
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          var JSCompiler_inline_result =
            targetElement[internalEventHandlersKey];
          void 0 === JSCompiler_inline_result &&
            (JSCompiler_inline_result = targetElement[
              internalEventHandlersKey
            ] =
              new Set());
          var listenerSetKey = domEventName + '__bubble';
          JSCompiler_inline_result.has(listenerSetKey) ||
            (addTrappedEventListener(targetElement, domEventName, 2, !1),
            JSCompiler_inline_result.add(listenerSetKey));
        }
        function listenToNativeEvent(
          domEventName,
          isCapturePhaseListener,
          target,
        ) {
          var eventSystemFlags = 0;
          isCapturePhaseListener && (eventSystemFlags |= 4);
          addTrappedEventListener(
            target,
            domEventName,
            eventSystemFlags,
            isCapturePhaseListener,
          );
        }
        var listeningMarker =
          '_reactListening' + Math.random().toString(36).slice(2);
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = !0;
            allNativeEvents.forEach(function (domEventName) {
              'selectionchange' !== domEventName &&
                (nonDelegatedEvents.has(domEventName) ||
                  listenToNativeEvent(domEventName, !1, rootContainerElement),
                listenToNativeEvent(domEventName, !0, rootContainerElement));
            });
            var ownerDocument =
              9 === rootContainerElement.nodeType
                ? rootContainerElement
                : rootContainerElement.ownerDocument;
            null === ownerDocument ||
              ownerDocument[listeningMarker] ||
              ((ownerDocument[listeningMarker] = !0),
              listenToNativeEvent('selectionchange', !1, ownerDocument));
          }
        }
        function addTrappedEventListener(
          targetContainer,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener,
        ) {
          switch (getEventPriority(domEventName)) {
            case 2:
              var listenerWrapper = dispatchDiscreteEvent;
              break;
            case 8:
              listenerWrapper = dispatchContinuousEvent;
              break;
            default:
              listenerWrapper = dispatchEvent;
          }
          eventSystemFlags = listenerWrapper.bind(
            null,
            domEventName,
            eventSystemFlags,
            targetContainer,
          );
          listenerWrapper = void 0;
          !passiveBrowserEventsSupported ||
            ('touchstart' !== domEventName &&
              'touchmove' !== domEventName &&
              'wheel' !== domEventName) ||
            (listenerWrapper = !0);
          isCapturePhaseListener
            ? void 0 !== listenerWrapper
              ? targetContainer.addEventListener(
                  domEventName,
                  eventSystemFlags,
                  {
                    capture: !0,
                    passive: listenerWrapper,
                  },
                )
              : targetContainer.addEventListener(
                  domEventName,
                  eventSystemFlags,
                  !0,
                )
            : void 0 !== listenerWrapper
              ? targetContainer.addEventListener(
                  domEventName,
                  eventSystemFlags,
                  {
                    passive: listenerWrapper,
                  },
                )
              : targetContainer.addEventListener(
                  domEventName,
                  eventSystemFlags,
                  !1,
                );
        }
        function dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetInst$jscomp$0,
          targetContainer,
        ) {
          var ancestorInst = targetInst$jscomp$0;
          if (
            0 === (eventSystemFlags & 1) &&
            0 === (eventSystemFlags & 2) &&
            null !== targetInst$jscomp$0
          )
            a: for (;;) {
              if (null === targetInst$jscomp$0) return;
              var nodeTag = targetInst$jscomp$0.tag;
              if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer) break;
                if (4 === nodeTag)
                  for (
                    nodeTag = targetInst$jscomp$0.return;
                    null !== nodeTag;

                  ) {
                    var grandTag = nodeTag.tag;
                    if (
                      (3 === grandTag || 4 === grandTag) &&
                      nodeTag.stateNode.containerInfo === targetContainer
                    )
                      return;
                    nodeTag = nodeTag.return;
                  }
                for (; null !== container; ) {
                  nodeTag = getClosestInstanceFromNode(container);
                  if (null === nodeTag) return;
                  grandTag = nodeTag.tag;
                  if (
                    5 === grandTag ||
                    6 === grandTag ||
                    26 === grandTag ||
                    27 === grandTag
                  ) {
                    targetInst$jscomp$0 = ancestorInst = nodeTag;
                    continue a;
                  }
                  container = container.parentNode;
                }
              }
              targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
          batchedUpdates$1(function () {
            var targetInst = ancestorInst,
              nativeEventTarget = getEventTarget(nativeEvent),
              dispatchQueue = [];
            a: {
              var reactName = topLevelEventsToReactNames.get(domEventName);
              if (void 0 !== reactName) {
                var SyntheticEventCtor = SyntheticEvent,
                  reactEventType = domEventName;
                switch (domEventName) {
                  case 'keypress':
                    if (0 === getEventCharCode(nativeEvent)) break a;
                  case 'keydown':
                  case 'keyup':
                    SyntheticEventCtor = SyntheticKeyboardEvent;
                    break;
                  case 'focusin':
                    reactEventType = 'focus';
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case 'focusout':
                    reactEventType = 'blur';
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case 'beforeblur':
                  case 'afterblur':
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case 'click':
                    if (2 === nativeEvent.button) break a;
                  case 'auxclick':
                  case 'dblclick':
                  case 'mousedown':
                  case 'mousemove':
                  case 'mouseup':
                  case 'mouseout':
                  case 'mouseover':
                  case 'contextmenu':
                    SyntheticEventCtor = SyntheticMouseEvent;
                    break;
                  case 'drag':
                  case 'dragend':
                  case 'dragenter':
                  case 'dragexit':
                  case 'dragleave':
                  case 'dragover':
                  case 'dragstart':
                  case 'drop':
                    SyntheticEventCtor = SyntheticDragEvent;
                    break;
                  case 'touchcancel':
                  case 'touchend':
                  case 'touchmove':
                  case 'touchstart':
                    SyntheticEventCtor = SyntheticTouchEvent;
                    break;
                  case ANIMATION_END:
                  case ANIMATION_ITERATION:
                  case ANIMATION_START:
                    SyntheticEventCtor = SyntheticAnimationEvent;
                    break;
                  case TRANSITION_END:
                    SyntheticEventCtor = SyntheticTransitionEvent;
                    break;
                  case 'scroll':
                  case 'scrollend':
                    SyntheticEventCtor = SyntheticUIEvent;
                    break;
                  case 'wheel':
                    SyntheticEventCtor = SyntheticWheelEvent;
                    break;
                  case 'copy':
                  case 'cut':
                  case 'paste':
                    SyntheticEventCtor = SyntheticClipboardEvent;
                    break;
                  case 'gotpointercapture':
                  case 'lostpointercapture':
                  case 'pointercancel':
                  case 'pointerdown':
                  case 'pointermove':
                  case 'pointerout':
                  case 'pointerover':
                  case 'pointerup':
                    SyntheticEventCtor = SyntheticPointerEvent;
                    break;
                  case 'toggle':
                  case 'beforetoggle':
                    SyntheticEventCtor = SyntheticToggleEvent;
                }
                var inCapturePhase = 0 !== (eventSystemFlags & 4),
                  accumulateTargetOnly =
                    !inCapturePhase &&
                    ('scroll' === domEventName || 'scrollend' === domEventName),
                  reactEventName = inCapturePhase
                    ? null !== reactName
                      ? reactName + 'Capture'
                      : null
                    : reactName;
                inCapturePhase = [];
                for (
                  var instance = targetInst, lastHostComponent;
                  null !== instance;

                ) {
                  var _instance = instance;
                  lastHostComponent = _instance.stateNode;
                  _instance = _instance.tag;
                  (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
                    null === lastHostComponent ||
                    null === reactEventName ||
                    ((_instance = getListener(instance, reactEventName)),
                    null != _instance &&
                      inCapturePhase.push(
                        createDispatchListener(
                          instance,
                          _instance,
                          lastHostComponent,
                        ),
                      ));
                  if (accumulateTargetOnly) break;
                  instance = instance.return;
                }
                0 < inCapturePhase.length &&
                  ((reactName = new SyntheticEventCtor(
                    reactName,
                    reactEventType,
                    null,
                    nativeEvent,
                    nativeEventTarget,
                  )),
                  dispatchQueue.push({
                    event: reactName,
                    listeners: inCapturePhase,
                  }));
              }
            }
            if (0 === (eventSystemFlags & 7)) {
              a: {
                reactName =
                  'mouseover' === domEventName ||
                  'pointerover' === domEventName;
                SyntheticEventCtor =
                  'mouseout' === domEventName || 'pointerout' === domEventName;
                if (
                  reactName &&
                  nativeEvent !== currentReplayingEvent &&
                  (reactEventType =
                    nativeEvent.relatedTarget || nativeEvent.fromElement) &&
                  (getClosestInstanceFromNode(reactEventType) ||
                    reactEventType[internalContainerInstanceKey])
                )
                  break a;
                if (SyntheticEventCtor || reactName) {
                  reactName =
                    nativeEventTarget.window === nativeEventTarget
                      ? nativeEventTarget
                      : (reactName = nativeEventTarget.ownerDocument)
                        ? reactName.defaultView || reactName.parentWindow
                        : window;
                  if (SyntheticEventCtor) {
                    if (
                      ((reactEventType =
                        nativeEvent.relatedTarget || nativeEvent.toElement),
                      (SyntheticEventCtor = targetInst),
                      (reactEventType = reactEventType
                        ? getClosestInstanceFromNode(reactEventType)
                        : null),
                      null !== reactEventType &&
                        ((accumulateTargetOnly =
                          getNearestMountedFiber(reactEventType)),
                        (inCapturePhase = reactEventType.tag),
                        reactEventType !== accumulateTargetOnly ||
                          (5 !== inCapturePhase &&
                            27 !== inCapturePhase &&
                            6 !== inCapturePhase)))
                    )
                      reactEventType = null;
                  } else
                    (SyntheticEventCtor = null), (reactEventType = targetInst);
                  if (SyntheticEventCtor !== reactEventType) {
                    inCapturePhase = SyntheticMouseEvent;
                    _instance = 'onMouseLeave';
                    reactEventName = 'onMouseEnter';
                    instance = 'mouse';
                    if (
                      'pointerout' === domEventName ||
                      'pointerover' === domEventName
                    )
                      (inCapturePhase = SyntheticPointerEvent),
                        (_instance = 'onPointerLeave'),
                        (reactEventName = 'onPointerEnter'),
                        (instance = 'pointer');
                    accumulateTargetOnly =
                      null == SyntheticEventCtor
                        ? reactName
                        : getNodeFromInstance(SyntheticEventCtor);
                    lastHostComponent =
                      null == reactEventType
                        ? reactName
                        : getNodeFromInstance(reactEventType);
                    reactName = new inCapturePhase(
                      _instance,
                      instance + 'leave',
                      SyntheticEventCtor,
                      nativeEvent,
                      nativeEventTarget,
                    );
                    reactName.target = accumulateTargetOnly;
                    reactName.relatedTarget = lastHostComponent;
                    _instance = null;
                    getClosestInstanceFromNode(nativeEventTarget) ===
                      targetInst &&
                      ((inCapturePhase = new inCapturePhase(
                        reactEventName,
                        instance + 'enter',
                        reactEventType,
                        nativeEvent,
                        nativeEventTarget,
                      )),
                      (inCapturePhase.target = lastHostComponent),
                      (inCapturePhase.relatedTarget = accumulateTargetOnly),
                      (_instance = inCapturePhase));
                    accumulateTargetOnly = _instance;
                    if (SyntheticEventCtor && reactEventType)
                      b: {
                        inCapturePhase = getParent;
                        reactEventName = SyntheticEventCtor;
                        instance = reactEventType;
                        lastHostComponent = 0;
                        for (
                          _instance = reactEventName;
                          _instance;
                          _instance = inCapturePhase(_instance)
                        )
                          lastHostComponent++;
                        _instance = 0;
                        for (
                          var tempB = instance;
                          tempB;
                          tempB = inCapturePhase(tempB)
                        )
                          _instance++;
                        for (; 0 < lastHostComponent - _instance; )
                          (reactEventName = inCapturePhase(reactEventName)),
                            lastHostComponent--;
                        for (; 0 < _instance - lastHostComponent; )
                          (instance = inCapturePhase(instance)), _instance--;
                        for (; lastHostComponent--; ) {
                          if (
                            reactEventName === instance ||
                            (null !== instance &&
                              reactEventName === instance.alternate)
                          ) {
                            inCapturePhase = reactEventName;
                            break b;
                          }
                          reactEventName = inCapturePhase(reactEventName);
                          instance = inCapturePhase(instance);
                        }
                        inCapturePhase = null;
                      }
                    else inCapturePhase = null;
                    null !== SyntheticEventCtor &&
                      accumulateEnterLeaveListenersForEvent(
                        dispatchQueue,
                        reactName,
                        SyntheticEventCtor,
                        inCapturePhase,
                        !1,
                      );
                    null !== reactEventType &&
                      null !== accumulateTargetOnly &&
                      accumulateEnterLeaveListenersForEvent(
                        dispatchQueue,
                        accumulateTargetOnly,
                        reactEventType,
                        inCapturePhase,
                        !0,
                      );
                  }
                }
              }
              a: {
                reactName = targetInst
                  ? getNodeFromInstance(targetInst)
                  : window;
                SyntheticEventCtor =
                  reactName.nodeName && reactName.nodeName.toLowerCase();
                if (
                  'select' === SyntheticEventCtor ||
                  ('input' === SyntheticEventCtor && 'file' === reactName.type)
                )
                  var getTargetInstFunc = getTargetInstForChangeEvent;
                else if (isTextInputElement(reactName))
                  if (isInputEventSupported)
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                  else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    var handleEventFunc = handleEventsForInputEventPolyfill;
                  }
                else
                  (SyntheticEventCtor = reactName.nodeName),
                    !SyntheticEventCtor ||
                    'input' !== SyntheticEventCtor.toLowerCase() ||
                    ('checkbox' !== reactName.type &&
                      'radio' !== reactName.type)
                      ? targetInst &&
                        isCustomElement(targetInst.elementType) &&
                        (getTargetInstFunc = getTargetInstForChangeEvent)
                      : (getTargetInstFunc = getTargetInstForClickEvent);
                if (
                  getTargetInstFunc &&
                  (getTargetInstFunc = getTargetInstFunc(
                    domEventName,
                    targetInst,
                  ))
                ) {
                  createAndAccumulateChangeEvent(
                    dispatchQueue,
                    getTargetInstFunc,
                    nativeEvent,
                    nativeEventTarget,
                  );
                  break a;
                }
                handleEventFunc &&
                  handleEventFunc(domEventName, reactName, targetInst);
                'focusout' === domEventName &&
                  targetInst &&
                  'number' === reactName.type &&
                  null != targetInst.memoizedProps.value &&
                  setDefaultValue(reactName, 'number', reactName.value);
              }
              handleEventFunc = targetInst
                ? getNodeFromInstance(targetInst)
                : window;
              switch (domEventName) {
                case 'focusin':
                  if (
                    isTextInputElement(handleEventFunc) ||
                    'true' === handleEventFunc.contentEditable
                  )
                    (activeElement = handleEventFunc),
                      (activeElementInst = targetInst),
                      (lastSelection = null);
                  break;
                case 'focusout':
                  lastSelection = activeElementInst = activeElement = null;
                  break;
                case 'mousedown':
                  mouseDown = !0;
                  break;
                case 'contextmenu':
                case 'mouseup':
                case 'dragend':
                  mouseDown = !1;
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget,
                  );
                  break;
                case 'selectionchange':
                  if (skipSelectionChangeEvent) break;
                case 'keydown':
                case 'keyup':
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget,
                  );
              }
              var fallbackData;
              if (canUseCompositionEvent)
                b: {
                  switch (domEventName) {
                    case 'compositionstart':
                      var eventType = 'onCompositionStart';
                      break b;
                    case 'compositionend':
                      eventType = 'onCompositionEnd';
                      break b;
                    case 'compositionupdate':
                      eventType = 'onCompositionUpdate';
                      break b;
                  }
                  eventType = void 0;
                }
              else
                isComposing
                  ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
                    (eventType = 'onCompositionEnd')
                  : 'keydown' === domEventName &&
                    229 === nativeEvent.keyCode &&
                    (eventType = 'onCompositionStart');
              eventType &&
                (useFallbackCompositionData &&
                  'ko' !== nativeEvent.locale &&
                  (isComposing || 'onCompositionStart' !== eventType
                    ? 'onCompositionEnd' === eventType &&
                      isComposing &&
                      (fallbackData = getData())
                    : ((root = nativeEventTarget),
                      (startText =
                        'value' in root ? root.value : root.textContent),
                      (isComposing = !0))),
                (handleEventFunc = accumulateTwoPhaseListeners(
                  targetInst,
                  eventType,
                )),
                0 < handleEventFunc.length &&
                  ((eventType = new SyntheticCompositionEvent(
                    eventType,
                    domEventName,
                    null,
                    nativeEvent,
                    nativeEventTarget,
                  )),
                  dispatchQueue.push({
                    event: eventType,
                    listeners: handleEventFunc,
                  }),
                  fallbackData
                    ? (eventType.data = fallbackData)
                    : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
                      null !== fallbackData &&
                        (eventType.data = fallbackData))));
              if (
                (fallbackData = canUseTextInputEvent
                  ? getNativeBeforeInputChars(domEventName, nativeEvent)
                  : getFallbackBeforeInputChars(domEventName, nativeEvent))
              )
                (eventType = accumulateTwoPhaseListeners(
                  targetInst,
                  'onBeforeInput',
                )),
                  0 < eventType.length &&
                    ((handleEventFunc = new SyntheticCompositionEvent(
                      'onBeforeInput',
                      'beforeinput',
                      null,
                      nativeEvent,
                      nativeEventTarget,
                    )),
                    dispatchQueue.push({
                      event: handleEventFunc,
                      listeners: eventType,
                    }),
                    (handleEventFunc.data = fallbackData));
              extractEvents$1(
                dispatchQueue,
                domEventName,
                targetInst,
                nativeEvent,
                nativeEventTarget,
              );
            }
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance: instance,
            listener: listener,
            currentTarget: currentTarget,
          };
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          for (
            var captureName = reactName + 'Capture', listeners = [];
            null !== targetFiber;

          ) {
            var _instance2 = targetFiber,
              stateNode = _instance2.stateNode;
            _instance2 = _instance2.tag;
            (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
              null === stateNode ||
              ((_instance2 = getListener(targetFiber, captureName)),
              null != _instance2 &&
                listeners.unshift(
                  createDispatchListener(targetFiber, _instance2, stateNode),
                ),
              (_instance2 = getListener(targetFiber, reactName)),
              null != _instance2 &&
                listeners.push(
                  createDispatchListener(targetFiber, _instance2, stateNode),
                ));
            if (3 === targetFiber.tag) return listeners;
            targetFiber = targetFiber.return;
          }
          return [];
        }
        function getParent(inst) {
          if (null === inst) return null;
          do inst = inst.return;
          while (inst && 5 !== inst.tag && 27 !== inst.tag);
          return inst ? inst : null;
        }
        function accumulateEnterLeaveListenersForEvent(
          dispatchQueue,
          event,
          target,
          common,
          inCapturePhase,
        ) {
          for (
            var registrationName = event._reactName, listeners = [];
            null !== target && target !== common;

          ) {
            var _instance3 = target,
              alternate = _instance3.alternate,
              stateNode = _instance3.stateNode;
            _instance3 = _instance3.tag;
            if (null !== alternate && alternate === common) break;
            (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
              null === stateNode ||
              ((alternate = stateNode),
              inCapturePhase
                ? ((stateNode = getListener(target, registrationName)),
                  null != stateNode &&
                    listeners.unshift(
                      createDispatchListener(target, stateNode, alternate),
                    ))
                : inCapturePhase ||
                  ((stateNode = getListener(target, registrationName)),
                  null != stateNode &&
                    listeners.push(
                      createDispatchListener(target, stateNode, alternate),
                    )));
            target = target.return;
          }
          0 !== listeners.length &&
            dispatchQueue.push({ event: event, listeners: listeners });
        }
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
          NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        function normalizeMarkupForTextOrAttribute(markup) {
          return ('string' === typeof markup ? markup : '' + markup)
            .replace(NORMALIZE_NEWLINES_REGEX, '\n')
            .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
        }
        function checkForUnmatchedText(serverText, clientText) {
          clientText = normalizeMarkupForTextOrAttribute(clientText);
          return normalizeMarkupForTextOrAttribute(serverText) === clientText
            ? !0
            : !1;
        }
        function setProp(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case 'children':
              'string' === typeof value
                ? 'body' === tag ||
                  ('textarea' === tag && '' === value) ||
                  setTextContent(domElement, value)
                : ('number' === typeof value || 'bigint' === typeof value) &&
                  'body' !== tag &&
                  setTextContent(domElement, '' + value);
              break;
            case 'className':
              setValueForKnownAttribute(domElement, 'class', value);
              break;
            case 'tabIndex':
              setValueForKnownAttribute(domElement, 'tabindex', value);
              break;
            case 'dir':
            case 'role':
            case 'viewBox':
            case 'width':
            case 'height':
              setValueForKnownAttribute(domElement, key, value);
              break;
            case 'style':
              setValueForStyles(domElement, value, prevValue);
              break;
            case 'data':
              if ('object' !== tag) {
                setValueForKnownAttribute(domElement, 'data', value);
                break;
              }
            case 'src':
            case 'href':
              if ('' === value && ('a' !== tag || 'href' !== key)) {
                domElement.removeAttribute(key);
                break;
              }
              if (
                null == value ||
                'function' === typeof value ||
                'symbol' === typeof value ||
                'boolean' === typeof value
              ) {
                domElement.removeAttribute(key);
                break;
              }
              value = sanitizeURL('' + value);
              domElement.setAttribute(key, value);
              break;
            case 'action':
            case 'formAction':
              if ('function' === typeof value) {
                domElement.setAttribute(
                  key,
                  "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')",
                );
                break;
              } else
                'function' === typeof prevValue &&
                  ('formAction' === key
                    ? ('input' !== tag &&
                        setProp(
                          domElement,
                          tag,
                          'name',
                          props.name,
                          props,
                          null,
                        ),
                      setProp(
                        domElement,
                        tag,
                        'formEncType',
                        props.formEncType,
                        props,
                        null,
                      ),
                      setProp(
                        domElement,
                        tag,
                        'formMethod',
                        props.formMethod,
                        props,
                        null,
                      ),
                      setProp(
                        domElement,
                        tag,
                        'formTarget',
                        props.formTarget,
                        props,
                        null,
                      ))
                    : (setProp(
                        domElement,
                        tag,
                        'encType',
                        props.encType,
                        props,
                        null,
                      ),
                      setProp(
                        domElement,
                        tag,
                        'method',
                        props.method,
                        props,
                        null,
                      ),
                      setProp(
                        domElement,
                        tag,
                        'target',
                        props.target,
                        props,
                        null,
                      )));
              if (
                null == value ||
                'symbol' === typeof value ||
                'boolean' === typeof value
              ) {
                domElement.removeAttribute(key);
                break;
              }
              value = sanitizeURL('' + value);
              domElement.setAttribute(key, value);
              break;
            case 'onClick':
              null != value && (domElement.onclick = noop$1);
              break;
            case 'onScroll':
              null != value && listenToNonDelegatedEvent('scroll', domElement);
              break;
            case 'onScrollEnd':
              null != value &&
                listenToNonDelegatedEvent('scrollend', domElement);
              break;
            case 'dangerouslySetInnerHTML':
              if (null != value) {
                if ('object' !== typeof value || !('__html' in value))
                  throw Error(formatProdErrorMessage(61));
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(formatProdErrorMessage(60));
                  domElement.innerHTML = key;
                }
              }
              break;
            case 'multiple':
              domElement.multiple =
                value &&
                'function' !== typeof value &&
                'symbol' !== typeof value;
              break;
            case 'muted':
              domElement.muted =
                value &&
                'function' !== typeof value &&
                'symbol' !== typeof value;
              break;
            case 'suppressContentEditableWarning':
            case 'suppressHydrationWarning':
            case 'defaultValue':
            case 'defaultChecked':
            case 'innerHTML':
            case 'ref':
              break;
            case 'autoFocus':
              break;
            case 'xlinkHref':
              if (
                null == value ||
                'function' === typeof value ||
                'boolean' === typeof value ||
                'symbol' === typeof value
              ) {
                domElement.removeAttribute('xlink:href');
                break;
              }
              key = sanitizeURL('' + value);
              domElement.setAttributeNS(
                'http://www.w3.org/1999/xlink',
                'xlink:href',
                key,
              );
              break;
            case 'contentEditable':
            case 'spellCheck':
            case 'draggable':
            case 'value':
            case 'autoReverse':
            case 'externalResourcesRequired':
            case 'focusable':
            case 'preserveAlpha':
              null != value &&
              'function' !== typeof value &&
              'symbol' !== typeof value
                ? domElement.setAttribute(key, '' + value)
                : domElement.removeAttribute(key);
              break;
            case 'inert':
            case 'allowFullScreen':
            case 'async':
            case 'autoPlay':
            case 'controls':
            case 'default':
            case 'defer':
            case 'disabled':
            case 'disablePictureInPicture':
            case 'disableRemotePlayback':
            case 'formNoValidate':
            case 'hidden':
            case 'loop':
            case 'noModule':
            case 'noValidate':
            case 'open':
            case 'playsInline':
            case 'readOnly':
            case 'required':
            case 'reversed':
            case 'scoped':
            case 'seamless':
            case 'itemScope':
              value && 'function' !== typeof value && 'symbol' !== typeof value
                ? domElement.setAttribute(key, '')
                : domElement.removeAttribute(key);
              break;
            case 'capture':
            case 'download':
              !0 === value
                ? domElement.setAttribute(key, '')
                : !1 !== value &&
                    null != value &&
                    'function' !== typeof value &&
                    'symbol' !== typeof value
                  ? domElement.setAttribute(key, value)
                  : domElement.removeAttribute(key);
              break;
            case 'cols':
            case 'rows':
            case 'size':
            case 'span':
              null != value &&
              'function' !== typeof value &&
              'symbol' !== typeof value &&
              !isNaN(value) &&
              1 <= value
                ? domElement.setAttribute(key, value)
                : domElement.removeAttribute(key);
              break;
            case 'rowSpan':
            case 'start':
              null == value ||
              'function' === typeof value ||
              'symbol' === typeof value ||
              isNaN(value)
                ? domElement.removeAttribute(key)
                : domElement.setAttribute(key, value);
              break;
            case 'popover':
              listenToNonDelegatedEvent('beforetoggle', domElement);
              listenToNonDelegatedEvent('toggle', domElement);
              setValueForAttribute(domElement, 'popover', value);
              break;
            case 'xlinkActuate':
              setValueForNamespacedAttribute(
                domElement,
                'http://www.w3.org/1999/xlink',
                'xlink:actuate',
                value,
              );
              break;
            case 'xlinkArcrole':
              setValueForNamespacedAttribute(
                domElement,
                'http://www.w3.org/1999/xlink',
                'xlink:arcrole',
                value,
              );
              break;
            case 'xlinkRole':
              setValueForNamespacedAttribute(
                domElement,
                'http://www.w3.org/1999/xlink',
                'xlink:role',
                value,
              );
              break;
            case 'xlinkShow':
              setValueForNamespacedAttribute(
                domElement,
                'http://www.w3.org/1999/xlink',
                'xlink:show',
                value,
              );
              break;
            case 'xlinkTitle':
              setValueForNamespacedAttribute(
                domElement,
                'http://www.w3.org/1999/xlink',
                'xlink:title',
                value,
              );
              break;
            case 'xlinkType':
              setValueForNamespacedAttribute(
                domElement,
                'http://www.w3.org/1999/xlink',
                'xlink:type',
                value,
              );
              break;
            case 'xmlBase':
              setValueForNamespacedAttribute(
                domElement,
                'http://www.w3.org/XML/1998/namespace',
                'xml:base',
                value,
              );
              break;
            case 'xmlLang':
              setValueForNamespacedAttribute(
                domElement,
                'http://www.w3.org/XML/1998/namespace',
                'xml:lang',
                value,
              );
              break;
            case 'xmlSpace':
              setValueForNamespacedAttribute(
                domElement,
                'http://www.w3.org/XML/1998/namespace',
                'xml:space',
                value,
              );
              break;
            case 'is':
              setValueForAttribute(domElement, 'is', value);
              break;
            case 'innerText':
            case 'textContent':
              break;
            default:
              if (
                !(2 < key.length) ||
                ('o' !== key[0] && 'O' !== key[0]) ||
                ('n' !== key[1] && 'N' !== key[1])
              )
                (key = aliases.get(key) || key),
                  setValueForAttribute(domElement, key, value);
          }
        }
        function setPropOnCustomElement(
          domElement,
          tag,
          key,
          value,
          props,
          prevValue,
        ) {
          switch (key) {
            case 'style':
              setValueForStyles(domElement, value, prevValue);
              break;
            case 'dangerouslySetInnerHTML':
              if (null != value) {
                if ('object' !== typeof value || !('__html' in value))
                  throw Error(formatProdErrorMessage(61));
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(formatProdErrorMessage(60));
                  domElement.innerHTML = key;
                }
              }
              break;
            case 'children':
              'string' === typeof value
                ? setTextContent(domElement, value)
                : ('number' === typeof value || 'bigint' === typeof value) &&
                  setTextContent(domElement, '' + value);
              break;
            case 'onScroll':
              null != value && listenToNonDelegatedEvent('scroll', domElement);
              break;
            case 'onScrollEnd':
              null != value &&
                listenToNonDelegatedEvent('scrollend', domElement);
              break;
            case 'onClick':
              null != value && (domElement.onclick = noop$1);
              break;
            case 'suppressContentEditableWarning':
            case 'suppressHydrationWarning':
            case 'innerHTML':
            case 'ref':
              break;
            case 'innerText':
            case 'textContent':
              break;
            default:
              if (!registrationNameDependencies.hasOwnProperty(key))
                a: {
                  if (
                    'o' === key[0] &&
                    'n' === key[1] &&
                    ((props = key.endsWith('Capture')),
                    (tag = key.slice(2, props ? key.length - 7 : void 0)),
                    (prevValue = domElement[internalPropsKey] || null),
                    (prevValue = null != prevValue ? prevValue[key] : null),
                    'function' === typeof prevValue &&
                      domElement.removeEventListener(tag, prevValue, props),
                    'function' === typeof value)
                  ) {
                    'function' !== typeof prevValue &&
                      null !== prevValue &&
                      (key in domElement
                        ? (domElement[key] = null)
                        : domElement.hasAttribute(key) &&
                          domElement.removeAttribute(key));
                    domElement.addEventListener(tag, value, props);
                    break a;
                  }
                  key in domElement
                    ? (domElement[key] = value)
                    : !0 === value
                      ? domElement.setAttribute(key, '')
                      : setValueForAttribute(domElement, key, value);
                }
          }
        }
        function setInitialProperties(domElement, tag, props) {
          switch (tag) {
            case 'div':
            case 'span':
            case 'svg':
            case 'path':
            case 'a':
            case 'g':
            case 'p':
            case 'li':
              break;
            case 'img':
              listenToNonDelegatedEvent('error', domElement);
              listenToNonDelegatedEvent('load', domElement);
              var hasSrc = !1,
                hasSrcSet = !1,
                propKey;
              for (propKey in props)
                if (props.hasOwnProperty(propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case 'src':
                        hasSrc = !0;
                        break;
                      case 'srcSet':
                        hasSrcSet = !0;
                        break;
                      case 'children':
                      case 'dangerouslySetInnerHTML':
                        throw Error(formatProdErrorMessage(137, tag));
                      default:
                        setProp(
                          domElement,
                          tag,
                          propKey,
                          propValue,
                          props,
                          null,
                        );
                    }
                }
              hasSrcSet &&
                setProp(domElement, tag, 'srcSet', props.srcSet, props, null);
              hasSrc && setProp(domElement, tag, 'src', props.src, props, null);
              return;
            case 'input':
              listenToNonDelegatedEvent('invalid', domElement);
              var defaultValue = (propKey = propValue = hasSrcSet = null),
                checked = null,
                defaultChecked = null;
              for (hasSrc in props)
                if (props.hasOwnProperty(hasSrc)) {
                  var propValue$184 = props[hasSrc];
                  if (null != propValue$184)
                    switch (hasSrc) {
                      case 'name':
                        hasSrcSet = propValue$184;
                        break;
                      case 'type':
                        propValue = propValue$184;
                        break;
                      case 'checked':
                        checked = propValue$184;
                        break;
                      case 'defaultChecked':
                        defaultChecked = propValue$184;
                        break;
                      case 'value':
                        propKey = propValue$184;
                        break;
                      case 'defaultValue':
                        defaultValue = propValue$184;
                        break;
                      case 'children':
                      case 'dangerouslySetInnerHTML':
                        if (null != propValue$184)
                          throw Error(formatProdErrorMessage(137, tag));
                        break;
                      default:
                        setProp(
                          domElement,
                          tag,
                          hasSrc,
                          propValue$184,
                          props,
                          null,
                        );
                    }
                }
              initInput(
                domElement,
                propKey,
                defaultValue,
                checked,
                defaultChecked,
                propValue,
                hasSrcSet,
                !1,
              );
              return;
            case 'select':
              listenToNonDelegatedEvent('invalid', domElement);
              hasSrc = propValue = propKey = null;
              for (hasSrcSet in props)
                if (
                  props.hasOwnProperty(hasSrcSet) &&
                  ((defaultValue = props[hasSrcSet]), null != defaultValue)
                )
                  switch (hasSrcSet) {
                    case 'value':
                      propKey = defaultValue;
                      break;
                    case 'defaultValue':
                      propValue = defaultValue;
                      break;
                    case 'multiple':
                      hasSrc = defaultValue;
                    default:
                      setProp(
                        domElement,
                        tag,
                        hasSrcSet,
                        defaultValue,
                        props,
                        null,
                      );
                  }
              tag = propKey;
              props = propValue;
              domElement.multiple = !!hasSrc;
              null != tag
                ? updateOptions(domElement, !!hasSrc, tag, !1)
                : null != props &&
                  updateOptions(domElement, !!hasSrc, props, !0);
              return;
            case 'textarea':
              listenToNonDelegatedEvent('invalid', domElement);
              propKey = hasSrcSet = hasSrc = null;
              for (propValue in props)
                if (
                  props.hasOwnProperty(propValue) &&
                  ((defaultValue = props[propValue]), null != defaultValue)
                )
                  switch (propValue) {
                    case 'value':
                      hasSrc = defaultValue;
                      break;
                    case 'defaultValue':
                      hasSrcSet = defaultValue;
                      break;
                    case 'children':
                      propKey = defaultValue;
                      break;
                    case 'dangerouslySetInnerHTML':
                      if (null != defaultValue)
                        throw Error(formatProdErrorMessage(91));
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        propValue,
                        defaultValue,
                        props,
                        null,
                      );
                  }
              initTextarea(domElement, hasSrc, hasSrcSet, propKey);
              return;
            case 'option':
              for (checked in props)
                if (
                  props.hasOwnProperty(checked) &&
                  ((hasSrc = props[checked]), null != hasSrc)
                )
                  switch (checked) {
                    case 'selected':
                      domElement.selected =
                        hasSrc &&
                        'function' !== typeof hasSrc &&
                        'symbol' !== typeof hasSrc;
                      break;
                    default:
                      setProp(domElement, tag, checked, hasSrc, props, null);
                  }
              return;
            case 'dialog':
              listenToNonDelegatedEvent('beforetoggle', domElement);
              listenToNonDelegatedEvent('toggle', domElement);
              listenToNonDelegatedEvent('cancel', domElement);
              listenToNonDelegatedEvent('close', domElement);
              break;
            case 'iframe':
            case 'object':
              listenToNonDelegatedEvent('load', domElement);
              break;
            case 'video':
            case 'audio':
              for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
              break;
            case 'image':
              listenToNonDelegatedEvent('error', domElement);
              listenToNonDelegatedEvent('load', domElement);
              break;
            case 'details':
              listenToNonDelegatedEvent('toggle', domElement);
              break;
            case 'embed':
            case 'source':
            case 'link':
              listenToNonDelegatedEvent('error', domElement),
                listenToNonDelegatedEvent('load', domElement);
            case 'area':
            case 'base':
            case 'br':
            case 'col':
            case 'hr':
            case 'keygen':
            case 'meta':
            case 'param':
            case 'track':
            case 'wbr':
            case 'menuitem':
              for (defaultChecked in props)
                if (
                  props.hasOwnProperty(defaultChecked) &&
                  ((hasSrc = props[defaultChecked]), null != hasSrc)
                )
                  switch (defaultChecked) {
                    case 'children':
                    case 'dangerouslySetInnerHTML':
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(
                        domElement,
                        tag,
                        defaultChecked,
                        hasSrc,
                        props,
                        null,
                      );
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (propValue$184 in props)
                  props.hasOwnProperty(propValue$184) &&
                    ((hasSrc = props[propValue$184]),
                    void 0 !== hasSrc &&
                      setPropOnCustomElement(
                        domElement,
                        tag,
                        propValue$184,
                        hasSrc,
                        props,
                        void 0,
                      ));
                return;
              }
          }
          for (defaultValue in props)
            props.hasOwnProperty(defaultValue) &&
              ((hasSrc = props[defaultValue]),
              null != hasSrc &&
                setProp(domElement, tag, defaultValue, hasSrc, props, null));
        }
        function updateProperties(domElement, tag, lastProps, nextProps) {
          switch (tag) {
            case 'div':
            case 'span':
            case 'svg':
            case 'path':
            case 'a':
            case 'g':
            case 'p':
            case 'li':
              break;
            case 'input':
              var name = null,
                type = null,
                value = null,
                defaultValue = null,
                lastDefaultValue = null,
                checked = null,
                defaultChecked = null;
              for (propKey in lastProps) {
                var lastProp = lastProps[propKey];
                if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                  switch (propKey) {
                    case 'checked':
                      break;
                    case 'value':
                      break;
                    case 'defaultValue':
                      lastDefaultValue = lastProp;
                    default:
                      nextProps.hasOwnProperty(propKey) ||
                        setProp(
                          domElement,
                          tag,
                          propKey,
                          null,
                          nextProps,
                          lastProp,
                        );
                  }
              }
              for (var propKey$201 in nextProps) {
                var propKey = nextProps[propKey$201];
                lastProp = lastProps[propKey$201];
                if (
                  nextProps.hasOwnProperty(propKey$201) &&
                  (null != propKey || null != lastProp)
                )
                  switch (propKey$201) {
                    case 'type':
                      type = propKey;
                      break;
                    case 'name':
                      name = propKey;
                      break;
                    case 'checked':
                      checked = propKey;
                      break;
                    case 'defaultChecked':
                      defaultChecked = propKey;
                      break;
                    case 'value':
                      value = propKey;
                      break;
                    case 'defaultValue':
                      defaultValue = propKey;
                      break;
                    case 'children':
                    case 'dangerouslySetInnerHTML':
                      if (null != propKey)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      propKey !== lastProp &&
                        setProp(
                          domElement,
                          tag,
                          propKey$201,
                          propKey,
                          nextProps,
                          lastProp,
                        );
                  }
              }
              updateInput(
                domElement,
                value,
                defaultValue,
                lastDefaultValue,
                checked,
                defaultChecked,
                type,
                name,
              );
              return;
            case 'select':
              propKey = value = defaultValue = propKey$201 = null;
              for (type in lastProps)
                if (
                  ((lastDefaultValue = lastProps[type]),
                  lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                )
                  switch (type) {
                    case 'value':
                      break;
                    case 'multiple':
                      propKey = lastDefaultValue;
                    default:
                      nextProps.hasOwnProperty(type) ||
                        setProp(
                          domElement,
                          tag,
                          type,
                          null,
                          nextProps,
                          lastDefaultValue,
                        );
                  }
              for (name in nextProps)
                if (
                  ((type = nextProps[name]),
                  (lastDefaultValue = lastProps[name]),
                  nextProps.hasOwnProperty(name) &&
                    (null != type || null != lastDefaultValue))
                )
                  switch (name) {
                    case 'value':
                      propKey$201 = type;
                      break;
                    case 'defaultValue':
                      defaultValue = type;
                      break;
                    case 'multiple':
                      value = type;
                    default:
                      type !== lastDefaultValue &&
                        setProp(
                          domElement,
                          tag,
                          name,
                          type,
                          nextProps,
                          lastDefaultValue,
                        );
                  }
              tag = defaultValue;
              lastProps = value;
              nextProps = propKey;
              null != propKey$201
                ? updateOptions(domElement, !!lastProps, propKey$201, !1)
                : !!nextProps !== !!lastProps &&
                  (null != tag
                    ? updateOptions(domElement, !!lastProps, tag, !0)
                    : updateOptions(
                        domElement,
                        !!lastProps,
                        lastProps ? [] : '',
                        !1,
                      ));
              return;
            case 'textarea':
              propKey = propKey$201 = null;
              for (defaultValue in lastProps)
                if (
                  ((name = lastProps[defaultValue]),
                  lastProps.hasOwnProperty(defaultValue) &&
                    null != name &&
                    !nextProps.hasOwnProperty(defaultValue))
                )
                  switch (defaultValue) {
                    case 'value':
                      break;
                    case 'children':
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        defaultValue,
                        null,
                        nextProps,
                        name,
                      );
                  }
              for (value in nextProps)
                if (
                  ((name = nextProps[value]),
                  (type = lastProps[value]),
                  nextProps.hasOwnProperty(value) &&
                    (null != name || null != type))
                )
                  switch (value) {
                    case 'value':
                      propKey$201 = name;
                      break;
                    case 'defaultValue':
                      propKey = name;
                      break;
                    case 'children':
                      break;
                    case 'dangerouslySetInnerHTML':
                      if (null != name) throw Error(formatProdErrorMessage(91));
                      break;
                    default:
                      name !== type &&
                        setProp(domElement, tag, value, name, nextProps, type);
                  }
              updateTextarea(domElement, propKey$201, propKey);
              return;
            case 'option':
              for (var propKey$217 in lastProps)
                if (
                  ((propKey$201 = lastProps[propKey$217]),
                  lastProps.hasOwnProperty(propKey$217) &&
                    null != propKey$201 &&
                    !nextProps.hasOwnProperty(propKey$217))
                )
                  switch (propKey$217) {
                    case 'selected':
                      domElement.selected = !1;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        propKey$217,
                        null,
                        nextProps,
                        propKey$201,
                      );
                  }
              for (lastDefaultValue in nextProps)
                if (
                  ((propKey$201 = nextProps[lastDefaultValue]),
                  (propKey = lastProps[lastDefaultValue]),
                  nextProps.hasOwnProperty(lastDefaultValue) &&
                    propKey$201 !== propKey &&
                    (null != propKey$201 || null != propKey))
                )
                  switch (lastDefaultValue) {
                    case 'selected':
                      domElement.selected =
                        propKey$201 &&
                        'function' !== typeof propKey$201 &&
                        'symbol' !== typeof propKey$201;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        lastDefaultValue,
                        propKey$201,
                        nextProps,
                        propKey,
                      );
                  }
              return;
            case 'img':
            case 'link':
            case 'area':
            case 'base':
            case 'br':
            case 'col':
            case 'embed':
            case 'hr':
            case 'keygen':
            case 'meta':
            case 'param':
            case 'source':
            case 'track':
            case 'wbr':
            case 'menuitem':
              for (var propKey$222 in lastProps)
                (propKey$201 = lastProps[propKey$222]),
                  lastProps.hasOwnProperty(propKey$222) &&
                    null != propKey$201 &&
                    !nextProps.hasOwnProperty(propKey$222) &&
                    setProp(
                      domElement,
                      tag,
                      propKey$222,
                      null,
                      nextProps,
                      propKey$201,
                    );
              for (checked in nextProps)
                if (
                  ((propKey$201 = nextProps[checked]),
                  (propKey = lastProps[checked]),
                  nextProps.hasOwnProperty(checked) &&
                    propKey$201 !== propKey &&
                    (null != propKey$201 || null != propKey))
                )
                  switch (checked) {
                    case 'children':
                    case 'dangerouslySetInnerHTML':
                      if (null != propKey$201)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        checked,
                        propKey$201,
                        nextProps,
                        propKey,
                      );
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (var propKey$227 in lastProps)
                  (propKey$201 = lastProps[propKey$227]),
                    lastProps.hasOwnProperty(propKey$227) &&
                      void 0 !== propKey$201 &&
                      !nextProps.hasOwnProperty(propKey$227) &&
                      setPropOnCustomElement(
                        domElement,
                        tag,
                        propKey$227,
                        void 0,
                        nextProps,
                        propKey$201,
                      );
                for (defaultChecked in nextProps)
                  (propKey$201 = nextProps[defaultChecked]),
                    (propKey = lastProps[defaultChecked]),
                    !nextProps.hasOwnProperty(defaultChecked) ||
                      propKey$201 === propKey ||
                      (void 0 === propKey$201 && void 0 === propKey) ||
                      setPropOnCustomElement(
                        domElement,
                        tag,
                        defaultChecked,
                        propKey$201,
                        nextProps,
                        propKey,
                      );
                return;
              }
          }
          for (var propKey$232 in lastProps)
            (propKey$201 = lastProps[propKey$232]),
              lastProps.hasOwnProperty(propKey$232) &&
                null != propKey$201 &&
                !nextProps.hasOwnProperty(propKey$232) &&
                setProp(
                  domElement,
                  tag,
                  propKey$232,
                  null,
                  nextProps,
                  propKey$201,
                );
          for (lastProp in nextProps)
            (propKey$201 = nextProps[lastProp]),
              (propKey = lastProps[lastProp]),
              !nextProps.hasOwnProperty(lastProp) ||
                propKey$201 === propKey ||
                (null == propKey$201 && null == propKey) ||
                setProp(
                  domElement,
                  tag,
                  lastProp,
                  propKey$201,
                  nextProps,
                  propKey,
                );
        }
        function isLikelyStaticResource(initiatorType) {
          switch (initiatorType) {
            case 'css':
            case 'script':
            case 'font':
            case 'img':
            case 'image':
            case 'input':
            case 'link':
              return !0;
            default:
              return !1;
          }
        }
        function estimateBandwidth() {
          if ('function' === typeof performance.getEntriesByType) {
            for (
              var count = 0,
                bits = 0,
                resourceEntries = performance.getEntriesByType('resource'),
                i = 0;
              i < resourceEntries.length;
              i++
            ) {
              var entry = resourceEntries[i],
                transferSize = entry.transferSize,
                initiatorType = entry.initiatorType,
                duration = entry.duration;
              if (
                transferSize &&
                duration &&
                isLikelyStaticResource(initiatorType)
              ) {
                initiatorType = 0;
                duration = entry.responseEnd;
                for (i += 1; i < resourceEntries.length; i++) {
                  var overlapEntry = resourceEntries[i],
                    overlapStartTime = overlapEntry.startTime;
                  if (overlapStartTime > duration) break;
                  var overlapTransferSize = overlapEntry.transferSize,
                    overlapInitiatorType = overlapEntry.initiatorType;
                  overlapTransferSize &&
                    isLikelyStaticResource(overlapInitiatorType) &&
                    ((overlapEntry = overlapEntry.responseEnd),
                    (initiatorType +=
                      overlapTransferSize *
                      (overlapEntry < duration
                        ? 1
                        : (duration - overlapStartTime) /
                          (overlapEntry - overlapStartTime))));
                }
                --i;
                bits +=
                  (8 * (transferSize + initiatorType)) / (entry.duration / 1e3);
                count++;
                if (10 < count) break;
              }
            }
            if (0 < count) return bits / count / 1e6;
          }
          return navigator.connection &&
            ((count = navigator.connection.downlink), 'number' === typeof count)
            ? count
            : 5;
        }
        var eventsEnabled = null,
          selectionInformation = null;
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return 9 === rootContainerElement.nodeType
            ? rootContainerElement
            : rootContainerElement.ownerDocument;
        }
        function getOwnHostContext(namespaceURI) {
          switch (namespaceURI) {
            case 'http://www.w3.org/2000/svg':
              return 1;
            case 'http://www.w3.org/1998/Math/MathML':
              return 2;
            default:
              return 0;
          }
        }
        function getChildHostContextProd(parentNamespace, type) {
          if (0 === parentNamespace)
            switch (type) {
              case 'svg':
                return 1;
              case 'math':
                return 2;
              default:
                return 0;
            }
          return 1 === parentNamespace && 'foreignObject' === type
            ? 0
            : parentNamespace;
        }
        function shouldSetTextContent(type, props) {
          return (
            'textarea' === type ||
            'noscript' === type ||
            'string' === typeof props.children ||
            'number' === typeof props.children ||
            'bigint' === typeof props.children ||
            ('object' === typeof props.dangerouslySetInnerHTML &&
              null !== props.dangerouslySetInnerHTML &&
              null != props.dangerouslySetInnerHTML.__html)
          );
        }
        var currentPopstateTransitionEvent = null;
        function shouldAttemptEagerTransition() {
          var event = window.event;
          if (event && 'popstate' === event.type) {
            if (event === currentPopstateTransitionEvent) return !1;
            currentPopstateTransitionEvent = event;
            return !0;
          }
          currentPopstateTransitionEvent = null;
          return !1;
        }
        var scheduleTimeout =
            'function' === typeof setTimeout ? setTimeout : void 0,
          cancelTimeout =
            'function' === typeof clearTimeout ? clearTimeout : void 0,
          localPromise = 'function' === typeof Promise ? Promise : void 0,
          scheduleMicrotask =
            'function' === typeof queueMicrotask
              ? queueMicrotask
              : 'undefined' !== typeof localPromise
                ? function (callback) {
                    return localPromise
                      .resolve(null)
                      .then(callback)
                      .catch(handleErrorInNextTick);
                  }
                : scheduleTimeout;
        function handleErrorInNextTick(error) {
          setTimeout(function () {
            throw error;
          });
        }
        function isSingletonScope(type) {
          return 'head' === type;
        }
        function clearHydrationBoundary(parentInstance, hydrationInstance) {
          var node = hydrationInstance,
            depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && 8 === nextNode.nodeType)
              if (((node = nextNode.data), '/$' === node || '/&' === node)) {
                if (0 === depth) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(hydrationInstance);
                  return;
                }
                depth--;
              } else if (
                '$' === node ||
                '$?' === node ||
                '$~' === node ||
                '$!' === node ||
                '&' === node
              )
                depth++;
              else if ('html' === node)
                releaseSingletonInstance(
                  parentInstance.ownerDocument.documentElement,
                );
              else if ('head' === node) {
                node = parentInstance.ownerDocument.head;
                releaseSingletonInstance(node);
                for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                  var nextNode$jscomp$0 = node$jscomp$0.nextSibling,
                    nodeName = node$jscomp$0.nodeName;
                  node$jscomp$0[internalHoistableMarker] ||
                    'SCRIPT' === nodeName ||
                    'STYLE' === nodeName ||
                    ('LINK' === nodeName &&
                      'stylesheet' === node$jscomp$0.rel.toLowerCase()) ||
                    node.removeChild(node$jscomp$0);
                  node$jscomp$0 = nextNode$jscomp$0;
                }
              } else
                'body' === node &&
                  releaseSingletonInstance(parentInstance.ownerDocument.body);
            node = nextNode;
          } while (node);
          retryIfBlockedOn(hydrationInstance);
        }
        function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
          var node = suspenseInstance;
          suspenseInstance = 0;
          do {
            var nextNode = node.nextSibling;
            1 === node.nodeType
              ? isHidden
                ? ((node._stashedDisplay = node.style.display),
                  (node.style.display = 'none'))
                : ((node.style.display = node._stashedDisplay || ''),
                  '' === node.getAttribute('style') &&
                    node.removeAttribute('style'))
              : 3 === node.nodeType &&
                (isHidden
                  ? ((node._stashedText = node.nodeValue),
                    (node.nodeValue = ''))
                  : (node.nodeValue = node._stashedText || ''));
            if (nextNode && 8 === nextNode.nodeType)
              if (((node = nextNode.data), '/$' === node))
                if (0 === suspenseInstance) break;
                else suspenseInstance--;
              else
                ('$' !== node &&
                  '$?' !== node &&
                  '$~' !== node &&
                  '$!' !== node) ||
                  suspenseInstance++;
            node = nextNode;
          } while (node);
        }
        function clearContainerSparingly(container) {
          var nextNode = container.firstChild;
          nextNode &&
            10 === nextNode.nodeType &&
            (nextNode = nextNode.nextSibling);
          for (; nextNode; ) {
            var node = nextNode;
            nextNode = nextNode.nextSibling;
            switch (node.nodeName) {
              case 'HTML':
              case 'HEAD':
              case 'BODY':
                clearContainerSparingly(node);
                detachDeletedInstance(node);
                continue;
              case 'SCRIPT':
              case 'STYLE':
                continue;
              case 'LINK':
                if ('stylesheet' === node.rel.toLowerCase()) continue;
            }
            container.removeChild(node);
          }
        }
        function canHydrateInstance(instance, type, props, inRootOrSingleton) {
          for (; 1 === instance.nodeType; ) {
            var anyProps = props;
            if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
              if (
                !inRootOrSingleton &&
                ('INPUT' !== instance.nodeName || 'hidden' !== instance.type)
              )
                break;
            } else if (!inRootOrSingleton)
              if ('input' === type && 'hidden' === instance.type) {
                var name = null == anyProps.name ? null : '' + anyProps.name;
                if (
                  'hidden' === anyProps.type &&
                  instance.getAttribute('name') === name
                )
                  return instance;
              } else return instance;
            else if (!instance[internalHoistableMarker])
              switch (type) {
                case 'meta':
                  if (!instance.hasAttribute('itemprop')) break;
                  return instance;
                case 'link':
                  name = instance.getAttribute('rel');
                  if (
                    'stylesheet' === name &&
                    instance.hasAttribute('data-precedence')
                  )
                    break;
                  else if (
                    name !== anyProps.rel ||
                    instance.getAttribute('href') !==
                      (null == anyProps.href || '' === anyProps.href
                        ? null
                        : anyProps.href) ||
                    instance.getAttribute('crossorigin') !==
                      (null == anyProps.crossOrigin
                        ? null
                        : anyProps.crossOrigin) ||
                    instance.getAttribute('title') !==
                      (null == anyProps.title ? null : anyProps.title)
                  )
                    break;
                  return instance;
                case 'style':
                  if (instance.hasAttribute('data-precedence')) break;
                  return instance;
                case 'script':
                  name = instance.getAttribute('src');
                  if (
                    (name !== (null == anyProps.src ? null : anyProps.src) ||
                      instance.getAttribute('type') !==
                        (null == anyProps.type ? null : anyProps.type) ||
                      instance.getAttribute('crossorigin') !==
                        (null == anyProps.crossOrigin
                          ? null
                          : anyProps.crossOrigin)) &&
                    name &&
                    instance.hasAttribute('async') &&
                    !instance.hasAttribute('itemprop')
                  )
                    break;
                  return instance;
                default:
                  return instance;
              }
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) break;
          }
          return null;
        }
        function canHydrateTextInstance(instance, text, inRootOrSingleton) {
          if ('' === text) return null;
          for (; 3 !== instance.nodeType; ) {
            if (
              (1 !== instance.nodeType ||
                'INPUT' !== instance.nodeName ||
                'hidden' !== instance.type) &&
              !inRootOrSingleton
            )
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
          for (; 8 !== instance.nodeType; ) {
            if (
              (1 !== instance.nodeType ||
                'INPUT' !== instance.nodeName ||
                'hidden' !== instance.type) &&
              !inRootOrSingleton
            )
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return '$?' === instance.data || '$~' === instance.data;
        }
        function isSuspenseInstanceFallback(instance) {
          return (
            '$!' === instance.data ||
            ('$?' === instance.data &&
              'loading' !== instance.ownerDocument.readyState)
          );
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          var ownerDocument = instance.ownerDocument;
          if ('$~' === instance.data) instance._reactRetry = callback;
          else if (
            '$?' !== instance.data ||
            'loading' !== ownerDocument.readyState
          )
            callback();
          else {
            var listener = function () {
              callback();
              ownerDocument.removeEventListener('DOMContentLoaded', listener);
            };
            ownerDocument.addEventListener('DOMContentLoaded', listener);
            instance._reactRetry = listener;
          }
        }
        function getNextHydratable(node) {
          for (; null != node; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
            if (8 === nodeType) {
              nodeType = node.data;
              if (
                '$' === nodeType ||
                '$!' === nodeType ||
                '$?' === nodeType ||
                '$~' === nodeType ||
                '&' === nodeType ||
                'F!' === nodeType ||
                'F' === nodeType
              )
                break;
              if ('/$' === nodeType || '/&' === nodeType) return null;
            }
          }
          return node;
        }
        var previousHydratableOnEnteringScopedSingleton = null;
        function getNextHydratableInstanceAfterHydrationBoundary(
          hydrationInstance,
        ) {
          hydrationInstance = hydrationInstance.nextSibling;
          for (var depth = 0; hydrationInstance; ) {
            if (8 === hydrationInstance.nodeType) {
              var data = hydrationInstance.data;
              if ('/$' === data || '/&' === data) {
                if (0 === depth)
                  return getNextHydratable(hydrationInstance.nextSibling);
                depth--;
              } else
                ('$' !== data &&
                  '$!' !== data &&
                  '$?' !== data &&
                  '$~' !== data &&
                  '&' !== data) ||
                  depth++;
            }
            hydrationInstance = hydrationInstance.nextSibling;
          }
          return null;
        }
        function getParentHydrationBoundary(targetInstance) {
          targetInstance = targetInstance.previousSibling;
          for (var depth = 0; targetInstance; ) {
            if (8 === targetInstance.nodeType) {
              var data = targetInstance.data;
              if (
                '$' === data ||
                '$!' === data ||
                '$?' === data ||
                '$~' === data ||
                '&' === data
              ) {
                if (0 === depth) return targetInstance;
                depth--;
              } else ('/$' !== data && '/&' !== data) || depth++;
            }
            targetInstance = targetInstance.previousSibling;
          }
          return null;
        }
        function resolveSingletonInstance(type, props, rootContainerInstance) {
          props = getOwnerDocumentFromRootContainer(rootContainerInstance);
          switch (type) {
            case 'html':
              type = props.documentElement;
              if (!type) throw Error(formatProdErrorMessage(452));
              return type;
            case 'head':
              type = props.head;
              if (!type) throw Error(formatProdErrorMessage(453));
              return type;
            case 'body':
              type = props.body;
              if (!type) throw Error(formatProdErrorMessage(454));
              return type;
            default:
              throw Error(formatProdErrorMessage(451));
          }
        }
        function releaseSingletonInstance(instance) {
          for (var attributes = instance.attributes; attributes.length; )
            instance.removeAttributeNode(attributes[0]);
          detachDeletedInstance(instance);
        }
        var preloadPropsMap = new Map(),
          preconnectsSet = new Set();
        function getHoistableRoot(container) {
          return 'function' === typeof container.getRootNode
            ? container.getRootNode()
            : 9 === container.nodeType
              ? container
              : container.ownerDocument;
        }
        var previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: flushSyncWork,
          r: requestFormReset,
          D: prefetchDNS,
          C: preconnect,
          L: preload,
          m: preloadModule,
          X: preinitScript,
          S: preinitStyle,
          M: preinitModuleScript,
        };
        function flushSyncWork() {
          var previousWasRendering = previousDispatcher.f(),
            wasRendering = flushSyncWork$1();
          return previousWasRendering || wasRendering;
        }
        function requestFormReset(form) {
          var formInst = getInstanceFromNode(form);
          null !== formInst && 5 === formInst.tag && 'form' === formInst.type
            ? requestFormReset$1(formInst)
            : previousDispatcher.r(form);
        }
        var globalDocument = 'undefined' === typeof document ? null : document;
        function preconnectAs(rel, href, crossOrigin) {
          var ownerDocument = globalDocument;
          if (ownerDocument && 'string' === typeof href && href) {
            var limitedEscapedHref =
              escapeSelectorAttributeValueInsideDoubleQuotes(href);
            limitedEscapedHref =
              'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
            'string' === typeof crossOrigin &&
              (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
            preconnectsSet.has(limitedEscapedHref) ||
              (preconnectsSet.add(limitedEscapedHref),
              (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
              null === ownerDocument.querySelector(limitedEscapedHref) &&
                ((href = ownerDocument.createElement('link')),
                setInitialProperties(href, 'link', rel),
                markNodeAsHoistable(href),
                ownerDocument.head.appendChild(href)));
          }
        }
        function prefetchDNS(href) {
          previousDispatcher.D(href);
          preconnectAs('dns-prefetch', href, null);
        }
        function preconnect(href, crossOrigin) {
          previousDispatcher.C(href, crossOrigin);
          preconnectAs('preconnect', href, crossOrigin);
        }
        function preload(href, as, options) {
          previousDispatcher.L(href, as, options);
          var ownerDocument = globalDocument;
          if (ownerDocument && href && as) {
            var preloadSelector =
              'link[rel="preload"][as="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(as) +
              '"]';
            'image' === as
              ? options && options.imageSrcSet
                ? ((preloadSelector +=
                    '[imagesrcset="' +
                    escapeSelectorAttributeValueInsideDoubleQuotes(
                      options.imageSrcSet,
                    ) +
                    '"]'),
                  'string' === typeof options.imageSizes &&
                    (preloadSelector +=
                      '[imagesizes="' +
                      escapeSelectorAttributeValueInsideDoubleQuotes(
                        options.imageSizes,
                      ) +
                      '"]'))
                : (preloadSelector +=
                    '[href="' +
                    escapeSelectorAttributeValueInsideDoubleQuotes(href) +
                    '"]')
              : (preloadSelector +=
                  '[href="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(href) +
                  '"]');
            var key = preloadSelector;
            switch (as) {
              case 'style':
                key = getStyleKey(href);
                break;
              case 'script':
                key = getScriptKey(href);
            }
            preloadPropsMap.has(key) ||
              ((href = assign(
                {
                  rel: 'preload',
                  href:
                    'image' === as && options && options.imageSrcSet
                      ? void 0
                      : href,
                  as: as,
                },
                options,
              )),
              preloadPropsMap.set(key, href),
              null !== ownerDocument.querySelector(preloadSelector) ||
                ('style' === as &&
                  ownerDocument.querySelector(
                    getStylesheetSelectorFromKey(key),
                  )) ||
                ('script' === as &&
                  ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
                ((as = ownerDocument.createElement('link')),
                setInitialProperties(as, 'link', href),
                markNodeAsHoistable(as),
                ownerDocument.head.appendChild(as)));
          }
        }
        function preloadModule(href, options) {
          previousDispatcher.m(href, options);
          var ownerDocument = globalDocument;
          if (ownerDocument && href) {
            var as =
                options && 'string' === typeof options.as
                  ? options.as
                  : 'script',
              preloadSelector =
                'link[rel="modulepreload"][as="' +
                escapeSelectorAttributeValueInsideDoubleQuotes(as) +
                '"][href="' +
                escapeSelectorAttributeValueInsideDoubleQuotes(href) +
                '"]',
              key = preloadSelector;
            switch (as) {
              case 'audioworklet':
              case 'paintworklet':
              case 'serviceworker':
              case 'sharedworker':
              case 'worker':
              case 'script':
                key = getScriptKey(href);
            }
            if (
              !preloadPropsMap.has(key) &&
              ((href = assign({ rel: 'modulepreload', href: href }, options)),
              preloadPropsMap.set(key, href),
              null === ownerDocument.querySelector(preloadSelector))
            ) {
              switch (as) {
                case 'audioworklet':
                case 'paintworklet':
                case 'serviceworker':
                case 'sharedworker':
                case 'worker':
                case 'script':
                  if (
                    ownerDocument.querySelector(getScriptSelectorFromKey(key))
                  )
                    return;
              }
              as = ownerDocument.createElement('link');
              setInitialProperties(as, 'link', href);
              markNodeAsHoistable(as);
              ownerDocument.head.appendChild(as);
            }
          }
        }
        function preinitStyle(href, precedence, options) {
          previousDispatcher.S(href, precedence, options);
          var ownerDocument = globalDocument;
          if (ownerDocument && href) {
            var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
              key = getStyleKey(href);
            precedence = precedence || 'default';
            var resource = styles.get(key);
            if (!resource) {
              var state = { loading: 0, preload: null };
              if (
                (resource = ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key),
                ))
              )
                state.loading = 5;
              else {
                href = assign(
                  {
                    rel: 'stylesheet',
                    href: href,
                    'data-precedence': precedence,
                  },
                  options,
                );
                (options = preloadPropsMap.get(key)) &&
                  adoptPreloadPropsForStylesheet(href, options);
                var link = (resource = ownerDocument.createElement('link'));
                markNodeAsHoistable(link);
                setInitialProperties(link, 'link', href);
                link._p = new Promise(function (resolve, reject) {
                  link.onload = resolve;
                  link.onerror = reject;
                });
                link.addEventListener('load', function () {
                  state.loading |= 1;
                });
                link.addEventListener('error', function () {
                  state.loading |= 2;
                });
                state.loading |= 4;
                insertStylesheet(resource, precedence, ownerDocument);
              }
              resource = {
                type: 'stylesheet',
                instance: resource,
                count: 1,
                state: state,
              };
              styles.set(key, resource);
            }
          }
        }
        function preinitScript(src, options) {
          previousDispatcher.X(src, options);
          var ownerDocument = globalDocument;
          if (ownerDocument && src) {
            var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
              key = getScriptKey(src),
              resource = scripts.get(key);
            resource ||
              ((resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key),
              )),
              resource ||
                ((src = assign({ src: src, async: !0 }, options)),
                (options = preloadPropsMap.get(key)) &&
                  adoptPreloadPropsForScript(src, options),
                (resource = ownerDocument.createElement('script')),
                markNodeAsHoistable(resource),
                setInitialProperties(resource, 'link', src),
                ownerDocument.head.appendChild(resource)),
              (resource = {
                type: 'script',
                instance: resource,
                count: 1,
                state: null,
              }),
              scripts.set(key, resource));
          }
        }
        function preinitModuleScript(src, options) {
          previousDispatcher.M(src, options);
          var ownerDocument = globalDocument;
          if (ownerDocument && src) {
            var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
              key = getScriptKey(src),
              resource = scripts.get(key);
            resource ||
              ((resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key),
              )),
              resource ||
                ((src = assign(
                  { src: src, async: !0, type: 'module' },
                  options,
                )),
                (options = preloadPropsMap.get(key)) &&
                  adoptPreloadPropsForScript(src, options),
                (resource = ownerDocument.createElement('script')),
                markNodeAsHoistable(resource),
                setInitialProperties(resource, 'link', src),
                ownerDocument.head.appendChild(resource)),
              (resource = {
                type: 'script',
                instance: resource,
                count: 1,
                state: null,
              }),
              scripts.set(key, resource));
          }
        }
        function getResource(
          type,
          currentProps,
          pendingProps,
          currentResource,
        ) {
          var JSCompiler_inline_result = (JSCompiler_inline_result =
            rootInstanceStackCursor.current)
            ? getHoistableRoot(JSCompiler_inline_result)
            : null;
          if (!JSCompiler_inline_result)
            throw Error(formatProdErrorMessage(446));
          switch (type) {
            case 'meta':
            case 'title':
              return null;
            case 'style':
              return 'string' === typeof pendingProps.precedence &&
                'string' === typeof pendingProps.href
                ? ((currentProps = getStyleKey(pendingProps.href)),
                  (pendingProps = getResourcesFromRoot(
                    JSCompiler_inline_result,
                  ).hoistableStyles),
                  (currentResource = pendingProps.get(currentProps)),
                  currentResource ||
                    ((currentResource = {
                      type: 'style',
                      instance: null,
                      count: 0,
                      state: null,
                    }),
                    pendingProps.set(currentProps, currentResource)),
                  currentResource)
                : { type: 'void', instance: null, count: 0, state: null };
            case 'link':
              if (
                'stylesheet' === pendingProps.rel &&
                'string' === typeof pendingProps.href &&
                'string' === typeof pendingProps.precedence
              ) {
                type = getStyleKey(pendingProps.href);
                var styles$243 = getResourcesFromRoot(
                    JSCompiler_inline_result,
                  ).hoistableStyles,
                  resource$244 = styles$243.get(type);
                resource$244 ||
                  ((JSCompiler_inline_result =
                    JSCompiler_inline_result.ownerDocument ||
                    JSCompiler_inline_result),
                  (resource$244 = {
                    type: 'stylesheet',
                    instance: null,
                    count: 0,
                    state: { loading: 0, preload: null },
                  }),
                  styles$243.set(type, resource$244),
                  (styles$243 = JSCompiler_inline_result.querySelector(
                    getStylesheetSelectorFromKey(type),
                  )) &&
                    !styles$243._p &&
                    ((resource$244.instance = styles$243),
                    (resource$244.state.loading = 5)),
                  preloadPropsMap.has(type) ||
                    ((pendingProps = {
                      rel: 'preload',
                      as: 'style',
                      href: pendingProps.href,
                      crossOrigin: pendingProps.crossOrigin,
                      integrity: pendingProps.integrity,
                      media: pendingProps.media,
                      hrefLang: pendingProps.hrefLang,
                      referrerPolicy: pendingProps.referrerPolicy,
                    }),
                    preloadPropsMap.set(type, pendingProps),
                    styles$243 ||
                      preloadStylesheet(
                        JSCompiler_inline_result,
                        type,
                        pendingProps,
                        resource$244.state,
                      )));
                if (currentProps && null === currentResource)
                  throw Error(formatProdErrorMessage(528, ''));
                return resource$244;
              }
              if (currentProps && null !== currentResource)
                throw Error(formatProdErrorMessage(529, ''));
              return null;
            case 'script':
              return (
                (currentProps = pendingProps.async),
                (pendingProps = pendingProps.src),
                'string' === typeof pendingProps &&
                currentProps &&
                'function' !== typeof currentProps &&
                'symbol' !== typeof currentProps
                  ? ((currentProps = getScriptKey(pendingProps)),
                    (pendingProps = getResourcesFromRoot(
                      JSCompiler_inline_result,
                    ).hoistableScripts),
                    (currentResource = pendingProps.get(currentProps)),
                    currentResource ||
                      ((currentResource = {
                        type: 'script',
                        instance: null,
                        count: 0,
                        state: null,
                      }),
                      pendingProps.set(currentProps, currentResource)),
                    currentResource)
                  : { type: 'void', instance: null, count: 0, state: null }
              );
            default:
              throw Error(formatProdErrorMessage(444, type));
          }
        }
        function getStyleKey(href) {
          return (
            'href="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(href) +
            '"'
          );
        }
        function getStylesheetSelectorFromKey(key) {
          return 'link[rel="stylesheet"][' + key + ']';
        }
        function stylesheetPropsFromRawProps(rawProps) {
          return assign({}, rawProps, {
            'data-precedence': rawProps.precedence,
            precedence: null,
          });
        }
        function preloadStylesheet(ownerDocument, key, preloadProps, state) {
          ownerDocument.querySelector(
            'link[rel="preload"][as="style"][' + key + ']',
          )
            ? (state.loading = 1)
            : ((key = ownerDocument.createElement('link')),
              (state.preload = key),
              key.addEventListener('load', function () {
                return (state.loading |= 1);
              }),
              key.addEventListener('error', function () {
                return (state.loading |= 2);
              }),
              setInitialProperties(key, 'link', preloadProps),
              markNodeAsHoistable(key),
              ownerDocument.head.appendChild(key));
        }
        function getScriptKey(src) {
          return (
            '[src="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(src) +
            '"]'
          );
        }
        function getScriptSelectorFromKey(key) {
          return 'script[async]' + key;
        }
        function acquireResource(hoistableRoot, resource, props) {
          resource.count++;
          if (null === resource.instance)
            switch (resource.type) {
              case 'style':
                var instance = hoistableRoot.querySelector(
                  'style[data-href~="' +
                    escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
                    '"]',
                );
                if (instance)
                  return (
                    (resource.instance = instance),
                    markNodeAsHoistable(instance),
                    instance
                  );
                var styleProps = assign({}, props, {
                  'data-href': props.href,
                  'data-precedence': props.precedence,
                  href: null,
                  precedence: null,
                });
                instance = (
                  hoistableRoot.ownerDocument || hoistableRoot
                ).createElement('style');
                markNodeAsHoistable(instance);
                setInitialProperties(instance, 'style', styleProps);
                insertStylesheet(instance, props.precedence, hoistableRoot);
                return (resource.instance = instance);
              case 'stylesheet':
                styleProps = getStyleKey(props.href);
                var instance$249 = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(styleProps),
                );
                if (instance$249)
                  return (
                    (resource.state.loading |= 4),
                    (resource.instance = instance$249),
                    markNodeAsHoistable(instance$249),
                    instance$249
                  );
                instance = stylesheetPropsFromRawProps(props);
                (styleProps = preloadPropsMap.get(styleProps)) &&
                  adoptPreloadPropsForStylesheet(instance, styleProps);
                instance$249 = (
                  hoistableRoot.ownerDocument || hoistableRoot
                ).createElement('link');
                markNodeAsHoistable(instance$249);
                var linkInstance = instance$249;
                linkInstance._p = new Promise(function (resolve, reject) {
                  linkInstance.onload = resolve;
                  linkInstance.onerror = reject;
                });
                setInitialProperties(instance$249, 'link', instance);
                resource.state.loading |= 4;
                insertStylesheet(instance$249, props.precedence, hoistableRoot);
                return (resource.instance = instance$249);
              case 'script':
                instance$249 = getScriptKey(props.src);
                if (
                  (styleProps = hoistableRoot.querySelector(
                    getScriptSelectorFromKey(instance$249),
                  ))
                )
                  return (
                    (resource.instance = styleProps),
                    markNodeAsHoistable(styleProps),
                    styleProps
                  );
                instance = props;
                if ((styleProps = preloadPropsMap.get(instance$249)))
                  (instance = assign({}, props)),
                    adoptPreloadPropsForScript(instance, styleProps);
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                styleProps = hoistableRoot.createElement('script');
                markNodeAsHoistable(styleProps);
                setInitialProperties(styleProps, 'link', instance);
                hoistableRoot.head.appendChild(styleProps);
                return (resource.instance = styleProps);
              case 'void':
                return null;
              default:
                throw Error(formatProdErrorMessage(443, resource.type));
            }
          else
            'stylesheet' === resource.type &&
              0 === (resource.state.loading & 4) &&
              ((instance = resource.instance),
              (resource.state.loading |= 4),
              insertStylesheet(instance, props.precedence, hoistableRoot));
          return resource.instance;
        }
        function insertStylesheet(instance, precedence, root) {
          for (
            var nodes = root.querySelectorAll(
                'link[rel="stylesheet"][data-precedence],style[data-precedence]',
              ),
              last = nodes.length ? nodes[nodes.length - 1] : null,
              prior = last,
              i = 0;
            i < nodes.length;
            i++
          ) {
            var node = nodes[i];
            if (node.dataset.precedence === precedence) prior = node;
            else if (prior !== last) break;
          }
          prior
            ? prior.parentNode.insertBefore(instance, prior.nextSibling)
            : ((precedence = 9 === root.nodeType ? root.head : root),
              precedence.insertBefore(instance, precedence.firstChild));
        }
        function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
          null == stylesheetProps.crossOrigin &&
            (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
          null == stylesheetProps.referrerPolicy &&
            (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
          null == stylesheetProps.title &&
            (stylesheetProps.title = preloadProps.title);
        }
        function adoptPreloadPropsForScript(scriptProps, preloadProps) {
          null == scriptProps.crossOrigin &&
            (scriptProps.crossOrigin = preloadProps.crossOrigin);
          null == scriptProps.referrerPolicy &&
            (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
          null == scriptProps.integrity &&
            (scriptProps.integrity = preloadProps.integrity);
        }
        var tagCaches = null;
        function getHydratableHoistableCache(
          type,
          keyAttribute,
          ownerDocument,
        ) {
          if (null === tagCaches) {
            var cache = new Map();
            var caches = (tagCaches = new Map());
            caches.set(ownerDocument, cache);
          } else
            (caches = tagCaches),
              (cache = caches.get(ownerDocument)),
              cache || ((cache = new Map()), caches.set(ownerDocument, cache));
          if (cache.has(type)) return cache;
          cache.set(type, null);
          ownerDocument = ownerDocument.getElementsByTagName(type);
          for (caches = 0; caches < ownerDocument.length; caches++) {
            var node = ownerDocument[caches];
            if (
              !(
                node[internalHoistableMarker] ||
                node[internalInstanceKey] ||
                ('link' === type && 'stylesheet' === node.getAttribute('rel'))
              ) &&
              'http://www.w3.org/2000/svg' !== node.namespaceURI
            ) {
              var nodeKey = node.getAttribute(keyAttribute) || '';
              nodeKey = type + nodeKey;
              var existing = cache.get(nodeKey);
              existing ? existing.push(node) : cache.set(nodeKey, [node]);
            }
          }
          return cache;
        }
        function mountHoistable(hoistableRoot, type, instance) {
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          hoistableRoot.head.insertBefore(
            instance,
            'title' === type
              ? hoistableRoot.querySelector('head > title')
              : null,
          );
        }
        function isHostHoistableType(type, props, hostContext) {
          if (1 === hostContext || null != props.itemProp) return !1;
          switch (type) {
            case 'meta':
            case 'title':
              return !0;
            case 'style':
              if (
                'string' !== typeof props.precedence ||
                'string' !== typeof props.href ||
                '' === props.href
              )
                break;
              return !0;
            case 'link':
              if (
                'string' !== typeof props.rel ||
                'string' !== typeof props.href ||
                '' === props.href ||
                props.onLoad ||
                props.onError
              )
                break;
              switch (props.rel) {
                case 'stylesheet':
                  return (
                    (type = props.disabled),
                    'string' === typeof props.precedence && null == type
                  );
                default:
                  return !0;
              }
            case 'script':
              if (
                props.async &&
                'function' !== typeof props.async &&
                'symbol' !== typeof props.async &&
                !props.onLoad &&
                !props.onError &&
                props.src &&
                'string' === typeof props.src
              )
                return !0;
          }
          return !1;
        }
        function preloadResource(resource) {
          return 'stylesheet' === resource.type &&
            0 === (resource.state.loading & 3)
            ? !1
            : !0;
        }
        function suspendResource(state, hoistableRoot, resource, props) {
          if (
            'stylesheet' === resource.type &&
            ('string' !== typeof props.media ||
              !1 !== matchMedia(props.media).matches) &&
            0 === (resource.state.loading & 4)
          ) {
            if (null === resource.instance) {
              var key = getStyleKey(props.href),
                instance = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(key),
                );
              if (instance) {
                hoistableRoot = instance._p;
                null !== hoistableRoot &&
                  'object' === typeof hoistableRoot &&
                  'function' === typeof hoistableRoot.then &&
                  (state.count++,
                  (state = onUnsuspend.bind(state)),
                  hoistableRoot.then(state, state));
                resource.state.loading |= 4;
                resource.instance = instance;
                markNodeAsHoistable(instance);
                return;
              }
              instance = hoistableRoot.ownerDocument || hoistableRoot;
              props = stylesheetPropsFromRawProps(props);
              (key = preloadPropsMap.get(key)) &&
                adoptPreloadPropsForStylesheet(props, key);
              instance = instance.createElement('link');
              markNodeAsHoistable(instance);
              var linkInstance = instance;
              linkInstance._p = new Promise(function (resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance, 'link', props);
              resource.instance = instance;
            }
            null === state.stylesheets && (state.stylesheets = new Map());
            state.stylesheets.set(resource, hoistableRoot);
            (hoistableRoot = resource.state.preload) &&
              0 === (resource.state.loading & 3) &&
              (state.count++,
              (resource = onUnsuspend.bind(state)),
              hoistableRoot.addEventListener('load', resource),
              hoistableRoot.addEventListener('error', resource));
          }
        }
        var estimatedBytesWithinLimit = 0;
        function waitForCommitToBeReady(state, timeoutOffset) {
          state.stylesheets &&
            0 === state.count &&
            insertSuspendedStylesheets(state, state.stylesheets);
          return 0 < state.count || 0 < state.imgCount
            ? function (commit) {
                var stylesheetTimer = setTimeout(function () {
                  state.stylesheets &&
                    insertSuspendedStylesheets(state, state.stylesheets);
                  if (state.unsuspend) {
                    var unsuspend = state.unsuspend;
                    state.unsuspend = null;
                    unsuspend();
                  }
                }, 6e4 + timeoutOffset);
                0 < state.imgBytes &&
                  0 === estimatedBytesWithinLimit &&
                  (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
                var imgTimer = setTimeout(
                  function () {
                    state.waitingForImages = !1;
                    if (
                      0 === state.count &&
                      (state.stylesheets &&
                        insertSuspendedStylesheets(state, state.stylesheets),
                      state.unsuspend)
                    ) {
                      var unsuspend = state.unsuspend;
                      state.unsuspend = null;
                      unsuspend();
                    }
                  },
                  (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) +
                    timeoutOffset,
                );
                state.unsuspend = commit;
                return function () {
                  state.unsuspend = null;
                  clearTimeout(stylesheetTimer);
                  clearTimeout(imgTimer);
                };
              }
            : null;
        }
        function onUnsuspend() {
          this.count--;
          if (
            0 === this.count &&
            (0 === this.imgCount || !this.waitingForImages)
          )
            if (this.stylesheets)
              insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
              var unsuspend = this.unsuspend;
              this.unsuspend = null;
              unsuspend();
            }
        }
        var precedencesByRoot = null;
        function insertSuspendedStylesheets(state, resources) {
          state.stylesheets = null;
          null !== state.unsuspend &&
            (state.count++,
            (precedencesByRoot = new Map()),
            resources.forEach(insertStylesheetIntoRoot, state),
            (precedencesByRoot = null),
            onUnsuspend.call(state));
        }
        function insertStylesheetIntoRoot(root, resource) {
          if (!(resource.state.loading & 4)) {
            var precedences = precedencesByRoot.get(root);
            if (precedences) var last = precedences.get(null);
            else {
              precedences = new Map();
              precedencesByRoot.set(root, precedences);
              for (
                var nodes = root.querySelectorAll(
                    'link[data-precedence],style[data-precedence]',
                  ),
                  i = 0;
                i < nodes.length;
                i++
              ) {
                var node = nodes[i];
                if (
                  'LINK' === node.nodeName ||
                  'not all' !== node.getAttribute('media')
                )
                  precedences.set(node.dataset.precedence, node), (last = node);
              }
              last && precedences.set(null, last);
            }
            nodes = resource.instance;
            node = nodes.getAttribute('data-precedence');
            i = precedences.get(node) || last;
            i === last && precedences.set(null, nodes);
            precedences.set(node, nodes);
            this.count++;
            last = onUnsuspend.bind(this);
            nodes.addEventListener('load', last);
            nodes.addEventListener('error', last);
            i
              ? i.parentNode.insertBefore(nodes, i.nextSibling)
              : ((root = 9 === root.nodeType ? root.head : root),
                root.insertBefore(nodes, root.firstChild));
            resource.state.loading |= 4;
          }
        }
        var HostTransitionContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Provider: null,
          Consumer: null,
          _currentValue: sharedNotPendingObject,
          _currentValue2: sharedNotPendingObject,
          _threadCount: 0,
        };
        function FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          onDefaultTransitionIndicator,
          formState,
        ) {
          this.tag = 1;
          this.containerInfo = containerInfo;
          this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = -1;
          this.callbackNode =
            this.next =
            this.pendingContext =
            this.context =
            this.cancelPendingCommit =
              null;
          this.callbackPriority = 0;
          this.expirationTimes = createLaneMap(-1);
          this.entangledLanes =
            this.shellSuspendCounter =
            this.errorRecoveryDisabledLanes =
            this.expiredLanes =
            this.warmLanes =
            this.pingedLanes =
            this.suspendedLanes =
            this.pendingLanes =
              0;
          this.entanglements = createLaneMap(0);
          this.hiddenUpdates = createLaneMap(null);
          this.identifierPrefix = identifierPrefix;
          this.onUncaughtError = onUncaughtError;
          this.onCaughtError = onCaughtError;
          this.onRecoverableError = onRecoverableError;
          this.pooledCache = null;
          this.pooledCacheLanes = 0;
          this.formState = formState;
          this.incompleteTransitions = new Map();
        }
        function createFiberRoot(
          containerInfo,
          tag,
          hydrate,
          initialChildren,
          hydrationCallbacks,
          isStrictMode,
          identifierPrefix,
          formState,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          onDefaultTransitionIndicator,
        ) {
          containerInfo = new FiberRootNode(
            containerInfo,
            tag,
            hydrate,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            onDefaultTransitionIndicator,
            formState,
          );
          tag = 1;
          !0 === isStrictMode && (tag |= 24);
          isStrictMode = createFiberImplClass(3, null, null, tag);
          containerInfo.current = isStrictMode;
          isStrictMode.stateNode = containerInfo;
          tag = createCache();
          tag.refCount++;
          containerInfo.pooledCache = tag;
          tag.refCount++;
          isStrictMode.memoizedState = {
            element: initialChildren,
            isDehydrated: hydrate,
            cache: tag,
          };
          initializeUpdateQueue(isStrictMode);
          return containerInfo;
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) return emptyContextObject;
          parentComponent = emptyContextObject;
          return parentComponent;
        }
        function updateContainerImpl(
          rootFiber,
          lane,
          element,
          container,
          parentComponent,
          callback,
        ) {
          parentComponent = getContextForSubtree(parentComponent);
          null === container.context
            ? (container.context = parentComponent)
            : (container.pendingContext = parentComponent);
          container = createUpdate(lane);
          container.payload = { element: element };
          callback = void 0 === callback ? null : callback;
          null !== callback && (container.callback = callback);
          element = enqueueUpdate(rootFiber, container, lane);
          null !== element &&
            (scheduleUpdateOnFiber(element, rootFiber, lane),
            entangleTransitions(element, rootFiber, lane));
        }
        function markRetryLaneImpl(fiber, retryLane) {
          fiber = fiber.memoizedState;
          if (null !== fiber && null !== fiber.dehydrated) {
            var a = fiber.retryLane;
            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
        }
        function attemptContinuousHydration(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var root = enqueueConcurrentRenderForLane(fiber, 67108864);
            null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
            markRetryLaneIfNotHydrated(fiber, 67108864);
          }
        }
        function attemptHydrationAtCurrentPriority(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var lane = requestUpdateLane();
            lane = getBumpedLaneForHydrationByLane(lane);
            var root = enqueueConcurrentRenderForLane(fiber, lane);
            null !== root && scheduleUpdateOnFiber(root, fiber, lane);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
        }
        var _enabled = !0;
        function dispatchDiscreteEvent(
          domEventName,
          eventSystemFlags,
          container,
          nativeEvent,
        ) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            (ReactDOMSharedInternals.p = 2),
              dispatchEvent(
                domEventName,
                eventSystemFlags,
                container,
                nativeEvent,
              );
          } finally {
            (ReactDOMSharedInternals.p = previousPriority),
              (ReactSharedInternals.T = prevTransition);
          }
        }
        function dispatchContinuousEvent(
          domEventName,
          eventSystemFlags,
          container,
          nativeEvent,
        ) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            (ReactDOMSharedInternals.p = 8),
              dispatchEvent(
                domEventName,
                eventSystemFlags,
                container,
                nativeEvent,
              );
          } finally {
            (ReactDOMSharedInternals.p = previousPriority),
              (ReactSharedInternals.T = prevTransition);
          }
        }
        function dispatchEvent(
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent,
        ) {
          if (_enabled) {
            var blockedOn = findInstanceBlockingEvent(nativeEvent);
            if (null === blockedOn)
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer,
              ),
                clearIfContinuousEvent(domEventName, nativeEvent);
            else if (
              queueIfContinuousEvent(
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent,
              )
            )
              nativeEvent.stopPropagation();
            else if (
              (clearIfContinuousEvent(domEventName, nativeEvent),
              eventSystemFlags & 4 &&
                -1 < discreteReplayableEvents.indexOf(domEventName))
            ) {
              for (; null !== blockedOn; ) {
                var fiber = getInstanceFromNode(blockedOn);
                if (null !== fiber)
                  switch (fiber.tag) {
                    case 3:
                      fiber = fiber.stateNode;
                      if (fiber.current.memoizedState.isDehydrated) {
                        var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                        if (0 !== lanes) {
                          var root = fiber;
                          root.pendingLanes |= 2;
                          for (root.entangledLanes |= 2; lanes; ) {
                            var lane = 1 << (31 - clz32(lanes));
                            root.entanglements[1] |= lane;
                            lanes &= ~lane;
                          }
                          ensureRootIsScheduled(fiber);
                          0 === (executionContext & 6) &&
                            ((workInProgressRootRenderTargetTime = now() + 500),
                            flushSyncWorkAcrossRoots_impl(0, !1));
                        }
                      }
                      break;
                    case 31:
                    case 13:
                      (root = enqueueConcurrentRenderForLane(fiber, 2)),
                        null !== root && scheduleUpdateOnFiber(root, fiber, 2),
                        flushSyncWork$1(),
                        markRetryLaneIfNotHydrated(fiber, 2);
                  }
                fiber = findInstanceBlockingEvent(nativeEvent);
                null === fiber &&
                  dispatchEventForPluginEventSystem(
                    domEventName,
                    eventSystemFlags,
                    nativeEvent,
                    return_targetInst,
                    targetContainer,
                  );
                if (fiber === blockedOn) break;
                blockedOn = fiber;
              }
              null !== blockedOn && nativeEvent.stopPropagation();
            } else
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                null,
                targetContainer,
              );
          }
        }
        function findInstanceBlockingEvent(nativeEvent) {
          nativeEvent = getEventTarget(nativeEvent);
          return findInstanceBlockingTarget(nativeEvent);
        }
        var return_targetInst = null;
        function findInstanceBlockingTarget(targetNode) {
          return_targetInst = null;
          targetNode = getClosestInstanceFromNode(targetNode);
          if (null !== targetNode) {
            var nearestMounted = getNearestMountedFiber(targetNode);
            if (null === nearestMounted) targetNode = null;
            else {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (31 === tag) {
                targetNode = getActivityInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (3 === tag) {
                if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                  return 3 === nearestMounted.tag
                    ? nearestMounted.stateNode.containerInfo
                    : null;
                targetNode = null;
              } else nearestMounted !== targetNode && (targetNode = null);
            }
          }
          return_targetInst = targetNode;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case 'beforetoggle':
            case 'cancel':
            case 'click':
            case 'close':
            case 'contextmenu':
            case 'copy':
            case 'cut':
            case 'auxclick':
            case 'dblclick':
            case 'dragend':
            case 'dragstart':
            case 'drop':
            case 'focusin':
            case 'focusout':
            case 'input':
            case 'invalid':
            case 'keydown':
            case 'keypress':
            case 'keyup':
            case 'mousedown':
            case 'mouseup':
            case 'paste':
            case 'pause':
            case 'play':
            case 'pointercancel':
            case 'pointerdown':
            case 'pointerup':
            case 'ratechange':
            case 'reset':
            case 'resize':
            case 'seeked':
            case 'submit':
            case 'toggle':
            case 'touchcancel':
            case 'touchend':
            case 'touchstart':
            case 'volumechange':
            case 'change':
            case 'selectionchange':
            case 'textInput':
            case 'compositionstart':
            case 'compositionend':
            case 'compositionupdate':
            case 'beforeblur':
            case 'afterblur':
            case 'beforeinput':
            case 'blur':
            case 'fullscreenchange':
            case 'focus':
            case 'hashchange':
            case 'popstate':
            case 'select':
            case 'selectstart':
              return 2;
            case 'drag':
            case 'dragenter':
            case 'dragexit':
            case 'dragleave':
            case 'dragover':
            case 'mousemove':
            case 'mouseout':
            case 'mouseover':
            case 'pointermove':
            case 'pointerout':
            case 'pointerover':
            case 'scroll':
            case 'touchmove':
            case 'wheel':
            case 'mouseenter':
            case 'mouseleave':
            case 'pointerenter':
            case 'pointerleave':
              return 8;
            case 'message':
              switch (getCurrentPriorityLevel()) {
                case ImmediatePriority:
                  return 2;
                case UserBlockingPriority:
                  return 8;
                case NormalPriority$1:
                case LowPriority:
                  return 32;
                case IdlePriority:
                  return 268435456;
                default:
                  return 32;
              }
            default:
              return 32;
          }
        }
        var hasScheduledReplayAttempt = !1,
          queuedFocus = null,
          queuedDrag = null,
          queuedMouse = null,
          queuedPointers = new Map(),
          queuedPointerCaptures = new Map(),
          queuedExplicitHydrationTargets = [],
          discreteReplayableEvents =
            'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset'.split(
              ' ',
            );
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case 'focusin':
            case 'focusout':
              queuedFocus = null;
              break;
            case 'dragenter':
            case 'dragleave':
              queuedDrag = null;
              break;
            case 'mouseover':
            case 'mouseout':
              queuedMouse = null;
              break;
            case 'pointerover':
            case 'pointerout':
              queuedPointers.delete(nativeEvent.pointerId);
              break;
            case 'gotpointercapture':
            case 'lostpointercapture':
              queuedPointerCaptures.delete(nativeEvent.pointerId);
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(
          existingQueuedEvent,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent,
        ) {
          if (
            null === existingQueuedEvent ||
            existingQueuedEvent.nativeEvent !== nativeEvent
          )
            return (
              (existingQueuedEvent = {
                blockedOn: blockedOn,
                domEventName: domEventName,
                eventSystemFlags: eventSystemFlags,
                nativeEvent: nativeEvent,
                targetContainers: [targetContainer],
              }),
              null !== blockedOn &&
                ((blockedOn = getInstanceFromNode(blockedOn)),
                null !== blockedOn && attemptContinuousHydration(blockedOn)),
              existingQueuedEvent
            );
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          blockedOn = existingQueuedEvent.targetContainers;
          null !== targetContainer &&
            -1 === blockedOn.indexOf(targetContainer) &&
            blockedOn.push(targetContainer);
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent,
        ) {
          switch (domEventName) {
            case 'focusin':
              return (
                (queuedFocus =
                  accumulateOrCreateContinuousQueuedReplayableEvent(
                    queuedFocus,
                    blockedOn,
                    domEventName,
                    eventSystemFlags,
                    targetContainer,
                    nativeEvent,
                  )),
                !0
              );
            case 'dragenter':
              return (
                (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedDrag,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent,
                )),
                !0
              );
            case 'mouseover':
              return (
                (queuedMouse =
                  accumulateOrCreateContinuousQueuedReplayableEvent(
                    queuedMouse,
                    blockedOn,
                    domEventName,
                    eventSystemFlags,
                    targetContainer,
                    nativeEvent,
                  )),
                !0
              );
            case 'pointerover':
              var pointerId = nativeEvent.pointerId;
              queuedPointers.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointers.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent,
                ),
              );
              return !0;
            case 'gotpointercapture':
              return (
                (pointerId = nativeEvent.pointerId),
                queuedPointerCaptures.set(
                  pointerId,
                  accumulateOrCreateContinuousQueuedReplayableEvent(
                    queuedPointerCaptures.get(pointerId) || null,
                    blockedOn,
                    domEventName,
                    eventSystemFlags,
                    targetContainer,
                    nativeEvent,
                  ),
                ),
                !0
              );
          }
          return !1;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted)
              if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
                if (
                  ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
                  null !== targetInst)
                ) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function () {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (31 === targetInst) {
                if (
                  ((targetInst = getActivityInstanceFromFiber(nearestMounted)),
                  null !== targetInst)
                ) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function () {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (
                3 === targetInst &&
                nearestMounted.stateNode.current.memoizedState.isDehydrated
              ) {
                queuedTarget.blockedOn =
                  3 === nearestMounted.tag
                    ? nearestMounted.stateNode.containerInfo
                    : null;
                return;
              }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (null !== queuedEvent.blockedOn) return !1;
          for (
            var targetContainers = queuedEvent.targetContainers;
            0 < targetContainers.length;

          ) {
            var nextBlockedOn = findInstanceBlockingEvent(
              queuedEvent.nativeEvent,
            );
            if (null === nextBlockedOn) {
              nextBlockedOn = queuedEvent.nativeEvent;
              var nativeEventClone = new nextBlockedOn.constructor(
                nextBlockedOn.type,
                nextBlockedOn,
              );
              currentReplayingEvent = nativeEventClone;
              nextBlockedOn.target.dispatchEvent(nativeEventClone);
              currentReplayingEvent = null;
            } else
              return (
                (targetContainers = getInstanceFromNode(nextBlockedOn)),
                null !== targetContainers &&
                  attemptContinuousHydration(targetContainers),
                (queuedEvent.blockedOn = nextBlockedOn),
                !1
              );
            targetContainers.shift();
          }
          return !0;
        }
        function attemptReplayContinuousQueuedEventInMap(
          queuedEvent,
          key,
          map,
        ) {
          attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = !1;
          null !== queuedFocus &&
            attemptReplayContinuousQueuedEvent(queuedFocus) &&
            (queuedFocus = null);
          null !== queuedDrag &&
            attemptReplayContinuousQueuedEvent(queuedDrag) &&
            (queuedDrag = null);
          null !== queuedMouse &&
            attemptReplayContinuousQueuedEvent(queuedMouse) &&
            (queuedMouse = null);
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(
            attemptReplayContinuousQueuedEventInMap,
          );
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          queuedEvent.blockedOn === unblocked &&
            ((queuedEvent.blockedOn = null),
            hasScheduledReplayAttempt ||
              ((hasScheduledReplayAttempt = !0),
              Scheduler.unstable_scheduleCallback(
                Scheduler.unstable_NormalPriority,
                replayUnblockedEvents,
              )));
        }
        var lastScheduledReplayQueue = null;
        function scheduleReplayQueueIfNeeded(formReplayingQueue) {
          lastScheduledReplayQueue !== formReplayingQueue &&
            ((lastScheduledReplayQueue = formReplayingQueue),
            Scheduler.unstable_scheduleCallback(
              Scheduler.unstable_NormalPriority,
              function () {
                lastScheduledReplayQueue === formReplayingQueue &&
                  (lastScheduledReplayQueue = null);
                for (var i = 0; i < formReplayingQueue.length; i += 3) {
                  var form = formReplayingQueue[i],
                    submitterOrAction = formReplayingQueue[i + 1],
                    formData = formReplayingQueue[i + 2];
                  if ('function' !== typeof submitterOrAction)
                    if (
                      null ===
                      findInstanceBlockingTarget(submitterOrAction || form)
                    )
                      continue;
                    else break;
                  var formInst = getInstanceFromNode(form);
                  null !== formInst &&
                    (formReplayingQueue.splice(i, 3),
                    (i -= 3),
                    startHostTransition(
                      formInst,
                      {
                        pending: !0,
                        data: formData,
                        method: form.method,
                        action: submitterOrAction,
                      },
                      submitterOrAction,
                      formData,
                    ));
                }
              },
            ));
        }
        function retryIfBlockedOn(unblocked) {
          function unblock(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
          }
          null !== queuedFocus &&
            scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          null !== queuedDrag &&
            scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          null !== queuedMouse &&
            scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
            var queuedTarget = queuedExplicitHydrationTargets[i];
            queuedTarget.blockedOn === unblocked &&
              (queuedTarget.blockedOn = null);
          }
          for (
            ;
            0 < queuedExplicitHydrationTargets.length &&
            ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

          )
            attemptExplicitHydrationTarget(i),
              null === i.blockedOn && queuedExplicitHydrationTargets.shift();
          i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
          if (null != i)
            for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
              var form = i[queuedTarget],
                submitterOrAction = i[queuedTarget + 1],
                formProps = form[internalPropsKey] || null;
              if ('function' === typeof submitterOrAction)
                formProps || scheduleReplayQueueIfNeeded(i);
              else if (formProps) {
                var action = null;
                if (
                  submitterOrAction &&
                  submitterOrAction.hasAttribute('formAction')
                )
                  if (
                    ((form = submitterOrAction),
                    (formProps = submitterOrAction[internalPropsKey] || null))
                  )
                    action = formProps.formAction;
                  else {
                    if (null !== findInstanceBlockingTarget(form)) continue;
                  }
                else action = formProps.action;
                'function' === typeof action
                  ? (i[queuedTarget + 1] = action)
                  : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
                scheduleReplayQueueIfNeeded(i);
              }
            }
        }
        function defaultOnDefaultTransitionIndicator() {
          function handleNavigate(event) {
            event.canIntercept &&
              'react-transition' === event.info &&
              event.intercept({
                handler: function () {
                  return new Promise(function (resolve) {
                    return (pendingResolve = resolve);
                  });
                },
                focusReset: 'manual',
                scroll: 'manual',
              });
          }
          function handleNavigateComplete() {
            null !== pendingResolve &&
              (pendingResolve(), (pendingResolve = null));
            isCancelled || setTimeout(startFakeNavigation, 20);
          }
          function startFakeNavigation() {
            if (!isCancelled && !navigation.transition) {
              var currentEntry = navigation.currentEntry;
              currentEntry &&
                null != currentEntry.url &&
                navigation.navigate(currentEntry.url, {
                  state: currentEntry.getState(),
                  info: 'react-transition',
                  history: 'replace',
                });
            }
          }
          if ('object' === typeof navigation) {
            var isCancelled = !1,
              pendingResolve = null;
            navigation.addEventListener('navigate', handleNavigate);
            navigation.addEventListener(
              'navigatesuccess',
              handleNavigateComplete,
            );
            navigation.addEventListener(
              'navigateerror',
              handleNavigateComplete,
            );
            setTimeout(startFakeNavigation, 100);
            return function () {
              isCancelled = !0;
              navigation.removeEventListener('navigate', handleNavigate);
              navigation.removeEventListener(
                'navigatesuccess',
                handleNavigateComplete,
              );
              navigation.removeEventListener(
                'navigateerror',
                handleNavigateComplete,
              );
              null !== pendingResolve &&
                (pendingResolve(), (pendingResolve = null));
            };
          }
        }
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
          function (children) {
            var root = this._internalRoot;
            if (null === root) throw Error(formatProdErrorMessage(409));
            var current = root.current,
              lane = requestUpdateLane();
            updateContainerImpl(current, lane, children, root, null, null);
          };
        ReactDOMHydrationRoot.prototype.unmount =
          ReactDOMRoot.prototype.unmount = function () {
            var root = this._internalRoot;
            if (null !== root) {
              this._internalRoot = null;
              var container = root.containerInfo;
              updateContainerImpl(root.current, 2, null, root, null, null);
              flushSyncWork$1();
              container[internalContainerInstanceKey] = null;
            }
          };
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (
          target,
        ) {
          if (target) {
            var updatePriority = resolveUpdatePriority();
            target = {
              blockedOn: null,
              target: target,
              priority: updatePriority,
            };
            for (
              var i = 0;
              i < queuedExplicitHydrationTargets.length &&
              0 !== updatePriority &&
              updatePriority < queuedExplicitHydrationTargets[i].priority;
              i++
            );
            queuedExplicitHydrationTargets.splice(i, 0, target);
            0 === i && attemptExplicitHydrationTarget(target);
          }
        };
        var isomorphicReactPackageVersion$jscomp$inline_1840 = React.version;
        if ('19.2.0' !== isomorphicReactPackageVersion$jscomp$inline_1840)
          throw Error(
            formatProdErrorMessage(
              527,
              isomorphicReactPackageVersion$jscomp$inline_1840,
              '19.2.0',
            ),
          );
        ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
          var fiber = componentOrElement._reactInternals;
          if (void 0 === fiber) {
            if ('function' === typeof componentOrElement.render)
              throw Error(formatProdErrorMessage(188));
            componentOrElement = Object.keys(componentOrElement).join(',');
            throw Error(formatProdErrorMessage(268, componentOrElement));
          }
          componentOrElement = findCurrentFiberUsingSlowPath(fiber);
          componentOrElement =
            null !== componentOrElement
              ? findCurrentHostFiberImpl(componentOrElement)
              : null;
          componentOrElement =
            null === componentOrElement ? null : componentOrElement.stateNode;
          return componentOrElement;
        };
        var internals$jscomp$inline_2347 = {
          bundleType: 0,
          version: '19.2.0',
          rendererPackageName: 'react-dom',
          currentDispatcherRef: ReactSharedInternals,
          reconcilerVersion: '19.2.0',
        };
        if ('undefined' !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
          var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (
            !hook$jscomp$inline_2348.isDisabled &&
            hook$jscomp$inline_2348.supportsFiber
          )
            try {
              (rendererID = hook$jscomp$inline_2348.inject(
                internals$jscomp$inline_2347,
              )),
                (injectedHook = hook$jscomp$inline_2348);
            } catch (err) {}
        }
        exports.createRoot = function (container, options) {
          if (!isValidContainer(container))
            throw Error(formatProdErrorMessage(299));
          var isStrictMode = !1,
            identifierPrefix = '',
            onUncaughtError = defaultOnUncaughtError,
            onCaughtError = defaultOnCaughtError,
            onRecoverableError = defaultOnRecoverableError;
          null !== options &&
            void 0 !== options &&
            (!0 === options.unstable_strictMode && (isStrictMode = !0),
            void 0 !== options.identifierPrefix &&
              (identifierPrefix = options.identifierPrefix),
            void 0 !== options.onUncaughtError &&
              (onUncaughtError = options.onUncaughtError),
            void 0 !== options.onCaughtError &&
              (onCaughtError = options.onCaughtError),
            void 0 !== options.onRecoverableError &&
              (onRecoverableError = options.onRecoverableError));
          options = createFiberRoot(
            container,
            1,
            !1,
            null,
            null,
            isStrictMode,
            identifierPrefix,
            null,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator,
          );
          container[internalContainerInstanceKey] = options.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMRoot(options);
        };
        exports.hydrateRoot = function (container, initialChildren, options) {
          if (!isValidContainer(container))
            throw Error(formatProdErrorMessage(299));
          var isStrictMode = !1,
            identifierPrefix = '',
            onUncaughtError = defaultOnUncaughtError,
            onCaughtError = defaultOnCaughtError,
            onRecoverableError = defaultOnRecoverableError,
            formState = null;
          null !== options &&
            void 0 !== options &&
            (!0 === options.unstable_strictMode && (isStrictMode = !0),
            void 0 !== options.identifierPrefix &&
              (identifierPrefix = options.identifierPrefix),
            void 0 !== options.onUncaughtError &&
              (onUncaughtError = options.onUncaughtError),
            void 0 !== options.onCaughtError &&
              (onCaughtError = options.onCaughtError),
            void 0 !== options.onRecoverableError &&
              (onRecoverableError = options.onRecoverableError),
            void 0 !== options.formState && (formState = options.formState));
          initialChildren = createFiberRoot(
            container,
            1,
            !0,
            initialChildren,
            null != options ? options : null,
            isStrictMode,
            identifierPrefix,
            formState,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator,
          );
          initialChildren.context = getContextForSubtree(null);
          options = initialChildren.current;
          isStrictMode = requestUpdateLane();
          isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
          identifierPrefix = createUpdate(isStrictMode);
          identifierPrefix.callback = null;
          enqueueUpdate(options, identifierPrefix, isStrictMode);
          options = isStrictMode;
          initialChildren.current.lanes = options;
          markRootUpdated$1(initialChildren, options);
          ensureRootIsScheduled(initialChildren);
          container[internalContainerInstanceKey] = initialChildren.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMHydrationRoot(initialChildren);
        };
        __webpack_unused_export__ = '19.2.0';

        /***/
      },

    /***/ '(client)/../../../../../Library/pnpm/store/v10/links/@/react-dom/19.2.0/09f8862f9cadb2790b70b94ddb646e94427b7be0ff242c2c964e8bf83ca4dd56/node_modules/react-dom/client.js':
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        function checkDCE() {
          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
          if (
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
          ) {
            return;
          }
          if (false) {
          }
          try {
            // Verify that the code above has been dead code eliminated (DCE'd).
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
          } catch (err) {
            // DevTools shouldn't crash React, no matter what.
            // We should still report in case we break this code.
            console.error(err);
          }
        }

        if (true) {
          // DCE check should happen before ReactDOM bundle executes so that
          // DevTools can report bad minification during injection.
          checkDCE();
          module.exports = __webpack_require__(
            '(client)/../../../../../Library/pnpm/store/v10/links/@/react-dom/19.2.0/09f8862f9cadb2790b70b94ddb646e94427b7be0ff242c2c964e8bf83ca4dd56/node_modules/react-dom/cjs/react-dom-client.production.js',
          );
        } else {
        }

        /***/
      },

    /***/ '(client)/../../../../../Library/pnpm/store/v10/links/@/react-error-boundary/3.1.4/d1b3100cfa3d9ab2d5020950bb3761d8ad5e329381f1fcdff9729b00d15faa13/node_modules/react-error-boundary/dist/react-error-boundary.umd.js':
      /***/ function (__unused_webpack_module, exports, __webpack_require__) {
        (function (global, factory) {
          true
            ? factory(
                exports,
                __webpack_require__(
                  '(client)/webpack/sharing/consume/client/react/react',
                ),
              )
            : 0;
        })(this, function (exports, React) {
          'use strict';

          function _interopNamespace(e) {
            if (e && e.__esModule) return e;
            var n = Object.create(null);
            if (e) {
              Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                  var d = Object.getOwnPropertyDescriptor(e, k);
                  Object.defineProperty(
                    n,
                    k,
                    d.get
                      ? d
                      : {
                          enumerable: true,
                          get: function () {
                            return e[k];
                          },
                        },
                  );
                }
              });
            }
            n['default'] = e;
            return Object.freeze(n);
          }

          var React__namespace = /*#__PURE__*/ _interopNamespace(React);

          function _setPrototypeOf(o, p) {
            _setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                o.__proto__ = p;
                return o;
              };

            return _setPrototypeOf(o, p);
          }

          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            _setPrototypeOf(subClass, superClass);
          }

          var changedArray = function changedArray(a, b) {
            if (a === void 0) {
              a = [];
            }

            if (b === void 0) {
              b = [];
            }

            return (
              a.length !== b.length ||
              a.some(function (item, index) {
                return !Object.is(item, b[index]);
              })
            );
          };

          var initialState = {
            error: null,
          };

          var ErrorBoundary = /*#__PURE__*/ (function (_React$Component) {
            _inheritsLoose(ErrorBoundary, _React$Component);

            function ErrorBoundary() {
              var _this;

              for (
                var _len = arguments.length, _args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                _args[_key] = arguments[_key];
              }

              _this =
                _React$Component.call.apply(
                  _React$Component,
                  [this].concat(_args),
                ) || this;
              _this.state = initialState;

              _this.resetErrorBoundary = function () {
                var _this$props;

                for (
                  var _len2 = arguments.length,
                    args = new Array(_len2),
                    _key2 = 0;
                  _key2 < _len2;
                  _key2++
                ) {
                  args[_key2] = arguments[_key2];
                }

                _this.props.onReset == null
                  ? void 0
                  : (_this$props = _this.props).onReset.apply(
                      _this$props,
                      args,
                    );

                _this.reset();
              };

              return _this;
            }

            ErrorBoundary.getDerivedStateFromError =
              function getDerivedStateFromError(error) {
                return {
                  error: error,
                };
              };

            var _proto = ErrorBoundary.prototype;

            _proto.reset = function reset() {
              this.setState(initialState);
            };

            _proto.componentDidCatch = function componentDidCatch(error, info) {
              var _this$props$onError, _this$props2;

              (_this$props$onError = (_this$props2 = this.props).onError) ==
              null
                ? void 0
                : _this$props$onError.call(_this$props2, error, info);
            };

            _proto.componentDidUpdate = function componentDidUpdate(
              prevProps,
              prevState,
            ) {
              var error = this.state.error;
              var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error
              // happens to *also* be in the resetKeys array, we'd end up resetting
              // the error boundary immediately. This would likely trigger a second
              // error to be thrown.
              // So we make sure that we don't check the resetKeys on the first call
              // of cDU after the error is set

              if (
                error !== null &&
                prevState.error !== null &&
                changedArray(prevProps.resetKeys, resetKeys)
              ) {
                var _this$props$onResetKe, _this$props3;

                (_this$props$onResetKe = (_this$props3 = this.props)
                  .onResetKeysChange) == null
                  ? void 0
                  : _this$props$onResetKe.call(
                      _this$props3,
                      prevProps.resetKeys,
                      resetKeys,
                    );
                this.reset();
              }
            };

            _proto.render = function render() {
              var error = this.state.error;
              var _this$props4 = this.props,
                fallbackRender = _this$props4.fallbackRender,
                FallbackComponent = _this$props4.FallbackComponent,
                fallback = _this$props4.fallback;

              if (error !== null) {
                var _props = {
                  error: error,
                  resetErrorBoundary: this.resetErrorBoundary,
                };

                if (/*#__PURE__*/ React__namespace.isValidElement(fallback)) {
                  return fallback;
                } else if (typeof fallbackRender === 'function') {
                  return fallbackRender(_props);
                } else if (FallbackComponent) {
                  return /*#__PURE__*/ React__namespace.createElement(
                    FallbackComponent,
                    _props,
                  );
                } else {
                  throw new Error(
                    'react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop',
                  );
                }
              }

              return this.props.children;
            };

            return ErrorBoundary;
          })(React__namespace.Component);

          function withErrorBoundary(Component, errorBoundaryProps) {
            var Wrapped = function Wrapped(props) {
              return /*#__PURE__*/ React__namespace.createElement(
                ErrorBoundary,
                errorBoundaryProps,
                /*#__PURE__*/ React__namespace.createElement(Component, props),
              );
            }; // Format for display in DevTools

            var name = Component.displayName || Component.name || 'Unknown';
            Wrapped.displayName = 'withErrorBoundary(' + name + ')';
            return Wrapped;
          }

          function useErrorHandler(givenError) {
            var _React$useState = React__namespace.useState(null),
              error = _React$useState[0],
              setError = _React$useState[1];

            if (givenError != null) throw givenError;
            if (error != null) throw error;
            return setError;
          }
          /*
  eslint
    @typescript-eslint/sort-type-union-intersection-members: "off",
    @typescript-eslint/no-throw-literal: "off",
    @typescript-eslint/prefer-nullish-coalescing: "off"
  */

          exports.ErrorBoundary = ErrorBoundary;
          exports.useErrorHandler = useErrorHandler;
          exports.withErrorBoundary = withErrorBoundary;

          Object.defineProperty(exports, '__esModule', { value: true });
        });
        //# sourceMappingURL=react-error-boundary.umd.js.map

        /***/
      },

    /***/ '(client)/../../../../../Library/pnpm/store/v10/links/@/react/19.2.0/a910955293fe48a2a8c542eb50a81385a2511b7ebc74d2fcc17e522c4b3a2f32/node_modules/react/cjs/react-jsx-runtime.production.js':
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        /**
         * @license React
         * react-jsx-runtime.production.js
         *
         * Copyright (c) Meta Platforms, Inc. and affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
          REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        function jsxProd(type, config, maybeKey) {
          var key = null;
          void 0 !== maybeKey && (key = '' + maybeKey);
          void 0 !== config.key && (key = '' + config.key);
          if ('key' in config) {
            maybeKey = {};
            for (var propName in config)
              'key' !== propName && (maybeKey[propName] = config[propName]);
          } else maybeKey = config;
          config = maybeKey.ref;
          return {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            ref: void 0 !== config ? config : null,
            props: maybeKey,
          };
        }
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsxProd;
        exports.jsxs = jsxProd;

        /***/
      },

    /***/ '(client)/../../../../../Library/pnpm/store/v10/links/@/react/19.2.0/a910955293fe48a2a8c542eb50a81385a2511b7ebc74d2fcc17e522c4b3a2f32/node_modules/react/jsx-runtime.js':
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        if (true) {
          module.exports = __webpack_require__(
            '(client)/../../../../../Library/pnpm/store/v10/links/@/react/19.2.0/a910955293fe48a2a8c542eb50a81385a2511b7ebc74d2fcc17e522c4b3a2f32/node_modules/react/cjs/react-jsx-runtime.production.js',
          );
        } else {
        }

        /***/
      },

    /***/ '(client)/../../../../../Library/pnpm/store/v10/links/@/scheduler/0.27.0/769e30ccb12382a7627d59e00e6d36ba15663a7c35f2c65f3934708e0b0ff464/node_modules/scheduler/cjs/scheduler.production.js':
      /***/ (__unused_webpack_module, exports) => {
        'use strict';
        /**
         * @license React
         * scheduler.production.js
         *
         * Copyright (c) Meta Platforms, Inc. and affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          a: for (; 0 < index; ) {
            var parentIndex = (index - 1) >>> 1,
              parent = heap[parentIndex];
            if (0 < compare(parent, node))
              (heap[parentIndex] = node),
                (heap[index] = parent),
                (index = parentIndex);
            else break a;
          }
        }
        function peek(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first = heap[0],
            last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            a: for (
              var index = 0, length = heap.length, halfLength = length >>> 1;
              index < halfLength;

            ) {
              var leftIndex = 2 * (index + 1) - 1,
                left = heap[leftIndex],
                rightIndex = leftIndex + 1,
                right = heap[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length && 0 > compare(right, left)
                  ? ((heap[index] = right),
                    (heap[rightIndex] = last),
                    (index = rightIndex))
                  : ((heap[index] = left),
                    (heap[leftIndex] = last),
                    (index = leftIndex));
              else if (rightIndex < length && 0 > compare(right, last))
                (heap[index] = right),
                  (heap[rightIndex] = last),
                  (index = rightIndex);
              else break a;
            }
          }
          return first;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        exports.unstable_now = void 0;
        if (
          'object' === typeof performance &&
          'function' === typeof performance.now
        ) {
          var localPerformance = performance;
          exports.unstable_now = function () {
            return localPerformance.now();
          };
        } else {
          var localDate = Date,
            initialTime = localDate.now();
          exports.unstable_now = function () {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [],
          timerQueue = [],
          taskIdCounter = 1,
          currentTask = null,
          currentPriorityLevel = 3,
          isPerformingWork = !1,
          isHostCallbackScheduled = !1,
          isHostTimeoutScheduled = !1,
          needsPaint = !1,
          localSetTimeout =
            'function' === typeof setTimeout ? setTimeout : null,
          localClearTimeout =
            'function' === typeof clearTimeout ? clearTimeout : null,
          localSetImmediate =
            'undefined' !== typeof setImmediate ? setImmediate : null;
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue),
                (timer.sortIndex = timer.expirationTime),
                push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = !1;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek(taskQueue))
              (isHostCallbackScheduled = !0),
                isMessageLoopRunning ||
                  ((isMessageLoopRunning = !0),
                  schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer &&
                requestHostTimeout(
                  handleTimeout,
                  firstTimer.startTime - currentTime,
                );
            }
        }
        var isMessageLoopRunning = !1,
          taskTimeoutID = -1,
          frameInterval = 5,
          startTime = -1;
        function shouldYieldToHost() {
          return needsPaint
            ? !0
            : exports.unstable_now() - startTime < frameInterval
              ? !1
              : !0;
        }
        function performWorkUntilDeadline() {
          needsPaint = !1;
          if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = !0;
            try {
              a: {
                isHostCallbackScheduled = !1;
                isHostTimeoutScheduled &&
                  ((isHostTimeoutScheduled = !1),
                  localClearTimeout(taskTimeoutID),
                  (taskTimeoutID = -1));
                isPerformingWork = !0;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (
                      currentTask = peek(taskQueue);
                      null !== currentTask &&
                      !(
                        currentTask.expirationTime > currentTime &&
                        shouldYieldToHost()
                      );

                    ) {
                      var callback = currentTask.callback;
                      if ('function' === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime,
                        );
                        currentTime = exports.unstable_now();
                        if ('function' === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = !0;
                          break b;
                        }
                        currentTask === peek(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = !0;
                    else {
                      var firstTimer = peek(timerQueue);
                      null !== firstTimer &&
                        requestHostTimeout(
                          handleTimeout,
                          firstTimer.startTime - currentTime,
                        );
                      hasMoreWork = !1;
                    }
                  }
                  break a;
                } finally {
                  (currentTask = null),
                    (currentPriorityLevel = previousPriorityLevel),
                    (isPerformingWork = !1);
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork
                ? schedulePerformWorkUntilDeadline()
                : (isMessageLoopRunning = !1);
            }
          }
        }
        var schedulePerformWorkUntilDeadline;
        if ('function' === typeof localSetImmediate)
          schedulePerformWorkUntilDeadline = function () {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ('undefined' !== typeof MessageChannel) {
          var channel = new MessageChannel(),
            port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function () {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function () {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function () {
            callback(exports.unstable_now());
          }, ms);
        }
        exports.unstable_IdlePriority = 5;
        exports.unstable_ImmediatePriority = 1;
        exports.unstable_LowPriority = 4;
        exports.unstable_NormalPriority = 3;
        exports.unstable_Profiling = null;
        exports.unstable_UserBlockingPriority = 2;
        exports.unstable_cancelCallback = function (task) {
          task.callback = null;
        };
        exports.unstable_forceFrameRate = function (fps) {
          0 > fps || 125 < fps
            ? console.error(
                'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported',
              )
            : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
        };
        exports.unstable_getCurrentPriorityLevel = function () {
          return currentPriorityLevel;
        };
        exports.unstable_next = function (eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_requestPaint = function () {
          needsPaint = !0;
        };
        exports.unstable_runWithPriority = function (
          priorityLevel,
          eventHandler,
        ) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_scheduleCallback = function (
          priorityLevel,
          callback,
          options,
        ) {
          var currentTime = exports.unstable_now();
          'object' === typeof options && null !== options
            ? ((options = options.delay),
              (options =
                'number' === typeof options && 0 < options
                  ? currentTime + options
                  : currentTime))
            : (options = currentTime);
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback: callback,
            priorityLevel: priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1,
          };
          options > currentTime
            ? ((priorityLevel.sortIndex = options),
              push(timerQueue, priorityLevel),
              null === peek(taskQueue) &&
                priorityLevel === peek(timerQueue) &&
                (isHostTimeoutScheduled
                  ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
                  : (isHostTimeoutScheduled = !0),
                requestHostTimeout(handleTimeout, options - currentTime)))
            : ((priorityLevel.sortIndex = timeout),
              push(taskQueue, priorityLevel),
              isHostCallbackScheduled ||
                isPerformingWork ||
                ((isHostCallbackScheduled = !0),
                isMessageLoopRunning ||
                  ((isMessageLoopRunning = !0),
                  schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = function (callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function () {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };

        /***/
      },

    /***/ '(client)/../../../../../Library/pnpm/store/v10/links/@/scheduler/0.27.0/769e30ccb12382a7627d59e00e6d36ba15663a7c35f2c65f3934708e0b0ff464/node_modules/scheduler/index.js':
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        'use strict';

        if (true) {
          module.exports = __webpack_require__(
            '(client)/../../../../../Library/pnpm/store/v10/links/@/scheduler/0.27.0/769e30ccb12382a7627d59e00e6d36ba15663a7c35f2c65f3934708e0b0ff464/node_modules/scheduler/cjs/scheduler.production.js',
          );
        } else {
        }

        /***/
      },

    /***/ '(client)/../../../packages/sdk/dist/index.esm.js': /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      'use strict';
      /* harmony export */ __webpack_require__.d(__webpack_exports__, {
        /* harmony export */ Au: () => /* binding */ isDebugMode,
        /* harmony export */ EW: () => /* binding */ createLink,
        /* harmony export */ M8: () => /* binding */ composeKeyWithSeparator,
        /* harmony export */ S5: () =>
          /* binding */ generateSnapshotFromManifest,
        /* harmony export */ UC: () => /* binding */ createLogger,
        /* harmony export */ WB: () => /* binding */ isReactNativeEnv,
        /* harmony export */ Xz: () => /* binding */ ENCODE_NAME_PREFIX,
        /* harmony export */ ZK: () => /* binding */ warn,
        /* harmony export */ cP: () => /* binding */ decodeName,
        /* harmony export */ hT: () => /* binding */ createScript,
        /* harmony export */ kP: () => /* binding */ isBrowserEnv,
        /* harmony export */ pv: () => /* binding */ safeToString,
        /* harmony export */ qN: () => /* binding */ loadScriptNode,
        /* harmony export */ vM: () => /* binding */ getResourceUrl,
        /* harmony export */ ve: () => /* binding */ loadScript,
        /* harmony export */ xw: () => /* binding */ isManifestProvider,
        /* harmony export */
      });
      /* unused harmony exports BROWSER_LOG_KEY, EncodedNameTransformMap, FederationModuleManifest, MANIFEST_EXT, MFModuleType, MFPrefetchCommon, MODULE_DEVTOOL_IDENTIFIER, ManifestFileName, NameTransformMap, NameTransformSymbol, SEPARATOR, StatsFileName, TEMP_DIR, assert, bindLoggerToCompiler, containerPlugin, containerReferencePlugin, createInfrastructureLogger, createModuleFederationConfig, createScriptNode, encodeName, error, generateExposeFilename, generateShareFilename, getManifestFileName, getProcessEnv, inferAutoPublicPath, infrastructureLogger, isRequiredVersion, isStaticResourcesEqual, logger, moduleFederationPlugin, normalizeOptions, parseEntry, safeWrapper, sharePlugin, simpleJoinRemoteEntry */
      const FederationModuleManifest = 'federation-manifest.json';
      const MANIFEST_EXT = '.json';
      const BROWSER_LOG_KEY = 'FEDERATION_DEBUG';
      const NameTransformSymbol = {
        AT: '@',
        HYPHEN: '-',
        SLASH: '/',
      };
      const NameTransformMap = {
        [NameTransformSymbol.AT]: 'scope_',
        [NameTransformSymbol.HYPHEN]: '_',
        [NameTransformSymbol.SLASH]: '__',
      };
      const EncodedNameTransformMap = {
        [NameTransformMap[NameTransformSymbol.AT]]: NameTransformSymbol.AT,
        [NameTransformMap[NameTransformSymbol.HYPHEN]]:
          NameTransformSymbol.HYPHEN,
        [NameTransformMap[NameTransformSymbol.SLASH]]:
          NameTransformSymbol.SLASH,
      };
      const SEPARATOR = ':';
      const ManifestFileName = 'mf-manifest.json';
      const StatsFileName = 'mf-stats.json';
      const MFModuleType = {
        NPM: 'npm',
        APP: 'app',
      };
      const MODULE_DEVTOOL_IDENTIFIER = '__MF_DEVTOOLS_MODULE_INFO__';
      const ENCODE_NAME_PREFIX = 'ENCODE_NAME_PREFIX';
      const TEMP_DIR = '.federation';
      const MFPrefetchCommon = {
        identifier: 'MFDataPrefetch',
        globalKey: '__PREFETCH__',
        library: 'mf-data-prefetch',
        exportsKey: '__PREFETCH_EXPORTS__',
        fileName: 'bootstrap.js',
      };
      var ContainerPlugin = /*#__PURE__*/ Object.freeze({
        __proto__: null,
      });
      var ContainerReferencePlugin = /*#__PURE__*/ Object.freeze({
        __proto__: null,
      });
      var ModuleFederationPlugin = /*#__PURE__*/ Object.freeze({
        __proto__: null,
      });
      var SharePlugin = /*#__PURE__*/ Object.freeze({
        __proto__: null,
      });
      function isBrowserEnv() {
        return (
          typeof window !== 'undefined' &&
          typeof window.document !== 'undefined'
        );
      }
      function isReactNativeEnv() {
        return (
          typeof navigator !== 'undefined' &&
          navigator?.product === 'ReactNative'
        );
      }
      function isBrowserDebug() {
        try {
          if (isBrowserEnv() && window.localStorage) {
            return Boolean(localStorage.getItem(BROWSER_LOG_KEY));
          }
        } catch (error) {
          return false;
        }
        return false;
      }
      function isDebugMode() {
        if (
          typeof process !== 'undefined' &&
          process.env &&
          process.env['FEDERATION_DEBUG']
        ) {
          return Boolean(process.env['FEDERATION_DEBUG']);
        }
        if (
          typeof FEDERATION_DEBUG !== 'undefined' &&
          Boolean(FEDERATION_DEBUG)
        ) {
          return true;
        }
        return isBrowserDebug();
      }
      const getProcessEnv = function () {
        return typeof process !== 'undefined' && process.env ? process.env : {};
      };
      const LOG_CATEGORY = '[ Federation Runtime ]';
      // entry: name:version   version : 1.0.0 | ^1.2.3
      // entry: name:entry  entry:  https://localhost:9000/federation-manifest.json
      const parseEntry = (str, devVerOrUrl, separator = SEPARATOR) => {
        const strSplit = str.split(separator);
        const devVersionOrUrl =
          getProcessEnv()['NODE_ENV'] === 'development' && devVerOrUrl;
        const defaultVersion = '*';
        const isEntry = (s) => s.startsWith('http') || s.includes(MANIFEST_EXT);
        // Check if the string starts with a type
        if (strSplit.length >= 2) {
          let [name, ...versionOrEntryArr] = strSplit;
          // @name@manifest-url.json
          if (str.startsWith(separator)) {
            name = strSplit.slice(0, 2).join(separator);
            versionOrEntryArr = [
              devVersionOrUrl || strSplit.slice(2).join(separator),
            ];
          }
          let versionOrEntry =
            devVersionOrUrl || versionOrEntryArr.join(separator);
          if (isEntry(versionOrEntry)) {
            return {
              name,
              entry: versionOrEntry,
            };
          } else {
            // Apply version rule
            // devVersionOrUrl => inputVersion => defaultVersion
            return {
              name,
              version: versionOrEntry || defaultVersion,
            };
          }
        } else if (strSplit.length === 1) {
          const [name] = strSplit;
          if (devVersionOrUrl && isEntry(devVersionOrUrl)) {
            return {
              name,
              entry: devVersionOrUrl,
            };
          }
          return {
            name,
            version: devVersionOrUrl || defaultVersion,
          };
        } else {
          throw `Invalid entry value: ${str}`;
        }
      };
      const composeKeyWithSeparator = function (...args) {
        if (!args.length) {
          return '';
        }
        return args.reduce((sum, cur) => {
          if (!cur) {
            return sum;
          }
          if (!sum) {
            return cur;
          }
          return `${sum}${SEPARATOR}${cur}`;
        }, '');
      };
      const encodeName = function (name, prefix = '', withExt = false) {
        try {
          const ext = withExt ? '.js' : '';
          return `${prefix}${name
            .replace(
              new RegExp(`${NameTransformSymbol.AT}`, 'g'),
              NameTransformMap[NameTransformSymbol.AT],
            )
            .replace(
              new RegExp(`${NameTransformSymbol.HYPHEN}`, 'g'),
              NameTransformMap[NameTransformSymbol.HYPHEN],
            )
            .replace(
              new RegExp(`${NameTransformSymbol.SLASH}`, 'g'),
              NameTransformMap[NameTransformSymbol.SLASH],
            )}${ext}`;
        } catch (err) {
          throw err;
        }
      };
      const decodeName = function (name, prefix, withExt) {
        try {
          let decodedName = name;
          if (prefix) {
            if (!decodedName.startsWith(prefix)) {
              return decodedName;
            }
            decodedName = decodedName.replace(new RegExp(prefix, 'g'), '');
          }
          decodedName = decodedName
            .replace(
              new RegExp(`${NameTransformMap[NameTransformSymbol.AT]}`, 'g'),
              EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.AT]],
            )
            .replace(
              new RegExp(`${NameTransformMap[NameTransformSymbol.SLASH]}`, 'g'),
              EncodedNameTransformMap[
                NameTransformMap[NameTransformSymbol.SLASH]
              ],
            )
            .replace(
              new RegExp(
                `${NameTransformMap[NameTransformSymbol.HYPHEN]}`,
                'g',
              ),
              EncodedNameTransformMap[
                NameTransformMap[NameTransformSymbol.HYPHEN]
              ],
            );
          if (withExt) {
            decodedName = decodedName.replace('.js', '');
          }
          return decodedName;
        } catch (err) {
          throw err;
        }
      };
      const generateExposeFilename = (exposeName, withExt) => {
        if (!exposeName) {
          return '';
        }
        let expose = exposeName;
        if (expose === '.') {
          expose = 'default_export';
        }
        if (expose.startsWith('./')) {
          expose = expose.replace('./', '');
        }
        return encodeName(expose, '__federation_expose_', withExt);
      };
      const generateShareFilename = (pkgName, withExt) => {
        if (!pkgName) {
          return '';
        }
        return encodeName(pkgName, '__federation_shared_', withExt);
      };
      const getResourceUrl = (module, sourceUrl) => {
        if ('getPublicPath' in module) {
          let publicPath;
          if (!module.getPublicPath.startsWith('function')) {
            publicPath = new Function(module.getPublicPath)();
          } else {
            publicPath = new Function('return ' + module.getPublicPath)()();
          }
          return `${publicPath}${sourceUrl}`;
        } else if ('publicPath' in module) {
          if (
            !isBrowserEnv() &&
            !isReactNativeEnv() &&
            typeof module.ssrPublicPath === 'string' &&
            module.ssrPublicPath.length > 0
          ) {
            return `${module.ssrPublicPath}${sourceUrl}`;
          }
          return `${module.publicPath}${sourceUrl}`;
        } else {
          console.warn(
            'Cannot get resource URL. If in debug mode, please ignore.',
            module,
            sourceUrl,
          );
          return '';
        }
      };
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      const assert = (condition, msg) => {
        if (!condition) {
          error(msg);
        }
      };
      const error = (msg) => {
        throw new Error(`${LOG_CATEGORY}: ${msg}`);
      };
      const warn = (msg) => {
        console.warn(`${LOG_CATEGORY}: ${msg}`);
      };
      function safeToString(info) {
        try {
          return JSON.stringify(info, null, 2);
        } catch (e) {
          return '';
        }
      }
      // RegExp for version string
      const VERSION_PATTERN_REGEXP = /^([\d^=v<>~]|[*xX]$)/;
      function isRequiredVersion(str) {
        return VERSION_PATTERN_REGEXP.test(str);
      }
      const simpleJoinRemoteEntry = (rPath, rName) => {
        if (!rPath) {
          return rName;
        }
        const transformPath = (str) => {
          if (str === '.') {
            return '';
          }
          if (str.startsWith('./')) {
            return str.replace('./', '');
          }
          if (str.startsWith('/')) {
            const strWithoutSlash = str.slice(1);
            if (strWithoutSlash.endsWith('/')) {
              return strWithoutSlash.slice(0, -1);
            }
            return strWithoutSlash;
          }
          return str;
        };
        const transformedPath = transformPath(rPath);
        if (!transformedPath) {
          return rName;
        }
        if (transformedPath.endsWith('/')) {
          return `${transformedPath}${rName}`;
        }
        return `${transformedPath}/${rName}`;
      };
      function inferAutoPublicPath(url) {
        return url
          .replace(/#.*$/, '')
          .replace(/\?.*$/, '')
          .replace(/\/[^\/]+$/, '/');
      }
      // Priority: overrides > remotes
      // eslint-disable-next-line max-lines-per-function
      function generateSnapshotFromManifest(manifest, options = {}) {
        const { remotes = {}, overrides = {}, version } = options;
        let remoteSnapshot;
        const getPublicPath = () => {
          if ('publicPath' in manifest.metaData) {
            if (manifest.metaData.publicPath === 'auto' && version) {
              // use same implementation as publicPath auto runtime module implements
              return inferAutoPublicPath(version);
            }
            return manifest.metaData.publicPath;
          } else {
            return manifest.metaData.getPublicPath;
          }
        };
        const overridesKeys = Object.keys(overrides);
        let remotesInfo = {};
        // If remotes are not provided, only the remotes in the manifest will be read
        if (!Object.keys(remotes).length) {
          remotesInfo =
            manifest.remotes?.reduce((res, next) => {
              let matchedVersion;
              const name = next.federationContainerName;
              // overrides have higher priority
              if (overridesKeys.includes(name)) {
                matchedVersion = overrides[name];
              } else {
                if ('version' in next) {
                  matchedVersion = next.version;
                } else {
                  matchedVersion = next.entry;
                }
              }
              res[name] = {
                matchedVersion,
              };
              return res;
            }, {}) || {};
        }
        // If remotes (deploy scenario) are specified, they need to be traversed again
        Object.keys(remotes).forEach(
          (key) =>
            (remotesInfo[key] = {
              // overrides will override dependencies
              matchedVersion: overridesKeys.includes(key)
                ? overrides[key]
                : remotes[key],
            }),
        );
        const {
          remoteEntry: {
            path: remoteEntryPath,
            name: remoteEntryName,
            type: remoteEntryType,
          },
          types: remoteTypes = {
            path: '',
            name: '',
            zip: '',
            api: '',
          },
          buildInfo: { buildVersion },
          globalName,
          ssrRemoteEntry,
        } = manifest.metaData;
        const { exposes } = manifest;
        let basicRemoteSnapshot = {
          version: version ? version : '',
          buildVersion,
          globalName,
          remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),
          remoteEntryType,
          remoteTypes: simpleJoinRemoteEntry(
            remoteTypes.path,
            remoteTypes.name,
          ),
          remoteTypesZip: remoteTypes.zip || '',
          remoteTypesAPI: remoteTypes.api || '',
          remotesInfo,
          shared: manifest?.shared.map((item) => ({
            assets: item.assets,
            sharedName: item.name,
            version: item.version,
            // @ts-ignore
            usedExports: item.referenceExports || [],
          })),
          modules: exposes?.map((expose) => ({
            moduleName: expose.name,
            modulePath: expose.path,
            assets: expose.assets,
          })),
        };
        if (manifest.metaData?.prefetchInterface) {
          const prefetchInterface = manifest.metaData.prefetchInterface;
          basicRemoteSnapshot = {
            ...basicRemoteSnapshot,
            prefetchInterface,
          };
        }
        if (manifest.metaData?.prefetchEntry) {
          const { path, name, type } = manifest.metaData.prefetchEntry;
          basicRemoteSnapshot = {
            ...basicRemoteSnapshot,
            prefetchEntry: simpleJoinRemoteEntry(path, name),
            prefetchEntryType: type,
          };
        }
        if ('publicPath' in manifest.metaData) {
          remoteSnapshot = {
            ...basicRemoteSnapshot,
            publicPath: getPublicPath(),
            ssrPublicPath: manifest.metaData.ssrPublicPath,
          };
        } else {
          remoteSnapshot = {
            ...basicRemoteSnapshot,
            getPublicPath: getPublicPath(),
          };
        }
        if (ssrRemoteEntry) {
          const fullSSRRemoteEntry = simpleJoinRemoteEntry(
            ssrRemoteEntry.path,
            ssrRemoteEntry.name,
          );
          remoteSnapshot.ssrRemoteEntry = fullSSRRemoteEntry;
          remoteSnapshot.ssrRemoteEntryType =
            ssrRemoteEntry.type || 'commonjs-module';
        }
        return remoteSnapshot;
      }
      function isManifestProvider(moduleInfo) {
        if (
          'remoteEntry' in moduleInfo &&
          moduleInfo.remoteEntry.includes(MANIFEST_EXT)
        ) {
          return true;
        } else {
          return false;
        }
      }
      function getManifestFileName(manifestOptions) {
        if (!manifestOptions) {
          return {
            statsFileName: StatsFileName,
            manifestFileName: ManifestFileName,
          };
        }
        let filePath =
          typeof manifestOptions === 'boolean'
            ? ''
            : manifestOptions.filePath || '';
        let fileName =
          typeof manifestOptions === 'boolean'
            ? ''
            : manifestOptions.fileName || '';
        const JSON_EXT = '.json';
        const addExt = (name) => {
          if (name.endsWith(JSON_EXT)) {
            return name;
          }
          return `${name}${JSON_EXT}`;
        };
        const insertSuffix = (name, suffix) => {
          return name.replace(JSON_EXT, `${suffix}${JSON_EXT}`);
        };
        const manifestFileName = fileName ? addExt(fileName) : ManifestFileName;
        const statsFileName = fileName
          ? insertSuffix(manifestFileName, '-stats')
          : StatsFileName;
        return {
          statsFileName: simpleJoinRemoteEntry(filePath, statsFileName),
          manifestFileName: simpleJoinRemoteEntry(filePath, manifestFileName),
        };
      }
      const PREFIX = '[ Module Federation ]';
      const DEFAULT_DELEGATE = console;
      const LOGGER_STACK_SKIP_TOKENS = [
        'logger.ts',
        'logger.js',
        'captureStackTrace',
        'Logger.emit',
        'Logger.log',
        'Logger.info',
        'Logger.warn',
        'Logger.error',
        'Logger.debug',
      ];
      function captureStackTrace() {
        try {
          const stack = new Error().stack;
          if (!stack) {
            return undefined;
          }
          const [, ...rawLines] = stack.split('\n');
          const filtered = rawLines.filter(
            (line) =>
              !LOGGER_STACK_SKIP_TOKENS.some((token) => line.includes(token)),
          );
          if (!filtered.length) {
            return undefined;
          }
          const stackPreview = filtered.slice(0, 5).join('\n');
          return `Stack trace:\n${stackPreview}`;
        } catch {
          return undefined;
        }
      }
      class Logger {
        constructor(prefix, delegate = DEFAULT_DELEGATE) {
          this.prefix = prefix;
          this.delegate = delegate ?? DEFAULT_DELEGATE;
        }
        setPrefix(prefix) {
          this.prefix = prefix;
        }
        setDelegate(delegate) {
          this.delegate = delegate ?? DEFAULT_DELEGATE;
        }
        emit(method, args) {
          const delegate = this.delegate;
          const debugMode = isDebugMode();
          const stackTrace = debugMode ? captureStackTrace() : undefined;
          const enrichedArgs = stackTrace ? [...args, stackTrace] : args;
          const order = (() => {
            switch (method) {
              case 'log':
                return ['log', 'info'];
              case 'info':
                return ['info', 'log'];
              case 'warn':
                return ['warn', 'info', 'log'];
              case 'error':
                return ['error', 'warn', 'log'];
              case 'debug':
              default:
                return ['debug', 'log'];
            }
          })();
          for (const candidate of order) {
            const handler = delegate[candidate];
            if (typeof handler === 'function') {
              handler.call(delegate, this.prefix, ...enrichedArgs);
              return;
            }
          }
          for (const candidate of order) {
            const handler = DEFAULT_DELEGATE[candidate];
            if (typeof handler === 'function') {
              handler.call(DEFAULT_DELEGATE, this.prefix, ...enrichedArgs);
              return;
            }
          }
        }
        log(...args) {
          this.emit('log', args);
        }
        warn(...args) {
          this.emit('warn', args);
        }
        error(...args) {
          this.emit('error', args);
        }
        success(...args) {
          this.emit('info', args);
        }
        info(...args) {
          this.emit('info', args);
        }
        ready(...args) {
          this.emit('info', args);
        }
        debug(...args) {
          if (isDebugMode()) {
            this.emit('debug', args);
          }
        }
      }
      function createLogger(prefix) {
        return new Logger(prefix);
      }
      function createInfrastructureLogger(prefix) {
        const infrastructureLogger = new Logger(prefix);
        Object.defineProperty(
          infrastructureLogger,
          '__mf_infrastructure_logger__',
          {
            value: true,
            enumerable: false,
            configurable: false,
          },
        );
        return infrastructureLogger;
      }
      function bindLoggerToCompiler(loggerInstance, compiler, name) {
        if (!loggerInstance.__mf_infrastructure_logger__) {
          return;
        }
        if (!compiler?.getInfrastructureLogger) {
          return;
        }
        try {
          const infrastructureLogger = compiler.getInfrastructureLogger(name);
          if (
            infrastructureLogger &&
            typeof infrastructureLogger === 'object' &&
            (typeof infrastructureLogger.log === 'function' ||
              typeof infrastructureLogger.info === 'function' ||
              typeof infrastructureLogger.warn === 'function' ||
              typeof infrastructureLogger.error === 'function')
          ) {
            loggerInstance.setDelegate(infrastructureLogger);
          }
        } catch {
          // If the bundler throws (older versions), fall back to default console logger.
          loggerInstance.setDelegate(undefined);
        }
      }
      const logger = createLogger(PREFIX);
      const infrastructureLogger = createInfrastructureLogger(PREFIX);

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      async function safeWrapper(callback, disableWarn) {
        try {
          const res = await callback();
          return res;
        } catch (e) {
          !disableWarn && warn(e);
          return;
        }
      }
      function isStaticResourcesEqual(url1, url2) {
        const REG_EXP = /^(https?:)?\/\//i;
        // Transform url1 and url2 into relative paths
        const relativeUrl1 = url1.replace(REG_EXP, '').replace(/\/$/, '');
        const relativeUrl2 = url2.replace(REG_EXP, '').replace(/\/$/, '');
        // Check if the relative paths are identical
        return relativeUrl1 === relativeUrl2;
      }
      function createScript(info) {
        // Retrieve the existing script element by its src attribute
        let script = null;
        let needAttach = true;
        let timeout = 20000;
        let timeoutId;
        const scripts = document.getElementsByTagName('script');
        for (let i = 0; i < scripts.length; i++) {
          const s = scripts[i];
          const scriptSrc = s.getAttribute('src');
          if (scriptSrc && isStaticResourcesEqual(scriptSrc, info.url)) {
            script = s;
            needAttach = false;
            break;
          }
        }
        if (!script) {
          const attrs = info.attrs;
          script = document.createElement('script');
          script.type =
            attrs?.['type'] === 'module' ? 'module' : 'text/javascript';
          let createScriptRes = undefined;
          if (info.createScriptHook) {
            createScriptRes = info.createScriptHook(info.url, info.attrs);
            if (createScriptRes instanceof HTMLScriptElement) {
              script = createScriptRes;
            } else if (typeof createScriptRes === 'object') {
              if ('script' in createScriptRes && createScriptRes.script) {
                script = createScriptRes.script;
              }
              if ('timeout' in createScriptRes && createScriptRes.timeout) {
                timeout = createScriptRes.timeout;
              }
            }
          }
          if (!script.src) {
            script.src = info.url;
          }
          if (attrs && !createScriptRes) {
            Object.keys(attrs).forEach((name) => {
              if (script) {
                if (name === 'async' || name === 'defer') {
                  script[name] = attrs[name];
                  // Attributes that do not exist are considered overridden
                } else if (!script.getAttribute(name)) {
                  script.setAttribute(name, attrs[name]);
                }
              }
            });
          }
        }
        const onScriptComplete = async (
          prev,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          event,
        ) => {
          clearTimeout(timeoutId);
          const onScriptCompleteCallback = () => {
            if (event?.type === 'error') {
              info?.onErrorCallback && info?.onErrorCallback(event);
            } else {
              info?.cb && info?.cb();
            }
          };
          // Prevent memory leaks in IE.
          if (script) {
            script.onerror = null;
            script.onload = null;
            safeWrapper(() => {
              const { needDeleteScript = true } = info;
              if (needDeleteScript) {
                script?.parentNode && script.parentNode.removeChild(script);
              }
            });
            if (prev && typeof prev === 'function') {
              const result = prev(event);
              if (result instanceof Promise) {
                const res = await result;
                onScriptCompleteCallback();
                return res;
              }
              onScriptCompleteCallback();
              return result;
            }
          }
          onScriptCompleteCallback();
        };
        script.onerror = onScriptComplete.bind(null, script.onerror);
        script.onload = onScriptComplete.bind(null, script.onload);
        timeoutId = setTimeout(() => {
          onScriptComplete(
            null,
            new Error(`Remote script "${info.url}" time-outed.`),
          );
        }, timeout);
        return {
          script,
          needAttach,
        };
      }
      function createLink(info) {
        // <link rel="preload" href="script.js" as="script">
        // Retrieve the existing script element by its src attribute
        let link = null;
        let needAttach = true;
        const links = document.getElementsByTagName('link');
        for (let i = 0; i < links.length; i++) {
          const l = links[i];
          const linkHref = l.getAttribute('href');
          const linkRel = l.getAttribute('rel');
          if (
            linkHref &&
            isStaticResourcesEqual(linkHref, info.url) &&
            linkRel === info.attrs['rel']
          ) {
            link = l;
            needAttach = false;
            break;
          }
        }
        if (!link) {
          link = document.createElement('link');
          link.setAttribute('href', info.url);
          let createLinkRes = undefined;
          const attrs = info.attrs;
          if (info.createLinkHook) {
            createLinkRes = info.createLinkHook(info.url, attrs);
            if (createLinkRes instanceof HTMLLinkElement) {
              link = createLinkRes;
            }
          }
          if (attrs && !createLinkRes) {
            Object.keys(attrs).forEach((name) => {
              if (link && !link.getAttribute(name)) {
                link.setAttribute(name, attrs[name]);
              }
            });
          }
        }
        const onLinkComplete = (
          prev,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          event,
        ) => {
          const onLinkCompleteCallback = () => {
            if (event?.type === 'error') {
              info?.onErrorCallback && info?.onErrorCallback(event);
            } else {
              info?.cb && info?.cb();
            }
          };
          // Prevent memory leaks in IE.
          if (link) {
            link.onerror = null;
            link.onload = null;
            safeWrapper(() => {
              const { needDeleteLink = true } = info;
              if (needDeleteLink) {
                link?.parentNode && link.parentNode.removeChild(link);
              }
            });
            if (prev) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const res = prev(event);
              onLinkCompleteCallback();
              return res;
            }
          }
          onLinkCompleteCallback();
        };
        link.onerror = onLinkComplete.bind(null, link.onerror);
        link.onload = onLinkComplete.bind(null, link.onload);
        return {
          link,
          needAttach,
        };
      }
      function loadScript(url, info) {
        const { attrs = {}, createScriptHook } = info;
        return new Promise((resolve, reject) => {
          const { script, needAttach } = createScript({
            url,
            cb: resolve,
            onErrorCallback: reject,
            attrs: {
              fetchpriority: 'high',
              ...attrs,
            },
            createScriptHook,
            needDeleteScript: true,
          });
          needAttach && document.head.appendChild(script);
        });
      }
      const sdkImportCache = new Map();
      function importNodeModule(name) {
        if (!name) {
          throw new Error('import specifier is required');
        }
        // Check cache to prevent infinite recursion
        if (sdkImportCache.has(name)) {
          return sdkImportCache.get(name);
        }
        const importModule = new Function('name', `return import(name)`);
        const promise = importModule(name)
          .then((res) => res)
          .catch((error) => {
            console.error(`Error importing module ${name}:`, error);
            // Remove from cache on error so it can be retried
            sdkImportCache.delete(name);
            throw error;
          });
        // Cache the promise to prevent recursive calls
        sdkImportCache.set(name, promise);
        return promise;
      }
      const loadNodeFetch = async () => {
        const fetchModule = await importNodeModule('node-fetch');
        return fetchModule.default || fetchModule;
      };
      const lazyLoaderHookFetch = async (input, init, loaderHook) => {
        const hook = (url, init) => {
          return loaderHook.lifecycle.fetch.emit(url, init);
        };
        const res = await hook(input, init || {});
        if (!res || !(res instanceof Response)) {
          const fetchFunction =
            typeof fetch === 'undefined' ? await loadNodeFetch() : fetch;
          return fetchFunction(input, init || {});
        }
        return res;
      };
      const createScriptNode =
        typeof ENV_TARGET === 'undefined' || ENV_TARGET !== 'web'
          ? (url, cb, attrs, loaderHook) => {
              if (loaderHook?.createScriptHook) {
                const hookResult = loaderHook.createScriptHook(url);
                if (
                  hookResult &&
                  typeof hookResult === 'object' &&
                  'url' in hookResult
                ) {
                  url = hookResult.url;
                }
              }
              let urlObj;
              try {
                urlObj = new URL(url);
              } catch (e) {
                console.error('Error constructing URL:', e);
                cb(new Error(`Invalid URL: ${e}`));
                return;
              }
              const getFetch = async () => {
                if (loaderHook?.fetch) {
                  return (input, init) =>
                    lazyLoaderHookFetch(input, init, loaderHook);
                }
                return typeof fetch === 'undefined' ? loadNodeFetch() : fetch;
              };
              const handleScriptFetch = async (f, urlObj) => {
                try {
                  const res = await f(urlObj.href);
                  const data = await res.text();
                  const [path, vm] = await Promise.all([
                    importNodeModule('path'),
                    importNodeModule('vm'),
                  ]);
                  const scriptContext = {
                    exports: {},
                    module: {
                      exports: {},
                    },
                  };
                  const urlDirname = urlObj.pathname
                    .split('/')
                    .slice(0, -1)
                    .join('/');
                  const filename = path.basename(urlObj.pathname);
                  const script = new vm.Script(
                    `(function(exports, module, require, __dirname, __filename) {${data}\n})`,
                    {
                      filename,
                      importModuleDynamically:
                        //@ts-ignore
                        vm.constants?.USE_MAIN_CONTEXT_DEFAULT_LOADER ??
                        importNodeModule,
                    },
                  );
                  script.runInThisContext()(
                    scriptContext.exports,
                    scriptContext.module,
                    eval('require'),
                    urlDirname,
                    filename,
                  );
                  const exportedInterface =
                    scriptContext.module.exports || scriptContext.exports;
                  if (attrs && exportedInterface && attrs['globalName']) {
                    const container =
                      exportedInterface[attrs['globalName']] ||
                      exportedInterface;
                    cb(undefined, container);
                    return;
                  }
                  cb(undefined, exportedInterface);
                } catch (e) {
                  cb(
                    e instanceof Error
                      ? e
                      : new Error(`Script execution error: ${e}`),
                  );
                }
              };
              getFetch()
                .then(async (f) => {
                  if (
                    attrs?.['type'] === 'esm' ||
                    attrs?.['type'] === 'module'
                  ) {
                    return loadModule(urlObj.href, {
                      fetch: f,
                      vm: await importNodeModule('vm'),
                    })
                      .then(async (module) => {
                        await module.evaluate();
                        cb(undefined, module.namespace);
                      })
                      .catch((e) => {
                        cb(
                          e instanceof Error
                            ? e
                            : new Error(`Script execution error: ${e}`),
                        );
                      });
                  }
                  handleScriptFetch(f, urlObj);
                })
                .catch((err) => {
                  cb(err);
                });
            }
          : (url, cb, attrs, loaderHook) => {
              cb(
                new Error(
                  'createScriptNode is disabled in non-Node.js environment',
                ),
              );
            };
      const loadScriptNode =
        typeof ENV_TARGET === 'undefined' || ENV_TARGET !== 'web'
          ? (url, info) => {
              return new Promise((resolve, reject) => {
                createScriptNode(
                  url,
                  (error, scriptContext) => {
                    if (error) {
                      reject(error);
                    } else {
                      const remoteEntryKey =
                        info?.attrs?.['globalName'] ||
                        `__FEDERATION_${info?.attrs?.['name']}:custom__`;
                      const entryExports = (globalThis[remoteEntryKey] =
                        scriptContext);
                      resolve(entryExports);
                    }
                  },
                  info.attrs,
                  info.loaderHook,
                );
              });
            }
          : (url, info) => {
              throw new Error(
                'loadScriptNode is disabled in non-Node.js environment',
              );
            };
      const esmModuleCache = new Map();
      async function loadModule(url, options) {
        // Check cache to prevent infinite recursion in ESM loading
        if (esmModuleCache.has(url)) {
          return esmModuleCache.get(url);
        }
        const { fetch, vm } = options;
        const response = await fetch(url);
        const code = await response.text();
        const module = new vm.SourceTextModule(code, {
          // @ts-ignore
          importModuleDynamically: async (specifier, script) => {
            const resolvedUrl = new URL(specifier, url).href;
            return loadModule(resolvedUrl, options);
          },
        });
        // Cache the module before linking to prevent cycles
        esmModuleCache.set(url, module);
        await module.link(async (specifier) => {
          const resolvedUrl = new URL(specifier, url).href;
          const module = await loadModule(resolvedUrl, options);
          return module;
        });
        return module;
      }
      function normalizeOptions(enableDefault, defaultOptions, key) {
        return function (options) {
          if (options === false) {
            return false;
          }
          if (typeof options === 'undefined') {
            if (enableDefault) {
              return defaultOptions;
            } else {
              return false;
            }
          }
          if (options === true) {
            return defaultOptions;
          }
          if (options && typeof options === 'object') {
            return {
              ...defaultOptions,
              ...options,
            };
          }
          throw new Error(
            `Unexpected type for \`${key}\`, expect boolean/undefined/object, got: ${typeof options}`,
          );
        };
      }
      const createModuleFederationConfig = (options) => {
        return options;
      };

      /***/
    },

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ // no module.id needed
      /******/ // no module.loaded needed
      /******/ exports: {},
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ var execOptions = {
      id: moduleId,
      module: module,
      factory: __webpack_modules__[moduleId],
      require: __webpack_require__,
    };
    /******/ __webpack_require__.i.forEach(function (handler) {
      handler(execOptions);
    });
    /******/ module = execOptions.module;
    /******/ execOptions.factory.call(
      module.exports,
      module,
      module.exports,
      execOptions.require,
    );
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /******/ // expose the modules object (__webpack_modules__)
  /******/ __webpack_require__.m = __webpack_modules__;
  /******/
  /******/ // expose the module cache
  /******/ __webpack_require__.c = __webpack_module_cache__;
  /******/
  /******/ // expose the module execution interceptor
  /******/ __webpack_require__.i = [];
  /******/
  /******/ // the startup function
  /******/ __webpack_require__.x = (x) => {};
  /************************************************************************/
  /******/ /* webpack/runtime/federation runtime */
  /******/ (() => {
    /******/ if (!__webpack_require__.federation) {
      /******/ __webpack_require__.federation = {
        /******/ initOptions: {
          name: 'app2',
          remotes: [
            {
              alias: 'app1',
              name: 'app1',
              entry: 'http://localhost:4101/remoteEntry.client.js',
              shareScope: ['default', 'client'],
              externalType: 'script',
            },
          ],
          shareStrategy: 'version-first',
        },
        /******/ chunkMatcher: function (chunkId) {
          return (
            '_client_webpack_sharing_consume_client_react_react' != chunkId
          );
        },
        /******/ rootOutputDir: '',
        /******/ bundlerRuntimeOptions: {
          remotes: {
            remoteInfos: {
              app1: [
                {
                  alias: 'app1',
                  name: 'app1',
                  entry: 'http://localhost:4101/remoteEntry.client.js',
                  shareScope: ['default', 'client'],
                  externalType: 'script',
                },
              ],
            },
            webpackRequire: __webpack_require__,
            idToRemoteMap: {},
            chunkMapping: {},
            idToExternalAndNameMapping: {},
          },
        },
        /******/
      };
      /******/ __webpack_require__.consumesLoadingData = {};
      /******/ __webpack_require__.remotesLoadingData = {};
      /******/
    }
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/compat get default export */
  /******/ (() => {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = (module) => {
      /******/ var getter =
        module && module.__esModule
          ? /******/ () => module['default']
          : /******/ () => module;
      /******/ __webpack_require__.d(getter, { a: getter });
      /******/ return getter;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (
          __webpack_require__.o(definition, key) &&
          !__webpack_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key],
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/ensure chunk */
  /******/ (() => {
    /******/ __webpack_require__.f = {};
    /******/ // This file contains only the entry chunk.
    /******/ // The chunk loading function for additional chunks
    /******/ __webpack_require__.e = (chunkId) => {
      /******/ return Promise.all(
        Object.keys(__webpack_require__.f).reduce((promises, key) => {
          /******/ __webpack_require__.f[key](chunkId, promises);
          /******/ return promises;
          /******/
        }, []),
      );
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/get javascript chunk filename */
  /******/ (() => {
    /******/ // This function allow to reference async chunks and sibling chunks for the entrypoint
    /******/ __webpack_require__.u = (chunkId) => {
      /******/ // return url for filenames based on template
      /******/ return '' + chunkId + '.js';
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/global */
  /******/ (() => {
    /******/ __webpack_require__.g = (function () {
      /******/ if (typeof globalThis === 'object') return globalThis;
      /******/ try {
        /******/ return this || new Function('return this')();
        /******/
      } catch (e) {
        /******/ if (typeof window === 'object') return window;
        /******/
      }
      /******/
    })();
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __webpack_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/load script */
  /******/ (() => {
    /******/ var inProgress = {};
    /******/ var dataWebpackPrefix = 'app2:';
    /******/ // loadScript function to load a script via script tag
    /******/ __webpack_require__.l = (url, done, key, chunkId) => {
      /******/ if (inProgress[url]) {
        inProgress[url].push(done);
        return;
      }
      /******/ var script, needAttach;
      /******/ if (key !== undefined) {
        /******/ var scripts = document.getElementsByTagName('script');
        /******/ for (var i = 0; i < scripts.length; i++) {
          /******/ var s = scripts[i];
          /******/ if (
            s.getAttribute('src') == url ||
            s.getAttribute('data-webpack') == dataWebpackPrefix + key
          ) {
            script = s;
            break;
          }
          /******/
        }
        /******/
      }
      /******/ if (!script) {
        /******/ needAttach = true;
        /******/ script = document.createElement('script');
        /******/
        /******/ script.charset = 'utf-8';
        /******/ script.timeout = 120;
        /******/ if (__webpack_require__.nc) {
          /******/ script.setAttribute('nonce', __webpack_require__.nc);
          /******/
        }
        /******/ script.setAttribute('data-webpack', dataWebpackPrefix + key);
        /******/ script.src = url;
        /******/
      }
      /******/ inProgress[url] = [done];
      /******/ var onScriptComplete = (prev, event) => {
        /******/ // avoid mem leaks in IE.
        /******/ script.onerror = script.onload = null;
        /******/ clearTimeout(timeout);
        /******/ var doneFns = inProgress[url];
        /******/ delete inProgress[url];
        /******/ script.parentNode && script.parentNode.removeChild(script);
        /******/ doneFns && doneFns.forEach((fn) => fn(event));
        /******/ if (prev) return prev(event);
        /******/
      };
      /******/ var timeout = setTimeout(
        onScriptComplete.bind(null, undefined, {
          type: 'timeout',
          target: script,
        }),
        120000,
      );
      /******/ script.onerror = onScriptComplete.bind(null, script.onerror);
      /******/ script.onload = onScriptComplete.bind(null, script.onload);
      /******/ needAttach && document.head.appendChild(script);
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = (exports) => {
      /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module',
        });
        /******/
      }
      /******/ Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/remotes loading */
  /******/ (() => {
    /******/ var chunkMapping = {
      /******/ client14: [
        /******/ 'webpack/container/remote/app1/HostBadge',
        /******/
      ],
      /******/
    };
    /******/ var idToExternalAndNameMapping = {
      /******/ 'webpack/container/remote/app1/HostBadge': [
        /******/ [
          /******/ 'default',
          /******/ 'client',
          /******/
        ],
        /******/ './HostBadge',
        /******/ 'webpack/container/reference/app1',
        /******/
      ],
      /******/
    };
    /******/ var idToRemoteMap = {
      /******/ 'webpack/container/remote/app1/HostBadge': [
        /******/ {
          /******/ externalType: 'script',
          /******/ name: 'app1',
          /******/
        },
        /******/
      ],
      /******/
    };
    /******/ __webpack_require__.federation.bundlerRuntimeOptions.remotes.chunkMapping =
      chunkMapping;
    /******/ __webpack_require__.federation.bundlerRuntimeOptions.remotes.idToExternalAndNameMapping =
      idToExternalAndNameMapping;
    /******/ __webpack_require__.federation.bundlerRuntimeOptions.remotes.idToRemoteMap =
      idToRemoteMap;
    /******/ __webpack_require__.remotesLoadingData.moduleIdToRemoteDataMapping =
      {
        /******/ 'webpack/container/remote/app1/HostBadge': {
          /******/ shareScope: [
            /******/ 'default',
            /******/ 'client',
            /******/
          ],
          /******/ name: './HostBadge',
          /******/ externalModuleId: 'webpack/container/reference/app1',
          /******/ remoteName: 'app1',
          /******/
        },
        /******/
      };
    /******/ __webpack_require__.f.remotes = (chunkId, promises) => {
      /******/ __webpack_require__.federation.bundlerRuntime.remotes({
        idToRemoteMap,
        chunkMapping,
        idToExternalAndNameMapping,
        chunkId,
        promises,
        webpackRequire: __webpack_require__,
      });
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/sharing */
  /******/ (() => {
    /******/ __webpack_require__.S = {};
    /******/ var initPromises = {};
    /******/ var initTokens = {};
    /******/ __webpack_require__.I = (name, initScope) => {
      /******/ if (!initScope) initScope = [];
      /******/ // handling circular init calls
      /******/ var initToken = initTokens[name];
      /******/ if (!initToken) initToken = initTokens[name] = {};
      /******/ if (initScope.indexOf(initToken) >= 0) return;
      /******/ initScope.push(initToken);
      /******/ // only runs once
      /******/ if (initPromises[name]) return initPromises[name];
      /******/ // creates a new share scope if needed
      /******/ if (!__webpack_require__.o(__webpack_require__.S, name))
        __webpack_require__.S[name] = {};
      /******/ // runs all init snippets from all modules reachable
      /******/ var scope = __webpack_require__.S[name];
      /******/ var warn = (msg) =>
        typeof console !== 'undefined' && console.warn && console.warn(msg);
      /******/ var uniqueName = 'app2';
      /******/ var register = (name, version, factory, eager) => {
        /******/ var versions = (scope[name] = scope[name] || {});
        /******/ var activeVersion = versions[version];
        /******/ if (
          !activeVersion ||
          (!activeVersion.loaded &&
            (!eager != !activeVersion.eager
              ? eager
              : uniqueName > activeVersion.from))
        )
          versions[version] = {
            get: factory,
            from: uniqueName,
            eager: !!eager,
          };
        /******/
      };
      /******/ var initExternal = (id) => {
        /******/ var handleError = (err) =>
          warn('Initialization of sharing external failed: ' + err);
        /******/ try {
          /******/ var module = __webpack_require__(id);
          /******/ if (!module) return;
          /******/ var initFn = (module) =>
            module &&
            module.init &&
            module.init(__webpack_require__.S[name], initScope);
          /******/ if (module.then)
            return promises.push(module.then(initFn, handleError));
          /******/ var initResult = initFn(module);
          /******/ if (initResult && initResult.then)
            return promises.push(initResult['catch'](handleError));
          /******/
        } catch (err) {
          handleError(err);
        }
        /******/
      };
      /******/ var promises = [];
      /******/ switch (name) {
        /******/ case 'client':
          {
            /******/ register('react-dom', '19.2.0', () =>
              Promise.all([
                __webpack_require__.e(
                  '_client_webpack_sharing_consume_client_react_react',
                ),
                __webpack_require__.e(
                  '_client_Library_pnpm_store_v10_links_react-dom_19_2_0_09f8862f9cadb2790b70b94ddb646e94427b7be-bfa05a',
                ),
              ]).then(
                () => () =>
                  __webpack_require__(
                    '(client)/../../../../../Library/pnpm/store/v10/links/@/react-dom/19.2.0/09f8862f9cadb2790b70b94ddb646e94427b7be0ff242c2c964e8bf83ca4dd56/node_modules/react-dom/index.js',
                  ),
              ),
            );
            /******/ register('react', '19.2.0', () =>
              __webpack_require__
                .e(
                  '_client_Library_pnpm_store_v10_links_react_19_2_0_a910955293fe48a2a8c542eb50a81385a2511b7ebc7-35b261',
                )
                .then(
                  () => () =>
                    __webpack_require__(
                      '(client)/../../../../../Library/pnpm/store/v10/links/@/react/19.2.0/a910955293fe48a2a8c542eb50a81385a2511b7ebc74d2fcc17e522c4b3a2f32/node_modules/react/index.js',
                    ),
                ),
            );
            /******/
          }
          /******/ break;
        /******/ case ['default', 'client']:
          {
            /******/ initExternal('webpack/container/reference/app1');
            /******/
          }
          /******/ break;
        /******/
      }
      /******/ if (!promises.length) return (initPromises[name] = 1);
      /******/ return (initPromises[name] = Promise.all(promises).then(
        () => (initPromises[name] = 1),
      ));
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/startup entrypoint */
  /******/ (() => {
    /******/ __webpack_require__.X = (result, chunkIds, fn) => {
      /******/ // arguments: chunkIds, moduleId are deprecated
      /******/ var moduleId = chunkIds;
      /******/ if (!fn)
        (chunkIds = result),
          (fn = () => __webpack_require__((__webpack_require__.s = moduleId)));
      /******/ return Promise.all(
        chunkIds.map(__webpack_require__.e, __webpack_require__),
      ).then(() => {
        /******/ var r = fn();
        /******/ return r === undefined ? result : r;
        /******/
      });
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/sharing */
  /******/ (() => {
    /******/ __webpack_require__.federation.initOptions.shared = {
      'react-dom': [
        {
          version: '19.2.0',
          /******/ get: () =>
            Promise.all([
              __webpack_require__.e(
                '_client_webpack_sharing_consume_client_react_react',
              ),
              __webpack_require__.e(
                '_client_Library_pnpm_store_v10_links_react-dom_19_2_0_09f8862f9cadb2790b70b94ddb646e94427b7be-bfa05a',
              ),
            ]).then(
              () => () =>
                __webpack_require__(
                  '(client)/../../../../../Library/pnpm/store/v10/links/@/react-dom/19.2.0/09f8862f9cadb2790b70b94ddb646e94427b7be0ff242c2c964e8bf83ca4dd56/node_modules/react-dom/index.js',
                ),
            ),
          /******/ scope: ['client'],
          /******/ shareConfig: {
            eager: false,
            requiredVersion: false,
            singleton: true,
            layer: 'client',
          },
          /******/
        },
      ],
      react: [
        {
          version: '19.2.0',
          /******/ get: () =>
            __webpack_require__
              .e(
                '_client_Library_pnpm_store_v10_links_react_19_2_0_a910955293fe48a2a8c542eb50a81385a2511b7ebc7-35b261',
              )
              .then(
                () => () =>
                  __webpack_require__(
                    '(client)/../../../../../Library/pnpm/store/v10/links/@/react/19.2.0/a910955293fe48a2a8c542eb50a81385a2511b7ebc74d2fcc17e522c4b3a2f32/node_modules/react/index.js',
                  ),
              ),
          /******/ scope: ['client'],
          /******/ shareConfig: {
            eager: false,
            requiredVersion: false,
            singleton: true,
            layer: 'client',
          },
          /******/
        },
      ],
    };
    /******/ __webpack_require__.S = {};
    /******/ var initPromises = {};
    /******/ var initTokens = {};
    /******/ __webpack_require__.I = (name, initScope) => {
      /******/ return __webpack_require__.federation.bundlerRuntime.I({
        shareScopeName: name,
        /******/ webpackRequire: __webpack_require__,
        /******/ initPromises: initPromises,
        /******/ initTokens: initTokens,
        /******/ initScope: initScope,
        /******/
      });
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/publicPath */
  /******/ (() => {
    /******/ var scriptUrl;
    /******/ if (__webpack_require__.g.importScripts)
      scriptUrl = __webpack_require__.g.location + '';
    /******/ var document = __webpack_require__.g.document;
    /******/ if (!scriptUrl && document) {
      /******/ if (document.currentScript)
        /******/ scriptUrl = document.currentScript.src;
      /******/ if (!scriptUrl) {
        /******/ var scripts = document.getElementsByTagName('script');
        /******/ if (scripts.length)
          scriptUrl = scripts[scripts.length - 1].src;
        /******/
      }
      /******/
    }
    /******/ // When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
    /******/ // or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
    /******/ if (!scriptUrl)
      throw new Error('Automatic publicPath is not supported in this browser');
    /******/ scriptUrl = scriptUrl
      .replace(/#.*$/, '')
      .replace(/\?.*$/, '')
      .replace(/\/[^\/]+$/, '/');
    /******/ __webpack_require__.p = scriptUrl;
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/consumes */
  /******/ (() => {
    /******/ var installedModules = {};
    /******/ __webpack_require__.consumesLoadingData.moduleIdToConsumeDataMapping =
      {
        /******/ '(client)/webpack/sharing/consume/client/react/react': {
          /******/ fallback: () =>
            __webpack_require__
              .e(
                '_client_Library_pnpm_store_v10_links_react_19_2_0_a910955293fe48a2a8c542eb50a81385a2511b7ebc7-35b261',
              )
              .then(
                () => () =>
                  __webpack_require__(
                    '(client)/../../../../../Library/pnpm/store/v10/links/@/react/19.2.0/a910955293fe48a2a8c542eb50a81385a2511b7ebc74d2fcc17e522c4b3a2f32/node_modules/react/index.js',
                  ),
              ),
          /******/ shareScope: ['client'],
          /******/ singleton: true,
          /******/ requiredVersion: false,
          /******/ strictVersion: false,
          /******/ eager: false,
          /******/ layer: 'client',
          /******/ shareKey: 'react',
          /******/
          /******/
        },
        /******/ '(client)/webpack/sharing/consume/client/react-dom/react-dom':
          {
            /******/ fallback: () =>
              Promise.all([
                __webpack_require__.e(
                  '_client_webpack_sharing_consume_client_react_react',
                ),
                __webpack_require__.e(
                  '_client_Library_pnpm_store_v10_links_react-dom_19_2_0_09f8862f9cadb2790b70b94ddb646e94427b7be-bfa05a',
                ),
              ]).then(
                () => () =>
                  __webpack_require__(
                    '(client)/../../../../../Library/pnpm/store/v10/links/@/react-dom/19.2.0/09f8862f9cadb2790b70b94ddb646e94427b7be0ff242c2c964e8bf83ca4dd56/node_modules/react-dom/index.js',
                  ),
              ),
            /******/ shareScope: ['client'],
            /******/ singleton: true,
            /******/ requiredVersion: false,
            /******/ strictVersion: false,
            /******/ eager: false,
            /******/ layer: 'client',
            /******/ shareKey: 'react-dom',
            /******/
            /******/
          },
        /******/
      };
    /******/ var moduleToHandlerMapping = {};
    /******/ __webpack_require__.consumesLoadingData.initialConsumes = [
      '(client)/webpack/sharing/consume/client/react/react',
      '(client)/webpack/sharing/consume/client/react-dom/react-dom',
    ];
    /******/ __webpack_require__.federation.installInitialConsumes = (
      options,
    ) =>
      __webpack_require__.federation.bundlerRuntime.installInitialConsumes({
        /******/ initialConsumes:
          __webpack_require__.consumesLoadingData.initialConsumes,
        /******/ installedModules: installedModules,
        /******/ moduleToHandlerMapping,
        /******/ webpackRequire: __webpack_require__,
        /******/ asyncLoad:
          typeof options === 'object' ? options.asyncLoad : undefined,
        /******/
      });
    /******/ __webpack_require__.consumesLoadingData.chunkMapping = {
      /******/ main: [
        /******/ '(client)/webpack/sharing/consume/client/react/react',
        /******/ '(client)/webpack/sharing/consume/client/react-dom/react-dom',
        /******/
      ],
      /******/ _client_webpack_sharing_consume_client_react_react: [
        /******/ '(client)/webpack/sharing/consume/client/react/react',
        /******/
      ],
      /******/
    };
    /******/ __webpack_require__.f.consumes = (chunkId, promises) => {
      /******/ __webpack_require__.federation.bundlerRuntime.consumes({
        /******/ chunkMapping:
          __webpack_require__.consumesLoadingData.chunkMapping,
        /******/ installedModules: installedModules,
        /******/ chunkId: chunkId,
        /******/ moduleToHandlerMapping,
        /******/ promises: promises,
        /******/ webpackRequire: __webpack_require__,
        /******/
      });
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/embed/federation */
  /******/ (() => {
    /******/ var prevStartup = __webpack_require__.x;
    /******/ var hasRun = false;
    /******/ __webpack_require__.x = () => {
      /******/ if (!hasRun) {
        /******/ hasRun = true;
        /******/ __webpack_require__(
          './node_modules/.federation/entry.cf3c121db0a10666d8c94d6c149b9b19.js',
        );
        /******/
      }
      /******/ if (typeof prevStartup === 'function') {
        /******/ return prevStartup();
        /******/
      } else {
        /******/ console.warn(
          '[Module Federation] prevStartup is not a function, skipping startup execution',
        );
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/jsonp chunk loading */
  /******/ (() => {
    /******/ // no baseURI
    /******/
    /******/ // object to store loaded and loading chunks
    /******/ // undefined = chunk not loaded, null = chunk preloaded/prefetched
    /******/ // [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
    /******/ var installedChunks = {
      /******/ main: 0,
      /******/ client1: 0,
      /******/ __federation_expose_server_actions: 0,
      /******/ _client_webpack_sharing_consume_client_react_react: 0,
      /******/
    };
    /******/
    /******/ __webpack_require__.f.j = (chunkId, promises) => {
      /******/ // JSONP chunk loading for javascript
      /******/ var installedChunkData = __webpack_require__.o(
        installedChunks,
        chunkId,
      )
        ? installedChunks[chunkId]
        : undefined;
      /******/ if (installedChunkData !== 0) {
        // 0 means "already installed".
        /******/
        /******/ // a Promise means "currently loading".
        /******/ if (installedChunkData) {
          /******/ promises.push(installedChunkData[2]);
          /******/
        } else {
          /******/ if (
            '_client_webpack_sharing_consume_client_react_react' != chunkId
          ) {
            /******/ // setup Promise in chunk cache
            /******/ var promise = new Promise(
              (resolve, reject) =>
                (installedChunkData = installedChunks[chunkId] =
                  [resolve, reject]),
            );
            /******/ promises.push((installedChunkData[2] = promise));
            /******/
            /******/ // start chunk loading
            /******/ var url =
              __webpack_require__.p + __webpack_require__.u(chunkId);
            /******/ // create error before stack unwound to get useful stacktrace later
            /******/ var error = new Error();
            /******/ var loadingEnded = (event) => {
              /******/ if (__webpack_require__.o(installedChunks, chunkId)) {
                /******/ installedChunkData = installedChunks[chunkId];
                /******/ if (installedChunkData !== 0)
                  installedChunks[chunkId] = undefined;
                /******/ if (installedChunkData) {
                  /******/ var errorType =
                    event && (event.type === 'load' ? 'missing' : event.type);
                  /******/ var realSrc =
                    event && event.target && event.target.src;
                  /******/ error.message =
                    'Loading chunk ' +
                    chunkId +
                    ' failed.\n(' +
                    errorType +
                    ': ' +
                    realSrc +
                    ')';
                  /******/ error.name = 'ChunkLoadError';
                  /******/ error.type = errorType;
                  /******/ error.request = realSrc;
                  /******/ installedChunkData[1](error);
                  /******/
                }
                /******/
              }
              /******/
            };
            /******/ __webpack_require__.l(
              url,
              loadingEnded,
              'chunk-' + chunkId,
              chunkId,
            );
            /******/
          } else installedChunks[chunkId] = 0;
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
    /******/ // no prefetching
    /******/
    /******/ // no preloaded
    /******/
    /******/ // no HMR
    /******/
    /******/ // no HMR manifest
    /******/
    /******/ // no on chunks loaded
    /******/
    /******/ // install a JSONP callback for chunk loading
    /******/ var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
      /******/ var [chunkIds, moreModules, runtime] = data;
      /******/ // add "moreModules" to the modules object,
      /******/ // then flag all "chunkIds" as loaded and fire callback
      /******/ var moduleId,
        chunkId,
        i = 0;
      /******/ if (chunkIds.some((id) => installedChunks[id] !== 0)) {
        /******/ for (moduleId in moreModules) {
          /******/ if (__webpack_require__.o(moreModules, moduleId)) {
            /******/ __webpack_require__.m[moduleId] = moreModules[moduleId];
            /******/
          }
          /******/
        }
        /******/ if (runtime) var result = runtime(__webpack_require__);
        /******/
      }
      /******/ if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);
      /******/ for (; i < chunkIds.length; i++) {
        /******/ chunkId = chunkIds[i];
        /******/ if (
          __webpack_require__.o(installedChunks, chunkId) &&
          installedChunks[chunkId]
        ) {
          /******/ installedChunks[chunkId][0]();
          /******/
        }
        /******/ installedChunks[chunkId] = 0;
        /******/
      }
      /******/
      /******/
    };
    /******/
    /******/ var chunkLoadingGlobal = (self['webpackChunkapp2'] =
      self['webpackChunkapp2'] || []);
    /******/ chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
    /******/ chunkLoadingGlobal.push = webpackJsonpCallback.bind(
      null,
      chunkLoadingGlobal.push.bind(chunkLoadingGlobal),
    );
    /******/
  })();
  /******/
  /************************************************************************/
  /******/ // run runtime startup
  /******/ __webpack_require__.x();
  /******/ var __webpack_exec__ = (moduleId) =>
    __webpack_require__((__webpack_require__.s = moduleId));
  /******/
  /******/
  /******/
  /******/ var promises = [];
  /******/ if (typeof __webpack_require__.x === 'function') {
    /******/ __webpack_require__.x();
    /******/
  } else {
    /******/ console.warn(
      '[Module Federation] __webpack_require__.x is not a function, skipping startup extension',
    );
    /******/
  }
  /******/ var __webpack_exports__ = Promise.all(
    [
      /******/ __webpack_require__.f.consumes ||
        function (chunkId, promises) {},
      /******/ __webpack_require__.f.remotes || function (chunkId, promises) {},
      /******/
    ].reduce((p, handler) => (handler('main', p), p), promises),
    /******/
  ).then(() =>
    __webpack_require__.X(0, [], () =>
      __webpack_exec__('(client)/../framework/framework/bootstrap.js'),
    ),
  );
  /******/
  /******/
})();
//# sourceMappingURL=main.js.map
