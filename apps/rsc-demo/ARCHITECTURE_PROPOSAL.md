# Module Federation Native RSC Architecture

## Executive Summary

This document proposes a unified architecture that leverages Module Federation's runtime, manifest system, and plugin hooks to solve RSC's SSR module resolution challenges without manual component maps or HTTP-based server action forwarding.

---

## Core Design Principles

1. **Single Source of Truth**: Extend `mf-manifest.json` to include RSC metadata
2. **Runtime Plugin Resolution**: Use MF runtime plugins to resolve client components during SSR
3. **In-Process Server Actions**: Load remote server actions via MF instead of HTTP forwarding
4. **Automatic Discovery**: No manual componentMap - derive from manifest at runtime
5. **Shared React Singleton**: Leverage MF share scope for React version consistency

---

## Architecture Components

### 1. Extended Manifest Schema

Extend `mf-manifest.json` via the `additionalData` hook to include RSC-specific data:

```typescript
// New manifest structure
interface RSCManifest extends Manifest {
  rsc: {
    // Which layer this manifest represents
    layer: 'client' | 'rsc' | 'ssr';

    // Client component registry (replaces react-client-manifest.json)
    clientComponents: {
      [exposePath: string]: {
        // Webpack module ID for SSR resolution
        moduleId: string;
        // Chunk files for client-side loading
        chunks: string[];
        // Export names
        exports: ('default' | '*' | string)[];
        // Original file path (for debugging)
        filePath: string;
      };
    };

    // Server actions registry (replaces react-server-actions-manifest.json)
    serverActions: {
      [actionId: string]: {
        // MF module path to import
        modulePath: string;
        // Export name
        exportName: string;
        // Is async action
        async: boolean;
      };
    };

    // For federated apps - remote RSC metadata
    remoteRSC?: {
      [remoteName: string]: {
        // URL to fetch remote's RSC manifest
        manifestUrl: string;
        // Server actions endpoint (fallback)
        actionsEndpoint: string;
        // Remote server container for direct MF loading
        serverEntry: string;
      };
    };
  };
}
```

### 2. Build-Time: Manifest Generation

Extend the webpack build to embed RSC data into MF manifest:

```javascript
// In build.js - client layer config
new ModuleFederationPlugin({
  name: 'app1',
  exposes: {
    './Button': './src/Button.js',
    './Counter': './src/DemoCounterButton.js',
  },
  manifest: {
    additionalData: async ({ stats, compiler, compilation }) => {
      // Read the react-client-manifest generated by ReactServerWebpackPlugin
      const clientManifest = JSON.parse(
        compilation.assets['react-client-manifest.json'].source()
      );

      // Transform to our format
      const clientComponents = {};
      for (const [filePath, entry] of Object.entries(clientManifest)) {
        // Map file path to expose path if it matches
        const exposePath = findExposePathForFile(stats.exposes, filePath);
        if (exposePath) {
          clientComponents[exposePath] = {
            moduleId: entry.id,
            chunks: entry.chunks,
            exports: [entry.name],
            filePath: filePath.replace('file://', ''),
          };
        }
      }

      // Attach to stats
      stats.rsc = {
        layer: 'client',
        clientComponents,
        serverActions: {}, // Client layer doesn't have actions
      };

      return stats;
    },
  },
});
```

### 3. Runtime Plugin: SSR Component Resolution

Create an MF runtime plugin that replaces the manual componentMap:

```javascript
// packages/app-shared/plugins/rscSSRResolverPlugin.js
import { FederationRuntimePlugin } from '@module-federation/runtime';

export function rscSSRResolverPlugin(): FederationRuntimePlugin {
  // Cache for loaded component modules
  const componentCache = new Map();

  // Registry built from manifest
  let componentRegistry = null;

  return {
    name: 'rsc-ssr-resolver-plugin',

    // Hook into initialization to load manifest
    async init(args) {
      const { options, origin } = args;

      // Load our own manifest
      const manifestUrl = `${options.remotes?.__PUBLIC_PATH__ || ''}/mf-manifest.json`;
      const manifest = await fetch(manifestUrl).then(r => r.json());

      // Build component registry from manifest
      if (manifest.rsc?.clientComponents) {
        componentRegistry = manifest.rsc.clientComponents;

        // Setup global webpack_require resolver for SSR
        setupSSRResolver(componentRegistry, origin);
      }

      return args;
    },

    // Hook into remote manifest loading
    async loadSnapshot(args) {
      const { manifestJson, remote } = args;

      // When loading a remote's manifest, also capture its RSC data
      if (manifestJson.rsc?.clientComponents) {
        // Merge remote's components into our registry with namespace
        for (const [path, component] of Object.entries(manifestJson.rsc.clientComponents)) {
          const namespacedPath = `${remote.name}/${path.replace('./', '')}`;
          componentRegistry[namespacedPath] = {
            ...component,
            // Mark as remote for special loading
            remote: remote.name,
          };
        }
      }

      return args;
    },

    // Hook into module loading for server actions
    async onLoad(args) {
      const { id, module, origin } = args;

      // Check if this is a server-actions module
      if (id.includes('server-actions') && args.exposeKey) {
        // Register all actions from this module
        const actionManifest = await fetchRemoteActionManifest(origin, args.remote);
        registerServerActionsFromManifest(actionManifest, module);
      }

      return args;
    },
  };
}

// SSR Resolver Setup
function setupSSRResolver(registry, federationHost) {
  // Replace the manual componentMap approach with manifest-driven resolution
  globalThis.__webpack_require__ = function(moduleId) {
    // Check cache first
    if (componentCache.has(moduleId)) {
      return componentCache.get(moduleId);
    }

    // Parse the module ID to find component
    // Format: "(client)/./src/Component.js" or "(client)/../remote/src/Component.js"
    const match = moduleId.match(/\(client\)\/(.+)/);
    const relativePath = match ? match[1] : moduleId;

    // Find in registry by path matching
    for (const [exposePath, component] of Object.entries(registry)) {
      if (component.filePath.endsWith(relativePath) ||
          component.moduleId === moduleId) {

        // Load the actual module
        let resolvedModule;

        if (component.remote) {
          // Remote component - use MF loadRemote
          resolvedModule = federationHost.loadRemote(
            `${component.remote}/${exposePath.replace('./', '')}`
          );
        } else {
          // Local component - use webpack require
          resolvedModule = __non_webpack_require__(
            `./build/client/${getChunkForComponent(component)}`
          );
        }

        componentCache.set(moduleId, resolvedModule);
        return resolvedModule;
      }
    }

    // Fallback for truly missing components
    console.warn(`RSC SSR: Component not found in manifest: ${moduleId}`);
    return { default: () => null };
  };

  // Chunk loading for SSR (no-op since we pre-resolve)
  globalThis.__webpack_chunk_load__ = () => Promise.resolve();
}
```

### 4. Server Actions: In-Process MF Loading

Replace HTTP forwarding with direct MF module loading:

```javascript
// packages/app-shared/plugins/rscServerActionsPlugin.js
import { FederationRuntimePlugin } from '@module-federation/runtime';
import { registerServerReference } from 'react-server-dom-webpack/server';

// Global registry for all server actions (local + remote)
const serverActionRegistry = new Map();

export function rscServerActionsPlugin(): FederationRuntimePlugin {
  return {
    name: 'rsc-server-actions-plugin',

    // When a remote's server-actions module is loaded via MF
    async onLoad(args) {
      const { id, module, exposeInfo } = args;

      // Detect server-actions expose
      if (exposeInfo?.name === './server-actions' || id.includes('server-actions')) {
        const remote = args.remoteInfo;

        // Fetch the remote's server actions manifest
        const manifestUrl = remote.rsc?.serverActionsManifest ||
          `${remote.entry.replace('remoteEntry.js', '')}react-server-actions-manifest.json`;

        const actionsManifest = await fetch(manifestUrl).then(r => r.json());

        // Register each action from the manifest
        for (const [actionId, actionDef] of Object.entries(actionsManifest)) {
          const actionFn = module[actionDef.name];
          if (typeof actionFn === 'function') {
            // Register with React's server reference system
            registerServerReference(
              actionFn,
              actionId,
              actionDef.name
            );

            // Also store in our registry for direct access
            serverActionRegistry.set(actionId, {
              fn: actionFn,
              remote: remote.name,
              async: actionDef.async ?? true,
            });
          }
        }

        console.log(`[RSC] Registered ${Object.keys(actionsManifest).length} actions from ${remote.name}`);
      }

      return args;
    },
  };
}

// Unified action getter - works for local and remote actions
export function getServerAction(actionId) {
  // Check our unified registry first
  if (serverActionRegistry.has(actionId)) {
    return serverActionRegistry.get(actionId).fn;
  }

  // Fallback to global registry (for local actions)
  if (globalThis.__RSC_SERVER_ACTION_REGISTRY__?.[actionId]) {
    return globalThis.__RSC_SERVER_ACTION_REGISTRY__[actionId];
  }

  throw new Error(`Server action not found: ${actionId}`);
}
```

### 5. SSR Entry: Manifest-Driven (No Manual Imports)

Replace the manual componentMap with manifest-driven resolution:

```javascript
// src/framework/ssr-entry.js - NEW VERSION
import { createFromNodeStream } from 'react-server-dom-webpack/client.node';
import { renderToPipeableStream } from 'react-dom/server';
import { init as initFederation } from '@module-federation/runtime';
import { rscSSRResolverPlugin } from '@rsc-demo/app-shared/plugins/rscSSRResolverPlugin';

// Initialize MF with our RSC plugin
const federation = initFederation({
  name: 'app1_ssr',
  remotes: [
    {
      name: 'app2',
      entry: 'http://localhost:4102/remoteEntry.server.js',
    },
  ],
  plugins: [
    rscSSRResolverPlugin(),
  ],
});

// Wait for federation to initialize (loads manifests, sets up resolvers)
await federation.ready;

// SSR Manifest is built dynamically from MF manifest
function buildSSRManifest() {
  const moduleMap = {};

  // Get component registry from our plugin
  const registry = federation.getPluginData('rsc-ssr-resolver-plugin', 'componentRegistry');

  for (const [exposePath, component] of Object.entries(registry)) {
    moduleMap[component.moduleId] = {
      default: { id: component.moduleId, name: 'default', chunks: [] },
      '*': { id: component.moduleId, name: '*', chunks: [] },
      '': { id: component.moduleId, name: '', chunks: [] },
    };
  }

  return {
    moduleLoading: { prefix: '', crossOrigin: null },
    moduleMap,
    serverModuleMap: null,
  };
}

export async function renderFlightToHTML(flightBuffer, clientManifest) {
  // Build SSR manifest from MF manifest data (no manual componentMap!)
  const ssrManifest = buildSSRManifest();

  // Create stream from flight buffer
  const { Readable } = await import('stream');
  const flightStream = Readable.from([flightBuffer]);

  // Deserialize the React tree
  const tree = await createFromNodeStream(flightStream, ssrManifest);

  // Render to HTML
  return new Promise((resolve, reject) => {
    let html = '';
    const { pipe } = renderToPipeableStream(tree, {
      onShellReady() {
        pipe({
          write: (chunk) => { html += chunk.toString(); },
          end: () => resolve(html),
        });
      },
      onShellError: reject,
      onError: (err) => console.error('SSR streaming error:', err),
    });
  });
}
```

### 6. API Server: Unified Action Handling

```javascript
// server/api.server.js - Updated POST handler
import { init as initFederation } from '@module-federation/runtime';
import { rscServerActionsPlugin, getServerAction } from '@rsc-demo/app-shared/plugins/rscServerActionsPlugin';

// Initialize federation with server actions plugin
const federation = initFederation({
  name: 'app1_rsc',
  remotes: [
    {
      name: 'app2',
      entry: 'http://localhost:4102/remoteEntry.server.js',
    },
  ],
  plugins: [
    rscServerActionsPlugin(),
  ],
});

// Preload remote server actions
async function preloadRemoteActions() {
  // This triggers the onLoad hook which registers actions
  await federation.loadRemote('app2/server-actions');
}

// Unified action handler - no HTTP forwarding needed
app.post('/react', async (req, res) => {
  const actionId = req.headers['rsc-action'];

  // Ensure remote actions are loaded
  await preloadRemoteActions();

  // Get action from unified registry (local or remote)
  const action = getServerAction(actionId);

  if (!action) {
    return res.status(404).json({ error: `Action not found: ${actionId}` });
  }

  // Decode arguments
  const args = await decodeReply(req.body);

  // Execute action (works for both local and remote!)
  const result = await action(...args);

  // Re-render and stream
  const rscBuffer = await renderRSCToBuffer({ ...currentProps });
  streamFlightResponse(res, rscBuffer);
});
```

---

## Benefits of This Architecture

| Benefit | Description |
|---------|-------------|
| **No Manual componentMap** | Components auto-discovered from manifest |
| **Unified Manifest** | Single source of truth for MF + RSC data |
| **In-Process Actions** | Remote actions loaded via MF, no HTTP hop |
| **Type Safety** | Manifest can generate TypeScript types |
| **Dynamic Discovery** | New remotes auto-register their components |
| **Version Safety** | MF share scope ensures React singleton |
| **Preloading** | Can prefetch remote chunks based on manifest |
| **Error Handling** | MF's `errorLoadRemote` hook provides fallbacks |

---

## Implementation Phases

### Phase 1: Manifest Extension (Build-Time)
1. Extend `additionalData` hook to embed RSC client manifest
2. Embed server actions manifest in mf-manifest.json
3. Add remote RSC metadata URLs

### Phase 2: SSR Resolution Plugin (Runtime)
1. Create `rscSSRResolverPlugin`
2. Replace manual componentMap with manifest-driven resolution
3. Handle remote component loading via MF

### Phase 3: Server Actions Plugin (Runtime)
1. Create `rscServerActionsPlugin`
2. Auto-register actions on remote module load
3. Remove HTTP forwarding code

### Phase 4: Cleanup
1. Remove react-client-manifest.json from separate file (embedded in MF manifest)
2. Remove componentMap from ssr-entry.js
3. Remove HTTP proxy code from api.server.js

---

## File Changes Required

```
apps/rsc-demo/
├── packages/
│   ├── app-shared/
│   │   └── plugins/
│   │       ├── rscSSRResolverPlugin.js     # NEW
│   │       ├── rscServerActionsPlugin.js    # NEW
│   │       └── rscManifestPlugin.js         # NEW (build-time)
│   ├── app1/
│   │   ├── scripts/
│   │   │   ├── build.js                     # MODIFY (add manifest plugin)
│   │   │   └── client.build.js              # MODIFY (additionalData hook)
│   │   ├── src/framework/
│   │   │   └── ssr-entry.js                 # REWRITE (manifest-driven)
│   │   └── server/
│   │       └── api.server.js                # MODIFY (unified actions)
│   └── app2/
│       └── (same changes as app1)
```

---

## Runtime Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           BUILD TIME                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ReactServerWebpackPlugin ──► react-client-manifest.json                │
│         │                                                                │
│         ▼                                                                │
│  ModuleFederationPlugin.additionalData() ──► mf-manifest.json           │
│         │                                    (includes rsc.clientComponents) │
│         ▼                                                                │
│  Same for server-actions ──► mf-manifest.json.rsc.serverActions          │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           RUNTIME (SSR)                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  initFederation({ plugins: [rscSSRResolverPlugin()] })                  │
│         │                                                                │
│         ├──► Load mf-manifest.json                                      │
│         ├──► Build componentRegistry from rsc.clientComponents          │
│         ├──► Setup globalThis.__webpack_require__                       │
│         │                                                                │
│         ▼                                                                │
│  renderFlightToHTML(flightBuffer)                                       │
│         │                                                                │
│         ├──► createFromNodeStream() parses $L references                │
│         ├──► __webpack_require__(moduleId) resolves from registry       │
│         └──► renderToPipeableStream() generates HTML                    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                       RUNTIME (Server Actions)                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  initFederation({ plugins: [rscServerActionsPlugin()] })                │
│         │                                                                │
│         ├──► loadRemote('app2/server-actions')                          │
│         │         │                                                      │
│         │         └──► onLoad hook fires                                │
│         │                   │                                            │
│         │                   ├──► Fetch react-server-actions-manifest    │
│         │                   └──► registerServerReference() for each     │
│         │                                                                │
│         ▼                                                                │
│  POST /react (action request)                                           │
│         │                                                                │
│         ├──► getServerAction(actionId)                                  │
│         │         └──► Returns local OR remote action function          │
│         │                                                                │
│         ├──► Execute action(...args)                                    │
│         └──► Stream updated Flight response                             │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Key Insights from Research

### Module Federation Runtime Capabilities Used

1. **Plugin Hooks**:
   - `init` - Load manifests and setup resolvers
   - `loadSnapshot` - Intercept remote manifest loading
   - `onLoad` - Intercept module loads for action registration
   - `fetch` - Custom manifest fetching if needed
   - `errorLoadRemote` - Fallback for failed loads

2. **Manifest Extension**:
   - `additionalData` hook allows embedding any custom data
   - Can include full react-client-manifest.json content
   - Remote discovery through manifest's remotes array

3. **Share Scope**:
   - React/react-dom shared as singletons
   - Separate share scopes for client/rsc/ssr layers
   - Version negotiation handled by MF runtime

4. **Module Cache**:
   - `moduleCache.get(remoteName)` prevents duplicate loads
   - Can pre-warm cache for critical remotes

### Why This Works

The key insight is that MF already solves the core problems RSC SSR faces:

| RSC Problem | MF Solution |
|-------------|-------------|
| "Which chunks contain this component?" | `manifest.exposes[path].assets.js.sync` |
| "What's the webpack module ID?" | Embed in `rsc.clientComponents[path].moduleId` |
| "How to load remote modules in Node?" | `loadRemote()` with async-node target |
| "How to share React across apps?" | Share scope with singleton + version matching |
| "How to discover remote capabilities?" | Manifest loading via `loadSnapshot` hook |

---

## Next Steps

1. **Prototype the manifest extension** - Add `additionalData` hook to current builds
2. **Create SSR resolver plugin** - Test with single app first
3. **Create server actions plugin** - Test local-to-remote action execution
4. **Remove legacy code** - Delete componentMap, HTTP forwarding
5. **Add tests** - Ensure manifest-driven resolution works reliably
