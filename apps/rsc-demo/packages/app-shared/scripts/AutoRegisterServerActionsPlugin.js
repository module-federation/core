'use strict';

/**
 * AutoRegisterServerActionsPlugin
 *
 * Ensures all `'use server'` modules are bundled and evaluated in the RSC server
 * entrypoint. This avoids needing manual `require(...)` side-effect imports in
 * `src/server-entry.js`.
 *
 * Why this is needed:
 * - In the RSC server compilation, `'use client'` modules are replaced with
 *   client-reference proxies, so their imports are NOT followed.
 * - Server Actions are often imported from client modules, which means the RSC
 *   server bundle would otherwise miss those `'use server'` modules entirely.
 * - The RSDW loader registers actions via side effects (`registerServerReference`)
 *   at module evaluation time, so they must be executed at least once.
 */
class AutoRegisterServerActionsPlugin {
  constructor(options = {}) {
    this.roots = Array.isArray(options.roots) ? options.roots : null;
    this.extensions = Array.isArray(options.extensions)
      ? options.extensions
      : ['.js', '.mjs'];
  }

  apply(compiler) {
    const fs = require('fs');
    const path = require('path');

    const writeBootstrap = async () => {
      const roots = (
        this.roots && this.roots.length
          ? this.roots
          : [path.join(compiler.context, 'src')]
      ).map((root) =>
        path.isAbsolute(root) ? root : path.join(compiler.context, root),
      );

      const srcDir = path.join(compiler.context, 'src');
      const bootstrapPath = path.join(srcDir, '__rsc_server_actions__.js');

      const requests = new Set();

      const shouldScanFile = (filePath) => {
        return this.extensions.some((ext) => filePath.endsWith(ext));
      };

      const isUseServerModule = (filePath) => {
        try {
          const src = fs.readFileSync(filePath, 'utf8');
          return /^\s*['"]use server['"]\s*;?/.test(src);
        } catch (_e) {
          return false;
        }
      };

      const walk = (dirPath) => {
        let entries;
        try {
          entries = fs.readdirSync(dirPath, { withFileTypes: true });
        } catch (_e) {
          return;
        }

        for (const entry of entries) {
          const fullPath = path.join(dirPath, entry.name);
          if (entry.isDirectory()) {
            walk(fullPath);
            continue;
          }
          if (!entry.isFile()) continue;
          if (!shouldScanFile(fullPath)) continue;
          if (!isUseServerModule(fullPath)) continue;

          const relative = path.relative(srcDir, fullPath);
          const request = (
            relative.startsWith('.') ? relative : `./${relative}`
          )
            .split(path.sep)
            .join('/');
          requests.add(request);
        }
      };

      for (const root of roots) {
        walk(root);
      }

      if (!fs.existsSync(srcDir)) {
        fs.mkdirSync(srcDir, { recursive: true });
      }

      const sorted = [...requests].sort();
      const lines = [
        "'use strict';",
        '',
        '/**',
        ' * AUTO-GENERATED FILE. DO NOT EDIT.',
        ' *',
        ' * Generated by AutoRegisterServerActionsPlugin to ensure all "use server"',
        ' * modules are bundled and evaluated in the RSC server build.',
        ' */',
        '',
        ...sorted.map((req) => `require('${req}');`),
        '',
      ];

      fs.writeFileSync(bootstrapPath, lines.join('\n'));
    };

    const ensureBootstrap = (_params, callback) => {
      Promise.resolve()
        .then(writeBootstrap)
        .then(
          () => callback(),
          (err) => callback(err),
        );
    };

    compiler.hooks.beforeCompile.tapAsync(
      'AutoRegisterServerActionsPlugin',
      ensureBootstrap,
    );
    compiler.hooks.watchRun.tapAsync(
      'AutoRegisterServerActionsPlugin',
      ensureBootstrap,
    );
  }
}

module.exports = AutoRegisterServerActionsPlugin;
module.exports.default = AutoRegisterServerActionsPlugin;
