= Mejorando la Resistencia y la tolerancia a fallos con Federaci贸n de M贸dulos

Federaci贸n de M贸dulos es una caracter铆stica de Webpack que le permite cargar din谩micamente m贸dulos de diferentes paquetes en tiempo de ejecuci贸n. Esto puede ayudarle a mejorar la resistencia y las capacidades de tolerancia a fallos de sus aplicaciones web, reduciendo el impacto de los fallos de red, errores del servidor o errores de c贸digo.

La resistencia es la capacidad de un sistema para recuperarse de fallos y seguir funcionando. Los failovers son los mecanismos que permiten a un sistema cambiar a una copia de seguridad o a un modo alternativo de funcionamiento cuando se produce un fallo.

En esta gu铆a, aprender谩 a utilizar la Federaci贸n de M贸dulos para:

- Cargar m贸dulos desde fuentes remotas con planes de contingencia (fallbacks)
- Manejo errores y reintentos al cargar m贸dulos
- Implementaci贸n de un patr贸n de interruptor (circuit breaker pattern) para evitar fallos en cascada.
- Utilizar _service workers_ para almacenar m贸dulos en cach茅 y servirlos offline.

== Requisitos previos

Para seguir esta gu铆a, necesita tener:

- Conocimiento b谩sico de Webpack y Federaci贸n de M贸dulos
- Node.js y npm instalados en el ordenador
- Un editor de c贸digo de su elecci贸n

== Configuraci贸n del proyecto

Para demostrar c贸mo funciona Federaci贸n de M贸dulos, crearemos una aplicaci贸n web sencilla que consta de dos partes: una aplicaci贸n hu茅sped y una aplicaci贸n remota. La aplicaci贸n hu茅sped cargar谩 un m贸dulo de la aplicaci贸n remota y mostrar谩 su contenido en la p谩gina. La aplicaci贸n remota expondr谩 un m贸dulo que devuelve un mensaje de saludo.

Para configurar el proyecto, siga estos pasos:

1. Cree una nueva carpeta llamada `module-federation-demo` y navege a ella desde el terminal.
2. Ejecute `npm init -y` para crear un archivo `package.json` con valores por defecto.
3. Ejecute `npm install webpack webpack-cli webpack-dev-server html-webpack-plugin` para instalar las dependencias.
4. Cree dos subcarpetas llamadas `host` y `remote` dentro de la carpeta `module-federation-demo`. Estas contendr谩n el c贸digo fuente para la aplicaci贸n hu茅sped y la aplicaci贸n remota respectivamente.
5. Cree un archivo `webpack.config.js` en cada subcarpeta con el siguiente contenido:

[tabs]
======
host webpack.config::
+
[source, javascript]
----
// webpack.config.js de la aplicaci贸n hu茅sped (host)
const HtmlWebpackPlugin = require("html-webpack-plugin");
const { ModuleFederationPlugin } = require("webpack").container;

module.exports = {
  mode: "development",
  devServer: {
    port: 3000,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./src/index.html",
    }),
    new ModuleFederationPlugin({
      name: "host",
      remotes: {
        remote: "remote@http://localhost:3001/remoteEntry.js",
      },
    }),
  ],
};
----

remote webpack.config::
+
[source, javascript]
----
// webpack.config.js for remote app
const HtmlWebpackPlugin = require("html-webpack-plugin");
const { ModuleFederationPlugin } = require("webpack").container;

module.exports = {
  mode: "development",
  devServer: {
    port: 3001,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./src/index.html",
    }),
    new ModuleFederationPlugin({
      name: "remote",
      filename: "remoteEntry.js",
      exposes: {
        "./greeting": "./src/greeting.js",
      },
    }),
  ],
};
----
======

`ModuleFederationPlugin` es el plugin principal que habilita Federaci贸n de M贸dulos. Este toma algunas opciones que definen c贸mo se exponen y consumen los m贸dulos.

En la aplicaci贸n hu茅sped, especificamos la opci贸n `remotes` que le dice a Webpack d贸nde encontrar el punto de entrada de la aplicaci贸n remota. La sintaxis es `<nombre>@<url>`, donde `<nombre>` es un alias que podemos usar para importar m贸dulos de la aplicaci贸n remota, y `<url>` es la URL del punto de entrada de la aplicaci贸n remota.

En la aplicaci贸n remota, especificamos la opci贸n `filename` que indica a Webpack el nombre que se debe utilizar en el archivo del punto de entrada. Tambi茅n especificamos la opci贸n `exposes` que le dice a Webpack qu茅 m贸dulos queremos exponer a otras aplicaciones. La sintaxis es `<nombre>:<ruta>`, donde `<nombre>` es un alias que otras aplicaciones pueden utilizar para importar nuestro m贸dulo, y `<ruta>` es la ruta relativa a nuestro archivo de m贸dulo.

6. Cree un archivo `index.html` en cada subcarpeta con el siguiente contenido:


[tabs]
======
host index.html::
+
[source, html]
----
<!-- index.html de la aplicaci贸n hu茅sped (host) -->
<html>
  <head>
    <title>Aplicaci贸n Hu茅sped</title>
  </head>
  <body>
    <h1>Aplicaci贸n Hu茅sped </h1>
    <div id="container"></div>
    <script src="main.js"></script>
  </body>
</html>
----

remote index.html::
+
[source, html]
----
<!-- index.html de la aplicaci贸n remota (remote) -->
<html>
  <head>
    <title>Aplicaci贸n Remota</title>
  </head>
  <body>
    <h1>Aplicaci贸n Remota</h1>
    <script src="remoteEntry.js"></script>
  </body>
</html>
----
=====

Los archivos `index.html` son los puntos de entrada para las aplicaciones web. Cargan los respectivos paquetes JavaScript generados por Webpack.

7. Cree una carpeta `src` en cada subcarpeta y a帽ada los siguientes archivos:

Host:

[tabs]
======
index.js::
+
[source, javascript]
----
// src/index.js de la aplicaci贸n hu茅sped
import("./bootstrap");
----

bootstrap.js::
+
[source, javascript]
----
// src/bootstrap.js de la aplicaci贸n hu茅sped
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(<App />, document.getElementById("container"));
----

App.js::
+
[source, javascript]
----
// src/App.js de la aplicaci贸n hu茅sped
import React, { useEffect, useState } from "react";

const App = () => {
  const [greeting, setGreeting] = useState("");

  useEffect(() => {
    // Carga el m贸dulo de saludo desde la aplicaci贸n remota
    import("remote/greeting")
      .then((module) => {
        // Llama a la funci贸n de exportaci贸n por defecto del m贸dulo y establece el estado de saludo
        setGreeting(module.default());
      })
      .catch((error) => {
        // Manejar cualquier error al cargar el m贸dulo
        console.error(error);
        setGreeting("Oops, algo sali贸 mal!");
      });
  }, []);

  return (
    <div>
      <p> El saludo de la aplicaci贸n remota es:</p>
      <p>{greeting}</p>
    </div>
  );
};

export default App;
----

Remote

[tabs]
======
index.js::
+
[source, javascript]
----
// src/index.js de la aplicaci贸n remota
import("./bootstrap");
----

bootstrap.js::
+
[source, javascript]
----
// src/bootstrap.js de la aplicaci贸n remota
import React from "react";
import ReactDOM from "react-dom";
import Greeting from "./Greeting";

ReactDOM.render(<Greeting />, document.getElementById("root"));
----

greeting.js::
+
[source, javascript]
----
// src/Greeting.js de la aplicaci贸n remota
import React from "react";

const Greeting = () => {
  return <h2> 隆Hola desde la aplicaci贸n remota! </h2>;
};

export default Greeting;
----
=====

Los archivos `src/index.js` son los puntos de entrada para los paquetes JavaScript. Importan un archivo `bootstrap.js` que contiene la l贸gica real de las aplicaciones. Este es un patr贸n com煤n para permitir la carga as铆ncrona de m贸dulos con Federaci贸n de M贸dulos.

Los archivos `src/bootstrap.js` de la aplicaci贸n host y de la aplicaci贸n remota utilizan React para renderizar algunos componentes de la p谩gina. La aplicaci贸n host importa un archivo `App.js` que contiene un componente que carga el m贸dulo de saludo de la aplicaci贸n remota y lo muestra en la p谩gina. La aplicaci贸n remota importa un archivo `Greeting.js` que contiene un componente que muestra un mensaje de saludo en la p谩gina.

El archivo `src/greeting.js` de la aplicaci贸n remota es el m贸dulo que exponemos a otras aplicaciones. Exporta una funci贸n que devuelve un mensaje de saludo.

8. Ejecuta `npm run dev` en ambas subcarpetas para iniciar los servidores de desarrollo. Deberia ver algo como esto en el navegador:

// TODO: (screenshot)

Ha configurado con 茅xito un proyecto b谩sico de Federaci贸n de M贸dulos. A continuaci贸n, veremos c贸mo mejorar sus capacidades de resistencia y tolerancia a fallos.

== Carga de m贸dulos con plan de contingencia

Uno de los beneficios de Federaci贸n de M贸dulos es que permite cargar m贸dulos desde fuentes remotas sin tener que empaquetarlos con la aplicaci贸n. Esto puede reducir el tama帽o del paquete y mejorar el rendimiento.

Sin embargo, esto tambi茅n introduce algunos riesgos. 驴Qu茅 pasa si la fuente remota no est谩 disponible o es lenta? 驴Y si el m贸dulo no se carga o ejecuta? 驴C贸mo puede asegurarse de que su aplicaci贸n sigue funcionando en estas situaciones?

Una forma de manejar estas situaciones es proporcionar planes de contingencia para los m贸dulos. Un "fallback" es un m贸dulo alternativo que puede cargar en caso de que el m贸dulo original falle. Por ejemplo, puede proporcionar una copia local del m贸dulo, o un m贸dulo falso que devuelva algunos datos ficticios.

Para utilizar fallbacks con Federaci贸n de M贸dulos, puede utilizar la opci贸n `fallback` del `ModuleFederationPlugin`. Esta opci贸n le permite especificar un objeto que mapea nombres remotos a m贸dulos fallback. Por ejemplo, puede modificar la configuraci贸n de Webpack de su aplicaci贸n host de la siguiente manera:

[source, javascript]
----
// webpack.config.js de la aplicaci贸n hu茅sped
const HtmlWebpackPlugin = require("html-webpack-plugin");
const { ModuleFederationPlugin } = require("webpack").container;

module.exports = {
  mode: "development",
  devServer: {
    port: 3000,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./src/index.html",
    }),
    new ModuleFederationPlugin({
      name: "host
      remotes: {
        remote: "remote@http://localhost:3001/remoteEntry.js",
      },
      // Especifica los m贸dulos de contingencia de la aplicaci贸n remota
      fallback: {
        remote: "./src/fallback.js",
      },
    }),
  ],
};
----

La opci贸n `fallback` indica a Webpack que cargue el archivo `src/fallback.js` como fallback de la aplicaci贸n remota. Este archivo debe exportar los mismos m贸dulos que la aplicaci贸n remota, pero con diferentes implementaciones. Por ejemplo, puede crear un archivo `src/fallback.js` como este:

[source, javascript]
----
// src/fallback.js for host app
// Exporta un m贸dulo de saludo simulado que devuelve un mensaje est谩tico
export const greeting = () => {
  return "Hello from the fallback module!";
};
----

Ahora, si la aplicaci贸n remota no puede cargar o exponer el m贸dulo de saludo, la aplicaci贸n host utilizar谩 el m贸dulo alternativo en su lugar. Puede comprobarlo deteniendo el servidor de la aplicaci贸n remota y actualizando la p谩gina de la aplicaci贸n host. Deber铆a ver algo como esto:

// TODO: (screenshot)

Ha implementado con 茅xito un mecanismo de contingencia para sus m贸dulos. A continuaci贸n, veremos c贸mo manejar errores y reintentos al cargar m贸dulos.

## Manejo de errores y reintentos al cargar m贸dulos

Otra forma de mejorar la resistencia de su aplicaci贸n web es gestionar los errores y reintentos al cargar m贸dulos desde fuentes remotas. Esto puede ayudarle a recuperarse de fallos temporales o problemas de red.

Para manejar errores y reintentos con Federaci贸n de M贸dulos, puede utilizar la funci贸n `import()` que Webpack proporciona. Esta funci贸n devuelve una promesa que resuelve al objeto m贸dulo si el m贸dulo se carga correctamente, o rechaza con un error si el m贸dulo no se carga. Puede usar el m茅todo `catch()` de la promesa para manejar cualquier error y reintentar cargar el m贸dulo si es necesario.

Por ejemplo, puede modificar el archivo `App.js` de su aplicaci贸n host de la siguiente manera:
[source, javascript]
----
// src/App.js de la aplicaci贸n hu茅sped
import React, { useEffect, useState } from "react";

const App = () => {
  const [greeting, setGreeting] = useState("");
  const [retryCount, setRetryCount] = useState(0);

  useEffect(() => {
    // Carga el m贸dulo de saludo desde la aplicaci贸n remota
    import("remote/greeting")
      .then((module) => {
        // Llama a la funci贸n de exportaci贸n por defecto del m贸dulo y establece el estado de saludo
        setGreeting(module.default());
      })
      .catch((error) => {
        // Manejar cualquier error al cargar el m贸dulo
        console.error(error);
        // Comprobar si hemos alcanzado el n煤mero m谩ximo de reintentos
        if (retryCount < 3) {
          // Incrementa la cuenta de reintentos
          setRetryCount(retryCount + 1);
          // Reintenta cargar el m贸dulo despu茅s de 1 segundo          setTimeout(() => {
            import("remote/greeting").then((module) => {
              setGreeting(module.default());
            });
          }, 1000);
        } else {
          // Desistir y mostrar un mensaje de error
          setGreeting("Lo sentimos, no hemos podido cargar el m贸dulo de saludo.");
        }
      });
  }, [retryCount]);

  return (
    <div>
      <p> El saludo de la aplicaci贸n remota es:</p>
      <p>{greeting}</p>
    </div>
  );
};

export default App;
----

El archivo `App.js` utiliza ahora un estado `retryCount` para llevar la cuenta de cu谩ntas veces ha intentado cargar el m贸dulo de saludo. Si el m贸dulo no se carga, comprueba si el recuento de reintentos es inferior a 3. Si es as铆, incrementa el recuento de reintentos e intenta cargar el m贸dulo de nuevo despu茅s de 1 segundo. Si no, se desiste y muestra un mensaje de error.

Puede probar esto simulando un fallo de red en las herramientas de desarrollo de su navegador. Deber铆a ver algo como esto

// TODO: (captura de pantalla)

Ha implementado con 茅xito un mecanismo de manejo de errores y reintentos para sus m贸dulos. A continuaci贸n, veremos c贸mo implementar un patr贸n de interruptor para evitar fallos en cascada.


## Implementaci贸n de patr贸n de interruptor para evitar fallos en cascada

Otra forma de mejorar la resistencia de la aplicaci贸n web es implementar un patr贸n de interruptores para evitar fallos en cascada. Un patr贸n de interruptor es un dise帽o que monitoriza la salud de un servicio remoto y evita peticiones excesivas cuando el servicio no est谩 funcionando correctamente. Esto puede ayudarle a evitar sobrecargar el servicio o malgastar recursos cuando es poco probable que el servicio responda.

Para implementar un patr贸n de interruptor de circuito con Federaci贸n de M贸dulos, puede utilizar una biblioteca de terceros llamada `opossum`. Esta biblioteca proporciona una funci贸n `circuitBreaker` que envuelve una funci贸n basada en promesas y controla sus tasas de 茅xito y fracaso. Tambi茅n proporciona algunas opciones para configurar el comportamiento del interruptor, como el umbral de fallo, la duraci贸n del tiempo de espera y el tiempo de espera de reinicio.

Por ejemplo, puede modificar el archivo `App.js` de su aplicaci贸n hu茅sped de la siguiente manera:

[source, javascript]
----
// src/App.js de la aplicaci贸n hu茅sped
import React, { useEffect, useState } from "react";
import { circuitBreaker } from "opossum";

const App = () => {
  const [greeting, setGreeting] = useState("");

  useEffect(() => {
    // Crea un interruptor de circuito para cargar el m贸dulo de saludo
    const breaker = circuitBreaker(() => import("remote/greeting"), {
      // Fijar el umbral de fallo en el 50%.
      errorThresholdPercentage: 50,
      // Ajusta la duraci贸n del tiempo de espera a 3 segundos
      timeout: 3000,
      // Ajusta el tiempo de espera de reinicio a 10 segundos
      resetTimeout: 10000,
    });

    // Cargar el m贸dulo de saludo mediante el interruptor de circuito
    breaker
      .fire()
      .then((module) => {
        // Llama a la funci贸n de exportaci贸n por defecto del m贸dulo y establece el estado de saludo
        setGreeting(module.default());
      })
      .catch((error) => {
        // Maneja cualquier error al cargar el m贸dulo
        console.error(error);
        // Comprueba si el interruptor de circuito est谩 encendido
        if (breaker.opened) {
          // Muestra un mensaje indicando que el servicio no est谩 disponible
          setGreeting("El servicio remoto no est谩 disponible. Por favor, int茅ntelo m谩s tarde ");
        } else {
          // Muestre un mensaje de que algo ha ido mal
          setGreeting("Oops, algo sali贸 mal!");
        }
      });
  }, []);

  return (
    <div>
      <p> El saludo de la aplicaci贸n remota es:</p>
      <p>{greeting}</p>
    </div>
  );
};

export default App;
----

El archivo `App.js` utiliza ahora un interruptor autom谩tico para cargar el m贸dulo de saludo. El interruptor controlar谩 las tasas de 茅xito y fracaso de la carga del m贸dulo y se abrir谩 o cerrar谩 en consecuencia. Si el interruptor est谩 abierto, rechazar谩 cualquier petici贸n inmediatamente y mostrar谩 un mensaje indicando que el servicio no est谩 disponible. Si el interruptor est谩 cerrado, intentar谩 cargar el m贸dulo normalmente y mostrar谩 un mensaje de que algo ha ido mal si falla.

Puede probar esto simulando un fallo de red en las herramientas de desarrollo del navegador. Deber铆a ver algo como esto:

// TODO: (screenshot)

Ha implementado con 茅xito un patr贸n de interruptor para sus m贸dulos. A continuaci贸n, veremos c贸mo utilizar service workers para cachear m贸dulos y servirlos offline.

## Uso de service workers para almacenar m贸dulos en cach茅 y servirlos _offline_

Otra forma de mejorar la resistencia de la aplicaci贸n web es utilizar service workers para cachear m贸dulos y servirlos _offline_. Un service worker es un script que se ejecuta en segundo plano e intercepta las peticiones de red. Puede almacenar en cach茅 las respuestas y servirlas desde la cach茅 cuando la red no est谩 disponible o es lenta. Esto puede ayudarte a mejorar el rendimiento y la fiabilidad de la aplicaci贸n web.

Para utilizar los service workers con Federaci贸n de M贸dulos, puede utilizar una librer铆a de terceros llamada `workbox`. Esta librer铆a proporciona algunas herramientas y m贸dulos para simplificar la creaci贸n y gesti贸n de service workers. Tambi茅n proporciona algunas estrategias para controlar c贸mo el service worker gestiona las peticiones de red y las respuestas de cach茅.

Por ejemplo, puede modificar la configuraci贸n de Webpack de la aplicaci贸n hu茅sped de la siguiente manera:

[source, javascript]
----
// webpack.config.js de la aplicaci贸n hu茅sped
const HtmlWebpackPlugin = require("html-webpack-plugin");
const { ModuleFederationPlugin } = require("webpack").container;
const { InjectManifest } = require("workbox-webpack-plugin");

module.exports = {
  mode: "development",
  devServer: {
    port: 3000,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./src/index.html",
    }),
    new ModuleFederationPlugin({
      name: "host",
      remotes: {
        remote: "remote@http://localhost:3001/remoteEntry.js",
      },
      fallback: {
        remote: "./src/fallback.js",
      },
    }),
    // Utilice el plugin InjectManifest para generar un service worker
    new InjectManifest({
      swSrc: "./src/sw.js",
      swDest: "sw.js",
    }),
  ],
};
----

El plugin `InjectManifest` es un plugin que genera un service worker basado en un fichero fuente. Este toma algunas opciones que definen el origen y el destino del archivo del service worker.

En este caso, especificamos una opci贸n `swSrc` que le dice a Webpack que use el archivo `src/sw.js` como fuente del service worker. Tambi茅n especificamos una opci贸n `swDest` que le dice a Webpack qu茅 nombre usar para el archivo del service worker generado.

A continuaci贸n, tenemos que crear un archivo `src/sw.js` que contenga la l贸gica del service worker. Podemos utilizar los m贸dulos `workbox` para implementar algunas estrategias de cach茅 para nuestros m贸dulos. Por ejemplo, podemos crear un archivo `src/sw.js` como este:

[source, javascript]
----
// src/sw.js for host app
import { precacheAndRoute } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate } from "workbox-strategies";

// Precache and route the files generated by Webpack
precacheAndRoute(self.__WB_MANIFEST);

// Register a route for remote modules using a stale-while-revalidate strategy
registerRoute(
  ({ url }) => url.origin === "http://localhost:3001",
  new StaleWhileRevalidate()
);
----

El archivo `sw.js` importa algunos m贸dulos del `workbox` y los utiliza para implementar algunas estrategias de cach茅 para nuestros m贸dulos.

La funci贸n `precacheAndRoute` toma un array de ficheros para prealmacenar y enrutar. En este caso, le pasamos la variable `self.__WB_MANIFEST`, el cual es un array de ficheros generados por Webpack. Esto asegurar谩 que los archivos de nuestra aplicaci贸n hu茅sped se almacenen en cach茅 y se sirvan desde la cach茅 cuando no estemos conectados.

La funci贸n `registerRoute` toma una funci贸n de coincidencia y una estrategia de cach茅. En este caso, le pasamos una funci贸n que coincide con cualquier petici贸n al origen de la aplicaci贸n remota, y una estrategia `StaleWhileRevalidate`. Esto garantizar谩 que cualquier m贸dulo remoto se almacene en cach茅 y se sirva desde la cach茅 si est谩 disponible, al tiempo que se actualiza la cach茅 en segundo plano si es posible.

Por 煤ltimo, tenemos que registrar el service worker en el archivo `index.html` de nuestra aplicaci贸n hu茅sped. Podemos a帽adir una etiqueta script como la siguiente:

[source, javascript]
----
<!-- index.html for host app -->
<html>
  <head>
    <title>Aplicaci贸n Hu茅sped</title>
  </head>
  <body>
    <h1>Host App</h1>
    <div id="container"></div>
    <script src="main.js"></script>
    <!-- Register the service worker -->
    <script>
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker.register("/sw.js");
        });
      }
    </script>
  </body>
</html>
----

La etiqueta script comprueba si el navegador soporta service workers y registra el archivo `sw.js` como un service worker.

Ahora, si se recarga la p谩gina de la aplicaci贸n hu茅sped, deber铆a ver algo como esto en las herramientas de desarrollo del navegador:

// TODO: (screenshot)

Ha registrado con 茅xito un service worker que almacena en cach茅 los m贸dulos y los sirve offline. Puede probarlo simulando un modo offline en las herramientas de desarrollo del navegador. Deber铆a ver algo como esto

// TODO: (screenshot)

Ha implementado con 茅xito un service worker para cachear m贸dulos y servirlos offline.

## Conclusi贸n

En esta gu铆a ha aprendido a utilizar la Federaci贸n de M贸dulos para mejorar la resistencia y la capacidad de recuperaci贸n ante fallos de sus aplicaciones web. Ha aprendido como:

- Cargar m贸dulos desde fuentes remotas con fallbacks
- Manejar errores y reintentos al cargar m贸dulos
- Implementar un patr贸n de interruptor para evitar fallos en cascada
- Utilizar service workers para almacenar m贸dulos en cach茅 y servirlos offline

Puede encontrar el c贸digo fuente de esta gu铆a en GitHub.

Esperamos que haya disfrutado de esta gu铆a y haya aprendido algo nuevo. Si tiene alg煤n comentario o pregunta, por favor h谩ganoslo saber en los comentarios de abajo. 隆Gracias por leer! 
