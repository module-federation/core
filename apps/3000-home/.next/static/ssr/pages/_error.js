(() => {
var exports = {};
exports.id = "pages/_error";
exports.ids = ["pages/_error"];
exports.modules = {

/***/ "../../node_modules/.pnpm/next@14.2.16_@babel+core@7.25.2_react-dom@18.3.1_react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F_error&preferredRegion=&absolutePagePath=private-next-pages%2F_error&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@14.2.16_@babel+core@7.25.2_react-dom@18.3.1_react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F_error&preferredRegion=&absolutePagePath=private-next-pages%2F_error&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   config: () => (/* binding */ config),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getServerSideProps: () => (/* binding */ getServerSideProps),
/* harmony export */   getStaticPaths: () => (/* binding */ getStaticPaths),
/* harmony export */   getStaticProps: () => (/* binding */ getStaticProps),
/* harmony export */   reportWebVitals: () => (/* binding */ reportWebVitals),
/* harmony export */   routeModule: () => (/* binding */ routeModule),
/* harmony export */   unstable_getServerProps: () => (/* binding */ unstable_getServerProps),
/* harmony export */   unstable_getServerSideProps: () => (/* binding */ unstable_getServerSideProps),
/* harmony export */   unstable_getStaticParams: () => (/* binding */ unstable_getStaticParams),
/* harmony export */   unstable_getStaticPaths: () => (/* binding */ unstable_getStaticPaths),
/* harmony export */   unstable_getStaticProps: () => (/* binding */ unstable_getStaticProps)
/* harmony export */ });
/* harmony import */ var next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages/module.compiled */ "../../node_modules/.pnpm/next@14.2.16_@babel+core@7.25.2_react-dom@18.3.1_react@18.3.1/node_modules/next/dist/server/future/route-modules/pages/module.compiled.js");
/* harmony import */ var next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ "../../node_modules/.pnpm/next@14.2.16_@babel+core@7.25.2_react-dom@18.3.1_react@18.3.1/node_modules/next/dist/server/future/route-kind.js");
/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ "../../node_modules/.pnpm/next@14.2.16_@babel+core@7.25.2_react-dom@18.3.1_react@18.3.1/node_modules/next/dist/build/templates/helpers.js");
/* harmony import */ var private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! private-next-pages/_document */ "./pages/_document.js");
/* harmony import */ var private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! private-next-pages/_app */ "./pages/_app.tsx");
/* harmony import */ var private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! private-next-pages/_error */ "../../node_modules/.pnpm/next@14.2.16_@babel+core@7.25.2_react-dom@18.3.1_react@18.3.1/node_modules/next/dist/pages/_error.js");
/* harmony import */ var private_next_pages_error__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__);



// Import the app and document modules.


// Import the userland code.

// Re-export the component (should be the default export).
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__, "default"));
// Re-export methods.
const getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__, "getStaticProps");
const getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__, "getStaticPaths");
const getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__, "getServerSideProps");
const config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__, "config");
const reportWebVitals = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__, "reportWebVitals");
// Re-export legacy methods.
const unstable_getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__, "unstable_getStaticProps");
const unstable_getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__, "unstable_getStaticPaths");
const unstable_getStaticParams = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__, "unstable_getStaticParams");
const unstable_getServerProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__, "unstable_getServerProps");
const unstable_getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__, "unstable_getServerSideProps");
// Create and export the route module that will be consumed.
const routeModule = new next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesRouteModule({
    definition: {
        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES,
        page: "/_error",
        pathname: "/_error",
        // The following aren't used in production.
        bundlePath: "",
        filename: ""
    },
    components: {
        App: private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__["default"],
        Document: private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__["default"]
    },
    userland: private_next_pages_error__WEBPACK_IMPORTED_MODULE_5__
});

//# sourceMappingURL=pages.js.map

/***/ }),

/***/ "../../packages/error-codes/dist/index.cjs.js":
/*!****************************************************!*\
  !*** ../../packages/error-codes/dist/index.cjs.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const RUNTIME_001 = "RUNTIME-001";
const RUNTIME_002 = "RUNTIME-002";
const RUNTIME_003 = "RUNTIME-003";
const RUNTIME_004 = "RUNTIME-004";
const RUNTIME_005 = "RUNTIME-005";
const RUNTIME_006 = "RUNTIME-006";
const RUNTIME_007 = "RUNTIME-007";
const RUNTIME_008 = "RUNTIME-008";
const TYPE_001 = "TYPE-001";
const BUILD_001 = "BUILD-001";
const getDocsUrl = (errorCode)=>{
    const type = errorCode.split("-")[0].toLowerCase();
    return `View the docs to see how to solve: https://module-federation.io/guide/troubleshooting/${type}/${errorCode}`;
};
const getShortErrorMsg = (errorCode, errorDescMap, args, originalErrorMsg)=>{
    const msg = [
        `${[
            errorDescMap[errorCode]
        ]} #${errorCode}`
    ];
    args && msg.push(`args: ${JSON.stringify(args)}`);
    msg.push(getDocsUrl(errorCode));
    originalErrorMsg && msg.push(`Original Error Message:\n ${originalErrorMsg}`);
    return msg.join("\n");
};
function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const runtimeDescMap = {
    [RUNTIME_001]: "Failed to get remoteEntry exports.",
    [RUNTIME_002]: 'The remote entry interface does not contain "init"',
    [RUNTIME_003]: "Failed to get manifest.",
    [RUNTIME_004]: "Failed to locate remote.",
    [RUNTIME_005]: "Invalid loadShareSync function call from bundler runtime",
    [RUNTIME_006]: "Invalid loadShareSync function call from runtime",
    [RUNTIME_007]: "Failed to get remote snapshot.",
    [RUNTIME_008]: "Failed to load script resources."
};
const typeDescMap = {
    [TYPE_001]: "Failed to generate type declaration. Execute the below cmd to reproduce and fix the error."
};
const buildDescMap = {
    [BUILD_001]: "Failed to find expose module."
};
const errorDescMap = _extends({}, runtimeDescMap, typeDescMap, buildDescMap);
exports.BUILD_001 = BUILD_001;
exports.RUNTIME_001 = RUNTIME_001;
exports.RUNTIME_002 = RUNTIME_002;
exports.RUNTIME_003 = RUNTIME_003;
exports.RUNTIME_004 = RUNTIME_004;
exports.RUNTIME_005 = RUNTIME_005;
exports.RUNTIME_006 = RUNTIME_006;
exports.RUNTIME_007 = RUNTIME_007;
exports.RUNTIME_008 = RUNTIME_008;
exports.TYPE_001 = TYPE_001;
exports.buildDescMap = buildDescMap;
exports.errorDescMap = errorDescMap;
exports.getShortErrorMsg = getShortErrorMsg;
exports.runtimeDescMap = runtimeDescMap;
exports.typeDescMap = typeDescMap;


/***/ }),

/***/ "../../packages/nextjs-mf/dist/utils/flushedChunks.js":
/*!************************************************************!*\
  !*** ../../packages/nextjs-mf/dist/utils/flushedChunks.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = (void 0) && (void 0).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.FlushedChunks = void 0;
const React = __importStar(__webpack_require__(/*! react */ "react"));
/**
 * FlushedChunks component.
 * This component creates script and link elements for each chunk.
 *
 * @param {FlushedChunksProps} props - The properties of the component.
 * @param {string[]} props.chunks - The chunks to be flushed.
 * @returns {React.ReactElement} The created script and link elements.
 */ const FlushedChunks = ({ chunks = [] })=>{
    const scripts = chunks.filter((c)=>{
        // TODO: host shouldnt flush its own remote out
        // if(c.includes('?')) {
        //   return c.split('?')[0].endsWith('.js')
        // }
        return c.endsWith(".js");
    }).map((chunk)=>{
        if (!chunk.includes("?") && chunk.includes("remoteEntry")) {
            chunk = chunk + "?t=" + Date.now();
        }
        return React.createElement("script", {
            key: chunk,
            src: chunk,
            async: true
        }, null);
    });
    const css = chunks.filter((c)=>c.endsWith(".css")).map((chunk)=>{
        return React.createElement("link", {
            key: chunk,
            href: chunk,
            rel: "stylesheet"
        }, null);
    });
    return React.createElement(React.Fragment, null, css, scripts);
};
exports.FlushedChunks = FlushedChunks; //# sourceMappingURL=flushedChunks.js.map


/***/ }),

/***/ "../../packages/nextjs-mf/dist/utils/index.js":
/*!****************************************************!*\
  !*** ../../packages/nextjs-mf/dist/utils/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = (void 0) && (void 0).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.revalidate = exports.FlushedChunks = exports.flushChunks = void 0;
/**
 * Flushes chunks from the module federation node utilities.
 * @module @module-federation/node/utils
 */ var utils_1 = __webpack_require__(/*! @module-federation/node/utils */ "../../packages/node/dist/src/utils/index.js");
Object.defineProperty(exports, "flushChunks", ({
    enumerable: true,
    get: function() {
        return utils_1.flushChunks;
    }
}));
/**
 * Exports the FlushedChunks component from the current directory.
 */ var flushedChunks_1 = __webpack_require__(/*! ./flushedChunks */ "../../packages/nextjs-mf/dist/utils/flushedChunks.js");
Object.defineProperty(exports, "FlushedChunks", ({
    enumerable: true,
    get: function() {
        return flushedChunks_1.FlushedChunks;
    }
}));
/**
 * Revalidates the current state.
 * If the function is called on the client side, it logs an error and returns a resolved promise with false.
 * If the function is called on the server side, it imports the revalidate function from the module federation node utilities and returns the result of calling that function.
 * @returns {Promise<boolean>} A promise that resolves with a boolean.
 */ const revalidate = function(fetchModule = undefined, force = false) {
    if (false) {} else {
        return Promise.resolve().then(()=>__importStar(__webpack_require__(/*! @module-federation/node/utils */ "../../packages/node/dist/src/utils/index.js"))).then(function(utils) {
            return utils.revalidate(fetchModule, force);
        });
    }
};
exports.revalidate = revalidate; //# sourceMappingURL=index.js.map


/***/ }),

/***/ "../../packages/node/dist/src/utils/flush-chunks.js":
/*!**********************************************************!*\
  !*** ../../packages/node/dist/src/utils/flush-chunks.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-undef */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.flushChunks = exports.getAllKnownRemotes = exports.usedChunks = void 0;
// @ts-ignore
if (!globalThis.usedChunks) {
    // @ts-ignore
    globalThis.usedChunks = new Set();
}
/**
 * Initialize usedChunks and share it globally.
 * @type {Set}
 */ // @ts-ignore
exports.usedChunks = globalThis.usedChunks;
/**
 * Load hostStats from the JSON file.
 * @returns {object} hostStats - An object containing host stats data.
 */ const loadHostStats = ()=>{
    try {
        //@ts-ignore
        return require("../federated-stats.json");
    } catch (e) {
        return {};
    }
};
const getAllKnownRemotes = function() {
    // Attempt to access the global federation controller safely
    const federationController = new Function("return globalThis")().__FEDERATION__;
    if (!federationController || !federationController.__INSTANCES__) {
        // If the federation controller or instances are not defined, return an empty object
        return {};
    }
    var collected = {};
    // Use a for...of loop to iterate over all federation instances
    for (const instance of federationController.__INSTANCES__){
        // Use another for...of loop to iterate over the module cache Map entries
        for (const [key, cacheModule] of instance.moduleCache){
            // Check if the cacheModule has remoteInfo and use it to collect remote names
            if (cacheModule.remoteInfo) {
                //@ts-ignore
                collected[cacheModule.remoteInfo.name] = cacheModule.remoteInfo;
            }
        }
    }
    return collected;
};
exports.getAllKnownRemotes = getAllKnownRemotes;
/**
 * Create a shareMap based on the loaded modules.
 * @returns {object} shareMap - An object containing the shareMap data.
 */ const createShareMap = ()=>{
    // Check if __webpack_share_scopes__ is defined and has a default property
    // @ts-ignore
    if (__webpack_require__.S?.default) {
        // Reduce the keys of the default property to create the share map
        // @ts-ignore
        return Object.keys(__webpack_require__.S.default).reduce((acc, key)=>{
            // @ts-ignore
            const shareMap = __webpack_require__.S.default[key];
            // shareScope may equal undefined or null if it has unexpected value
            if (!shareMap || typeof shareMap !== "object") {
                return acc;
            }
            // Get the loaded modules for the current key
            const loadedModules = Object.values(shareMap)// Filter out the modules that are not loaded
            // @ts-ignore
            .filter((sharedModule)=>sharedModule.loaded)// Map the filtered modules to their 'from' properties
            // @ts-ignore
            .map((sharedModule)=>sharedModule.from);
            // If there are any loaded modules, add them to the accumulator object
            if (loadedModules.length > 0) {
                // @ts-ignore
                acc[key] = loadedModules;
            }
            // Return the accumulator object for the next iteration
            return acc;
        }, {});
    }
    // If __webpack_share_scopes__ is not defined or doesn't have a default property, return an empty object
    return {};
};
/**
 * Process a single chunk and return an array of updated chunks.
 * @param {string} chunk - A chunk string containing remote and request data.
 * @param {object} shareMap - An object containing the shareMap data.
 * @param {object} hostStats - An object containing host stats data.
 * @returns {Promise<Array>} A promise that resolves to an array of updated chunks.
 */ // @ts-ignore
const processChunk = async (chunk, shareMap, hostStats)=>{
    const chunks = new Set();
    const [remote, req] = chunk.split("/");
    const request = "./" + req;
    const knownRemotes = (0, exports.getAllKnownRemotes)();
    //@ts-ignore
    if (!knownRemotes[remote]) {
        console.error(`flush chunks: Remote ${remote} is not defined in the global config`);
        return;
    }
    try {
        //@ts-ignore
        const remoteName = new URL(knownRemotes[remote].entry).pathname.split("/").pop();
        //@ts-ignore
        const statsFile = knownRemotes[remote].entry.replace(remoteName, "federated-stats.json").replace("ssr", "chunks");
        let stats = {};
        try {
            stats = await fetch(statsFile).then((res)=>res.json());
        } catch (e) {
            console.error("flush error", e);
        }
        //@ts-ignore
        const [prefix] = knownRemotes[remote].entry.split("static/");
        //@ts-ignore
        if (stats.federatedModules) {
            //@ts-ignore
            stats.federatedModules.forEach((modules)=>{
                if (modules.exposes?.[request]) {
                    //@ts-ignore
                    modules.exposes[request].forEach((chunk)=>{
                        chunks.add([
                            prefix,
                            chunk
                        ].join(""));
                        Object.values(chunk).forEach((chunk)=>{
                            //@ts-ignore
                            if (chunk.files) {
                                //@ts-ignore
                                chunk.files.forEach((file)=>{
                                    chunks.add(prefix + file);
                                });
                            }
                            //@ts-ignore
                            if (chunk.requiredModules) {
                                //@ts-ignore
                                chunk.requiredModules.forEach((module)=>{
                                    if (shareMap[module]) {
                                    // If the module is from the host, log the host stats
                                    }
                                });
                            }
                        });
                    });
                }
            });
        }
        return Array.from(chunks);
    } catch (e) {
        console.error("flush error:", e);
    }
};
/**
 * Flush the chunks and return a deduplicated array of chunks.
 * @returns {Promise<Array>} A promise that resolves to an array of deduplicated chunks.
 */ const flushChunks = async ()=>{
    const hostStats = loadHostStats();
    const shareMap = createShareMap();
    const allFlushed = await Promise.all(Array.from(exports.usedChunks).map(async (chunk)=>processChunk(chunk, shareMap, hostStats)));
    // Deduplicate the chunks array
    const dedupe = Array.from(new Set([
        ...allFlushed.flat()
    ]));
    // Clear usedChunks
    exports.usedChunks.clear();
    // Filter out any undefined or null values
    return dedupe.filter(Boolean);
};
exports.flushChunks = flushChunks; //# sourceMappingURL=flush-chunks.js.map


/***/ }),

/***/ "../../packages/node/dist/src/utils/hmr-client.js":
/*!********************************************************!*\
  !*** ../../packages/node/dist/src/utils/hmr-client.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);

/**
 * HMR Client - Simple Library Interface for Custom Hot Module Replacement
 *
 * This library provides a clean, intuitive API for controlling custom HMR operations.
 * It wraps the complexity of the underlying HMR implementation and provides easy-to-use
 * methods for developers who want basic HMR control.
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HMRClient = void 0;
exports.createHMRClient = createHMRClient;
const custom_hmr_helpers_1 = __webpack_require__(/*! ./custom-hmr-helpers */ "../../packages/node/dist/src/utils/custom-hmr-helpers.js");
class HMRClient {
    constructor(options = {}){
        this.isAttached = false;
        this.updateProvider = null;
        this.pollingInterval = null;
        this.options = {
            autoAttach: true,
            logging: true,
            pollingInterval: 1000,
            maxRetries: 3,
            ...options
        };
        this.stats = {
            totalUpdates: 0,
            successfulUpdates: 0,
            failedUpdates: 0,
            lastUpdateTime: null
        };
        if (this.options.autoAttach) {
            this.attach();
        }
    }
    /**
     * Initialize and attach the HMR runtime to the current environment
     * @returns Success status
     */ attach() {
        try {
            if (this.isAttached) {
                this.log("HMR Client already attached");
                return true;
            }
            // Check if we're in a webpack environment
            if (false) {}
            // Check if module.hot is available
            if (true) {
                this.log("Warning: module.hot not available. Some HMR features may not work.");
            }
            this.isAttached = true;
            this.log("HMR Client successfully attached");
            return true;
        } catch (error) {
            this.log("Failed to attach HMR Client:", error.message);
            return false;
        }
    }
    /**
     * Detach the HMR client and cleanup resources
     */ detach() {
        this.stopPolling();
        this.updateProvider = null;
        this.isAttached = false;
        this.log("HMR Client detached");
    }
    /**
     * Set an update provider function
     * @param provider - Function that returns update data
     */ setUpdateProvider(provider) {
        if (typeof provider !== "function") {
            throw new Error("Update provider must be a function");
        }
        this.updateProvider = provider;
        this.log("Update provider configured");
    }
    /**
     * Check for updates and apply them if available
     * @param options - Check options
     * @returns Result object with success status and details
     */ async checkForUpdates(options = {}) {
        const opts = {
            autoApply: true,
            ...options
        };
        try {
            if (!this.updateProvider) {
                return {
                    success: false,
                    reason: "no_provider",
                    message: "No update provider configured"
                };
            }
            this.log("Checking for updates...");
            const updateData = await this.updateProvider();
            if (!updateData || !updateData.update) {
                return {
                    success: false,
                    reason: "no_updates",
                    message: "No updates available"
                };
            }
            if (opts.autoApply) {
                return await this.applyUpdate(updateData);
            } else {
                return {
                    success: true,
                    reason: "updates_available",
                    message: "Updates available but not applied",
                    updateData
                };
            }
        } catch (error) {
            this.stats.failedUpdates++;
            this.log("Error checking for updates:", error.message);
            return {
                success: false,
                reason: "check_error",
                message: error.message,
                error: error
            };
        }
    }
    /**
     * Apply a specific update
     * @param updateData - Update data to apply
     * @returns Result object
     */ async applyUpdate(updateData) {
        try {
            if (!this.isAttached) {
                throw new Error("HMR Client not attached. Call attach() first.");
            }
            this.stats.totalUpdates++;
            this.log("Applying update...");
            const update = updateData.update;
            if (!update) {
                throw new Error("Update data is null");
            }
            const manifestJsonString = JSON.stringify(update.manifest);
            const chunkJsStringsMap = this.prepareChunkMap(update);
            await (0, custom_hmr_helpers_1.applyHotUpdateFromStringsByPatching)(module,  true ? __webpack_require__ : 0, manifestJsonString, chunkJsStringsMap);
            this.stats.successfulUpdates++;
            this.stats.lastUpdateTime = new Date().toISOString();
            this.log("Update applied successfully");
            return {
                success: true,
                reason: "update_applied",
                message: "Update applied successfully",
                updateId: update.originalInfo?.updateId,
                stats: this.getStats()
            };
        } catch (error) {
            this.stats.failedUpdates++;
            this.log("Failed to apply update:", error.message);
            return {
                success: false,
                reason: "apply_error",
                message: error.message,
                error: error
            };
        }
    }
    /**
     * Force a hot update regardless of whether updates are available
     * @param options - Force update options
     * @returns Result object
     */ async forceUpdate(options = {}) {
        const opts = {
            createMinimalUpdate: true,
            ...options
        };
        try {
            this.log("Forcing update...");
            let updateData = opts.updateData;
            if (!updateData && opts.createMinimalUpdate) {
                // Create a minimal update for testing/force scenarios
                updateData = {
                    update: {
                        manifest: {
                            h:  true ? __webpack_require__.h() : 0,
                            c: this.getCurrentChunks(),
                            r: this.getCurrentChunks(),
                            m: this.getCurrentModules()
                        },
                        script: this.createMinimalScript(),
                        originalInfo: {
                            updateId: "force-update-" + Date.now(),
                            webpackHash:  true ? __webpack_require__.h() : 0
                        }
                    }
                };
            }
            if (!updateData) {
                throw new Error("No update data available and createMinimalUpdate is disabled");
            }
            return await this.applyUpdate(updateData);
        } catch (error) {
            this.log("Force update failed:", error.message);
            return {
                success: false,
                reason: "force_error",
                message: error.message,
                error: error
            };
        }
    }
    /**
     * Start automatic polling for updates
     * @param options - Polling options
     * @returns Polling control object
     */ startPolling(options = {}) {
        const opts = {
            interval: this.options.pollingInterval,
            forceMode: false,
            onUpdate: null,
            onError: null,
            ...options
        };
        if (this.pollingInterval) {
            this.log("Polling already active");
            return {
                stop: ()=>this.stopPolling()
            };
        }
        this.log(`Starting update polling (interval: ${opts.interval}ms, force: ${opts.forceMode})`);
        const pollFunction = async ()=>{
            try {
                let result;
                if (opts.forceMode) {
                    result = await this.forceUpdate();
                } else {
                    result = await this.checkForUpdates();
                }
                if (result.success && opts.onUpdate) {
                    opts.onUpdate(result);
                } else if (!result.success && opts.onError) {
                    opts.onError(result);
                }
            } catch (error) {
                this.log("Polling error:", error.message);
                if (opts.onError) {
                    opts.onError({
                        success: false,
                        reason: "check_error",
                        message: error.message,
                        error: error
                    });
                }
            }
        };
        // Run initial check
        pollFunction();
        // Start interval
        this.pollingInterval = setInterval(pollFunction, opts.interval);
        return {
            stop: ()=>this.stopPolling()
        };
    }
    /**
     * Stop automatic polling
     */ stopPolling() {
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
            this.pollingInterval = null;
            this.log("Polling stopped");
        }
    }
    /**
     * Get current HMR status and statistics
     * @returns Status object
     */ getStatus() {
        return {
            isAttached: this.isAttached,
            hasWebpackRequire: typeof __webpack_require__ !== "undefined",
            hasModuleHot:  true && !!module.hot,
            hotStatus: this.getHotStatus(),
            webpackHash: this.getWebpackHash(),
            isPolling: !!this.pollingInterval,
            hasUpdateProvider: !!this.updateProvider,
            stats: this.getStats()
        };
    }
    /**
     * Get update statistics
     * @returns Stats object
     */ getStats() {
        return {
            ...this.stats
        };
    }
    /**
     * Create a simple update provider from a URL endpoint
     * @param url - Update endpoint URL
     * @param options - Fetch options
     * @returns Update provider function
     */ static createHttpUpdateProvider(url, options = {}) {
        return async function httpUpdateProvider() {
            try {
                const response = await fetch(url, {
                    method: "GET",
                    headers: {
                        "Content-Type": "application/json",
                        ...options.headers
                    },
                    ...options
                });
                if (!response.ok) {
                    return {
                        update: null
                    };
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error("HTTP update provider error:", error);
                return {
                    update: null
                };
            }
        };
    }
    /**
     * Create an update provider from a queue of predefined updates
     * @param updates - Array of update objects
     * @returns Update provider function
     */ static createQueueUpdateProvider(updates = []) {
        let index = 0;
        return async function queueUpdateProvider() {
            if (index < updates.length) {
                const update = updates[index];
                index++;
                return {
                    update
                };
            }
            return {
                update: null
            };
        };
    }
    /**
     * Create an update provider from a callback function
     * @param callback - Callback function
     * @returns Update provider function
     */ static createCallbackUpdateProvider(callback) {
        return async function callbackUpdateProvider() {
            try {
                const currentHash =  true ? __webpack_require__.h() : 0;
                const result = await callback(currentHash);
                return result || {
                    update: null
                };
            } catch (error) {
                return {
                    update: null
                };
            }
        };
    }
    // Private helper methods
    log(message, ...args) {
        if (this.options.logging) {
            console.log(`[HMR Client] ${message}`, ...args);
        }
    }
    getHotStatus() {
        try {
            return  false ? 0 : "unavailable";
        } catch (error) {
            return "error";
        }
    }
    getWebpackHash() {
        try {
            return  true ? __webpack_require__.h() : 0;
        } catch (error) {
            return null;
        }
    }
    getCurrentChunks() {
        try {
            return  true ? Object.keys(__webpack_require__.hmrS_readFileVm || {}) : 0;
        } catch (error) {
            return [
                "index"
            ];
        }
    }
    getCurrentModules() {
        try {
            return  true ? Object.keys(__webpack_require__.c || {}) : 0;
        } catch (error) {
            return [];
        }
    }
    prepareChunkMap(update) {
        return {
            index: update.script || "exports.modules = {}; exports.runtime = function() {};"
        };
    }
    createMinimalScript() {
        return `
      exports.modules = {};
      exports.runtime = function(__webpack_require__) {
        // Minimal runtime update for force mode
        console.log('[HMR] Force update applied');
      };
    `;
    }
}
exports.HMRClient = HMRClient;
// Convenience function to create a new HMR client instance
function createHMRClient(options) {
    return new HMRClient(options);
} //# sourceMappingURL=hmr-client.js.map


/***/ }),

/***/ "../../packages/node/dist/src/utils/hot-reload.js":
/*!********************************************************!*\
  !*** ../../packages/node/dist/src/utils/hot-reload.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __importDefault = (void 0) && (void 0).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.federationHMRIntegration = exports.revalidate = exports.fetchRemote = exports.createFetcher = exports.checkFakeRemote = exports.checkMedusaConfigChange = exports.checkUnreachableRemote = exports.performReload = exports.triggerHMRUpdate = void 0;
exports.getFetchModule = getFetchModule;
const flush_chunks_1 = __webpack_require__(/*! ./flush-chunks */ "../../packages/node/dist/src/utils/flush-chunks.js");
const hmr_client_1 = __webpack_require__(/*! ./hmr-client */ "../../packages/node/dist/src/utils/hmr-client.js");
const crypto_1 = __importDefault(__webpack_require__(/*! crypto */ "crypto"));
const helpers_1 = __importDefault(__webpack_require__(/*! @module-federation/runtime/helpers */ "../../packages/runtime/dist/helpers.cjs.cjs"));
const hashmap = globalThis.mfHashMap || {};
globalThis.moduleGraphDirty = false;
/**
 * Initialize or get the global HMR client instance for Module Federation hot reload
 */ function getOrCreateHMRClient() {
    if (!globalThis.mfHMRClient) {
        globalThis.mfHMRClient = (0, hmr_client_1.createHMRClient)({
            autoAttach: true,
            logging: true,
            pollingInterval: 1000,
            maxRetries: 3
        });
        console.log("[Module Federation Hot Reload] HMR Client initialized");
    }
    return globalThis.mfHMRClient;
}
/**
 * Trigger HMR update when remote entry changes are detected
 * This is the primary integration point between Federation's change detection and HMR
 */ const triggerHMRUpdate = async ()=>{
    try {
        console.log("[Module Federation Hot Reload] Triggering HMR update for remote entry changes...");
        const hmrClient = getOrCreateHMRClient();
        const result = await hmrClient.forceUpdate({
            createMinimalUpdate: true
        });
        if (result.success) {
            console.log("[Module Federation Hot Reload] HMR update triggered successfully");
            return true;
        } else {
            console.warn("[Module Federation Hot Reload] Failed to trigger HMR update:", result.message);
            return false;
        }
    } catch (error) {
        console.error("[Module Federation Hot Reload] Error triggering HMR update:", error);
        return false;
    }
};
exports.triggerHMRUpdate = triggerHMRUpdate;
const performReload = async (shouldReload)=>{
    if (!shouldReload) {
        return false;
    }
    try {
        console.log("[Module Federation Hot Reload] Starting HMR-based reload...");
        const gs = new Function("return globalThis")();
        console.log("[Module Federation Hot Reload] Starting server-side nuclear reset...");
        // 1. Clear ALL webpack chunks and modules
        //@ts-ignore
        if (true) {
            console.log("[Module Federation Hot Reload] Clearing webpack require cache...");
            //@ts-ignore
            if (__webpack_require__.cache) {
                //@ts-ignore
                Object.keys(__webpack_require__.cache).forEach((id)=>{
                    //@ts-ignore
                    delete __webpack_require__.cache[id];
                });
            }
            // Clear chunk loading cache
            //@ts-ignore
            if (__webpack_require__.l && __webpack_require__.l.cache) {
                //@ts-ignore
                __webpack_require__.l.cache.clear();
            }
            // Clear chunk registry
            //@ts-ignore
            if (__webpack_require__.cache) {
                //@ts-ignore
                __webpack_require__.cache = {};
            }
        }
        // 2. Clear ALL federation instances and their caches (but preserve bundlerRuntime)
        //@ts-ignore
        if (gs.__FEDERATION__ && gs.__FEDERATION__.__INSTANCES__) {
            //@ts-ignore
            gs.__FEDERATION__.__INSTANCES__.forEach((instance)=>{
                // Preserve bundlerRuntime before clearing
                const preservedBundlerRuntime = instance.bundlerRuntime;
                // Clear module cache
                if (instance.moduleCache) {
                    instance.moduleCache.forEach((mc)=>{
                        if (mc.remoteInfo && mc.remoteInfo.entryGlobalName) {
                            delete gs[mc.remoteInfo.entryGlobalName];
                        }
                    });
                    instance.moduleCache.clear();
                }
                // Clear remote cache
                if (instance.remoteCache) {
                    instance.remoteCache.clear();
                }
                // Clear share scope map but preserve structure
                if (instance.shareScopeMap) {
                    Object.keys(instance.shareScopeMap).forEach((scope)=>{
                        if (instance.shareScopeMap[scope]) {
                            // Clear the contents but keep the scope structure
                            Object.keys(instance.shareScopeMap[scope]).forEach((pkg)=>{
                                delete instance.shareScopeMap[scope][pkg];
                            });
                        }
                    });
                }
                // Restore bundlerRuntime after clearing
                if (preservedBundlerRuntime) {
                    instance.bundlerRuntime = preservedBundlerRuntime;
                    console.log("[Module Federation Hot Reload] Preserved bundlerRuntime for instance:", instance.name);
                }
            // Don't delete instance global, just clear its caches
            // if (gs[instance.name]) {
            //   delete gs[instance.name];
            // }
            });
        // Don't clear the instances array completely, just their caches
        // gs.__FEDERATION__.__INSTANCES__ = [];
        }
        // 3. Clear federation-related webpack instances (preserve bundlerRuntime)
        //@ts-ignore
        if (__webpack_require__?.federation) {
            //@ts-ignore
            if (__webpack_require__.federation?.instance) {
                // Preserve bundlerRuntime
                //@ts-ignore
                const preservedBundlerRuntime = __webpack_require__.federation.instance.bundlerRuntime;
                //@ts-ignore
                __webpack_require__.federation.instance.moduleCache?.clear();
                //@ts-ignore
                __webpack_require__.federation.instance.remoteCache?.clear();
                // Restore bundlerRuntime
                if (preservedBundlerRuntime) {
                    //@ts-ignore
                    __webpack_require__.federation.instance.bundlerRuntime = preservedBundlerRuntime;
                    console.log("[Module Federation Hot Reload] Preserved webpack federation bundlerRuntime");
                }
            // Don't delete the instance completely
            // delete __webpack_require__.federation.instance;
            }
        // Don't delete federation completely
        // delete __webpack_require__.federation;
        }
        // 4. Clear ALL Next.js related caches
        if (gs.__NEXT_DATA__) {
            delete gs.__NEXT_DATA__;
        }
        // Clear Next.js module cache for federation modules
        if (gs.__webpack_require__ && gs.__webpack_require__.cache) {
            Object.keys(gs.__webpack_require__.cache).forEach((moduleId)=>{
                // Clear federation module entries
                if (moduleId.includes("shop/") || moduleId.includes("checkout/") || moduleId.includes("webpack_container_remote") || moduleId.includes("federation")) {
                    console.log(`[Module Federation Hot Reload] Clearing Next.js cache for: ${moduleId}`);
                    delete gs.__webpack_require__.cache[moduleId];
                }
            });
        }
        // Clear Next.js build manifests that might cache federation modules
        if (gs.__BUILD_MANIFEST) {
            delete gs.__BUILD_MANIFEST;
        }
        if (gs.__BUILD_MANIFEST_CB) {
            delete gs.__BUILD_MANIFEST_CB;
        }
        // 5. Clear ALL federation globals and registries
        helpers_1.default.global.resetFederationGlobalInfo();
        // Reset ALL federation-related globals
        globalThis.moduleGraphDirty = false;
        globalThis.mfHashMap = {};
        if (gs.usedChunks) {
            gs.usedChunks.clear();
        }
        // Clear manifest and runtime caches
        if (gs.__FEDERATION_MANIFEST_CACHE__) {
            gs.__FEDERATION_MANIFEST_CACHE__ = {};
        }
        if (gs.__FEDERATION_RUNTIME__) {
            delete gs.__FEDERATION_RUNTIME__;
        }
        // Clear any shared scope maps
        if (gs.__FEDERATION_SHARED__) {
            delete gs.__FEDERATION_SHARED__;
        }
        // 6. Clear selective remote entry globals (avoid critical runtime components)
        Object.keys(gs).forEach((key)=>{
            // Only clear globals that are clearly cache-related, not runtime components
            if (key.includes("remote") && !key.includes("Runtime") || key.includes("Remote") && !key.includes("Runtime") || key.includes("mf_") || key.includes("container") && key.includes("cache") || key.includes("Container") && key.includes("cache") || key.includes("_cache") || key.includes("Cache")) {
                try {
                    // Double check this isn't a critical runtime component
                    if (!key.includes("bundlerRuntime") && !key.includes("Runtime") && !key.includes("__FEDERATION__") && !key.includes("__webpack_require__")) {
                        delete gs[key];
                        console.log(`[Module Federation Hot Reload] Cleared global: ${key}`);
                    }
                } catch (e) {
                // Some globals might be non-configurable
                }
            }
        });
        // 7. Force garbage collection if available
        //@ts-ignore
        if (global.gc) {
            //@ts-ignore
            global.gc();
            console.log("[Module Federation Hot Reload] Forced garbage collection");
        }
        console.log("[Module Federation Hot Reload] NUCLEAR RESET COMPLETE - all modules and chunks cleared");
        // Use HMR client for hot module replacement
        const hmrClient = getOrCreateHMRClient();
        const result = await hmrClient.forceUpdate({
            createMinimalUpdate: true
        });
        if (result.success) {
            console.log("[Module Federation Hot Reload] HMR update applied successfully");
            return true;
        } else {
            console.warn("[Module Federation Hot Reload] HMR update failed:", result.message);
            // Fallback: Nuclear reset already happened, now force complete reinitialization
            console.log("[Module Federation Hot Reload] Primary HMR failed, forcing complete reinitialization...");
            try {
                // Method 1: Force complete webpack chunk invalidation
                //@ts-ignore
                if (true) {
                    console.log("[Module Federation Hot Reload] Forcing webpack chunk invalidation...");
                    // Clear ALL webpack caches aggressively
                    //@ts-ignore
                    if (__webpack_require__.cache) {
                        //@ts-ignore
                        Object.keys(__webpack_require__.cache).forEach((id)=>{
                            try {
                                //@ts-ignore
                                delete __webpack_require__.cache[id];
                            } catch (e) {}
                        });
                        //@ts-ignore
                        __webpack_require__.cache = {};
                    }
                    // Force clear chunk loading functions
                    //@ts-ignore
                    if (__webpack_require__.l) {
                        //@ts-ignore
                        __webpack_require__.l.cache = new Map();
                    }
                    // Reset webpack chunk registry
                    //@ts-ignore
                    if (__webpack_require__.O) {
                        //@ts-ignore
                        __webpack_require__.O.j = {};
                    }
                }
                // Method 2: Force federation runtime reinitialization
                console.log("[Module Federation Hot Reload] Forcing federation runtime reinitialization...");
                const gs = new Function("return globalThis")();
                // Force recreate federation instances from scratch
                //@ts-ignore
                if (gs.__FEDERATION__) {
                    //@ts-ignore
                    gs.__FEDERATION__ = {
                        __INSTANCES__: [],
                        __SHARE_SCOPE__: {},
                        __GLOBAL_LOADING_DATA__: {}
                    };
                }
                // Method 3: Force Next.js to reinitialize
                //@ts-ignore
                if (globalThis.webpackHotUpdate) {
                    console.log("[Module Federation Hot Reload] Triggering Next.js complete refresh...");
                    try {
                        //@ts-ignore
                        globalThis.webpackHotUpdate();
                    } catch (e) {
                        console.log("[Module Federation Hot Reload] Next.js refresh failed, continuing...");
                    }
                }
                // Method 4: Force browser to treat everything as fresh
                console.log("[Module Federation Hot Reload] Marking all modules as dirty for browser reload...");
                // Set flags that will force fresh loading on next request
                globalThis.moduleGraphDirty = true;
                //@ts-ignore
                globalThis.federationNuclearReset = Date.now();
                console.log("[Module Federation Hot Reload] Complete reinitialization successful!");
                return true;
            } catch (fallbackError) {
                console.warn("[Module Federation Hot Reload] Complete reinitialization failed:", fallbackError);
                // Final fallback: At least we've cleared everything, mark for fresh start
                globalThis.moduleGraphDirty = true;
                //@ts-ignore
                globalThis.federationNuclearReset = Date.now();
                console.log("[Module Federation Hot Reload] Nuclear reset completed, next request will be fresh");
                return true;
            }
        }
    } catch (error) {
        console.error("[Module Federation Hot Reload] Error during HMR-based reload:", error);
        return false;
    }
};
exports.performReload = performReload;
const checkUnreachableRemote = (remoteScope)=>{
    for(const property in remoteScope.remotes){
        if (!remoteScope[property]) {
            console.error("unreachable remote found", property, "hot reloading to refetch");
            return true;
        }
    }
    return false;
};
exports.checkUnreachableRemote = checkUnreachableRemote;
const checkMedusaConfigChange = (remoteScope, fetchModule)=>{
    //@ts-ignore
    if (remoteScope._medusa) {
        //@ts-ignore
        for(const property in remoteScope._medusa){
            fetchModule(property).then((res)=>res.json()).then((medusaResponse)=>{
                if (medusaResponse.version !== //@ts-ignore
                remoteScope?._medusa[property].version) {
                    console.log("medusa config changed", property, "hot reloading to refetch");
                    (0, exports.performReload)(true);
                    return true;
                }
            });
        }
    }
    return false;
};
exports.checkMedusaConfigChange = checkMedusaConfigChange;
const checkFakeRemote = (remoteScope)=>{
    for(const property in remoteScope._config){
        let remote = remoteScope._config[property];
        const resolveRemote = async ()=>{
            remote = await remote();
        };
        if (typeof remote === "function") {
            resolveRemote();
        }
        if (remote.fake) {
            console.log("fake remote found", property, "hot reloading to refetch");
            return true;
        }
    }
    return false;
};
exports.checkFakeRemote = checkFakeRemote;
const createFetcher = (url, fetchModule, name, cb)=>{
    console.log(`[Module Federation Debug] Creating fetcher for remote '${name}' at URL: ${url}`);
    return fetchModule(url).then((re)=>{
        console.log(`[Module Federation Debug] Fetch response for '${name}' - status: ${re.status}, ok: ${re.ok}`);
        if (!re.ok) {
            throw new Error(`Error loading remote: status: ${re.status}, content-type: ${re.headers.get("content-type")}`);
        }
        return re.text();
    }).then((contents)=>{
        const hash = crypto_1.default.createHash("md5").update(contents).digest("hex");
        console.log(`[Module Federation Debug] Generated hash for '${name}': ${hash} (content length: ${contents.length})`);
        cb(hash);
    }).catch((e)=>{
        console.error("Remote", name, url, "Failed to load or is not online", e);
    });
};
exports.createFetcher = createFetcher;
/**
 * Custom update check function that compares hash values
 * Uses HMR client to force apply updates when differences are detected
 */ const checkForUpdates = async (remoteName, newHash)=>{
    const currentHash = hashmap[remoteName];
    console.log(`[Module Federation Debug] checkForUpdates called for '${remoteName}' - currentHash: ${currentHash}, newHash: ${newHash}`);
    if (currentHash && currentHash !== newHash) {
        console.log(`[Module Federation HMR] Hash difference detected for ${remoteName}`);
        console.log(`[Module Federation HMR] Old hash: ${currentHash}, New hash: ${newHash}`);
        // Update the hash map
        hashmap[remoteName] = newHash;
        console.log(`[Module Federation Debug] Updated hashmap for '${remoteName}' with new hash`);
        // Use HMR client to force apply update
        const hmrClient = getOrCreateHMRClient();
        console.log(`[Module Federation Debug] Triggering HMR update for '${remoteName}'...`);
        const result = await hmrClient.forceUpdate({
            createMinimalUpdate: true
        });
        if (result.success) {
            console.log(`[Module Federation HMR] Successfully applied HMR update for ${remoteName}`);
            return true;
        } else {
            console.warn(`[Module Federation HMR] Failed to apply HMR update for ${remoteName}:`, result.message);
            return false;
        }
    } else if (!currentHash) {
        // First time seeing this remote, just store the hash
        console.log(`[Module Federation Debug] First time seeing remote '${remoteName}', storing hash: ${newHash}`);
        hashmap[remoteName] = newHash;
    } else {
        console.log(`[Module Federation Debug] No hash change detected for '${remoteName}' (current: ${currentHash}, new: ${newHash})`);
    }
    return false;
};
const fetchRemote = (remoteScope, fetchModule)=>{
    const fetches = [];
    let needReload = false;
    for(const property in remoteScope){
        const name = property;
        const container = remoteScope[property];
        const url = container.entry;
        const fetcher = (0, exports.createFetcher)(url, fetchModule, name, async (hash)=>{
            const updateApplied = await checkForUpdates(name, hash);
            if (updateApplied) {
                needReload = true;
            }
        });
        fetches.push(fetcher);
    }
    return Promise.all(fetches).then(()=>{
        return needReload;
    });
};
exports.fetchRemote = fetchRemote;
//@ts-ignore
/**
 * Revalidate remote entries and trigger HMR updates when changes are detected
 * This function detects remote entry changes and uses the HMR client for hot updates
 */ /**
 * Check for remote entry updates and apply HMR if changes are detected
 * This is the main entry point used by Next.js _document and other integration points
 */ const revalidate = async (fetchModule = getFetchModule() || (()=>undefined), force = false)=>{
    let hasRemoteChanges = false;
    // Check for remote changes on both server and client side
    if (true) {
        // Server-side: Check for remote changes and log detailed info
        console.log("[Module Federation] Server-side revalidate called - checking for remote changes");
        console.log("[Module Federation Debug] fetchModule available:", !!fetchModule);
        console.log("[Module Federation Debug] force parameter:", force);
        try {
            const remotesFromAPI = (0, flush_chunks_1.getAllKnownRemotes)();
            console.log("[Module Federation Debug] Known remotes:", Object.keys(remotesFromAPI));
            for(const remoteName in remotesFromAPI){
                const container = remotesFromAPI[remoteName];
                const url = container.entry;
                console.log(`[Module Federation Debug] Checking remote '${remoteName}' at ${url}`);
                if (!url) continue;
                try {
                    const response = await fetchModule(url);
                    const content = await response.text();
                    const newHash = crypto_1.default.createHash("md5").update(content).digest("hex");
                    const currentHash = hashmap[remoteName];
                    console.log(`[Module Federation Debug] Remote '${remoteName}' hash - current: ${currentHash}, new: ${newHash}`);
                    if (currentHash && currentHash !== newHash) {
                        console.log(`[Module Federation] 🔥 SERVER-SIDE REMOTE CHANGE DETECTED for '${remoteName}'!`);
                        console.log(`[Module Federation] Old hash: ${currentHash}`);
                        console.log(`[Module Federation] New hash: ${newHash}`);
                        // Update hash even on server-side
                        hashmap[remoteName] = newHash;
                        // Set flags for immediate HMR processing
                        globalThis.moduleGraphDirty = true;
                        hasRemoteChanges = true;
                        force = true; // Force HMR processing
                        console.log(`[Module Federation] 🔥 Marking module graph as DIRTY - will attempt immediate HMR!`);
                    } else if (!currentHash) {
                        console.log(`[Module Federation Debug] First time seeing remote '${remoteName}', storing hash`);
                        hashmap[remoteName] = newHash;
                    }
                } catch (error) {
                    console.warn(`[Module Federation Debug] Error checking remote '${remoteName}':`, error);
                }
            }
        } catch (error) {
            console.error("[Module Federation Debug] Error in server-side revalidate:", error);
        }
        // If no changes detected on server-side, return early
        if (!hasRemoteChanges && !force) {
            return false;
        }
    }
    if (globalThis.moduleGraphDirty || force) {
        console.log(`[Module Federation] 🚀 TRIGGERING FORCE RELOAD - moduleGraphDirty: ${globalThis.moduleGraphDirty}, force: ${force}`);
        return await exports.federationHMRIntegration.forceReload();
    }
    // Use the new HMR integration to check and apply updates
    return await exports.federationHMRIntegration.checkAndApplyUpdates();
};
exports.revalidate = revalidate;
function getFetchModule() {
    //@ts-ignore
    const loadedModule = //@ts-ignore
    globalThis.webpackChunkLoad || global.webpackChunkLoad || global.fetch;
    if (loadedModule) {
        return loadedModule;
    }
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const nodeFetch = __webpack_require__(/*! node-fetch */ "../../node_modules/.pnpm/node-fetch@2.7.0_encoding@0.1.13/node_modules/node-fetch/lib/index.js");
    return nodeFetch.default || nodeFetch;
}
/**
 * Enhanced integration function for Module Federation + HMR
 * This provides a clean interface for external code to trigger HMR-based reloads
 * when federation remote entries change
 */ exports.federationHMRIntegration = {
    /**
     * Initialize HMR client for federation hot reload
     */ init () {
        return getOrCreateHMRClient();
    },
    /**
     * Check for updates on all known remotes
     * This is the main method to use for manual update checking, like in Next.js _document
     */ async checkForUpdates () {
        try {
            const remotesFromAPI = (0, flush_chunks_1.getAllKnownRemotes)();
            const updatedRemotes = [];
            let hasUpdates = false;
            // Check each remote for updates
            for(const remoteName in remotesFromAPI){
                const container = remotesFromAPI[remoteName];
                const url = container.entry;
                if (!url) continue;
                try {
                    const response = await getFetchModule()(url);
                    const content = await response.text();
                    const newHash = crypto_1.default.createHash("md5").update(content).digest("hex");
                    const currentHash = hashmap[remoteName];
                    if (currentHash && currentHash !== newHash) {
                        console.log(`[Module Federation HMR] Update detected for remote '${remoteName}'`);
                        updatedRemotes.push(remoteName);
                        hasUpdates = true;
                        hashmap[remoteName] = newHash;
                    } else if (!currentHash) {
                        // First time seeing this remote
                        hashmap[remoteName] = newHash;
                    }
                } catch (error) {
                    console.warn(`[Module Federation HMR] Error checking remote '${remoteName}':`, error);
                }
            }
            return {
                hasUpdates,
                updatedRemotes
            };
        } catch (error) {
            console.error("[Module Federation HMR] Error checking for updates:", error);
            return {
                hasUpdates: false,
                updatedRemotes: []
            };
        }
    },
    /**
     * Apply HMR updates if any are detected
     * Returns true if updates were successfully applied
     */ async applyUpdates () {
        return await (0, exports.triggerHMRUpdate)();
    },
    /**
     * Check for updates and apply them if found
     * This combines checkForUpdates() and applyUpdates() in one call
     * This is what revalidate() uses internally
     */ async checkAndApplyUpdates () {
        const { hasUpdates } = await this.checkForUpdates();
        if (hasUpdates) {
            return await this.applyUpdates();
        }
        return false;
    },
    /**
     * Force HMR reload regardless of change detection
     */ async forceReload () {
        console.log("[Module Federation HMR] Forcing HMR reload...");
        return await (0, exports.performReload)(true);
    },
    /**
     * Get HMR client status and statistics
     */ getStatus () {
        try {
            const hmrClient = getOrCreateHMRClient();
            return {
                ...hmrClient.getStatus(),
                knownRemotes: Object.keys((0, flush_chunks_1.getAllKnownRemotes)()),
                remoteHashes: {
                    ...hashmap
                }
            };
        } catch (error) {
            console.error("[Module Federation HMR] Error getting status:", error);
            return null;
        }
    }
}; //# sourceMappingURL=hot-reload.js.map


/***/ }),

/***/ "../../packages/node/dist/src/utils/index.js":
/*!***************************************************!*\
  !*** ../../packages/node/dist/src/utils/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
__exportStar(__webpack_require__(/*! ./hot-reload */ "../../packages/node/dist/src/utils/hot-reload.js"), exports);
__exportStar(__webpack_require__(/*! ./flush-chunks */ "../../packages/node/dist/src/utils/flush-chunks.js"), exports);
__exportStar(__webpack_require__(/*! ./hmr-client */ "../../packages/node/dist/src/utils/hmr-client.js"), exports);
__exportStar(__webpack_require__(/*! ./hmr-runtime */ "../../packages/node/dist/src/utils/hmr-runtime.js"), exports);
__exportStar(__webpack_require__(/*! ./custom-hmr-helpers */ "../../packages/node/dist/src/utils/custom-hmr-helpers.js"), exports);
__exportStar(__webpack_require__(/*! ./hmr-runtime-patch */ "../../packages/node/dist/src/utils/hmr-runtime-patch.js"), exports); //# sourceMappingURL=index.js.map


/***/ }),

/***/ "../../packages/runtime-core/dist sync recursive":
/*!**********************************************!*\
  !*** ../../packages/runtime-core/dist/ sync ***!
  \**********************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "../../packages/runtime-core/dist sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "../../packages/runtime-core/dist/index.cjs.cjs":
/*!******************************************************!*\
  !*** ../../packages/runtime-core/dist/index.cjs.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "../../node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var polyfills = __webpack_require__(/*! ./polyfills.cjs.cjs */ "../../packages/runtime-core/dist/polyfills.cjs.cjs");
var sdk = __webpack_require__(/*! @module-federation/sdk */ "../../packages/sdk/dist/index.cjs.cjs");
var errorCodes = __webpack_require__(/*! @module-federation/error-codes */ "../../packages/error-codes/dist/index.cjs.js");
const LOG_CATEGORY = "[ Federation Runtime ]";
// FIXME: pre-bundle ?
const logger = sdk.createLogger(LOG_CATEGORY);
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function assert(condition, msg) {
    if (!condition) {
        error(msg);
    }
}
function error(msg) {
    if (msg instanceof Error) {
        msg.message = `${LOG_CATEGORY}: ${msg.message}`;
        throw msg;
    }
    throw new Error(`${LOG_CATEGORY}: ${msg}`);
}
function warn(msg) {
    if (msg instanceof Error) {
        msg.message = `${LOG_CATEGORY}: ${msg.message}`;
        logger.warn(msg);
    } else {
        logger.warn(msg);
    }
}
function addUniqueItem(arr, item) {
    if (arr.findIndex((name)=>name === item) === -1) {
        arr.push(item);
    }
    return arr;
}
function getFMId(remoteInfo) {
    if ("version" in remoteInfo && remoteInfo.version) {
        return `${remoteInfo.name}:${remoteInfo.version}`;
    } else if ("entry" in remoteInfo && remoteInfo.entry) {
        return `${remoteInfo.name}:${remoteInfo.entry}`;
    } else {
        return `${remoteInfo.name}`;
    }
}
function isRemoteInfoWithEntry(remote) {
    return typeof remote.entry !== "undefined";
}
function isPureRemoteEntry(remote) {
    return !remote.entry.includes(".json");
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function safeWrapper(callback, disableWarn) {
    try {
        const res = await callback();
        return res;
    } catch (e) {
        !disableWarn && warn(e);
        return;
    }
}
function isObject(val) {
    return val && typeof val === "object";
}
const objectToString = Object.prototype.toString;
// eslint-disable-next-line @typescript-eslint/ban-types
function isPlainObject(val) {
    return objectToString.call(val) === "[object Object]";
}
function isStaticResourcesEqual(url1, url2) {
    const REG_EXP = /^(https?:)?\/\//i;
    // Transform url1 and url2 into relative paths
    const relativeUrl1 = url1.replace(REG_EXP, "").replace(/\/$/, "");
    const relativeUrl2 = url2.replace(REG_EXP, "").replace(/\/$/, "");
    // Check if the relative paths are identical
    return relativeUrl1 === relativeUrl2;
}
function arrayOptions(options) {
    return Array.isArray(options) ? options : [
        options
    ];
}
function getRemoteEntryInfoFromSnapshot(snapshot) {
    const defaultRemoteEntryInfo = {
        url: "",
        type: "global",
        globalName: ""
    };
    if (sdk.isBrowserEnv() || sdk.isReactNativeEnv()) {
        return "remoteEntry" in snapshot ? {
            url: snapshot.remoteEntry,
            type: snapshot.remoteEntryType,
            globalName: snapshot.globalName
        } : defaultRemoteEntryInfo;
    }
    if ("ssrRemoteEntry" in snapshot) {
        return {
            url: snapshot.ssrRemoteEntry || defaultRemoteEntryInfo.url,
            type: snapshot.ssrRemoteEntryType || defaultRemoteEntryInfo.type,
            globalName: snapshot.globalName
        };
    }
    return defaultRemoteEntryInfo;
}
const processModuleAlias = (name, subPath)=>{
    // @host/ ./button -> @host/button
    let moduleName;
    if (name.endsWith("/")) {
        moduleName = name.slice(0, -1);
    } else {
        moduleName = name;
    }
    if (subPath.startsWith(".")) {
        subPath = subPath.slice(1);
    }
    moduleName = moduleName + subPath;
    return moduleName;
};
const CurrentGlobal = typeof globalThis === "object" ? globalThis : window;
const nativeGlobal = (()=>{
    try {
        // get real window (incase of sandbox)
        return document.defaultView;
    } catch (e) {
        // node env
        return CurrentGlobal;
    }
})();
const Global = nativeGlobal;
function definePropertyGlobalVal(target, key, val) {
    Object.defineProperty(target, key, {
        value: val,
        configurable: false,
        writable: true
    });
}
function includeOwnProperty(target, key) {
    return Object.hasOwnProperty.call(target, key);
}
// This section is to prevent encapsulation by certain microfrontend frameworks. Due to reuse policies, sandbox escapes.
// The sandbox in the microfrontend does not replicate the value of 'configurable'.
// If there is no loading content on the global object, this section defines the loading object.
if (!includeOwnProperty(CurrentGlobal, "__GLOBAL_LOADING_REMOTE_ENTRY__")) {
    definePropertyGlobalVal(CurrentGlobal, "__GLOBAL_LOADING_REMOTE_ENTRY__", {});
}
const globalLoading = CurrentGlobal.__GLOBAL_LOADING_REMOTE_ENTRY__;
function setGlobalDefaultVal(target) {
    var _target___FEDERATION__, _target___FEDERATION__1, _target___FEDERATION__2, _target___FEDERATION__3, _target___FEDERATION__4, _target___FEDERATION__5;
    if (includeOwnProperty(target, "__VMOK__") && !includeOwnProperty(target, "__FEDERATION__")) {
        definePropertyGlobalVal(target, "__FEDERATION__", target.__VMOK__);
    }
    if (!includeOwnProperty(target, "__FEDERATION__")) {
        definePropertyGlobalVal(target, "__FEDERATION__", {
            __GLOBAL_PLUGIN__: [],
            __INSTANCES__: [],
            moduleInfo: {},
            __SHARE__: {},
            __MANIFEST_LOADING__: {},
            __PRELOADED_MAP__: new Map()
        });
        definePropertyGlobalVal(target, "__VMOK__", target.__FEDERATION__);
    }
    var ___GLOBAL_PLUGIN__;
    (___GLOBAL_PLUGIN__ = (_target___FEDERATION__ = target.__FEDERATION__).__GLOBAL_PLUGIN__) != null ? ___GLOBAL_PLUGIN__ : _target___FEDERATION__.__GLOBAL_PLUGIN__ = [];
    var ___INSTANCES__;
    (___INSTANCES__ = (_target___FEDERATION__1 = target.__FEDERATION__).__INSTANCES__) != null ? ___INSTANCES__ : _target___FEDERATION__1.__INSTANCES__ = [];
    var _moduleInfo;
    (_moduleInfo = (_target___FEDERATION__2 = target.__FEDERATION__).moduleInfo) != null ? _moduleInfo : _target___FEDERATION__2.moduleInfo = {};
    var ___SHARE__;
    (___SHARE__ = (_target___FEDERATION__3 = target.__FEDERATION__).__SHARE__) != null ? ___SHARE__ : _target___FEDERATION__3.__SHARE__ = {};
    var ___MANIFEST_LOADING__;
    (___MANIFEST_LOADING__ = (_target___FEDERATION__4 = target.__FEDERATION__).__MANIFEST_LOADING__) != null ? ___MANIFEST_LOADING__ : _target___FEDERATION__4.__MANIFEST_LOADING__ = {};
    var ___PRELOADED_MAP__;
    (___PRELOADED_MAP__ = (_target___FEDERATION__5 = target.__FEDERATION__).__PRELOADED_MAP__) != null ? ___PRELOADED_MAP__ : _target___FEDERATION__5.__PRELOADED_MAP__ = new Map();
}
setGlobalDefaultVal(CurrentGlobal);
setGlobalDefaultVal(nativeGlobal);
function resetFederationGlobalInfo() {
    CurrentGlobal.__FEDERATION__.__GLOBAL_PLUGIN__ = [];
    CurrentGlobal.__FEDERATION__.__INSTANCES__ = [];
    CurrentGlobal.__FEDERATION__.moduleInfo = {};
    CurrentGlobal.__FEDERATION__.__SHARE__ = {};
    CurrentGlobal.__FEDERATION__.__MANIFEST_LOADING__ = {};
    Object.keys(globalLoading).forEach((key)=>{
        delete globalLoading[key];
    });
}
function setGlobalFederationInstance(FederationInstance) {
    CurrentGlobal.__FEDERATION__.__INSTANCES__.push(FederationInstance);
}
function getGlobalFederationConstructor() {
    return CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR__;
}
function setGlobalFederationConstructor(FederationConstructor, isDebug = sdk.isDebugMode()) {
    if (isDebug) {
        CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = FederationConstructor;
        CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = "0.15.0";
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
function getInfoWithoutType(target, key) {
    if (typeof key === "string") {
        const keyRes = target[key];
        if (keyRes) {
            return {
                value: target[key],
                key: key
            };
        } else {
            const targetKeys = Object.keys(target);
            for (const targetKey of targetKeys){
                const [targetTypeOrName, _] = targetKey.split(":");
                const nKey = `${targetTypeOrName}:${key}`;
                const typeWithKeyRes = target[nKey];
                if (typeWithKeyRes) {
                    return {
                        value: typeWithKeyRes,
                        key: nKey
                    };
                }
            }
            return {
                value: undefined,
                key: key
            };
        }
    } else {
        throw new Error("key must be string");
    }
}
const getGlobalSnapshot = ()=>nativeGlobal.__FEDERATION__.moduleInfo;
const getTargetSnapshotInfoByModuleInfo = (moduleInfo, snapshot)=>{
    // Check if the remote is included in the hostSnapshot
    const moduleKey = getFMId(moduleInfo);
    const getModuleInfo = getInfoWithoutType(snapshot, moduleKey).value;
    // The remoteSnapshot might not include a version
    if (getModuleInfo && !getModuleInfo.version && "version" in moduleInfo && moduleInfo["version"]) {
        getModuleInfo.version = moduleInfo["version"];
    }
    if (getModuleInfo) {
        return getModuleInfo;
    }
    // If the remote is not included in the hostSnapshot, deploy a micro app snapshot
    if ("version" in moduleInfo && moduleInfo["version"]) {
        const { version } = moduleInfo, resModuleInfo = polyfills._object_without_properties_loose(moduleInfo, [
            "version"
        ]);
        const moduleKeyWithoutVersion = getFMId(resModuleInfo);
        const getModuleInfoWithoutVersion = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, moduleKeyWithoutVersion).value;
        if ((getModuleInfoWithoutVersion == null ? void 0 : getModuleInfoWithoutVersion.version) === version) {
            return getModuleInfoWithoutVersion;
        }
    }
    return;
};
const getGlobalSnapshotInfoByModuleInfo = (moduleInfo)=>getTargetSnapshotInfoByModuleInfo(moduleInfo, nativeGlobal.__FEDERATION__.moduleInfo);
const setGlobalSnapshotInfoByModuleInfo = (remoteInfo, moduleDetailInfo)=>{
    const moduleKey = getFMId(remoteInfo);
    nativeGlobal.__FEDERATION__.moduleInfo[moduleKey] = moduleDetailInfo;
    return nativeGlobal.__FEDERATION__.moduleInfo;
};
const addGlobalSnapshot = (moduleInfos)=>{
    nativeGlobal.__FEDERATION__.moduleInfo = polyfills._extends({}, nativeGlobal.__FEDERATION__.moduleInfo, moduleInfos);
    return ()=>{
        const keys = Object.keys(moduleInfos);
        for (const key of keys){
            delete nativeGlobal.__FEDERATION__.moduleInfo[key];
        }
    };
};
const getRemoteEntryExports = (name, globalName)=>{
    const remoteEntryKey = globalName || `__FEDERATION_${name}:custom__`;
    const entryExports = CurrentGlobal[remoteEntryKey];
    return {
        remoteEntryKey,
        entryExports
    };
};
// This function is used to register global plugins.
// It iterates over the provided plugins and checks if they are already registered.
// If a plugin is not registered, it is added to the global plugins.
// If a plugin is already registered, a warning message is logged.
const registerGlobalPlugins = (plugins)=>{
    const { __GLOBAL_PLUGIN__ } = nativeGlobal.__FEDERATION__;
    plugins.forEach((plugin)=>{
        if (__GLOBAL_PLUGIN__.findIndex((p)=>p.name === plugin.name) === -1) {
            __GLOBAL_PLUGIN__.push(plugin);
        } else {
            warn(`The plugin ${plugin.name} has been registered.`);
        }
    });
};
const getGlobalHostPlugins = ()=>nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__;
const getPreloaded = (id)=>CurrentGlobal.__FEDERATION__.__PRELOADED_MAP__.get(id);
const setPreloaded = (id)=>CurrentGlobal.__FEDERATION__.__PRELOADED_MAP__.set(id, true);
const DEFAULT_SCOPE = "default";
const DEFAULT_REMOTE_TYPE = "global";
// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// those constants are based on https://www.rubydoc.info/gems/semantic_range/3.0.0/SemanticRange#BUILDIDENTIFIER-constant
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
const buildIdentifier = "[0-9A-Za-z-]+";
const build = `(?:\\+(${buildIdentifier}(?:\\.${buildIdentifier})*))`;
const numericIdentifier = "0|[1-9]\\d*";
const numericIdentifierLoose = "[0-9]+";
const nonNumericIdentifier = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
const preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`;
const preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\.${preReleaseIdentifierLoose})*))`;
const preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`;
const preRelease = `(?:-(${preReleaseIdentifier}(?:\\.${preReleaseIdentifier})*))`;
const xRangeIdentifier = `${numericIdentifier}|x|X|\\*`;
const xRangePlain = `[v=\\s]*(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`;
const hyphenRange = `^\\s*(${xRangePlain})\\s+-\\s+(${xRangePlain})\\s*$`;
const mainVersionLoose = `(${numericIdentifierLoose})\\.(${numericIdentifierLoose})\\.(${numericIdentifierLoose})`;
const loosePlain = `[v=\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`;
const gtlt = "((?:<|>)?=?)";
const comparatorTrim = `(\\s*)${gtlt}\\s*(${loosePlain}|${xRangePlain})`;
const loneTilde = "(?:~>?)";
const tildeTrim = `(\\s*)${loneTilde}\\s+`;
const loneCaret = "(?:\\^)";
const caretTrim = `(\\s*)${loneCaret}\\s+`;
const star = "(<|>)?=?\\s*\\*";
const caret = `^${loneCaret}${xRangePlain}$`;
const mainVersion = `(${numericIdentifier})\\.(${numericIdentifier})\\.(${numericIdentifier})`;
const fullPlain = `v?${mainVersion}${preRelease}?${build}?`;
const tilde = `^${loneTilde}${xRangePlain}$`;
const xRange = `^${gtlt}\\s*${xRangePlain}$`;
const comparator = `^${gtlt}\\s*(${fullPlain})$|^$`;
// copy from semver package
const gte0 = "^\\s*>=\\s*0.0.0\\s*$";
// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function parseRegex(source) {
    return new RegExp(source);
}
function isXVersion(version) {
    return !version || version.toLowerCase() === "x" || version === "*";
}
function pipe(...fns) {
    return (x)=>fns.reduce((v, f)=>f(v), x);
}
function extractComparator(comparatorString) {
    return comparatorString.match(parseRegex(comparator));
}
function combineVersion(major, minor, patch, preRelease) {
    const mainVersion = `${major}.${minor}.${patch}`;
    if (preRelease) {
        return `${mainVersion}-${preRelease}`;
    }
    return mainVersion;
}
// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function parseHyphen(range) {
    return range.replace(parseRegex(hyphenRange), (_range, from, fromMajor, fromMinor, fromPatch, _fromPreRelease, _fromBuild, to, toMajor, toMinor, toPatch, toPreRelease)=>{
        if (isXVersion(fromMajor)) {
            from = "";
        } else if (isXVersion(fromMinor)) {
            from = `>=${fromMajor}.0.0`;
        } else if (isXVersion(fromPatch)) {
            from = `>=${fromMajor}.${fromMinor}.0`;
        } else {
            from = `>=${from}`;
        }
        if (isXVersion(toMajor)) {
            to = "";
        } else if (isXVersion(toMinor)) {
            to = `<${Number(toMajor) + 1}.0.0-0`;
        } else if (isXVersion(toPatch)) {
            to = `<${toMajor}.${Number(toMinor) + 1}.0-0`;
        } else if (toPreRelease) {
            to = `<=${toMajor}.${toMinor}.${toPatch}-${toPreRelease}`;
        } else {
            to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
    });
}
function parseComparatorTrim(range) {
    return range.replace(parseRegex(comparatorTrim), "$1$2$3");
}
function parseTildeTrim(range) {
    return range.replace(parseRegex(tildeTrim), "$1~");
}
function parseCaretTrim(range) {
    return range.replace(parseRegex(caretTrim), "$1^");
}
function parseCarets(range) {
    return range.trim().split(/\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(caret), (_, major, minor, patch, preRelease)=>{
            if (isXVersion(major)) {
                return "";
            } else if (isXVersion(minor)) {
                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;
            } else if (isXVersion(patch)) {
                if (major === "0") {
                    return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;
                } else {
                    return `>=${major}.${minor}.0 <${Number(major) + 1}.0.0-0`;
                }
            } else if (preRelease) {
                if (major === "0") {
                    if (minor === "0") {
                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${minor}.${Number(patch) + 1}-0`;
                    } else {
                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;
                    }
                } else {
                    return `>=${major}.${minor}.${patch}-${preRelease} <${Number(major) + 1}.0.0-0`;
                }
            } else {
                if (major === "0") {
                    if (minor === "0") {
                        return `>=${major}.${minor}.${patch} <${major}.${minor}.${Number(patch) + 1}-0`;
                    } else {
                        return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;
                    }
                }
                return `>=${major}.${minor}.${patch} <${Number(major) + 1}.0.0-0`;
            }
        })).join(" ");
}
function parseTildes(range) {
    return range.trim().split(/\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(tilde), (_, major, minor, patch, preRelease)=>{
            if (isXVersion(major)) {
                return "";
            } else if (isXVersion(minor)) {
                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;
            } else if (isXVersion(patch)) {
                return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;
            } else if (preRelease) {
                return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;
            }
            return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;
        })).join(" ");
}
function parseXRanges(range) {
    return range.split(/\s+/).map((rangeVersion)=>rangeVersion.trim().replace(parseRegex(xRange), (ret, gtlt, major, minor, patch, preRelease)=>{
            const isXMajor = isXVersion(major);
            const isXMinor = isXMajor || isXVersion(minor);
            const isXPatch = isXMinor || isXVersion(patch);
            if (gtlt === "=" && isXPatch) {
                gtlt = "";
            }
            preRelease = "";
            if (isXMajor) {
                if (gtlt === ">" || gtlt === "<") {
                    // nothing is allowed
                    return "<0.0.0-0";
                } else {
                    // nothing is forbidden
                    return "*";
                }
            } else if (gtlt && isXPatch) {
                // replace X with 0
                if (isXMinor) {
                    minor = 0;
                }
                patch = 0;
                if (gtlt === ">") {
                    // >1 => >=2.0.0
                    // >1.2 => >=1.3.0
                    gtlt = ">=";
                    if (isXMinor) {
                        major = Number(major) + 1;
                        minor = 0;
                        patch = 0;
                    } else {
                        minor = Number(minor) + 1;
                        patch = 0;
                    }
                } else if (gtlt === "<=") {
                    // <=0.7.x is actually <0.8.0, since any 0.7.x should pass
                    // Similarly, <=7.x is actually <8.0.0, etc.
                    gtlt = "<";
                    if (isXMinor) {
                        major = Number(major) + 1;
                    } else {
                        minor = Number(minor) + 1;
                    }
                }
                if (gtlt === "<") {
                    preRelease = "-0";
                }
                return `${gtlt + major}.${minor}.${patch}${preRelease}`;
            } else if (isXMinor) {
                return `>=${major}.0.0${preRelease} <${Number(major) + 1}.0.0-0`;
            } else if (isXPatch) {
                return `>=${major}.${minor}.0${preRelease} <${major}.${Number(minor) + 1}.0-0`;
            }
            return ret;
        })).join(" ");
}
function parseStar(range) {
    return range.trim().replace(parseRegex(star), "");
}
function parseGTE0(comparatorString) {
    return comparatorString.trim().replace(parseRegex(gte0), "");
}
// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function compareAtom(rangeAtom, versionAtom) {
    rangeAtom = Number(rangeAtom) || rangeAtom;
    versionAtom = Number(versionAtom) || versionAtom;
    if (rangeAtom > versionAtom) {
        return 1;
    }
    if (rangeAtom === versionAtom) {
        return 0;
    }
    return -1;
}
function comparePreRelease(rangeAtom, versionAtom) {
    const { preRelease: rangePreRelease } = rangeAtom;
    const { preRelease: versionPreRelease } = versionAtom;
    if (rangePreRelease === undefined && Boolean(versionPreRelease)) {
        return 1;
    }
    if (Boolean(rangePreRelease) && versionPreRelease === undefined) {
        return -1;
    }
    if (rangePreRelease === undefined && versionPreRelease === undefined) {
        return 0;
    }
    for(let i = 0, n = rangePreRelease.length; i <= n; i++){
        const rangeElement = rangePreRelease[i];
        const versionElement = versionPreRelease[i];
        if (rangeElement === versionElement) {
            continue;
        }
        if (rangeElement === undefined && versionElement === undefined) {
            return 0;
        }
        if (!rangeElement) {
            return 1;
        }
        if (!versionElement) {
            return -1;
        }
        return compareAtom(rangeElement, versionElement);
    }
    return 0;
}
function compareVersion(rangeAtom, versionAtom) {
    return compareAtom(rangeAtom.major, versionAtom.major) || compareAtom(rangeAtom.minor, versionAtom.minor) || compareAtom(rangeAtom.patch, versionAtom.patch) || comparePreRelease(rangeAtom, versionAtom);
}
function eq(rangeAtom, versionAtom) {
    return rangeAtom.version === versionAtom.version;
}
function compare(rangeAtom, versionAtom) {
    switch(rangeAtom.operator){
        case "":
        case "=":
            return eq(rangeAtom, versionAtom);
        case ">":
            return compareVersion(rangeAtom, versionAtom) < 0;
        case ">=":
            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) < 0;
        case "<":
            return compareVersion(rangeAtom, versionAtom) > 0;
        case "<=":
            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) > 0;
        case undefined:
            {
                // mean * or x -> all versions
                return true;
            }
        default:
            return false;
    }
}
// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts
// Copyright (c)
// vite-plugin-federation is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//      http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
function parseComparatorString(range) {
    return pipe(// ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
    // ^1.2.3 --> >=1.2.3 <2.0.0-0
    // ^1.2.0 --> >=1.2.0 <2.0.0-0
    parseCarets, // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
    parseTildes, parseXRanges, parseStar)(range);
}
function parseRange(range) {
    return pipe(// `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    parseHyphen, // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    parseComparatorTrim, // `~ 1.2.3` => `~1.2.3`
    parseTildeTrim, // `^ 1.2.3` => `^1.2.3`
    parseCaretTrim)(range.trim()).split(/\s+/).join(" ");
}
function satisfy(version, range) {
    if (!version) {
        return false;
    }
    // Extract version details once
    const extractedVersion = extractComparator(version);
    if (!extractedVersion) {
        // If the version string is invalid, it can't satisfy any range
        return false;
    }
    const [, versionOperator, , versionMajor, versionMinor, versionPatch, versionPreRelease] = extractedVersion;
    const versionAtom = {
        operator: versionOperator,
        version: combineVersion(versionMajor, versionMinor, versionPatch, versionPreRelease),
        major: versionMajor,
        minor: versionMinor,
        patch: versionPatch,
        preRelease: versionPreRelease == null ? void 0 : versionPreRelease.split(".")
    };
    // Split the range by || to handle OR conditions
    const orRanges = range.split("||");
    for (const orRange of orRanges){
        const trimmedOrRange = orRange.trim();
        if (!trimmedOrRange) {
            // An empty range string signifies wildcard *, satisfy any valid version
            // (We already checked if the version itself is valid)
            return true;
        }
        // Handle simple wildcards explicitly before complex parsing
        if (trimmedOrRange === "*" || trimmedOrRange === "x") {
            return true;
        }
        try {
            // Apply existing parsing logic to the current OR sub-range
            const parsedSubRange = parseRange(trimmedOrRange); // Handles hyphens, trims etc.
            // Check if the result of initial parsing is empty, which can happen
            // for some wildcard cases handled by parseRange/parseComparatorString.
            // E.g. `parseStar` used in `parseComparatorString` returns ''.
            if (!parsedSubRange.trim()) {
                // If parsing results in empty string, treat as wildcard match
                return true;
            }
            const parsedComparatorString = parsedSubRange.split(" ").map((rangeVersion)=>parseComparatorString(rangeVersion)) // Expands ^, ~
            .join(" ");
            // Check again if the comparator string became empty after specific parsing like ^ or ~
            if (!parsedComparatorString.trim()) {
                return true;
            }
            // Split the sub-range by space for implicit AND conditions
            const comparators = parsedComparatorString.split(/\s+/).map((comparator)=>parseGTE0(comparator)) // Filter out empty strings that might result from multiple spaces
            .filter(Boolean);
            // If a sub-range becomes empty after parsing (e.g., invalid characters),
            // it cannot be satisfied. This check might be redundant now but kept for safety.
            if (comparators.length === 0) {
                continue;
            }
            let subRangeSatisfied = true;
            for (const comparator of comparators){
                const extractedComparator = extractComparator(comparator);
                // If any part of the AND sub-range is invalid, the sub-range is not satisfied
                if (!extractedComparator) {
                    subRangeSatisfied = false;
                    break;
                }
                const [, rangeOperator, , rangeMajor, rangeMinor, rangePatch, rangePreRelease] = extractedComparator;
                const rangeAtom = {
                    operator: rangeOperator,
                    version: combineVersion(rangeMajor, rangeMinor, rangePatch, rangePreRelease),
                    major: rangeMajor,
                    minor: rangeMinor,
                    patch: rangePatch,
                    preRelease: rangePreRelease == null ? void 0 : rangePreRelease.split(".")
                };
                // Check if the version satisfies this specific comparator in the AND chain
                if (!compare(rangeAtom, versionAtom)) {
                    subRangeSatisfied = false; // This part of the AND condition failed
                    break; // No need to check further comparators in this sub-range
                }
            }
            // If all AND conditions within this OR sub-range were met, the overall range is satisfied
            if (subRangeSatisfied) {
                return true;
            }
        } catch (e) {
            // Log error and treat this sub-range as unsatisfied
            console.error(`[semver] Error processing range part "${trimmedOrRange}":`, e);
            continue;
        }
    }
    // If none of the OR sub-ranges were satisfied
    return false;
}
function formatShare(shareArgs, from, name, shareStrategy) {
    let get;
    if ("get" in shareArgs) {
        // eslint-disable-next-line prefer-destructuring
        get = shareArgs.get;
    } else if ("lib" in shareArgs) {
        get = ()=>Promise.resolve(shareArgs.lib);
    } else {
        get = ()=>Promise.resolve(()=>{
                throw new Error(`Can not get shared '${name}'!`);
            });
    }
    var _shareArgs_version, _shareArgs_scope, _shareArgs_strategy;
    return polyfills._extends({
        deps: [],
        useIn: [],
        from,
        loading: null
    }, shareArgs, {
        shareConfig: polyfills._extends({
            requiredVersion: `^${shareArgs.version}`,
            singleton: false,
            eager: false,
            strictVersion: false
        }, shareArgs.shareConfig),
        get,
        loaded: (shareArgs == null ? void 0 : shareArgs.loaded) || "lib" in shareArgs ? true : undefined,
        version: (_shareArgs_version = shareArgs.version) != null ? _shareArgs_version : "0",
        scope: Array.isArray(shareArgs.scope) ? shareArgs.scope : [
            (_shareArgs_scope = shareArgs.scope) != null ? _shareArgs_scope : "default"
        ],
        strategy: ((_shareArgs_strategy = shareArgs.strategy) != null ? _shareArgs_strategy : shareStrategy) || "version-first"
    });
}
function formatShareConfigs(globalOptions, userOptions) {
    const shareArgs = userOptions.shared || {};
    const from = userOptions.name;
    const shareInfos = Object.keys(shareArgs).reduce((res, pkgName)=>{
        const arrayShareArgs = arrayOptions(shareArgs[pkgName]);
        res[pkgName] = res[pkgName] || [];
        arrayShareArgs.forEach((shareConfig)=>{
            res[pkgName].push(formatShare(shareConfig, from, pkgName, userOptions.shareStrategy));
        });
        return res;
    }, {});
    const shared = polyfills._extends({}, globalOptions.shared);
    Object.keys(shareInfos).forEach((shareKey)=>{
        if (!shared[shareKey]) {
            shared[shareKey] = shareInfos[shareKey];
        } else {
            shareInfos[shareKey].forEach((newUserSharedOptions)=>{
                const isSameVersion = shared[shareKey].find((sharedVal)=>sharedVal.version === newUserSharedOptions.version);
                if (!isSameVersion) {
                    shared[shareKey].push(newUserSharedOptions);
                }
            });
        }
    });
    return {
        shared,
        shareInfos
    };
}
function versionLt(a, b) {
    const transformInvalidVersion = (version)=>{
        const isNumberVersion = !Number.isNaN(Number(version));
        if (isNumberVersion) {
            const splitArr = version.split(".");
            let validVersion = version;
            for(let i = 0; i < 3 - splitArr.length; i++){
                validVersion += ".0";
            }
            return validVersion;
        }
        return version;
    };
    if (satisfy(transformInvalidVersion(a), `<=${transformInvalidVersion(b)}`)) {
        return true;
    } else {
        return false;
    }
}
const findVersion = (shareVersionMap, cb)=>{
    const callback = cb || function(prev, cur) {
        return versionLt(prev, cur);
    };
    return Object.keys(shareVersionMap).reduce((prev, cur)=>{
        if (!prev) {
            return cur;
        }
        if (callback(prev, cur)) {
            return cur;
        }
        // default version is '0' https://github.com/webpack/webpack/blob/main/lib/sharing/ProvideSharedModule.js#L136
        if (prev === "0") {
            return cur;
        }
        return prev;
    }, 0);
};
const isLoaded = (shared)=>{
    return Boolean(shared.loaded) || typeof shared.lib === "function";
};
const isLoading = (shared)=>{
    return Boolean(shared.loading);
};
function findSingletonVersionOrderByVersion(shareScopeMap, scope, pkgName) {
    const versions = shareScopeMap[scope][pkgName];
    const callback = function(prev, cur) {
        return !isLoaded(versions[prev]) && versionLt(prev, cur);
    };
    return findVersion(shareScopeMap[scope][pkgName], callback);
}
function findSingletonVersionOrderByLoaded(shareScopeMap, scope, pkgName) {
    const versions = shareScopeMap[scope][pkgName];
    const callback = function(prev, cur) {
        const isLoadingOrLoaded = (shared)=>{
            return isLoaded(shared) || isLoading(shared);
        };
        if (isLoadingOrLoaded(versions[cur])) {
            if (isLoadingOrLoaded(versions[prev])) {
                return Boolean(versionLt(prev, cur));
            } else {
                return true;
            }
        }
        if (isLoadingOrLoaded(versions[prev])) {
            return false;
        }
        return versionLt(prev, cur);
    };
    return findVersion(shareScopeMap[scope][pkgName], callback);
}
function getFindShareFunction(strategy) {
    if (strategy === "loaded-first") {
        return findSingletonVersionOrderByLoaded;
    }
    return findSingletonVersionOrderByVersion;
}
function getRegisteredShare(localShareScopeMap, pkgName, shareInfo, resolveShare) {
    if (!localShareScopeMap) {
        return;
    }
    const { shareConfig, scope = DEFAULT_SCOPE, strategy } = shareInfo;
    const scopes = Array.isArray(scope) ? scope : [
        scope
    ];
    for (const sc of scopes){
        if (shareConfig && localShareScopeMap[sc] && localShareScopeMap[sc][pkgName]) {
            const { requiredVersion } = shareConfig;
            const findShareFunction = getFindShareFunction(strategy);
            const maxOrSingletonVersion = findShareFunction(localShareScopeMap, sc, pkgName);
            //@ts-ignore
            const defaultResolver = ()=>{
                if (shareConfig.singleton) {
                    if (typeof requiredVersion === "string" && !satisfy(maxOrSingletonVersion, requiredVersion)) {
                        const msg = `Version ${maxOrSingletonVersion} from ${maxOrSingletonVersion && localShareScopeMap[sc][pkgName][maxOrSingletonVersion].from} of shared singleton module ${pkgName} does not satisfy the requirement of ${shareInfo.from} which needs ${requiredVersion})`;
                        if (shareConfig.strictVersion) {
                            error(msg);
                        } else {
                            warn(msg);
                        }
                    }
                    return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];
                } else {
                    if (requiredVersion === false || requiredVersion === "*") {
                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];
                    }
                    if (satisfy(maxOrSingletonVersion, requiredVersion)) {
                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];
                    }
                    for (const [versionKey, versionValue] of Object.entries(localShareScopeMap[sc][pkgName])){
                        if (satisfy(versionKey, requiredVersion)) {
                            return versionValue;
                        }
                    }
                }
            };
            const params = {
                shareScopeMap: localShareScopeMap,
                scope: sc,
                pkgName,
                version: maxOrSingletonVersion,
                GlobalFederation: Global.__FEDERATION__,
                resolver: defaultResolver
            };
            const resolveShared = resolveShare.emit(params) || params;
            return resolveShared.resolver();
        }
    }
}
function getGlobalShareScope() {
    return Global.__FEDERATION__.__SHARE__;
}
function getTargetSharedOptions(options) {
    const { pkgName, extraOptions, shareInfos } = options;
    const defaultResolver = (sharedOptions)=>{
        if (!sharedOptions) {
            return undefined;
        }
        const shareVersionMap = {};
        sharedOptions.forEach((shared)=>{
            shareVersionMap[shared.version] = shared;
        });
        const callback = function(prev, cur) {
            return !isLoaded(shareVersionMap[prev]) && versionLt(prev, cur);
        };
        const maxVersion = findVersion(shareVersionMap, callback);
        return shareVersionMap[maxVersion];
    };
    var _extraOptions_resolver;
    const resolver = (_extraOptions_resolver = extraOptions == null ? void 0 : extraOptions.resolver) != null ? _extraOptions_resolver : defaultResolver;
    return Object.assign({}, resolver(shareInfos[pkgName]), extraOptions == null ? void 0 : extraOptions.customShareInfo);
}
const ShareUtils = {
    getRegisteredShare,
    getGlobalShareScope
};
const GlobalUtils = {
    Global,
    nativeGlobal,
    resetFederationGlobalInfo,
    setGlobalFederationInstance,
    getGlobalFederationConstructor,
    setGlobalFederationConstructor,
    getInfoWithoutType,
    getGlobalSnapshot,
    getTargetSnapshotInfoByModuleInfo,
    getGlobalSnapshotInfoByModuleInfo,
    setGlobalSnapshotInfoByModuleInfo,
    addGlobalSnapshot,
    getRemoteEntryExports,
    registerGlobalPlugins,
    getGlobalHostPlugins,
    getPreloaded,
    setPreloaded
};
var helpers = {
    global: GlobalUtils,
    share: ShareUtils
};
function getBuilderId() {
    //@ts-ignore
    return  true ? "home_app:1.0.0" : 0;
}
// Function to match a remote with its name and expose
// id: pkgName(@federation/app1) + expose(button) = @federation/app1/button
// id: alias(app1) + expose(button) = app1/button
// id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort
function matchRemoteWithNameAndExpose(remotes, id) {
    for (const remote of remotes){
        // match pkgName
        const isNameMatched = id.startsWith(remote.name);
        let expose = id.replace(remote.name, "");
        if (isNameMatched) {
            if (expose.startsWith("/")) {
                const pkgNameOrAlias = remote.name;
                expose = `.${expose}`;
                return {
                    pkgNameOrAlias,
                    expose,
                    remote
                };
            } else if (expose === "") {
                return {
                    pkgNameOrAlias: remote.name,
                    expose: ".",
                    remote
                };
            }
        }
        // match alias
        const isAliasMatched = remote.alias && id.startsWith(remote.alias);
        let exposeWithAlias = remote.alias && id.replace(remote.alias, "");
        if (remote.alias && isAliasMatched) {
            if (exposeWithAlias && exposeWithAlias.startsWith("/")) {
                const pkgNameOrAlias = remote.alias;
                exposeWithAlias = `.${exposeWithAlias}`;
                return {
                    pkgNameOrAlias,
                    expose: exposeWithAlias,
                    remote
                };
            } else if (exposeWithAlias === "") {
                return {
                    pkgNameOrAlias: remote.alias,
                    expose: ".",
                    remote
                };
            }
        }
    }
    return;
}
// Function to match a remote with its name or alias
function matchRemote(remotes, nameOrAlias) {
    for (const remote of remotes){
        const isNameMatched = nameOrAlias === remote.name;
        if (isNameMatched) {
            return remote;
        }
        const isAliasMatched = remote.alias && nameOrAlias === remote.alias;
        if (isAliasMatched) {
            return remote;
        }
    }
    return;
}
function registerPlugins(plugins, hookInstances) {
    const globalPlugins = getGlobalHostPlugins();
    // Incorporate global plugins
    if (globalPlugins.length > 0) {
        globalPlugins.forEach((plugin)=>{
            if (plugins == null ? void 0 : plugins.find((item)=>item.name !== plugin.name)) {
                plugins.push(plugin);
            }
        });
    }
    if (plugins && plugins.length > 0) {
        plugins.forEach((plugin)=>{
            hookInstances.forEach((hookInstance)=>{
                hookInstance.applyPlugin(plugin);
            });
        });
    }
    return plugins;
}
const importCallback = ".then(callbacks[0]).catch(callbacks[1])";
async function loadEsmEntry({ entry, remoteEntryExports }) {
    return new Promise((resolve, reject)=>{
        try {
            if (!remoteEntryExports) {
                if (typeof FEDERATION_ALLOW_NEW_FUNCTION !== "undefined") {
                    new Function("callbacks", `import("${entry}")${importCallback}`)([
                        resolve,
                        reject
                    ]);
                } else {
                    Promise.resolve(/* webpackIgnore: true */ /* @vite-ignore */ entry).then((p)=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__("../../packages/runtime-core/dist sync recursive")(p))).then(resolve).catch(reject);
                }
            } else {
                resolve(remoteEntryExports);
            }
        } catch (e) {
            reject(e);
        }
    });
}
async function loadSystemJsEntry({ entry, remoteEntryExports }) {
    return new Promise((resolve, reject)=>{
        try {
            if (!remoteEntryExports) {
                //@ts-ignore
                if (false) {} else {
                    new Function("callbacks", `System.import("${entry}")${importCallback}`)([
                        resolve,
                        reject
                    ]);
                }
            } else {
                resolve(remoteEntryExports);
            }
        } catch (e) {
            reject(e);
        }
    });
}
function handleRemoteEntryLoaded(name, globalName, entry) {
    const { remoteEntryKey, entryExports } = getRemoteEntryExports(name, globalName);
    assert(entryExports, errorCodes.getShortErrorMsg(errorCodes.RUNTIME_001, errorCodes.runtimeDescMap, {
        remoteName: name,
        remoteEntryUrl: entry,
        remoteEntryKey
    }));
    return entryExports;
}
async function loadEntryScript({ name, globalName, entry, loaderHook }) {
    const { entryExports: remoteEntryExports } = getRemoteEntryExports(name, globalName);
    if (remoteEntryExports) {
        return remoteEntryExports;
    }
    return sdk.loadScript(entry, {
        attrs: {},
        createScriptHook: (url, attrs)=>{
            const res = loaderHook.lifecycle.createScript.emit({
                url,
                attrs
            });
            if (!res) return;
            if (res instanceof HTMLScriptElement) {
                return res;
            }
            if ("script" in res || "timeout" in res) {
                return res;
            }
            return;
        }
    }).then(()=>{
        return handleRemoteEntryLoaded(name, globalName, entry);
    }).catch((e)=>{
        assert(undefined, errorCodes.getShortErrorMsg(errorCodes.RUNTIME_008, errorCodes.runtimeDescMap, {
            remoteName: name,
            resourceUrl: entry
        }));
        throw e;
    });
}
async function loadEntryDom({ remoteInfo, remoteEntryExports, loaderHook }) {
    const { entry, entryGlobalName: globalName, name, type } = remoteInfo;
    switch(type){
        case "esm":
        case "module":
            return loadEsmEntry({
                entry,
                remoteEntryExports
            });
        case "system":
            return loadSystemJsEntry({
                entry,
                remoteEntryExports
            });
        default:
            return loadEntryScript({
                entry,
                globalName,
                name,
                loaderHook
            });
    }
}
async function loadEntryNode({ remoteInfo, loaderHook }) {
    const { entry, entryGlobalName: globalName, name, type } = remoteInfo;
    const { entryExports: remoteEntryExports } = getRemoteEntryExports(name, globalName);
    if (remoteEntryExports) {
        return remoteEntryExports;
    }
    return sdk.loadScriptNode(entry, {
        attrs: {
            name,
            globalName,
            type
        },
        loaderHook: {
            createScriptHook: (url, attrs = {})=>{
                const res = loaderHook.lifecycle.createScript.emit({
                    url,
                    attrs
                });
                if (!res) return;
                if ("url" in res) {
                    return res;
                }
                return;
            }
        }
    }).then(()=>{
        return handleRemoteEntryLoaded(name, globalName, entry);
    }).catch((e)=>{
        throw e;
    });
}
function getRemoteEntryUniqueKey(remoteInfo) {
    const { entry, name } = remoteInfo;
    return sdk.composeKeyWithSeparator(name, entry);
}
async function getRemoteEntry({ origin, remoteEntryExports, remoteInfo }) {
    const uniqueKey = getRemoteEntryUniqueKey(remoteInfo);
    if (remoteEntryExports) {
        return remoteEntryExports;
    }
    if (!globalLoading[uniqueKey]) {
        const loadEntryHook = origin.remoteHandler.hooks.lifecycle.loadEntry;
        const loaderHook = origin.loaderHook;
        globalLoading[uniqueKey] = loadEntryHook.emit({
            loaderHook,
            remoteInfo,
            remoteEntryExports
        }).then((res)=>{
            if (res) {
                return res;
            }
            // Use ENV_TARGET if defined, otherwise fallback to isBrowserEnv, must keep this
            const isWebEnvironment = typeof ENV_TARGET !== "undefined" ? ENV_TARGET === "web" : sdk.isBrowserEnv();
            return isWebEnvironment ? loadEntryDom({
                remoteInfo,
                remoteEntryExports,
                loaderHook
            }) : loadEntryNode({
                remoteInfo,
                loaderHook
            });
        });
    }
    return globalLoading[uniqueKey];
}
function getRemoteInfo(remote) {
    return polyfills._extends({}, remote, {
        entry: "entry" in remote ? remote.entry : "",
        type: remote.type || DEFAULT_REMOTE_TYPE,
        entryGlobalName: remote.entryGlobalName || remote.name,
        shareScope: remote.shareScope || DEFAULT_SCOPE
    });
}
let Module = class Module {
    async getEntry() {
        if (this.remoteEntryExports) {
            return this.remoteEntryExports;
        }
        let remoteEntryExports;
        try {
            remoteEntryExports = await getRemoteEntry({
                origin: this.host,
                remoteInfo: this.remoteInfo,
                remoteEntryExports: this.remoteEntryExports
            });
        } catch (err) {
            const uniqueKey = getRemoteEntryUniqueKey(this.remoteInfo);
            remoteEntryExports = await this.host.loaderHook.lifecycle.loadEntryError.emit({
                getRemoteEntry,
                origin: this.host,
                remoteInfo: this.remoteInfo,
                remoteEntryExports: this.remoteEntryExports,
                globalLoading,
                uniqueKey
            });
        }
        assert(remoteEntryExports, `remoteEntryExports is undefined \n ${sdk.safeToString(this.remoteInfo)}`);
        this.remoteEntryExports = remoteEntryExports;
        return this.remoteEntryExports;
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    async get(id, expose, options, remoteSnapshot) {
        const { loadFactory = true } = options || {
            loadFactory: true
        };
        // Get remoteEntry.js
        const remoteEntryExports = await this.getEntry();
        if (!this.inited) {
            const localShareScopeMap = this.host.shareScopeMap;
            const shareScopeKeys = Array.isArray(this.remoteInfo.shareScope) ? this.remoteInfo.shareScope : [
                this.remoteInfo.shareScope
            ];
            if (!shareScopeKeys.length) {
                shareScopeKeys.push("default");
            }
            shareScopeKeys.forEach((shareScopeKey)=>{
                if (!localShareScopeMap[shareScopeKey]) {
                    localShareScopeMap[shareScopeKey] = {};
                }
            });
            // TODO: compate legacy init params, should use shareScopeMap if exist
            const shareScope = localShareScopeMap[shareScopeKeys[0]];
            const initScope = [];
            const remoteEntryInitOptions = {
                version: this.remoteInfo.version || "",
                shareScopeKeys: Array.isArray(this.remoteInfo.shareScope) ? shareScopeKeys : this.remoteInfo.shareScope || "default"
            };
            // Help to find host instance
            Object.defineProperty(remoteEntryInitOptions, "shareScopeMap", {
                value: localShareScopeMap,
                // remoteEntryInitOptions will be traversed and assigned during container init, ,so this attribute is not allowed to be traversed
                enumerable: false
            });
            const initContainerOptions = await this.host.hooks.lifecycle.beforeInitContainer.emit({
                shareScope,
                // @ts-ignore shareScopeMap will be set by Object.defineProperty
                remoteEntryInitOptions,
                initScope,
                remoteInfo: this.remoteInfo,
                origin: this.host
            });
            if (typeof (remoteEntryExports == null ? void 0 : remoteEntryExports.init) === "undefined") {
                error(errorCodes.getShortErrorMsg(errorCodes.RUNTIME_002, errorCodes.runtimeDescMap, {
                    hostName: this.host.name,
                    remoteName: this.remoteInfo.name,
                    remoteEntryUrl: this.remoteInfo.entry,
                    remoteEntryKey: this.remoteInfo.entryGlobalName
                }));
            }
            await remoteEntryExports.init(initContainerOptions.shareScope, initContainerOptions.initScope, initContainerOptions.remoteEntryInitOptions);
            await this.host.hooks.lifecycle.initContainer.emit(polyfills._extends({}, initContainerOptions, {
                id,
                remoteSnapshot,
                remoteEntryExports
            }));
        }
        this.lib = remoteEntryExports;
        this.inited = true;
        let moduleFactory;
        moduleFactory = await this.host.loaderHook.lifecycle.getModuleFactory.emit({
            remoteEntryExports,
            expose,
            moduleInfo: this.remoteInfo
        });
        // get exposeGetter
        if (!moduleFactory) {
            moduleFactory = await remoteEntryExports.get(expose);
        }
        assert(moduleFactory, `${getFMId(this.remoteInfo)} remote don't export ${expose}.`);
        // keep symbol for module name always one format
        const symbolName = processModuleAlias(this.remoteInfo.name, expose);
        const wrapModuleFactory = this.wraperFactory(moduleFactory, symbolName);
        if (!loadFactory) {
            return wrapModuleFactory;
        }
        const exposeContent = await wrapModuleFactory();
        return exposeContent;
    }
    wraperFactory(moduleFactory, id) {
        function defineModuleId(res, id) {
            if (res && typeof res === "object" && Object.isExtensible(res) && !Object.getOwnPropertyDescriptor(res, Symbol.for("mf_module_id"))) {
                Object.defineProperty(res, Symbol.for("mf_module_id"), {
                    value: id,
                    enumerable: false
                });
            }
        }
        if (moduleFactory instanceof Promise) {
            return async ()=>{
                const res = await moduleFactory();
                // This parameter is used for bridge debugging
                defineModuleId(res, id);
                return res;
            };
        } else {
            return ()=>{
                const res = moduleFactory();
                // This parameter is used for bridge debugging
                defineModuleId(res, id);
                return res;
            };
        }
    }
    constructor({ remoteInfo, host }){
        this.inited = false;
        this.lib = undefined;
        this.remoteInfo = remoteInfo;
        this.host = host;
    }
};
class SyncHook {
    on(fn) {
        if (typeof fn === "function") {
            this.listeners.add(fn);
        }
    }
    once(fn) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this.on(function wrapper(...args) {
            self.remove(wrapper);
            // eslint-disable-next-line prefer-spread
            return fn.apply(null, args);
        });
    }
    emit(...data) {
        let result;
        if (this.listeners.size > 0) {
            // eslint-disable-next-line prefer-spread
            this.listeners.forEach((fn)=>{
                result = fn(...data);
            });
        }
        return result;
    }
    remove(fn) {
        this.listeners.delete(fn);
    }
    removeAll() {
        this.listeners.clear();
    }
    constructor(type){
        this.type = "";
        this.listeners = new Set();
        if (type) {
            this.type = type;
        }
    }
}
class AsyncHook extends SyncHook {
    emit(...data) {
        let result;
        const ls = Array.from(this.listeners);
        if (ls.length > 0) {
            let i = 0;
            const call = (prev)=>{
                if (prev === false) {
                    return false; // Abort process
                } else if (i < ls.length) {
                    return Promise.resolve(ls[i++].apply(null, data)).then(call);
                } else {
                    return prev;
                }
            };
            result = call();
        }
        return Promise.resolve(result);
    }
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function checkReturnData(originalData, returnedData) {
    if (!isObject(returnedData)) {
        return false;
    }
    if (originalData !== returnedData) {
        // eslint-disable-next-line no-restricted-syntax
        for(const key in originalData){
            if (!(key in returnedData)) {
                return false;
            }
        }
    }
    return true;
}
class SyncWaterfallHook extends SyncHook {
    emit(data) {
        if (!isObject(data)) {
            error(`The data for the "${this.type}" hook should be an object.`);
        }
        for (const fn of this.listeners){
            try {
                const tempData = fn(data);
                if (checkReturnData(data, tempData)) {
                    data = tempData;
                } else {
                    this.onerror(`A plugin returned an unacceptable value for the "${this.type}" type.`);
                    break;
                }
            } catch (e) {
                warn(e);
                this.onerror(e);
            }
        }
        return data;
    }
    constructor(type){
        super(), this.onerror = error;
        this.type = type;
    }
}
class AsyncWaterfallHook extends SyncHook {
    emit(data) {
        if (!isObject(data)) {
            error(`The response data for the "${this.type}" hook must be an object.`);
        }
        const ls = Array.from(this.listeners);
        if (ls.length > 0) {
            let i = 0;
            const processError = (e)=>{
                warn(e);
                this.onerror(e);
                return data;
            };
            const call = (prevData)=>{
                if (checkReturnData(data, prevData)) {
                    data = prevData;
                    if (i < ls.length) {
                        try {
                            return Promise.resolve(ls[i++](data)).then(call, processError);
                        } catch (e) {
                            return processError(e);
                        }
                    }
                } else {
                    this.onerror(`A plugin returned an incorrect value for the "${this.type}" type.`);
                }
                return data;
            };
            return Promise.resolve(call(data));
        }
        return Promise.resolve(data);
    }
    constructor(type){
        super(), this.onerror = error;
        this.type = type;
    }
}
class PluginSystem {
    applyPlugin(plugin) {
        assert(isPlainObject(plugin), "Plugin configuration is invalid.");
        // The plugin's name is mandatory and must be unique
        const pluginName = plugin.name;
        assert(pluginName, "A name must be provided by the plugin.");
        if (!this.registerPlugins[pluginName]) {
            this.registerPlugins[pluginName] = plugin;
            Object.keys(this.lifecycle).forEach((key)=>{
                const pluginLife = plugin[key];
                if (pluginLife) {
                    this.lifecycle[key].on(pluginLife);
                }
            });
        }
    }
    removePlugin(pluginName) {
        assert(pluginName, "A name is required.");
        const plugin = this.registerPlugins[pluginName];
        assert(plugin, `The plugin "${pluginName}" is not registered.`);
        Object.keys(plugin).forEach((key)=>{
            if (key !== "name") {
                this.lifecycle[key].remove(plugin[key]);
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-shadow
    inherit({ lifecycle, registerPlugins }) {
        Object.keys(lifecycle).forEach((hookName)=>{
            assert(!this.lifecycle[hookName], `The hook "${hookName}" has a conflict and cannot be inherited.`);
            this.lifecycle[hookName] = lifecycle[hookName];
        });
        Object.keys(registerPlugins).forEach((pluginName)=>{
            assert(!this.registerPlugins[pluginName], `The plugin "${pluginName}" has a conflict and cannot be inherited.`);
            this.applyPlugin(registerPlugins[pluginName]);
        });
    }
    constructor(lifecycle){
        this.registerPlugins = {};
        this.lifecycle = lifecycle;
        this.lifecycleKeys = Object.keys(lifecycle);
    }
}
function defaultPreloadArgs(preloadConfig) {
    return polyfills._extends({
        resourceCategory: "sync",
        share: true,
        depsRemote: true,
        prefetchInterface: false
    }, preloadConfig);
}
function formatPreloadArgs(remotes, preloadArgs) {
    return preloadArgs.map((args)=>{
        const remoteInfo = matchRemote(remotes, args.nameOrAlias);
        assert(remoteInfo, `Unable to preload ${args.nameOrAlias} as it is not included in ${!remoteInfo && sdk.safeToString({
            remoteInfo,
            remotes
        })}`);
        return {
            remote: remoteInfo,
            preloadConfig: defaultPreloadArgs(args)
        };
    });
}
function normalizePreloadExposes(exposes) {
    if (!exposes) {
        return [];
    }
    return exposes.map((expose)=>{
        if (expose === ".") {
            return expose;
        }
        if (expose.startsWith("./")) {
            return expose.replace("./", "");
        }
        return expose;
    });
}
function preloadAssets(remoteInfo, host, assets, useLinkPreload = true) {
    const { cssAssets, jsAssetsWithoutEntry, entryAssets } = assets;
    if (host.options.inBrowser) {
        entryAssets.forEach((asset)=>{
            const { moduleInfo } = asset;
            const module = host.moduleCache.get(remoteInfo.name);
            if (module) {
                getRemoteEntry({
                    origin: host,
                    remoteInfo: moduleInfo,
                    remoteEntryExports: module.remoteEntryExports
                });
            } else {
                getRemoteEntry({
                    origin: host,
                    remoteInfo: moduleInfo,
                    remoteEntryExports: undefined
                });
            }
        });
        if (useLinkPreload) {
            const defaultAttrs = {
                rel: "preload",
                as: "style"
            };
            cssAssets.forEach((cssUrl)=>{
                const { link: cssEl, needAttach } = sdk.createLink({
                    url: cssUrl,
                    cb: ()=>{
                    // noop
                    },
                    attrs: defaultAttrs,
                    createLinkHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createLink.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    }
                });
                needAttach && document.head.appendChild(cssEl);
            });
        } else {
            const defaultAttrs = {
                rel: "stylesheet",
                type: "text/css"
            };
            cssAssets.forEach((cssUrl)=>{
                const { link: cssEl, needAttach } = sdk.createLink({
                    url: cssUrl,
                    cb: ()=>{
                    // noop
                    },
                    attrs: defaultAttrs,
                    createLinkHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createLink.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    },
                    needDeleteLink: false
                });
                needAttach && document.head.appendChild(cssEl);
            });
        }
        if (useLinkPreload) {
            const defaultAttrs = {
                rel: "preload",
                as: "script"
            };
            jsAssetsWithoutEntry.forEach((jsUrl)=>{
                const { link: linkEl, needAttach } = sdk.createLink({
                    url: jsUrl,
                    cb: ()=>{
                    // noop
                    },
                    attrs: defaultAttrs,
                    createLinkHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createLink.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLLinkElement) {
                            return res;
                        }
                        return;
                    }
                });
                needAttach && document.head.appendChild(linkEl);
            });
        } else {
            const defaultAttrs = {
                fetchpriority: "high",
                type: (remoteInfo == null ? void 0 : remoteInfo.type) === "module" ? "module" : "text/javascript"
            };
            jsAssetsWithoutEntry.forEach((jsUrl)=>{
                const { script: scriptEl, needAttach } = sdk.createScript({
                    url: jsUrl,
                    cb: ()=>{
                    // noop
                    },
                    attrs: defaultAttrs,
                    createScriptHook: (url, attrs)=>{
                        const res = host.loaderHook.lifecycle.createScript.emit({
                            url,
                            attrs
                        });
                        if (res instanceof HTMLScriptElement) {
                            return res;
                        }
                        return;
                    },
                    needDeleteScript: true
                });
                needAttach && document.head.appendChild(scriptEl);
            });
        }
    }
}
function assignRemoteInfo(remoteInfo, remoteSnapshot) {
    const remoteEntryInfo = getRemoteEntryInfoFromSnapshot(remoteSnapshot);
    if (!remoteEntryInfo.url) {
        error(`The attribute remoteEntry of ${remoteInfo.name} must not be undefined.`);
    }
    let entryUrl = sdk.getResourceUrl(remoteSnapshot, remoteEntryInfo.url);
    if (!sdk.isBrowserEnv() && !entryUrl.startsWith("http")) {
        entryUrl = `https:${entryUrl}`;
    }
    remoteInfo.type = remoteEntryInfo.type;
    remoteInfo.entryGlobalName = remoteEntryInfo.globalName;
    remoteInfo.entry = entryUrl;
    remoteInfo.version = remoteSnapshot.version;
    remoteInfo.buildVersion = remoteSnapshot.buildVersion;
}
function snapshotPlugin() {
    return {
        name: "snapshot-plugin",
        async afterResolve (args) {
            const { remote, pkgNameOrAlias, expose, origin, remoteInfo, id } = args;
            if (!isRemoteInfoWithEntry(remote) || !isPureRemoteEntry(remote)) {
                const { remoteSnapshot, globalSnapshot } = await origin.snapshotHandler.loadRemoteSnapshotInfo({
                    moduleInfo: remote,
                    id
                });
                assignRemoteInfo(remoteInfo, remoteSnapshot);
                // preloading assets
                const preloadOptions = {
                    remote,
                    preloadConfig: {
                        nameOrAlias: pkgNameOrAlias,
                        exposes: [
                            expose
                        ],
                        resourceCategory: "sync",
                        share: false,
                        depsRemote: false
                    }
                };
                const assets = await origin.remoteHandler.hooks.lifecycle.generatePreloadAssets.emit({
                    origin,
                    preloadOptions,
                    remoteInfo,
                    remote,
                    remoteSnapshot,
                    globalSnapshot
                });
                if (assets) {
                    preloadAssets(remoteInfo, origin, assets, false);
                }
                return polyfills._extends({}, args, {
                    remoteSnapshot
                });
            }
            return args;
        }
    };
}
// name
// name:version
function splitId(id) {
    const splitInfo = id.split(":");
    if (splitInfo.length === 1) {
        return {
            name: splitInfo[0],
            version: undefined
        };
    } else if (splitInfo.length === 2) {
        return {
            name: splitInfo[0],
            version: splitInfo[1]
        };
    } else {
        return {
            name: splitInfo[1],
            version: splitInfo[2]
        };
    }
}
// Traverse all nodes in moduleInfo and traverse the entire snapshot
function traverseModuleInfo(globalSnapshot, remoteInfo, traverse, isRoot, memo = {}, remoteSnapshot) {
    const id = getFMId(remoteInfo);
    const { value: snapshotValue } = getInfoWithoutType(globalSnapshot, id);
    const effectiveRemoteSnapshot = remoteSnapshot || snapshotValue;
    if (effectiveRemoteSnapshot && !sdk.isManifestProvider(effectiveRemoteSnapshot)) {
        traverse(effectiveRemoteSnapshot, remoteInfo, isRoot);
        if (effectiveRemoteSnapshot.remotesInfo) {
            const remoteKeys = Object.keys(effectiveRemoteSnapshot.remotesInfo);
            for (const key of remoteKeys){
                if (memo[key]) {
                    continue;
                }
                memo[key] = true;
                const subRemoteInfo = splitId(key);
                const remoteValue = effectiveRemoteSnapshot.remotesInfo[key];
                traverseModuleInfo(globalSnapshot, {
                    name: subRemoteInfo.name,
                    version: remoteValue.matchedVersion
                }, traverse, false, memo, undefined);
            }
        }
    }
}
const isExisted = (type, url)=>{
    return document.querySelector(`${type}[${type === "link" ? "href" : "src"}="${url}"]`);
};
// eslint-disable-next-line max-lines-per-function
function generatePreloadAssets(origin, preloadOptions, remote, globalSnapshot, remoteSnapshot) {
    const cssAssets = [];
    const jsAssets = [];
    const entryAssets = [];
    const loadedSharedJsAssets = new Set();
    const loadedSharedCssAssets = new Set();
    const { options } = origin;
    const { preloadConfig: rootPreloadConfig } = preloadOptions;
    const { depsRemote } = rootPreloadConfig;
    const memo = {};
    traverseModuleInfo(globalSnapshot, remote, (moduleInfoSnapshot, remoteInfo, isRoot)=>{
        let preloadConfig;
        if (isRoot) {
            preloadConfig = rootPreloadConfig;
        } else {
            if (Array.isArray(depsRemote)) {
                // eslint-disable-next-line array-callback-return
                const findPreloadConfig = depsRemote.find((remoteConfig)=>{
                    if (remoteConfig.nameOrAlias === remoteInfo.name || remoteConfig.nameOrAlias === remoteInfo.alias) {
                        return true;
                    }
                    return false;
                });
                if (!findPreloadConfig) {
                    return;
                }
                preloadConfig = defaultPreloadArgs(findPreloadConfig);
            } else if (depsRemote === true) {
                preloadConfig = rootPreloadConfig;
            } else {
                return;
            }
        }
        const remoteEntryUrl = sdk.getResourceUrl(moduleInfoSnapshot, getRemoteEntryInfoFromSnapshot(moduleInfoSnapshot).url);
        if (remoteEntryUrl) {
            entryAssets.push({
                name: remoteInfo.name,
                moduleInfo: {
                    name: remoteInfo.name,
                    entry: remoteEntryUrl,
                    type: "remoteEntryType" in moduleInfoSnapshot ? moduleInfoSnapshot.remoteEntryType : "global",
                    entryGlobalName: "globalName" in moduleInfoSnapshot ? moduleInfoSnapshot.globalName : remoteInfo.name,
                    shareScope: "",
                    version: "version" in moduleInfoSnapshot ? moduleInfoSnapshot.version : undefined
                },
                url: remoteEntryUrl
            });
        }
        let moduleAssetsInfo = "modules" in moduleInfoSnapshot ? moduleInfoSnapshot.modules : [];
        const normalizedPreloadExposes = normalizePreloadExposes(preloadConfig.exposes);
        if (normalizedPreloadExposes.length && "modules" in moduleInfoSnapshot) {
            var _moduleInfoSnapshot_modules;
            moduleAssetsInfo = moduleInfoSnapshot == null ? void 0 : (_moduleInfoSnapshot_modules = moduleInfoSnapshot.modules) == null ? void 0 : _moduleInfoSnapshot_modules.reduce((assets, moduleAssetInfo)=>{
                if ((normalizedPreloadExposes == null ? void 0 : normalizedPreloadExposes.indexOf(moduleAssetInfo.moduleName)) !== -1) {
                    assets.push(moduleAssetInfo);
                }
                return assets;
            }, []);
        }
        function handleAssets(assets) {
            const assetsRes = assets.map((asset)=>sdk.getResourceUrl(moduleInfoSnapshot, asset));
            if (preloadConfig.filter) {
                return assetsRes.filter(preloadConfig.filter);
            }
            return assetsRes;
        }
        if (moduleAssetsInfo) {
            const assetsLength = moduleAssetsInfo.length;
            for(let index = 0; index < assetsLength; index++){
                const assetsInfo = moduleAssetsInfo[index];
                const exposeFullPath = `${remoteInfo.name}/${assetsInfo.moduleName}`;
                origin.remoteHandler.hooks.lifecycle.handlePreloadModule.emit({
                    id: assetsInfo.moduleName === "." ? remoteInfo.name : exposeFullPath,
                    name: remoteInfo.name,
                    remoteSnapshot: moduleInfoSnapshot,
                    preloadConfig,
                    remote: remoteInfo,
                    origin
                });
                const preloaded = getPreloaded(exposeFullPath);
                if (preloaded) {
                    continue;
                }
                if (preloadConfig.resourceCategory === "all") {
                    cssAssets.push(...handleAssets(assetsInfo.assets.css.async));
                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.async));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));
                // eslint-disable-next-line no-constant-condition
                } else if (preloadConfig.resourceCategory = "sync") {
                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));
                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));
                }
                setPreloaded(exposeFullPath);
            }
        }
    }, true, memo, remoteSnapshot);
    if (remoteSnapshot.shared) {
        const collectSharedAssets = (shareInfo, snapshotShared)=>{
            const registeredShared = getRegisteredShare(origin.shareScopeMap, snapshotShared.sharedName, shareInfo, origin.sharedHandler.hooks.lifecycle.resolveShare);
            // If the global share does not exist, or the lib function does not exist, it means that the shared has not been loaded yet and can be preloaded.
            if (registeredShared && typeof registeredShared.lib === "function") {
                snapshotShared.assets.js.sync.forEach((asset)=>{
                    loadedSharedJsAssets.add(asset);
                });
                snapshotShared.assets.css.sync.forEach((asset)=>{
                    loadedSharedCssAssets.add(asset);
                });
            }
        };
        remoteSnapshot.shared.forEach((shared)=>{
            var _options_shared;
            const shareInfos = (_options_shared = options.shared) == null ? void 0 : _options_shared[shared.sharedName];
            if (!shareInfos) {
                return;
            }
            // if no version, preload all shared
            const sharedOptions = shared.version ? shareInfos.find((s)=>s.version === shared.version) : shareInfos;
            if (!sharedOptions) {
                return;
            }
            const arrayShareInfo = arrayOptions(sharedOptions);
            arrayShareInfo.forEach((s)=>{
                collectSharedAssets(s, shared);
            });
        });
    }
    const needPreloadJsAssets = jsAssets.filter((asset)=>!loadedSharedJsAssets.has(asset) && !isExisted("script", asset));
    const needPreloadCssAssets = cssAssets.filter((asset)=>!loadedSharedCssAssets.has(asset) && !isExisted("link", asset));
    return {
        cssAssets: needPreloadCssAssets,
        jsAssetsWithoutEntry: needPreloadJsAssets,
        entryAssets: entryAssets.filter((entry)=>!isExisted("script", entry.url))
    };
}
const generatePreloadAssetsPlugin = function() {
    return {
        name: "generate-preload-assets-plugin",
        async generatePreloadAssets (args) {
            const { origin, preloadOptions, remoteInfo, remote, globalSnapshot, remoteSnapshot } = args;
            if (!sdk.isBrowserEnv()) {
                return {
                    cssAssets: [],
                    jsAssetsWithoutEntry: [],
                    entryAssets: []
                };
            }
            if (isRemoteInfoWithEntry(remote) && isPureRemoteEntry(remote)) {
                return {
                    cssAssets: [],
                    jsAssetsWithoutEntry: [],
                    entryAssets: [
                        {
                            name: remote.name,
                            url: remote.entry,
                            moduleInfo: {
                                name: remoteInfo.name,
                                entry: remote.entry,
                                type: remoteInfo.type || "global",
                                entryGlobalName: "",
                                shareScope: ""
                            }
                        }
                    ]
                };
            }
            assignRemoteInfo(remoteInfo, remoteSnapshot);
            const assets = generatePreloadAssets(origin, preloadOptions, remoteInfo, globalSnapshot, remoteSnapshot);
            return assets;
        }
    };
};
function getGlobalRemoteInfo(moduleInfo, origin) {
    const hostGlobalSnapshot = getGlobalSnapshotInfoByModuleInfo({
        name: origin.name,
        version: origin.options.version
    });
    // get remote detail info from global
    const globalRemoteInfo = hostGlobalSnapshot && "remotesInfo" in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && getInfoWithoutType(hostGlobalSnapshot.remotesInfo, moduleInfo.name).value;
    if (globalRemoteInfo && globalRemoteInfo.matchedVersion) {
        return {
            hostGlobalSnapshot,
            globalSnapshot: getGlobalSnapshot(),
            remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
                name: moduleInfo.name,
                version: globalRemoteInfo.matchedVersion
            })
        };
    }
    return {
        hostGlobalSnapshot: undefined,
        globalSnapshot: getGlobalSnapshot(),
        remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
            name: moduleInfo.name,
            version: "version" in moduleInfo ? moduleInfo.version : undefined
        })
    };
}
class SnapshotHandler {
    // eslint-disable-next-line max-lines-per-function
    async loadRemoteSnapshotInfo({ moduleInfo, id, expose }) {
        const { options } = this.HostInstance;
        await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({
            options,
            moduleInfo
        });
        let hostSnapshot = getGlobalSnapshotInfoByModuleInfo({
            name: this.HostInstance.options.name,
            version: this.HostInstance.options.version
        });
        if (!hostSnapshot) {
            hostSnapshot = {
                version: this.HostInstance.options.version || "",
                remoteEntry: "",
                remotesInfo: {}
            };
            addGlobalSnapshot({
                [this.HostInstance.options.name]: hostSnapshot
            });
        }
        // In dynamic loadRemote scenarios, incomplete remotesInfo delivery may occur. In such cases, the remotesInfo in the host needs to be completed in the snapshot at runtime.
        // This ensures the snapshot's integrity and helps the chrome plugin correctly identify all producer modules, ensuring that proxyable producer modules will not be missing.
        if (hostSnapshot && "remotesInfo" in hostSnapshot && !getInfoWithoutType(hostSnapshot.remotesInfo, moduleInfo.name).value) {
            if ("version" in moduleInfo || "entry" in moduleInfo) {
                hostSnapshot.remotesInfo = polyfills._extends({}, hostSnapshot == null ? void 0 : hostSnapshot.remotesInfo, {
                    [moduleInfo.name]: {
                        matchedVersion: "version" in moduleInfo ? moduleInfo.version : moduleInfo.entry
                    }
                });
            }
        }
        const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } = this.getGlobalRemoteInfo(moduleInfo);
        const { remoteSnapshot: globalRemoteSnapshot, globalSnapshot: globalSnapshotRes } = await this.hooks.lifecycle.loadSnapshot.emit({
            options,
            moduleInfo,
            hostGlobalSnapshot,
            remoteSnapshot,
            globalSnapshot
        });
        let mSnapshot;
        let gSnapshot;
        // global snapshot includes manifest or module info includes manifest
        if (globalRemoteSnapshot) {
            if (sdk.isManifestProvider(globalRemoteSnapshot)) {
                const remoteEntry = sdk.isBrowserEnv() ? globalRemoteSnapshot.remoteEntry : globalRemoteSnapshot.ssrRemoteEntry || globalRemoteSnapshot.remoteEntry || "";
                const moduleSnapshot = await this.getManifestJson(remoteEntry, moduleInfo, {});
                // eslint-disable-next-line @typescript-eslint/no-shadow
                const globalSnapshotRes = setGlobalSnapshotInfoByModuleInfo(polyfills._extends({}, moduleInfo, {
                    // The global remote may be overridden
                    // Therefore, set the snapshot key to the global address of the actual request
                    entry: remoteEntry
                }), moduleSnapshot);
                mSnapshot = moduleSnapshot;
                gSnapshot = globalSnapshotRes;
            } else {
                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                    options: this.HostInstance.options,
                    moduleInfo,
                    remoteSnapshot: globalRemoteSnapshot,
                    from: "global"
                });
                mSnapshot = remoteSnapshotRes;
                gSnapshot = globalSnapshotRes;
            }
        } else {
            if (isRemoteInfoWithEntry(moduleInfo)) {
                // get from manifest.json and merge remote info from remote server
                const moduleSnapshot = await this.getManifestJson(moduleInfo.entry, moduleInfo, {});
                // eslint-disable-next-line @typescript-eslint/no-shadow
                const globalSnapshotRes = setGlobalSnapshotInfoByModuleInfo(moduleInfo, moduleSnapshot);
                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                    options: this.HostInstance.options,
                    moduleInfo,
                    remoteSnapshot: moduleSnapshot,
                    from: "global"
                });
                mSnapshot = remoteSnapshotRes;
                gSnapshot = globalSnapshotRes;
            } else {
                error(errorCodes.getShortErrorMsg(errorCodes.RUNTIME_007, errorCodes.runtimeDescMap, {
                    hostName: moduleInfo.name,
                    hostVersion: moduleInfo.version,
                    globalSnapshot: JSON.stringify(globalSnapshotRes)
                }));
            }
        }
        await this.hooks.lifecycle.afterLoadSnapshot.emit({
            id,
            host: this.HostInstance,
            options,
            moduleInfo,
            remoteSnapshot: mSnapshot
        });
        return {
            remoteSnapshot: mSnapshot,
            globalSnapshot: gSnapshot
        };
    }
    getGlobalRemoteInfo(moduleInfo) {
        return getGlobalRemoteInfo(moduleInfo, this.HostInstance);
    }
    async getManifestJson(manifestUrl, moduleInfo, extraOptions) {
        const getManifest = async ()=>{
            let manifestJson = this.manifestCache.get(manifestUrl);
            if (manifestJson) {
                return manifestJson;
            }
            try {
                let res = await this.loaderHook.lifecycle.fetch.emit(manifestUrl, {});
                if (!res || !(res instanceof Response)) {
                    res = await fetch(manifestUrl, {});
                }
                manifestJson = await res.json();
            } catch (err) {
                manifestJson = await this.HostInstance.remoteHandler.hooks.lifecycle.errorLoadRemote.emit({
                    id: manifestUrl,
                    error: err,
                    from: "runtime",
                    lifecycle: "afterResolve",
                    origin: this.HostInstance
                });
                if (!manifestJson) {
                    delete this.manifestLoading[manifestUrl];
                    error(errorCodes.getShortErrorMsg(errorCodes.RUNTIME_003, errorCodes.runtimeDescMap, {
                        manifestUrl,
                        moduleName: moduleInfo.name,
                        hostName: this.HostInstance.options.name
                    }, `${err}`));
                }
            }
            assert(manifestJson.metaData && manifestJson.exposes && manifestJson.shared, `${manifestUrl} is not a federation manifest`);
            this.manifestCache.set(manifestUrl, manifestJson);
            return manifestJson;
        };
        const asyncLoadProcess = async ()=>{
            const manifestJson = await getManifest();
            const remoteSnapshot = sdk.generateSnapshotFromManifest(manifestJson, {
                version: manifestUrl
            });
            const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
                options: this.HostInstance.options,
                moduleInfo,
                manifestJson,
                remoteSnapshot,
                manifestUrl,
                from: "manifest"
            });
            return remoteSnapshotRes;
        };
        if (!this.manifestLoading[manifestUrl]) {
            this.manifestLoading[manifestUrl] = asyncLoadProcess().then((res)=>res);
        }
        return this.manifestLoading[manifestUrl];
    }
    constructor(HostInstance){
        this.loadingHostSnapshot = null;
        this.manifestCache = new Map();
        this.hooks = new PluginSystem({
            beforeLoadRemoteSnapshot: new AsyncHook("beforeLoadRemoteSnapshot"),
            loadSnapshot: new AsyncWaterfallHook("loadGlobalSnapshot"),
            loadRemoteSnapshot: new AsyncWaterfallHook("loadRemoteSnapshot"),
            afterLoadSnapshot: new AsyncWaterfallHook("afterLoadSnapshot")
        });
        this.manifestLoading = Global.__FEDERATION__.__MANIFEST_LOADING__;
        this.HostInstance = HostInstance;
        this.loaderHook = HostInstance.loaderHook;
    }
}
class SharedHandler {
    // register shared in shareScopeMap
    registerShared(globalOptions, userOptions) {
        const { shareInfos, shared } = formatShareConfigs(globalOptions, userOptions);
        const sharedKeys = Object.keys(shareInfos);
        sharedKeys.forEach((sharedKey)=>{
            const sharedVals = shareInfos[sharedKey];
            sharedVals.forEach((sharedVal)=>{
                const registeredShared = getRegisteredShare(this.shareScopeMap, sharedKey, sharedVal, this.hooks.lifecycle.resolveShare);
                if (!registeredShared && sharedVal && sharedVal.lib) {
                    this.setShared({
                        pkgName: sharedKey,
                        lib: sharedVal.lib,
                        get: sharedVal.get,
                        loaded: true,
                        shared: sharedVal,
                        from: userOptions.name
                    });
                }
            });
        });
        return {
            shareInfos,
            shared
        };
    }
    async loadShare(pkgName, extraOptions) {
        const { host } = this;
        // This function performs the following steps:
        // 1. Checks if the currently loaded share already exists, if not, it throws an error
        // 2. Searches globally for a matching share, if found, it uses it directly
        // 3. If not found, it retrieves it from the current share and stores the obtained share globally.
        const shareInfo = getTargetSharedOptions({
            pkgName,
            extraOptions,
            shareInfos: host.options.shared
        });
        if (shareInfo == null ? void 0 : shareInfo.scope) {
            await Promise.all(shareInfo.scope.map(async (shareScope)=>{
                await Promise.all(this.initializeSharing(shareScope, {
                    strategy: shareInfo.strategy
                }));
                return;
            }));
        }
        const loadShareRes = await this.hooks.lifecycle.beforeLoadShare.emit({
            pkgName,
            shareInfo,
            shared: host.options.shared,
            origin: host
        });
        const { shareInfo: shareInfoRes } = loadShareRes;
        // Assert that shareInfoRes exists, if not, throw an error
        assert(shareInfoRes, `Cannot find ${pkgName} Share in the ${host.options.name}. Please ensure that the ${pkgName} Share parameters have been injected`);
        // Retrieve from cache
        const registeredShared = getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
        const addUseIn = (shared)=>{
            if (!shared.useIn) {
                shared.useIn = [];
            }
            addUniqueItem(shared.useIn, host.options.name);
        };
        if (registeredShared && registeredShared.lib) {
            addUseIn(registeredShared);
            return registeredShared.lib;
        } else if (registeredShared && registeredShared.loading && !registeredShared.loaded) {
            const factory = await registeredShared.loading;
            registeredShared.loaded = true;
            if (!registeredShared.lib) {
                registeredShared.lib = factory;
            }
            addUseIn(registeredShared);
            return factory;
        } else if (registeredShared) {
            const asyncLoadProcess = async ()=>{
                const factory = await registeredShared.get();
                shareInfoRes.lib = factory;
                shareInfoRes.loaded = true;
                addUseIn(shareInfoRes);
                const gShared = getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
                if (gShared) {
                    gShared.lib = factory;
                    gShared.loaded = true;
                }
                return factory;
            };
            const loading = asyncLoadProcess();
            this.setShared({
                pkgName,
                loaded: false,
                shared: registeredShared,
                from: host.options.name,
                lib: null,
                loading
            });
            return loading;
        } else {
            if (extraOptions == null ? void 0 : extraOptions.customShareInfo) {
                return false;
            }
            const asyncLoadProcess = async ()=>{
                const factory = await shareInfoRes.get();
                shareInfoRes.lib = factory;
                shareInfoRes.loaded = true;
                addUseIn(shareInfoRes);
                const gShared = getRegisteredShare(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);
                if (gShared) {
                    gShared.lib = factory;
                    gShared.loaded = true;
                }
                return factory;
            };
            const loading = asyncLoadProcess();
            this.setShared({
                pkgName,
                loaded: false,
                shared: shareInfoRes,
                from: host.options.name,
                lib: null,
                loading
            });
            return loading;
        }
    }
    /**
   * This function initializes the sharing sequence (executed only once per share scope).
   * It accepts one argument, the name of the share scope.
   * If the share scope does not exist, it creates one.
   */ // eslint-disable-next-line @typescript-eslint/member-ordering
    initializeSharing(shareScopeName = DEFAULT_SCOPE, extraOptions) {
        const { host } = this;
        const from = extraOptions == null ? void 0 : extraOptions.from;
        const strategy = extraOptions == null ? void 0 : extraOptions.strategy;
        let initScope = extraOptions == null ? void 0 : extraOptions.initScope;
        const promises = [];
        if (from !== "build") {
            const { initTokens } = this;
            if (!initScope) initScope = [];
            let initToken = initTokens[shareScopeName];
            if (!initToken) initToken = initTokens[shareScopeName] = {
                from: this.host.name
            };
            if (initScope.indexOf(initToken) >= 0) return promises;
            initScope.push(initToken);
        }
        const shareScope = this.shareScopeMap;
        const hostName = host.options.name;
        // Creates a new share scope if necessary
        if (!shareScope[shareScopeName]) {
            shareScope[shareScopeName] = {};
        }
        // Executes all initialization snippets from all accessible modules
        const scope = shareScope[shareScopeName];
        const register = (name, shared)=>{
            var _activeVersion_shareConfig;
            const { version, eager } = shared;
            scope[name] = scope[name] || {};
            const versions = scope[name];
            const activeVersion = versions[version];
            const activeVersionEager = Boolean(activeVersion && (activeVersion.eager || ((_activeVersion_shareConfig = activeVersion.shareConfig) == null ? void 0 : _activeVersion_shareConfig.eager)));
            if (!activeVersion || activeVersion.strategy !== "loaded-first" && !activeVersion.loaded && (Boolean(!eager) !== !activeVersionEager ? eager : hostName > activeVersion.from)) {
                versions[version] = shared;
            }
        };
        const initFn = (mod)=>mod && mod.init && mod.init(shareScope[shareScopeName], initScope);
        const initRemoteModule = async (key)=>{
            const { module } = await host.remoteHandler.getRemoteModuleAndOptions({
                id: key
            });
            if (module.getEntry) {
                let remoteEntryExports;
                try {
                    remoteEntryExports = await module.getEntry();
                } catch (error) {
                    remoteEntryExports = await host.remoteHandler.hooks.lifecycle.errorLoadRemote.emit({
                        id: key,
                        error,
                        from: "runtime",
                        lifecycle: "beforeLoadShare",
                        origin: host
                    });
                }
                if (!module.inited) {
                    await initFn(remoteEntryExports);
                    module.inited = true;
                }
            }
        };
        Object.keys(host.options.shared).forEach((shareName)=>{
            const sharedArr = host.options.shared[shareName];
            sharedArr.forEach((shared)=>{
                if (shared.scope.includes(shareScopeName)) {
                    register(shareName, shared);
                }
            });
        });
        // TODO: strategy==='version-first' need to be removed in the future
        if (host.options.shareStrategy === "version-first" || strategy === "version-first") {
            host.options.remotes.forEach((remote)=>{
                if (remote.shareScope === shareScopeName) {
                    promises.push(initRemoteModule(remote.name));
                }
            });
        }
        return promises;
    }
    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.
    // 1. If the loaded shared already exists globally, then it will be reused
    // 2. If lib exists in local shared, it will be used directly
    // 3. If the local get returns something other than Promise, then it will be used directly
    loadShareSync(pkgName, extraOptions) {
        const { host } = this;
        const shareInfo = getTargetSharedOptions({
            pkgName,
            extraOptions,
            shareInfos: host.options.shared
        });
        if (shareInfo == null ? void 0 : shareInfo.scope) {
            shareInfo.scope.forEach((shareScope)=>{
                this.initializeSharing(shareScope, {
                    strategy: shareInfo.strategy
                });
            });
        }
        const registeredShared = getRegisteredShare(this.shareScopeMap, pkgName, shareInfo, this.hooks.lifecycle.resolveShare);
        const addUseIn = (shared)=>{
            if (!shared.useIn) {
                shared.useIn = [];
            }
            addUniqueItem(shared.useIn, host.options.name);
        };
        if (registeredShared) {
            if (typeof registeredShared.lib === "function") {
                addUseIn(registeredShared);
                if (!registeredShared.loaded) {
                    registeredShared.loaded = true;
                    if (registeredShared.from === host.options.name) {
                        shareInfo.loaded = true;
                    }
                }
                return registeredShared.lib;
            }
            if (typeof registeredShared.get === "function") {
                const module = registeredShared.get();
                if (!(module instanceof Promise)) {
                    addUseIn(registeredShared);
                    this.setShared({
                        pkgName,
                        loaded: true,
                        from: host.options.name,
                        lib: module,
                        shared: registeredShared
                    });
                    return module;
                }
            }
        }
        if (shareInfo.lib) {
            if (!shareInfo.loaded) {
                shareInfo.loaded = true;
            }
            return shareInfo.lib;
        }
        if (shareInfo.get) {
            const module = shareInfo.get();
            if (module instanceof Promise) {
                const errorCode = (extraOptions == null ? void 0 : extraOptions.from) === "build" ? errorCodes.RUNTIME_005 : errorCodes.RUNTIME_006;
                throw new Error(errorCodes.getShortErrorMsg(errorCode, errorCodes.runtimeDescMap, {
                    hostName: host.options.name,
                    sharedPkgName: pkgName
                }));
            }
            shareInfo.lib = module;
            this.setShared({
                pkgName,
                loaded: true,
                from: host.options.name,
                lib: shareInfo.lib,
                shared: shareInfo
            });
            return shareInfo.lib;
        }
        throw new Error(errorCodes.getShortErrorMsg(errorCodes.RUNTIME_006, errorCodes.runtimeDescMap, {
            hostName: host.options.name,
            sharedPkgName: pkgName
        }));
    }
    initShareScopeMap(scopeName, shareScope, extraOptions = {}) {
        const { host } = this;
        this.shareScopeMap[scopeName] = shareScope;
        this.hooks.lifecycle.initContainerShareScopeMap.emit({
            shareScope,
            options: host.options,
            origin: host,
            scopeName,
            hostShareScopeMap: extraOptions.hostShareScopeMap
        });
    }
    setShared({ pkgName, shared, from, lib, loading, loaded, get }) {
        const { version, scope = "default" } = shared, shareInfo = polyfills._object_without_properties_loose(shared, [
            "version",
            "scope"
        ]);
        const scopes = Array.isArray(scope) ? scope : [
            scope
        ];
        scopes.forEach((sc)=>{
            if (!this.shareScopeMap[sc]) {
                this.shareScopeMap[sc] = {};
            }
            if (!this.shareScopeMap[sc][pkgName]) {
                this.shareScopeMap[sc][pkgName] = {};
            }
            if (!this.shareScopeMap[sc][pkgName][version]) {
                this.shareScopeMap[sc][pkgName][version] = polyfills._extends({
                    version,
                    scope: [
                        "default"
                    ]
                }, shareInfo, {
                    lib,
                    loaded,
                    loading
                });
                if (get) {
                    this.shareScopeMap[sc][pkgName][version].get = get;
                }
                return;
            }
            const registeredShared = this.shareScopeMap[sc][pkgName][version];
            if (loading && !registeredShared.loading) {
                registeredShared.loading = loading;
            }
        });
    }
    _setGlobalShareScopeMap(hostOptions) {
        const globalShareScopeMap = getGlobalShareScope();
        const identifier = hostOptions.id || hostOptions.name;
        if (identifier && !globalShareScopeMap[identifier]) {
            globalShareScopeMap[identifier] = this.shareScopeMap;
        }
    }
    constructor(host){
        this.hooks = new PluginSystem({
            afterResolve: new AsyncWaterfallHook("afterResolve"),
            beforeLoadShare: new AsyncWaterfallHook("beforeLoadShare"),
            // not used yet
            loadShare: new AsyncHook(),
            resolveShare: new SyncWaterfallHook("resolveShare"),
            // maybe will change, temporarily for internal use only
            initContainerShareScopeMap: new SyncWaterfallHook("initContainerShareScopeMap")
        });
        this.host = host;
        this.shareScopeMap = {};
        this.initTokens = {};
        this._setGlobalShareScopeMap(host.options);
    }
}
class RemoteHandler {
    formatAndRegisterRemote(globalOptions, userOptions) {
        const userRemotes = userOptions.remotes || [];
        return userRemotes.reduce((res, remote)=>{
            this.registerRemote(remote, res, {
                force: false
            });
            return res;
        }, globalOptions.remotes);
    }
    setIdToRemoteMap(id, remoteMatchInfo) {
        const { remote, expose } = remoteMatchInfo;
        const { name, alias } = remote;
        this.idToRemoteMap[id] = {
            name: remote.name,
            expose
        };
        if (alias && id.startsWith(name)) {
            const idWithAlias = id.replace(name, alias);
            this.idToRemoteMap[idWithAlias] = {
                name: remote.name,
                expose
            };
            return;
        }
        if (alias && id.startsWith(alias)) {
            const idWithName = id.replace(alias, name);
            this.idToRemoteMap[idWithName] = {
                name: remote.name,
                expose
            };
        }
    }
    // eslint-disable-next-line max-lines-per-function
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async loadRemote(id, options) {
        const { host } = this;
        try {
            const { loadFactory = true } = options || {
                loadFactory: true
            };
            // 1. Validate the parameters of the retrieved module. There are two module request methods: pkgName + expose and alias + expose.
            // 2. Request the snapshot information of the current host and globally store the obtained snapshot information. The retrieved module information is partially offline and partially online. The online module information will retrieve the modules used online.
            // 3. Retrieve the detailed information of the current module from global (remoteEntry address, expose resource address)
            // 4. After retrieving remoteEntry, call the init of the module, and then retrieve the exported content of the module through get
            // id: pkgName(@federation/app1) + expose(button) = @federation/app1/button
            // id: alias(app1) + expose(button) = app1/button
            // id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort
            const { module, moduleOptions, remoteMatchInfo } = await this.getRemoteModuleAndOptions({
                id
            });
            const { pkgNameOrAlias, remote, expose, id: idRes, remoteSnapshot } = remoteMatchInfo;
            const moduleOrFactory = await module.get(idRes, expose, options, remoteSnapshot);
            const moduleWrapper = await this.hooks.lifecycle.onLoad.emit({
                id: idRes,
                pkgNameOrAlias,
                expose,
                exposeModule: loadFactory ? moduleOrFactory : undefined,
                exposeModuleFactory: loadFactory ? undefined : moduleOrFactory,
                remote,
                options: moduleOptions,
                moduleInstance: module,
                origin: host
            });
            this.setIdToRemoteMap(id, remoteMatchInfo);
            if (typeof moduleWrapper === "function") {
                return moduleWrapper;
            }
            return moduleOrFactory;
        } catch (error) {
            const { from = "runtime" } = options || {
                from: "runtime"
            };
            const failOver = await this.hooks.lifecycle.errorLoadRemote.emit({
                id,
                error,
                from,
                lifecycle: "onLoad",
                origin: host
            });
            if (!failOver) {
                throw error;
            }
            return failOver;
        }
    }
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async preloadRemote(preloadOptions) {
        const { host } = this;
        await this.hooks.lifecycle.beforePreloadRemote.emit({
            preloadOps: preloadOptions,
            options: host.options,
            origin: host
        });
        const preloadOps = formatPreloadArgs(host.options.remotes, preloadOptions);
        await Promise.all(preloadOps.map(async (ops)=>{
            const { remote } = ops;
            const remoteInfo = getRemoteInfo(remote);
            const { globalSnapshot, remoteSnapshot } = await host.snapshotHandler.loadRemoteSnapshotInfo({
                moduleInfo: remote
            });
            const assets = await this.hooks.lifecycle.generatePreloadAssets.emit({
                origin: host,
                preloadOptions: ops,
                remote,
                remoteInfo,
                globalSnapshot,
                remoteSnapshot
            });
            if (!assets) {
                return;
            }
            preloadAssets(remoteInfo, host, assets);
        }));
    }
    registerRemotes(remotes, options) {
        const { host } = this;
        remotes.forEach((remote)=>{
            this.registerRemote(remote, host.options.remotes, {
                force: options == null ? void 0 : options.force
            });
        });
    }
    async getRemoteModuleAndOptions(options) {
        const { host } = this;
        const { id } = options;
        let loadRemoteArgs;
        try {
            loadRemoteArgs = await this.hooks.lifecycle.beforeRequest.emit({
                id,
                options: host.options,
                origin: host
            });
        } catch (error) {
            loadRemoteArgs = await this.hooks.lifecycle.errorLoadRemote.emit({
                id,
                options: host.options,
                origin: host,
                from: "runtime",
                error,
                lifecycle: "beforeRequest"
            });
            if (!loadRemoteArgs) {
                throw error;
            }
        }
        const { id: idRes } = loadRemoteArgs;
        const remoteSplitInfo = matchRemoteWithNameAndExpose(host.options.remotes, idRes);
        assert(remoteSplitInfo, errorCodes.getShortErrorMsg(errorCodes.RUNTIME_004, errorCodes.runtimeDescMap, {
            hostName: host.options.name,
            requestId: idRes
        }));
        const { remote: rawRemote } = remoteSplitInfo;
        const remoteInfo = getRemoteInfo(rawRemote);
        const matchInfo = await host.sharedHandler.hooks.lifecycle.afterResolve.emit(polyfills._extends({
            id: idRes
        }, remoteSplitInfo, {
            options: host.options,
            origin: host,
            remoteInfo
        }));
        const { remote, expose } = matchInfo;
        assert(remote && expose, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${idRes}.`);
        let module = host.moduleCache.get(remote.name);
        const moduleOptions = {
            host: host,
            remoteInfo
        };
        if (!module) {
            module = new Module(moduleOptions);
            host.moduleCache.set(remote.name, module);
        }
        return {
            module,
            moduleOptions,
            remoteMatchInfo: matchInfo
        };
    }
    registerRemote(remote, targetRemotes, options) {
        const { host } = this;
        const normalizeRemote = ()=>{
            if (remote.alias) {
                // Validate if alias equals the prefix of remote.name and remote.alias, if so, throw an error
                // As multi-level path references cannot guarantee unique names, alias being a prefix of remote.name is not supported
                const findEqual = targetRemotes.find((item)=>{
                    var _item_alias;
                    return remote.alias && (item.name.startsWith(remote.alias) || ((_item_alias = item.alias) == null ? void 0 : _item_alias.startsWith(remote.alias)));
                });
                assert(!findEqual, `The alias ${remote.alias} of remote ${remote.name} is not allowed to be the prefix of ${findEqual && findEqual.name} name or alias`);
            }
            // Set the remote entry to a complete path
            if ("entry" in remote) {
                if (sdk.isBrowserEnv() && !remote.entry.startsWith("http")) {
                    remote.entry = new URL(remote.entry, window.location.origin).href;
                }
            }
            if (!remote.shareScope) {
                remote.shareScope = DEFAULT_SCOPE;
            }
            if (!remote.type) {
                remote.type = DEFAULT_REMOTE_TYPE;
            }
        };
        this.hooks.lifecycle.beforeRegisterRemote.emit({
            remote,
            origin: host
        });
        const registeredRemote = targetRemotes.find((item)=>item.name === remote.name);
        if (!registeredRemote) {
            normalizeRemote();
            targetRemotes.push(remote);
            this.hooks.lifecycle.registerRemote.emit({
                remote,
                origin: host
            });
        } else {
            const messages = [
                `The remote "${remote.name}" is already registered.`,
                "Please note that overriding it may cause unexpected errors."
            ];
            if (options == null ? void 0 : options.force) {
                // remove registered remote
                this.removeRemote(registeredRemote);
                normalizeRemote();
                targetRemotes.push(remote);
                this.hooks.lifecycle.registerRemote.emit({
                    remote,
                    origin: host
                });
                sdk.warn(messages.join(" "));
            }
        }
    }
    removeRemote(remote) {
        try {
            const { host } = this;
            const { name } = remote;
            const remoteIndex = host.options.remotes.findIndex((item)=>item.name === name);
            if (remoteIndex !== -1) {
                host.options.remotes.splice(remoteIndex, 1);
            }
            const loadedModule = host.moduleCache.get(remote.name);
            if (loadedModule) {
                const remoteInfo = loadedModule.remoteInfo;
                const key = remoteInfo.entryGlobalName;
                if (CurrentGlobal[key]) {
                    var _Object_getOwnPropertyDescriptor;
                    if ((_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(CurrentGlobal, key)) == null ? void 0 : _Object_getOwnPropertyDescriptor.configurable) {
                        delete CurrentGlobal[key];
                    } else {
                        // @ts-ignore
                        CurrentGlobal[key] = undefined;
                    }
                }
                const remoteEntryUniqueKey = getRemoteEntryUniqueKey(loadedModule.remoteInfo);
                if (globalLoading[remoteEntryUniqueKey]) {
                    delete globalLoading[remoteEntryUniqueKey];
                }
                host.snapshotHandler.manifestCache.delete(remoteInfo.entry);
                // delete unloaded shared and instance
                let remoteInsId = remoteInfo.buildVersion ? sdk.composeKeyWithSeparator(remoteInfo.name, remoteInfo.buildVersion) : remoteInfo.name;
                const remoteInsIndex = CurrentGlobal.__FEDERATION__.__INSTANCES__.findIndex((ins)=>{
                    if (remoteInfo.buildVersion) {
                        return ins.options.id === remoteInsId;
                    } else {
                        return ins.name === remoteInsId;
                    }
                });
                if (remoteInsIndex !== -1) {
                    const remoteIns = CurrentGlobal.__FEDERATION__.__INSTANCES__[remoteInsIndex];
                    remoteInsId = remoteIns.options.id || remoteInsId;
                    const globalShareScopeMap = getGlobalShareScope();
                    let isAllSharedNotUsed = true;
                    const needDeleteKeys = [];
                    Object.keys(globalShareScopeMap).forEach((instId)=>{
                        const shareScopeMap = globalShareScopeMap[instId];
                        shareScopeMap && Object.keys(shareScopeMap).forEach((shareScope)=>{
                            const shareScopeVal = shareScopeMap[shareScope];
                            shareScopeVal && Object.keys(shareScopeVal).forEach((shareName)=>{
                                const sharedPkgs = shareScopeVal[shareName];
                                sharedPkgs && Object.keys(sharedPkgs).forEach((shareVersion)=>{
                                    const shared = sharedPkgs[shareVersion];
                                    if (shared && typeof shared === "object" && shared.from === remoteInfo.name) {
                                        if (shared.loaded || shared.loading) {
                                            shared.useIn = shared.useIn.filter((usedHostName)=>usedHostName !== remoteInfo.name);
                                            if (shared.useIn.length) {
                                                isAllSharedNotUsed = false;
                                            } else {
                                                needDeleteKeys.push([
                                                    instId,
                                                    shareScope,
                                                    shareName,
                                                    shareVersion
                                                ]);
                                            }
                                        } else {
                                            needDeleteKeys.push([
                                                instId,
                                                shareScope,
                                                shareName,
                                                shareVersion
                                            ]);
                                        }
                                    }
                                });
                            });
                        });
                    });
                    if (isAllSharedNotUsed) {
                        remoteIns.shareScopeMap = {};
                        delete globalShareScopeMap[remoteInsId];
                    }
                    needDeleteKeys.forEach(([insId, shareScope, shareName, shareVersion])=>{
                        var _globalShareScopeMap_insId_shareScope_shareName, _globalShareScopeMap_insId_shareScope, _globalShareScopeMap_insId;
                        (_globalShareScopeMap_insId = globalShareScopeMap[insId]) == null ? true : (_globalShareScopeMap_insId_shareScope = _globalShareScopeMap_insId[shareScope]) == null ? true : (_globalShareScopeMap_insId_shareScope_shareName = _globalShareScopeMap_insId_shareScope[shareName]) == null ? true : delete _globalShareScopeMap_insId_shareScope_shareName[shareVersion];
                    });
                    CurrentGlobal.__FEDERATION__.__INSTANCES__.splice(remoteInsIndex, 1);
                }
                const { hostGlobalSnapshot } = getGlobalRemoteInfo(remote, host);
                if (hostGlobalSnapshot) {
                    const remoteKey = hostGlobalSnapshot && "remotesInfo" in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && getInfoWithoutType(hostGlobalSnapshot.remotesInfo, remote.name).key;
                    if (remoteKey) {
                        delete hostGlobalSnapshot.remotesInfo[remoteKey];
                        if (Boolean(Global.__FEDERATION__.__MANIFEST_LOADING__[remoteKey])) {
                            delete Global.__FEDERATION__.__MANIFEST_LOADING__[remoteKey];
                        }
                    }
                }
                host.moduleCache.delete(remote.name);
            }
        } catch (err) {
            logger.log("removeRemote fail: ", err);
        }
    }
    constructor(host){
        this.hooks = new PluginSystem({
            beforeRegisterRemote: new SyncWaterfallHook("beforeRegisterRemote"),
            registerRemote: new SyncWaterfallHook("registerRemote"),
            beforeRequest: new AsyncWaterfallHook("beforeRequest"),
            onLoad: new AsyncHook("onLoad"),
            handlePreloadModule: new SyncHook("handlePreloadModule"),
            errorLoadRemote: new AsyncHook("errorLoadRemote"),
            beforePreloadRemote: new AsyncHook("beforePreloadRemote"),
            generatePreloadAssets: new AsyncHook("generatePreloadAssets"),
            // not used yet
            afterPreloadRemote: new AsyncHook(),
            loadEntry: new AsyncHook()
        });
        this.host = host;
        this.idToRemoteMap = {};
    }
}
const USE_SNAPSHOT =  true ? !false : 0; // Default to true (use snapshot) when not explicitly defined
class FederationHost {
    initOptions(userOptions) {
        this.registerPlugins(userOptions.plugins);
        const options = this.formatOptions(this.options, userOptions);
        this.options = options;
        return options;
    }
    async loadShare(pkgName, extraOptions) {
        return this.sharedHandler.loadShare(pkgName, extraOptions);
    }
    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.
    // 1. If the loaded shared already exists globally, then it will be reused
    // 2. If lib exists in local shared, it will be used directly
    // 3. If the local get returns something other than Promise, then it will be used directly
    loadShareSync(pkgName, extraOptions) {
        return this.sharedHandler.loadShareSync(pkgName, extraOptions);
    }
    initializeSharing(shareScopeName = DEFAULT_SCOPE, extraOptions) {
        return this.sharedHandler.initializeSharing(shareScopeName, extraOptions);
    }
    initRawContainer(name, url, container) {
        const remoteInfo = getRemoteInfo({
            name,
            entry: url
        });
        const module = new Module({
            host: this,
            remoteInfo
        });
        module.remoteEntryExports = container;
        this.moduleCache.set(name, module);
        return module;
    }
    // eslint-disable-next-line max-lines-per-function
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async loadRemote(id, options) {
        return this.remoteHandler.loadRemote(id, options);
    }
    // eslint-disable-next-line @typescript-eslint/member-ordering
    async preloadRemote(preloadOptions) {
        return this.remoteHandler.preloadRemote(preloadOptions);
    }
    initShareScopeMap(scopeName, shareScope, extraOptions = {}) {
        this.sharedHandler.initShareScopeMap(scopeName, shareScope, extraOptions);
    }
    formatOptions(globalOptions, userOptions) {
        const { shared } = formatShareConfigs(globalOptions, userOptions);
        const { userOptions: userOptionsRes, options: globalOptionsRes } = this.hooks.lifecycle.beforeInit.emit({
            origin: this,
            userOptions,
            options: globalOptions,
            shareInfo: shared
        });
        const remotes = this.remoteHandler.formatAndRegisterRemote(globalOptionsRes, userOptionsRes);
        const { shared: handledShared } = this.sharedHandler.registerShared(globalOptionsRes, userOptionsRes);
        const plugins = [
            ...globalOptionsRes.plugins
        ];
        if (userOptionsRes.plugins) {
            userOptionsRes.plugins.forEach((plugin)=>{
                if (!plugins.includes(plugin)) {
                    plugins.push(plugin);
                }
            });
        }
        const optionsRes = polyfills._extends({}, globalOptions, userOptions, {
            plugins,
            remotes,
            shared: handledShared
        });
        this.hooks.lifecycle.init.emit({
            origin: this,
            options: optionsRes
        });
        return optionsRes;
    }
    registerPlugins(plugins) {
        const pluginRes = registerPlugins(plugins, [
            this.hooks,
            this.remoteHandler.hooks,
            this.sharedHandler.hooks,
            this.snapshotHandler.hooks,
            this.loaderHook,
            this.bridgeHook
        ]);
        // Merge plugin
        this.options.plugins = this.options.plugins.reduce((res, plugin)=>{
            if (!plugin) return res;
            if (res && !res.find((item)=>item.name === plugin.name)) {
                res.push(plugin);
            }
            return res;
        }, pluginRes || []);
    }
    registerRemotes(remotes, options) {
        return this.remoteHandler.registerRemotes(remotes, options);
    }
    constructor(userOptions){
        this.hooks = new PluginSystem({
            beforeInit: new SyncWaterfallHook("beforeInit"),
            init: new SyncHook(),
            // maybe will change, temporarily for internal use only
            beforeInitContainer: new AsyncWaterfallHook("beforeInitContainer"),
            // maybe will change, temporarily for internal use only
            initContainer: new AsyncWaterfallHook("initContainer")
        });
        this.version = "0.15.0";
        this.moduleCache = new Map();
        this.loaderHook = new PluginSystem({
            // FIXME: may not be suitable , not open to the public yet
            getModuleInfo: new SyncHook(),
            createScript: new SyncHook(),
            createLink: new SyncHook(),
            fetch: new AsyncHook(),
            loadEntryError: new AsyncHook(),
            getModuleFactory: new AsyncHook()
        });
        this.bridgeHook = new PluginSystem({
            beforeBridgeRender: new SyncHook(),
            afterBridgeRender: new SyncHook(),
            beforeBridgeDestroy: new SyncHook(),
            afterBridgeDestroy: new SyncHook()
        });
        const plugins = USE_SNAPSHOT ? [
            snapshotPlugin(),
            generatePreloadAssetsPlugin()
        ] : [];
        // TODO: Validate the details of the options
        // Initialize options with default values
        const defaultOptions = {
            id: getBuilderId(),
            name: userOptions.name,
            plugins,
            remotes: [],
            shared: {},
            inBrowser: sdk.isBrowserEnv()
        };
        this.name = userOptions.name;
        this.options = defaultOptions;
        this.snapshotHandler = new SnapshotHandler(this);
        this.sharedHandler = new SharedHandler(this);
        this.remoteHandler = new RemoteHandler(this);
        this.shareScopeMap = this.sharedHandler.shareScopeMap;
        this.registerPlugins([
            ...defaultOptions.plugins,
            ...userOptions.plugins || []
        ]);
        this.options = this.formatOptions(defaultOptions, userOptions);
    }
}
var index = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
exports.loadScript = sdk.loadScript;
exports.loadScriptNode = sdk.loadScriptNode;
exports.CurrentGlobal = CurrentGlobal;
exports.FederationHost = FederationHost;
exports.Global = Global;
exports.Module = Module;
exports.addGlobalSnapshot = addGlobalSnapshot;
exports.assert = assert;
exports.getGlobalFederationConstructor = getGlobalFederationConstructor;
exports.getGlobalSnapshot = getGlobalSnapshot;
exports.getInfoWithoutType = getInfoWithoutType;
exports.getRegisteredShare = getRegisteredShare;
exports.getRemoteEntry = getRemoteEntry;
exports.getRemoteInfo = getRemoteInfo;
exports.helpers = helpers;
exports.isStaticResourcesEqual = isStaticResourcesEqual;
exports.matchRemoteWithNameAndExpose = matchRemoteWithNameAndExpose;
exports.registerGlobalPlugins = registerGlobalPlugins;
exports.resetFederationGlobalInfo = resetFederationGlobalInfo;
exports.safeWrapper = safeWrapper;
exports.satisfy = satisfy;
exports.setGlobalFederationConstructor = setGlobalFederationConstructor;
exports.setGlobalFederationInstance = setGlobalFederationInstance;
exports.types = index;


/***/ }),

/***/ "../../packages/runtime-core/dist/polyfills.cjs.cjs":
/*!**********************************************************!*\
  !*** ../../packages/runtime-core/dist/polyfills.cjs.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
exports._extends = _extends;
exports._object_without_properties_loose = _object_without_properties_loose;


/***/ }),

/***/ "../../packages/runtime/dist/helpers.cjs.cjs":
/*!***************************************************!*\
  !*** ../../packages/runtime/dist/helpers.cjs.cjs ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var polyfills = __webpack_require__(/*! ./polyfills.cjs.cjs */ "../../packages/runtime/dist/polyfills.cjs.cjs");
var runtimeCore = __webpack_require__(/*! @module-federation/runtime-core */ "../../packages/runtime-core/dist/index.cjs.cjs");
var utils = __webpack_require__(/*! ./utils.cjs.cjs */ "../../packages/runtime/dist/utils.cjs.cjs");
var helpers = {
    global: polyfills._extends({}, runtimeCore.helpers.global, {
        getGlobalFederationInstance: utils.getGlobalFederationInstance
    }),
    share: runtimeCore.helpers.share
};
module.exports = helpers;


/***/ }),

/***/ "../../packages/runtime/dist/polyfills.cjs.cjs":
/*!*****************************************************!*\
  !*** ../../packages/runtime/dist/polyfills.cjs.cjs ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
exports._extends = _extends;


/***/ }),

/***/ "../../packages/runtime/dist/utils.cjs.cjs":
/*!*************************************************!*\
  !*** ../../packages/runtime/dist/utils.cjs.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var runtimeCore = __webpack_require__(/*! @module-federation/runtime-core */ "../../packages/runtime-core/dist/index.cjs.cjs");
// injected by bundler, so it can not use runtime-core stuff
function getBuilderId() {
    //@ts-ignore
    return  true ? "home_app:1.0.0" : 0;
}
function getGlobalFederationInstance(name, version) {
    const buildId = getBuilderId();
    return runtimeCore.CurrentGlobal.__FEDERATION__.__INSTANCES__.find((GMInstance)=>{
        if (buildId && GMInstance.options.id === getBuilderId()) {
            return true;
        }
        if (GMInstance.options.name === name && !GMInstance.options.version && !version) {
            return true;
        }
        if (GMInstance.options.name === name && version && GMInstance.options.version === version) {
            return true;
        }
        return false;
    });
}
exports.getGlobalFederationInstance = getGlobalFederationInstance;


/***/ }),

/***/ "../../packages/sdk/dist/index.cjs.cjs":
/*!*********************************************!*\
  !*** ../../packages/sdk/dist/index.cjs.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var polyfills = __webpack_require__(/*! ./polyfills.cjs.cjs */ "../../packages/sdk/dist/polyfills.cjs.cjs");
const FederationModuleManifest = "federation-manifest.json";
const MANIFEST_EXT = ".json";
const BROWSER_LOG_KEY = "FEDERATION_DEBUG";
const NameTransformSymbol = {
    AT: "@",
    HYPHEN: "-",
    SLASH: "/"
};
const NameTransformMap = {
    [NameTransformSymbol.AT]: "scope_",
    [NameTransformSymbol.HYPHEN]: "_",
    [NameTransformSymbol.SLASH]: "__"
};
const EncodedNameTransformMap = {
    [NameTransformMap[NameTransformSymbol.AT]]: NameTransformSymbol.AT,
    [NameTransformMap[NameTransformSymbol.HYPHEN]]: NameTransformSymbol.HYPHEN,
    [NameTransformMap[NameTransformSymbol.SLASH]]: NameTransformSymbol.SLASH
};
const SEPARATOR = ":";
const ManifestFileName = "mf-manifest.json";
const StatsFileName = "mf-stats.json";
const MFModuleType = {
    NPM: "npm",
    APP: "app"
};
const MODULE_DEVTOOL_IDENTIFIER = "__MF_DEVTOOLS_MODULE_INFO__";
const ENCODE_NAME_PREFIX = "ENCODE_NAME_PREFIX";
const TEMP_DIR = ".federation";
const MFPrefetchCommon = {
    identifier: "MFDataPrefetch",
    globalKey: "__PREFETCH__",
    library: "mf-data-prefetch",
    exportsKey: "__PREFETCH_EXPORTS__",
    fileName: "bootstrap.js"
};
var ContainerPlugin = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
var ContainerReferencePlugin = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
var ModuleFederationPlugin = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
var SharePlugin = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
function isBrowserEnv() {
    return  false && 0;
}
function isReactNativeEnv() {
    var _navigator;
    return typeof navigator !== "undefined" && ((_navigator = navigator) == null ? void 0 : _navigator.product) === "ReactNative";
}
function isBrowserDebug() {
    try {
        if (isBrowserEnv() && window.localStorage) {
            return Boolean(localStorage.getItem(BROWSER_LOG_KEY));
        }
    } catch (error1) {
        return false;
    }
    return false;
}
function isDebugMode() {
    if (typeof process !== "undefined" && process.env && process.env["FEDERATION_DEBUG"]) {
        return Boolean(process.env["FEDERATION_DEBUG"]);
    }
    if (typeof FEDERATION_DEBUG !== "undefined" && Boolean(FEDERATION_DEBUG)) {
        return true;
    }
    return isBrowserDebug();
}
const getProcessEnv = function() {
    return typeof process !== "undefined" && process.env ? process.env : {};
};
const LOG_CATEGORY = "[ Federation Runtime ]";
// entry: name:version   version : 1.0.0 | ^1.2.3
// entry: name:entry  entry:  https://localhost:9000/federation-manifest.json
const parseEntry = (str, devVerOrUrl, separator = SEPARATOR)=>{
    const strSplit = str.split(separator);
    const devVersionOrUrl = getProcessEnv()["NODE_ENV"] === "development" && devVerOrUrl;
    const defaultVersion = "*";
    const isEntry = (s)=>s.startsWith("http") || s.includes(MANIFEST_EXT);
    // Check if the string starts with a type
    if (strSplit.length >= 2) {
        let [name, ...versionOrEntryArr] = strSplit;
        // @name@manifest-url.json
        if (str.startsWith(separator)) {
            name = strSplit.slice(0, 2).join(separator);
            versionOrEntryArr = [
                devVersionOrUrl || strSplit.slice(2).join(separator)
            ];
        }
        let versionOrEntry = devVersionOrUrl || versionOrEntryArr.join(separator);
        if (isEntry(versionOrEntry)) {
            return {
                name,
                entry: versionOrEntry
            };
        } else {
            // Apply version rule
            // devVersionOrUrl => inputVersion => defaultVersion
            return {
                name,
                version: versionOrEntry || defaultVersion
            };
        }
    } else if (strSplit.length === 1) {
        const [name] = strSplit;
        if (devVersionOrUrl && isEntry(devVersionOrUrl)) {
            return {
                name,
                entry: devVersionOrUrl
            };
        }
        return {
            name,
            version: devVersionOrUrl || defaultVersion
        };
    } else {
        throw `Invalid entry value: ${str}`;
    }
};
const composeKeyWithSeparator = function(...args) {
    if (!args.length) {
        return "";
    }
    return args.reduce((sum, cur)=>{
        if (!cur) {
            return sum;
        }
        if (!sum) {
            return cur;
        }
        return `${sum}${SEPARATOR}${cur}`;
    }, "");
};
const encodeName = function(name, prefix = "", withExt = false) {
    try {
        const ext = withExt ? ".js" : "";
        return `${prefix}${name.replace(new RegExp(`${NameTransformSymbol.AT}`, "g"), NameTransformMap[NameTransformSymbol.AT]).replace(new RegExp(`${NameTransformSymbol.HYPHEN}`, "g"), NameTransformMap[NameTransformSymbol.HYPHEN]).replace(new RegExp(`${NameTransformSymbol.SLASH}`, "g"), NameTransformMap[NameTransformSymbol.SLASH])}${ext}`;
    } catch (err) {
        throw err;
    }
};
const decodeName = function(name, prefix, withExt) {
    try {
        let decodedName = name;
        if (prefix) {
            if (!decodedName.startsWith(prefix)) {
                return decodedName;
            }
            decodedName = decodedName.replace(new RegExp(prefix, "g"), "");
        }
        decodedName = decodedName.replace(new RegExp(`${NameTransformMap[NameTransformSymbol.AT]}`, "g"), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.AT]]).replace(new RegExp(`${NameTransformMap[NameTransformSymbol.SLASH]}`, "g"), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.SLASH]]).replace(new RegExp(`${NameTransformMap[NameTransformSymbol.HYPHEN]}`, "g"), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.HYPHEN]]);
        if (withExt) {
            decodedName = decodedName.replace(".js", "");
        }
        return decodedName;
    } catch (err) {
        throw err;
    }
};
const generateExposeFilename = (exposeName, withExt)=>{
    if (!exposeName) {
        return "";
    }
    let expose = exposeName;
    if (expose === ".") {
        expose = "default_export";
    }
    if (expose.startsWith("./")) {
        expose = expose.replace("./", "");
    }
    return encodeName(expose, "__federation_expose_", withExt);
};
const generateShareFilename = (pkgName, withExt)=>{
    if (!pkgName) {
        return "";
    }
    return encodeName(pkgName, "__federation_shared_", withExt);
};
const getResourceUrl = (module, sourceUrl)=>{
    if ("getPublicPath" in module) {
        let publicPath;
        if (!module.getPublicPath.startsWith("function")) {
            publicPath = new Function(module.getPublicPath)();
        } else {
            publicPath = new Function("return " + module.getPublicPath)()();
        }
        return `${publicPath}${sourceUrl}`;
    } else if ("publicPath" in module) {
        if (!isBrowserEnv() && !isReactNativeEnv() && "ssrPublicPath" in module) {
            return `${module.ssrPublicPath}${sourceUrl}`;
        }
        return `${module.publicPath}${sourceUrl}`;
    } else {
        console.warn("Cannot get resource URL. If in debug mode, please ignore.", module, sourceUrl);
        return "";
    }
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
const assert = (condition, msg)=>{
    if (!condition) {
        error(msg);
    }
};
const error = (msg)=>{
    throw new Error(`${LOG_CATEGORY}: ${msg}`);
};
const warn = (msg)=>{
    console.warn(`${LOG_CATEGORY}: ${msg}`);
};
function safeToString(info) {
    try {
        return JSON.stringify(info, null, 2);
    } catch (e) {
        return "";
    }
}
// RegExp for version string
const VERSION_PATTERN_REGEXP = /^([\d^=v<>~]|[*xX]$)/;
function isRequiredVersion(str) {
    return VERSION_PATTERN_REGEXP.test(str);
}
const simpleJoinRemoteEntry = (rPath, rName)=>{
    if (!rPath) {
        return rName;
    }
    const transformPath = (str)=>{
        if (str === ".") {
            return "";
        }
        if (str.startsWith("./")) {
            return str.replace("./", "");
        }
        if (str.startsWith("/")) {
            const strWithoutSlash = str.slice(1);
            if (strWithoutSlash.endsWith("/")) {
                return strWithoutSlash.slice(0, -1);
            }
            return strWithoutSlash;
        }
        return str;
    };
    const transformedPath = transformPath(rPath);
    if (!transformedPath) {
        return rName;
    }
    if (transformedPath.endsWith("/")) {
        return `${transformedPath}${rName}`;
    }
    return `${transformedPath}/${rName}`;
};
function inferAutoPublicPath(url) {
    return url.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
}
// Priority: overrides > remotes
// eslint-disable-next-line max-lines-per-function
function generateSnapshotFromManifest(manifest, options = {}) {
    var _manifest_metaData, _manifest_metaData1;
    const { remotes = {}, overrides = {}, version } = options;
    let remoteSnapshot;
    const getPublicPath = ()=>{
        if ("publicPath" in manifest.metaData) {
            if (manifest.metaData.publicPath === "auto" && version) {
                // use same implementation as publicPath auto runtime module implements
                return inferAutoPublicPath(version);
            }
            return manifest.metaData.publicPath;
        } else {
            return manifest.metaData.getPublicPath;
        }
    };
    const overridesKeys = Object.keys(overrides);
    let remotesInfo = {};
    // If remotes are not provided, only the remotes in the manifest will be read
    if (!Object.keys(remotes).length) {
        var _manifest_remotes;
        remotesInfo = ((_manifest_remotes = manifest.remotes) == null ? void 0 : _manifest_remotes.reduce((res, next)=>{
            let matchedVersion;
            const name = next.federationContainerName;
            // overrides have higher priority
            if (overridesKeys.includes(name)) {
                matchedVersion = overrides[name];
            } else {
                if ("version" in next) {
                    matchedVersion = next.version;
                } else {
                    matchedVersion = next.entry;
                }
            }
            res[name] = {
                matchedVersion
            };
            return res;
        }, {})) || {};
    }
    // If remotes (deploy scenario) are specified, they need to be traversed again
    Object.keys(remotes).forEach((key)=>remotesInfo[key] = {
            // overrides will override dependencies
            matchedVersion: overridesKeys.includes(key) ? overrides[key] : remotes[key]
        });
    const { remoteEntry: { path: remoteEntryPath, name: remoteEntryName, type: remoteEntryType }, types: remoteTypes, buildInfo: { buildVersion }, globalName, ssrRemoteEntry } = manifest.metaData;
    const { exposes } = manifest;
    let basicRemoteSnapshot = {
        version: version ? version : "",
        buildVersion,
        globalName,
        remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),
        remoteEntryType,
        remoteTypes: simpleJoinRemoteEntry(remoteTypes.path, remoteTypes.name),
        remoteTypesZip: remoteTypes.zip || "",
        remoteTypesAPI: remoteTypes.api || "",
        remotesInfo,
        shared: manifest == null ? void 0 : manifest.shared.map((item)=>({
                assets: item.assets,
                sharedName: item.name,
                version: item.version
            })),
        modules: exposes == null ? void 0 : exposes.map((expose)=>({
                moduleName: expose.name,
                modulePath: expose.path,
                assets: expose.assets
            }))
    };
    if ((_manifest_metaData = manifest.metaData) == null ? void 0 : _manifest_metaData.prefetchInterface) {
        const prefetchInterface = manifest.metaData.prefetchInterface;
        basicRemoteSnapshot = polyfills._({}, basicRemoteSnapshot, {
            prefetchInterface
        });
    }
    if ((_manifest_metaData1 = manifest.metaData) == null ? void 0 : _manifest_metaData1.prefetchEntry) {
        const { path, name, type } = manifest.metaData.prefetchEntry;
        basicRemoteSnapshot = polyfills._({}, basicRemoteSnapshot, {
            prefetchEntry: simpleJoinRemoteEntry(path, name),
            prefetchEntryType: type
        });
    }
    if ("publicPath" in manifest.metaData) {
        remoteSnapshot = polyfills._({}, basicRemoteSnapshot, {
            publicPath: getPublicPath(),
            ssrPublicPath: manifest.metaData.ssrPublicPath
        });
    } else {
        remoteSnapshot = polyfills._({}, basicRemoteSnapshot, {
            getPublicPath: getPublicPath()
        });
    }
    if (ssrRemoteEntry) {
        const fullSSRRemoteEntry = simpleJoinRemoteEntry(ssrRemoteEntry.path, ssrRemoteEntry.name);
        remoteSnapshot.ssrRemoteEntry = fullSSRRemoteEntry;
        remoteSnapshot.ssrRemoteEntryType = ssrRemoteEntry.type || "commonjs-module";
    }
    return remoteSnapshot;
}
function isManifestProvider(moduleInfo) {
    if ("remoteEntry" in moduleInfo && moduleInfo.remoteEntry.includes(MANIFEST_EXT)) {
        return true;
    } else {
        return false;
    }
}
const PREFIX = "[ Module Federation ]";
let Logger = class Logger {
    setPrefix(prefix) {
        this.prefix = prefix;
    }
    log(...args) {
        console.log(this.prefix, ...args);
    }
    warn(...args) {
        console.log(this.prefix, ...args);
    }
    error(...args) {
        console.log(this.prefix, ...args);
    }
    success(...args) {
        console.log(this.prefix, ...args);
    }
    info(...args) {
        console.log(this.prefix, ...args);
    }
    ready(...args) {
        console.log(this.prefix, ...args);
    }
    debug(...args) {
        if (isDebugMode()) {
            console.log(this.prefix, ...args);
        }
    }
    constructor(prefix){
        this.prefix = prefix;
    }
};
function createLogger(prefix) {
    return new Logger(prefix);
}
const logger = createLogger(PREFIX);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function safeWrapper(callback, disableWarn) {
    try {
        const res = await callback();
        return res;
    } catch (e) {
        !disableWarn && warn(e);
        return;
    }
}
function isStaticResourcesEqual(url1, url2) {
    const REG_EXP = /^(https?:)?\/\//i;
    // Transform url1 and url2 into relative paths
    const relativeUrl1 = url1.replace(REG_EXP, "").replace(/\/$/, "");
    const relativeUrl2 = url2.replace(REG_EXP, "").replace(/\/$/, "");
    // Check if the relative paths are identical
    return relativeUrl1 === relativeUrl2;
}
function createScript(info) {
    // Retrieve the existing script element by its src attribute
    let script = null;
    let needAttach = true;
    let timeout = 20000;
    let timeoutId;
    const scripts = document.getElementsByTagName("script");
    for(let i = 0; i < scripts.length; i++){
        const s = scripts[i];
        const scriptSrc = s.getAttribute("src");
        if (scriptSrc && isStaticResourcesEqual(scriptSrc, info.url)) {
            script = s;
            needAttach = false;
            break;
        }
    }
    if (!script) {
        const attrs = info.attrs;
        script = document.createElement("script");
        script.type = (attrs == null ? void 0 : attrs["type"]) === "module" ? "module" : "text/javascript";
        let createScriptRes = undefined;
        if (info.createScriptHook) {
            createScriptRes = info.createScriptHook(info.url, info.attrs);
            if (createScriptRes instanceof HTMLScriptElement) {
                script = createScriptRes;
            } else if (typeof createScriptRes === "object") {
                if ("script" in createScriptRes && createScriptRes.script) {
                    script = createScriptRes.script;
                }
                if ("timeout" in createScriptRes && createScriptRes.timeout) {
                    timeout = createScriptRes.timeout;
                }
            }
        }
        if (!script.src) {
            script.src = info.url;
        }
        if (attrs && !createScriptRes) {
            Object.keys(attrs).forEach((name)=>{
                if (script) {
                    if (name === "async" || name === "defer") {
                        script[name] = attrs[name];
                    // Attributes that do not exist are considered overridden
                    } else if (!script.getAttribute(name)) {
                        script.setAttribute(name, attrs[name]);
                    }
                }
            });
        }
    }
    const onScriptComplete = async (prev, event)=>{
        clearTimeout(timeoutId);
        const onScriptCompleteCallback = ()=>{
            if ((event == null ? void 0 : event.type) === "error") {
                (info == null ? void 0 : info.onErrorCallback) && (info == null ? void 0 : info.onErrorCallback(event));
            } else {
                (info == null ? void 0 : info.cb) && (info == null ? void 0 : info.cb());
            }
        };
        // Prevent memory leaks in IE.
        if (script) {
            script.onerror = null;
            script.onload = null;
            safeWrapper(()=>{
                const { needDeleteScript = true } = info;
                if (needDeleteScript) {
                    (script == null ? void 0 : script.parentNode) && script.parentNode.removeChild(script);
                }
            });
            if (prev && typeof prev === "function") {
                const result = prev(event);
                if (result instanceof Promise) {
                    const res = await result;
                    onScriptCompleteCallback();
                    return res;
                }
                onScriptCompleteCallback();
                return result;
            }
        }
        onScriptCompleteCallback();
    };
    script.onerror = onScriptComplete.bind(null, script.onerror);
    script.onload = onScriptComplete.bind(null, script.onload);
    timeoutId = setTimeout(()=>{
        onScriptComplete(null, new Error(`Remote script "${info.url}" time-outed.`));
    }, timeout);
    return {
        script,
        needAttach
    };
}
function createLink(info) {
    // <link rel="preload" href="script.js" as="script">
    // Retrieve the existing script element by its src attribute
    let link = null;
    let needAttach = true;
    const links = document.getElementsByTagName("link");
    for(let i = 0; i < links.length; i++){
        const l = links[i];
        const linkHref = l.getAttribute("href");
        const linkRel = l.getAttribute("rel");
        if (linkHref && isStaticResourcesEqual(linkHref, info.url) && linkRel === info.attrs["rel"]) {
            link = l;
            needAttach = false;
            break;
        }
    }
    if (!link) {
        link = document.createElement("link");
        link.setAttribute("href", info.url);
        let createLinkRes = undefined;
        const attrs = info.attrs;
        if (info.createLinkHook) {
            createLinkRes = info.createLinkHook(info.url, attrs);
            if (createLinkRes instanceof HTMLLinkElement) {
                link = createLinkRes;
            }
        }
        if (attrs && !createLinkRes) {
            Object.keys(attrs).forEach((name)=>{
                if (link && !link.getAttribute(name)) {
                    link.setAttribute(name, attrs[name]);
                }
            });
        }
    }
    const onLinkComplete = (prev, event)=>{
        const onLinkCompleteCallback = ()=>{
            if ((event == null ? void 0 : event.type) === "error") {
                (info == null ? void 0 : info.onErrorCallback) && (info == null ? void 0 : info.onErrorCallback(event));
            } else {
                (info == null ? void 0 : info.cb) && (info == null ? void 0 : info.cb());
            }
        };
        // Prevent memory leaks in IE.
        if (link) {
            link.onerror = null;
            link.onload = null;
            safeWrapper(()=>{
                const { needDeleteLink = true } = info;
                if (needDeleteLink) {
                    (link == null ? void 0 : link.parentNode) && link.parentNode.removeChild(link);
                }
            });
            if (prev) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const res = prev(event);
                onLinkCompleteCallback();
                return res;
            }
        }
        onLinkCompleteCallback();
    };
    link.onerror = onLinkComplete.bind(null, link.onerror);
    link.onload = onLinkComplete.bind(null, link.onload);
    return {
        link,
        needAttach
    };
}
function loadScript(url, info) {
    const { attrs = {}, createScriptHook } = info;
    return new Promise((resolve, reject)=>{
        const { script, needAttach } = createScript({
            url,
            cb: resolve,
            onErrorCallback: reject,
            attrs: polyfills._({
                fetchpriority: "high"
            }, attrs),
            createScriptHook,
            needDeleteScript: true
        });
        needAttach && document.head.appendChild(script);
    });
}
function importNodeModule(name) {
    if (!name) {
        throw new Error("import specifier is required");
    }
    const importModule = new Function("name", `return import(name)`);
    return importModule(name).then((res)=>res).catch((error1)=>{
        console.error(`Error importing module ${name}:`, error1);
        throw error1;
    });
}
const loadNodeFetch = async ()=>{
    const fetchModule = await importNodeModule("node-fetch");
    return fetchModule.default || fetchModule;
};
const lazyLoaderHookFetch = async (input, init, loaderHook)=>{
    const hook = (url, init)=>{
        return loaderHook.lifecycle.fetch.emit(url, init);
    };
    const res = await hook(input, init || {});
    if (!res || !(res instanceof Response)) {
        const fetchFunction = typeof fetch === "undefined" ? await loadNodeFetch() : fetch;
        return fetchFunction(input, init || {});
    }
    return res;
};
const createScriptNode = typeof ENV_TARGET === "undefined" || ENV_TARGET !== "web" ? (url, cb, attrs, loaderHook)=>{
    if (loaderHook == null ? void 0 : loaderHook.createScriptHook) {
        const hookResult = loaderHook.createScriptHook(url);
        if (hookResult && typeof hookResult === "object" && "url" in hookResult) {
            url = hookResult.url;
        }
    }
    let urlObj;
    try {
        urlObj = new URL(url);
    } catch (e) {
        console.error("Error constructing URL:", e);
        cb(new Error(`Invalid URL: ${e}`));
        return;
    }
    const getFetch = async ()=>{
        if (loaderHook == null ? void 0 : loaderHook.fetch) {
            return (input, init)=>lazyLoaderHookFetch(input, init, loaderHook);
        }
        return typeof fetch === "undefined" ? loadNodeFetch() : fetch;
    };
    const handleScriptFetch = async (f, urlObj)=>{
        try {
            var _vm_constants;
            const res = await f(urlObj.href);
            const data = await res.text();
            const [path, vm] = await Promise.all([
                importNodeModule("path"),
                importNodeModule("vm")
            ]);
            const scriptContext = {
                exports: {},
                module: {
                    exports: {}
                }
            };
            const urlDirname = urlObj.pathname.split("/").slice(0, -1).join("/");
            const filename = path.basename(urlObj.pathname);
            var _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER;
            const script = new vm.Script(`(function(exports, module, require, __dirname, __filename) {${data}\n})`, {
                filename,
                importModuleDynamically: (_vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER = (_vm_constants = vm.constants) == null ? void 0 : _vm_constants.USE_MAIN_CONTEXT_DEFAULT_LOADER) != null ? _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER : importNodeModule
            });
            script.runInThisContext()(scriptContext.exports, scriptContext.module, eval("require"), urlDirname, filename);
            const exportedInterface = scriptContext.module.exports || scriptContext.exports;
            if (attrs && exportedInterface && attrs["globalName"]) {
                const container = exportedInterface[attrs["globalName"]] || exportedInterface;
                cb(undefined, container);
                return;
            }
            cb(undefined, exportedInterface);
        } catch (e) {
            cb(e instanceof Error ? e : new Error(`Script execution error: ${e}`));
        }
    };
    getFetch().then(async (f)=>{
        if ((attrs == null ? void 0 : attrs["type"]) === "esm" || (attrs == null ? void 0 : attrs["type"]) === "module") {
            return loadModule(urlObj.href, {
                fetch: f,
                vm: await importNodeModule("vm")
            }).then(async (module)=>{
                await module.evaluate();
                cb(undefined, module.namespace);
            }).catch((e)=>{
                cb(e instanceof Error ? e : new Error(`Script execution error: ${e}`));
            });
        }
        handleScriptFetch(f, urlObj);
    }).catch((err)=>{
        cb(err);
    });
} : (url, cb, attrs, loaderHook)=>{
    cb(new Error("createScriptNode is disabled in non-Node.js environment"));
};
const loadScriptNode = typeof ENV_TARGET === "undefined" || ENV_TARGET !== "web" ? (url, info)=>{
    return new Promise((resolve, reject)=>{
        createScriptNode(url, (error1, scriptContext)=>{
            if (error1) {
                reject(error1);
            } else {
                var _info_attrs, _info_attrs1;
                const remoteEntryKey = (info == null ? void 0 : (_info_attrs = info.attrs) == null ? void 0 : _info_attrs["globalName"]) || `__FEDERATION_${info == null ? void 0 : (_info_attrs1 = info.attrs) == null ? void 0 : _info_attrs1["name"]}:custom__`;
                const entryExports = globalThis[remoteEntryKey] = scriptContext;
                resolve(entryExports);
            }
        }, info.attrs, info.loaderHook);
    });
} : (url, info)=>{
    throw new Error("loadScriptNode is disabled in non-Node.js environment");
};
async function loadModule(url, options) {
    const { fetch: fetch1, vm } = options;
    const response = await fetch1(url);
    const code = await response.text();
    const module = new vm.SourceTextModule(code, {
        // @ts-ignore
        importModuleDynamically: async (specifier, script)=>{
            const resolvedUrl = new URL(specifier, url).href;
            return loadModule(resolvedUrl, options);
        }
    });
    await module.link(async (specifier)=>{
        const resolvedUrl = new URL(specifier, url).href;
        const module = await loadModule(resolvedUrl, options);
        return module;
    });
    return module;
}
function normalizeOptions(enableDefault, defaultOptions, key) {
    return function(options) {
        if (options === false) {
            return false;
        }
        if (typeof options === "undefined") {
            if (enableDefault) {
                return defaultOptions;
            } else {
                return false;
            }
        }
        if (options === true) {
            return defaultOptions;
        }
        if (options && typeof options === "object") {
            return polyfills._({}, defaultOptions, options);
        }
        throw new Error(`Unexpected type for \`${key}\`, expect boolean/undefined/object, got: ${typeof options}`);
    };
}
exports.BROWSER_LOG_KEY = BROWSER_LOG_KEY;
exports.ENCODE_NAME_PREFIX = ENCODE_NAME_PREFIX;
exports.EncodedNameTransformMap = EncodedNameTransformMap;
exports.FederationModuleManifest = FederationModuleManifest;
exports.MANIFEST_EXT = MANIFEST_EXT;
exports.MFModuleType = MFModuleType;
exports.MFPrefetchCommon = MFPrefetchCommon;
exports.MODULE_DEVTOOL_IDENTIFIER = MODULE_DEVTOOL_IDENTIFIER;
exports.ManifestFileName = ManifestFileName;
exports.NameTransformMap = NameTransformMap;
exports.NameTransformSymbol = NameTransformSymbol;
exports.SEPARATOR = SEPARATOR;
exports.StatsFileName = StatsFileName;
exports.TEMP_DIR = TEMP_DIR;
exports.assert = assert;
exports.composeKeyWithSeparator = composeKeyWithSeparator;
exports.containerPlugin = ContainerPlugin;
exports.containerReferencePlugin = ContainerReferencePlugin;
exports.createLink = createLink;
exports.createLogger = createLogger;
exports.createScript = createScript;
exports.createScriptNode = createScriptNode;
exports.decodeName = decodeName;
exports.encodeName = encodeName;
exports.error = error;
exports.generateExposeFilename = generateExposeFilename;
exports.generateShareFilename = generateShareFilename;
exports.generateSnapshotFromManifest = generateSnapshotFromManifest;
exports.getProcessEnv = getProcessEnv;
exports.getResourceUrl = getResourceUrl;
exports.inferAutoPublicPath = inferAutoPublicPath;
exports.isBrowserEnv = isBrowserEnv;
exports.isDebugMode = isDebugMode;
exports.isManifestProvider = isManifestProvider;
exports.isReactNativeEnv = isReactNativeEnv;
exports.isRequiredVersion = isRequiredVersion;
exports.isStaticResourcesEqual = isStaticResourcesEqual;
exports.loadScript = loadScript;
exports.loadScriptNode = loadScriptNode;
exports.logger = logger;
exports.moduleFederationPlugin = ModuleFederationPlugin;
exports.normalizeOptions = normalizeOptions;
exports.parseEntry = parseEntry;
exports.safeToString = safeToString;
exports.safeWrapper = safeWrapper;
exports.sharePlugin = SharePlugin;
exports.simpleJoinRemoteEntry = simpleJoinRemoteEntry;
exports.warn = warn;


/***/ }),

/***/ "../../packages/sdk/dist/polyfills.cjs.cjs":
/*!*************************************************!*\
  !*** ../../packages/sdk/dist/polyfills.cjs.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
exports._ = _extends;


/***/ }),

/***/ "./components/menu.tsx":
/*!*****************************!*\
  !*** ./components/menu.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AppMenu)
/* harmony export */ });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "webpack/sharing/consume/default/react/jsx-dev-runtime/react/jsx-dev-runtime");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/router */ "webpack/sharing/consume/default/next/router/next/router");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _barrel_optimize_names_Menu_antd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=Menu!=!antd */ "__barrel_optimize__?names=Menu!=!../../node_modules/.pnpm/antd@5.19.1_react-dom@18.3.1_react@18.3.1/node_modules/antd/es/index.js");



const menuItems = [
    {
        label: "Main home",
        key: "/"
    },
    {
        label: "Test hook from remote",
        key: "/home/test-remote-hook"
    },
    {
        label: "Test broken remotes",
        key: "/home/test-broken-remotes"
    },
    {
        label: "Exposed pages",
        key: "/home/exposed-pages"
    },
    {
        label: "Exposed components",
        type: "group",
        children: [
            {
                label: "home/SharedNav",
                key: "/home/test-shared-nav"
            }
        ]
    }
];
function AppMenu() {
    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_1__.useRouter)();
    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
        children: [
            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
                style: {
                    padding: "10px",
                    fontWeight: 600,
                    backgroundColor: "#fff"
                },
                children: "Home App Menu"
            }, void 0, false, {
                fileName: "/Users/bytedance/dev/universe/apps/3000-home/components/menu.tsx",
                lineNumber: 23,
                columnNumber: 7
            }, this),
            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Menu_antd__WEBPACK_IMPORTED_MODULE_2__.Menu, {
                mode: "inline",
                selectedKeys: [
                    router.asPath
                ],
                style: {
                    height: "100%"
                },
                onClick: ({ key })=>router.push(key),
                items: menuItems
            }, void 0, false, {
                fileName: "/Users/bytedance/dev/universe/apps/3000-home/components/menu.tsx",
                lineNumber: 28,
                columnNumber: 7
            }, this)
        ]
    }, void 0, true);
}


/***/ }),

/***/ "./lib/server-hmr.js":
/*!***************************!*\
  !*** ./lib/server-hmr.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Next.js Native Server HMR Utility
// Uses Next.js exact internal APIs - copied directly from Next.js source
// Proven to work with 18/19 tests passing in blog example

const path = __webpack_require__(/*! path */ "path");
// Import Next.js exact cache management APIs (lazy loading to avoid webpack issues)
let deleteCache, deleteFromRequireCache;
let clearModuleContext;
let debug = (...args)=>console.log("[Native Server HMR]", ...args);
// Lazy initialization function to avoid webpack processing issues
function initializeNextAPIs() {
    if (false) {} // Skip on client side
    // Use Node.js native require to avoid webpack bundling Next.js internals
    const nodeRequire = eval("require");
    // Import Next.js cache APIs directly - exactly like Next.js hot reloader does
    const requireCacheHotReloader = nodeRequire("next/dist/build/webpack/plugins/nextjs-require-cache-hot-reloader");
    deleteCache = requireCacheHotReloader.deleteCache; // This takes single file path
    deleteFromRequireCache = requireCacheHotReloader.deleteFromRequireCache; // Separate function
    // Import clearModuleContext from sandbox
    const sandboxModule = nodeRequire("next/dist/server/web/sandbox");
    clearModuleContext = sandboxModule.clearModuleContext;
    console.log("[Native Server HMR] Successfully loaded Next.js internal cache APIs");
}
function performHMR() {
    if (false) {}
    // Initialize APIs on first use
    if (!deleteCache) {
        initializeNextAPIs();
    }
    try {
        debug("\uD83D\uDD25 Starting Next.js native HMR...");
        const cacheKeys = Object.keys(__webpack_require__.c);
        const cwd = process.cwd();
        let cleared = 0;
        // Clear federation caches first if available (preserve bundlerRuntime)
        if (global.__webpack_require__ && global.__webpack_require__.federation) {
            const federation = global.__webpack_require__.federation;
            if (federation.instance) {
                const preservedBundlerRuntime = federation.instance.bundlerRuntime;
                if (federation.instance.moduleCache) {
                    federation.instance.moduleCache.clear();
                    debug("\uD83D\uDD04 Cleared federation module cache");
                }
                if (federation.instance.remoteCache) {
                    federation.instance.remoteCache.clear();
                    debug("\uD83D\uDD04 Cleared federation remote cache");
                }
                if (preservedBundlerRuntime) {
                    federation.instance.bundlerRuntime = preservedBundlerRuntime;
                    debug("✅ Preserved federation bundlerRuntime");
                }
            }
        }
        // Target Next.js compiled modules (.next directory) and source modules
        for (const key of cacheKeys){
            const shouldClear = // Source files in working directory (not node_modules)
            key.startsWith(cwd) && !key.includes("node_modules") || // Next.js compiled files in .next directory
            key.includes("/.next/server/") || // Pages and API routes
            key.includes("/pages/") || // App directory files
            key.includes("/app/");
            if (shouldClear) {
                try {
                    // Use Next.js exact sequence: clearModuleContext first, then deleteCache
                    if (clearModuleContext) {
                        clearModuleContext(key);
                    }
                    // Use Next.js native deleteCache - handles both manifest and require cache
                    if (deleteCache) {
                        deleteCache(key);
                    } else if (deleteFromRequireCache) {
                        deleteFromRequireCache(key);
                    } else {
                        // Fallback to manual deletion
                        delete __webpack_require__.c[key];
                    }
                    cleared++;
                    debug(`🗑️ Cleared: ${key.replace(cwd, ".")}`);
                } catch (e) {
                    // Some modules might not be clearable
                    debug(`⚠️ Could not clear: ${key.replace(cwd, ".")}`);
                }
            }
        }
        debug(`✅ Next.js HMR completed - cleared ${cleared} modules`);
        return cleared;
    } catch (error) {
        debug("❌ Error during Next.js HMR:", error);
        return 0;
    }
}
// Pure Next.js pattern for clearing all page cache - exact same as blog example
function clearAllPageCache() {
    // Initialize APIs on first use
    if (!deleteCache) {
        initializeNextAPIs();
    }
    try {
        console.log("[HMR] \uD83D\uDD25 Starting clearAllPageCache - complete state reset...");
        const cacheKeys = Object.keys(__webpack_require__.c);
        let clearedCount = 0;
        // Clear all user modules and Next.js compiled modules
        const cwd = process.cwd();
        for (const key of cacheKeys){
            const shouldClear = // Source files in working directory (not node_modules)
            key.startsWith(cwd) && !key.includes("node_modules") || // Next.js compiled files in .next directory
            key.includes("/.next/server/") || // Pages and API routes
            key.includes("/pages/") || // App directory files
            key.includes("/app/");
            if (shouldClear) {
                try {
                    // Use Next.js exact sequence: clearModuleContext first, then deleteCache
                    if (clearModuleContext) {
                        clearModuleContext(key);
                    }
                    // Use Next.js native deleteCache - handles both manifest and require cache
                    if (deleteCache) {
                        deleteCache(key);
                    } else if (deleteFromRequireCache) {
                        deleteFromRequireCache(key);
                    } else {
                        // Fallback to manual deletion only if native APIs unavailable
                        delete __webpack_require__.c[key];
                    }
                    clearedCount++;
                    console.log(`[HMR] 🗑️ Cleared: ${key.replace(cwd, ".")}`);
                } catch (e) {
                    // Some modules might not be clearable - this is normal
                    console.log(`[HMR] ⚠️ Could not clear: ${key.replace(cwd, ".")}`);
                }
            }
        }
        // Clear federation caches if available (preserve bundlerRuntime)
        if (global.__webpack_require__ && global.__webpack_require__.federation) {
            const federation = global.__webpack_require__.federation;
            if (federation.instance) {
                const preservedBundlerRuntime = federation.instance.bundlerRuntime;
                if (federation.instance.moduleCache) {
                    federation.instance.moduleCache.clear();
                    console.log("[HMR] \uD83D\uDD04 Cleared federation module cache");
                }
                if (federation.instance.remoteCache) {
                    federation.instance.remoteCache.clear();
                    console.log("[HMR] \uD83D\uDD04 Cleared federation remote cache");
                }
                if (preservedBundlerRuntime) {
                    federation.instance.bundlerRuntime = preservedBundlerRuntime;
                    console.log("[HMR] ✅ Preserved federation bundlerRuntime");
                }
            }
        }
        console.log(`[HMR] ✅ clearAllPageCache completed - cleared ${clearedCount} modules`);
        return {
            success: true,
            clearedCount,
            method: "pure-next-js-internals"
        };
    } catch (error) {
        console.error("[HMR] ❌ Error clearing all page cache:", error);
        return {
            success: false,
            error: error.message
        };
    }
}
// Pure Next.js pattern for invalidating specific modules
function invalidateModule(modulePath) {
    // Initialize APIs on first use
    if (!deleteCache) {
        initializeNextAPIs();
    }
    try {
        // Use Next.js native clearModuleContext first (exact pattern from blog)
        if (clearModuleContext) {
            clearModuleContext(modulePath);
        }
        // Use Next.js native deleteCache - single file path, not array
        if (deleteCache) {
            deleteCache(modulePath);
            console.log(`[HMR] ✅ Invalidated module: ${modulePath}`);
            return {
                success: true,
                path: modulePath,
                method: "pure-next-js-internals"
            };
        } else {
            // Fallback only if native APIs are not available
            delete __webpack_require__.c[modulePath];
            return {
                success: true,
                path: modulePath,
                method: "manual-cache-delete"
            };
        }
    } catch (error) {
        console.error("[HMR] ❌ Error invalidating module:", error);
        return {
            success: false,
            error: error.message,
            path: modulePath
        };
    }
}
// Unified reloadAll command - uses best available Next.js internal APIs
function reloadAll() {
    if (false) {}
    // Initialize APIs on first use
    if (!deleteCache) {
        initializeNextAPIs();
    }
    try {
        console.log("[HMR] \uD83D\uDE80 Starting reloadAll - using Next.js internal APIs...");
        let totalCleared = 0;
        // Step 1: Clear Module Federation caches (preserve bundlerRuntime)
        if (global.__webpack_require__?.federation?.instance) {
            const federation = global.__webpack_require__.federation.instance;
            const preservedBundlerRuntime = federation.bundlerRuntime;
            if (federation.moduleCache) {
                federation.moduleCache.clear();
                console.log("[HMR] \uD83D\uDD04 Cleared federation module cache");
            }
            if (federation.remoteCache) {
                federation.remoteCache.clear();
                console.log("[HMR] \uD83D\uDD04 Cleared federation remote cache");
            }
            // Preserve bundlerRuntime
            if (preservedBundlerRuntime) {
                federation.bundlerRuntime = preservedBundlerRuntime;
            }
        }
        // Step 2: Clear global federation instances
        if (global.__FEDERATION__?.__INSTANCES__) {
            for (const instance of global.__FEDERATION__.__INSTANCES__){
                if (instance.moduleCache) {
                    instance.moduleCache.clear();
                }
            }
        }
        // Step 3: Clear used chunks global state
        if (global.usedChunks?.clear) {
            global.usedChunks.clear();
        }
        // Step 4: Clear Next.js modules using internal APIs (best method)
        const cacheKeys = Object.keys(__webpack_require__.c);
        const cwd = process.cwd();
        for (const key of cacheKeys){
            const shouldClear = key.startsWith(cwd) && !key.includes("node_modules") || key.includes("/.next/server/") || key.includes("/pages/") || key.includes("/app/") || key.includes("/components/") || key.includes("/lib/") || key.includes("/utils/") || key.includes("/src/");
            if (shouldClear) {
                try {
                    // Use Next.js internal APIs in correct order
                    if (clearModuleContext) {
                        clearModuleContext(key);
                    }
                    if (deleteCache) {
                        deleteCache(key);
                    } else if (deleteFromRequireCache) {
                        deleteFromRequireCache(key);
                    } else {
                        // Only fallback if no Next.js APIs available
                        delete __webpack_require__.c[key];
                    }
                    totalCleared++;
                } catch (e) {
                // Some modules might not be clearable
                }
            }
        }
        console.log(`[HMR] ✅ reloadAll completed - cleared ${totalCleared} modules using Next.js internals`);
        return {
            success: true,
            totalCleared,
            method: "next-js-internal-apis"
        };
    } catch (error) {
        console.error("[HMR] ❌ Error during reloadAll:", error);
        return {
            success: false,
            error: error.message
        };
    }
}
// Initialize in both development and production for flexibility
if (true) {
    // Initialize APIs - in production, APIs will be available but cache clearing will be no-op
    initializeNextAPIs();
    // Expose native server HMR functions globally for compatibility
    global.__NATIVE_SERVER_HMR__ = {
        ensurePage: (page, clientOnly)=>({
                success: true,
                page,
                clientOnly
            }),
        invalidateModule: (modulePath)=>invalidateModule(modulePath),
        clearModuleCache: (modulePath)=>invalidateModule(modulePath),
        getCacheInfo: ()=>{
            // Ensure APIs are initialized
            if (!deleteCache) {
                initializeNextAPIs();
            }
            const cacheKeys = Object.keys(__webpack_require__.c);
            return {
                totalCacheSize: cacheKeys.length,
                workingDirectory: process.cwd(),
                nodeEnv: "development",
                nativeAPIsAvailable: {
                    deleteCache: !!deleteCache,
                    deleteFromRequireCache: !!deleteFromRequireCache,
                    clearModuleContext: !!clearModuleContext
                },
                hmrActionsAvailable: [],
                method: "next-internal-apis",
                productionMode: "development" === "production"
            };
        },
        reloadAll: ()=>{
            if (false) {}
            return reloadAll();
        },
        publishHMREvent: (event)=>({
                success: true,
                event,
                method: "federation-aware"
            })
    };
    debug(`Native server-side functions exposed on global.__NATIVE_SERVER_HMR__ (${"development"} mode)`);
    // Handle process exit
    process.on("exit", ()=>{
        debug("Process exiting, cleaning up...");
    });
}
module.exports = {
    reloadAll
};


/***/ }),

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "webpack/sharing/consume/default/react/jsx-dev-runtime/react/jsx-dev-runtime");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _module_federation_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @module-federation/runtime */ "../../packages/runtime/dist/index.esm.js");
/* harmony import */ var _barrel_optimize_names_ConfigProvider_Layout_version_antd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=ConfigProvider,Layout,version!=!antd */ "__barrel_optimize__?names=ConfigProvider,Layout,version!=!../../node_modules/.pnpm/antd@5.19.1_react-dom@18.3.1_react@18.3.1/node_modules/antd/es/index.js");
/* harmony import */ var _ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ant-design/cssinjs */ "webpack/sharing/consume/default/@ant-design/cssinjs/@ant-design/cssinjs");
/* harmony import */ var _ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/router */ "webpack/sharing/consume/default/next/router/next/router");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _components_menu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/menu */ "./components/menu.tsx");




console.log("logging init", typeof _module_federation_runtime__WEBPACK_IMPORTED_MODULE_2__.init);



const SharedNav = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.lazy(()=>__webpack_require__.e(/*! import() */ "components_SharedNav_tsx").then(__webpack_require__.bind(__webpack_require__, /*! ../components/SharedNav */ "./components/SharedNav.tsx")));

function MyApp(props) {
    const { Component, pageProps } = props;
    const { asPath } = (0,next_router__WEBPACK_IMPORTED_MODULE_4__.useRouter)();
    const [MenuComponent, setMenuComponent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>_components_menu__WEBPACK_IMPORTED_MODULE_5__["default"]);
    // Add HMR support for federation modules
    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{
        if (false) {}
    }, []);
    const handleRouteChange = async (url)=>{
        try {
            if (url.startsWith("/shop")) {
                // Check if we need to force refresh the federation module
                const forceRefresh =  false && 0;
                const cacheKey = forceRefresh ? `shop/menu?t=${Date.now()}` : "shop/menu";
                console.log("[HMR] Loading shop menu", {
                    forceRefresh,
                    cacheKey
                });
                // @ts-ignore
                const RemoteAppMenu = (await __webpack_require__.e(/*! import() */ "webpack_container_remote_shop_menu").then(__webpack_require__.t.bind(__webpack_require__, /*! shop/menu */ "webpack/container/remote/shop/menu", 23))).default;
                setMenuComponent(()=>RemoteAppMenu);
            } else if (url.startsWith("/checkout")) {
                // Check if we need to force refresh the federation module
                const forceRefresh =  false && 0;
                const cacheKey = forceRefresh ? `checkout/menu?t=${Date.now()}` : "checkout/menu";
                console.log("[HMR] Loading checkout menu", {
                    forceRefresh,
                    cacheKey
                });
                // @ts-ignore
                const RemoteAppMenu = (await __webpack_require__.e(/*! import() */ "webpack_container_remote_checkout_menu").then(__webpack_require__.t.bind(__webpack_require__, /*! checkout/menu */ "webpack/container/remote/checkout/menu", 23))).default;
                setMenuComponent(()=>RemoteAppMenu);
            } else {
                setMenuComponent(()=>_components_menu__WEBPACK_IMPORTED_MODULE_5__["default"]);
            }
        } catch (error) {
            console.error("[HMR] Error loading federation module:", error);
            // Fallback to host menu on error
            setMenuComponent(()=>_components_menu__WEBPACK_IMPORTED_MODULE_5__["default"]);
        }
    };
    // handle first route hit.
    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{
        handleRouteChange(asPath);
    }, [
        asPath
    ]);
    //handle route change
    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{
        // Step 3: Subscribe on events
        next_router__WEBPACK_IMPORTED_MODULE_4___default().events.on("routeChangeStart", handleRouteChange);
        return ()=>{
            next_router__WEBPACK_IMPORTED_MODULE_4___default().events.off("routeChangeStart", handleRouteChange);
        };
    }, []);
    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_3__.StyleProvider, {
        layer: true,
        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ConfigProvider_Layout_version_antd__WEBPACK_IMPORTED_MODULE_6__.ConfigProvider, {
            theme: {
                hashed: false
            },
            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ConfigProvider_Layout_version_antd__WEBPACK_IMPORTED_MODULE_6__.Layout, {
                style: {
                    minHeight: "100vh"
                },
                prefixCls: "dd",
                children: [
                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {
                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SharedNav, {}, void 0, false, {
                            fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
                            lineNumber: 84,
                            columnNumber: 13
                        }, this)
                    }, void 0, false, {
                        fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
                        lineNumber: 83,
                        columnNumber: 11
                    }, this),
                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ConfigProvider_Layout_version_antd__WEBPACK_IMPORTED_MODULE_6__.Layout, {
                        children: [
                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ConfigProvider_Layout_version_antd__WEBPACK_IMPORTED_MODULE_6__.Layout.Sider, {
                                width: 200,
                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MenuComponent, {}, void 0, false, {
                                    fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
                                    lineNumber: 88,
                                    columnNumber: 15
                                }, this)
                            }, void 0, false, {
                                fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
                                lineNumber: 87,
                                columnNumber: 13
                            }, this),
                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ConfigProvider_Layout_version_antd__WEBPACK_IMPORTED_MODULE_6__.Layout, {
                                children: [
                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ConfigProvider_Layout_version_antd__WEBPACK_IMPORTED_MODULE_6__.Layout.Content, {
                                        style: {
                                            background: "#fff",
                                            padding: 20
                                        },
                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {
                                            ...pageProps
                                        }, void 0, false, {
                                            fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
                                            lineNumber: 92,
                                            columnNumber: 17
                                        }, this)
                                    }, void 0, false, {
                                        fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
                                        lineNumber: 91,
                                        columnNumber: 15
                                    }, this),
                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ConfigProvider_Layout_version_antd__WEBPACK_IMPORTED_MODULE_6__.Layout.Footer, {
                                        style: {
                                            background: "#fff",
                                            color: "#999",
                                            textAlign: "center"
                                        },
                                        children: [
                                            "antd@",
                                            _barrel_optimize_names_ConfigProvider_Layout_version_antd__WEBPACK_IMPORTED_MODULE_6__.version
                                        ]
                                    }, void 0, true, {
                                        fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
                                        lineNumber: 94,
                                        columnNumber: 15
                                    }, this)
                                ]
                            }, void 0, true, {
                                fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
                                lineNumber: 90,
                                columnNumber: 13
                            }, this)
                        ]
                    }, void 0, true, {
                        fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
                        lineNumber: 86,
                        columnNumber: 11
                    }, this)
                ]
            }, void 0, true, {
                fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
                lineNumber: 82,
                columnNumber: 9
            }, this)
        }, void 0, false, {
            fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
            lineNumber: 81,
            columnNumber: 7
        }, this)
    }, void 0, false, {
        fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_app.tsx",
        lineNumber: 80,
        columnNumber: 5
    }, this);
}
// Use getServerSideProps pattern for pages to get server render count
// This will be picked up by individual pages that use getServerSideProps
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MyApp);


/***/ }),

/***/ "./pages/_document.js":
/*!****************************!*\
  !*** ./pages/_document.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "webpack/sharing/consume/default/react/jsx-dev-runtime/react/jsx-dev-runtime");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_document__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/document */ "../../node_modules/.pnpm/next@14.2.16_@babel+core@7.25.2_react-dom@18.3.1_react@18.3.1/node_modules/next/document.js");
/* harmony import */ var next_document__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_document__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _module_federation_nextjs_mf_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @module-federation/nextjs-mf/utils */ "../../packages/nextjs-mf/dist/utils/index.js");




class MyDocument extends (next_document__WEBPACK_IMPORTED_MODULE_2___default()) {
    static async getInitialProps(ctx) {
        console.log("[Module Federation Document] Processing request for:", ctx.pathname);
        // Server-side only checks
        if ( true && ctx.pathname && "development" === "development") {
            if (!ctx.pathname.endsWith("_error")) {
                // Check for HMR trigger via reloadAll query parameter
                const query = ctx.query || {};
                if (query.reloadAll === "true") {
                    console.log(`[HMR Document] 🔥 HMR triggered via ?reloadAll=true`);
                    try {
                        if (global.__NATIVE_SERVER_HMR__ && global.__NATIVE_SERVER_HMR__.reloadAll) {
                            const result = global.__NATIVE_SERVER_HMR__.reloadAll();
                            console.log(`[HMR Document] ✅ reloadAll cleared ${result.totalCleared} modules`);
                        } else {
                            // Fallback to manual HMR
                            const { reloadAll } = __webpack_require__(/*! ../lib/server-hmr */ "./lib/server-hmr.js");
                            const result = reloadAll();
                            console.log(`[HMR Document] ✅ Fallback reloadAll cleared ${result.totalCleared} modules`);
                        }
                    } catch (error) {
                        console.error(`[HMR Document] ❌ Error during reloadAll:`, error);
                    }
                }
                // Check for remote changes
                await (0,_module_federation_nextjs_mf_utils__WEBPACK_IMPORTED_MODULE_3__.revalidate)();
            }
        }
        const initialProps = await next_document__WEBPACK_IMPORTED_MODULE_2___default().getInitialProps(ctx);
        const chunks = await (0,_module_federation_nextjs_mf_utils__WEBPACK_IMPORTED_MODULE_3__.flushChunks)();
        return {
            ...initialProps,
            chunks
        };
    }
    render() {
        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_document__WEBPACK_IMPORTED_MODULE_2__.Html, {
            children: [
                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_document__WEBPACK_IMPORTED_MODULE_2__.Head, {
                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_module_federation_nextjs_mf_utils__WEBPACK_IMPORTED_MODULE_3__.FlushedChunks, {
                        chunks: this.props.chunks
                    }, void 0, false, {
                        fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_document.js",
                        lineNumber: 62,
                        columnNumber: 11
                    }, this)
                }, void 0, false, {
                    fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_document.js",
                    lineNumber: 61,
                    columnNumber: 9
                }, this),
                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("body", {
                    children: [
                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_document__WEBPACK_IMPORTED_MODULE_2__.Main, {}, void 0, false, {
                            fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_document.js",
                            lineNumber: 65,
                            columnNumber: 11
                        }, this),
                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_document__WEBPACK_IMPORTED_MODULE_2__.NextScript, {}, void 0, false, {
                            fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_document.js",
                            lineNumber: 66,
                            columnNumber: 11
                        }, this)
                    ]
                }, void 0, true, {
                    fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_document.js",
                    lineNumber: 64,
                    columnNumber: 9
                }, this)
            ]
        }, void 0, true, {
            fileName: "/Users/bytedance/dev/universe/apps/3000-home/pages/_document.js",
            lineNumber: 60,
            columnNumber: 7
        }, this);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MyDocument);


/***/ }),

/***/ "__barrel_optimize__?names=ConfigProvider,Layout,version!=!../../node_modules/.pnpm/antd@5.19.1_react-dom@18.3.1_react@18.3.1/node_modules/antd/es/index.js":
/*!******************************************************************************************************************************************************************!*\
  !*** __barrel_optimize__?names=ConfigProvider,Layout,version!=!../../node_modules/.pnpm/antd@5.19.1_react-dom@18.3.1_react@18.3.1/node_modules/antd/es/index.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigProvider: () => (/* reexport safe */ _config_provider__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Layout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   version: () => (/* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _config_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config-provider */ "../../node_modules/.pnpm/antd@5.19.1_react-dom@18.3.1_react@18.3.1/node_modules/antd/es/config-provider/index.js");
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layout */ "../../node_modules/.pnpm/antd@5.19.1_react-dom@18.3.1_react@18.3.1/node_modules/antd/es/layout/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./version */ "../../node_modules/.pnpm/antd@5.19.1_react-dom@18.3.1_react@18.3.1/node_modules/antd/es/version/index.js");
/* __next_internal_client_entry_do_not_use__ ConfigProvider,Layout,version auto */ 




/***/ }),

/***/ "__barrel_optimize__?names=Menu!=!../../node_modules/.pnpm/antd@5.19.1_react-dom@18.3.1_react@18.3.1/node_modules/antd/es/index.js":
/*!*****************************************************************************************************************************************!*\
  !*** __barrel_optimize__?names=Menu!=!../../node_modules/.pnpm/antd@5.19.1_react-dom@18.3.1_react@18.3.1/node_modules/antd/es/index.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Menu: () => (/* reexport safe */ _menu__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./menu */ "../../node_modules/.pnpm/antd@5.19.1_react-dom@18.3.1_react@18.3.1/node_modules/antd/es/menu/index.js");
/* __next_internal_client_entry_do_not_use__ Menu auto */ 


/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "data:text/javascript;base64,CiAgICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgewogICAgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUgPSBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZSB8fCBuZXcgU2V0KCk7CiAgICBtb2R1bGUuZmlsZW5hbWUgJiYgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUuYWRkKG1vZHVsZS5maWxlbmFtZSk7CiAgICBpZihtb2R1bGUuY2hpbGRyZW4pIHsKICAgIG1vZHVsZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpIHsKICAgICAgYy5maWxlbmFtZSAmJiBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZS5hZGQoYy5maWxlbmFtZSk7CiAgICB9KQp9CiAgfQogICAg":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:text/javascript;base64,CiAgICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgewogICAgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUgPSBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZSB8fCBuZXcgU2V0KCk7CiAgICBtb2R1bGUuZmlsZW5hbWUgJiYgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUuYWRkKG1vZHVsZS5maWxlbmFtZSk7CiAgICBpZihtb2R1bGUuY2hpbGRyZW4pIHsKICAgIG1vZHVsZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpIHsKICAgICAgYy5maWxlbmFtZSAmJiBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZS5hZGQoYy5maWxlbmFtZSk7CiAgICB9KQp9CiAgfQogICAg ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

    if(typeof module !== 'undefined') {
    globalThis.entryChunkCache = globalThis.entryChunkCache || new Set();
    module.filename && globalThis.entryChunkCache.add(module.filename);
    if(module.children) {
    module.children.forEach(function(c) {
      c.filename && globalThis.entryChunkCache.add(c.filename);
    })
}
  }
    

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))



var promises = [];
__webpack_require__.x();
var __webpack_exports__ = Promise.all([
	__webpack_require__.f.consumes || function(chunkId, promises) {},
	__webpack_require__.f.remotes || function(chunkId, promises) {},
].reduce((p, handler) => (handler('pages/_error', p), p), promises)
).then(() => (__webpack_require__.X(0, ["vendor-chunks/next@14.2.16_@babel+core@7.25.2_react-dom@18.3.1_react@18.3.1","vendor-chunks/rc-util@5.43.0_react-dom@18.3.1_react@18.3.1","vendor-chunks/@swc+helpers@0.5.5","vendor-chunks/@babel+runtime@7.26.0","vendor-chunks/classnames@2.5.1","vendor-chunks/@ctrl+tinycolor@3.6.1","vendor-chunks/antd@5.19.1_react-dom@18.3.1_react@18.3.1","vendor-chunks/rc-menu@9.14.1_react-dom@18.3.1_react@18.3.1","vendor-chunks/rc-field-form@2.2.1_react-dom@18.3.1_react@18.3.1","vendor-chunks/@rc-component+trigger@2.2.3_react-dom@18.3.1_react@18.3.1","vendor-chunks/@rc-component+async-validator@5.0.4","vendor-chunks/rc-motion@2.9.3_react-dom@18.3.1_react@18.3.1","vendor-chunks/resize-observer-polyfill@1.5.1","vendor-chunks/rc-overflow@1.3.2_react-dom@18.3.1_react@18.3.1","vendor-chunks/rc-resize-observer@1.4.0_react-dom@18.3.1_react@18.3.1","vendor-chunks/@rc-component+portal@1.1.2_react-dom@18.3.1_react@18.3.1","vendor-chunks/rc-tooltip@6.2.1_react-dom@18.3.1_react@18.3.1","vendor-chunks/react-is@18.3.1","vendor-chunks/@babel+runtime@7.25.6","vendor-chunks/rc-picker@4.6.15_dayjs@1.11.13_react-dom@18.3.1_react@18.3.1","vendor-chunks/rc-pagination@4.2.0_react-dom@18.3.1_react@18.3.1","vendor-chunks/tr46@0.0.3","vendor-chunks/iconv-lite@0.6.3","vendor-chunks/node-fetch@2.7.0_encoding@0.1.13","vendor-chunks/whatwg-url@5.0.0","vendor-chunks/webidl-conversions@3.0.1","vendor-chunks/encoding@0.1.13","vendor-chunks/safer-buffer@2.1.2"], () => (__webpack_exec__("data:text/javascript;base64,CiAgICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgewogICAgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUgPSBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZSB8fCBuZXcgU2V0KCk7CiAgICBtb2R1bGUuZmlsZW5hbWUgJiYgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUuYWRkKG1vZHVsZS5maWxlbmFtZSk7CiAgICBpZihtb2R1bGUuY2hpbGRyZW4pIHsKICAgIG1vZHVsZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpIHsKICAgICAgYy5maWxlbmFtZSAmJiBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZS5hZGQoYy5maWxlbmFtZSk7CiAgICB9KQp9CiAgfQogICAg"), __webpack_exec__("../../node_modules/.pnpm/next@14.2.16_@babel+core@7.25.2_react-dom@18.3.1_react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2F_error&preferredRegion=&absolutePagePath=private-next-pages%2F_error&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!")))));
module.exports = __webpack_exports__;

})();