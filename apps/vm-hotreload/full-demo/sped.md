# HMR Runtime API Specification (Node.js readFileVm Variant)andlers).1.2. Target EnvironmentThis runtime is specifically designed for:Node.js: It uses Node.js specific modules like require('fs'), require('path'), and require('vm').Webpack: The structure and naming conventions (__webpack_require__, chunkId, moduleId) indicate it's part of a webpack-generated bundle. It integrates with webpack's internal module system and HMR API.1.3. Key ConceptsModule: A unit of code, typically a JavaScript file, managed by webpack. Each module has a unique moduleId.Chunk: A larger file generated by webpack that can contain multiple modules. Updates are often delivered as chunks.Update Manifest: A JSON file (typically ending in .hot-update.json) generated by webpack during a recompilation. It lists which chunks have been updated and contains a new hash for the compilation.Update Chunk: A JavaScript file (typically ending in .hot-update.js) containing the new code for updated modules and potentially new runtime code.__webpack_require__: Webpack's internal runtime function used for loading modules, accessing the module cache, and other internal operations. This HMR runtime heavily extends and interacts with it.2. Global State and Configuration2.1. installedChunksvar installedChunks = __webpack_require__.hmrS_readFileVm = __webpack_require__.hmrS_readFileVm || {
## 1. Introduction
This document provides a detailed specification for the Hot Module Replacement (HMR) runtime, specifically tailored for a Node.js environment where update chunks are loaded from the filesystem and executed within the current V8 context using the vm module. This runtime enables developers to update modules in a running Node.js application without a full server restart, significantly speeding up development workflows.
### 1.1. Purpose of this HMR Runtimewebpack to recompile. The client-side (in this case, Node.js runtime) then checks for these updates.3.1. __webpack_require__.hmrM(): Fetching the Update Manifest__webpack_require__.hmrM = function() {
The primary purpose of this HMR runtime is to:
- Detect changes to modules in a running application
- Fetch these changes (update chunks) from the filesystem
- Evaluate the new module code
- Determine which modules need to be updated and how (e.g., re-evaluation, disposal, propagation to parent modules)
- Apply these updates with minimal disruption to the application state
- Provide hooks and mechanisms for modules to manage their state during updates (e.g., dispose handlers, accept handlers)
### 1.2. Target Environment
This runtime is specifically designed for:
- Node.js: It uses Node.js specific modules like `require('fs')`, `require('path')`, and `require('vm')`
- Webpack: The structure and naming conventions (`__webpack_require__`, `chunkId`, `moduleId`) indicate it's part of a webpack-generated bundle. It integrates with webpack's internal module system and HMR API.
### 1.3. Key Concepts
- **Module**: A unit of code, typically a JavaScript file, managed by webpack. Each module has a unique `moduleId`.
- **Chunk**: A larger file generated by webpack that can contain multiple modules. Updates are often delivered as chunks.
- **Update Manifest**: A JSON file (typically ending in `.hot-update.json`) generated by webpack during a recompilation. It lists which chunks have been updated and contains a new hash for the compilation.
- **Update Chunk**: A JavaScript file (typically ending in `.hot-update.js`) containing the new code for updated modules and potentially new runtime code.
- **__webpack_require__**: Webpack's internal runtime function used for loading modules, accessing the module cache, and other internal operations. This HMR runtime heavily extends and interacts with it.
## 2. Global State and Configuration
### 2.1. installedChunks
3.2. __webpack_require__.hmrC.readFileVm(chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList): Checking for Updates__webpack_require__.hmrC.readFileVm = function (
  chunkIds,          // Array of chunk IDs that have updates (from manifest)
  removedChunks,     // Array of chunk IDs that were removed
  removedModules,    // Array of module IDs that were removed
  promises,          // Array to push loading promises into
  applyHandlers,     // Array to push apply handler functions into
  updatedModulesList // Optional array to collect IDs of modules being updated
) {
  applyHandlers.push(applyHandler); // Register the main apply handler for this update cycle

  currentUpdateChunks = {};        // Tracks which chunks are part of this update
  currentUpdateRemovedChunks = removedChunks; // Store removed chunks for later cleanup
  currentUpdate = removedModules.reduce(function (obj, key) {
    obj[key] = false; // Mark removed modules for disposal (false means no new factory)
    return obj;
  }, {});
  currentUpdateRuntime = [];       // Array to store new runtime functions from update chunks

  chunkIds.forEach(function (chunkId) {
    if (
      __webpack_require__.o(installedChunks, chunkId) && // Check if chunkId is a known key in installedChunks
      installedChunks[chunkId] !== undefined          // And its value is not undefined (0 or Promise)
    ) {
      // If chunk is considered installed or already loading, load its update
      promises.push(loadUpdateChunk(chunkId, updatedModulesList));
      currentUpdateChunks[chunkId] = true; // Mark as part of this update and will be loaded
    } else {
      // Chunk was not previously installed or its status is unclear; might be a new chunk
      // or an issue. For this HMR strategy, it seems to assume chunks are known.
      currentUpdateChunks[chunkId] = false; // Mark as not being loaded (or already loaded if it's a new chunk not needing an update file)
    }
  });

  // Hook into webpack's dynamic import mechanism (if present) for HMR
  if (__webpack_require__.f) { // __webpack_require__.f is the object for chunk loading functions
    __webpack_require__.f.readFileVmHmr = function (chunkId, promises) {
      if (
        currentUpdateChunks &&
        __webpack_require__.o(currentUpdateChunks, chunkId) && // Is this chunk part of the current HMR update?
        !currentUpdateChunks[chunkId]                         // And not yet marked to be loaded?
      ) {
        // This typically handles cases where a chunk becomes relevant during the HMR process
        // itself, e.g., an update causes a new dynamic import.
        promises.push(loadUpdateChunk(chunkId)); // Load its update
        currentUpdateChunks[chunkId] = true;     // Mark as loaded for this update cycle
      }
    };
  }
};
Purpose: This is the central function called by webpack's HMR engine after it has determined (usually via hmrM) which chunks have updates. It orchestrates the loading of these update chunks and prepares for applying the changes.Parameters:chunkIds: An array of chunkIds that have pending updates (derived from the manifest's c field).removedChunks: An array of chunkIds that are no longer part of the application (e.g., due to code splitting changes).removedModules: An array of moduleIds that have been removed entirely.promises: An array (passed by reference from the HMR engine) where this function will push Promise objects returned by loadUpdateChunk. The HMR engine waits for all these promises to resolve.applyHandlers: An array (passed by reference) where this function pushes handler functions. The HMR engine will call these handlers to actually apply the updates. Here, it pushes the main applyHandler.updatedModulesList: An optional array (passed by reference) to collect the moduleIds of all modules that are being updated.Mechanism:Register applyHandler: Pushes the applyHandler function (defined later) into the applyHandlers array. This handler will be responsible for the actual application of changes once all update chunks are loaded.Initialize Update State:currentUpdateChunks = {}: Resets/initializes an object to track which chunks are part of the current update attempt and whether their update files are being loaded.currentUpdateRemovedChunks = removedChunks: Stores the list of chunks that were removed in this update.currentUpdate = removedModules.reduce(...): Initializes currentUpdate (which will store the new module factories) by marking all removedModules with false. This signifies they should be disposed of and have no new version.currentUpdateRuntime = []: Initializes an array to collect any new runtime code included in the update chunks.Load Update Chunks:Iterates over chunkIds.For each chunkId, it checks if the chunk is currently "installed" (i.e., installedChunks[chunkId] is 0 or a Promise). This check ensures that we only try to update chunks that are actually part of the running application.If the chunk is installed, it calls loadUpdateChunk(chunkId, updatedModulesList) and pushes the returned Promise into the promises array. It also marks currentUpdateChunks[chunkId] = true.If the chunk is not considered installed, it marks currentUpdateChunks[chunkId] = false.Dynamic Import HMR Hook (Optional):If __webpack_require__.f (webpack's namespace for chunk loading functions like jsonp or require) exists, it installs a special HMR hook: __webpack_require__.f.readFileVmHmr.This hook allows the HMR process to load update chunks for dynamically imported modules if those modules are affected by the current hot update. If a chunk is requested via dynamic import during an HMR update cycle and it's part of currentUpdateChunks but not yet loaded, this hook will trigger loadUpdateChunk for it.Side Effects:Populates promises with promises for loading update chunks.Populates applyHandlers with the applyHandler.Sets global HMR state variables: currentUpdateChunks, currentUpdateRemovedChunks, currentUpdate, currentUpdateRuntime.Potentially modifies __webpack_require__.f to add an HMR-specific chunk loading handler.3.3. __webpack_require__.hmrI.readFileVm(moduleId, applyHandlers): Registering Modules for Update (Less Common in this Flow)__webpack_require__.hmrI.readFileVm = function (moduleId, applyHandlers) {
  // This function is typically used when HMR updates are managed module by module,
  // rather than chunk by chunk. In the readFileVm strategy primarily driven by hmrC,
  // its role might be more for specific edge cases or if an update is initiated
  // for a single module outside the main chunk update flow.

  if (!currentUpdate) {
    // If no update is in progress, initialize the state.
    // This suggests it can be an entry point for an update.
    currentUpdate = {};
    currentUpdateRuntime = [];
    currentUpdateRemovedChunks = []; // No removed chunks known in this specific path
    applyHandlers.push(applyHandler); // Add the main apply handler
  }
  if (!__webpack_require__.o(currentUpdate, moduleId)) {
    // If this module isn't already part of the current update,
    // add its current factory to currentUpdate. This means it's being replaced.
    currentUpdate[moduleId] = __webpack_require__.m[moduleId];
  }
};
Purpose: This function is part of webpack's HMR interface, usually for handling individual module updates or when an HMR update is initiated from a module itself (e.g., via module.hot.check(true) which might trigger this for affected modules). In the context of the readFileVm strategy which seems primarily driven by hmrC (chunk-based updates), hmrI might handle scenarios where a module is being invalidated and replaced individually.Parameters:moduleId: The ID of the module being affected by the update.applyHandlers: An array (passed by reference) to push apply handler functions into.Mechanism:Initialize Update State (if needed):Checks if currentUpdate is already defined (i.e., an update is in progress).If not, it initializes currentUpdate = {}, currentUpdateRuntime = [], and currentUpdateRemovedChunks = []. This indicates that hmrI can potentially start a new update cycle.It then pushes applyHandler to applyHandlers.Register Module for Update:If the moduleId is not already a key in currentUpdate (meaning it hasn't been processed yet in this update cycle), it adds the module to currentUpdate.currentUpdate[moduleId] = __webpack_require__.m[moduleId]; stores the current factory function of the module. This is different from hmrC where currentUpdate is populated by new factories from update chunks or marked as false for removed modules. Here, it seems to be marking the existing module for potential replacement or re-evaluation if a new version isn't provided by an update chunk. However, loadUpdateChunk will later overwrite this with the new factory if one is found.Context: The exact interplay with hmrC depends on how webpack's HMR engine calls these functions. If hmrC has already set up currentUpdate with new factories, this function might simply ensure applyHandler is registered if called independently. If an update chunk for this moduleId is loaded via loadUpdateChunk, the value in currentUpdate[moduleId] will be overridden by the new factory.4. Loading Update Chunks4.1. loadUpdateChunk(chunkId, updatedModulesList)function loadUpdateChunk(chunkId, updatedModulesList) {
  return new Promise(function(resolve, reject) {
    // 1. Determine filename of the update chunk
    var filename = require('path').join(__dirname, "" + __webpack_require__.hu(chunkId));
    // __webpack_require__.hu(chunkId) should return the relative path to the .hot-update.js file

    // 2. Read the update chunk file content
    require('fs').readFile(filename, 'utf-8', function(err, content) {
      if(err) return reject(err); // Filesystem error

      // 3. Prepare an 'update' object to be populated by the chunk's code
      var update = {};
      // The update chunk is expected to be a CommonJS-like module that populates 'exports'

      // 4. Execute the update chunk's code in the current context
      // It's wrapped in a function to provide a module-like environment (exports, require, __dirname, __filename)
      require('vm').runInThisContext(
        '(function(exports, require, __dirname, __filename) {' + content + '\n})',
        filename // Options for vm.runInThisContext, filename is for stack traces
      )(update, require, require('path').dirname(filename), filename);
      // The executed code should modify the 'update' object, e.g., update.modules = {...}; update.runtime = ...;

      // 5. Extract updated modules and runtime code from the executed chunk
      var updatedModules = update.modules; // Object: { moduleId: newFactoryFunction, ... }
      var runtime = update.runtime;       // Optional: new runtime function

      // 6. Merge updated modules into the global 'currentUpdate' object
      for(var moduleId in updatedModules) {
        if(__webpack_require__.o(updatedModules, moduleId)) { // hasOwnProperty check
          currentUpdate[moduleId] = updatedModules[moduleId]; // Store the new module factory
          if(updatedModulesList) updatedModulesList.push(moduleId); // Optionally track updated module IDs
        }
      }

      // 7. Add any new runtime code to 'currentUpdateRuntime'
      if(runtime) currentUpdateRuntime.push(runtime);

      resolve(); // Signal that this chunk has been processed
    });
  });
}
Purpose: Asynchronously loads the content of an update chunk file (e.g., chunkId.hash.hot-update.js), executes its JavaScript code, and integrates the new module definitions and runtime code into the ongoing HMR update process.Parameters:chunkId: The ID of the chunk to load the update for.updatedModulesList (optional): An array to which the moduleIds of the modules updated by this chunk will be pushed.Mechanism:Filename Resolution:__webpack_require__.hu(chunkId): This webpack internal function is expected to return the relative filename of the hot update JavaScript file for the given chunkId (e.g., mychunk.1234abcd.hot-update.js).require('path').join(__dirname, ...): Constructs the absolute path to the update chunk file.File Reading:require('fs').readFile(filename, 'utf-8', ...): Asynchronously reads the content of the update chunk file.If there's an error reading the file, the promise is rejected.Execution Context Preparation:var update = {};: An empty object update is created. The code within the update chunk is expected to populate this object (typically by assigning to exports if the wrapper function treats update as exports).Code Execution via vm:require('vm').runInThisContext(...): This is the core of how the update chunk's code is executed.The content of the update chunk is wrapped in an immediately-invoked function expression (IIFE): (function(exports, require, __dirname, __filename) { ...content... \n}). This provides a Node.js module-like environment to the chunk code:exports: The update object is passed as exports. The chunk code should assign its new module factories to exports.modules and any new runtime code to exports.runtime.require: The standard Node.js require function.__dirname: The directory name of the update chunk file.__filename: The filename of the update chunk file.The filename argument to runInThisContext is used for better stack traces if errors occur within the executed code.Extracting Update Data:var updatedModules = update.modules;: Retrieves the map of new module factories (moduleId -> factoryFunction) from the update object.var runtime = update.runtime;: Retrieves any new runtime code (a function) from the update object.Merging Updated Modules:Iterates through updatedModules.For each moduleId and its new newFactoryFunction:currentUpdate[moduleId] = updatedModules[moduleId];: Stores the new factory function in the global currentUpdate object. This object accumulates all new module code from all update chunks in the current HMR cycle.If updatedModulesList is provided, the moduleId is added to it.Adding Runtime Code:If runtime code exists (it's a function), it's pushed into the currentUpdateRuntime array. These runtime functions will be executed during the apply phase.Resolution: The promise resolves (with no value) once the chunk is processed, indicating success.Return Value: A Promise that resolves when the update chunk is loaded and processed, or rejects on error.Expected Update Chunk Format (Content of .hot-update.js):// Example: mychunk.1234abcd.hot-update.js
exports.modules = {
  "./src/moduleA.js": function(module, exports, __webpack_require__) {
    // ... new code for moduleA ...
    module.exports = "New Module A";
  },
  "./src/moduleB.js": function(module, exports, __webpack_require__) {
    // ... new code for moduleB ...
    module.exports = "New Module B";
  }
};
// Optionally, provide new runtime code
// exports.runtime = function(__webpack_require__) { /* ... new runtime logic ... */ };
5. Applying UpdatesThis is handled by the applyHandler function and its returned dispose and apply methods.5.1. applyHandler(options)function applyHandler(options) {
  // options: An object with callbacks and flags, e.g.:
  //   onDeclined, onUnaccepted, onAccepted, onDisposed, onErrored
  //   ignoreDeclined, ignoreUnaccepted, ignoreErrored

  // Cleanup hook for webpack's dynamic import HMR integration
  if (__webpack_require__.f) delete __webpack_require__.f.readFileVmHmr;
  currentUpdateChunks = undefined; // Clear this state as we are now in the apply phase

  // ... (getAffectedModuleEffects and addAllToSet are defined here) ...

  // --- Phase 1: Determine effects of updates and build 'appliedUpdate' ---
  var outdatedDependencies = {}; // { parentId: [dependencyId, ...] }
  var outdatedModules = [];      // [moduleId, ...]
  var appliedUpdate = {};        // { moduleId: newFactoryFunction | warnUnexpectedRequire }

  var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
    console.warn(
      "[HMR] unexpected require(" + module.id + ") to disposed module"
    );
  };

  for (var moduleId in currentUpdate) { // Iterate over modules from loaded update chunks
    if (__webpack_require__.o(currentUpdate, moduleId)) {
      var newModuleFactory = currentUpdate[moduleId]; // false if module was removed, else new factory
      var result = newModuleFactory
        ? getAffectedModuleEffects(moduleId) // Analyze impact if module was updated
        : { type: "disposed", moduleId: moduleId }; // Module was removed

      var abortError = false;
      var doApply = false;
      var doDispose = false;
      var chainInfo = "";
      if (result.chain) {
        chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
      }

      switch (result.type) {
        case "self-declined":
          if (options.onDeclined) options.onDeclined(result);
          if (!options.ignoreDeclined)
            abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
          break;
        case "declined":
          if (options.onDeclined) options.onDeclined(result);
          if (!options.ignoreDeclined)
            abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
          break;
        case "unaccepted":
          if (options.onUnaccepted) options.onUnaccepted(result);
          if (!options.ignoreUnaccepted)
            abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
          break;
        case "accepted":
          if (options.onAccepted) options.onAccepted(result);
          doApply = true;
          break;
        case "disposed": // For modules that were explicitly removed (newModuleFactory is false)
          if (options.onDisposed) options.onDisposed(result);
          doDispose = true;
          break;
        default:
          throw new Error("Unexception type " + result.type);
      }

      if (abortError) {
        return { error: abortError }; // Abort the entire HMR update
      }

      if (doApply) {
        appliedUpdate[moduleId] = newModuleFactory; // Store new factory for application
        addAllToSet(outdatedModules, result.outdatedModules); // Collect all modules that need re-evaluation or disposal
        for (var mid in result.outdatedDependencies) {
          if (__webpack_require__.o(result.outdatedDependencies, mid)) {
            if (!outdatedDependencies[mid]) outdatedDependencies[mid] = [];
            addAllToSet(outdatedDependencies[mid], result.outdatedDependencies[mid]);
          }
        }
      }
      if (doDispose) { // Typically for modules listed in `removedModules`
        addAllToSet(outdatedModules, [result.moduleId]);
        appliedUpdate[moduleId] = warnUnexpectedRequire; // Replace factory with a warning
      }
    }
  }
  currentUpdate = undefined; // Clear this global state

  // --- Phase 2: Identify self-accepted modules that need re-execution ---
  var outdatedSelfAcceptedModules = [];
  for (var j = 0; j < outdatedModules.length; j++) {
    var outdatedModuleId = outdatedModules[j];
    var module = __webpack_require__.c[outdatedModuleId]; // Get module from cache
    if (
      module &&
      (module.hot._selfAccepted || module.hot._main) && // Is self-accepting or the main module
      appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire && // Not a disposed module
      !module.hot._selfInvalidated // Not invalidated by module.hot.invalidate()
    ) {
      outdatedSelfAcceptedModules.push({
        module: outdatedModuleId,
        require: module.hot._requireSelf, // Function to re-require the module
        errorHandler: module.hot._selfAccepted // Error handler for self-acceptance
      });
    }
  }

  // Return an object with 'dispose' and 'apply' methods
  return {
    dispose: function() { /* ... see 5.1.2 ... */ },
    apply: function(reportError) { /* ... see 5.1.3 ... */ }
  };
}
Purpose: This is the main workhorse for applying the HMR update. It's called by the HMR engine after all update chunks (from hmrC) have been loaded and their promises resolved. It determines the precise effects of the changes, handles accept/decline logic, and prepares for the actual module replacement.Parameter:options: An object provided by the HMR engine, containing:Callbacks: onDeclined, onUnaccepted, onAccepted, onDisposed, onErrored (for logging or custom handling of these events).Flags: ignoreDeclined, ignoreUnaccepted, ignoreErrored (booleans to control whether to abort on these conditions).Internal State Variables (scoped to applyHandler execution or module-level):outdatedDependencies: Stores a map { parentModuleId: [dependencyModuleId, ...] }. These are dependencies that are outdated and whose parent module has accepted the update for them. The parent module's accept handlers for these dependencies will be called.outdatedModules: An array of moduleIds that are outdated. This includes the directly updated modules and any parents that couldn't accept the change and are therefore also outdated. These modules will be disposed of.appliedUpdate: An object { moduleId: newFactoryFunction | warnUnexpectedRequire }. This stores the new module factories for modules that will be updated, or a warning function for modules that are disposed.outdatedSelfAcceptedModules: An array of objects for modules that are outdated but have accepted their own update (module.hot.accept()). These will be re-executed.Mechanism (Two Main Phases):Phase 1: Determine Effects and Build appliedUpdateCleanup:if (__webpack_require__.f) delete __webpack_require__.f.readFileVmHmr;: Removes the HMR-specific dynamic import hook.currentUpdateChunks = undefined;: Clears the global state related to chunks being updated.Iterate currentUpdate: Loops through each moduleId in currentUpdate (which contains new factories from loadUpdateChunk or false for removed modules).Get Affected Module Effects:If newModuleFactory exists (module was updated, not removed), call getAffectedModuleEffects(moduleId) to determine how the update propagates (see 5.1.1).If newModuleFactory is false (module was removed), the effect is type: "disposed".Process Result Type: A switch statement handles the result.type:self-declined / declined / unaccepted:Calls the corresponding options.on... callback if provided.If options.ignore... is false, creates an Error and sets abortError. The HMR update will be aborted.accepted:Calls options.onAccepted if provided.Sets doApply = true.disposed:Calls options.onDisposed if provided.Sets doDispose = true.Abort Check: If abortError is set, the function immediately returns { error: abortError }, and the HMR process stops.If doApply:appliedUpdate[moduleId] = newModuleFactory;: The new module factory is staged for application.addAllToSet(outdatedModules, result.outdatedModules);: Adds all modules affected by this accepted update (the module itself and any un-accepting parents up to an acceptance boundary) to outdatedModules.Populates outdatedDependencies based on result.outdatedDependencies.If doDispose: (For modules that were explicitly removed)Adds the moduleId to outdatedModules.appliedUpdate[moduleId] = warnUnexpectedRequire;: Sets the module's factory to a function that warns if it's required after disposal.Clear currentUpdate: currentUpdate = undefined; clears this global state as its contents have been processed into appliedUpdate.Phase 2: Identify Self-Accepted Modules for Re-executionIterates through the outdatedModules list compiled in Phase 1.For each outdatedModuleId:Retrieves the module object from webpack's cache: module = __webpack_require__.c[outdatedModuleId].Checks conditions:Is the module valid (module)?Is it self-accepting (module.hot._selfAccepted) or the main entry module (module.hot._main)?Is it not a disposed module (appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire)?Has it not been invalidated by module.hot.invalidate() (!module.hot._selfInvalidated)?If all conditions pass, an object { module, require, errorHandler } is added to outdatedSelfAcceptedModules.module: The moduleId.require: module.hot._requireSelf, a special function to re-execute this module.errorHandler: module.hot._selfAccepted, which can be true or an error handler function provided to module.hot.accept(errorHandler).Return Value: An object with two methods: dispose and apply. If an error occurs that aborts the HMR process (e.g., an unaccepted module and ignoreUnaccepted is false), it returns { error: ErrorObject }.5.1.1. getAffectedModuleEffects(updateModuleId) (Internal to applyHandler)function getAffectedModuleEffects(updateModuleId) {
  var outdatedModules = [updateModuleId]; // Start with the directly updated module
  var outdatedDependencies = {};          // { parentId: [dependencyId, ...] }

  // Queue for breadth-first or depth-first traversal up the dependency chain
  var queue = outdatedModules.map(function (id) {
    return {
      chain: [id], // Tracks the propagation path for error messages
      id: id
    };
  });

  while (queue.length > 0) {
    var queueItem = queue.pop(); // Process one module from the queue
    var moduleId = queueItem.id;
    var chain = queueItem.chain;
    var module = __webpack_require__.c[moduleId]; // Get module from cache

    // If module doesn't exist or is already self-accepted and not invalidated, stop propagation here.
    if (!module || (module.hot._selfAccepted && !module.hot._selfInvalidated)) {
      continue;
    }
    // If module explicitly declines itself.
    if (module.hot._selfDeclined) {
      return { type: "self-declined", chain: chain, moduleId: moduleId };
    }
    // If module is the main entry point and not self-accepted, it's unaccepted.
    if (module.hot._main) { // Typically, _main is true for the entry module
      return { type: "unaccepted", chain: chain, moduleId: moduleId };
    }

    // Check all parents of the current module
    for (var i = 0; i < module.parents.length; i++) {
      var parentId = module.parents[i];
      var parent = __webpack_require__.c[parentId];
      if (!parent) continue; // Parent not in cache (should not happen in consistent state)

      // If parent explicitly declined this dependency (moduleId).
      if (parent.hot._declinedDependencies[moduleId]) {
        return { type: "declined", chain: chain.concat([parentId]), moduleId: moduleId, parentId: parentId };
      }
      // If parent is already in outdatedModules, skip (already processed or will be).
      if (outdatedModules.indexOf(parentId) !== -1) continue;

      // If parent accepts this dependency (moduleId).
      if (parent.hot._acceptedDependencies[moduleId]) {
        if (!outdatedDependencies[parentId]) outdatedDependencies[parentId] = [];
        addAllToSet(outdatedDependencies[parentId], [moduleId]); // Record acceptance
        continue; // Stop propagation along this path, parent accepted it.
      }

      // If parent did not accept and did not decline:
      delete outdatedDependencies[parentId]; // Clear any prior acceptances for this parent (if any)
      outdatedModules.push(parentId);        // Parent becomes outdated
      queue.push({                           // Add parent to queue for further propagation
        chain: chain.concat([parentId]),
        id: parentId
      });
    }
  }

  // If propagation completes without decline/unaccepted, the update is accepted at this boundary.
  return {
    type: "accepted",
    moduleId: updateModuleId, // The originally changed module that triggered this
    outdatedModules: outdatedModules, // All modules that became outdated due to this change
    outdatedDependencies: outdatedDependencies // Dependencies accepted by their parents
  };
}
Purpose: Analyzes the impact of a single module update (updateModuleId) by traversing up its dependency graph (parents, grandparents, etc.). It determines if the update is accepted, declined, or unaccepted, and collects all modules that become outdated as a result.Parameter:updateModuleId: The moduleId of the module that has a new version.Mechanism (Dependency Graph Traversal):Initialization:outdatedModules = [updateModuleId]: The initially updated module is the first outdated one.outdatedDependencies = {}: To store dependencies that are accepted by their parents.queue: A queue for traversing the graph, initialized with the updateModuleId and its propagation chain (for error reporting).Traversal Loop: While the queue is not empty:Dequeue a moduleId and its chain.Get the module object from webpack's cache (__webpack_require__.c).Self-Accept/Invalidate Check: If the module doesn't exist, or if it's self-accepted (module.hot._selfAccepted) and not invalidated (!module.hot._selfInvalidated), then this path of propagation stops. The update is considered handled by this module itself.Self-Decline Check: If module.hot._selfDeclined is true, the module refuses the update. Return { type: "self-declined", ... }.Main Module Check: If module.hot._main is true (it's an entry point) and it hasn't self-accepted, the update is unaccepted at the root. Return { type: "unaccepted", ... }.Iterate Parents: For each parentId of the current moduleId:Get the parent module object.Declined Dependency Check: If parent.hot._declinedDependencies[moduleId] is true, the parent refuses the update for this specific child. Return { type: "declined", ... }.Already Outdated Check: If parentId is already in outdatedModules, skip (it's already part of the current outdated set).Accepted Dependency Check: If parent.hot._acceptedDependencies[moduleId] is true (the parent accepts updates from this child):Record this acceptance in outdatedDependencies.continue to the next parent; propagation stops along this specific path because the parent handled it.Propagation: If the parent neither accepted nor declined the dependency:Remove any previous acceptance for this parent from outdatedDependencies (shouldn't happen if logic is sound, but defensive).Add parentId to outdatedModules (the parent itself becomes outdated).Enqueue the parentId to continue propagation upwards.Accepted Result: If the loop completes without any declines or unaccepted states, it means the update has been contained within some boundary (either by self-accepting modules or modules accepting their dependencies). Return { type: "accepted", ... }.Return Value: An object describing the outcome:type: String - "self-declined", "declined", "unaccepted", or "accepted".chain (if not accepted): Array of moduleIds showing the propagation path that led to the result.moduleId: The ID of the module causing the issue (for declined/self-declined) or the initially updated module (for accepted).parentId (if declined): The ID of the parent that declined the dependency.outdatedModules (if accepted): Array of all moduleIds that became outdated due to this update.outdatedDependencies (if accepted): Map of { parentId: [dependencyId, ...] } for accepted dependencies.5.1.2. applyHandler(...).dispose() Method// This is the 'dispose' method returned by applyHandler
dispose: function () {
  // 1. Clean up 'installedChunks' for removed chunks
  currentUpdateRemovedChunks.forEach(function (chunkId) {
    delete installedChunks[chunkId];
  });
  currentUpdateRemovedChunks = undefined; // Clear global state

  var idx;
  var queue = outdatedModules.slice(); // Process all modules marked as outdated

  while (queue.length > 0) {
    var moduleId = queue.pop();
    var module = __webpack_require__.c[moduleId]; // Get module from cache
    if (!module) continue;

    var data = {}; // Data object to pass to dispose handlers

    // 2. Call dispose handlers registered by the module
    var disposeHandlers = module.hot._disposeHandlers;
    for (j = 0; j < disposeHandlers.length; j++) {
      disposeHandlers[j].call(null, data); // Execute handler, passing 'data'
    }
    __webpack_require__.hmrD[moduleId] = data; // Store 'data' (HMR Dispose Data)

    // 3. Disable the module
    module.hot.active = false; // Mark module as inactive

    // 4. Remove module from cache
    delete __webpack_require__.c[moduleId];

    // 5. No need to clear from outdatedDependencies here, as it's handled later or irrelevant if module is gone
    delete outdatedDependencies[moduleId]; // This removes the parent from needing to call accept handlers for this now-disposed child.

    // 6. Remove "parents" references from all children of this disposed module
    for (j = 0; j < module.children.length; j++) {
      var child = __webpack_require__.c[module.children[j]];
      if (!child) continue;
      idx = child.parents.indexOf(moduleId);
      if (idx >= 0) {
        child.parents.splice(idx, 1);
      }
    }
  }

  // 7. Remove outdated dependencies from their parent's children list
  // This is for modules that were NOT fully disposed but had specific dependencies updated and accepted.
  var dependency;
  var moduleOutdatedDependencies; // Renaming for clarity inside the loop
  for (var outdatedModuleId_parent in outdatedDependencies) { // Iterate parents who accepted dependencies
    if (__webpack_require__.o(outdatedDependencies, outdatedModuleId_parent)) {
      module = __webpack_require__.c[outdatedModuleId_parent]; // The parent module
      if (module) {
        moduleOutdatedDependencies = outdatedDependencies[outdatedModuleId_parent]; // List of its accepted (and now outdated) children
        for (j = 0; j < moduleOutdatedDependencies.length; j++) {
          dependency = moduleOutdatedDependencies[j]; // The moduleId of the outdated child
          idx = module.children.indexOf(dependency);  // Find this child in parent's children list
          if (idx >= 0) module.children.splice(idx, 1); // Remove it
        }
      }
    }
  }
}
Purpose: Performs the cleanup of old module versions. This includes running dispose handlers, removing modules from the cache, and updating module graph linkage (parent/child relationships).Mechanism:Cleanup installedChunks: Iterates currentUpdateRemovedChunks (chunks that were entirely removed in this update) and deletes their entries from the global installedChunks object. Clears currentUpdateRemovedChunks.Process outdatedModules: Iterates through a copy of the outdatedModules list (modules identified in Phase 1 of applyHandler as needing disposal).For each moduleId:Retrieves the module object from cache (__webpack_require__.c).Call Dispose Handlers:var data = {}; Creates an empty object.Iterates module.hot._disposeHandlers (handlers registered by the module code using module.hot.dispose(handler)).Calls each handler(data). These handlers can populate the data object to pass state to the next version of the module.__webpack_require__.hmrD[moduleId] = data;: Stores this data object in a global HMR dispose data store (hmrD), keyed by moduleId. The new version of the module can access this via module.hot.data.Disable Module: module.hot.active = false; Marks the module as inactive. This can prevent it from being used or causing side effects if it's somehow still referenced.Remove from Cache: delete __webpack_require__.c[moduleId]; Removes the module entirely from webpack's active module cache.Clear from outdatedDependencies: delete outdatedDependencies[moduleId]; If this module was also a parent that had accepted dependencies, this removes it from that list, as it's now fully disposed.Update Children's Parent References: Iterates through module.children. For each child module, it removes the current moduleId from the child.parents array. This correctly updates the module graph.Update Parent's Children List for Accepted Dependencies:Iterates through outdatedDependencies. The keys are parentIds that accepted updates from certain children.For each parentModule and its list of acceptedOutdatedChildren:It removes each acceptedOutdatedChild from the parentModule.children array. This is because these children (dependencies) are being replaced, and the new versions will be re-required, re-establishing the link.5.1.3. applyHandler(...).apply(reportError) Method// This is the 'apply' method returned by applyHandler
apply: function (reportError) { // reportError is a function to call with errors
  // 1. Insert new code (module factories)
  for (var updateModuleId in appliedUpdate) { // Iterate modules staged in appliedUpdate
    if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
      __webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
      // __webpack_require__.m is webpack's map of moduleId -> factoryFunction
    }
  }

  // 2. Run new runtime modules
  for (var i = 0; i < currentUpdateRuntime.length; i++) {
    currentUpdateRuntime[i](__webpack_require__); // Execute each new runtime function
  }
  currentUpdateRuntime = undefined; // Clear global state

  // 3. Call accept handlers for accepted dependencies
  var moduleOutdatedDependencies_apply; // Renaming for clarity
  for (var outdatedModuleId_parent_apply in outdatedDependencies) { // Iterate parents who accepted dependencies
    if (__webpack_require__.o(outdatedDependencies, outdatedModuleId_parent_apply)) {
      var module = __webpack_require__.c[outdatedModuleId_parent_apply]; // Get parent module from cache
      if (module) { // Parent should still be in cache (it accepted, wasn't fully outdated)
        moduleOutdatedDependencies_apply = outdatedDependencies[outdatedModuleId_parent_apply]; // List of its accepted (and now outdated) children
        var callbacks = [];
        var errorHandlers = [];
        var dependenciesForCallbacks = []; // To pass specific dependency to error handler

        // Collect unique callbacks and their error handlers
        for (var j = 0; j < moduleOutdatedDependencies_apply.length; j++) {
          var dependency = moduleOutdatedDependencies_apply[j]; // moduleId of the accepted child
          var acceptCallback = module.hot._acceptedDependencies[dependency]; // The actual callback function
          var errorHandler = module.hot._acceptedErrorHandlers[dependency]; // Optional error handler for this accept

          if (acceptCallback) {
            if (callbacks.indexOf(acceptCallback) !== -1) continue; // Avoid duplicate calls for same handler
            callbacks.push(acceptCallback);
            errorHandlers.push(errorHandler);
            dependenciesForCallbacks.push(dependency);
          }
        }

        // Execute collected accept callbacks
        for (var k = 0; k < callbacks.length; k++) {
          try {
            callbacks[k].call(null, moduleOutdatedDependencies_apply); // Call handler with list of changed deps
            // Note: Webpack typically passes an array of updated dependency IDs to the accept handler.
          } catch (err) {
            // Handle errors during accept handler execution
            if (typeof errorHandlers[k] === "function") { // If custom error handler for this accept
              try {
                errorHandlers[k](err, { moduleId: outdatedModuleId_parent_apply, dependencyId: dependenciesForCallbacks[k] });
              } catch (err2) { // Error in the custom error handler itself
                if (options.onErrored) options.onErrored({ type: "accept-error-handler-errored", moduleId: outdatedModuleId_parent_apply, dependencyId: dependenciesForCallbacks[k], error: err2, originalError: err });
                if (!options.ignoreErrored) { reportError(err2); reportError(err); }
              }
            } else { // No custom error handler
              if (options.onErrored) options.onErrored({ type: "accept-errored", moduleId: outdatedModuleId_parent_apply, dependencyId: dependenciesForCallbacks[k], error: err });
              if (!options.ignoreErrored) { reportError(err); }
            }
          }
        }
      }
    }
  }

  // 4. Re-execute self-accepted outdated modules
  for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
    var item = outdatedSelfAcceptedModules[o];
    var moduleId = item.module;
    try {
      item.require(moduleId); // This calls module.hot._requireSelf(moduleId)
                              // which typically involves __webpack_require__(moduleId)
                              // to re-run the (new) module factory.
    } catch (err) {
      // Handle errors during self-accept re-execution
      if (typeof item.errorHandler === "function") { // If module.hot.accept(errHandler) was used
        try {
          item.errorHandler(err, { moduleId: moduleId, module: __webpack_require__.c[moduleId] });
        } catch (err1) { // Error in the self-accept error handler
          if (options.onErrored) options.onErrored({ type: "self-accept-error-handler-errored", moduleId: moduleId, error: err1, originalError: err });
          if (!options.ignoreErrored) { reportError(err1); reportError(err); }
        }
      } else { // No custom error handler (module.hot.accept() or module.hot.accept(true))
        if (options.onErrored) options.onErrored({ type: "self-accept-errored", moduleId: moduleId, error: err });
        if (!options.ignoreErrored) { reportError(err); }
      }
    }
  }

  return outdatedModules; // Return the list of modules that were disposed/reloaded
}
Purpose: Activates the new module code and runs necessary handlers. This is where the application state effectively changes.Parameter:reportError: A function passed by the HMR engine to report errors that occur during the apply phase.Mechanism:Install New Module Factories:Iterates appliedUpdate (which contains moduleId: newFactoryFunction or moduleId: warnUnexpectedRequire).For each updateModuleId, it updates webpack's central module factory store: __webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId]. The next time __webpack_require__(updateModuleId) is called, it will use this new factory.Run New Runtime Code:Iterates currentUpdateRuntime (runtime functions collected from update chunks).Executes each runtimeFunction(__webpack_require__). These can perform arbitrary setup or modifications needed by the updated code.Clears currentUpdateRuntime.Call Accept Handlers (for accepted dependencies):Iterates outdatedDependencies (map of parentId: [acceptedChildId, ...]).For each parentModule that accepted updates from its children:Retrieves the parentModule from cache (__webpack_require__.c).Collects all unique acceptCallback functions registered by the parentModule for its acceptedChildren (using module.hot.accept(dependency, callback)). Also collects associated errorHandlers.Calls each unique acceptCallback(listOfAcceptedChildrenIds).Error Handling: If a callback throws an error:If an errorHandler was registered for that specific accept, it's called.If the errorHandler itself throws an error, or if no errorHandler was registered, the error is reported via options.onErrored and reportError (unless options.ignoreErrored is true).Re-execute Self-Accepted Modules:Iterates outdatedSelfAcceptedModules (modules that are outdated but have module.hot.accept() without specific dependencies).For each item = { module: moduleId, require: requireSelfFunction, errorHandler: selfAcceptErrorHandler }:Calls item.require(moduleId). This is typically module.hot._requireSelf, which effectively calls __webpack_require__(moduleId). Since __webpack_require__.m[moduleId] now points to the new factory, this re-runs the module's new code.Error Handling: If re-execution throws an error:If item.errorHandler is a function (from module.hot.accept(errHandler)), it's called.If the errorHandler itself throws, or if no specific errorHandler was provided (i.e., module.hot.accept() or module.hot.accept(true)), the error is reported via options.onErrored and reportError (unless options.ignoreErrored is true).Return Value: The outdatedModules array. This list represents all modules that were effectively replaced or reloaded as part of this HMR cycle. The HMR engine might use this for logging or further status updates.5.2. Helper Functions5.2.1. addAllToSet(a, b) (Internal to applyHandler)function addAllToSet(a, b) { // a: target array (set), b: source array
  for (var i = 0; i < b.length; i++) {
    var item = b[i];
    if (a.indexOf(item) === -1) a.push(item); // Add if not already present
  }
}
Purpose: A simple utility to add all items from array b to array a, ensuring uniqueness (acting like adding to a set).Parameters:a: The target array (mutated).b: The source array of items to add.6. Module Hot API Interaction (Implicit)This HMR runtime relies heavily on properties and methods that webpack injects onto each module's module.hot object. Key interactions include:module.hot._selfAccepted: (Boolean or Function) Checked by getAffectedModuleEffects and applyHandler to see if a module handles its own updates. If a function, it's an error handler.module.hot._selfInvalidated: (Boolean) Checked by getAffectedModuleEffects. If true, self-acceptance is bypassed, forcing propagation. Set by module.hot.invalidate().module.hot._selfDeclined: (Boolean) Checked by getAffectedModuleEffects. If true, the module refuses updates. Set by module.hot.decline().module.hot._main: (Boolean) Checked by getAffectedModuleEffects. Identifies entry modules.module.hot._acceptedDependencies: (Object: { dependencyId: callbackFunction }) Checked by getAffectedModuleEffects. Stores callbacks for accepted dependencies. Populated by module.hot.accept(dependency, callback).module.hot._acceptedErrorHandlers: (Object: { dependencyId: errorHandlerFunction }) Used in applyHandler().apply() when calling accept handlers. Populated by module.hot.accept(dependency, callback, errorHandler).module.hot._declinedDependencies: (Object: { dependencyId: true }) Checked by getAffectedModuleEffects. Stores dependencies that are explicitly declined. Populated by module.hot.decline(dependency).module.parents: (Array of moduleIds) Used by getAffectedModuleEffects to traverse up the dependency graph. Maintained by webpack.module.children: (Array of moduleIds) Used by applyHandler().dispose() to update graph linkage. Maintained by webpack.module.hot._disposeHandlers: (Array of Functions) Used by applyHandler().dispose(). Populated by module.hot.dispose(callback).module.hot._requireSelf: (Function) Used by applyHandler().apply() to re-execute self-accepting modules.module.hot.active: (Boolean) Set to false in applyHandler().dispose() to mark a module as inactive.__webpack_require__.hmrD: (Object: { moduleId: data }) Global store for data passed from dispose handlers to the new module version (accessible via module.hot.data).7. Event Callbacks (options in applyHandler)The applyHandler function accepts an options object, which can contain callbacks to allow the HMR orchestrator (or user code) to react to various events in the HMR lifecycle:options.onDeclined(result): Called when an update is declined (either self-declined or declined by a parent).result: { type, chain, moduleId, parentId? }options.onUnaccepted(result): Called when an update reaches an entry point (main module) and is not accepted.result: { type, chain, moduleId }options.onAccepted(result): Called when a module update is successfully accepted (either by itself or a parent).result: { type, moduleId, outdatedModules, outdatedDependencies }options.onDisposed(result): Called when a module is marked for disposal (typically because it was removed).result: { type, moduleId }options.onErrored(errorData): Called when an error occurs within an accept handler, a self-accept handler, or their respective error handlers.errorData: An object detailing the error context (e.g., type, moduleId, dependencyId, error, originalError).options.ignoreDeclined (Boolean): If true, the HMR process will not abort if an update is declined.options.ignoreUnaccepted (Boolean): If true, the HMR process will not abort if an update is unaccepted.options.ignoreErrored (Boolean): If true, errors reported via reportError (e.g., from accept handlers) will not necessarily halt the HMR process or be re-thrown by the HMR engine.These options provide flexibility in how the HMR process behaves and integrates with the broader application or development server.This detailed specification should cover the core functionality and interactions of the provided HMR runtime code. It's a sophisticated piece of machinery designed to make the development experience smoother by enabling live updates in a Node.js environment.
