# Loading Applications

This chapter will introduce how to use `createRemoteAppComponent` to load and integrate remote React applications in host applications.

## What is createRemoteAppComponent?

`createRemoteAppComponent` is the core API o  // Performance optimization: Control re-rendering behavior
  // - false: Standard behavior (default)
  // - true: Completely disable re-renders
  // - string[]: Only watch specified props
  disableRerender?: boolean | string[];React Bridge for loading remote React applications in host applications. It has the following features:

- **ğŸš€ Automatic Lazy Loading** - Remote applications are loaded only when needed
- **ğŸ”§ Lifecycle Management** - Automatically handles component mounting and unmounting
- **ğŸ›£ï¸ Router Integration** - Seamlessly integrates with React Router, supports basename injection
- **âš¡ Error Handling** - Built-in loading failure and runtime error handling mechanisms
- **ğŸ¨ Style Isolation** - Supports component-level styling and class name configuration 


## å®‰è£…

import { PackageManagerTabs } from '@theme';

<PackageManagerTabs
  command={{
    npm: 'npm install @module-federation/bridge-react@latest',
    yarn: 'yarn add @module-federation/bridge-react@latest',
    pnpm: 'pnpm add @module-federation/bridge-react@latest',
  }}
/>
## Basic Usage

### Step 1: Configure Remote Modules

Add remote application configuration to the host application's configuration file:

:::tip Build Tool Support
The following example uses Rsbuild configuration. Please adjust according to your build tool:
- **Rsbuild**: `@module-federation/rsbuild-plugin`
- **Rspack**: `@module-federation/enhanced/rspack`
- **Webpack**: `@module-federation/enhanced/webpack`
- **Vite**: `@module-federation/vite`

:::


```ts
// rsbuild.config.ts
import { pluginModuleFederation } from '@module-federation/rsbuild-plugin';
import { defineConfig } from '@rsbuild/core';

export default defineConfig({
  plugins: [
    pluginModuleFederation({
      name: 'host-app',
      remotes: {
        'remote1': 'remote1@http://localhost:3001/remoteEntry.js',
      },
    }),
  ],
});
```

### Step 2: Create Remote Components

#### 2.1 Define Loading and Error Components

First, create loading state and error handling components:

```tsx
// ./src/components/RemoteComponents.tsx
import React from 'react';

// Loading state component
export const LoadingComponent = () => (
  <div style={{ padding: '20px', textAlign: 'center' }}>
    <div>Loading remote application...</div>
  </div>
);

// Error fallback component
export const ErrorFallback = ({ error }: { error: Error }) => (
  <div style={{ padding: '20px', border: '1px solid #ff6b6b', borderRadius: '8px' }}>
    <h3>Remote Application Load Failed</h3>
    <p>Error details: {error.message}</p>
    <button onClick={() => window.location.reload()}>
      Reload Page
    </button>
  </div>
);
```

#### 2.2 Create Remote Application Component

Use `createRemoteAppComponent` to create remote components:

```tsx
// ./src/remotes/Remote1App.tsx
import { createRemoteAppComponent } from '@module-federation/bridge-react';
import { loadRemote } from '@module-federation/runtime';
import { LoadingComponent, ErrorFallback } from '../components/RemoteComponents';

export const Remote1App = createRemoteAppComponent({
  loader: () => loadRemote('remote1/export-app'),
  loading: LoadingComponent,
  fallback: ErrorFallback,
});
```

#### 2.3 Main Application Router Configuration

Configure routing in the main application:

```tsx
// ./src/App.tsx
import React from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { Remote1App } from './remotes/Remote1App';

// Host application home component
const HomePage = () => (
  <div style={{ padding: '20px' }}>
    <h1>Host Application Home</h1>
    <p>This is the home content of the host application</p>
  </div>
);

const App = () => {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route
          path="/remote1/*"
          // Use Remote1App component, will be lazy loaded
          Component={() => (
            <Remote1App
              // Can set className and style, will be automatically injected to the component
              className={styles.remote1}
              style={{ color: 'red' }}
              // name and age are remote component props, will be automatically passed to remote component
              name={'Ming'}
              age={12}
              // Can set ref, will be automatically forwarded to remote component for DOM manipulation
              ref={ref}
            />
          )}
        />
      </Routes>
    </BrowserRouter>
  );
};

export default App;
```

## Remote Component Props

### Router-related Properties

- **`basename`**: Set the base path for the remote application
- **`memoryRoute`**: Memory route configuration, used to control sub-application routing as memoryRouter

### Style Properties

- **`style`**: React.CSSProperties - Set component styles
- **`className`**: string - Set component class name

### Reference Support

- **`ref`**: React.Ref\<HTMLDivElement\> - Forward reference to internal container element for DOM manipulation

### Performance Optimization Properties

- **`disableRerender`**: boolean | string[] - Control remote component re-rendering behavior (default: false)
  - `false`: Standard behavior, re-render on props changes
  - `true`: Completely disable re-renders (except essential props)
  - `['prop1', 'prop2']`: Only re-render when specified props change

### Data Passing

- **`props`**: Property object passed to remote component
- Or pass properties directly, such as `userId={'123'}`

## createRemoteAppComponent API å‚è€ƒ

### å‡½æ•°ç­¾å

```tsx
function createRemoteAppComponent<T = Record<string, unknown>, E extends keyof T = keyof T>(
  config: RemoteComponentParams<T, E>
): React.ForwardRefExoticComponent<
  Omit<RemoteComponentProps<T>, "ref"> & React.RefAttributes<HTMLDivElement>
>
```

### RemoteComponentParams\<T, E\>

é…ç½®å‚æ•°æ¥å£ï¼š

```tsx
interface RemoteComponentParams<T = Record<string, unknown>, E extends keyof T = keyof T> {
  // è¿œç¨‹æ¨¡å—åŠ è½½å™¨
  loader: () => Promise<T>;
  
  // åŠ è½½çŠ¶æ€æ˜¾ç¤ºå†…å®¹
  loading: React.ReactNode;
  
  // é”™è¯¯å›é€€ç»„ä»¶
  fallback: React.ComponentType<{ error: Error }>;
  
  // å¯¼å‡ºåç§°ï¼ˆå¯é€‰ï¼‰
  export?: E;
  
  // ä¼ é€’ç»™è¿œç¨‹ç»„ä»¶çš„å±æ€§ï¼ˆå¯é€‰ï¼‰
  props?: T;
}
```

### RemoteComponentProps\<T\>

Component properties interface:

```tsx
interface RemoteComponentProps<T = Record<string, unknown>> {
  // Properties passed to remote component
  props?: T;
  
  // Error fallback component
  fallback?: React.ComponentType<{ error: Error }>;
  
  // Loading state content
  loading?: React.ReactNode;
  
  // Router base path
  basename?: string;
  
  // Memory route configuration
  memoryRoute?: {
    entryPath: string;
    initialState?: Record<string, unknown>;
  };
  
  // Style properties
  style?: React.CSSProperties;
  className?: string;
  
  // Performance optimization: disable re-render when host props change
  disableRerender?: boolean;
  
  // Other custom properties
  [key: string]: unknown;
}
```

### å‚æ•°è¯¦è§£

### loader

- **ç±»å‹**: `() => Promise<T>`
- **å¿…éœ€**: æ˜¯
- **ä½œç”¨**: ç”¨äºåŠ è½½è¿œç¨‹æ¨¡å—çš„å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ª Promiseï¼Œè¯¥ Promise è§£æä¸ºè¿œç¨‹æ¨¡å—å¯¹è±¡
- **ç¤ºä¾‹**:
  ```tsx
  loader: () => loadRemote('remote1/export-app')
  loader: () => import('remote1/export-app')
  ```

### loading

- **ç±»å‹**: `React.ReactNode`
- **å¿…éœ€**: æ˜¯
- **ä½œç”¨**: åœ¨è¿œç¨‹åº”ç”¨åŠ è½½æœŸé—´æ˜¾ç¤ºçš„åŠ è½½å†…å®¹ï¼Œå¯ä»¥æ˜¯ç»„ä»¶ã€å…ƒç´ æˆ–å­—ç¬¦ä¸²
- **ç¤ºä¾‹**:
  ```tsx
  loading: <div>Loading...</div>
  loading: 'Loading remote app...'
  loading: <Spinner />
  ```

### fallback

- **ç±»å‹**: `React.ComponentType<{ error: Error }>`
- **å¿…éœ€**: æ˜¯
- **ä½œç”¨**: å½“è¿œç¨‹åº”ç”¨åŠ è½½å¤±è´¥æ—¶æ˜¾ç¤ºçš„é”™è¯¯å›é€€ç»„ä»¶ï¼Œä¼šæ¥æ”¶é”™è¯¯å¯¹è±¡ä½œä¸º `error` å±æ€§
- **ç¤ºä¾‹**:
  ```tsx
  fallback: ({ error }) => <div>Error: {error.message}</div>
  fallback: ErrorBoundaryComponent
  ```

### export

- **ç±»å‹**: `E extends keyof T` (æ³›å‹çº¦æŸï¼Œé€šå¸¸æ˜¯ `string`)
- **å¿…éœ€**: å¦
- **é»˜è®¤å€¼**: `'default'`
- **ä½œç”¨**: æŒ‡å®šè¦ä½¿ç”¨çš„è¿œç¨‹æ¨¡å—å¯¼å‡ºåç§°
- **ç¤ºä¾‹**:
  
  å‡è®¾è¿œç¨‹æ¨¡å—æœ‰ä»¥ä¸‹å¯¼å‡ºï¼š
  ```tsx
  // è¿œç¨‹æ¨¡å—çš„å¯¼å‡º
  export default App;           // é»˜è®¤å¯¼å‡º
  export const provider = App;  // å‘½åå¯¼å‡º provider
  export const dashboard = Dashboard; // å‘½åå¯¼å‡º dashboard
  ```
  
  åœ¨å®¿ä¸»åº”ç”¨ä¸­å¯ä»¥è¿™æ ·ä½¿ç”¨ï¼š
  ```tsx
  // ä½¿ç”¨é»˜è®¤å¯¼å‡ºï¼ˆå¯ä»¥çœç•¥ export å‚æ•°ï¼‰
  createRemoteAppComponent({
    loader: () => loadRemote('remote1/export-app'),
    // export: 'default' // å¯ä»¥çœç•¥ï¼Œé»˜è®¤å°±æ˜¯ 'default'
  })
  
  // ä½¿ç”¨å‘½åå¯¼å‡º provider
  createRemoteAppComponent({
    loader: () => loadRemote('remote1/export-app'),
    export: 'provider'
  })
  
    // Use named export dashboard
  createRemoteAppComponent({
    loader: () => loadRemote('remote1/export-app'),
    export: 'dashboard'
  })
  ```

## Performance Optimization

### Using `disableRerender` to Control Re-rendering

The `disableRerender` prop provides three modes to fine-tune remote component re-rendering behavior for significant performance gains.

#### Three Usage Modes

##### Mode 1: ğŸš« Complete Disable (Boolean `true`)

Use when the remote app doesn't need to respond to any host prop changes.

```tsx
<Remote1App 
  disableRerender={true}  // Completely disable re-renders
  name="Ming"
  age={12}
  count={count}  // count changes won't trigger re-render
/>
```

**Behavior:**
- âœ… Renders only once (initial render)
- âŒ Subsequent prop changes won't trigger re-renders
- âš ï¸ Essential props still trigger re-render: `moduleName`, `basename`, `memoryRoute`

**Use Case:** Completely static remote apps like sidebars, footers.

---

##### Mode 2: ğŸ¯ Watch Specific Props (Array)

Only re-renders when specified props change - the most flexible mode!

```tsx
<Remote1App 
  disableRerender={['userId', 'theme']}  // Only watch these two props
  userId={userId}        // âœ… Changes will trigger re-render
  theme={theme}          // âœ… Changes will trigger re-render
  count={count}          // âŒ Changes won't trigger re-render
  timestamp={timestamp}  // âŒ Changes won't trigger re-render
/>
```

**Behavior:**
- âœ… Re-renders when `userId` or `theme` changes
- âŒ Other prop changes are ignored
- âš ï¸ Essential props always trigger re-render

**Use Case:** Remote apps that only care about specific data, like user profiles (userId, theme), dashboards with specific metrics.

---

##### Mode 3: âœ¨ Standard Behavior (Default / `false`)

Default React behavior - re-renders on every prop change.

```tsx
<Remote1App name="Ming" age={12} count={count} />
// or explicitly
<Remote1App disableRerender={false} name="Ming" age={12} count={count} />
```

---

#### Real-World Example: E-commerce Dashboard

```tsx
function Dashboard() {
  const [time, setTime] = useState(Date.now());
  const [userId, setUserId] = useState(1);
  const [theme, setTheme] = useState('light');
  const [cartCount, setCartCount] = useState(0);
  
  // Update time every second
  useEffect(() => {
    const timer = setInterval(() => setTime(Date.now()), 1000);
    return () => clearInterval(timer);
  }, []);
  
  return (
    <div>
      <div>Current Time: {new Date(time).toLocaleTimeString()}</div>
      
      {/* UserProfile only cares about userId and theme */}
      <UserProfileRemote 
        disableRerender={['userId', 'theme']}
        userId={userId}
        theme={theme}
        time={time}        // time changes won't cause re-render âœ…
        cartCount={cartCount}  // cartCount changes won't cause re-render âœ…
      />
      
      {/* CartWidget only cares about cartCount */}
      <CartWidgetRemote 
        disableRerender={['cartCount']}
        cartCount={cartCount}
        userId={userId}    // userId changes won't cause re-render âœ…
        theme={theme}      // theme changes won't cause re-render âœ…
        time={time}        // time changes won't cause re-render âœ…
      />
      
      {/* StaticSidebar doesn't need any updates */}
      <SidebarRemote 
        disableRerender={true}
        userId={userId}
        theme={theme}
        time={time}
      />
    </div>
  );
}
```

**Result:** 
- Time updates every second â†’ No remote component re-renders
- Only when relevant data changes, corresponding component updates
- Performance improvement up to **99%**

---

#### When to Use Each Mode

##### âœ… Use `disableRerender={true}` when:
- Remote app is completely static
- Doesn't need to respond to any prop changes
- Maximum performance optimization needed
- Example: Static sidebars, footers, headers

##### âœ… Use `disableRerender={['prop1', 'prop2']}` when:
- Remote app only responds to specific props
- Some props change frequently but are irrelevant
- Need fine-grained optimization
- Example: User profiles (userId, theme), dashboards (specific metrics)

##### âŒ Don't use when:
- Remote app needs to respond to all prop changes
- Real-time data synchronization required
- Props contain critical state that must update immediately

#### Basic Usage

```tsx
import { createRemoteAppComponent } from '@module-federation/bridge-react';
import { loadRemote } from '@module-federation/runtime';

const Remote1App = createRemoteAppComponent({
  loader: () => loadRemote('remote1/export-app'),
  loading: LoadingComponent,
  fallback: ErrorFallback,
});

function App() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      {/* Host state changes won't trigger Remote1App re-render */}
      <button onClick={() => setCount(c => c + 1)}>
        Host Count: {count}
      </button>
      
      <Remote1App 
        disableRerender={true}  // Enable optimization
        name="Username"
        userId={123}
      />
    </div>
  );
}
```

#### Usage with React Router

:::warning Important
When using `disableRerender`, you must avoid inline function components in routes. Otherwise, the component will be unmounted and remounted on every render, negating the optimization.
:::

âŒ **Incorrect: Inline Function Component**

```tsx
<Routes>
  {/* Wrong: Creates new component type on every render */}
  <Route 
    path="/remote1/*" 
    Component={() => <Remote1App disableRerender={true} />} 
  />
</Routes>
```

âœ… **Correct: Extract Component**

```tsx
// Approach 1: Extract as named component
const Remote1Route = () => {
  return <Remote1App disableRerender={true} />;
};

<Routes>
  <Route path="/remote1/*" Component={Remote1Route} />
</Routes>

// Approach 2: Include local state
const Remote1Route = () => {
  const [localCount, setLocalCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setLocalCount(c => c + 1)}>
        Local Count: {localCount}
      </button>
      <Remote1App 
        disableRerender={true}
        basename="/remote1"
      />
    </div>
  );
};

<Routes>
  <Route path="/remote1/*" Component={Remote1Route} />
</Routes>
```

#### Important Notes

1. **Initial props still apply**
   ```tsx
   // These initial props will be applied on first render
   <Remote1App 
     disableRerender={true}
     userId={123}      // Used on first render
     theme="dark"      // Used on first render
   />
   // Subsequent userId or theme changes won't update the remote app
   ```

2. **Essential props still trigger re-render**
   ```tsx
   // Even with disableRerender enabled, these prop changes will trigger re-render
   <Remote1App 
     disableRerender={true}
     moduleName="remote1/app"  // Changes trigger re-render
     basename="/app"           // Changes trigger re-render
     memoryRoute={{...}}       // Changes trigger re-render
   />
   ```

3. **Unmounting clears state**
   ```tsx
   // After unmounting, next mount is treated as first render
   {showRemote && <Remote1App disableRerender={true} />}
   ```

#### Advanced Pattern: Event Communication

If you need to communicate with the remote app while disabling re-renders, you can use an event bus:

```tsx
import EventEmitter from 'events';

// Create event bus
const eventBus = new EventEmitter();

// Host application
function HostApp() {
  const [userId, setUserId] = useState(1);
  
  // Notify remote app via events
  const handleUserChange = (newUserId) => {
    setUserId(newUserId);
    eventBus.emit('userChanged', { userId: newUserId });
  };
  
  return (
    <div>
      <button onClick={() => handleUserChange(2)}>Switch User</button>
      <Remote1App 
        disableRerender={true}
        eventBus={eventBus}  // Pass once
      />
    </div>
  );
}

// Inside remote app
function RemoteApp({ eventBus }) {
  const [userId, setUserId] = useState(1);
  
  useEffect(() => {
    const handler = (data) => setUserId(data.userId);
    eventBus.on('userChanged', handler);
    return () => eventBus.off('userChanged', handler);
  }, [eventBus]);
  
  return <div>Current User: {userId}</div>;
}
```


Enable debug logging to view render behavior:

```tsx
import { LoggerInstance } from '@module-federation/bridge-react';

// Enable debug logging
LoggerInstance.enable();
```

Expected log output:

```
// First render
RemoteAppWrapper useEffect triggered >>> { initialized: true, hasRenderedRef: false }
RemoteAppWrapper mark as rendered (disableRerender=true) >>>

// On host updates
RemoteAppWrapper React.memo preventing re-render (disableRerender=true) >>>
{ propsChanged: ['count'] }
```
````
  ```