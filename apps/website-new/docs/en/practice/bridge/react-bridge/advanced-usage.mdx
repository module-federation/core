# Advanced Usage

This chapter introduces advanced usage scenarios and best practices for React Bridge.

## Using export to Specify Module Export

When a remote module has multiple exports, you can specify which export to use:

```tsx
// Remote application - multiple exports
export const provider = createBridgeComponent({
  rootComponent: App
});

export const adminProvider = createBridgeComponent({
  rootComponent: AdminApp
});

export default provider;
```

```tsx
// Host application - specify export
const Remote1App = createRemoteAppComponent({
  loader: () => loadRemote('remote1/export-app'),
  export: 'provider', // Specify using provider export
  fallback: FallbackErrorComp,
  loading: FallbackComp,
});

const AdminRemoteApp = createRemoteAppComponent({
  loader: () => loadRemote('remote1/export-app'),
  export: 'adminProvider', // Specify using adminProvider export
  fallback: FallbackErrorComp,
  loading: FallbackComp,
});
```

## Using memoryRoute to Control Routing

`memoryRoute` allows controlling sub-application routing as memoryRouter, which won't directly display URLs in the browser address bar:

```tsx
function App() {
  return (
    <BrowserRouter basename="/">
      <Routes>
        <Route path="/" Component={Home} />
        <Route
          path="/remote1/*"
          Component={() => (
            <Remote1App
              className={styles.remote1}
              style={{ color: 'red' }}
              // Use memoryRoute to control sub-application routing as memoryRouter
              // Won't directly display URL in browser address bar
              memoryRoute={{ entryPath: '/detail' }}
              // Other properties will be passed to remote component
              props1={'props_value'}
              props2={'another_props_value'}
              ref={ref}
            />
          )}
        />
      </Routes>
    </BrowserRouter>
  );
}
```

### memoryRoute Use Cases

1. **Applications in Modals**: When loading remote applications in popups, you don't want to affect the main application's URL
2. **Tab Pages**: Loading different remote applications in tabs
3. **Embedded Components**: Embedding remote applications as components in specific areas of a page

## React 18/19 createRoot Options Configuration

### Setting Default Options

Set default options for all instances when creating bridge components:

```tsx
import { createBridgeComponent } from '@module-federation/bridge-react';

export default createBridgeComponent({
  rootComponent: App,
  // Set default createRoot options for all instances using this component
  defaultRootOptions: {
    identifierPrefix: 'my-app-',
    onRecoverableError: (error) => {
      console.error('Recoverable rendering error:', error);
      // You can add error reporting logic here
    }
  }
});
```

### Instance-level Options

Set options for specific instances during rendering:

```tsx
// In consumer application
const RemoteApp = createRemoteAppComponent({
  loader: () => loadRemote('remote1/export-app'),
  fallback: FallbackErrorComp,
  loading: FallbackComp,
});

// Pass rootOptions during rendering
<RemoteApp
  props={{ message: 'Hello' }}
  rootOptions={{
    identifierPrefix: 'instance-',
    onRecoverableError: (error) => {
      console.error('Recoverable error for this instance:', error);
    }
  }}
/>
```

Options passed during rendering will override default options set when creating the component.

## Error Handling Best Practices

### Comprehensive Error Fallback Component

```tsx
const FallbackErrorComp = ({ error }: { error: Error }) => {
  const [isRetrying, setIsRetrying] = React.useState(false);

  const handleRetry = async () => {
    setIsRetrying(true);
    try {
      // You can add retry logic here
      window.location.reload();
    } catch (err) {
      console.error('Retry failed:', err);
    } finally {
      setIsRetrying(false);
    }
  };

  return (
    <div className="error-fallback">
      <h2>Application Loading Failed</h2>
      <details>
        <summary>Error Details</summary>
        <pre>{error.message}</pre>
        {error.stack && <pre>{error.stack}</pre>}
      </details>
      <button onClick={handleRetry} disabled={isRetrying}>
        {isRetrying ? 'Retrying...' : 'Reload'}
      </button>
    </div>
  );
};
```

### Error Boundary Integration

Use with React Error Boundary:

```tsx
import { ErrorBoundary } from 'react-error-boundary';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route
          path="/remote/*"
          element={
            <ErrorBoundary fallback={<FallbackErrorComp />}>
              <RemoteApp basename="/remote" />
            </ErrorBoundary>
          }
        />
      </Routes>
    </BrowserRouter>
  );
}
```

## Performance Optimization

### Prefetch Remote Modules

```tsx
import { loadRemote } from '@module-federation/runtime';

// Prefetch before route switching
const preloadRemoteApp = () => {
  loadRemote('remote1/export-app').catch(console.error);
};

// Prefetch on user hover
<Link 
  to="/remote1" 
  onMouseEnter={preloadRemoteApp}
>
  Visit Remote Application
</Link>
```

### Lazy Loading Implementation

```tsx
import { lazy, Suspense } from 'react';

const LazyRemoteApp = lazy(() => 
  import('./RemoteAppWrapper').then(module => ({
    default: module.RemoteAppWrapper
  }))
);

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyRemoteApp />
    </Suspense>
  );
}
```

## Multi-version React Coexistence

### Version Detection

```tsx
import React from 'react';

// Detect React version
const reactVersion = React.version;
console.log('Current React version:', reactVersion);

// Use different imports based on version
let createBridgeComponent;
if (reactVersion.startsWith('16') || reactVersion.startsWith('17')) {
  createBridgeComponent = require('@module-federation/bridge-react/16').createBridgeComponent;
} else if (reactVersion.startsWith('18')) {
  createBridgeComponent = require('@module-federation/bridge-react/18').createBridgeComponent;
} else {
  // React 19+
  createBridgeComponent = require('@module-federation/bridge-react/19').createBridgeComponent;
}
```

### Version Isolation Strategy

```tsx
// remote-app.tsx - Remote application
import { createBridgeComponent } from '@module-federation/bridge-react';

// Ensure using correct React version
export default createBridgeComponent({
  rootComponent: App,
  // You can add version-specific configuration here
  defaultRootOptions: {
    identifierPrefix: `react-${React.version}-`,
  }
});
```

Through these advanced usages, you can better control and optimize React Bridge's performance in complex scenarios. Next, you can check [Data Prefetch](./data-prefetch) to learn how to improve application loading performance.
