# Bridge

## Introduction

The `MF bridge` is a utility function provided by `Module Federation` to help users load application-level modules through `Module Federation`. It automatically provides the necessary application lifecycle functions `render` and `destroy` required by the `provider` function and ensures compatibility with different framework versions. Additionally, it allows proper routing collaboration between applications.

:::tip
Before reading this chapter, it's assumed you are already familiar with:

- [How to consume and export modules](../guide/start/quick-start.mdx)
- [Module Federation Builder plugin](../guide/basic/rspack.mdx)
- [Features and capabilities of the Module Federation Runtime](../guide/basic/runtime.mdx)

:::

## Toolkits

### @module-federation/bridge-react

The `@module-federation/bridge-react` toolkit is a `bridge` utility function package provided by MF for React v18 applications. The exported `createBridgeComponent` can be used for exporting modules in React v18 applications. Usage examples of `@module-federation/bridge-react` can be found in the [Host demo](https://github.com/module-federation/core/blob/6756c9142d0bf41262a26fe30e3c39d7957cfa58/apps/router-demo/router-host-2000) and [Remote demo](https://github.com/module-federation/core/blob/6756c9142d0bf41262a26fe30e3c39d7957cfa58/apps/router-demo/router-remote2-2002).

### @module-federation/bridge-vue3

The `@module-federation/bridge-vue3` toolkit is a `bridge` utility function package provided by MF for Vue v3 applications. The exported `createBridgeComponent` can be used for exporting modules in Vue v3 sub-applications. Usage examples of `@module-federation/bridge-vue3` can be found in the [Host demo](https://github.com/module-federation/core/blob/6756c9142d0bf41262a26fe30e3c39d7957cfa58/apps/router-demo/router-host-2100) and [Remote demo](https://github.com/module-federation/core/blob/6756c9142d0bf41262a26fe30e3c39d7957cfa58/apps/router-demo/router-remote3-2003).

## React Bridge (for React v18)

`@module-federation/bridge-react` provides a `bridge` utility function for React v18 applications. The provided `createBridgeComponent` can be used to export application-level modules, and `createRemoteComponent` can be used to load application-level modules.

### Installation

import { PackageManagerTabs } from '@theme';

<PackageManagerTabs
  command={{
    npm: 'npm install @module-federation/bridge-react@0.0.0-next-20240619092013',
    yarn: 'yarn add @module-federation/bridge-react@0.0.0-next-20240619092013',
    pnpm: 'pnpm add @module-federation/bridge-react@0.0.0-next-20240619092013',
  }}
/>

### Type

```tsx
function createRemoteComponent<T, E extends keyof T>(
  // Function to load remote application, e.g., loadRemote('remote1/export-app') or import('remote1/export-app')
  lazyComponent: () => Promise<T>,
  info?: {
    // Default is 'default', used to specify module export
    export?: E;
  }
): (props: {
    basename?: string;
    memoryRoute?: { entryPath: string };
    fallback: ReactNode;
} & RawComponentType) => React.JSX.Element;
```

### Example

> Remote

```tsx
// ./src/export-app.tsx
import App from './src/App.tsx';
import { createBridgeComponent } from '@module-federation/bridge-react';

export default createBridgeComponent({
  rootComponent: App
});
```

```ts
// rsbuild.config.ts
export default defineConfig({
  source: {
    alias: {
      // Set react-router-dom to the proxy's router for convenience
      'react-router-dom$': path.resolve(
        __dirname,
        'node_modules/@module-federation/bridge-react/dist/router.es.js',
      ),
    },
  },
  tools: {
    rspack: (config, { appendPlugins }) => {
      appendPlugins([
        new ModuleFederationPlugin({
          name: 'remote1',
          exposes: {
            './export-app': './src/export-app.tsx',
          },
          shared: ['react', 'react-dom'],
        }),
      ]);
    },
  },
});
```

> Host

```ts
// rsbuild.config.ts
export default defineConfig({
  tools: {
    rspack: (config, { appendPlugins }) => {
      config.output!.uniqueName = 'host';
      appendPlugins([
        new ModuleFederationPlugin({
          name: 'host',
          remotes: {
            remote1: 'remote1@http://localhost:2001/mf-manifest.json',
          },
        }),
      ]);
    },
  },
});
```

```tsx
// ./src/App.tsx
import React from 'react';
import { createRemoteComponent } from '@module-federation/bridge-react';

const Remote1App = createRemoteComponent(() => loadRemote('remote2/export-app'));

const App = () => {
  return (
    <BrowserRouter basename="/">
      <Routes>
        <Route path="/" Component={Home} />
        <Route
          path="/remote1/*"
          Component={() => <Remote1App fallback={<div>loading</div>} />}
        />
      </Routes>
    </BrowserRouter>
  );
};
```

### Parameters

#### createRemoteComponent

```tsx
function createRemoteComponent<T, E extends keyof T>(
  // Function to load remote application, e.g., loadRemote('remote1/export-app') or import('remote1/export-app')
  lazyComponent: () => Promise<T>,
  options?: {
    // Default is 'default', used to specify module export
    export?: E;
  }
): (props: {
    basename?: ProviderParams['basename'];
    memoryRoute?: { entryPath: string };
    fallback: ReactNode;
} & RawComponentType) => React.JSX.Element;
```

* `lazyComponent`
  * type: `() => Promise<Module>`
  * Purpose: Used to load remote modules, e.g., `loadRemote('remote1/export-app')` or `import('remote1/export-app')`

```tsx
const Remote1App = createRemoteComponent(() => loadRemote('remote1/export-app'));
```

* `options`
  * `export`
    * type: `string`
    * Purpose: Used to specify module export
```tsx
// remote
export const provider = createBridgeComponent({
  rootComponent: App
});

// host
const Remote1App = createRemoteComponent(() => loadRemote('remote1/export-app'), {
  export: 'provider'
});
```

* ReturnType
  * type: `(props: PropsInfo) => React.JSX.Element`
  * Purpose: Used to render remote module components

```tsx
const Remote1App = createRemoteComponent(() => loadRemote('remote1/export-app'));

function App() {
  return (
    <BrowserRouter basename="/">
      <Routes>
        <Route
          path="/remote1/*"
          Component={() => <Remote1App fallback={<div>loading</div>} />}
        />
      </Routes>
    </BrowserRouter>
  );
}
```

```tsx
const Remote1App = createRemoteComponent(() => loadRemote('remote1/export-app'));

function App() {
  return (
    <BrowserRouter basename="/">
      <Routes>
        <Route
          path="/remote1/*"
          {/* Use memoryRoute to control sub-application routes with memoryRouter, which won't display the URL directly in the browser address */}
          Component={() => <Remote1App fallback={<div>loading</div>} memoryRoute={{ entryPath: '/detail' }}/>}
        />
      </Routes>
    </BrowserRouter>
  );
}
```

#### createBridgeComponent

```tsx
function createBridgeComponent<T>(bridgeInfo: {
  rootComponent: React.ComponentType<T>;
}): () => {
  render(info: {
    name?: string;
    basename?: string;
    memoryRoute?: {
      entryPath: string;
    };
    dom?: HTMLElement;
  }): void;
  destroy(info: { dom: HTMLElement }): void;
}
```

* `bridgeInfo`
  * type: `{ rootComponent: React.ComponentType<T>; }`
  * Purpose: Used to pass the root component
* ReturnType
  * type: `() => { render: (info: RenderFnParams) => void; destroy: (info: { dom: HTMLElement}) => void; }`

```tsx
// ./src/export-app.tsx
import React from 'react';
import App from './src/App.tsx';
import { createRemoteComponent } from '@module-federation/bridge-react';

export default createBridgeComponent({
  rootComponent: App
});
```

## Vue Bridge (for Vue v3)

`@module-federation/bridge-vue3` provides a `bridge` utility function for Vue v3 applications. The provided `createBridgeComponent` can be used to export application-level modules, and `createRemoteComponent` can be used to load application-level modules.

### Installation

<PackageManagerTabs
  command={{
    npm: 'npm install @module-federation/bridge-vue3@latest',
    yarn: 'yarn add @module-federation/bridge-vue3',
    pnpm: 'pnpm add @module-federation/bridge-vue3@latest',
  }}
/>

### Type

```tsx
function createRemoteComponent<T, E extends keyof T>(
  // Function to load remote application, e.g., loadRemote('remote1/export-app') or import('remote1/export-app')
  lazyComponent: () => Promise<T>,
  info?:
 {
    // Default is 'default', used to specify module export
    export?: E;
  }
): (props: {
    basename?: string;
    memoryRoute?: { entryPath: string };
}) => DefineComponent;

function createBridgeComponent(bridgeInfo: {
  rootComponent: VueComponent;
}): () => {
  render(info: {
    name?: string;
    basename?: string;
    memoryRoute?: {
      entryPath: string;
    };
    dom?: HTMLElement;
  }): void;
  destroy(info: {
    dom: HTMLElement;
  }): void;
}
```

### Example

> Remote

```tsx
// ./src/export-app.ts
import App from './App.vue';
import router from './router';
import { createBridgeComponent } from '@module-federation/bridge-vue3';

export default createBridgeComponent({
  rootComponent: App,
  appOptions: () => ({
    router,
  }),
});
```

```ts
// rsbuild.config.ts
export default defineConfig({
  tools: {
    rspack: (config, { appendPlugins }) => {
      appendPlugins([
        new ModuleFederationPlugin({
          name: 'remote1',
          exposes: {
            './export-app': './src/export-app.ts',
          },
          shared: ['vue', 'vue-router'],
        }),
      ]);
    },
  },
});
```

> Host

```ts
// rsbuild.config.ts
export default defineConfig({
  tools: {
    rspack: (config, { appendPlugins }) => {
      config.output!.uniqueName = 'host';
      appendPlugins([
        new ModuleFederationPlugin({
          name: 'host',
          remotes: {
            remote1: 'remote1@http://localhost:2001/mf-manifest.json',
          },
        }),
      ]);
    },
  },
});
```

```tsx
// ./src/router.ts
import * as bridge from '@module-federation/bridge-vue3';

const Remote2 = bridge.createRemoteComponent(() =>
  loadRemote('remote1/export-app'),
);

const router = createRouter({
  history: createWebHistory(),
  routes: [
    // Define your routes here
    { path: '/', component: Home },
    { path: '/remote1/:pathMatch(.*)*', component: Remote2 },
    // Other routes
  ],
});
export default router;
```

### Parameters

#### createRemoteComponent

```tsx
function createRemoteComponent<T, E extends keyof T>(
  // Function to load remote application, e.g., loadRemote('remote1/export-app') or import('remote1/export-app')
  lazyComponent: () => Promise<T>,
  options?: {
    // Default is 'default', used to specify module export
    export?: E;
  }
): (props: {
    basename?: string;
    memoryRoute?: { entryPath: string };
}) => DefineComponent;
```

* `lazyComponent`
  * type: `() => Promise<Module>`
  * Purpose: Used to load remote modules, e.g., `loadRemote('remote1/export-app')` or `import('remote1/export-app')`

```tsx
const Remote1App = createRemoteComponent(() => loadRemote('remote1/export-app'));
```

* `options`
  * `export`
    * type: `string`
    * Purpose: Used to specify module export
```tsx
// remote
export const provider = createBridgeComponent({
  rootComponent: App
});

// host
const Remote1App = createRemoteComponent(() => loadRemote('remote1/export-app'), {
  export: 'provider'
});
```

* ReturnType
  * type: `VueComponent`
  * Purpose: Used to render remote module components

```tsx
import * as bridge from '@module-federation/bridge-vue3';

const Remote2 = bridge.createRemoteComponent(() =>
  loadRemote('remote1/export-app'),
);

const router = createRouter({
  history: createWebHistory(),
  routes: [
    // Define your routes here
    { path: '/', component: Home },
    { path: '/remote1/:pathMatch(.*)*', component: Remote2 },
    // Other routes
  ],
});
export default router;
```

#### createBridgeComponent

```tsx
function createBridgeComponent<T>(bridgeInfo: {
  rootComponent: VueComponent;
  appOptions?: () => ({
    router: Router;
  });
}): () => {
  render(info: {
    name?: string;
    basename?: string;
    memoryRoute?: {
      entryPath: string;
    };
    dom?: HTMLElement;
  }): void;
  destroy(info: { dom: HTMLElement }): void;
}
```

* `bridgeInfo`
  * type: `{ rootComponent: VueComponent; appOptions?: () => ({ router: Router }) }`
  * Purpose: Used to pass the root component
* ReturnType
  * type: `() => { render: (info: RenderFnParams) => void; destroy: (info: { dom: HTMLElement}) => void; }`

```tsx
// ./src/export-app.ts
import { createBridgeComponent } from '@module-federation/bridge-vue3';
import App from './App.vue';
import router from './router';

export default createBridgeComponent({
  rootComponent: App,
  appOptions: () => ({
    router,
  }),
});
```

## FAQ

### Why Bridge?

Bridge is mainly used to solve two problems:

* Cross-application framework (React, Vue) loading and rendering
* Support for loading modules with routes (routes can work together properly)

These two problems are important features in the "micro-frontend framework".

### How to solve it if the corresponding framework bridge is not provided?

Currently, `Module Federation` provides official bridge toolkits. If you need bridge toolkits for other frameworks, you can provide feedback via [issue](https://github.com/module-federation/core/issues) or refer to the existing [`Bridge`](https://github.com/module-federation/core/blob/34ba220bcee3d032e4083aae37f802d1ed20d61b/packages/bridge/bridge-react) to implement it yourself.

The implementation of `Bridge` is very simple. The core is based on `DOM` rendering. Here is the pseudocode:

> Export module

```tsx
export default function () {
  const rootMap = new Map<any, ReactDOM.Root>();
  return {
    render(info: { dom: HTMLElement; basename?: string; memoryRoute?: { entryPath: string; } }) {
      const root = ReactDOM.createRoot(info.dom);
      rootMap.set(info.dom, root);
      root.render(<App />);
    },
    destroy(info: { dom: HTMLElement }) {
      const root = rootMap.get(info.dom);
      root?.unmount();
    },
  };
}
```

> Load module

```tsx
const LazyComponent = React.lazy(async () => {
  const m = await loadRemote('remote1/export-app');
  return {
    default: () => {
      const rootRef = useRef(null);
      const providerInfoRef = useRef<any>(null);

      useEffect(() => {
        const providerReturn = providerInfo();
        providerInfoRef.current = providerReturn;
        providerReturn.render(renderProps);

        return () => {
          providerInfoRef.current?.destroy({
            dom: renderDom.current,
          });
        };
      }, []);
      return <div ref={rootRef}></div>;
    },
  };
});

function Component() {
  return (
    <React.Suspense fallback={<div>loading</div>}>
      <LazyComponent />
    </React.Suspense>
  );
}
```
