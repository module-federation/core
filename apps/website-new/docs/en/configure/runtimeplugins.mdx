# runtimePlugins

- Type: `string[]`
- Required: No
- Default: `undefined`

The `runtimePlugins` configuration is used to add additional plugins needed at runtime. The value should be the path to the specific plugin, which can be an absolute/relative path or a package name. You can learn more about how to develop `runtimePlugin` details by visiting the [Plugin System](../plugin/dev/index).

Once set, runtime plugins will be automatically injected and used during the build process.

## TypeScript Interface

```ts
/**
 * Runtime plugin file paths or package names.
 * Each entry can be:
 * - Absolute file path: '/path/to/plugin.js'
 * - Relative file path: './runtime-plugins/my-plugin.js'
 * - Package name: '@my-org/federation-plugin'
 */
type RuntimePlugins = string[];

/**
 * Runtime plugin function signature
 */
type ModuleFederationRuntimePlugin = {
  name: string;
  beforeInit?: (args: BeforeInitArgs) => BeforeInitArgs | void;
  beforeLoadShare?: (args: BeforeLoadShareArgs) => BeforeLoadShareArgs | void;
  afterLoadShare?: (args: AfterLoadShareArgs) => AfterLoadShareArgs | void;
  beforeRequest?: (args: BeforeRequestArgs) => BeforeRequestArgs | void;
  afterRequest?: (args: AfterRequestArgs) => AfterRequestArgs | void;
  errorLoadRemote?: (args: ErrorLoadRemoteArgs) => void;
  beforeLoadRemote?: (args: BeforeLoadRemoteArgs) => BeforeLoadRemoteArgs | void;
  createScript?: (args: CreateScriptArgs) => HTMLScriptElement | void;
  fetch?: (url: string, options?: RequestInit) => Promise<Response>;
};

/**
 * Runtime plugin factory function
 */
type RuntimePluginFactory = () => ModuleFederationRuntimePlugin;
```

## Plugin Hook Types

```ts
// Hook argument types (simplified)
interface BeforeInitArgs {
  userOptions: UserOptions;
  origin: FederationHost;
}

interface BeforeLoadShareArgs {
  pkgName: string;
  shareInfo?: Shared;
  shared: ShareInfos;
  origin: FederationHost;
}

interface AfterLoadShareArgs {
  pkgName: string;
  sharedModule: any;
  shared: ShareInfos;
  origin: FederationHost;
}

interface BeforeRequestArgs {
  id: string;
  options: LoadModuleOptions;
  origin: FederationHost;
}

interface AfterRequestArgs {
  id: string;
  result: Module;
  options: LoadModuleOptions;
  origin: FederationHost;
}

interface ErrorLoadRemoteArgs {
  id: string;
  error: Error;
  from: 'build' | 'runtime';
  origin: FederationHost;
}

interface BeforeLoadRemoteArgs {
  id: string;
  options: LoadModuleOptions;
  origin: FederationHost;
}

interface CreateScriptArgs {
  url: string;
  attrs?: Record<string, string>;
}
```

- Examples

To create a runtime plugin file, you can name it `custom-runtime-plugin.ts`:

```ts title="custom-runtime-plugin.ts"
import { ModuleFederationRuntimePlugin } from '@module-federation/enhanced/runtime';

export default function (): ModuleFederationRuntimePlugin {
  return {
    name: 'custom-plugin-build',
    beforeInit(args) {
      console.log('[build time inject] beforeInit: ', args);
      return args;
    },
    beforeLoadShare(args) {
      console.log('[build time inject] beforeLoadShare: ', args);
      return args;
    },
  };
}
```

Then, apply this plugin in your build configuration:

```ts title="rspack.config.ts"
const path = require('path');
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      remotes: {
        'manifest-provider':
          'manifest_provider@http://localhost:3011/mf-manifest.json',
      },
      runtimePlugins: [path.resolve(__dirname, './custom-runtime-plugin.ts')],
    }),
  ],
};
```
