# Runtime API

import { Steps, Tab, Tabs, Badge, Aside } from '@theme';
import Collapse from '@components/Collapse'
import Runtime from '@components/en/runtime';

<Runtime />

## createInstance

Used to create ModuleFederation instance.

**Type Definition:**

```typescript
function createInstance(options: UserOptions): ModuleFederation

interface UserOptions {
  id?: string;
  name: string;
  version?: string;
  remotes?: Remote[];
  shared?: {
    [pkgName: string]: ShareArgs | ShareArgs[];
  };
  plugins?: ModuleFederationRuntimePlugin[];
  shareStrategy?: 'version-first' | 'loaded-first';
}

type Remote = (RemoteWithEntry | RemoteWithVersion) & {
  alias?: string;
  shareScope?: string | string[];
  type?: RemoteEntryType;
  entryGlobalName?: string;
};

interface RemoteWithEntry {
  name: string;
  entry: string;
}

interface RemoteWithVersion {
  name: string;
  version: string;
}

type ShareArgs = 
  | (SharedBaseArgs & { get: SharedGetter })
  | (SharedBaseArgs & { lib: () => Module })
  | SharedBaseArgs;

interface SharedBaseArgs {
  version?: string;
  shareConfig?: SharedConfig;
  scope?: string | Array<string>;
  deps?: Array<string>;
  strategy?: 'version-first' | 'loaded-first';
  loaded?: boolean;
}

interface SharedConfig {
  singleton?: boolean;
  requiredVersion: false | string;
  eager?: boolean;
  strictVersion?: boolean;
  layer?: string | null;
}

type SharedGetter = (() => () => Module) | (() => Promise<() => Module>);
```

* When to use `createInstance`?

To ensure the uniqueness of the ModuleFederation instance, after the build plugin creates an instance, it will be stored in memory. The exported APIs all first obtain the ModuleFederation instance from memory and then call the APIs of the ModuleFederation instance. This is also why APIs like loadRemote can be used directly from the `@module-federation/enhanced/runtime` package and inherently understand what application container they are attached to.

This singleton pattern works for most scenarios, but in the following cases, you need to use `createInstance`:

- No build plugin is used  (Only use runtime)
- Multiple ModuleFederation instances need to be created with different configurations for each instance
- You want to use ModuleFederation's partitioning feature to encapsulate corresponding APIs for use in other projects

**TypeScript Example:**

```typescript
import { createInstance, type UserOptions, type ModuleFederation } from '@module-federation/enhanced/runtime';

// Type-safe configuration
const options: UserOptions = {
  name: 'host',
  remotes: [
    {
      name: 'sub1',
      entry: 'http://localhost:8080/mf-manifest.json'
    }
  ],
  shared: {
    react: {
      version: '18.2.0',
      singleton: true,
      lib: () => import('react')
    }
  }
};

const mf: ModuleFederation = createInstance(options);

// Type-safe remote loading with generic return type
interface UtilModule {
  add: (a: number, b: number, c: number) => number;
}

mf.loadRemote<UtilModule>('sub1/util').then((m) => {
  const result = m.add(1, 2, 3); // TypeScript knows this returns a number
  console.log(result);
});
```

## init <Badge type='danger'>Deprecated</Badge>

:::warning Warning

This API will be deprecated. If you need to get an existing instance, you can use [getInstance](#getinstance) to retrieve the created instance.

If you need to create a new instance, please use the [createInstance](#createinstance).

:::

- Type: `init(options: InitOptions): void`
- Used for dynamically registering `Vmok` modules at runtime.
- InitOptions:

<Collapse>

```ts
type InitOptions {
    // Name of the current host
    name: string;
    // List of dependent remote modules
    // tip: The remotes configured at runtime are not completely consistent in type and data with those passed in by the build plugin.
    remotes: Array<RemoteInfo>;
    // List of dependencies that the current host needs to share
    // When using the build plugin, users can configure the dependencies to be shared in the build plugin, and the build plugin will inject the dependencies to be shared into the shared configuration at runtime.
    // When shared is passed in at runtime, the version instance reference must be passed in manually, because it cannot be directly obtained at runtime.
    shared?: {
      [pkgName: string]: ShareArgs | ShareArgs[];
    };
};

type ShareArgs =
  | (SharedBaseArgs & { get: SharedGetter })
  | (SharedBaseArgs & { lib: () => Module });

type SharedBaseArgs = {
  version: string;
  shareConfig?: SharedConfig;
  scope?: string | Array<string>;
  deps?: Array<string>;
  strategy?: 'version-first' | 'loaded-first';
};

type SharedGetter = (() => () => Module) | (() => Promise<() => Module>);

type RemoteInfo = {
  alias?: string;
};

interface RemotesWithEntry {
  name: string;
  entry: string;
}

type ShareInfos = {
  // Package name and basic information of the dependency, sharing strategy
  [pkgName: string]: Share;
};

type Share = {
  // Version of the shared dependency
  version: string;
  // Which modules consume the current shared dependency
  useIn?: Array<string>;
  // Which module the shared dependency comes from
  from?: string;
  // Factory function to get the instance of the shared dependency. When the cached shared instance cannot be loaded, it will load its own shared dependency.
  lib: () => Module;
  // Sharing strategy, which strategy will be used to determine the reuse of shared dependencies
  shareConfig?: SharedConfig;
  // Dependencies between shares
  deps?: Array<string>;
  // Under which scope the current shared dependency is placed, the default is default
  scope?: string | Array<string>;
};
```

</Collapse>

<Collapse title="Example">

```ts
import { init, loadRemote } from '@module-federation/enhanced/runtime';

init({
    name: "mf_host",
    remotes: [
        {
            name: "remote",
            // After configuring an alias, it can be loaded directly through the alias
            alias: "app1",
            // Decide which module to load by specifying the address of the module's manifest.json file
            entry: "http://localhost:2001/mf-manifest.json"
        }
    ],
});
```
</Collapse>

### How to Migrate

#### Build Plugin(Use build plugin)

1. Remove calls to the `init` API
2. Use [registerShared](#registershared) instead of the `shared` configuration in `init`
3. Use [registerRemotes](#registerremotes) instead of the `remotes` configuration in `init`
4. Use [registerPlugins](#registerplugins) instead of the `plugins` configuration in `init`
5. Use [getInstance](#getinstance) to obtain the `ModuleFederation` instance created by the build plugin

```diff
- import { init } from '@module-federation/enhanced/runtime';
+ import { registerShared, registerRemotes, registerPlugins, getInstance } from '@module-federation/enhanced/runtime';
import React from 'react';
import mfRuntimePlugin from 'mf-runtime-plugin';

- const instance = init({
+ const instance = getInstance();
- name: 'mf_host',
- remotes: [
-   {
-     name: 'remote',
-     entry: 'http://localhost:2001/mf-manifest.json',
-   }
- ],
+ registerRemotes([
+   {
+     name: 'remote',
+     entry: 'http://localhost:2001/mf-manifest.json',
+   }
+ ]);
- shared: {
-   react: {
-         version: "18.0.0",
-         scope: "default",
-         lib: ()=> React,
-         shareConfig: {
-             singleton: true,
-             requiredVersion: "^18.0.0"
-     }
-   },
- },
+ registerShared({
+   react: {
+     version: "18.0.0",
+     scope: "default",
+     lib: ()=> React,
+     shareConfig: {
+       singleton: true,
+       requiredVersion: "^18.0.0"
+     }
+   }
+ });
- plugins: [mfRuntimePlugin()]
+ registerPlugins([mfRuntimePlugin()]);
-});

```

#### Pure Runtime(Not Use Build Plugin)

```diff
- import { init } from '@module-federation/enhanced/runtime';
+ import { createInstance } from '@module-federation/enhanced/runtime';

-const instance = init({
+ const instance = createInstance({
name: 'mf_host',
remotes: [
  {
    name: 'remote',
    entry: 'http://localhost:2001/mf-manifest.json',
  }
],
shared: {
  react: {
        version: "18.0.0",
        scope: "default",
        lib: ()=> React,
        shareConfig: {
            singleton: true,
            requiredVersion: "^18.0.0"
    }
  },
},
plugins: [mfRuntimePlugin()]
});
```

If you are not using the build plugin, you can replace `init` with [createInstance](#createinstance), which has exactly the same parameters.

## getInstance

**Type Definition:**

```typescript
function getInstance(): ModuleFederation

interface ModuleFederation {
  name: string;
  version?: string;
  options: Options;
  
  // Core methods
  loadRemote<T = any>(id: string, options?: LoadModuleOptions): Promise<T>;
  loadShare<T = any>(pkgName: string, extraOptions?: LoadShareExtraOptions): Promise<() => T>;
  preloadRemote(preloadOptions: PreloadRemoteArgs[]): Promise<void>;
  
  // Registration methods
  registerRemotes(remotes: Remote[], options?: { force?: boolean }): void;
  registerPlugins(plugins: ModuleFederationRuntimePlugin[]): void;
  registerShared(shared: { [pkgName: string]: ShareArgs | ShareArgs[] }): void;
  
  // Utility methods
  initializeSharing(shareScope: string): Promise<void>;
  initContainer(shareScope?: string): Promise<void>;
}

interface LoadModuleOptions {
  version?: string;
  from?: 'build' | 'runtime';
}

interface LoadShareExtraOptions {
  customShareInfo?: Partial<Shared>;
  resolver?: (sharedOptions: ShareInfos[string]) => Shared;
}
```

Retrieves the `ModuleFederation` instance created by the build plugin.

When the build plugin is used, you can call `getInstance` to retrieve the `ModuleFederation` instance created by the build plugin.

**TypeScript Example:**

```typescript
import { getInstance, type ModuleFederation } from '@module-federation/enhanced/runtime';

const mfInstance: ModuleFederation = getInstance();

// Type-safe remote loading with interface
interface UtilModule {
  formatDate: (date: Date) => string;
  calculateSum: (numbers: number[]) => number;
}

// Load remote module with type safety
const utilModule = await mfInstance.loadRemote<UtilModule>('remote/util');
const formattedDate = utilModule.formatDate(new Date()); // TypeScript knows the return type
const sum = utilModule.calculateSum([1, 2, 3, 4]); // Type-safe method call
```

**Error Handling:**

If the build plugin is not used, calling `getInstance` will throw an exception. In this case, you need to use the [createInstance](#createinstance) to create a new instance.

```typescript
import { getInstance, createInstance, type ModuleFederation } from '@module-federation/enhanced/runtime';

let mf: ModuleFederation;

try {
  mf = getInstance();
} catch (error) {
  // Fallback to creating a new instance
  mf = createInstance({
    name: 'fallback-host',
    remotes: []
  });
}
```

## registerRemotes

**Type Definition:**

```typescript
function registerRemotes(
  remotes: Remote[], 
  options?: { force?: boolean }
): void

type Remote = (RemoteWithEntry | RemoteWithVersion) & RemoteInfoCommon;

interface RemoteInfoCommon {
  alias?: string;
  shareScope?: string | string[];
  type?: RemoteEntryType;
  entryGlobalName?: string;
}

interface RemoteWithEntry {
  name: string;
  entry: string;
}

interface RemoteWithVersion {
  name: string;
  version: string;
}

type RemoteEntryType = 'global' | 'esm' | 'systemjs';
```

## registerRemotes

<Collapse>

```typescript
function registerRemotes(remotes: Remote[], options?: { force?: boolean }) {}

type Remote = (RemoteWithEntry | RemoteWithVersion) & RemoteInfoCommon;

interface RemoteInfoCommon {
  alias?: string;
  shareScope?: string;
  type?: RemoteEntryType;
  entryGlobalName?: string;
}

interface RemoteWithEntry {
    name: string;
    entry: string;
}

interface RemoteWithVersion {
    name: string;
    version: string;
}
```

</Collapse>

- Details

**info**: Please set `force:true` with caution!

If `force: true` is set, it will overwrite the registered (and loaded) modules, and automatically delete the cache of the loaded modules (if they have been loaded), and output a warning in the console to inform that this operation is risky.

<Tabs>
  <Tab label="Build Plugin(Use build plugin)">
  ```tsx
    import { registerRemotes } from '@module-federation/enhanced/runtime';

    // register new remote sub2
    registerRemotes([
      {
          name: 'sub2',
          entry: 'http://localhost:2002/mf-manifest.json',
      }
    ]);

    // override remote sub1
    registerRemotes([
      {
          name: 'sub1',
          entry: 'http://localhost:2003/mf-manifest.json',
      }
    ],{ force:true });
  ```
  </Tab>
  <Tab label="Pure Runtime(Not use build plugin)">
  ```ts
    import { createInstance } from '@module-federation/enhanced/runtime';

    const mf = createInstance({
      name: 'mf_host',
      remotes: [
        {
          name: 'sub1',
          entry: 'http://localhost:2001/mf-manifest.json',
        }
      ]
    });

    // register new remote sub2
    mf.registerRemotes([
      {
          name: 'sub2',
          entry: 'http://localhost:2002/mf-manifest.json',
      }
    ]);

    //  override remote sub1
    mf.registerRemotes([
      {
          name: 'sub1',
          entry: 'http://localhost:2003/mf-manifest.json',
      }
    ],{ force:true });
  ```
  </Tab>
</Tabs>

## registerPlugins

**Type Definition:**

```typescript
function registerPlugins(plugins: ModuleFederationRuntimePlugin[]): void

interface ModuleFederationRuntimePlugin {
  name: string;
  version?: string;
  apply?: (instance: ModuleFederation) => void;
  
  // Lifecycle hooks - all optional
  beforeInit?: (args: BeforeInitOptions) => BeforeInitOptions;
  init?: (args: InitOptions) => void;
  beforeRequest?: (args: BeforeRequestOptions) => Promise<BeforeRequestOptions>;
  afterResolve?: (args: AfterResolveOptions) => Promise<AfterResolveOptions>;
  onLoad?: (args: OnLoadOptions) => Promise<void>;
  handlePreloadModule?: (args: HandlePreloadModuleOptions) => void;
  errorLoadRemote?: (args: ErrorLoadRemoteOptions) => Promise<void | unknown>;
  beforeLoadShare?: (args: BeforeLoadShareOptions) => Promise<BeforeLoadShareOptions>;
  resolveShare?: (args: ResolveShareOptions) => ResolveShareOptions;
  beforePreloadRemote?: (args: BeforePreloadRemoteOptions) => BeforePreloadRemoteOptions;
  generatePreloadAssets?: (args: GeneratePreloadAssetsOptions) => Promise<PreloadAssets>;
  createScript?: (args: CreateScriptOptions) => HTMLScriptElement | void;
  createLink?: (args: CreateLinkOptions) => HTMLLinkElement | void;
}

// Hook argument types
interface BeforeInitOptions {
  userOptions: UserOptions;
  options: Options;
  origin: ModuleFederation;
  shareInfo: ShareInfos;
}

interface InitOptions {
  options: Options;
  origin: ModuleFederation;
}

interface CreateScriptOptions {
  url: string;
}

interface CreateLinkOptions {
  url: string;
}
```

<Tabs>
  <Tab label="Build Plugin(Use build plugin)">
  ```tsx
    import { registerPlugins } from '@module-federation/enhanced/runtime';
    import runtimePlugin from './custom-runtime-plugin';

    // add new runtime plugin
    registerPlugins([runtimePlugin()]);

    registerPlugins([
      {
        name: 'custom-plugin-runtime',
        beforeInit(args) {
          const { userOptions, origin } = args;
          if (origin.options.name && origin.options.name !== userOptions.name) {
            userOptions.name = origin.options.name;
          }
          console.log('[build time inject] beforeInit: ', args);
          return args;
        },
        beforeLoadShare(args) {
          console.log('[build time inject] beforeLoadShare: ', args);
          return args;
        },
        createLink({ url }) {
          const link = document.createElement('link');
          link.setAttribute('href', url);
          link.setAttribute('rel', 'preload');
          link.setAttribute('as', 'script');
          link.setAttribute('crossorigin', 'anonymous');
          return link;
        },
      }
    ]);
  ```
  </Tab>
  <Tab label="Pure Runtime(Not use build plugin)">
  ```ts
    import { createInstance } from '@module-federation/enhanced/runtime';
    import runtimePlugin from './custom-runtime-plugin';

    const mf = createInstance({
      name: 'mf_host',
      remotes: [
        {
          name: 'sub1',
          entry: 'http://localhost:2001/mf-manifest.json',
        }
      ]
    });

    // add new runtime plugin
    mf.registerPlugins([runtimePlugin()]);

    mf.registerPlugins([
      {
        name: 'custom-plugin-runtime',
        beforeInit(args) {
          const { userOptions, origin } = args;
          if (origin.options.name && origin.options.name !== userOptions.name) {
            userOptions.name = origin.options.name;
          }
          console.log('[build time inject] beforeInit: ', args);
          return args;
        },
        beforeLoadShare(args) {
          console.log('[build time inject] beforeLoadShare: ', args);
          return args;
        },
        createLink({ url }) {
          const link = document.createElement('link');
          link.setAttribute('href', url);
          link.setAttribute('rel', 'preload');
          link.setAttribute('as', 'script');
          link.setAttribute('crossorigin', 'anonymous');
          return link;
        },
      }
    ]);
  ```
  </Tab>
</Tabs>

## registerShared

**Type Definition:**

```typescript
function registerShared(shared: SharedRegistry): void

type SharedRegistry = {
  [pkgName: string]: ShareArgs | ShareArgs[];
};

type ShareArgs = 
  | (SharedBaseArgs & { get: SharedGetter })
  | (SharedBaseArgs & { lib: () => Module })
  | SharedBaseArgs;

interface SharedBaseArgs {
  version?: string;
  shareConfig?: SharedConfig;
  scope?: string | Array<string>;
  deps?: Array<string>;
  strategy?: 'version-first' | 'loaded-first';
  loaded?: boolean;
}

interface SharedConfig {
  singleton?: boolean;
  requiredVersion: false | string;
  eager?: boolean;
  strictVersion?: boolean;
  layer?: string | null;
}

type SharedGetter = (() => () => Module) | (() => Promise<() => Module>);

// Utility types for better developer experience
type ReactSharedConfig = SharedBaseArgs & {
  lib: () => typeof React;
};

type ReactDOMSharedConfig = SharedBaseArgs & {
  lib: () => typeof ReactDOM;
};
```

## registerShared

<Collapse>

```typescript
function registerShared(shared: Shared) {}

type Shared = {
  [pkgName: string]: ShareArgs | ShareArgs[];
}
type ShareArgs = (SharedBaseArgs & {
    get: SharedGetter;
}) | (SharedBaseArgs & {
    lib: () => Module;
}) | SharedBaseArgs;
type SharedBaseArgs = {
    version?: string;
    shareConfig?: SharedConfig;
    scope?: string | Array<string>;
    deps?: Array<string>;
    strategy?: 'version-first' | 'loaded-first';
    loaded?: boolean;
};
interface SharedConfig {
    singleton?: boolean;
    requiredVersion: false | string;
    eager?: boolean;
    strictVersion?: boolean;
    layer?: string | null;
}
type SharedGetter = (() => () => Module) | (() => Promise<() => Module>);
```

</Collapse>

<Tabs>
  <Tab label="Build Plugin(Use build plugin)">
  ```tsx
    import { registerShared } from '@module-federation/enhanced/runtime';
    import React from 'react';
    import ReactDom from 'react-dom';

    registerShared({
      react: {
            version: "18.0.0",
            scope: "default",
            lib: ()=> React,
            shareConfig: {
                singleton: true,
                requiredVersion: "^18.0.0"
            }
        },
        "react-dom": {
            version: "18.0.0",
            scope: "default",
            lib: ()=> ReactDom,
            shareConfig: {
                singleton: true,
                requiredVersion: "^18.0.0"
            }
        }
    });
  ```
  </Tab>
  <Tab label="Pure Runtime(Not use build plugin)">
  ```ts
    import { createInstance } from '@module-federation/enhanced/runtime';
    import React from 'react';
    import ReactDom from 'react-dom';

    const mf = createInstance({
      name: 'mf_host',
      remotes: [
        {
          name: 'sub1',
          entry: 'http://localhost:2001/mf-manifest.json',
        }
      ]
    });

    registerShared({
      react: {
            version: "18.0.0",
            scope: "default",
            lib: ()=> React,
            shareConfig: {
                singleton: true,
                requiredVersion: "^18.0.0"
            }
        },
        "react-dom": {
            version: "18.0.0",
            scope: "default",
            lib: ()=> ReactDom,
            shareConfig: {
                singleton: true,
                requiredVersion: "^18.0.0"
            }
        }
    });
  ```
  </Tab>
</Tabs>

## loadShare

**Type Definition:**

```typescript
function loadShare<T = any>(
  pkgName: string, 
  extraOptions?: LoadShareExtraOptions
): Promise<() => T>

interface LoadShareExtraOptions {
  customShareInfo?: Partial<Shared>;
  resolver?: (sharedOptions: ShareInfos[string]) => Shared;
}

interface Shared {
  version: string;
  get: SharedGetter;
  shareConfig: SharedConfig;
  scope: Array<string>;
  useIn: Array<string>;
  from: string;
  deps: Array<string>;
  lib?: () => Module;
  loaded?: boolean;
  loading?: null | Promise<any>;
  eager?: boolean;
  strategy: ShareStrategy;
}

type ShareInfos = {
  [pkgName: string]: Shared[];
};

type ShareStrategy = 'version-first' | 'loaded-first';
type SharedGetter = (() => () => Module) | (() => Promise<() => Module>);
```

Gets a `share` dependency. When there is a `share` dependency in the global environment that meets the requirements of the current `host`, the existing dependency that meets the `share` conditions will be reused first. Otherwise, its own dependency will be loaded and stored in the global cache.

This `API` is **generally not called directly by the user, but is used by the build plugin to transform its own dependencies**.

**TypeScript Examples with Proper Typing:**

<Tabs>
  <Tab label="Build Plugin(Use build plugin)">
  ```typescript
    import { registerShared, loadShare, type SharedRegistry, type ReactSharedConfig } from '@module-federation/enhanced/runtime';
    import React from 'react';
    import ReactDOM from 'react-dom';

    // Type-safe shared configuration
    const sharedConfig: SharedRegistry = {
      react: {
        version: "18.2.0",
        scope: "default",
        lib: () => React,
        shareConfig: {
          singleton: true,
          requiredVersion: "^18.0.0"
        }
      } as ReactSharedConfig,
      "react-dom": {
        version: "18.2.0",
        scope: "default",
        lib: () => ReactDOM,
        shareConfig: {
          singleton: true,
          requiredVersion: "^18.0.0"
        }
      }
    };

    registerShared(sharedConfig);

    // Type-safe shared loading
    const reactFactory = await loadShare<typeof React>("react");
    const ReactLib = reactFactory(); // TypeScript knows this is the React library
    
    // Use with proper typing
    const element = ReactLib.createElement('h1', null, 'Hello World');
    console.log(element);
  ```
  </Tab>
  <Tab label="Pure Runtime(Not use build plugin)">
  ```typescript
    import { createInstance, type UserOptions, type SharedRegistry } from '@module-federation/enhanced/runtime';
    import React from 'react';
    import ReactDOM from 'react-dom';

    const config: UserOptions = {
      name: 'mf_host',
      remotes: [
        {
          name: 'remote',
          entry: 'http://localhost:2001/mf-manifest.json',
          alias: 'app1'
        }
      ]
    };

    const mf = createInstance(config);

    // Type-safe shared registration
    const sharedConfig: SharedRegistry = {
      react: {
        version: "18.2.0",
        scope: "default",
        lib: () => React,
        shareConfig: {
          singleton: true,
          requiredVersion: "^18.0.0"
        }
      },
      "react-dom": {
        version: "18.2.0",
        scope: "default", 
        lib: () => ReactDOM,
        shareConfig: {
          singleton: true,
          requiredVersion: "^18.0.0"
        }
      }
    };

    mf.registerShared(sharedConfig);

    // Type-safe shared loading with error handling
    try {
      const reactFactory = await mf.loadShare<typeof React>("react");
      const ReactLib = reactFactory();
      
      // TypeScript provides full autocomplete and type checking
      const component = ReactLib.createElement('div', { className: 'container' }, 'Hello from shared React!');
      console.log(component);
    } catch (error) {
      console.error('Failed to load shared dependency:', error);
    }
  ```
  </Tab>
</Tabs>

If multiple versions of shared are set, the loaded shared with the highest version will be returned by default. This behavior can be changed by setting `extraOptions.resolver`:

```ts
// ...

loadShare('react', {
   resolver: (sharedOptions) => {
      return (
        sharedOptions.find((i) => i.version === '17.0.0') ?? sharedOptions[0]
      );
  },
 }).then((reactFactory) => {
  console.log(reactFactory()); // { version: '17.0.0)' }
});
```

## loadRemote

**Type Definition:**

```typescript
function loadRemote<T = any>(id: string, options?: LoadModuleOptions): Promise<T>

interface LoadModuleOptions {
  version?: string;
  from?: 'build' | 'runtime';
}

// Usage with specific module types
interface RemoteModule<T = Record<string, any>> {
  [key: string]: T;
}

// For component modules
interface ComponentModule {
  default: React.ComponentType<any>;
  [exportName: string]: React.ComponentType<any>;
}

// For utility modules
interface UtilityModule {
  [functionName: string]: (...args: any[]) => any;
}
```

Loads a remote module with full TypeScript support.

**TypeScript Examples:**

<Tabs>
  <Tab label="Build Plugin(Use build plugin)">
  ```typescript
    import { loadRemote } from '@module-federation/enhanced/runtime';

    // Define interfaces for type safety
    interface UtilModule {
      add: (a: number, b: number, c: number) => number;
      multiply: (a: number, b: number) => number;
    }

    interface ComponentModule {
      default: React.ComponentType<{ title: string }>;
      Button: React.ComponentType<{ onClick: () => void; children: React.ReactNode }>;
    }

    // Type-safe remote loading
    const utilModule = await loadRemote<UtilModule>("remote/util");
    const result = utilModule.add(1, 2, 3); // TypeScript knows this returns number

    // Load React components with proper typing
    const { default: RemoteApp, Button } = await loadRemote<ComponentModule>("app1/components");
    
    // Use components with type safety
    const MyComponent: React.FC = () => (
      <div>
        <RemoteApp title="Hello from Remote" />
        <Button onClick={() => console.log('clicked')}>
          Click me
        </Button>
      </div>
    );
  ```
  </Tab>
  <Tab label="Pure Runtime(Not use build plugin)">
  ```typescript
    import { createInstance, type UserOptions, type ModuleFederation } from '@module-federation/enhanced/runtime';

    // Type-safe configuration
    const config: UserOptions = {
      name: 'mf_host',
      remotes: [
        {
          name: 'remote',
          entry: 'http://localhost:2001/mf-manifest.json',
          alias: 'app1'
        }
      ]
    };

    const mf: ModuleFederation = createInstance(config);

    // Define module interfaces
    interface UtilModule {
      add: (a: number, b: number, c: number) => number;
      subtract: (a: number, b: number) => number;
    }

    // Type-safe remote loading with error handling
    try {
      const utilModule = await mf.loadRemote<UtilModule>("remote/util");
      const sum = utilModule.add(1, 2, 3); // Type-safe method call
      
      const utilModuleByAlias = await mf.loadRemote<UtilModule>("app1/util");
      const difference = utilModuleByAlias.subtract(10, 5);
      
      console.log({ sum, difference });
    } catch (error) {
      console.error('Failed to load remote module:', error);
    }
  ```
  </Tab>
</Tabs>

## preloadRemote

**Type Definition:**

```typescript
function preloadRemote(preloadOptions: PreloadRemoteArgs[]): Promise<void>

interface PreloadRemoteArgs {
  nameOrAlias: string;
  exposes?: string[];
  resourceCategory?: 'all' | 'sync';
  share?: boolean;
  depsRemote?: boolean | depsPreloadArg[];
  filter?: (assetUrl: string) => boolean;
  prefetchInterface?: boolean;
}

type depsPreloadArg = Omit<PreloadRemoteArgs, 'depsRemote'>;

interface PreloadAssets {
  cssAssets: string[];
  jsAssetsWithoutEntry: string[];
  entryAssets: EntryAssets[];
}

interface EntryAssets {
  name: string;
  url: string;
  moduleInfo: RemoteInfo;
}
```

## preloadRemote

<Collapse>

```typescript
async function preloadRemote(preloadOptions: Array<PreloadRemoteArgs>){}

type depsPreloadArg = Omit<PreloadRemoteArgs, 'depsRemote'>;
type PreloadRemoteArgs = {
  // Name or alias of the remote to be preloaded
  nameOrAlias: string;
  // Whether to preload the module's interface, the default value is false. For details, please refer to the <Interface Prefetch> chapter in <Performance Optimization>. The @vmok/kit version needs to be greater than 1.7.6.
  prefetchInterface?: boolean;
  // The exposes to be preloaded
  // By default, all exposes are preloaded
  // When exposes are provided, only the required exposes will be loaded
  exposes?: Array<string>; // Default request
  // The default is sync, which only loads the synchronous code referenced in expose
  // When set to all, both synchronous and asynchronous references will be loaded
  resourceCategory?: 'all' | 'sync';
  // When no value is configured, all dependencies are loaded by default
  // After configuring dependencies, only the configuration options will be loaded
  depsRemote?: boolean | Array<depsPreloadArg>;
  // When not configured, resources are not filtered
  // After configuration, unnecessary resources will be filtered
  filter?: (assetUrl: string) => boolean;
};
```

</Collapse>

- Details

Through `preloadRemote`, you can start preloading module resources at an earlier stage to avoid waterfall requests. What can `preloadRemote` preload:

* `remote`'s `remoteEntry`
* `remote`'s `expose`
* `remote`'s synchronous or asynchronous resources
* `remote`'s dependent `remote` resources
<Tabs>
  <Tab label="Build Plugin(Use build plugin)">
  ```tsx
    import { registerRemotes, preloadRemote } from '@module-federation/enhanced/runtime';

    registerRemotes([
      {
          name: 'sub1',
          entry: "http://localhost:2001/mf-manifest.json"
      },
      {
          name: 'sub2',
          entry: "http://localhost:2002/mf-manifest.json"
      },
      {
          name: 'sub3',
          entry: "http://localhost:2003/mf-manifest.json"
      },
    ]);

    // 预加载 sub1 模块
    // 过滤资源名称中携带 ignore 的资源信息
    // 只预加载子依赖的 sub1-button 模块
    preloadRemote([
        {
            nameOrAlias: 'sub1',
            filter(assetUrl) {
                return assetUrl.indexOf('ignore') === -1;
            },
            depsRemote: [{ nameOrAlias: 'sub1-button' }],
        },
    ]);


    // 预加载 sub2 模块
    // 预加载 sub2 下的所有 expose
    // 预加载 sub2 的同步资源和异步资源
    preloadRemote([
        {
            nameOrAlias: 'sub2',
            resourceCategory: 'all',
        },
    ]);

    // 预加载 sub3 模块的 add expose
    preloadRemote([
        {
            nameOrAlias: 'sub3',
            resourceCategory: 'all',
            exposes: ['add'],
        },
    ]);
  ```
  </Tab>
  <Tab label="Pure Runtime(Not use build plugin)">
  ```ts
    import { createInstance } from '@module-federation/enhanced/runtime';

    const mf = createInstance({
      name: 'mf_host',
      remotes: []
    });

    mf.registerRemotes([
      {
          name: 'sub1',
          entry: "http://localhost:2001/mf-manifest.json"
      },
      {
          name: 'sub2',
          entry: "http://localhost:2002/mf-manifest.json"
      },
      {
          name: 'sub3',
          entry: "http://localhost:2003/mf-manifest.json"
      },
    ]);

    // preload sub1
    // Filter resource information with ignore in resource names
    // Preload only sub-dependency sub1-button module
    mf.preloadRemote([
        {
            nameOrAlias: 'sub1',
            filter(assetUrl) {
                return assetUrl.indexOf('ignore') === -1;
            },
            depsRemote: [{ nameOrAlias: 'sub1-button' }],
        },
    ]);


    // preload sub2
    // Preload all exposes in sub2
    // Preload sub2's sync and async resources
    mf.preloadRemote([
        {
            nameOrAlias: 'sub2',
            resourceCategory: 'all',
        },
    ]);

    // preload sub3
    // Preload all exposes in sub3
    // Preload sub3's sync and async resources
    mf.preloadRemote([
        {
            nameOrAlias: 'sub3',
            resourceCategory: 'all',
            exposes: ['add'],
        },
    ]);
  ```
  </Tab>
</Tabs>

