# 共享依赖 Tree Shaking

## 背景

在使用模块联邦（Module Federation, MF）时，我们常常通过 `shared` 配置来共享通用依赖（如 antd, React 等），以减少重复打包和提升应用间的一致性。然而，传统 `shared` 机制存在一个痛点：它总是会打包并提供**完整的**依赖包，即便你的应用实际只用到了其中的一小部分功能（例如，只用了一个 antd 的 `Button` 组件）。

这会导致：
*   **构建产物体积过大**：不必要的代码被打包，增加了最终产物的体积。
*   **运行时性能损耗**：浏览器需要下载并执行更多非必需的 JavaScript，延长了页面加载和渲染时间。

**Shared Tree Shaking** 正是为了解决这一问题而生。它能够智能地分析你的代码，精确识别出实际被使用的模块导出（exports），并仅打包这部分代码。最终，你的应用将获得一个经过“摇树”优化、体积更小的共享依赖。

> **核心收益：**
> * **更小的构建体积**：从源头上减少不必要的代码，大幅缩减产物尺寸。
> * **更快的加载速度**：用户只需下载真正需要的代码，加速页面响应。
> * **更优的渲染性能**：减少浏览器解析和执行的 JavaScript，提升运行时体验。

## 工作原理简介

Shared Tree Shaking 的核心思想是**按需打包**。它通过静态代码分析，在构建期收集每个应用对共享依赖的具体使用情况（例如，A 应用使用了 antd 的 `Button` 和 `Input`，B 应用使用了 `Modal`）。

基于这些信息，它提供了两种灵活的策略来生成最优的共享产物：

1.  **服务端辅助策略 (server)**：在 CI/CD 或云端发布环节，一个中心化服务会聚合所有应用对共享依赖的使用信息，并生成一个“最小并集”的优化产物。此产物仅包含所有应用实际用到的模块，供大家一起消费。
2.  **推断式策略 (infer)**：在没有中心化服务支持的环境下，应用可以自行推断。如果当前页面所需的功能已经被某个已加载的、经过 Tree Shaking 的共享包所满足，则直接复用；否则，回退加载完整的依赖包，确保功能完备。

## 实践

为你的项目开启 Shared Tree Shaking 非常简单，只需在模块联邦配置文件中添加 `treeShaking` 选项即可。

### 策略一：推断式策略 (`infer`)

此策略适用于无中心化构建服务、或希望在本地开发和小型项目中快速体验的场景。

```ts
// webpack.config.js 或 rspack.config.js
export default {
  //...
  plugins: [
    new ModuleFederationPlugin({
      //...
      shared: {
        'antd': {
          treeShaking: { strategy: 'infer' }
        }
      }
    })
  ]
};
```

`infer` 策略会基于运行时已加载的模块进行判断，虽然灵活性高，但由于缺少完整的依赖信息，复用率会有所降低。

因此需要用户手动添加额外的 [usedExports](../../configure/shared#usedexports) 来提高 shared 的复用率。


### 策略二：服务端辅助策略 (`server`)

此策略适用于拥有部署服务（Deployment Service）的团队，是**官方推荐的最佳实践**。它能最大化 Tree Shaking 收益。

```ts
// webpack.config.js 或 rspack.config.js
export default {
  //...
  plugins: [
    new ModuleFederationPlugin({
      //...
      shared: {
        'antd': {
          treeShaking: { strategy: 'server' }
        }
      }
    })
  ]
};
```

在启用此策略后，MF Runtime 将依据服务端下发的 Snapshot 来决定是否加载 tree shaking 的共享依赖。

#### 服务端辅助策略（server）的自建实现思路

> **前置要求**：需要有部署服务或者能控制 deploy server 。

1. 部署阶段收集所有模块的依赖信息，并加载对应的 mf-stats.json
2. 收集所有设置 Tree Shaking 的 usedExports 信息（根据 mf-stats.json 里 shared 是否有 `usedExports` 字段判端是否开启了 Tree Shaking）
3. 参考 [example](https://github.com/2heal1/re-shake-shared-example/tree/main) 对收集到的 shared 发起新一轮的构建，随后上传对应的资源文件
4. 更新 snapshot 中的 `reShakeShareEntry`、`reShakeShareName`和 `treeShakingStatus` 字段，并下发数据。

## 常见问题与注意事项

**1. Shared Tree Shaking 能和 `eager: true` 一起使用吗？**

  **不能。** `eager: true` 会将共享依赖直接打包进应用入口文件（initial chunk），这与 Shared Tree Shaking 按需动态加载的机制相冲突。你需要在这两者之间做出取舍：
* 如果你追求极致的初始加载性能，且共享依赖体积不大，`eager: true` 可能是个不错的选择。
* 如果你的共享依赖体积庞大（如组件库），强烈建议关闭 `eager`，转而使用 Shared Tree Shaking 来获得显著的体积与性能收益。

**2. 它是否会破坏已发布项目的共享依赖？**

  **不会。** Tree Shaking 有严格的命中条件，并且它的数据源与原先的 shared 不同，因此不会破坏已发布项目的共享依赖。

注意：需要关注的是如果 strategy 为 `infer` 或者在运行时加载动态生产者，那么可能会发生「项目 A 加载**自身** Tree Shaking 的共享依赖，项目 B 加载**自身**全量的共享依赖」的情况。如果这个共享依赖是必须单例，那么可能会出现页面崩溃或未知情况。因此如果是必须代理的组件库，请小心设置！
