# 进阶用法

本章介绍 React Bridge 的高级使用场景和最佳实践。

## 使用 export 指定模块导出

当远程模块有多个导出时，可以指定使用特定的导出：

```tsx
// 远程应用 - 多个导出
export const provider = createBridgeComponent({
  rootComponent: App
});

export const adminProvider = createBridgeComponent({
  rootComponent: AdminApp
});

export default provider;
```

```tsx
// 宿主应用 - 指定导出
const Remote1App = createRemoteAppComponent({
  loader: () => loadRemote('remote1/export-app'),
  export: 'provider', // 指定使用 provider 导出
  fallback: FallbackErrorComp,
  loading: FallbackComp,
});

const AdminRemoteApp = createRemoteAppComponent({
  loader: () => loadRemote('remote1/export-app'),
  export: 'adminProvider', // 指定使用 adminProvider 导出
  fallback: FallbackErrorComp,
  loading: FallbackComp,
});
```

## 使用 memoryRoute 控制路由

`memoryRoute` 允许将子应用路由作为 memoryRouter 控制，不会直接在浏览器地址栏中显示 URL：

```tsx
function App() {
  return (
    <BrowserRouter basename="/">
      <Routes>
        <Route path="/" Component={Home} />
        <Route
          path="/remote1/*"
          Component={() => (
            <Remote1App
              className={styles.remote1}
              style={{ color: 'red' }}
              // 使用 memoryRoute 将子应用路由作为 memoryRouter 控制
              // 不会直接在浏览器地址栏中显示 URL
              memoryRoute={{ entryPath: '/detail' }}
              // 其他属性将传递给远程组件
              props1={'props_value'}
              props2={'another_props_value'}
              ref={ref}
            />
          )}
        />
      </Routes>
    </BrowserRouter>
  );
}
```

### memoryRoute 使用场景

1. **模态框中的应用**：在弹窗中加载远程应用时，不希望影响主应用的 URL
2. **Tab 页面**：在标签页中加载不同的远程应用
3. **嵌入式组件**：将远程应用作为组件嵌入到页面的特定区域

## React 18/19 createRoot 选项配置

### 设置默认选项

在创建 bridge component 时设置所有实例的默认选项：

```tsx
import { createBridgeComponent } from '@module-federation/bridge-react';

export default createBridgeComponent({
  rootComponent: App,
  // 为使用此组件的所有实例设置默认 createRoot 选项
  defaultRootOptions: {
    identifierPrefix: 'my-app-',
    onRecoverableError: (error) => {
      console.error('可恢复的渲染错误:', error);
      // 可以在这里添加错误上报逻辑
    }
  }
});
```

### 实例级别选项

在渲染时为特定实例设置选项：

```tsx
// 在消费者应用中
const RemoteApp = createRemoteAppComponent({
  loader: () => loadRemote('remote1/export-app'),
  fallback: FallbackErrorComp,
  loading: FallbackComp,
});

// 在渲染时传递 rootOptions
<RemoteApp
  props={{ message: 'Hello' }}
  rootOptions={{
    identifierPrefix: 'instance-',
    onRecoverableError: (error) => {
      console.error('此实例的可恢复错误:', error);
    }
  }}
/>
```

渲染时传递的选项将覆盖创建组件时设置的默认选项。

## 错误处理最佳实践

### 完善的错误回退组件

```tsx
const FallbackErrorComp = ({ error }: { error: Error }) => {
  const [isRetrying, setIsRetrying] = React.useState(false);

  const handleRetry = async () => {
    setIsRetrying(true);
    try {
      // 可以在这里添加重试逻辑
      window.location.reload();
    } catch (err) {
      console.error('重试失败:', err);
    } finally {
      setIsRetrying(false);
    }
  };

  return (
    <div className="error-fallback">
      <h2>应用加载失败</h2>
      <details>
        <summary>错误详情</summary>
        <pre>{error.message}</pre>
        {error.stack && <pre>{error.stack}</pre>}
      </details>
      <button onClick={handleRetry} disabled={isRetrying}>
        {isRetrying ? '重试中...' : '重新加载'}
      </button>
    </div>
  );
};
```

### 错误边界集成

结合 React Error Boundary 使用：

```tsx
import { ErrorBoundary } from 'react-error-boundary';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route
          path="/remote/*"
          element={
            <ErrorBoundary fallback={<FallbackErrorComp />}>
              <RemoteApp basename="/remote" />
            </ErrorBoundary>
          }
        />
      </Routes>
    </BrowserRouter>
  );
}
```

## 性能优化

### 预加载远程模块

```tsx
import { loadRemote } from '@module-federation/runtime';

// 在路由切换前预加载
const preloadRemoteApp = () => {
  loadRemote('remote1/export-app').catch(console.error);
};

// 在用户 hover 时预加载
<Link 
  to="/remote1" 
  onMouseEnter={preloadRemoteApp}
>
  访问远程应用
</Link>
```

### 懒加载实现

```tsx
import { lazy, Suspense } from 'react';

const LazyRemoteApp = lazy(() => 
  import('./RemoteAppWrapper').then(module => ({
    default: module.RemoteAppWrapper
  }))
);

function App() {
  return (
    <Suspense fallback={<div>加载中...</div>}>
      <LazyRemoteApp />
    </Suspense>
  );
}
```

## 多版本 React 共存

### 版本检测

```tsx
import React from 'react';

// 检测 React 版本
const reactVersion = React.version;
console.log('当前 React 版本:', reactVersion);

// 根据版本使用不同的导入
let createBridgeComponent;
if (reactVersion.startsWith('16') || reactVersion.startsWith('17')) {
  createBridgeComponent = require('@module-federation/bridge-react/16').createBridgeComponent;
} else if (reactVersion.startsWith('18')) {
  createBridgeComponent = require('@module-federation/bridge-react/18').createBridgeComponent;
} else {
  // React 19+
  createBridgeComponent = require('@module-federation/bridge-react/19').createBridgeComponent;
}
```

### 版本隔离策略

```tsx
// remote-app.tsx - 远程应用
import { createBridgeComponent } from '@module-federation/bridge-react';

// 确保使用正确的 React 版本
export default createBridgeComponent({
  rootComponent: App,
  // 可以在这里添加版本特定的配置
  defaultRootOptions: {
    identifierPrefix: `react-${React.version}-`,
  }
});
```

通过这些进阶用法，您可以更好地控制和优化 React Bridge 在复杂场景下的表现。接下来可以查看 [高级功能](./advanced-features) 了解运行时插件等更高级的特性。
