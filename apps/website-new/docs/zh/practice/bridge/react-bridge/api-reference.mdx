# API 参考

本章提供了 React Bridge 所有 API 的详细文档。

## createBridgeComponent

`createBridgeComponent` 用于导出远程 React 组件。

```tsx
/**
 * 创建用于远程加载的 Bridge Component
 * @param bridgeInfo - Bridge Component配置信息
 * @returns 返回一个提供 render 和 destroy 方法的函数
 */
function createBridgeComponent<T>(
  bridgeInfo: ProviderFnParams<T>
): () => {
  render(info: RenderFnParams): Promise<void>;
  destroy(info: DestroyParams): Promise<void>;
};
```

### ProviderFnParams

Bridge Component 配置信息：

```tsx
interface ProviderFnParams<T> {
  /** 要远程加载的根组件 */
  rootComponent: React.ComponentType<T>;

  /**
   * 自定义渲染函数，用于自定义渲染逻辑
   * @param App - React 元素
   * @param id - DOM 元素或字符串 ID
   * @returns React 根元素或 Promise
   */
  render?: (
    App: React.ReactElement,
    id?: HTMLElement | string,
  ) => RootType | Promise<RootType>;

  /**
   * 自定义 createRoot 函数，用于 React 18 及以上版本
   * @param container - DOM 容器
   * @param options - CreateRoot 选项
   * @returns React 根节点
   */
  createRoot?: (
    container: Element | DocumentFragment,
    options?: CreateRootOptions,
  ) => Root;

  /**
   * React 18 和 19 的 createRoot 默认选项
   * 这些选项将在创建根节点时使用，除非在渲染参数中被 rootOptions 覆盖
   * @example
   * {
   *   identifierPrefix: 'app-',
   *   onRecoverableError: (err) => console.error(err)
   * }
   */
  defaultRootOptions?: CreateRootOptions;
}
```

### 使用示例

```tsx
import { createBridgeComponent } from '@module-federation/bridge-react';

export default createBridgeComponent({
  rootComponent: App,
  // 可选：自定义默认 createRoot 选项 (React 18+)
  defaultRootOptions: {
    identifierPrefix: 'my-app-',
    onRecoverableError: (error) => console.error(error)
  }
});
```

## createRemoteAppComponent

`createRemoteAppComponent` 用于加载远程 React 组件。

```tsx
/**
 * 创建远程 React 组件
 * @param options - 远程组件配置选项
 * @returns 返回一个可以接收 props 并渲染远程组件的 React 组件
 */
function createRemoteAppComponent<T, E extends keyof T = 'default'>(
  options: RemoteComponentParams<T, E>
): React.ForwardRefExoticComponent<
  React.PropsWithoutRef<RemoteComponentProps> & React.RefAttributes<HTMLDivElement>
>;
```

### RemoteComponentParams

远程组件配置参数：

```tsx
interface RemoteComponentParams<
  T = Record<string, unknown>,
  E extends keyof T = keyof T
> {
  /**
   * 加载远程模块的函数
   * 例如：() => loadRemote('remote1/export-app') 或 () => import('remote1/export-app')
   */
  loader: () => Promise<T>;

  /** 加载远程模块时显示的组件 */
  loading: React.ReactNode;

  /** 加载或渲染远程模块失败时显示的错误组件 */
  fallback: React.ComponentType<{ error: Error }>;

  /**
   * 指定模块导出名称
   * 默认为 'default'
   */
  export?: E;
}
```

### RemoteComponentProps

远程组件属性：

```tsx
interface RemoteComponentProps<T = Record<string, unknown>> {
  /** 传递给远程组件的属性 */
  props?: T;

  /**
   * 内存路由配置，用于将子应用路由作为 memoryRouter 控制
   * 不会直接在浏览器地址栏中显示 URL
   */
  memoryRoute?: { entryPath: string };

  /** 基础路径名 */
  basename?: string;

  /** 样式 */
  style?: React.CSSProperties;

  /** 类名 */
  className?: string;

  /** React 18+ createRoot 选项，会覆盖默认选项 */
  rootOptions?: CreateRootOptions;
}
```

### 使用示例

```tsx
import { createRemoteAppComponent } from '@module-federation/bridge-react';
import { loadRemote } from '@module-federation/runtime';

const RemoteApp = createRemoteAppComponent({
  loader: () => loadRemote('remote1/export-app'),
  loading: <div>Loading...</div>,
  fallback: ({ error }) => <div>Error: {error.message}</div>,
  export: 'default' // 可选，默认为 'default'
});

// 使用组件
<RemoteApp
  basename="/remote1"
  className="remote-app"
  style={{ minHeight: '400px' }}
  props={{ message: 'Hello from host!' }}
  rootOptions={{ // React 18+ 选项
    identifierPrefix: 'remote-',
    onRecoverableError: console.error
  }}
/>
```

## React 18/19 CreateRoot 选项

对于 React 18 和 19，支持传递 `createRoot` 选项：

### CreateRootOptions

```tsx
interface CreateRootOptions {
  /**
   * 可选的字符串前缀，React 用于生成 useId 生成的 id。
   * 用于避免多个根元素之间的冲突。
   */
  identifierPrefix?: string;

  /**
   * 当 React 自动从错误中恢复时调用的可选回调。
   */
  onRecoverableError?: (error: unknown) => void;
}
```

### 配置方式

1. **在 createBridgeComponent 时设置默认选项**：

```tsx
export default createBridgeComponent({
  rootComponent: App,
  defaultRootOptions: {
    identifierPrefix: 'my-app-',
    onRecoverableError: (error) => console.error('可恢复错误:', error)
  }
});
```

2. **在使用 RemoteApp 时覆盖选项**：

```tsx
<RemoteApp
  rootOptions={{
    identifierPrefix: 'instance-',
    onRecoverableError: (error) => console.error('实例错误:', error)
  }}
/>
```

渲染时传递的 `rootOptions` 将覆盖创建组件时设置的 `defaultRootOptions`。

## createLazyComponent

`createLazyComponent` 是通过运行时插件提供的高级 API，用于组件级的懒加载。

:::info 前置条件
使用 `createLazyComponent` 需要先注册 `lazyLoadComponentPlugin` 插件。
:::

### 注册插件

```tsx
import { getInstance } from '@module-federation/runtime';
import { lazyLoadComponentPlugin } from '@module-federation/bridge-react';

// 注册插件
const instance = getInstance();
instance.registerPlugins([lazyLoadComponentPlugin()]);
```

### API 签名

```tsx
/**
 * 创建懒加载组件
 * @param options - 懒加载组件配置选项
 * @returns 返回一个 React 组件
 */
function createLazyComponent<T>(
  options: LazyComponentOptions<T>
): React.ComponentType<T>;
```

### LazyComponentOptions

```tsx
interface LazyComponentOptions<T = Record<string, unknown>> {
  /**
   * 加载远程模块的函数
   * 例如：() => loadRemote('remote/component') 或 () => import('remote/component')
   */
  loader: () => Promise<{ default: React.ComponentType<T> } | React.ComponentType<T>>;

  /** 加载时显示的组件 */
  loading?: React.ReactNode;

  /** 加载失败时显示的错误组件 */
  fallback?: React.ComponentType<{ error: Error }>;

  /** 
   * 指定模块导出名称
   * 默认为 'default'
   */
  export?: string;
}
```

### 使用示例

```tsx
import { getInstance } from '@module-federation/runtime';
import { lazyLoadComponentPlugin } from '@module-federation/bridge-react';
import { loadRemote } from '@module-federation/runtime';

// 1. 注册插件
const instance = getInstance();
instance.registerPlugins([lazyLoadComponentPlugin()]);

// 2. 创建懒加载组件
const LazyButton = instance.createLazyComponent({
  loader: () => loadRemote('remote/Button'),
  loading: <div>Loading Button...</div>,
  fallback: ({ error }) => <div>Failed to load: {error.message}</div>,
});

const LazyHeader = instance.createLazyComponent({
  loader: () => loadRemote('remote/components'),
  export: 'Header', // 使用命名导出
  loading: <div>Loading Header...</div>,
  fallback: ({ error }) => <div>Error: {error.message}</div>,
});

// 3. 使用组件
function App() {
  return (
    <div>
      <LazyHeader title="My App" />
      <LazyButton onClick={() => console.log('clicked')}>
        Click me
      </LazyButton>
    </div>
  );
}
```

### 与 createRemoteAppComponent 的区别

| 特性 | createLazyComponent | createRemoteAppComponent |
|------|-------------------|------------------------|
| **用途** | 组件级懒加载 | 应用级懒加载 |
| **路由处理** | 不处理路由 | 自动处理 basename 和路由上下文 |
| **注册要求** | 需要注册运行时插件 | 无需注册插件 |
| **适用场景** | 加载单个组件 | 加载整个应用或应用片段 |
| **错误边界** | 需要手动处理 | 内置错误处理 |

### 最佳实践

1. **错误处理**：
```tsx
const MyComponent = instance.createLazyComponent({
  loader: () => loadRemote('remote/Component'),
  fallback: ({ error }) => {
    console.error('Component load failed:', error);
    return <div>组件加载失败，请稍后重试</div>;
  },
});
```

2. **数据预取优化**：
```tsx
// 可以结合 prefetch 进行数据预取
instance.prefetch({ 
  id: 'remote/Component',
  preloadComponentResource: true 
});

const MyComponent = instance.createLazyComponent({
  loader: () => loadRemote('remote/Component'),
});
```

3. **TypeScript 支持**：
```tsx
interface ButtonProps {
  children: React.ReactNode;
  onClick: () => void;
}

const LazyButton = instance.createLazyComponent<ButtonProps>({
  loader: () => loadRemote('remote/Button'),
  loading: <div>Loading...</div>,
});
```