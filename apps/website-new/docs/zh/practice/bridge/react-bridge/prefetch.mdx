# 预加载优化

React Bridge 内置了强大的预加载（prefetch）能力，帮助您优化远程应用和组件的加载性能，提升用户体验。

## 预加载概述

预加载功能允许您在用户实际需要之前就开始加载远程资源，从而减少用户等待时间。React Bridge 支持以下类型的预加载：

- **远程应用预加载** - 提前加载整个远程应用
- **远程组件预加载** - 提前加载单个远程组件  
- **依赖资源预加载** - 预加载 CSS、JS 等静态资源
- **智能预加载策略** - 基于用户行为的预测性加载

## 基本用法

### 应用级别预加载

使用 `loadRemote` 函数可以预加载远程应用：

```tsx
import { loadRemote } from '@module-federation/runtime';

// 预加载远程应用
const preloadRemoteApp = async () => {
  try {
    await loadRemote('remote1/export-app');
    console.log('远程应用预加载完成');
  } catch (error) {
    console.error('预加载失败:', error);
  }
};

// 在组件挂载时预加载
useEffect(() => {
  preloadRemoteApp();
}, []);
```

### 组件级别预加载

```tsx
import { createRemoteAppComponent } from '@module-federation/bridge-react';
import { loadRemote } from '@module-federation/runtime';

// 创建远程组件
const RemoteComponent = createRemoteAppComponent({
  loader: () => loadRemote('remote1/component'),
  loading: <div>Loading...</div>,
  fallback: ({ error }) => <div>Error: {error.message}</div>,
});

// 预加载函数
const preloadComponent = () => {
  // 预加载不会触发实际渲染，只是加载资源
  loadRemote('remote1/component').catch(console.error);
};

function App() {
  return (
    <div>
      {/* 用户悬停时预加载 */}
      <button onMouseEnter={preloadComponent}>
        加载远程组件
      </button>
      
      <Suspense fallback={<div>Loading...</div>}>
        <RemoteComponent />
      </Suspense>
    </div>
  );
}
```

## 预加载策略

### 1. 路由导航预加载

在用户即将导航到某个页面时预加载：

```tsx
import { Link } from 'react-router-dom';
import { loadRemote } from '@module-federation/runtime';

const Navigation = () => {
  const preloadRemotePage = (remoteName: string) => {
    return () => {
      loadRemote(remoteName).catch(console.error);
    };
  };

  return (
    <nav>
      <Link 
        to="/remote1"
        onMouseEnter={preloadRemotePage('remote1/export-app')}
        onFocus={preloadRemotePage('remote1/export-app')}
      >
        远程应用 1
      </Link>
      
      <Link 
        to="/remote2"
        onMouseEnter={preloadRemotePage('remote2/export-app')}
        onFocus={preloadRemotePage('remote2/export-app')}
      >
        远程应用 2
      </Link>
    </nav>
  );
};
```

### 2. 可视区域预加载

使用 Intersection Observer 在组件即将进入可视区域时预加载：

```tsx
import { useEffect, useRef } from 'react';
import { loadRemote } from '@module-federation/runtime';

const LazySection = ({ remoteName, children }) => {
  const sectionRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            // 进入可视区域时预加载
            loadRemote(remoteName).catch(console.error);
            observer.unobserve(entry.target);
          }
        });
      },
      { rootMargin: '100px' } // 提前 100px 开始预加载
    );

    if (sectionRef.current) {
      observer.observe(sectionRef.current);
    }

    return () => observer.disconnect();
  }, [remoteName]);

  return (
    <div ref={sectionRef}>
      {children}
    </div>
  );
};
```

### 3. 时间延迟预加载

在页面加载完成后延迟预加载：

```tsx
import { useEffect } from 'react';
import { loadRemote } from '@module-federation/runtime';

const App = () => {
  useEffect(() => {
    // 页面加载完成后 2 秒开始预加载
    const timer = setTimeout(() => {
      const remoteApps = [
        'remote1/export-app',
        'remote2/export-app',
        'remote3/component'
      ];

      remoteApps.forEach(remoteName => {
        loadRemote(remoteName).catch(console.error);
      });
    }, 2000);

    return () => clearTimeout(timer);
  }, []);

  return (
    <div>
      {/* 主应用内容 */}
    </div>
  );
};
```

## 预加载缓存

React Bridge 会自动缓存已加载的远程模块，避免重复加载：

```tsx
import { loadRemote } from '@module-federation/runtime';

// 第一次调用会实际加载
const module1 = await loadRemote('remote1/export-app');

// 第二次调用会使用缓存
const module2 = await loadRemote('remote1/export-app'); // 从缓存获取

console.log(module1 === module2); // true
```

## 错误处理

预加载过程中的错误处理：

```tsx
const preloadWithErrorHandling = async (remoteName: string) => {
  try {
    await loadRemote(remoteName);
    console.log(`${remoteName} 预加载成功`);
  } catch (error) {
    // 预加载失败不应该影响主应用功能
    console.warn(`${remoteName} 预加载失败:`, error);
    
    // 可以选择重试
    setTimeout(() => {
      loadRemote(remoteName).catch(() => {
        console.warn(`${remoteName} 重试预加载也失败`);
      });
    }, 5000);
  }
};
```

## 性能监控

监控预加载的效果：

```tsx
const preloadWithMetrics = async (remoteName: string) => {
  const startTime = performance.now();
  
  try {
    await loadRemote(remoteName);
    const loadTime = performance.now() - startTime;
    
    console.log(`${remoteName} 预加载耗时: ${loadTime.toFixed(2)}ms`);
    
    // 发送性能数据到分析服务
    analytics.track('remote_prefetch_success', {
      remoteName,
      loadTime,
      timestamp: Date.now()
    });
  } catch (error) {
    analytics.track('remote_prefetch_error', {
      remoteName,
      error: error.message,
      timestamp: Date.now()
    });
  }
};
```

## 最佳实践

### 1. 合理的预加载时机

- **用户意图明确时**：如悬停在链接上
- **空闲时间**：如页面加载完成后
- **预测性加载**：基于用户行为模式

### 2. 避免过度预加载

```tsx
// ❌ 不推荐：同时预加载太多资源
const preloadAll = () => {
  const remotes = Array.from({ length: 20 }, (_, i) => `remote${i}/app`);  
  remotes.forEach(remote => loadRemote(remote));
};

// ✅ 推荐：优先级预加载
const preloadByPriority = () => {
  // 高优先级：用户最可能访问的
  loadRemote('popular-remote/app');
  
  // 低优先级：延迟预加载
  setTimeout(() => {
    loadRemote('less-used-remote/app');
  }, 3000);
};
```

### 3. 网络状况感知

```tsx
const preloadWithNetworkAwareness = (remoteName: string) => {
  // 只在网络条件好时预加载
  if (navigator.connection) {
    const { effectiveType, saveData } = navigator.connection;
    
    if (saveData || effectiveType === 'slow-2g' || effectiveType === '2g') {
      console.log('网络条件较差，跳过预加载');
      return;
    }
  }
  
  loadRemote(remoteName).catch(console.error);
};
```

## 与运行时插件结合

对于更高级的预加载功能，可以结合运行时插件使用：

```tsx
import { getInstance } from '@module-federation/runtime';

const runtime = getInstance();

// 使用运行时插件的预加载功能
runtime.preloadRemote('remote1/export-app').then(() => {
  console.log('预加载完成');
});
```

详细的运行时插件功能请参考：[运行时文档](/zh/guide/basic/runtime/runtime)

通过合理使用这些预加载功能，您可以显著提升应用的性能和用户体验。记住，预加载是一个优化手段，应该根据实际使用场景和用户行为来制定合适的策略。
