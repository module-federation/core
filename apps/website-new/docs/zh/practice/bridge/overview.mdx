# Bridge 介绍

## 什么是 Bridge？

`Bridge` 是 Module Federation 提供的跨框架应用级模块加载解决方案。它专门设计用于处理"应用级别模块"的导出、加载和渲染——这些模块不仅包含组件，还具备完整的应用框架渲染能力和路由系统。

通过 Bridge，您可以：
- **跨框架集成**：在 React 应用中加载 Vue 应用，或反之
- **路由协同**：确保不同应用间的路由能够无缝协作
- **应用级复用**：将整个应用或应用片段作为模块进行共享

这些能力使 Bridge 成为构建大型微前端架构的核心工具。

## 支持的框架

### React Bridge (`@module-federation/bridge-react`)

专为 React 应用设计的 Bridge 工具包，支持 React 16-19 的所有版本。

#### 核心 API

**`createBridgeComponent`**
- 用途：将 React 应用包装为可远程加载的模块
- 适用场景：当您希望将 React 应用作为模块导出给其他应用使用时

**`createRemoteAppComponent`** 
- 用途：在宿主应用中加载和渲染远程 React 应用
- 特性：自动创建渲染上下文，处理路由集成和生命周期管理

**`createLazyComponent`**
- 用途：组件级的懒加载，需要配合运行时插件使用
- 优势：更细粒度的加载控制和性能优化

#### 实践示例
- [宿主应用示例](https://github.com/module-federation/core/tree/main/apps/router-demo/router-host-2000)
- [远程应用示例](https://github.com/module-federation/core/tree/main/apps/router-demo/router-remote2-2002)

### Vue Bridge (`@module-federation/bridge-vue3`)

专为 Vue 3 应用设计的 Bridge 工具包。

#### 核心 API

**`createBridgeComponent`**
- 用途：将 Vue 3 应用包装为可远程加载的模块
- 支持：完整的 Vue 3 生态系统集成

**`createRemoteAppComponent`**
- 用途：在 Vue 应用中加载其他框架的应用模块
- 特性：自动处理 Vue 3 的组合式 API 和响应式系统

## 常见问题

### 为什么需要 Bridge？

Bridge 解决了微前端架构中的两个核心挑战：

1. **跨框架兼容性** 
   - 不同团队可以使用不同的前端框架（React、Vue 等）
   - 应用间可以相互集成，无需统一技术栈

2. **路由系统协同**
   - 支持加载带有复杂路由的应用模块
   - 确保宿主应用和远程应用的路由能够协调工作
   - 支持嵌套路由和动态路由场景

这些能力是构建大型、可扩展微前端系统的关键基础设施。

### 如何扩展到其他框架？

目前官方提供了 React 和 Vue 3 的 Bridge 实现。如果您需要其他框架的支持：

1. **提交需求**：通过 [GitHub Issues](https://github.com/module-federation/core/issues) 告诉我们您的需求
2. **参考实现**：查看现有的 [Bridge 实现](https://github.com/module-federation/core/blob/main/packages/bridge/bridge-react) 来了解如何开发
3. **贡献代码**：欢迎为社区贡献新的框架支持

### Bridge 的实现原理

Bridge 的核心思想很简单：基于 DOM 的渲染抽象。以下是简化的实现原理：

#### 导出端（远程应用）

```tsx
export default function createProvider() {
  const rootMap = new Map<HTMLElement, ReactDOM.Root>();
  
  return {
    // 渲染应用到指定 DOM 节点
    render(info: { 
      dom: HTMLElement; 
      basename?: string; 
      memoryRoute?: { entryPath: string; }
    }) {
      const root = ReactDOM.createRoot(info.dom);
      rootMap.set(info.dom, root);
      
      root.render(
        <BrowserRouter basename={info.basename}>
          <App />
        </BrowserRouter>
      );
    },
    
    // 清理资源
    destroy(info: { dom: HTMLElement }) {
      const root = rootMap.get(info.dom);
      root?.unmount();
      rootMap.delete(info.dom);
    },
  }
}
```

#### 消费端（宿主应用）

```tsx
const RemoteApp = React.lazy(async () => {
  // 加载远程模块
  const module = await loadRemote('remote1/export-app');
  const provider = module.default;
  
  return {
    default: () => {
      const containerRef = useRef<HTMLDivElement>(null);
      const providerRef = useRef<any>(null);

      useEffect(() => {
        if (containerRef.current) {
          // 创建 provider 实例
          const instance = provider();
          providerRef.current = instance;
          
          // 渲染远程应用
          instance.render({
            dom: containerRef.current,
            basename: '/remote-app'
          });
        }

        // 清理函数
        return () => {
          if (providerRef.current && containerRef.current) {
            providerRef.current.destroy({
              dom: containerRef.current
            });
          }
        };
      }, []);

      return <div ref={containerRef} />;
    }
  };
});

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <RemoteApp />
    </Suspense>
  );
}
```

通过这种模式，Bridge 实现了框架无关的应用级模块加载，为微前端架构提供了坚实的技术基础。

