{"version":3,"sources":["../../../src/server/app-render/collect-segment-data.tsx"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  InitialRSCPayload,\n  Segment as FlightRouterStateSegment,\n  DynamicParamTypesShort,\n} from './types'\nimport type { ManifestNode } from '../../build/webpack/plugins/flight-manifest-plugin'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream } from 'react-server-dom-webpack/client.edge'\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { unstable_prerender as prerender } from 'react-server-dom-webpack/static.edge'\n\nimport {\n  streamFromBuffer,\n  streamToBuffer,\n} from '../stream-utils/node-web-streams-helper'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  encodeChildSegmentKey,\n  encodeSegment,\n  ROOT_SEGMENT_KEY,\n  type EncodedSegment,\n} from '../../shared/lib/segment-cache/segment-value-encoding'\nimport { getDigestForWellKnownError } from './create-error-handler'\nimport type { FallbackRouteParams } from '../request/fallback-params'\n\n// Contains metadata about the route tree. The client must fetch this before\n// it can fetch any actual segment data.\nexport type RootTreePrefetch = {\n  buildId: string\n  tree: TreePrefetch\n  head: HeadData\n  isHeadPartial: boolean\n  staleTime: number\n}\n\nexport type TreePrefetch = {\n  // The segment, in the format expected by a FlightRouterState.\n  segment: FlightRouterStateSegment\n\n  // Child segments.\n  slots: null | {\n    [parallelRouteKey: string]: TreePrefetch\n  }\n\n  // Extra fields that only exist so we can reconstruct a FlightRouterState on\n  // the client. We may be able to unify TreePrefetch and FlightRouterState\n  // after some refactoring, but in the meantime it would be wasteful to add a\n  // bunch of new prefetch-only fields to FlightRouterState. So think of\n  // TreePrefetch as a superset of FlightRouterState.\n  isRootLayout: boolean\n}\n\nexport type SegmentPrefetch = {\n  buildId: string\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n}\n\nfunction onSegmentPrerenderError(error: unknown) {\n  const digest = getDigestForWellKnownError(error)\n  if (digest) {\n    return digest\n  }\n  // We don't need to log the errors because we would have already done that\n  // when generating the original Flight stream for the whole page.\n}\n\nexport async function collectSegmentData(\n  shouldAssumePartialData: boolean,\n  fullPageDataBuffer: Buffer,\n  staleTime: number,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any,\n  fallbackRouteParams: FallbackRouteParams | null\n): Promise<Map<string, Buffer>> {\n  // Traverse the router tree and generate a prefetch response for each segment.\n\n  // A mutable map to collect the results as we traverse the route tree.\n  const resultMap = new Map<string, Buffer>()\n\n  // Before we start, warm up the module cache by decoding the page data once.\n  // Then we can assume that any remaining async tasks that occur the next time\n  // are due to hanging promises caused by dynamic data access. Note we only\n  // have to do this once per page, not per individual segment.\n  //\n  try {\n    await createFromReadableStream(streamFromBuffer(fullPageDataBuffer), {\n      serverConsumerManifest,\n    })\n    await waitAtLeastOneReactRenderTask()\n  } catch {}\n\n  // Create an abort controller that we'll use to stop the stream.\n  const abortController = new AbortController()\n  const onCompletedProcessingRouteTree = async () => {\n    // Since all we're doing is decoding and re-encoding a cached prerender, if\n    // serializing the stream takes longer than a microtask, it must because of\n    // hanging promises caused by dynamic data.\n    await waitAtLeastOneReactRenderTask()\n    abortController.abort()\n  }\n\n  // Generate a stream for the route tree prefetch. While we're walking the\n  // tree, we'll also spawn additional tasks to generate the segment prefetches.\n  // The promises for these tasks are pushed to a mutable array that we will\n  // await once the route tree is fully rendered.\n  const segmentTasks: Array<Promise<[string, Buffer]>> = []\n  const { prelude: treeStream } = await prerender(\n    // RootTreePrefetch is not a valid return type for a React component, but\n    // we need to use a component so that when we decode the original stream\n    // inside of it, the side effects are transferred to the new stream.\n    // @ts-expect-error\n    <PrefetchTreeData\n      shouldAssumePartialData={shouldAssumePartialData}\n      fullPageDataBuffer={fullPageDataBuffer}\n      fallbackRouteParams={fallbackRouteParams}\n      serverConsumerManifest={serverConsumerManifest}\n      clientModules={clientModules}\n      staleTime={staleTime}\n      segmentTasks={segmentTasks}\n      onCompletedProcessingRouteTree={onCompletedProcessingRouteTree}\n    />,\n    clientModules,\n    {\n      signal: abortController.signal,\n      onError: onSegmentPrerenderError,\n    }\n  )\n\n  // Write the route tree to a special `/_tree` segment.\n  const treeBuffer = await streamToBuffer(treeStream)\n  resultMap.set('/_tree', treeBuffer)\n\n  // Now that we've finished rendering the route tree, all the segment tasks\n  // should have been spawned. Await them in parallel and write the segment\n  // prefetches to the result map.\n  for (const [segmentPath, buffer] of await Promise.all(segmentTasks)) {\n    resultMap.set(segmentPath, buffer)\n  }\n\n  return resultMap\n}\n\nasync function PrefetchTreeData({\n  shouldAssumePartialData,\n  fullPageDataBuffer,\n  fallbackRouteParams,\n  serverConsumerManifest,\n  clientModules,\n  staleTime,\n  segmentTasks,\n  onCompletedProcessingRouteTree,\n}: {\n  shouldAssumePartialData: boolean\n  fullPageDataBuffer: Buffer\n  serverConsumerManifest: any\n  fallbackRouteParams: FallbackRouteParams | null\n  clientModules: ManifestNode\n  staleTime: number\n  segmentTasks: Array<Promise<[string, Buffer]>>\n  onCompletedProcessingRouteTree: () => void\n}): Promise<RootTreePrefetch | null> {\n  // We're currently rendering a Flight response for the route tree prefetch.\n  // Inside this component, decode the Flight stream for the whole page. This is\n  // a hack to transfer the side effects from the original Flight stream (e.g.\n  // Float preloads) onto the Flight stream for the tree prefetch.\n  // TODO: React needs a better way to do this. Needed for Server Actions, too.\n  const initialRSCPayload: InitialRSCPayload = await createFromReadableStream(\n    createUnclosingPrefetchStream(streamFromBuffer(fullPageDataBuffer)),\n    {\n      serverConsumerManifest,\n    }\n  )\n\n  const buildId = initialRSCPayload.b\n\n  // FlightDataPath is an unsound type, hence the additional checks.\n  const flightDataPaths = initialRSCPayload.f\n  if (flightDataPaths.length !== 1 && flightDataPaths[0].length !== 3) {\n    console.error(\n      'Internal Next.js error: InitialRSCPayload does not match the expected ' +\n        'shape for a prerendered page during segment prefetch generation.'\n    )\n    return null\n  }\n  const flightRouterState: FlightRouterState = flightDataPaths[0][0]\n  const seedData: CacheNodeSeedData = flightDataPaths[0][1]\n  const head: HeadData = flightDataPaths[0][2]\n\n  // Compute the route metadata tree by traversing the FlightRouterState. As we\n  // walk the tree, we will also spawn a task to produce a prefetch response for\n  // each segment.\n  const tree = collectSegmentDataImpl(\n    shouldAssumePartialData,\n    flightRouterState,\n    buildId,\n    seedData,\n    fallbackRouteParams,\n    fullPageDataBuffer,\n    clientModules,\n    serverConsumerManifest,\n    ROOT_SEGMENT_KEY,\n    segmentTasks\n  )\n\n  const isHeadPartial =\n    shouldAssumePartialData || (await isPartialRSCData(head, clientModules))\n\n  // Notify the abort controller that we're done processing the route tree.\n  // Anything async that happens after this point must be due to hanging\n  // promises in the original stream.\n  onCompletedProcessingRouteTree()\n\n  // Render the route tree to a special `/_tree` segment.\n  const treePrefetch: RootTreePrefetch = {\n    buildId,\n    tree,\n    head,\n    isHeadPartial,\n    staleTime,\n  }\n  return treePrefetch\n}\n\nfunction collectSegmentDataImpl(\n  shouldAssumePartialData: boolean,\n  route: FlightRouterState,\n  buildId: string,\n  seedData: CacheNodeSeedData | null,\n  fallbackRouteParams: FallbackRouteParams | null,\n  fullPageDataBuffer: Buffer,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any,\n  key: string,\n  segmentTasks: Array<Promise<[string, Buffer]>>\n): TreePrefetch {\n  // Metadata about the segment. Sent as part of the tree prefetch. Null if\n  // there are no children.\n  let slotMetadata: { [parallelRouteKey: string]: TreePrefetch } | null = null\n\n  const children = route[1]\n  const seedDataChildren = seedData !== null ? seedData[2] : null\n  for (const parallelRouteKey in children) {\n    const childRoute = children[parallelRouteKey]\n    const childSegment = childRoute[0]\n    const childSeedData =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n\n    const childKey = encodeChildSegmentKey(\n      key,\n      parallelRouteKey,\n      Array.isArray(childSegment) && fallbackRouteParams !== null\n        ? encodeSegmentWithPossibleFallbackParam(\n            childSegment,\n            fallbackRouteParams\n          )\n        : encodeSegment(childSegment)\n    )\n    const childTree = collectSegmentDataImpl(\n      shouldAssumePartialData,\n      childRoute,\n      buildId,\n      childSeedData,\n      fallbackRouteParams,\n      fullPageDataBuffer,\n      clientModules,\n      serverConsumerManifest,\n      childKey,\n      segmentTasks\n    )\n    if (slotMetadata === null) {\n      slotMetadata = {}\n    }\n    slotMetadata[parallelRouteKey] = childTree\n  }\n\n  if (seedData !== null) {\n    // Spawn a task to write the segment data to a new Flight stream.\n    segmentTasks.push(\n      // Since we're already in the middle of a render, wait until after the\n      // current task to escape the current rendering context.\n      waitAtLeastOneReactRenderTask().then(() =>\n        renderSegmentPrefetch(\n          shouldAssumePartialData,\n          buildId,\n          seedData,\n          key,\n          clientModules\n        )\n      )\n    )\n  } else {\n    // This segment does not have any seed data. Skip generating a prefetch\n    // response for it. We'll still include it in the route tree, though.\n    // TODO: We should encode in the route tree whether a segment is missing\n    // so we don't attempt to fetch it for no reason. As of now this shouldn't\n    // ever happen in practice, though.\n  }\n\n  // Metadata about the segment. Sent to the client as part of the\n  // tree prefetch.\n  return {\n    segment: route[0],\n    slots: slotMetadata,\n    isRootLayout: route[4] === true,\n  }\n}\n\nfunction encodeSegmentWithPossibleFallbackParam(\n  segment: [string, string, DynamicParamTypesShort],\n  fallbackRouteParams: FallbackRouteParams\n): EncodedSegment {\n  const name = segment[0]\n  if (!fallbackRouteParams.has(name)) {\n    // Normal case. No matching fallback parameter.\n    return encodeSegment(segment)\n  }\n  // This segment includes a fallback parameter. During prerendering, a random\n  // placeholder value was used; however, for segment prefetches, we need the\n  // segment path to be predictable so the server can create a rewrite for it.\n  // So, replace the placeholder segment value with a \"template\" string,\n  // e.g. `[name]`.\n  // TODO: This will become a bit cleaner once remove route parameters from the\n  // server response, and instead add them to the segment keys on the client.\n  // Instead of a string replacement, like we do here, route params will always\n  // be encoded in separate step from the rest of the segment, not just in the\n  // case of fallback params.\n  const encodedSegment = encodeSegment(segment)\n  const lastIndex = encodedSegment.lastIndexOf('$')\n  const encodedFallbackSegment =\n    // NOTE: This is guaranteed not to clash with the rest of the segment\n    // because non-simple characters (including [ and ]) trigger a base\n    // 64 encoding.\n    encodedSegment.substring(0, lastIndex + 1) + `[${name}]`\n  return encodedFallbackSegment as EncodedSegment\n}\n\nasync function renderSegmentPrefetch(\n  shouldAssumePartialData: boolean,\n  buildId: string,\n  seedData: CacheNodeSeedData,\n  key: string,\n  clientModules: ManifestNode\n): Promise<[string, Buffer]> {\n  // Render the segment data to a stream.\n  // In the future, this is where we can include additional metadata, like the\n  // stale time and cache tags.\n  const rsc = seedData[1]\n  const loading = seedData[3]\n  const segmentPrefetch: SegmentPrefetch = {\n    buildId,\n    rsc,\n    loading,\n    isPartial:\n      shouldAssumePartialData || (await isPartialRSCData(rsc, clientModules)),\n  }\n  // Since all we're doing is decoding and re-encoding a cached prerender, if\n  // it takes longer than a microtask, it must because of hanging promises\n  // caused by dynamic data. Abort the stream at the end of the current task.\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => abortController.abort())\n  const { prelude: segmentStream } = await prerender(\n    segmentPrefetch,\n    clientModules,\n    {\n      signal: abortController.signal,\n      onError: onSegmentPrerenderError,\n    }\n  )\n  const segmentBuffer = await streamToBuffer(segmentStream)\n  if (key === ROOT_SEGMENT_KEY) {\n    return ['/_index', segmentBuffer]\n  } else {\n    return [key, segmentBuffer]\n  }\n}\n\nasync function isPartialRSCData(\n  rsc: React.ReactNode,\n  clientModules: ManifestNode\n): Promise<boolean> {\n  // We can determine if a segment contains only partial data if it takes longer\n  // than a task to encode, because dynamic data is encoded as an infinite\n  // promise. We must do this in a separate Flight prerender from the one that\n  // actually generates the prefetch stream because we need to include\n  // `isPartial` in the stream itself.\n  let isPartial = false\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => {\n    // If we haven't yet finished the outer task, then it must be because we\n    // accessed dynamic data.\n    isPartial = true\n    abortController.abort()\n  })\n  await prerender(rsc, clientModules, {\n    signal: abortController.signal,\n    onError() {},\n  })\n  return isPartial\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["createFromReadableStream","unstable_prerender","prerender","streamFromBuffer","streamToBuffer","waitAtLeastOneReactRenderTask","encodeChildSegmentKey","encodeSegment","ROOT_SEGMENT_KEY","getDigestForWellKnownError","onSegmentPrerenderError","error","digest","collectSegmentData","shouldAssumePartialData","fullPageDataBuffer","staleTime","clientModules","serverConsumerManifest","fallbackRouteParams","resultMap","Map","abortController","AbortController","onCompletedProcessingRouteTree","abort","segmentTasks","prelude","treeStream","PrefetchTreeData","signal","onError","treeBuffer","set","segmentPath","buffer","Promise","all","initialRSCPayload","createUnclosingPrefetchStream","buildId","b","flightDataPaths","f","length","console","flightRouterState","seedData","head","tree","collectSegmentDataImpl","isHeadPartial","isPartialRSCData","treePrefetch","route","key","slotMetadata","children","seedDataChildren","parallelRouteKey","childRoute","childSegment","childSeedData","childKey","Array","isArray","encodeSegmentWithPossibleFallbackParam","childTree","push","then","renderSegmentPrefetch","segment","slots","isRootLayout","name","has","encodedSegment","lastIndex","lastIndexOf","encodedFallbackSegment","substring","rsc","loading","segmentPrefetch","isPartial","segmentStream","segmentBuffer","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"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"}