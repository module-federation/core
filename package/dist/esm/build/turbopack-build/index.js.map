{"version":3,"sources":["../../../src/build/turbopack-build/index.ts"],"sourcesContent":["import path from 'path'\nimport {\n  formatNodeOptions,\n  getParsedNodeOptionsWithoutInspect,\n} from '../../server/lib/utils'\nimport { Worker } from '../../lib/worker'\nimport { NextBuildContext } from '../build-context'\n\nasync function turbopackBuildWithWorker() {\n  const nodeOptions = getParsedNodeOptionsWithoutInspect()\n\n  try {\n    const worker = new Worker(path.join(__dirname, 'impl.js'), {\n      exposedMethods: ['workerMain', 'waitForShutdown'],\n      numWorkers: 1,\n      maxRetries: 0,\n      forkOptions: {\n        env: {\n          ...process.env,\n          NEXT_PRIVATE_BUILD_WORKER: '1',\n          NODE_OPTIONS: formatNodeOptions(nodeOptions),\n        },\n      },\n    }) as Worker & typeof import('./impl')\n    const { nextBuildSpan, ...prunedBuildContext } = NextBuildContext\n    const result = await worker.workerMain({\n      buildContext: prunedBuildContext,\n    })\n\n    // destroy worker when Turbopack has shutdown so it's not sticking around using memory\n    // We need to wait for shutdown to make sure persistent cache is flushed\n    result.shutdownPromise = worker.waitForShutdown().then(() => {\n      worker.end()\n    })\n\n    return result\n  } catch (err: any) {\n    // When the error is a serialized `Error` object we need to recreate the `Error` instance\n    // in order to keep the consistent error reporting behavior.\n    if (err.type === 'Error') {\n      const error = new Error(err.message)\n      if (err.name) {\n        error.name = err.name\n      }\n      if (err.cause) {\n        error.cause = err.cause\n      }\n      error.message = err.message\n      error.stack = err.stack\n      throw error\n    }\n    throw err\n  }\n}\n\nexport function turbopackBuild(\n  withWorker: boolean\n): ReturnType<typeof import('./impl').turbopackBuild> {\n  if (withWorker) {\n    return turbopackBuildWithWorker()\n  } else {\n    const build = (require('./impl') as typeof import('./impl')).turbopackBuild\n    return build()\n  }\n}\n"],"names":["path","formatNodeOptions","getParsedNodeOptionsWithoutInspect","Worker","NextBuildContext","turbopackBuildWithWorker","nodeOptions","worker","join","__dirname","exposedMethods","numWorkers","maxRetries","forkOptions","env","process","NEXT_PRIVATE_BUILD_WORKER","NODE_OPTIONS","nextBuildSpan","prunedBuildContext","result","workerMain","buildContext","shutdownPromise","waitForShutdown","then","end","err","type","error","Error","message","name","cause","stack","turbopackBuild","withWorker","build","require"],"mappings":"AAAA,OAAOA,UAAU,OAAM;AACvB,SACEC,iBAAiB,EACjBC,kCAAkC,QAC7B,yBAAwB;AAC/B,SAASC,MAAM,QAAQ,mBAAkB;AACzC,SAASC,gBAAgB,QAAQ,mBAAkB;AAEnD,eAAeC;IACb,MAAMC,cAAcJ;IAEpB,IAAI;QACF,MAAMK,SAAS,IAAIJ,OAAOH,KAAKQ,IAAI,CAACC,WAAW,YAAY;YACzDC,gBAAgB;gBAAC;gBAAc;aAAkB;YACjDC,YAAY;YACZC,YAAY;YACZC,aAAa;gBACXC,KAAK;oBACH,GAAGC,QAAQD,GAAG;oBACdE,2BAA2B;oBAC3BC,cAAchB,kBAAkBK;gBAClC;YACF;QACF;QACA,MAAM,EAAEY,aAAa,EAAE,GAAGC,oBAAoB,GAAGf;QACjD,MAAMgB,SAAS,MAAMb,OAAOc,UAAU,CAAC;YACrCC,cAAcH;QAChB;QAEA,sFAAsF;QACtF,wEAAwE;QACxEC,OAAOG,eAAe,GAAGhB,OAAOiB,eAAe,GAAGC,IAAI,CAAC;YACrDlB,OAAOmB,GAAG;QACZ;QAEA,OAAON;IACT,EAAE,OAAOO,KAAU;QACjB,yFAAyF;QACzF,4DAA4D;QAC5D,IAAIA,IAAIC,IAAI,KAAK,SAAS;YACxB,MAAMC,QAAQ,qBAAsB,CAAtB,IAAIC,MAAMH,IAAII,OAAO,GAArB,qBAAA;uBAAA;4BAAA;8BAAA;YAAqB;YACnC,IAAIJ,IAAIK,IAAI,EAAE;gBACZH,MAAMG,IAAI,GAAGL,IAAIK,IAAI;YACvB;YACA,IAAIL,IAAIM,KAAK,EAAE;gBACbJ,MAAMI,KAAK,GAAGN,IAAIM,KAAK;YACzB;YACAJ,MAAME,OAAO,GAAGJ,IAAII,OAAO;YAC3BF,MAAMK,KAAK,GAAGP,IAAIO,KAAK;YACvB,MAAML;QACR;QACA,MAAMF;IACR;AACF;AAEA,OAAO,SAASQ,eACdC,UAAmB;IAEnB,IAAIA,YAAY;QACd,OAAO/B;IACT,OAAO;QACL,MAAMgC,QAAQ,AAACC,QAAQ,UAAsCH,cAAc;QAC3E,OAAOE;IACT;AACF"}