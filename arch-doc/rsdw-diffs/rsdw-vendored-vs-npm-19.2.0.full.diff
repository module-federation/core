diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.browser.development.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.browser.development.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js	2025-12-17 14:32:43
@@ -8,8 +8,8 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
+'use strict';
+'production' !== process.env.NODE_ENV &&
   (function () {
     function resolveClientReference(bundlerConfig, metadata) {
       if (bundlerConfig) {
@@ -17,12 +17,12 @@
         if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))
           moduleExports = bundlerConfig.name;
         else {
-          bundlerConfig = moduleExports && moduleExports["*"];
+          bundlerConfig = moduleExports && moduleExports['*'];
           if (!bundlerConfig)
             throw Error(
               'Could not find the module "' +
                 metadata[0] +
-                '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'
+                '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.',
             );
           moduleExports = metadata[2];
         }
@@ -33,11 +33,11 @@
       return metadata;
     }
     function resolveServerReference(bundlerConfig, id) {
-      var name = "",
+      var name = '',
         resolvedModuleData = bundlerConfig[id];
       if (resolvedModuleData) name = resolvedModuleData.name;
       else {
-        var idx = id.lastIndexOf("#");
+        var idx = id.lastIndexOf('#');
         -1 !== idx &&
           ((name = id.slice(idx + 1)),
           (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -45,7 +45,7 @@
           throw Error(
             'Could not find the module "' +
               id +
-              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
           );
       }
       return resolvedModuleData.async
@@ -54,17 +54,17 @@
     }
     function requireAsyncModule(id) {
       var promise = __webpack_require__(id);
-      if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+      if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
         return null;
       promise.then(
         function (value) {
-          promise.status = "fulfilled";
+          promise.status = 'fulfilled';
           promise.value = value;
         },
         function (reason) {
-          promise.status = "rejected";
+          promise.status = 'rejected';
           promise.reason = reason;
-        }
+        },
       );
       return promise;
     }
@@ -98,13 +98,13 @@
     }
     function requireModule(metadata) {
       var moduleExports = __webpack_require__(metadata[0]);
-      if (4 === metadata.length && "function" === typeof moduleExports.then)
-        if ("fulfilled" === moduleExports.status)
+      if (4 === metadata.length && 'function' === typeof moduleExports.then)
+        if ('fulfilled' === moduleExports.status)
           moduleExports = moduleExports.value;
         else throw moduleExports.reason;
-      return "*" === metadata[2]
+      return '*' === metadata[2]
         ? moduleExports
-        : "" === metadata[2]
+        : '' === metadata[2]
           ? moduleExports.__esModule
             ? moduleExports.default
             : moduleExports
@@ -115,12 +115,12 @@
       return __webpack_chunk_load__(chunkId);
     }
     function getIteratorFn(maybeIterable) {
-      if (null === maybeIterable || "object" !== typeof maybeIterable)
+      if (null === maybeIterable || 'object' !== typeof maybeIterable)
         return null;
       maybeIterable =
         (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-        maybeIterable["@@iterator"];
-      return "function" === typeof maybeIterable ? maybeIterable : null;
+        maybeIterable['@@iterator'];
+      return 'function' === typeof maybeIterable ? maybeIterable : null;
     }
     function isObjectPrototype(object) {
       if (!object) return !1;
@@ -143,8 +143,8 @@
         if (
           !descriptor ||
           (!descriptor.enumerable &&
-            (("key" !== names[i] && "ref" !== names[i]) ||
-              "function" !== typeof descriptor.get))
+            (('key' !== names[i] && 'ref' !== names[i]) ||
+              'function' !== typeof descriptor.get))
         )
           return !1;
       }
@@ -160,35 +160,35 @@
     }
     function describeValueForErrorMessage(value) {
       switch (typeof value) {
-        case "string":
+        case 'string':
           return JSON.stringify(
-            10 >= value.length ? value : value.slice(0, 10) + "..."
+            10 >= value.length ? value : value.slice(0, 10) + '...',
           );
-        case "object":
-          if (isArrayImpl(value)) return "[...]";
+        case 'object':
+          if (isArrayImpl(value)) return '[...]';
           if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-            return "client";
+            return 'client';
           value = objectName(value);
-          return "Object" === value ? "{...}" : value;
-        case "function":
+          return 'Object' === value ? '{...}' : value;
+        case 'function':
           return value.$$typeof === CLIENT_REFERENCE_TAG
-            ? "client"
+            ? 'client'
             : (value = value.displayName || value.name)
-              ? "function " + value
-              : "function";
+              ? 'function ' + value
+              : 'function';
         default:
           return String(value);
       }
     }
     function describeElementType(type) {
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (type.$$typeof) {
           case REACT_FORWARD_REF_TYPE:
             return describeElementType(type.render);
@@ -201,74 +201,74 @@
               return describeElementType(type(payload));
             } catch (x) {}
         }
-      return "";
+      return '';
     }
     function describeObjectForErrorMessage(objectOrArray, expandedName) {
       var objKind = objectName(objectOrArray);
-      if ("Object" !== objKind && "Array" !== objKind) return objKind;
+      if ('Object' !== objKind && 'Array' !== objKind) return objKind;
       var start = -1,
         length = 0;
       if (isArrayImpl(objectOrArray))
         if (jsxChildrenParents.has(objectOrArray)) {
           var type = jsxChildrenParents.get(objectOrArray);
-          objKind = "<" + describeElementType(type) + ">";
+          objKind = '<' + describeElementType(type) + '>';
           for (var i = 0; i < objectOrArray.length; i++) {
             var value = objectOrArray[i];
             value =
-              "string" === typeof value
+              'string' === typeof value
                 ? value
-                : "object" === typeof value && null !== value
-                  ? "{" + describeObjectForErrorMessage(value) + "}"
-                  : "{" + describeValueForErrorMessage(value) + "}";
-            "" + i === expandedName
+                : 'object' === typeof value && null !== value
+                  ? '{' + describeObjectForErrorMessage(value) + '}'
+                  : '{' + describeValueForErrorMessage(value) + '}';
+            '' + i === expandedName
               ? ((start = objKind.length),
                 (length = value.length),
                 (objKind += value))
               : (objKind =
                   15 > value.length && 40 > objKind.length + value.length
                     ? objKind + value
-                    : objKind + "{...}");
+                    : objKind + '{...}');
           }
-          objKind += "</" + describeElementType(type) + ">";
+          objKind += '</' + describeElementType(type) + '>';
         } else {
-          objKind = "[";
+          objKind = '[';
           for (type = 0; type < objectOrArray.length; type++)
-            0 < type && (objKind += ", "),
+            0 < type && (objKind += ', '),
               (i = objectOrArray[type]),
               (i =
-                "object" === typeof i && null !== i
+                'object' === typeof i && null !== i
                   ? describeObjectForErrorMessage(i)
                   : describeValueForErrorMessage(i)),
-              "" + type === expandedName
+              '' + type === expandedName
                 ? ((start = objKind.length),
                   (length = i.length),
                   (objKind += i))
                 : (objKind =
                     10 > i.length && 40 > objKind.length + i.length
                       ? objKind + i
-                      : objKind + "...");
-          objKind += "]";
+                      : objKind + '...');
+          objKind += ']';
         }
       else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-        objKind = "<" + describeElementType(objectOrArray.type) + "/>";
+        objKind = '<' + describeElementType(objectOrArray.type) + '/>';
       else {
-        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
         if (jsxPropsParents.has(objectOrArray)) {
           objKind = jsxPropsParents.get(objectOrArray);
-          objKind = "<" + (describeElementType(objKind) || "...");
+          objKind = '<' + (describeElementType(objKind) || '...');
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++) {
-            objKind += " ";
+            objKind += ' ';
             value = type[i];
-            objKind += describeKeyForErrorMessage(value) + "=";
+            objKind += describeKeyForErrorMessage(value) + '=';
             var _value2 = objectOrArray[value];
             var _substr2 =
               value === expandedName &&
-              "object" === typeof _value2 &&
+              'object' === typeof _value2 &&
               null !== _value2
                 ? describeObjectForErrorMessage(_value2)
                 : describeValueForErrorMessage(_value2);
-            "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
+            'string' !== typeof _value2 && (_substr2 = '{' + _substr2 + '}');
             value === expandedName
               ? ((start = objKind.length),
                 (length = _substr2.length),
@@ -276,19 +276,19 @@
               : (objKind =
                   10 > _substr2.length && 40 > objKind.length + _substr2.length
                     ? objKind + _substr2
-                    : objKind + "...");
+                    : objKind + '...');
           }
-          objKind += ">";
+          objKind += '>';
         } else {
-          objKind = "{";
+          objKind = '{';
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++)
-            0 < i && (objKind += ", "),
+            0 < i && (objKind += ', '),
               (value = type[i]),
-              (objKind += describeKeyForErrorMessage(value) + ": "),
+              (objKind += describeKeyForErrorMessage(value) + ': '),
               (_value2 = objectOrArray[value]),
               (_value2 =
-                "object" === typeof _value2 && null !== _value2
+                'object' === typeof _value2 && null !== _value2
                   ? describeObjectForErrorMessage(_value2)
                   : describeValueForErrorMessage(_value2)),
               value === expandedName
@@ -298,47 +298,47 @@
                 : (objKind =
                     10 > _value2.length && 40 > objKind.length + _value2.length
                       ? objKind + _value2
-                      : objKind + "...");
-          objKind += "}";
+                      : objKind + '...');
+          objKind += '}';
         }
       }
       return void 0 === expandedName
         ? objKind
         : -1 < start && 0 < length
-          ? ((objectOrArray = " ".repeat(start) + "^".repeat(length)),
-            "\n  " + objKind + "\n  " + objectOrArray)
-          : "\n  " + objKind;
+          ? ((objectOrArray = ' '.repeat(start) + '^'.repeat(length)),
+            '\n  ' + objKind + '\n  ' + objectOrArray)
+          : '\n  ' + objKind;
     }
     function serializeNumber(number) {
       return Number.isFinite(number)
         ? 0 === number && -Infinity === 1 / number
-          ? "$-0"
+          ? '$-0'
           : number
         : Infinity === number
-          ? "$Infinity"
+          ? '$Infinity'
           : -Infinity === number
-            ? "$-Infinity"
-            : "$NaN";
+            ? '$-Infinity'
+            : '$NaN';
     }
     function processReply(
       root,
       formFieldPrefix,
       temporaryReferences,
       resolve,
-      reject
+      reject,
     ) {
       function serializeTypedArray(tag, typedArray) {
         typedArray = new Blob([
           new Uint8Array(
             typedArray.buffer,
             typedArray.byteOffset,
-            typedArray.byteLength
-          )
+            typedArray.byteLength,
+          ),
         ]);
         var blobId = nextPartId++;
         null === formData && (formData = new FormData());
         formData.append(formFieldPrefix + blobId, typedArray);
-        return "$" + tag + blobId.toString(16);
+        return '$' + tag + blobId.toString(16);
       }
       function serializeBinaryReader(reader) {
         function progress(entry) {
@@ -347,9 +347,9 @@
               data.append(formFieldPrefix + entry, new Blob(buffer)),
               data.append(
                 formFieldPrefix + streamId,
-                '"$o' + entry.toString(16) + '"'
+                '"$o' + entry.toString(16) + '"',
               ),
-              data.append(formFieldPrefix + streamId, "C"),
+              data.append(formFieldPrefix + streamId, 'C'),
               pendingParts--,
               0 === pendingParts && resolve(data))
             : (buffer.push(entry.value),
@@ -361,12 +361,12 @@
         var streamId = nextPartId++,
           buffer = [];
         reader.read(new Uint8Array(1024)).then(progress, reject);
-        return "$r" + streamId.toString(16);
+        return '$r' + streamId.toString(16);
       }
       function serializeReader(reader) {
         function progress(entry) {
           if (entry.done)
-            data.append(formFieldPrefix + streamId, "C"),
+            data.append(formFieldPrefix + streamId, 'C'),
               pendingParts--,
               0 === pendingParts && resolve(data);
           else
@@ -383,11 +383,11 @@
         pendingParts++;
         var streamId = nextPartId++;
         reader.read().then(progress, reject);
-        return "$R" + streamId.toString(16);
+        return '$R' + streamId.toString(16);
       }
       function serializeReadableStream(stream) {
         try {
-          var binaryReader = stream.getReader({ mode: "byob" });
+          var binaryReader = stream.getReader({ mode: 'byob' });
         } catch (x) {
           return serializeReader(stream.getReader());
         }
@@ -397,11 +397,11 @@
         function progress(entry) {
           if (entry.done) {
             if (void 0 === entry.value)
-              data.append(formFieldPrefix + streamId, "C");
+              data.append(formFieldPrefix + streamId, 'C');
             else
               try {
                 var partJSON = JSON.stringify(entry.value, resolveToJSON);
-                data.append(formFieldPrefix + streamId, "C" + partJSON);
+                data.append(formFieldPrefix + streamId, 'C' + partJSON);
               } catch (x) {
                 reject(x);
                 return;
@@ -423,38 +423,38 @@
         var streamId = nextPartId++;
         iterable = iterable === iterator;
         iterator.next().then(progress, reject);
-        return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+        return '$' + (iterable ? 'x' : 'X') + streamId.toString(16);
       }
       function resolveToJSON(key, value) {
         var originalValue = this[key];
-        "object" !== typeof originalValue ||
+        'object' !== typeof originalValue ||
           originalValue === value ||
           originalValue instanceof Date ||
-          ("Object" !== objectName(originalValue)
+          ('Object' !== objectName(originalValue)
             ? console.error(
-                "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                'Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s',
                 objectName(originalValue),
-                describeObjectForErrorMessage(this, key)
+                describeObjectForErrorMessage(this, key),
               )
             : console.error(
-                "Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s",
-                describeObjectForErrorMessage(this, key)
+                'Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s',
+                describeObjectForErrorMessage(this, key),
               ));
         if (null === value) return null;
-        if ("object" === typeof value) {
+        if ('object' === typeof value) {
           switch (value.$$typeof) {
             case REACT_ELEMENT_TYPE:
-              if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+              if (void 0 !== temporaryReferences && -1 === key.indexOf(':')) {
                 var parentReference = writtenObjects.get(this);
                 if (void 0 !== parentReference)
                   return (
-                    temporaryReferences.set(parentReference + ":" + key, value),
-                    "$T"
+                    temporaryReferences.set(parentReference + ':' + key, value),
+                    '$T'
                   );
               }
               throw Error(
-                "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
-                  describeObjectForErrorMessage(this, key)
+                'React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.' +
+                  describeObjectForErrorMessage(this, key),
               );
             case REACT_LAZY_TYPE:
               originalValue = value._payload;
@@ -466,12 +466,12 @@
                 var lazyId = nextPartId++,
                   partJSON = serializeModel(parentReference, lazyId);
                 formData.append(formFieldPrefix + lazyId, partJSON);
-                return "$" + lazyId.toString(16);
+                return '$' + lazyId.toString(16);
               } catch (x) {
                 if (
-                  "object" === typeof x &&
+                  'object' === typeof x &&
                   null !== x &&
-                  "function" === typeof x.then
+                  'function' === typeof x.then
                 ) {
                   pendingParts++;
                   var _lazyId = nextPartId++;
@@ -487,7 +487,7 @@
                     }
                   };
                   x.then(parentReference, parentReference);
-                  return "$" + _lazyId.toString(16);
+                  return '$' + _lazyId.toString(16);
                 }
                 reject(x);
                 return null;
@@ -495,7 +495,7 @@
                 pendingParts--;
               }
           }
-          if ("function" === typeof value.then) {
+          if ('function' === typeof value.then) {
             null === formData && (formData = new FormData());
             pendingParts++;
             var promiseId = nextPartId++;
@@ -510,17 +510,17 @@
                 reject(reason);
               }
             }, reject);
-            return "$@" + promiseId.toString(16);
+            return '$@' + promiseId.toString(16);
           }
           parentReference = writtenObjects.get(value);
           if (void 0 !== parentReference)
             if (modelRoot === value) modelRoot = null;
             else return parentReference;
           else
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
               ((parentReference = writtenObjects.get(this)),
               void 0 !== parentReference &&
-                ((parentReference = parentReference + ":" + key),
+                ((parentReference = parentReference + ':' + key),
                 writtenObjects.set(value, parentReference),
                 void 0 !== temporaryReferences &&
                   temporaryReferences.set(parentReference, value)));
@@ -529,11 +529,11 @@
             null === formData && (formData = new FormData());
             var _data3 = formData;
             key = nextPartId++;
-            var prefix = formFieldPrefix + key + "_";
+            var prefix = formFieldPrefix + key + '_';
             value.forEach(function (originalValue, originalKey) {
               _data3.append(prefix + originalKey, originalValue);
             });
-            return "$K" + key.toString(16);
+            return '$K' + key.toString(16);
           }
           if (value instanceof Map)
             return (
@@ -541,7 +541,7 @@
               (parentReference = serializeModel(Array.from(value), key)),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$Q" + key.toString(16)
+              '$Q' + key.toString(16)
             );
           if (value instanceof Set)
             return (
@@ -549,7 +549,7 @@
               (parentReference = serializeModel(Array.from(value), key)),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$W" + key.toString(16)
+              '$W' + key.toString(16)
             );
           if (value instanceof ArrayBuffer)
             return (
@@ -557,37 +557,37 @@
               (parentReference = nextPartId++),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + parentReference, key),
-              "$A" + parentReference.toString(16)
+              '$A' + parentReference.toString(16)
             );
           if (value instanceof Int8Array)
-            return serializeTypedArray("O", value);
+            return serializeTypedArray('O', value);
           if (value instanceof Uint8Array)
-            return serializeTypedArray("o", value);
+            return serializeTypedArray('o', value);
           if (value instanceof Uint8ClampedArray)
-            return serializeTypedArray("U", value);
+            return serializeTypedArray('U', value);
           if (value instanceof Int16Array)
-            return serializeTypedArray("S", value);
+            return serializeTypedArray('S', value);
           if (value instanceof Uint16Array)
-            return serializeTypedArray("s", value);
+            return serializeTypedArray('s', value);
           if (value instanceof Int32Array)
-            return serializeTypedArray("L", value);
+            return serializeTypedArray('L', value);
           if (value instanceof Uint32Array)
-            return serializeTypedArray("l", value);
+            return serializeTypedArray('l', value);
           if (value instanceof Float32Array)
-            return serializeTypedArray("G", value);
+            return serializeTypedArray('G', value);
           if (value instanceof Float64Array)
-            return serializeTypedArray("g", value);
+            return serializeTypedArray('g', value);
           if (value instanceof BigInt64Array)
-            return serializeTypedArray("M", value);
+            return serializeTypedArray('M', value);
           if (value instanceof BigUint64Array)
-            return serializeTypedArray("m", value);
-          if (value instanceof DataView) return serializeTypedArray("V", value);
-          if ("function" === typeof Blob && value instanceof Blob)
+            return serializeTypedArray('m', value);
+          if (value instanceof DataView) return serializeTypedArray('V', value);
+          if ('function' === typeof Blob && value instanceof Blob)
             return (
               null === formData && (formData = new FormData()),
               (key = nextPartId++),
               formData.append(formFieldPrefix + key, value),
-              "$B" + key.toString(16)
+              '$B' + key.toString(16)
             );
           if ((parentReference = getIteratorFn(value)))
             return (
@@ -596,20 +596,20 @@
                 ? ((key = nextPartId++),
                   (parentReference = serializeModel(
                     Array.from(parentReference),
-                    key
+                    key,
                   )),
                   null === formData && (formData = new FormData()),
                   formData.append(formFieldPrefix + key, parentReference),
-                  "$i" + key.toString(16))
+                  '$i' + key.toString(16))
                 : Array.from(parentReference)
             );
           if (
-            "function" === typeof ReadableStream &&
+            'function' === typeof ReadableStream &&
             value instanceof ReadableStream
           )
             return serializeReadableStream(value);
           parentReference = value[ASYNC_ITERATOR];
-          if ("function" === typeof parentReference)
+          if ('function' === typeof parentReference)
             return serializeAsyncIterable(value, parentReference.call(value));
           parentReference = getPrototypeOf(value);
           if (
@@ -619,98 +619,98 @@
           ) {
             if (void 0 === temporaryReferences)
               throw Error(
-                "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported." +
-                  describeObjectForErrorMessage(this, key)
+                'Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.' +
+                  describeObjectForErrorMessage(this, key),
               );
-            return "$T";
+            return '$T';
           }
           value.$$typeof === REACT_CONTEXT_TYPE
             ? console.error(
-                "React Context Providers cannot be passed to Server Functions from the Client.%s",
-                describeObjectForErrorMessage(this, key)
+                'React Context Providers cannot be passed to Server Functions from the Client.%s',
+                describeObjectForErrorMessage(this, key),
               )
-            : "Object" !== objectName(value)
+            : 'Object' !== objectName(value)
               ? console.error(
-                  "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                  'Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s',
                   objectName(value),
-                  describeObjectForErrorMessage(this, key)
+                  describeObjectForErrorMessage(this, key),
                 )
               : isSimpleObject(value)
                 ? Object.getOwnPropertySymbols &&
                   ((parentReference = Object.getOwnPropertySymbols(value)),
                   0 < parentReference.length &&
                     console.error(
-                      "Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s",
+                      'Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s',
                       parentReference[0].description,
-                      describeObjectForErrorMessage(this, key)
+                      describeObjectForErrorMessage(this, key),
                     ))
                 : console.error(
-                    "Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s",
-                    describeObjectForErrorMessage(this, key)
+                    'Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s',
+                    describeObjectForErrorMessage(this, key),
                   );
           return value;
         }
-        if ("string" === typeof value) {
-          if ("Z" === value[value.length - 1] && this[key] instanceof Date)
-            return "$D" + value;
-          key = "$" === value[0] ? "$" + value : value;
+        if ('string' === typeof value) {
+          if ('Z' === value[value.length - 1] && this[key] instanceof Date)
+            return '$D' + value;
+          key = '$' === value[0] ? '$' + value : value;
           return key;
         }
-        if ("boolean" === typeof value) return value;
-        if ("number" === typeof value) return serializeNumber(value);
-        if ("undefined" === typeof value) return "$undefined";
-        if ("function" === typeof value) {
+        if ('boolean' === typeof value) return value;
+        if ('number' === typeof value) return serializeNumber(value);
+        if ('undefined' === typeof value) return '$undefined';
+        if ('function' === typeof value) {
           parentReference = knownServerReferences.get(value);
           if (void 0 !== parentReference)
             return (
               (key = JSON.stringify(
                 { id: parentReference.id, bound: parentReference.bound },
-                resolveToJSON
+                resolveToJSON,
               )),
               null === formData && (formData = new FormData()),
               (parentReference = nextPartId++),
               formData.set(formFieldPrefix + parentReference, key),
-              "$F" + parentReference.toString(16)
+              '$F' + parentReference.toString(16)
             );
           if (
             void 0 !== temporaryReferences &&
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
             ((parentReference = writtenObjects.get(this)),
             void 0 !== parentReference)
           )
             return (
-              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+              temporaryReferences.set(parentReference + ':' + key, value), '$T'
             );
           throw Error(
-            "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+            'Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.',
           );
         }
-        if ("symbol" === typeof value) {
+        if ('symbol' === typeof value) {
           if (
             void 0 !== temporaryReferences &&
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
             ((parentReference = writtenObjects.get(this)),
             void 0 !== parentReference)
           )
             return (
-              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+              temporaryReferences.set(parentReference + ':' + key, value), '$T'
             );
           throw Error(
-            "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
-              describeObjectForErrorMessage(this, key)
+            'Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.' +
+              describeObjectForErrorMessage(this, key),
           );
         }
-        if ("bigint" === typeof value) return "$n" + value.toString(10);
+        if ('bigint' === typeof value) return '$n' + value.toString(10);
         throw Error(
-          "Type " +
+          'Type ' +
             typeof value +
-            " is not supported as an argument to a Server Function."
+            ' is not supported as an argument to a Server Function.',
         );
       }
       function serializeModel(model, id) {
-        "object" === typeof model &&
+        'object' === typeof model &&
           null !== model &&
-          ((id = "$" + id.toString(16)),
+          ((id = '$' + id.toString(16)),
           writtenObjects.set(model, id),
           void 0 !== temporaryReferences && temporaryReferences.set(id, model));
         modelRoot = model;
@@ -724,7 +724,7 @@
         json = serializeModel(root, 0);
       null === formData
         ? resolve(json)
-        : (formData.set(formFieldPrefix + "0", json),
+        : (formData.set(formFieldPrefix + '0', json),
           0 === pendingParts && resolve(formData));
       return function () {
         0 < pendingParts &&
@@ -739,36 +739,36 @@
       line,
       col,
       environmentName,
-      innerFunction
+      innerFunction,
     ) {
-      name || (name = "<anonymous>");
+      name || (name = '<anonymous>');
       var encodedName = JSON.stringify(name);
       1 >= line
         ? ((line = encodedName.length + 7),
           (col =
-            "s=>({" +
+            's=>({' +
             encodedName +
-            " ".repeat(col < line ? 0 : col - line) +
-            ":(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */"))
+            ' '.repeat(col < line ? 0 : col - line) +
+            ':(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */'))
         : (col =
-            "/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */" +
-            "\n".repeat(line - 2) +
-            "server=>({" +
+            '/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */' +
+            '\n'.repeat(line - 2) +
+            'server=>({' +
             encodedName +
-            ":\n" +
-            " ".repeat(1 > col ? 0 : col - 1) +
-            "(...args) => server(...args)})");
-      filename.startsWith("/") && (filename = "file://" + filename);
+            ':\n' +
+            ' '.repeat(1 > col ? 0 : col - 1) +
+            '(...args) => server(...args)})');
+      filename.startsWith('/') && (filename = 'file://' + filename);
       sourceMap
         ? ((col +=
-            "\n//# sourceURL=about://React/" +
+            '\n//# sourceURL=about://React/' +
             encodeURIComponent(environmentName) +
-            "/" +
+            '/' +
             encodeURI(filename) +
-            "?s" +
+            '?s' +
             fakeServerFunctionIdx++),
-          (col += "\n//# sourceMappingURL=" + sourceMap))
-        : filename && (col += "\n//# sourceURL=" + filename);
+          (col += '\n//# sourceMappingURL=' + sourceMap))
+        : filename && (col += '\n//# sourceURL=' + filename);
       try {
         return (0, eval)(col)(innerFunction)[name];
       } catch (x) {
@@ -780,19 +780,19 @@
         knownServerReferences.set(reference, {
           id: id,
           originalBind: reference.bind,
-          bound: bound
+          bound: bound,
         });
     }
     function createBoundServerReference(
       metaData,
       callServer,
       encodeFormAction,
-      findSourceMapURL
+      findSourceMapURL,
     ) {
       function action() {
         var args = Array.prototype.slice.call(arguments);
         return bound
-          ? "fulfilled" === bound.status
+          ? 'fulfilled' === bound.status
             ? callServer(id, bound.value.concat(args))
             : Promise.resolve(bound).then(function (boundArgs) {
                 return callServer(id, boundArgs.concat(args));
@@ -803,11 +803,11 @@
         bound = metaData.bound,
         location = metaData.location;
       if (location) {
-        encodeFormAction = metaData.name || "";
+        encodeFormAction = metaData.name || '';
         var filename = location[1],
           line = location[2];
         location = location[3];
-        metaData = metaData.env || "Server";
+        metaData = metaData.env || 'Server';
         findSourceMapURL =
           null == findSourceMapURL
             ? null
@@ -819,7 +819,7 @@
           line,
           location,
           metaData,
-          action
+          action,
         );
       }
       registerBoundServerReference(action, id, bound);
@@ -827,11 +827,11 @@
     }
     function parseStackLocation(error) {
       error = error.stack;
-      error.startsWith("Error: react-stack-top-frame\n") &&
+      error.startsWith('Error: react-stack-top-frame\n') &&
         (error = error.slice(29));
-      var endOfFirst = error.indexOf("\n");
+      var endOfFirst = error.indexOf('\n');
       if (-1 !== endOfFirst) {
-        var endOfSecond = error.indexOf("\n", endOfFirst + 1);
+        var endOfSecond = error.indexOf('\n', endOfFirst + 1);
         endOfFirst =
           -1 === endOfSecond
             ? error.slice(endOfFirst + 1)
@@ -843,65 +843,65 @@
         ((error = jscSpiderMonkeyFrameRegExp.exec(endOfFirst)), !error)
       )
         return null;
-      endOfFirst = error[1] || "";
-      "<anonymous>" === endOfFirst && (endOfFirst = "");
-      endOfSecond = error[2] || error[5] || "";
-      "<anonymous>" === endOfSecond && (endOfSecond = "");
+      endOfFirst = error[1] || '';
+      '<anonymous>' === endOfFirst && (endOfFirst = '');
+      endOfSecond = error[2] || error[5] || '';
+      '<anonymous>' === endOfSecond && (endOfSecond = '');
       return [
         endOfFirst,
         endOfSecond,
         +(error[3] || error[6]),
-        +(error[4] || error[7])
+        +(error[4] || error[7]),
       ];
     }
     function getComponentNameFromType(type) {
       if (null == type) return null;
-      if ("function" === typeof type)
+      if ('function' === typeof type)
         return type.$$typeof === REACT_CLIENT_REFERENCE
           ? null
           : type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_FRAGMENT_TYPE:
-          return "Fragment";
+          return 'Fragment';
         case REACT_PROFILER_TYPE:
-          return "Profiler";
+          return 'Profiler';
         case REACT_STRICT_MODE_TYPE:
-          return "StrictMode";
+          return 'StrictMode';
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
         case REACT_ACTIVITY_TYPE:
-          return "Activity";
+          return 'Activity';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (
-          ("number" === typeof type.tag &&
+          ('number' === typeof type.tag &&
             console.error(
-              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
+              'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.',
             ),
           type.$$typeof)
         ) {
           case REACT_PORTAL_TYPE:
-            return "Portal";
+            return 'Portal';
           case REACT_CONTEXT_TYPE:
-            return type.displayName || "Context";
+            return type.displayName || 'Context';
           case REACT_CONSUMER_TYPE:
-            return (type._context.displayName || "Context") + ".Consumer";
+            return (type._context.displayName || 'Context') + '.Consumer';
           case REACT_FORWARD_REF_TYPE:
             var innerType = type.render;
             type = type.displayName;
             type ||
-              ((type = innerType.displayName || innerType.name || ""),
-              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
+              ((type = innerType.displayName || innerType.name || ''),
+              (type = '' !== type ? 'ForwardRef(' + type + ')' : 'ForwardRef'));
             return type;
           case REACT_MEMO_TYPE:
             return (
               (innerType = type.displayName || null),
               null !== innerType
                 ? innerType
-                : getComponentNameFromType(type.type) || "Memo"
+                : getComponentNameFromType(type.type) || 'Memo'
             );
           case REACT_LAZY_TYPE:
             innerType = type._payload;
@@ -915,19 +915,19 @@
     function getArrayKind(array) {
       for (var kind = 0, i = 0; i < array.length; i++) {
         var value = array[i];
-        if ("object" === typeof value && null !== value)
+        if ('object' === typeof value && null !== value)
           if (
             isArrayImpl(value) &&
             2 === value.length &&
-            "string" === typeof value[0]
+            'string' === typeof value[0]
           ) {
             if (0 !== kind && 3 !== kind) return 1;
             kind = 3;
           } else return 1;
         else {
           if (
-            "function" === typeof value ||
-            ("string" === typeof value && 50 < value.length) ||
+            'function' === typeof value ||
+            ('string' === typeof value && 50 < value.length) ||
             (0 !== kind && 2 !== kind)
           )
             return 1;
@@ -939,7 +939,7 @@
     function addObjectToProperties(object, properties, indent, prefix) {
       for (var key in object)
         hasOwnProperty.call(object, key) &&
-          "_" !== key[0] &&
+          '_' !== key[0] &&
           addValueToProperties(key, object[key], properties, indent, prefix);
     }
     function addValueToProperties(
@@ -947,70 +947,70 @@
       value,
       properties,
       indent,
-      prefix
+      prefix,
     ) {
       switch (typeof value) {
-        case "object":
+        case 'object':
           if (null === value) {
-            value = "null";
+            value = 'null';
             break;
           } else {
             if (value.$$typeof === REACT_ELEMENT_TYPE) {
-              var typeName = getComponentNameFromType(value.type) || "\u2026",
+              var typeName = getComponentNameFromType(value.type) || '\u2026',
                 key = value.key;
               value = value.props;
               var propsKeys = Object.keys(value),
                 propsLength = propsKeys.length;
               if (null == key && 0 === propsLength) {
-                value = "<" + typeName + " />";
+                value = '<' + typeName + ' />';
                 break;
               }
               if (
                 3 > indent ||
                 (1 === propsLength &&
-                  "children" === propsKeys[0] &&
+                  'children' === propsKeys[0] &&
                   null == key)
               ) {
-                value = "<" + typeName + " \u2026 />";
+                value = '<' + typeName + ' \u2026 />';
                 break;
               }
               properties.push([
-                prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-                "<" + typeName
+                prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+                '<' + typeName,
               ]);
               null !== key &&
                 addValueToProperties(
-                  "key",
+                  'key',
                   key,
                   properties,
                   indent + 1,
-                  prefix
+                  prefix,
                 );
               propertyName = !1;
               for (var propKey in value)
-                "children" === propKey
+                'children' === propKey
                   ? null != value.children &&
                     (!isArrayImpl(value.children) ||
                       0 < value.children.length) &&
                     (propertyName = !0)
                   : hasOwnProperty.call(value, propKey) &&
-                    "_" !== propKey[0] &&
+                    '_' !== propKey[0] &&
                     addValueToProperties(
                       propKey,
                       value[propKey],
                       properties,
                       indent + 1,
-                      prefix
+                      prefix,
                     );
               properties.push([
-                "",
-                propertyName ? ">\u2026</" + typeName + ">" : "/>"
+                '',
+                propertyName ? '>\u2026</' + typeName + '>' : '/>',
               ]);
               return;
             }
             typeName = Object.prototype.toString.call(value);
             typeName = typeName.slice(8, typeName.length - 1);
-            if ("Array" === typeName)
+            if ('Array' === typeName)
               if (
                 ((propKey = getArrayKind(value)),
                 2 === propKey || 0 === propKey)
@@ -1019,8 +1019,8 @@
                 break;
               } else if (3 === propKey) {
                 properties.push([
-                  prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-                  ""
+                  prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+                  '',
                 ]);
                 for (
                   propertyName = 0;
@@ -1033,12 +1033,12 @@
                       typeName[1],
                       properties,
                       indent + 1,
-                      prefix
+                      prefix,
                     );
                 return;
               }
-            if ("Promise" === typeName) {
-              if ("fulfilled" === value.status) {
+            if ('Promise' === typeName) {
+              if ('fulfilled' === value.status) {
                 if (
                   ((typeName = properties.length),
                   addValueToProperties(
@@ -1046,189 +1046,189 @@
                     value.value,
                     properties,
                     indent,
-                    prefix
+                    prefix,
                   ),
                   properties.length > typeName)
                 ) {
                   properties = properties[typeName];
                   properties[1] =
-                    "Promise<" + (properties[1] || "Object") + ">";
+                    'Promise<' + (properties[1] || 'Object') + '>';
                   return;
                 }
               } else if (
-                "rejected" === value.status &&
+                'rejected' === value.status &&
                 ((typeName = properties.length),
                 addValueToProperties(
                   propertyName,
                   value.reason,
                   properties,
                   indent,
-                  prefix
+                  prefix,
                 ),
                 properties.length > typeName)
               ) {
                 properties = properties[typeName];
-                properties[1] = "Rejected Promise<" + properties[1] + ">";
+                properties[1] = 'Rejected Promise<' + properties[1] + '>';
                 return;
               }
               properties.push([
-                "\u00a0\u00a0".repeat(indent) + propertyName,
-                "Promise"
+                '\u00a0\u00a0'.repeat(indent) + propertyName,
+                'Promise',
               ]);
               return;
             }
-            "Object" === typeName &&
+            'Object' === typeName &&
               (propKey = Object.getPrototypeOf(value)) &&
-              "function" === typeof propKey.constructor &&
+              'function' === typeof propKey.constructor &&
               (typeName = propKey.constructor.name);
             properties.push([
-              prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-              "Object" === typeName ? (3 > indent ? "" : "\u2026") : typeName
+              prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+              'Object' === typeName ? (3 > indent ? '' : '\u2026') : typeName,
             ]);
             3 > indent &&
               addObjectToProperties(value, properties, indent + 1, prefix);
             return;
           }
-        case "function":
-          value = "" === value.name ? "() => {}" : value.name + "() {}";
+        case 'function':
+          value = '' === value.name ? '() => {}' : value.name + '() {}';
           break;
-        case "string":
+        case 'string':
           value =
-            "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects." ===
+            'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.' ===
             value
-              ? "\u2026"
+              ? '\u2026'
               : JSON.stringify(value);
           break;
-        case "undefined":
-          value = "undefined";
+        case 'undefined':
+          value = 'undefined';
           break;
-        case "boolean":
-          value = value ? "true" : "false";
+        case 'boolean':
+          value = value ? 'true' : 'false';
           break;
         default:
           value = String(value);
       }
       properties.push([
-        prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-        value
+        prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+        value,
       ]);
     }
     function getIODescription(value) {
       try {
         switch (typeof value) {
-          case "object":
-            if (null === value) return "";
+          case 'object':
+            if (null === value) return '';
             if (value instanceof Error) return String(value.message);
-            if ("string" === typeof value.url) return value.url;
-            if ("string" === typeof value.href) return value.href;
-            if ("string" === typeof value.src) return value.src;
-            if ("string" === typeof value.currentSrc) return value.currentSrc;
-            if ("string" === typeof value.command) return value.command;
+            if ('string' === typeof value.url) return value.url;
+            if ('string' === typeof value.href) return value.href;
+            if ('string' === typeof value.src) return value.src;
+            if ('string' === typeof value.currentSrc) return value.currentSrc;
+            if ('string' === typeof value.command) return value.command;
             if (
-              "object" === typeof value.request &&
+              'object' === typeof value.request &&
               null !== value.request &&
-              "string" === typeof value.request.url
+              'string' === typeof value.request.url
             )
               return value.request.url;
             if (
-              "object" === typeof value.response &&
+              'object' === typeof value.response &&
               null !== value.response &&
-              "string" === typeof value.response.url
+              'string' === typeof value.response.url
             )
               return value.response.url;
             if (
-              "string" === typeof value.id ||
-              "number" === typeof value.id ||
-              "bigint" === typeof value.id
+              'string' === typeof value.id ||
+              'number' === typeof value.id ||
+              'bigint' === typeof value.id
             )
               return String(value.id);
-            if ("string" === typeof value.name) return value.name;
+            if ('string' === typeof value.name) return value.name;
             var str = value.toString();
-            return str.startsWith("[object ") ||
+            return str.startsWith('[object ') ||
               5 > str.length ||
               500 < str.length
-              ? ""
+              ? ''
               : str;
-          case "string":
-            return 5 > value.length || 500 < value.length ? "" : value;
-          case "number":
-          case "bigint":
+          case 'string':
+            return 5 > value.length || 500 < value.length ? '' : value;
+          case 'number':
+          case 'bigint':
             return String(value);
           default:
-            return "";
+            return '';
         }
       } catch (x) {
-        return "";
+        return '';
       }
     }
     function markAllTracksInOrder() {
       supportsUserTiming &&
         (console.timeStamp(
-          "Server Requests Track",
+          'Server Requests Track',
           0.001,
           0.001,
-          "Server Requests \u269b",
+          'Server Requests \u269b',
           void 0,
-          "primary-light"
+          'primary-light',
         ),
         console.timeStamp(
-          "Server Components Track",
+          'Server Components Track',
           0.001,
           0.001,
-          "Primary",
-          "Server Components \u269b",
-          "primary-light"
+          'Primary',
+          'Server Components \u269b',
+          'primary-light',
         ));
     }
     function getIOColor(functionName) {
       switch (functionName.charCodeAt(0) % 3) {
         case 0:
-          return "tertiary-light";
+          return 'tertiary-light';
         case 1:
-          return "tertiary";
+          return 'tertiary';
         default:
-          return "tertiary-dark";
+          return 'tertiary-dark';
       }
     }
     function getIOLongName(ioInfo, description, env, rootEnv) {
       ioInfo = ioInfo.name;
       description =
-        "" === description ? ioInfo : ioInfo + " (" + description + ")";
+        '' === description ? ioInfo : ioInfo + ' (' + description + ')';
       return env === rootEnv || void 0 === env
         ? description
-        : description + " [" + env + "]";
+        : description + ' [' + env + ']';
     }
     function getIOShortName(ioInfo, description, env, rootEnv) {
       ioInfo = ioInfo.name;
-      env = env === rootEnv || void 0 === env ? "" : " [" + env + "]";
-      var desc = "";
+      env = env === rootEnv || void 0 === env ? '' : ' [' + env + ']';
+      var desc = '';
       rootEnv = 30 - ioInfo.length - env.length;
       if (1 < rootEnv) {
         var l = description.length;
-        if (0 < l && l <= rootEnv) desc = " (" + description + ")";
+        if (0 < l && l <= rootEnv) desc = ' (' + description + ')';
         else if (
-          description.startsWith("http://") ||
-          description.startsWith("https://") ||
-          description.startsWith("/")
+          description.startsWith('http://') ||
+          description.startsWith('https://') ||
+          description.startsWith('/')
         ) {
-          var queryIdx = description.indexOf("?");
+          var queryIdx = description.indexOf('?');
           -1 === queryIdx && (queryIdx = description.length);
           47 === description.charCodeAt(queryIdx - 1) && queryIdx--;
-          desc = description.lastIndexOf("/", queryIdx - 1);
+          desc = description.lastIndexOf('/', queryIdx - 1);
           queryIdx - desc < rootEnv
-            ? (desc = " (\u2026" + description.slice(desc, queryIdx) + ")")
+            ? (desc = ' (\u2026' + description.slice(desc, queryIdx) + ')')
             : ((l = description.slice(desc, desc + rootEnv / 2)),
               (description = description.slice(
                 queryIdx - rootEnv / 2,
-                queryIdx
+                queryIdx,
               )),
               (desc =
-                " (" +
-                (0 < desc ? "\u2026" : "") +
+                ' (' +
+                (0 < desc ? '\u2026' : '') +
                 l +
-                "\u2026" +
+                '\u2026' +
                 description +
-                ")"));
+                ')'));
         }
       }
       return ioInfo + desc + env;
@@ -1239,7 +1239,7 @@
       startTime,
       endTime,
       rootEnv,
-      value
+      value,
     ) {
       if (supportsUserTiming && 0 < endTime) {
         var description = getIODescription(value),
@@ -1247,22 +1247,22 @@
             asyncInfo.awaited,
             description,
             asyncInfo.env,
-            rootEnv
+            rootEnv,
           ),
-          entryName = "await " + name;
+          entryName = 'await ' + name;
         name = getIOColor(name);
         var debugTask = asyncInfo.debugTask || asyncInfo.awaited.debugTask;
         if (debugTask) {
           var properties = [];
-          "object" === typeof value && null !== value
-            ? addObjectToProperties(value, properties, 0, "")
+          'object' === typeof value && null !== value
+            ? addObjectToProperties(value, properties, 0, '')
             : void 0 !== value &&
-              addValueToProperties("awaited value", value, properties, 0, "");
+              addValueToProperties('awaited value', value, properties, 0, '');
           asyncInfo = getIOLongName(
             asyncInfo.awaited,
             description,
             asyncInfo.env,
-            rootEnv
+            rootEnv,
           );
           debugTask.run(
             performance.measure.bind(performance, entryName, {
@@ -1272,12 +1272,12 @@
                 devtools: {
                   color: name,
                   track: trackNames[trackIdx],
-                  trackGroup: "Server Components \u269b",
+                  trackGroup: 'Server Components \u269b',
                   properties: properties,
-                  tooltipText: asyncInfo
-                }
-              }
-            })
+                  tooltipText: asyncInfo,
+                },
+              },
+            }),
           );
         } else
           console.timeStamp(
@@ -1285,8 +1285,8 @@
             0 > startTime ? 0 : startTime,
             endTime,
             trackNames[trackIdx],
-            "Server Components \u269b",
-            name
+            'Server Components \u269b',
+            name,
           );
       }
     }
@@ -1300,38 +1300,38 @@
         debugTask
           ? ((error = [
               [
-                "rejected with",
-                "object" === typeof error &&
+                'rejected with',
+                'object' === typeof error &&
                 null !== error &&
-                "string" === typeof error.message
+                'string' === typeof error.message
                   ? String(error.message)
-                  : String(error)
-              ]
+                  : String(error),
+              ],
             ]),
             (ioInfo =
               getIOLongName(ioInfo, description, ioInfo.env, rootEnv) +
-              " Rejected"),
+              ' Rejected'),
             debugTask.run(
-              performance.measure.bind(performance, "\u200b" + entryName, {
+              performance.measure.bind(performance, '\u200b' + entryName, {
                 start: 0 > startTime ? 0 : startTime,
                 end: endTime,
                 detail: {
                   devtools: {
-                    color: "error",
-                    track: "Server Requests \u269b",
+                    color: 'error',
+                    track: 'Server Requests \u269b',
                     properties: error,
-                    tooltipText: ioInfo
-                  }
-                }
-              })
+                    tooltipText: ioInfo,
+                  },
+                },
+              }),
             ))
           : console.timeStamp(
               entryName,
               0 > startTime ? 0 : startTime,
               endTime,
-              "Server Requests \u269b",
+              'Server Requests \u269b',
               void 0,
-              "error"
+              'error',
             );
       }
     }
@@ -1345,33 +1345,33 @@
           debugTask = ioInfo.debugTask;
         if (debugTask) {
           var properties = [];
-          "object" === typeof value && null !== value
-            ? addObjectToProperties(value, properties, 0, "")
+          'object' === typeof value && null !== value
+            ? addObjectToProperties(value, properties, 0, '')
             : void 0 !== value &&
-              addValueToProperties("Resolved", value, properties, 0, "");
+              addValueToProperties('Resolved', value, properties, 0, '');
           ioInfo = getIOLongName(ioInfo, description, ioInfo.env, rootEnv);
           debugTask.run(
-            performance.measure.bind(performance, "\u200b" + entryName, {
+            performance.measure.bind(performance, '\u200b' + entryName, {
               start: 0 > startTime ? 0 : startTime,
               end: endTime,
               detail: {
                 devtools: {
                   color: color,
-                  track: "Server Requests \u269b",
+                  track: 'Server Requests \u269b',
                   properties: properties,
-                  tooltipText: ioInfo
-                }
-              }
-            })
+                  tooltipText: ioInfo,
+                },
+              },
+            }),
           );
         } else
           console.timeStamp(
             entryName,
             0 > startTime ? 0 : startTime,
             endTime,
-            "Server Requests \u269b",
+            'Server Requests \u269b',
             void 0,
-            color
+            color,
           );
       }
     }
@@ -1387,27 +1387,27 @@
       weakResponse = weakResponse.weak.deref();
       if (void 0 === weakResponse)
         throw Error(
-          "We did not expect to receive new data after GC:ing the response."
+          'We did not expect to receive new data after GC:ing the response.',
         );
       return weakResponse;
     }
     function closeDebugChannel(debugChannel) {
-      debugChannel.callback && debugChannel.callback("");
+      debugChannel.callback && debugChannel.callback('');
     }
     function readChunk(chunk) {
       switch (chunk.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(chunk);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(chunk);
       }
       switch (chunk.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return chunk.value;
-        case "pending":
-        case "blocked":
-        case "halted":
+        case 'pending':
+        case 'blocked':
+        case 'halted':
           throw chunk;
         default:
           throw chunk.reason;
@@ -1423,39 +1423,39 @@
         null !== response._pendingInitialRender &&
           (clearTimeout(response._pendingInitialRender),
           (response._pendingInitialRender = null)));
-      return new ReactPromise("pending", null, null);
+      return new ReactPromise('pending', null, null);
     }
     function releasePendingChunk(response, chunk) {
-      "pending" === chunk.status &&
+      'pending' === chunk.status &&
         0 === --response._pendingChunks &&
         ((response._weakResponse.response = null),
         (response._pendingInitialRender = setTimeout(
           flushInitialRenderPerformance.bind(null, response),
-          100
+          100,
         )));
     }
     function moveDebugInfoFromChunkToInnerValue(chunk, value) {
       value = resolveLazy(value);
-      "object" !== typeof value ||
+      'object' !== typeof value ||
         null === value ||
         (!isArrayImpl(value) &&
-          "function" !== typeof value[ASYNC_ITERATOR] &&
+          'function' !== typeof value[ASYNC_ITERATOR] &&
           value.$$typeof !== REACT_ELEMENT_TYPE &&
           value.$$typeof !== REACT_LAZY_TYPE) ||
         ((chunk = chunk._debugInfo.splice(0)),
         isArrayImpl(value._debugInfo)
           ? value._debugInfo.unshift.apply(value._debugInfo, chunk)
-          : Object.defineProperty(value, "_debugInfo", {
+          : Object.defineProperty(value, '_debugInfo', {
               configurable: !1,
               enumerable: !1,
               writable: !0,
-              value: chunk
+              value: chunk,
             }));
     }
     function wakeChunk(listeners, value, chunk) {
       for (var i = 0; i < listeners.length; i++) {
         var listener = listeners[i];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(value)
           : fulfillReference(listener, value, chunk);
       }
@@ -1464,7 +1464,7 @@
     function rejectChunk(listeners, error) {
       for (var i = 0; i < listeners.length; i++) {
         var listener = listeners[i];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(error)
           : rejectReference(listener, error);
       }
@@ -1482,7 +1482,7 @@
         ) {
           var listener = reference[referencedChunk];
           if (
-            "function" !== typeof listener &&
+            'function' !== typeof listener &&
             ((listener = resolveBlockedCycle(resolvedChunk, listener)),
             null !== listener)
           )
@@ -1492,13 +1492,13 @@
     }
     function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
       switch (chunk.status) {
-        case "fulfilled":
+        case 'fulfilled':
           wakeChunk(resolveListeners, chunk.value, chunk);
           break;
-        case "blocked":
+        case 'blocked':
           for (var i = 0; i < resolveListeners.length; i++) {
             var listener = resolveListeners[i];
-            if ("function" !== typeof listener) {
+            if ('function' !== typeof listener) {
               var cyclicHandler = resolveBlockedCycle(chunk, listener);
               null !== cyclicHandler &&
                 (fulfillReference(listener, cyclicHandler.value, chunk),
@@ -1509,7 +1509,7 @@
                   -1 !== listener && rejectListeners.splice(listener, 1)));
             }
           }
-        case "pending":
+        case 'pending':
           if (chunk.value)
             for (i = 0; i < resolveListeners.length; i++)
               chunk.value.push(resolveListeners[i]);
@@ -1524,21 +1524,21 @@
                 chunk.reason.push(rejectListeners[resolveListeners]);
           } else chunk.reason = rejectListeners;
           break;
-        case "rejected":
+        case 'rejected':
           rejectListeners && rejectChunk(rejectListeners, chunk.reason);
       }
     }
     function triggerErrorOnChunk(response, chunk, error) {
-      if ("pending" !== chunk.status && "blocked" !== chunk.status)
+      if ('pending' !== chunk.status && 'blocked' !== chunk.status)
         chunk.reason.error(error);
       else {
         releasePendingChunk(response, chunk);
         var listeners = chunk.reason;
-        if ("pending" === chunk.status && null != chunk._debugChunk) {
+        if ('pending' === chunk.status && null != chunk._debugChunk) {
           var prevHandler = initializingHandler,
             prevChunk = initializingChunk;
           initializingHandler = null;
-          chunk.status = "blocked";
+          chunk.status = 'blocked';
           chunk.value = null;
           chunk.reason = null;
           initializingChunk = chunk;
@@ -1549,21 +1549,21 @@
               (initializingChunk = prevChunk);
           }
         }
-        chunk.status = "rejected";
+        chunk.status = 'rejected';
         chunk.reason = error;
         null !== listeners && rejectChunk(listeners, error);
       }
     }
     function createResolvedModelChunk(response, value) {
-      return new ReactPromise("resolved_model", value, response);
+      return new ReactPromise('resolved_model', value, response);
     }
     function createResolvedIteratorResultChunk(response, value, done) {
       return new ReactPromise(
-        "resolved_model",
+        'resolved_model',
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
-        response
+          '}',
+        response,
       );
     }
     function resolveIteratorResultChunk(response, chunk, value, done) {
@@ -1572,16 +1572,16 @@
         chunk,
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}"
+          '}',
       );
     }
     function resolveModelChunk(response, chunk, value) {
-      if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+      if ('pending' !== chunk.status) chunk.reason.enqueueModel(value);
       else {
         releasePendingChunk(response, chunk);
         var resolveListeners = chunk.value,
           rejectListeners = chunk.reason;
-        chunk.status = "resolved_model";
+        chunk.status = 'resolved_model';
         chunk.value = value;
         chunk.reason = response;
         null !== resolveListeners &&
@@ -1590,11 +1590,11 @@
       }
     }
     function resolveModuleChunk(response, chunk, value) {
-      if ("pending" === chunk.status || "blocked" === chunk.status) {
+      if ('pending' === chunk.status || 'blocked' === chunk.status) {
         releasePendingChunk(response, chunk);
         response = chunk.value;
         var rejectListeners = chunk.reason;
-        chunk.status = "resolved_module";
+        chunk.status = 'resolved_module';
         chunk.value = value;
         value = value[1];
         for (var debugInfo = [], i = 0; i < value.length; ) {
@@ -1612,9 +1612,9 @@
             }
             var end = (ioInfo = -1);
             scriptFilename = 0;
-            if ("function" === typeof performance.getEntriesByType)
+            if ('function' === typeof performance.getEntriesByType)
               for (
-                var resourceEntries = performance.getEntriesByType("resource"),
+                var resourceEntries = performance.getEntriesByType('resource'),
                   i$jscomp$0 = 0;
                 i$jscomp$0 < resourceEntries.length;
                 i$jscomp$0++
@@ -1626,28 +1626,28 @@
                   (scriptFilename = resourceEntry.transferSize || 0));
               }
             resourceEntries = Promise.resolve(href);
-            resourceEntries.status = "fulfilled";
+            resourceEntries.status = 'fulfilled';
             resourceEntries.value = { chunkId: chunkId, href: href };
-            i$jscomp$0 = Error("react-stack-top-frame");
-            i$jscomp$0.stack.startsWith("Error: react-stack-top-frame")
+            i$jscomp$0 = Error('react-stack-top-frame');
+            i$jscomp$0.stack.startsWith('Error: react-stack-top-frame')
               ? (i$jscomp$0.stack =
-                  "Error: react-stack-top-frame\n    at Client Component Bundle (" +
+                  'Error: react-stack-top-frame\n    at Client Component Bundle (' +
                   href +
-                  ":1:1)\n    at Client Component Bundle (" +
+                  ':1:1)\n    at Client Component Bundle (' +
                   href +
-                  ":1:1)")
+                  ':1:1)')
               : (i$jscomp$0.stack =
-                  "Client Component Bundle@" +
+                  'Client Component Bundle@' +
                   href +
-                  ":1:1\nClient Component Bundle@" +
+                  ':1:1\nClient Component Bundle@' +
                   href +
-                  ":1:1");
+                  ':1:1');
             ioInfo = {
-              name: "script",
+              name: 'script',
               start: ioInfo,
               end: end,
               value: resourceEntries,
-              debugStack: i$jscomp$0
+              debugStack: i$jscomp$0,
             };
             0 < scriptFilename && (ioInfo.byteSize = scriptFilename);
             chunkIOInfoCache.set(chunkId, ioInfo);
@@ -1666,31 +1666,31 @@
       if (null !== debugChunk) {
         var debugInfo = chunk._debugInfo;
         try {
-          if ("resolved_model" === debugChunk.status) {
+          if ('resolved_model' === debugChunk.status) {
             for (
               var idx = debugInfo.length, c = debugChunk._debugChunk;
               null !== c;
 
             )
-              "fulfilled" !== c.status && idx++, (c = c._debugChunk);
+              'fulfilled' !== c.status && idx++, (c = c._debugChunk);
             initializeModelChunk(debugChunk);
             switch (debugChunk.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 debugInfo[idx] = initializeDebugInfo(
                   response,
-                  debugChunk.value
+                  debugChunk.value,
                 );
                 break;
-              case "blocked":
-              case "pending":
+              case 'blocked':
+              case 'pending':
                 waitForReference(
                   debugChunk,
                   debugInfo,
-                  "" + idx,
+                  '' + idx,
                   response,
                   initializeDebugInfo,
-                  [""],
-                  !0
+                  [''],
+                  !0,
                 );
                 break;
               default:
@@ -1698,18 +1698,18 @@
             }
           } else
             switch (debugChunk.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 break;
-              case "blocked":
-              case "pending":
+              case 'blocked':
+              case 'pending':
                 waitForReference(
                   debugChunk,
                   {},
-                  "debug",
+                  'debug',
                   response,
                   initializeDebugInfo,
-                  [""],
-                  !0
+                  [''],
+                  !0,
                 );
                 break;
               default:
@@ -1726,7 +1726,7 @@
       initializingHandler = null;
       var resolvedModel = chunk.value,
         response = chunk.reason;
-      chunk.status = "blocked";
+      chunk.status = 'blocked';
       chunk.value = null;
       chunk.reason = null;
       initializingChunk = chunk;
@@ -1741,7 +1741,7 @@
             resolvedModel++
           ) {
             var listener = resolveListeners[resolvedModel];
-            "function" === typeof listener
+            'function' === typeof listener
               ? listener(value)
               : fulfillReference(listener, value, chunk);
           }
@@ -1753,11 +1753,11 @@
             return;
           }
         }
-        chunk.status = "fulfilled";
+        chunk.status = 'fulfilled';
         chunk.value = value;
         moveDebugInfoFromChunkToInnerValue(chunk, value);
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       } finally {
         (initializingHandler = prevHandler), (initializingChunk = prevChunk);
       }
@@ -1765,10 +1765,10 @@
     function initializeModuleChunk(chunk) {
       try {
         var value = requireModule(chunk.value);
-        chunk.status = "fulfilled";
+        chunk.status = 'fulfilled';
         chunk.value = value;
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       }
     }
     function reportGlobalError(weakResponse, error) {
@@ -1777,7 +1777,7 @@
         response._closed = !0;
         response._closedReason = error;
         response._chunks.forEach(function (chunk) {
-          "pending" === chunk.status &&
+          'pending' === chunk.status &&
             triggerErrorOnChunk(response, chunk, error);
         });
         weakResponse = response._debugChannel;
@@ -1792,19 +1792,19 @@
       return null;
     }
     function getTaskName(type) {
-      if (type === REACT_FRAGMENT_TYPE) return "<>";
-      if ("function" === typeof type) return '"use client"';
+      if (type === REACT_FRAGMENT_TYPE) return '<>';
+      if ('function' === typeof type) return '"use client"';
       if (
-        "object" === typeof type &&
+        'object' === typeof type &&
         null !== type &&
         type.$$typeof === REACT_LAZY_TYPE
       )
-        return type._init === readChunk ? '"use client"' : "<...>";
+        return type._init === readChunk ? '"use client"' : '<...>';
       try {
         var name = getComponentNameFromType(type);
-        return name ? "<" + name + ">" : "<...>";
+        return name ? '<' + name + '>' : '<...>';
       } catch (x) {
-        return "<...>";
+        return '<...>';
       }
     }
     function initializeElement(response, element, lazyNode) {
@@ -1820,7 +1820,7 @@
           (normalizedStackTrace = createFakeJSXCallStackInDEV(
             response,
             stack,
-            env
+            env,
           ));
       element._debugStack = normalizedStackTrace;
       normalizedStackTrace = null;
@@ -1828,14 +1828,14 @@
         null !== stack &&
         ((normalizedStackTrace = console.createTask.bind(
           console,
-          getTaskName(element.type)
+          getTaskName(element.type),
         )),
         (stack = buildFakeCallStack(
           response,
           stack,
           env,
           !1,
-          normalizedStackTrace
+          normalizedStackTrace,
         )),
         (env = null === owner ? null : initializeFakeTask(response, owner)),
         null === env
@@ -1849,16 +1849,16 @@
           lazyNode._store.validated &&
           !element._store.validated &&
           (element._store.validated = lazyNode._store.validated),
-        "fulfilled" === lazyNode._payload.status &&
+        'fulfilled' === lazyNode._payload.status &&
           lazyNode._debugInfo &&
           ((response = lazyNode._debugInfo.splice(0)),
           element._debugInfo
             ? element._debugInfo.unshift.apply(element._debugInfo, response)
-            : Object.defineProperty(element, "_debugInfo", {
+            : Object.defineProperty(element, '_debugInfo', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: response
+                value: response,
               })));
       Object.freeze(element.props);
     }
@@ -1866,7 +1866,7 @@
       var lazyType = {
         $$typeof: REACT_LAZY_TYPE,
         _payload: chunk,
-        _init: readChunk
+        _init: readChunk,
       };
       lazyType._debugInfo = chunk._debugInfo;
       lazyType._store = { validated: validated };
@@ -1877,7 +1877,7 @@
         chunk = chunks.get(id);
       chunk ||
         ((chunk = response._closed
-          ? new ReactPromise("rejected", null, response._closedReason)
+          ? new ReactPromise('rejected', null, response._closedReason)
           : createPendingChunk(response)),
         chunks.set(id, chunk));
       return chunk;
@@ -1896,7 +1896,7 @@
       ) {
         for (
           ;
-          "object" === typeof value &&
+          'object' === typeof value &&
           null !== value &&
           value.$$typeof === REACT_LAZY_TYPE;
 
@@ -1905,23 +1905,23 @@
             value = handler.value;
           else {
             switch (value.status) {
-              case "resolved_model":
+              case 'resolved_model':
                 initializeModelChunk(value);
                 break;
-              case "resolved_module":
+              case 'resolved_module':
                 initializeModuleChunk(value);
             }
             switch (value.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 value = value.value;
                 continue;
-              case "blocked":
+              case 'blocked':
                 var cyclicHandler = resolveBlockedCycle(value, reference);
                 if (null !== cyclicHandler) {
                   value = cyclicHandler.value;
                   continue;
                 }
-              case "pending":
+              case 'pending':
                 path.splice(0, i - 1);
                 null === value.value
                   ? (value.value = [reference])
@@ -1930,7 +1930,7 @@
                   ? (value.reason = [reference])
                   : value.reason.push(reference);
                 return;
-              case "halted":
+              case 'halted':
                 return;
               default:
                 rejectReference(reference, value.reason);
@@ -1941,7 +1941,7 @@
       }
       for (
         ;
-        "object" === typeof value &&
+        'object' === typeof value &&
         null !== value &&
         value.$$typeof === REACT_LAZY_TYPE;
 
@@ -1950,14 +1950,14 @@
           value = handler.value;
         else {
           switch (path.status) {
-            case "resolved_model":
+            case 'resolved_model':
               initializeModelChunk(path);
               break;
-            case "resolved_module":
+            case 'resolved_module':
               initializeModuleChunk(path);
           }
           switch (path.status) {
-            case "fulfilled":
+            case 'fulfilled':
               value = path.value;
               continue;
           }
@@ -1965,22 +1965,22 @@
         }
       response = map(response, value, parentObject, key);
       parentObject[key] = response;
-      "" === key && null === handler.value && (handler.value = response);
+      '' === key && null === handler.value && (handler.value = response);
       if (
         parentObject[0] === REACT_ELEMENT_TYPE &&
-        "object" === typeof handler.value &&
+        'object' === typeof handler.value &&
         null !== handler.value &&
         handler.value.$$typeof === REACT_ELEMENT_TYPE
       )
         switch (((reference = handler.value), key)) {
-          case "3":
+          case '3':
             transferReferencedDebugInfo(handler.chunk, fulfilledChunk);
             reference.props = response;
             break;
-          case "4":
+          case '4':
             reference._owner = response;
             break;
-          case "5":
+          case '5':
             reference._debugStack = response;
             break;
           default:
@@ -1993,9 +1993,9 @@
       0 === handler.deps &&
         ((fulfilledChunk = handler.chunk),
         null !== fulfilledChunk &&
-          "blocked" === fulfilledChunk.status &&
+          'blocked' === fulfilledChunk.status &&
           ((key = fulfilledChunk.value),
-          (fulfilledChunk.status = "fulfilled"),
+          (fulfilledChunk.status = 'fulfilled'),
           (fulfilledChunk.value = handler.value),
           (fulfilledChunk.reason = handler.reason),
           null !== key && wakeChunk(key, handler.value, fulfilledChunk)));
@@ -2009,15 +2009,15 @@
         handler.value = null;
         handler.reason = error;
         handler = handler.chunk;
-        if (null !== handler && "blocked" === handler.status) {
+        if (null !== handler && 'blocked' === handler.status) {
           if (
-            "object" === typeof blockedValue &&
+            'object' === typeof blockedValue &&
             null !== blockedValue &&
             blockedValue.$$typeof === REACT_ELEMENT_TYPE
           ) {
             var erroredComponent = {
-              name: getComponentNameFromType(blockedValue.type) || "",
-              owner: blockedValue._owner
+              name: getComponentNameFromType(blockedValue.type) || '',
+              owner: blockedValue._owner,
             };
             erroredComponent.debugStack = blockedValue._debugStack;
             supportsCreateTask &&
@@ -2035,15 +2035,15 @@
       response,
       map,
       path,
-      isAwaitingDebugInfo
+      isAwaitingDebugInfo,
     ) {
       if (
         !(
           (void 0 !== response._debugChannel &&
             response._debugChannel.hasReadable) ||
-          "pending" !== referencedChunk.status ||
+          'pending' !== referencedChunk.status ||
           parentObject[0] !== REACT_ELEMENT_TYPE ||
-          ("4" !== key && "5" !== key)
+          ('4' !== key && '5' !== key)
         )
       )
         return null;
@@ -2057,7 +2057,7 @@
           value: null,
           reason: null,
           deps: 1,
-          errored: !1
+          errored: !1,
         };
       parentObject = {
         response: response,
@@ -2065,7 +2065,7 @@
         parentObject: parentObject,
         key: key,
         map: map,
-        path: path
+        path: path,
       };
       parentObject.isDebug = isAwaitingDebugInfo;
       null === referencedChunk.value
@@ -2082,11 +2082,11 @@
           metaData,
           response._callServer,
           response._encodeFormAction,
-          response._debugFindSourceMapURL
+          response._debugFindSourceMapURL,
         );
       var serverReference = resolveServerReference(
           response._serverReferenceConfig,
-          metaData.id
+          metaData.id,
         ),
         promise = preloadModule(serverReference);
       if (promise)
@@ -2108,7 +2108,7 @@
           value: null,
           reason: null,
           deps: 1,
-          errored: !1
+          errored: !1,
         };
       promise.then(
         function () {
@@ -2121,32 +2121,32 @@
           registerBoundServerReference(
             resolvedValue,
             metaData.id,
-            metaData.bound
+            metaData.bound,
           );
           parentObject[key] = resolvedValue;
-          "" === key &&
+          '' === key &&
             null === handler.value &&
             (handler.value = resolvedValue);
           if (
             parentObject[0] === REACT_ELEMENT_TYPE &&
-            "object" === typeof handler.value &&
+            'object' === typeof handler.value &&
             null !== handler.value &&
             handler.value.$$typeof === REACT_ELEMENT_TYPE
           )
             switch (((boundArgs = handler.value), key)) {
-              case "3":
+              case '3':
                 boundArgs.props = resolvedValue;
                 break;
-              case "4":
+              case '4':
                 boundArgs._owner = resolvedValue;
             }
           handler.deps--;
           0 === handler.deps &&
             ((resolvedValue = handler.chunk),
             null !== resolvedValue &&
-              "blocked" === resolvedValue.status &&
+              'blocked' === resolvedValue.status &&
               ((boundArgs = resolvedValue.value),
-              (resolvedValue.status = "fulfilled"),
+              (resolvedValue.status = 'fulfilled'),
               (resolvedValue.value = handler.value),
               null !== boundArgs &&
                 wakeChunk(boundArgs, handler.value, resolvedValue)));
@@ -2158,15 +2158,15 @@
             handler.value = null;
             handler.reason = error;
             var chunk = handler.chunk;
-            if (null !== chunk && "blocked" === chunk.status) {
+            if (null !== chunk && 'blocked' === chunk.status) {
               if (
-                "object" === typeof blockedValue &&
+                'object' === typeof blockedValue &&
                 null !== blockedValue &&
                 blockedValue.$$typeof === REACT_ELEMENT_TYPE
               ) {
                 var erroredComponent = {
-                  name: getComponentNameFromType(blockedValue.type) || "",
-                  owner: blockedValue._owner
+                  name: getComponentNameFromType(blockedValue.type) || '',
+                  owner: blockedValue._owner,
                 };
                 erroredComponent.debugStack = blockedValue._debugStack;
                 supportsCreateTask &&
@@ -2176,20 +2176,20 @@
               triggerErrorOnChunk(response, chunk, error);
             }
           }
-        }
+        },
       );
       return null;
     }
     function resolveLazy(value) {
       for (
         ;
-        "object" === typeof value &&
+        'object' === typeof value &&
         null !== value &&
         value.$$typeof === REACT_LAZY_TYPE;
 
       ) {
         var payload = value._payload;
-        if ("fulfilled" === payload.status) value = payload.value;
+        if ('fulfilled' === payload.status) value = payload.value;
         else break;
       }
       return value;
@@ -2205,43 +2205,43 @@
       }
     }
     function getOutlinedModel(response, reference, parentObject, key, map) {
-      var path = reference.split(":");
+      var path = reference.split(':');
       reference = parseInt(path[0], 16);
       reference = getChunk(response, reference);
       null !== initializingChunk &&
         isArrayImpl(initializingChunk._children) &&
         initializingChunk._children.push(reference);
       switch (reference.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(reference);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(reference);
       }
       switch (reference.status) {
-        case "fulfilled":
+        case 'fulfilled':
           for (var value = reference.value, i = 1; i < path.length; i++) {
             for (
               ;
-              "object" === typeof value &&
+              'object' === typeof value &&
               null !== value &&
               value.$$typeof === REACT_LAZY_TYPE;
 
             ) {
               value = value._payload;
               switch (value.status) {
-                case "resolved_model":
+                case 'resolved_model':
                   initializeModelChunk(value);
                   break;
-                case "resolved_module":
+                case 'resolved_module':
                   initializeModuleChunk(value);
               }
               switch (value.status) {
-                case "fulfilled":
+                case 'fulfilled':
                   value = value.value;
                   break;
-                case "blocked":
-                case "pending":
+                case 'blocked':
+                case 'pending':
                   return waitForReference(
                     value,
                     parentObject,
@@ -2249,9 +2249,9 @@
                     response,
                     map,
                     path.slice(i - 1),
-                    !1
+                    !1,
                   );
-                case "halted":
+                case 'halted':
                   return (
                     initializingHandler
                       ? ((parentObject = initializingHandler),
@@ -2262,7 +2262,7 @@
                           value: null,
                           reason: null,
                           deps: 1,
-                          errored: !1
+                          errored: !1,
                         }),
                     null
                   );
@@ -2278,7 +2278,7 @@
                           value: null,
                           reason: value.reason,
                           deps: 0,
-                          errored: !0
+                          errored: !0,
                         }),
                     null
                   );
@@ -2288,21 +2288,21 @@
           }
           for (
             ;
-            "object" === typeof value &&
+            'object' === typeof value &&
             null !== value &&
             value.$$typeof === REACT_LAZY_TYPE;
 
           ) {
             path = value._payload;
             switch (path.status) {
-              case "resolved_model":
+              case 'resolved_model':
                 initializeModelChunk(path);
                 break;
-              case "resolved_module":
+              case 'resolved_module':
                 initializeModuleChunk(path);
             }
             switch (path.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 value = path.value;
                 continue;
             }
@@ -2310,11 +2310,11 @@
           }
           response = map(response, value, parentObject, key);
           (parentObject[0] !== REACT_ELEMENT_TYPE ||
-            ("4" !== key && "5" !== key)) &&
+            ('4' !== key && '5' !== key)) &&
             transferReferencedDebugInfo(initializingChunk, reference);
           return response;
-        case "pending":
-        case "blocked":
+        case 'pending':
+        case 'blocked':
           return waitForReference(
             reference,
             parentObject,
@@ -2322,9 +2322,9 @@
             response,
             map,
             path,
-            !1
+            !1,
           );
-        case "halted":
+        case 'halted':
           return (
             initializingHandler
               ? ((parentObject = initializingHandler), parentObject.deps++)
@@ -2334,7 +2334,7 @@
                   value: null,
                   reason: null,
                   deps: 1,
-                  errored: !1
+                  errored: !1,
                 }),
             null
           );
@@ -2350,7 +2350,7 @@
                   value: null,
                   reason: reference.reason,
                   deps: 0,
-                  errored: !0
+                  errored: !0,
                 }),
             null
           );
@@ -2377,17 +2377,17 @@
     function defineLazyGetter(response, chunk, parentObject, key) {
       Object.defineProperty(parentObject, key, {
         get: function () {
-          "resolved_model" === chunk.status && initializeModelChunk(chunk);
+          'resolved_model' === chunk.status && initializeModelChunk(chunk);
           switch (chunk.status) {
-            case "fulfilled":
+            case 'fulfilled':
               return chunk.value;
-            case "rejected":
+            case 'rejected':
               throw chunk.reason;
           }
-          return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
+          return 'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.';
         },
         enumerable: !0,
-        configurable: !1
+        configurable: !1,
       });
       return null;
     }
@@ -2398,56 +2398,56 @@
       return model;
     }
     function getInferredFunctionApproximate(code) {
-      code = code.startsWith("Object.defineProperty(")
+      code = code.startsWith('Object.defineProperty(')
         ? code.slice(22)
-        : code.startsWith("(")
+        : code.startsWith('(')
           ? code.slice(1)
           : code;
-      if (code.startsWith("async function")) {
-        var idx = code.indexOf("(", 14);
+      if (code.startsWith('async function')) {
+        var idx = code.indexOf('(', 14);
         if (-1 !== idx)
           return (
             (code = code.slice(14, idx).trim()),
-            (0, eval)("({" + JSON.stringify(code) + ":async function(){}})")[
+            (0, eval)('({' + JSON.stringify(code) + ':async function(){}})')[
               code
             ]
           );
-      } else if (code.startsWith("function")) {
-        if (((idx = code.indexOf("(", 8)), -1 !== idx))
+      } else if (code.startsWith('function')) {
+        if (((idx = code.indexOf('(', 8)), -1 !== idx))
           return (
             (code = code.slice(8, idx).trim()),
-            (0, eval)("({" + JSON.stringify(code) + ":function(){}})")[code]
+            (0, eval)('({' + JSON.stringify(code) + ':function(){}})')[code]
           );
       } else if (
-        code.startsWith("class") &&
-        ((idx = code.indexOf("{", 5)), -1 !== idx)
+        code.startsWith('class') &&
+        ((idx = code.indexOf('{', 5)), -1 !== idx)
       )
         return (
           (code = code.slice(5, idx).trim()),
-          (0, eval)("({" + JSON.stringify(code) + ":class{}})")[code]
+          (0, eval)('({' + JSON.stringify(code) + ':class{}})')[code]
         );
       return function () {};
     }
     function parseModelString(response, parentObject, key, value) {
-      if ("$" === value[0]) {
-        if ("$" === value)
+      if ('$' === value[0]) {
+        if ('$' === value)
           return (
             null !== initializingHandler &&
-              "0" === key &&
+              '0' === key &&
               (initializingHandler = {
                 parent: initializingHandler,
                 chunk: null,
                 value: null,
                 reason: null,
                 deps: 0,
-                errored: !1
+                errored: !1,
               }),
             REACT_ELEMENT_TYPE
           );
         switch (value[1]) {
-          case "$":
+          case '$':
             return value.slice(1);
-          case "L":
+          case 'L':
             return (
               (parentObject = parseInt(value.slice(2), 16)),
               (response = getChunk(response, parentObject)),
@@ -2456,7 +2456,7 @@
                 initializingChunk._children.push(response),
               createLazyChunkWrapper(response, 0)
             );
-          case "@":
+          case '@':
             return (
               (parentObject = parseInt(value.slice(2), 16)),
               (response = getChunk(response, parentObject)),
@@ -2465,46 +2465,46 @@
                 initializingChunk._children.push(response),
               response
             );
-          case "S":
+          case 'S':
             return Symbol.for(value.slice(2));
-          case "F":
+          case 'F':
             var ref = value.slice(2);
             return getOutlinedModel(
               response,
               ref,
               parentObject,
               key,
-              loadServerReference
+              loadServerReference,
             );
-          case "T":
-            parentObject = "$" + value.slice(2);
+          case 'T':
+            parentObject = '$' + value.slice(2);
             response = response._tempRefs;
             if (null == response)
               throw Error(
-                "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+                'Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.',
               );
             return response.get(parentObject);
-          case "Q":
+          case 'Q':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createMap)
             );
-          case "W":
+          case 'W':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createSet)
             );
-          case "B":
+          case 'B':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createBlob)
             );
-          case "K":
+          case 'K':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createFormData)
             );
-          case "Z":
+          case 'Z':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2512,10 +2512,10 @@
                 ref,
                 parentObject,
                 key,
-                resolveErrorDev
+                resolveErrorDev,
               )
             );
-          case "i":
+          case 'i':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2523,22 +2523,22 @@
                 ref,
                 parentObject,
                 key,
-                extractIterator
+                extractIterator,
               )
             );
-          case "I":
+          case 'I':
             return Infinity;
-          case "-":
-            return "$-0" === value ? -0 : -Infinity;
-          case "N":
+          case '-':
+            return '$-0' === value ? -0 : -Infinity;
+          case 'N':
             return NaN;
-          case "u":
+          case 'u':
             return;
-          case "D":
+          case 'D':
             return new Date(Date.parse(value.slice(2)));
-          case "n":
+          case 'n':
             return BigInt(value.slice(2));
-          case "P":
+          case 'P':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2546,10 +2546,10 @@
                 ref,
                 parentObject,
                 key,
-                applyConstructor
+                applyConstructor,
               )
             );
-          case "E":
+          case 'E':
             response = value.slice(2);
             try {
               if (!mightHaveStaticConstructor.test(response))
@@ -2558,46 +2558,46 @@
             try {
               if (
                 ((ref = getInferredFunctionApproximate(response)),
-                response.startsWith("Object.defineProperty("))
+                response.startsWith('Object.defineProperty('))
               ) {
                 var idx = response.lastIndexOf(',"name",{value:"');
                 if (-1 !== idx) {
                   var name = JSON.parse(
-                    response.slice(idx + 16 - 1, response.length - 2)
+                    response.slice(idx + 16 - 1, response.length - 2),
                   );
-                  Object.defineProperty(ref, "name", { value: name });
+                  Object.defineProperty(ref, 'name', { value: name });
                 }
               }
             } catch (_) {
               ref = function () {};
             }
             return ref;
-          case "Y":
+          case 'Y':
             if (
               2 < value.length &&
               (ref = response._debugChannel && response._debugChannel.callback)
             ) {
-              if ("@" === value[2])
+              if ('@' === value[2])
                 return (
                   (parentObject = value.slice(3)),
                   (key = parseInt(parentObject, 16)),
-                  response._chunks.has(key) || ref("P:" + parentObject),
+                  response._chunks.has(key) || ref('P:' + parentObject),
                   getChunk(response, key)
                 );
               value = value.slice(2);
               idx = parseInt(value, 16);
-              response._chunks.has(idx) || ref("Q:" + value);
+              response._chunks.has(idx) || ref('Q:' + value);
               ref = getChunk(response, idx);
-              return "fulfilled" === ref.status
+              return 'fulfilled' === ref.status
                 ? ref.value
                 : defineLazyGetter(response, ref, parentObject, key);
             }
             Object.defineProperty(parentObject, key, {
               get: function () {
-                return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
+                return 'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.';
               },
               enumerable: !0,
-              configurable: !1
+              configurable: !1,
             });
             return null;
           default:
@@ -2611,7 +2611,7 @@
     }
     function missingCall() {
       throw Error(
-        'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+        'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.',
       );
     }
     function ResponseInstance(
@@ -2625,7 +2625,7 @@
       findSourceMapURL,
       replayConsole,
       environmentName,
-      debugChannel
+      debugChannel,
     ) {
       var chunks = new Map();
       this._bundlerConfig = bundlerConfig;
@@ -2650,11 +2650,11 @@
           ? null
           : ReactSharedInteralsServer.A.getOwner();
       this._debugRootStack =
-        null !== bundlerConfig ? Error("react-stack-top-frame") : null;
-      environmentName = void 0 === environmentName ? "Server" : environmentName;
+        null !== bundlerConfig ? Error('react-stack-top-frame') : null;
+      environmentName = void 0 === environmentName ? 'Server' : environmentName;
       supportsCreateTask &&
         (this._debugRootTask = console.createTask(
-          '"use ' + environmentName.toLowerCase() + '"'
+          '"use ' + environmentName.toLowerCase() + '"',
         ));
       this._debugStartTime = performance.now();
       this._debugFindSourceMapURL = findSourceMapURL;
@@ -2675,21 +2675,21 @@
         _rowID: 0,
         _rowTag: 0,
         _rowLength: 0,
-        _buffer: []
+        _buffer: [],
       };
       weakResponse = unwrapWeakResponse(weakResponse);
       var debugValuePromise = Promise.resolve(streamDebugValue);
-      debugValuePromise.status = "fulfilled";
+      debugValuePromise.status = 'fulfilled';
       debugValuePromise.value = streamDebugValue;
       streamState._debugInfo = {
-        name: "RSC stream",
+        name: 'RSC stream',
         start: weakResponse._debugStartTime,
         end: weakResponse._debugStartTime,
         byteSize: 0,
         value: debugValuePromise,
         owner: weakResponse._debugRootOwner,
         debugStack: weakResponse._debugRootStack,
-        debugTask: weakResponse._debugRootTask
+        debugTask: weakResponse._debugRootTask,
       };
       streamState._debugTargetChunkSize = MIN_CHUNK_SIZE;
       return streamState;
@@ -2709,32 +2709,32 @@
             value: debugInfo.value,
             owner: debugInfo.owner,
             debugStack: debugInfo.debugStack,
-            debugTask: debugInfo.debugTask
+            debugTask: debugInfo.debugTask,
           }),
           (streamState._debugTargetChunkSize = chunkLength + MIN_CHUNK_SIZE))
         : ((debugInfo.end = endTime), (debugInfo.byteSize = chunkLength));
     }
     function addDebugInfo(chunk, debugInfo) {
       var value = resolveLazy(chunk.value);
-      "object" !== typeof value ||
+      'object' !== typeof value ||
       null === value ||
       (!isArrayImpl(value) &&
-        "function" !== typeof value[ASYNC_ITERATOR] &&
+        'function' !== typeof value[ASYNC_ITERATOR] &&
         value.$$typeof !== REACT_ELEMENT_TYPE &&
         value.$$typeof !== REACT_LAZY_TYPE)
         ? chunk._debugInfo.push.apply(chunk._debugInfo, debugInfo)
         : isArrayImpl(value._debugInfo)
           ? value._debugInfo.push.apply(value._debugInfo, debugInfo)
-          : Object.defineProperty(value, "_debugInfo", {
+          : Object.defineProperty(value, '_debugInfo', {
               configurable: !1,
               enumerable: !1,
               writable: !0,
-              value: debugInfo
+              value: debugInfo,
             });
     }
     function resolveChunkDebugInfo(streamState, chunk) {
       streamState = [{ awaited: streamState._debugInfo }];
-      "pending" === chunk.status || "blocked" === chunk.status
+      'pending' === chunk.status || 'blocked' === chunk.status
         ? ((streamState = addDebugInfo.bind(null, chunk, streamState)),
           chunk.then(streamState, streamState))
         : addDebugInfo(chunk, streamState);
@@ -2742,10 +2742,10 @@
     function resolveBuffer(response, id, buffer, streamState) {
       var chunks = response._chunks,
         chunk = chunks.get(id);
-      chunk && "pending" !== chunk.status
+      chunk && 'pending' !== chunk.status
         ? chunk.reason.enqueueValue(buffer)
         : (chunk && releasePendingChunk(response, chunk),
-          (response = new ReactPromise("fulfilled", buffer, null)),
+          (response = new ReactPromise('fulfilled', buffer, null)),
           resolveChunkDebugInfo(streamState, response),
           chunks.set(id, response));
     }
@@ -2755,15 +2755,15 @@
       model = JSON.parse(model, response._fromJSON);
       var clientReference = resolveClientReference(
         response._bundlerConfig,
-        model
+        model,
       );
       if ((model = preloadModule(clientReference))) {
         if (chunk) {
           releasePendingChunk(response, chunk);
           var blockedChunk = chunk;
-          blockedChunk.status = "blocked";
+          blockedChunk.status = 'blocked';
         } else
-          (blockedChunk = new ReactPromise("blocked", null, null)),
+          (blockedChunk = new ReactPromise('blocked', null, null)),
             chunks.set(id, blockedChunk);
         resolveChunkDebugInfo(streamState, blockedChunk);
         model.then(
@@ -2772,16 +2772,16 @@
           },
           function (error) {
             return triggerErrorOnChunk(response, blockedChunk, error);
-          }
+          },
         );
       } else
         chunk
           ? (resolveChunkDebugInfo(streamState, chunk),
             resolveModuleChunk(response, chunk, clientReference))
           : ((chunk = new ReactPromise(
-              "resolved_module",
+              'resolved_module',
               clientReference,
-              null
+              null,
             )),
             resolveChunkDebugInfo(streamState, chunk),
             chunks.set(id, chunk));
@@ -2792,7 +2792,7 @@
       if (chunk) {
         if (
           (resolveChunkDebugInfo(streamState, chunk),
-          "pending" === chunk.status)
+          'pending' === chunk.status)
         ) {
           releasePendingChunk(response, chunk);
           id = chunk.value;
@@ -2800,7 +2800,7 @@
             streamState = initializingHandler;
             chunks = initializingChunk;
             initializingHandler = null;
-            chunk.status = "blocked";
+            chunk.status = 'blocked';
             chunk.value = null;
             chunk.reason = null;
             initializingChunk = chunk;
@@ -2820,13 +2820,13 @@
               (initializingHandler = streamState), (initializingChunk = chunks);
             }
           }
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = stream;
           chunk.reason = controller;
           null !== id && wakeChunk(id, chunk.value, chunk);
         }
       } else
-        (response = new ReactPromise("fulfilled", stream, controller)),
+        (response = new ReactPromise('fulfilled', stream, controller)),
           resolveChunkDebugInfo(streamState, response),
           chunks.set(id, response);
     }
@@ -2836,7 +2836,7 @@
         type: type,
         start: function (c) {
           controller = c;
-        }
+        },
       });
       var previousBlockedChunk = null;
       resolveStream(
@@ -2855,7 +2855,7 @@
             if (null === previousBlockedChunk) {
               var chunk = createResolvedModelChunk(response, json);
               initializeModelChunk(chunk);
-              "fulfilled" === chunk.status
+              'fulfilled' === chunk.status
                 ? controller.enqueue(chunk.value)
                 : (chunk.then(
                     function (v) {
@@ -2863,7 +2863,7 @@
                     },
                     function (e) {
                       return controller.error(e);
-                    }
+                    },
                   ),
                   (previousBlockedChunk = chunk));
             } else {
@@ -2875,7 +2875,7 @@
                 },
                 function (e) {
                   return controller.error(e);
-                }
+                },
               );
               previousBlockedChunk = _chunk3;
               chunk.then(function () {
@@ -2904,9 +2904,9 @@
                 return controller.error(error);
               });
             }
-          }
+          },
         },
-        streamState
+        streamState,
       );
     }
     function asyncIterator() {
@@ -2927,14 +2927,14 @@
         return createIterator(function (arg) {
           if (void 0 !== arg)
             throw Error(
-              "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+              'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
             );
           if (nextReadIndex === buffer.length) {
             if (closed)
               return new ReactPromise(
-                "fulfilled",
+                'fulfilled',
                 { done: !0, value: void 0 },
-                null
+                null,
               );
             buffer[nextReadIndex] = createPendingChunk(response);
           }
@@ -2949,21 +2949,21 @@
           enqueueValue: function (value) {
             if (nextWriteIndex === buffer.length)
               buffer[nextWriteIndex] = new ReactPromise(
-                "fulfilled",
+                'fulfilled',
                 { done: !1, value: value },
-                null
+                null,
               );
             else {
               var chunk = buffer[nextWriteIndex],
                 resolveListeners = chunk.value,
                 rejectListeners = chunk.reason;
-              chunk.status = "fulfilled";
+              chunk.status = 'fulfilled';
               chunk.value = { done: !1, value: value };
               null !== resolveListeners &&
                 wakeChunkIfInitialized(
                   chunk,
                   resolveListeners,
-                  rejectListeners
+                  rejectListeners,
                 );
             }
             nextWriteIndex++;
@@ -2973,13 +2973,13 @@
               ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                   response,
                   value,
-                  !1
+                  !1,
                 ))
               : resolveIteratorResultChunk(
                   response,
                   buffer[nextWriteIndex],
                   value,
-                  !1
+                  !1,
                 );
             nextWriteIndex++;
           },
@@ -2989,20 +2989,20 @@
               ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                   response,
                   value,
-                  !0
+                  !0,
                 ))
               : resolveIteratorResultChunk(
                   response,
                   buffer[nextWriteIndex],
                   value,
-                  !0
+                  !0,
                 );
             for (nextWriteIndex++; nextWriteIndex < buffer.length; )
               resolveIteratorResultChunk(
                 response,
                 buffer[nextWriteIndex++],
                 '"$undefined"',
-                !0
+                !0,
               );
           },
           error: function (error) {
@@ -3014,9 +3014,9 @@
 
             )
               triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);
-          }
+          },
         },
-        streamState
+        streamState,
       );
     }
     function resolveErrorDev(response, errorInfo) {
@@ -3030,8 +3030,8 @@
         Error.bind(
           null,
           errorInfo.message ||
-            "An error occurred in the Server Components render but no message was provided"
-        )
+            'An error occurred in the Server Components render but no message was provided',
+        ),
       );
       var ownerTask = null;
       null != errorInfo.owner &&
@@ -3040,8 +3040,8 @@
           response,
           errorInfo,
           {},
-          "",
-          createModel
+          '',
+          createModel,
         )),
         null !== errorInfo &&
           (ownerTask = initializeFakeTask(response, errorInfo)));
@@ -3061,9 +3061,9 @@
       col,
       enclosingLine,
       enclosingCol,
-      environmentName
+      environmentName,
     ) {
-      name || (name = "<anonymous>");
+      name || (name = '<anonymous>');
       var encodedName = JSON.stringify(name);
       1 > enclosingLine ? (enclosingLine = 0) : enclosingLine--;
       1 > enclosingCol ? (enclosingCol = 0) : enclosingCol--;
@@ -3081,66 +3081,66 @@
           (col = col - enclosingCol - line - 3),
           0 > col && (col = 0),
           (encodedName =
-            "({" +
+            '({' +
             encodedName +
-            ":" +
-            " ".repeat(enclosingCol) +
-            "_=>" +
-            " ".repeat(col) +
-            "_()})"))
+            ':' +
+            ' '.repeat(enclosingCol) +
+            '_=>' +
+            ' '.repeat(col) +
+            '_()})'))
         : 1 > enclosingLine
           ? ((enclosingCol -= encodedName.length + 3),
             0 > enclosingCol && (enclosingCol = 0),
             (encodedName =
-              "({" +
+              '({' +
               encodedName +
-              ":" +
-              " ".repeat(enclosingCol) +
-              "_=>" +
-              "\n".repeat(line - enclosingLine) +
-              " ".repeat(col) +
-              "_()})"))
+              ':' +
+              ' '.repeat(enclosingCol) +
+              '_=>' +
+              '\n'.repeat(line - enclosingLine) +
+              ' '.repeat(col) +
+              '_()})'))
           : enclosingLine === line
             ? ((col = col - enclosingCol - 3),
               0 > col && (col = 0),
               (encodedName =
-                "\n".repeat(enclosingLine - 1) +
-                "({" +
+                '\n'.repeat(enclosingLine - 1) +
+                '({' +
                 encodedName +
-                ":\n" +
-                " ".repeat(enclosingCol) +
-                "_=>" +
-                " ".repeat(col) +
-                "_()})"))
+                ':\n' +
+                ' '.repeat(enclosingCol) +
+                '_=>' +
+                ' '.repeat(col) +
+                '_()})'))
             : (encodedName =
-                "\n".repeat(enclosingLine - 1) +
-                "({" +
+                '\n'.repeat(enclosingLine - 1) +
+                '({' +
                 encodedName +
-                ":\n" +
-                " ".repeat(enclosingCol) +
-                "_=>" +
-                "\n".repeat(line - enclosingLine) +
-                " ".repeat(col) +
-                "_()})");
+                ':\n' +
+                ' '.repeat(enclosingCol) +
+                '_=>' +
+                '\n'.repeat(line - enclosingLine) +
+                ' '.repeat(col) +
+                '_()})');
       encodedName =
         1 > enclosingLine
           ? encodedName +
-            "\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */"
-          : "/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */" +
+            '\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */'
+          : '/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */' +
             encodedName;
-      filename.startsWith("/") && (filename = "file://" + filename);
+      filename.startsWith('/') && (filename = 'file://' + filename);
       sourceMap
         ? ((encodedName +=
-            "\n//# sourceURL=about://React/" +
+            '\n//# sourceURL=about://React/' +
             encodeURIComponent(environmentName) +
-            "/" +
+            '/' +
             encodeURI(filename) +
-            "?" +
+            '?' +
             fakeFunctionIdx++),
-          (encodedName += "\n//# sourceMappingURL=" + sourceMap))
+          (encodedName += '\n//# sourceMappingURL=' + sourceMap))
         : (encodedName = filename
-            ? encodedName + ("\n//# sourceURL=" + encodeURI(filename))
-            : encodedName + "\n//# sourceURL=<anonymous>");
+            ? encodedName + ('\n//# sourceURL=' + encodeURI(filename))
+            : encodedName + '\n//# sourceURL=<anonymous>');
       try {
         var fn = (0, eval)(encodedName)[name];
       } catch (x) {
@@ -3155,15 +3155,15 @@
       stack,
       environmentName,
       useEnclosingLine,
-      innerCall
+      innerCall,
     ) {
       for (var i = 0; i < stack.length; i++) {
         var frame = stack[i],
           frameKey =
-            frame.join("-") +
-            "-" +
+            frame.join('-') +
+            '-' +
             environmentName +
-            (useEnclosingLine ? "-e" : "-n"),
+            (useEnclosingLine ? '-e' : '-n'),
           fn = fakeFunctionCache.get(frameKey);
         if (void 0 === fn) {
           fn = frame[0];
@@ -3184,7 +3184,7 @@
             col,
             useEnclosingLine ? line : enclosingLine,
             useEnclosingLine ? col : frame,
-            environmentName
+            environmentName,
           );
           fakeFunctionCache.set(frameKey, fn);
         }
@@ -3198,7 +3198,7 @@
         ? response._rootEnvironmentName !== childEnvironmentName
           ? ((response = console.createTask.bind(
               console,
-              '"use ' + childEnvironmentName.toLowerCase() + '"'
+              '"use ' + childEnvironmentName.toLowerCase() + '"',
             )),
             rootTask.run(response))
           : rootTask
@@ -3224,17 +3224,17 @@
         env !== cachedEntry
           ? '"use ' + env.toLowerCase() + '"'
           : void 0 !== debugInfo.key
-            ? "<" + (debugInfo.name || "...") + ">"
+            ? '<' + (debugInfo.name || '...') + '>'
             : void 0 !== debugInfo.name
-              ? debugInfo.name || "unknown"
-              : "await " + (debugInfo.awaited.name || "unknown");
+              ? debugInfo.name || 'unknown'
+              : 'await ' + (debugInfo.awaited.name || 'unknown');
       env = console.createTask.bind(console, env);
       useEnclosingLine = buildFakeCallStack(
         response,
         stack,
         cachedEntry,
         useEnclosingLine,
-        env
+        env,
       );
       null === ownerTask
         ? ((response = getRootTask(response, cachedEntry)),
@@ -3246,7 +3246,7 @@
       return (debugInfo.debugTask = response);
     }
     function fakeJSXCallSite() {
-      return Error("react-stack-top-frame");
+      return Error('react-stack-top-frame');
     }
     function initializeFakeStack(response, debugInfo) {
       if (void 0 === debugInfo.debugStack) {
@@ -3254,7 +3254,7 @@
           (debugInfo.debugStack = createFakeJSXCallStackInDEV(
             response,
             debugInfo.stack,
-            null == debugInfo.env ? "" : debugInfo.env
+            null == debugInfo.env ? '' : debugInfo.env,
           ));
         var owner = debugInfo.owner;
         null != owner &&
@@ -3274,16 +3274,16 @@
         _componentInfoOrAsyncInfo.debugTask = response._debugRootTask;
       } else
         void 0 !== debugInfo.stack && initializeFakeStack(response, debugInfo);
-      "number" === typeof debugInfo.time &&
+      'number' === typeof debugInfo.time &&
         (debugInfo = { time: debugInfo.time + response._timeOrigin });
       return debugInfo;
     }
     function getCurrentStackInDEV() {
       var owner = currentOwnerInDEV;
-      if (null === owner) return "";
+      if (null === owner) return '';
       try {
-        var info = "";
-        if (owner.owner || "string" !== typeof owner.name) {
+        var info = '';
+        if (owner.owner || 'string' !== typeof owner.name) {
           for (; owner; ) {
             var ownerStack = owner.debugStack;
             if (null != ownerStack) {
@@ -3294,16 +3294,16 @@
                 Error.prepareStackTrace = void 0;
                 var stack = error.stack;
                 Error.prepareStackTrace = prevPrepareStackTrace;
-                stack.startsWith("Error: react-stack-top-frame\n") &&
+                stack.startsWith('Error: react-stack-top-frame\n') &&
                   (stack = stack.slice(29));
-                var idx = stack.indexOf("\n");
+                var idx = stack.indexOf('\n');
                 -1 !== idx && (stack = stack.slice(idx + 1));
-                idx = stack.indexOf("react_stack_bottom_frame");
-                -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
+                idx = stack.indexOf('react_stack_bottom_frame');
+                -1 !== idx && (idx = stack.lastIndexOf('\n', idx));
                 var JSCompiler_inline_result =
-                  -1 !== idx ? (stack = stack.slice(0, idx)) : "";
+                  -1 !== idx ? (stack = stack.slice(0, idx)) : '';
                 info =
-                  JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
+                  JSCompiler_temp_const + ('\n' + JSCompiler_inline_result);
               }
             } else break;
           }
@@ -3316,20 +3316,20 @@
             } catch (x) {
               (prefix =
                 ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) ||
-                ""),
+                ''),
                 (suffix =
-                  -1 < x.stack.indexOf("\n    at")
-                    ? " (<anonymous>)"
-                    : -1 < x.stack.indexOf("@")
-                      ? "@unknown:0:0"
-                      : "");
+                  -1 < x.stack.indexOf('\n    at')
+                    ? ' (<anonymous>)'
+                    : -1 < x.stack.indexOf('@')
+                      ? '@unknown:0:0'
+                      : '');
             }
           JSCompiler_inline_result$jscomp$0 =
-            "\n" + prefix + JSCompiler_temp_const + suffix;
+            '\n' + prefix + JSCompiler_temp_const + suffix;
         }
       } catch (x) {
         JSCompiler_inline_result$jscomp$0 =
-          "\nError generating stack: " + x.message + "\n" + x.stack;
+          '\nError generating stack: ' + x.message + '\n' + x.stack;
       }
       return JSCompiler_inline_result$jscomp$0;
     }
@@ -3339,13 +3339,13 @@
         if (null == blockedChunk)
           (blockedChunk = createResolvedModelChunk(response, json)),
             initializeModelChunk(blockedChunk),
-            "fulfilled" === blockedChunk.status
+            'fulfilled' === blockedChunk.status
               ? replayConsoleWithCallStackInDEV(response, blockedChunk.value)
               : (blockedChunk.then(
                   function (v) {
                     return replayConsoleWithCallStackInDEV(response, v);
                   },
-                  function () {}
+                  function () {},
                 ),
                 (response._blockedConsole = blockedChunk));
         else {
@@ -3354,7 +3354,7 @@
             function (v) {
               return replayConsoleWithCallStackInDEV(response, v);
             },
-            function () {}
+            function () {},
           );
           response._blockedConsole = _chunk4;
           var unblock = function () {
@@ -3377,16 +3377,16 @@
         var promise = ioInfo.value;
         if (promise)
           switch (promise.status) {
-            case "fulfilled":
+            case 'fulfilled':
               logIOInfo(ioInfo, response, promise.value);
               break;
-            case "rejected":
+            case 'rejected':
               logIOInfoErrored(ioInfo, response, promise.reason);
               break;
             default:
               promise.then(
                 logIOInfo.bind(null, ioInfo, response),
-                logIOInfoErrored.bind(null, ioInfo, response)
+                logIOInfoErrored.bind(null, ioInfo, response),
               );
           }
         else logIOInfo(ioInfo, response, void 0);
@@ -3397,17 +3397,17 @@
         chunk = chunks.get(id);
       chunk
         ? (resolveModelChunk(response, chunk, model),
-          "resolved_model" === chunk.status && initializeModelChunk(chunk))
+          'resolved_model' === chunk.status && initializeModelChunk(chunk))
         : ((chunk = createResolvedModelChunk(response, model)),
           chunks.set(id, chunk),
           initializeModelChunk(chunk));
-      "fulfilled" === chunk.status
+      'fulfilled' === chunk.status
         ? initializeIOInfo(response, chunk.value)
         : chunk.then(
             function (v) {
               initializeIOInfo(response, v);
             },
-            function () {}
+            function () {},
           );
     }
     function mergeBuffer(buffer, lastChunk) {
@@ -3433,7 +3433,7 @@
       lastChunk,
       constructor,
       bytesPerElement,
-      streamState
+      streamState,
     ) {
       buffer =
         0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
@@ -3442,7 +3442,7 @@
       constructor = new constructor(
         buffer.buffer,
         buffer.byteOffset,
-        buffer.byteLength / bytesPerElement
+        buffer.byteLength / bytesPerElement,
       );
       resolveBuffer(response, id, constructor, streamState);
     }
@@ -3451,7 +3451,7 @@
       root,
       trackIdx$jscomp$6,
       trackTime,
-      parentEndTime
+      parentEndTime,
     ) {
       if (!isArrayImpl(root._children)) {
         var previousResult = root._children,
@@ -3467,9 +3467,9 @@
           if (supportsUserTiming && 0 <= previousEndTime && 10 > trackIdx) {
             var color =
                 componentInfo.env === response$jscomp$0._rootEnvironmentName
-                  ? "primary-light"
-                  : "secondary-light",
-              entryName = componentInfo.name + " [deduped]",
+                  ? 'primary-light'
+                  : 'secondary-light',
+              entryName = componentInfo.name + ' [deduped]',
               debugTask = componentInfo.debugTask;
             debugTask
               ? debugTask.run(
@@ -3479,17 +3479,17 @@
                     0 > startTime ? 0 : startTime,
                     previousEndTime,
                     trackNames[trackIdx],
-                    "Server Components \u269b",
-                    color
-                  )
+                    'Server Components \u269b',
+                    color,
+                  ),
                 )
               : console.timeStamp(
                   entryName,
                   0 > startTime ? 0 : startTime,
                   previousEndTime,
                   trackNames[trackIdx],
-                  "Server Components \u269b",
-                  color
+                  'Server Components \u269b',
+                  color,
                 );
           }
         }
@@ -3501,8 +3501,8 @@
       if (debugInfo) {
         for (var startTime$jscomp$0 = 0, i = 0; i < debugInfo.length; i++) {
           var info = debugInfo[i];
-          "number" === typeof info.time && (startTime$jscomp$0 = info.time);
-          if ("string" === typeof info.name) {
+          'number' === typeof info.time && (startTime$jscomp$0 = info.time);
+          if ('string' === typeof info.name) {
             startTime$jscomp$0 < trackTime && trackIdx$jscomp$6++;
             trackTime = startTime$jscomp$0;
             break;
@@ -3510,7 +3510,7 @@
         }
         for (var _i4 = debugInfo.length - 1; 0 <= _i4; _i4--) {
           var _info = debugInfo[_i4];
-          if ("number" === typeof _info.time && _info.time > parentEndTime) {
+          if ('number' === typeof _info.time && _info.time > parentEndTime) {
             parentEndTime = _info.time;
             break;
           }
@@ -3519,7 +3519,7 @@
       var result = {
         track: trackIdx$jscomp$6,
         endTime: -Infinity,
-        component: null
+        component: null,
       };
       root._children = result;
       for (
@@ -3535,7 +3535,7 @@
           children[_i5],
           childTrackIdx,
           childTrackTime,
-          parentEndTime
+          parentEndTime,
         );
         null !== childResult.component &&
           (result.component = childResult.component);
@@ -3555,13 +3555,13 @@
           _i6--
         ) {
           var _info2 = debugInfo[_i6];
-          if ("number" === typeof _info2.time) {
+          if ('number' === typeof _info2.time) {
             0 === componentEndTime && (componentEndTime = _info2.time);
             var time = _info2.time;
             if (-1 < endTimeIdx)
               for (var j = endTimeIdx - 1; j > _i6; j--) {
                 var candidateInfo = debugInfo[j];
-                if ("string" === typeof candidateInfo.name) {
+                if ('string' === typeof candidateInfo.name) {
                   componentEndTime > childrenEndTime &&
                     (childrenEndTime = componentEndTime);
                   var componentInfo$jscomp$0 = candidateInfo,
@@ -3573,7 +3573,7 @@
                     childrenEndTime$jscomp$0 = childrenEndTime;
                   if (
                     isLastComponent &&
-                    "rejected" === root.status &&
+                    'rejected' === root.status &&
                     root.reason !== response._closedReason
                   ) {
                     var componentInfo$jscomp$2 = componentInfo$jscomp$1,
@@ -3588,44 +3588,44 @@
                           env === response._rootEnvironmentName ||
                           void 0 === env
                             ? name
-                            : name + " [" + env + "]",
+                            : name + ' [' + env + ']',
                         properties = [
                           [
-                            "Error",
-                            "object" === typeof error &&
+                            'Error',
+                            'object' === typeof error &&
                             null !== error &&
-                            "string" === typeof error.message
+                            'string' === typeof error.message
                               ? String(error.message)
-                              : String(error)
-                          ]
+                              : String(error),
+                          ],
                         ];
                       null != componentInfo$jscomp$2.key &&
                         addValueToProperties(
-                          "key",
+                          'key',
                           componentInfo$jscomp$2.key,
                           properties,
                           0,
-                          ""
+                          '',
                         );
                       null != componentInfo$jscomp$2.props &&
                         addObjectToProperties(
                           componentInfo$jscomp$2.props,
                           properties,
                           0,
-                          ""
+                          '',
                         );
-                      performance.measure("\u200b" + entryName$jscomp$0, {
+                      performance.measure('\u200b' + entryName$jscomp$0, {
                         start: 0 > startTime$jscomp$2 ? 0 : startTime$jscomp$2,
                         end: childrenEndTime$jscomp$1,
                         detail: {
                           devtools: {
-                            color: "error",
+                            color: 'error',
                             track: trackNames[trackIdx$jscomp$1],
-                            trackGroup: "Server Components \u269b",
-                            tooltipText: entryName$jscomp$0 + " Errored",
-                            properties: properties
-                          }
-                        }
+                            trackGroup: 'Server Components \u269b',
+                            tooltipText: entryName$jscomp$0 + ' Errored',
+                            properties: properties,
+                          },
+                        },
                       });
                     }
                   } else {
@@ -3647,43 +3647,43 @@
                         color$jscomp$0 =
                           0.5 > selfTime
                             ? isPrimaryEnv
-                              ? "primary-light"
-                              : "secondary-light"
+                              ? 'primary-light'
+                              : 'secondary-light'
                             : 50 > selfTime
                               ? isPrimaryEnv
-                                ? "primary"
-                                : "secondary"
+                                ? 'primary'
+                                : 'secondary'
                               : 500 > selfTime
                                 ? isPrimaryEnv
-                                  ? "primary-dark"
-                                  : "secondary-dark"
-                                : "error",
+                                  ? 'primary-dark'
+                                  : 'secondary-dark'
+                                : 'error',
                         entryName$jscomp$1 =
                           isPrimaryEnv || void 0 === env$jscomp$0
                             ? name$jscomp$0
-                            : name$jscomp$0 + " [" + env$jscomp$0 + "]",
+                            : name$jscomp$0 + ' [' + env$jscomp$0 + ']',
                         debugTask$jscomp$0 = componentInfo$jscomp$3.debugTask;
                       if (debugTask$jscomp$0) {
                         var properties$jscomp$0 = [];
                         null != componentInfo$jscomp$3.key &&
                           addValueToProperties(
-                            "key",
+                            'key',
                             componentInfo$jscomp$3.key,
                             properties$jscomp$0,
                             0,
-                            ""
+                            '',
                           );
                         null != componentInfo$jscomp$3.props &&
                           addObjectToProperties(
                             componentInfo$jscomp$3.props,
                             properties$jscomp$0,
                             0,
-                            ""
+                            '',
                           );
                         debugTask$jscomp$0.run(
                           performance.measure.bind(
                             performance,
-                            "\u200b" + entryName$jscomp$1,
+                            '\u200b' + entryName$jscomp$1,
                             {
                               start:
                                 0 > startTime$jscomp$3 ? 0 : startTime$jscomp$3,
@@ -3692,21 +3692,21 @@
                                 devtools: {
                                   color: color$jscomp$0,
                                   track: trackNames[trackIdx$jscomp$2],
-                                  trackGroup: "Server Components \u269b",
-                                  properties: properties$jscomp$0
-                                }
-                              }
-                            }
-                          )
+                                  trackGroup: 'Server Components \u269b',
+                                  properties: properties$jscomp$0,
+                                },
+                              },
+                            },
+                          ),
                         );
                       } else
                         console.timeStamp(
-                          "\u200b" + entryName$jscomp$1,
+                          '\u200b' + entryName$jscomp$1,
                           0 > startTime$jscomp$3 ? 0 : startTime$jscomp$3,
                           childrenEndTime$jscomp$2,
                           trackNames[trackIdx$jscomp$2],
-                          "Server Components \u269b",
-                          color$jscomp$0
+                          'Server Components \u269b',
+                          color$jscomp$0,
                         );
                     }
                   }
@@ -3724,17 +3724,17 @@
                   if (promise) {
                     var thenable = promise;
                     switch (thenable.status) {
-                      case "fulfilled":
+                      case 'fulfilled':
                         logComponentAwait(
                           asyncInfo,
                           trackIdx$jscomp$6,
                           time,
                           endTime,
                           env$jscomp$1,
-                          thenable.value
+                          thenable.value,
                         );
                         break;
-                      case "rejected":
+                      case 'rejected':
                         var asyncInfo$jscomp$0 = asyncInfo,
                           trackIdx$jscomp$3 = trackIdx$jscomp$6,
                           startTime$jscomp$4 = time,
@@ -3744,12 +3744,12 @@
                         if (supportsUserTiming && 0 < endTime$jscomp$0) {
                           var description = getIODescription(error$jscomp$0),
                             entryName$jscomp$2 =
-                              "await " +
+                              'await ' +
                               getIOShortName(
                                 asyncInfo$jscomp$0.awaited,
                                 description,
                                 asyncInfo$jscomp$0.env,
-                                rootEnv
+                                rootEnv,
                               ),
                             debugTask$jscomp$1 =
                               asyncInfo$jscomp$0.debugTask ||
@@ -3757,21 +3757,21 @@
                           if (debugTask$jscomp$1) {
                             var properties$jscomp$1 = [
                                 [
-                                  "Rejected",
-                                  "object" === typeof error$jscomp$0 &&
+                                  'Rejected',
+                                  'object' === typeof error$jscomp$0 &&
                                   null !== error$jscomp$0 &&
-                                  "string" === typeof error$jscomp$0.message
+                                  'string' === typeof error$jscomp$0.message
                                     ? String(error$jscomp$0.message)
-                                    : String(error$jscomp$0)
-                                ]
+                                    : String(error$jscomp$0),
+                                ],
                               ],
                               tooltipText =
                                 getIOLongName(
                                   asyncInfo$jscomp$0.awaited,
                                   description,
                                   asyncInfo$jscomp$0.env,
-                                  rootEnv
-                                ) + " Rejected";
+                                  rootEnv,
+                                ) + ' Rejected';
                             debugTask$jscomp$1.run(
                               performance.measure.bind(
                                 performance,
@@ -3784,15 +3784,15 @@
                                   end: endTime$jscomp$0,
                                   detail: {
                                     devtools: {
-                                      color: "error",
+                                      color: 'error',
                                       track: trackNames[trackIdx$jscomp$3],
-                                      trackGroup: "Server Components \u269b",
+                                      trackGroup: 'Server Components \u269b',
                                       properties: properties$jscomp$1,
-                                      tooltipText: tooltipText
-                                    }
-                                  }
-                                }
-                              )
+                                      tooltipText: tooltipText,
+                                    },
+                                  },
+                                },
+                              ),
                             );
                           } else
                             console.timeStamp(
@@ -3800,8 +3800,8 @@
                               0 > startTime$jscomp$4 ? 0 : startTime$jscomp$4,
                               endTime$jscomp$0,
                               trackNames[trackIdx$jscomp$3],
-                              "Server Components \u269b",
-                              "error"
+                              'Server Components \u269b',
+                              'error',
                             );
                         }
                         break;
@@ -3812,7 +3812,7 @@
                           time,
                           endTime,
                           env$jscomp$1,
-                          void 0
+                          void 0,
                         );
                     }
                   } else
@@ -3822,7 +3822,7 @@
                       time,
                       endTime,
                       env$jscomp$1,
-                      void 0
+                      void 0,
                     );
                 }
               }
@@ -3830,7 +3830,7 @@
               endTime = time;
               for (var _j = debugInfo.length - 1; _j > _i6; _j--) {
                 var _candidateInfo = debugInfo[_j];
-                if ("string" === typeof _candidateInfo.name) {
+                if ('string' === typeof _candidateInfo.name) {
                   componentEndTime > childrenEndTime &&
                     (childrenEndTime = componentEndTime);
                   var _componentInfo = _candidateInfo,
@@ -3845,40 +3845,40 @@
                       entryName$jscomp$3 =
                         env$jscomp$2 === _env || void 0 === env$jscomp$2
                           ? name$jscomp$1
-                          : name$jscomp$1 + " [" + env$jscomp$2 + "]",
+                          : name$jscomp$1 + ' [' + env$jscomp$2 + ']',
                       properties$jscomp$2 = [
                         [
-                          "Aborted",
-                          "The stream was aborted before this Component finished rendering."
-                        ]
+                          'Aborted',
+                          'The stream was aborted before this Component finished rendering.',
+                        ],
                       ];
                     null != componentInfo$jscomp$4.key &&
                       addValueToProperties(
-                        "key",
+                        'key',
                         componentInfo$jscomp$4.key,
                         properties$jscomp$2,
                         0,
-                        ""
+                        '',
                       );
                     null != componentInfo$jscomp$4.props &&
                       addObjectToProperties(
                         componentInfo$jscomp$4.props,
                         properties$jscomp$2,
                         0,
-                        ""
+                        '',
                       );
-                    performance.measure("\u200b" + entryName$jscomp$3, {
+                    performance.measure('\u200b' + entryName$jscomp$3, {
                       start: 0 > startTime$jscomp$5 ? 0 : startTime$jscomp$5,
                       end: childrenEndTime$jscomp$3,
                       detail: {
                         devtools: {
-                          color: "warning",
+                          color: 'warning',
                           track: trackNames[trackIdx$jscomp$4],
-                          trackGroup: "Server Components \u269b",
-                          tooltipText: entryName$jscomp$3 + " Aborted",
-                          properties: properties$jscomp$2
-                        }
-                      }
+                          trackGroup: 'Server Components \u269b',
+                          tooltipText: entryName$jscomp$3 + ' Aborted',
+                          properties: properties$jscomp$2,
+                        },
+                      },
                     });
                   }
                   componentEndTime = time;
@@ -3900,12 +3900,12 @@
                     rootEnv$jscomp$0 = _env2;
                   if (supportsUserTiming && 0 < endTime$jscomp$1) {
                     var entryName$jscomp$4 =
-                        "await " +
+                        'await ' +
                         getIOShortName(
                           asyncInfo$jscomp$1.awaited,
-                          "",
+                          '',
                           asyncInfo$jscomp$1.env,
-                          rootEnv$jscomp$0
+                          rootEnv$jscomp$0,
                         ),
                       debugTask$jscomp$2 =
                         asyncInfo$jscomp$1.debugTask ||
@@ -3914,10 +3914,10 @@
                       var tooltipText$jscomp$0 =
                         getIOLongName(
                           asyncInfo$jscomp$1.awaited,
-                          "",
+                          '',
                           asyncInfo$jscomp$1.env,
-                          rootEnv$jscomp$0
-                        ) + " Aborted";
+                          rootEnv$jscomp$0,
+                        ) + ' Aborted';
                       debugTask$jscomp$2.run(
                         performance.measure.bind(
                           performance,
@@ -3928,20 +3928,20 @@
                             end: endTime$jscomp$1,
                             detail: {
                               devtools: {
-                                color: "warning",
+                                color: 'warning',
                                 track: trackNames[trackIdx$jscomp$5],
-                                trackGroup: "Server Components \u269b",
+                                trackGroup: 'Server Components \u269b',
                                 properties: [
                                   [
-                                    "Aborted",
-                                    "The stream was aborted before this Promise resolved."
-                                  ]
+                                    'Aborted',
+                                    'The stream was aborted before this Promise resolved.',
+                                  ],
                                 ],
-                                tooltipText: tooltipText$jscomp$0
-                              }
-                            }
-                          }
-                        )
+                                tooltipText: tooltipText$jscomp$0,
+                              },
+                            },
+                          },
+                        ),
                       );
                     } else
                       console.timeStamp(
@@ -3949,8 +3949,8 @@
                         0 > startTime$jscomp$6 ? 0 : startTime$jscomp$6,
                         endTime$jscomp$1,
                         trackNames[trackIdx$jscomp$5],
-                        "Server Components \u269b",
-                        "warning"
+                        'Server Components \u269b',
+                        'warning',
                       );
                   }
                 }
@@ -3973,7 +3973,7 @@
             rootChunk,
             0,
             -Infinity,
-            -Infinity
+            -Infinity,
           ));
       }
     }
@@ -3983,7 +3983,7 @@
       id,
       tag,
       buffer,
-      chunk
+      chunk,
     ) {
       switch (tag) {
         case 65:
@@ -3991,7 +3991,7 @@
             response,
             id,
             mergeBuffer(buffer, chunk).buffer,
-            streamState
+            streamState,
           );
           return;
         case 79:
@@ -4002,7 +4002,7 @@
             chunk,
             Int8Array,
             1,
-            streamState
+            streamState,
           );
           return;
         case 111:
@@ -4010,7 +4010,7 @@
             response,
             id,
             0 === buffer.length ? chunk : mergeBuffer(buffer, chunk),
-            streamState
+            streamState,
           );
           return;
         case 85:
@@ -4021,7 +4021,7 @@
             chunk,
             Uint8ClampedArray,
             1,
-            streamState
+            streamState,
           );
           return;
         case 83:
@@ -4032,7 +4032,7 @@
             chunk,
             Int16Array,
             2,
-            streamState
+            streamState,
           );
           return;
         case 115:
@@ -4043,7 +4043,7 @@
             chunk,
             Uint16Array,
             2,
-            streamState
+            streamState,
           );
           return;
         case 76:
@@ -4054,7 +4054,7 @@
             chunk,
             Int32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 108:
@@ -4065,7 +4065,7 @@
             chunk,
             Uint32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 71:
@@ -4076,7 +4076,7 @@
             chunk,
             Float32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 103:
@@ -4087,7 +4087,7 @@
             chunk,
             Float64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 77:
@@ -4098,7 +4098,7 @@
             chunk,
             BigInt64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 109:
@@ -4109,7 +4109,7 @@
             chunk,
             BigUint64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 86:
@@ -4120,12 +4120,12 @@
             chunk,
             DataView,
             1,
-            streamState
+            streamState,
           );
           return;
       }
       for (
-        var stringDecoder = response._stringDecoder, row = "", i = 0;
+        var stringDecoder = response._stringDecoder, row = '', i = 0;
         i < buffer.length;
         i++
       )
@@ -4144,42 +4144,42 @@
           response = JSON.parse(streamState, response._fromJSON);
           streamState = ReactDOMSharedInternals.d;
           switch (id) {
-            case "D":
+            case 'D':
               streamState.D(response);
               break;
-            case "C":
-              "string" === typeof response
+            case 'C':
+              'string' === typeof response
                 ? streamState.C(response)
                 : streamState.C(response[0], response[1]);
               break;
-            case "L":
+            case 'L':
               id = response[0];
               row = response[1];
               3 === response.length
                 ? streamState.L(id, row, response[2])
                 : streamState.L(id, row);
               break;
-            case "m":
-              "string" === typeof response
+            case 'm':
+              'string' === typeof response
                 ? streamState.m(response)
                 : streamState.m(response[0], response[1]);
               break;
-            case "X":
-              "string" === typeof response
+            case 'X':
+              'string' === typeof response
                 ? streamState.X(response)
                 : streamState.X(response[0], response[1]);
               break;
-            case "S":
-              "string" === typeof response
+            case 'S':
+              'string' === typeof response
                 ? streamState.S(response)
                 : streamState.S(
                     response[0],
                     0 === response[1] ? void 0 : response[1],
-                    3 === response.length ? response[2] : void 0
+                    3 === response.length ? response[2] : void 0,
                   );
               break;
-            case "M":
-              "string" === typeof response
+            case 'M':
+              'string' === typeof response
                 ? streamState.M(response)
                 : streamState.M(response[0], response[1]);
           }
@@ -4193,16 +4193,16 @@
           chunk
             ? (resolveChunkDebugInfo(streamState, chunk),
               triggerErrorOnChunk(response, chunk, error))
-            : ((response = new ReactPromise("rejected", null, error)),
+            : ((response = new ReactPromise('rejected', null, error)),
               resolveChunkDebugInfo(streamState, response),
               tag.set(id, response));
           break;
         case 84:
           tag = response._chunks;
-          (chunk = tag.get(id)) && "pending" !== chunk.status
+          (chunk = tag.get(id)) && 'pending' !== chunk.status
             ? chunk.reason.enqueueValue(row)
             : (chunk && releasePendingChunk(response, chunk),
-              (response = new ReactPromise("fulfilled", row, null)),
+              (response = new ReactPromise('fulfilled', row, null)),
               resolveChunkDebugInfo(streamState, response),
               tag.set(id, response));
           break;
@@ -4211,24 +4211,24 @@
           break;
         case 68:
           id = getChunk(response, id);
-          "fulfilled" !== id.status &&
-            "rejected" !== id.status &&
-            "halted" !== id.status &&
-            "blocked" !== id.status &&
-            "resolved_module" !== id.status &&
+          'fulfilled' !== id.status &&
+            'rejected' !== id.status &&
+            'halted' !== id.status &&
+            'blocked' !== id.status &&
+            'resolved_module' !== id.status &&
             ((streamState = id._debugChunk),
             (tag = createResolvedModelChunk(response, row)),
             (tag._debugChunk = streamState),
             (id._debugChunk = tag),
             initializeDebugChunk(response, id),
-            "blocked" !== tag.status ||
+            'blocked' !== tag.status ||
               (void 0 !== response._debugChannel &&
                 response._debugChannel.hasReadable) ||
               '"' !== row[0] ||
-              "$" !== row[1] ||
-              ((streamState = row.slice(2, row.length - 1).split(":")),
+              '$' !== row[1] ||
+              ((streamState = row.slice(2, row.length - 1).split(':')),
               (streamState = parseInt(streamState[0], 16)),
-              "pending" === getChunk(response, streamState).status &&
+              'pending' === getChunk(response, streamState).status &&
                 (id._debugChunk = null)));
           break;
         case 74:
@@ -4241,7 +4241,7 @@
           startReadableStream(response, id, void 0, streamState);
           break;
         case 114:
-          startReadableStream(response, id, "bytes", streamState);
+          startReadableStream(response, id, 'bytes', streamState);
           break;
         case 88:
           startAsyncIterable(response, id, !1, streamState);
@@ -4251,20 +4251,20 @@
           break;
         case 67:
           (response = response._chunks.get(id)) &&
-            "fulfilled" === response.status &&
-            response.reason.close("" === row ? '"$undefined"' : row);
+            'fulfilled' === response.status &&
+            response.reason.close('' === row ? '"$undefined"' : row);
           break;
         default:
-          if ("" === row) {
+          if ('' === row) {
             if (
               ((streamState = response._chunks),
               (row = streamState.get(id)) ||
                 streamState.set(id, (row = createPendingChunk(response))),
-              "pending" === row.status || "blocked" === row.status)
+              'pending' === row.status || 'blocked' === row.status)
             )
               releasePendingChunk(response, row),
                 (response = row),
-                (response.status = "halted"),
+                (response.status = 'halted'),
                 (response.value = null),
                 (response.reason = null);
           } else
@@ -4350,7 +4350,7 @@
                 weakResponse,
                 rowTag,
                 buffer,
-                rowLength
+                rowLength,
               ),
               (i = lastIdx),
               3 === rowState && i++,
@@ -4371,9 +4371,9 @@
     }
     function createFromJSONCallback(response) {
       return function (key, value) {
-        if ("string" === typeof value)
+        if ('string' === typeof value)
           return parseModelString(response, this, key, value);
-        if ("object" === typeof value && null !== value) {
+        if ('object' === typeof value && null !== value) {
           if (value[0] === REACT_ELEMENT_TYPE)
             b: {
               var owner = value[4],
@@ -4384,46 +4384,46 @@
                 type: value[1],
                 key: value[2],
                 props: value[3],
-                _owner: void 0 === owner ? null : owner
+                _owner: void 0 === owner ? null : owner,
               };
-              Object.defineProperty(value, "ref", {
+              Object.defineProperty(value, 'ref', {
                 enumerable: !1,
-                get: nullRefGetter
+                get: nullRefGetter,
               });
               value._store = {};
-              Object.defineProperty(value._store, "validated", {
+              Object.defineProperty(value._store, 'validated', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: key
+                value: key,
               });
-              Object.defineProperty(value, "_debugInfo", {
+              Object.defineProperty(value, '_debugInfo', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: null
+                value: null,
               });
-              Object.defineProperty(value, "_debugStack", {
+              Object.defineProperty(value, '_debugStack', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: void 0 === stack ? null : stack
+                value: void 0 === stack ? null : stack,
               });
-              Object.defineProperty(value, "_debugTask", {
+              Object.defineProperty(value, '_debugTask', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: null
+                value: null,
               });
               if (null !== initializingHandler) {
                 owner = initializingHandler;
                 initializingHandler = owner.parent;
                 if (owner.errored) {
-                  stack = new ReactPromise("rejected", null, owner.reason);
+                  stack = new ReactPromise('rejected', null, owner.reason);
                   initializeElement(response, value, null);
                   owner = {
-                    name: getComponentNameFromType(value.type) || "",
-                    owner: value._owner
+                    name: getComponentNameFromType(value.type) || '',
+                    owner: value._owner,
                   };
                   owner.debugStack = value._debugStack;
                   supportsCreateTask && (owner.debugTask = value._debugTask);
@@ -4432,7 +4432,7 @@
                   break b;
                 }
                 if (0 < owner.deps) {
-                  stack = new ReactPromise("blocked", null, null);
+                  stack = new ReactPromise('blocked', null, null);
                   owner.value = value;
                   owner.chunk = stack;
                   key = createLazyChunkWrapper(stack, key);
@@ -4451,16 +4451,16 @@
       };
     }
     function close(weakResponse) {
-      reportGlobalError(weakResponse, Error("Connection closed."));
+      reportGlobalError(weakResponse, Error('Connection closed.'));
     }
     function createDebugCallbackFromWritableStream(debugWritable) {
       var textEncoder = new TextEncoder(),
         writer = debugWritable.getWriter();
       return function (message) {
-        "" === message
+        '' === message
           ? writer.close()
           : writer
-              .write(textEncoder.encode(message + "\n"))
+              .write(textEncoder.encode(message + '\n'))
               .catch(console.error);
       };
     }
@@ -4472,9 +4472,9 @@
               callback:
                 void 0 !== options.debugChannel.writable
                   ? createDebugCallbackFromWritableStream(
-                      options.debugChannel.writable
+                      options.debugChannel.writable,
                     )
-                  : null
+                  : null,
             }
           : void 0;
       return new ResponseInstance(
@@ -4490,13 +4490,13 @@
         options && options.findSourceMapURL ? options.findSourceMapURL : void 0,
         options ? !1 !== options.replayConsoleLogs : !0,
         options && options.environmentName ? options.environmentName : void 0,
-        debugChannel
+        debugChannel,
       )._weakResponse;
     }
     function startReadingFromUniversalStream(
       response$jscomp$0,
       stream,
-      onDone
+      onDone,
     ) {
       function progress(_ref) {
         var value = _ref.value;
@@ -4505,9 +4505,9 @@
           processBinaryChunk(
             response$jscomp$0,
             streamState,
-            new Uint8Array(value)
+            new Uint8Array(value),
           );
-        else if ("string" === typeof value) {
+        else if ('string' === typeof value) {
           if (
             ((_ref = streamState), void 0 !== response$jscomp$0.weak.deref())
           ) {
@@ -4566,23 +4566,23 @@
                         (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
                   continue;
                 case 3:
-                  lastIdx = value.indexOf("\n", i);
+                  lastIdx = value.indexOf('\n', i);
                   break;
                 case 4:
                   if (84 !== rowTag)
                     throw Error(
-                      "Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams."
+                      'Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams.',
                     );
                   if (rowLength < value.length || value.length > 3 * rowLength)
                     throw Error(
-                      "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+                      'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
                     );
                   lastIdx = value.length;
               }
               if (-1 < lastIdx) {
                 if (0 < buffer.length)
                   throw Error(
-                    "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+                    'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
                   );
                 i = value.slice(i, lastIdx);
                 processFullStringRow(response, _ref, rowID, rowTag, i);
@@ -4592,7 +4592,7 @@
                 buffer.length = 0;
               } else if (value.length !== i)
                 throw Error(
-                  "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+                  'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
                 );
             }
             _ref._rowState = rowState;
@@ -4624,8 +4624,8 @@
         reader = stream.getReader();
       reader.read().then(progress).catch(error);
     }
-    var React = require("react"),
-      ReactDOM = require("react-dom"),
+    var React = require('react'),
+      ReactDOM = require('react-dom'),
       decoderOptions = { stream: !0 },
       bind = Function.prototype.bind,
       chunkCache = new Map(),
@@ -4640,26 +4640,26 @@
     var chunkIOInfoCache = new Map(),
       ReactDOMSharedInternals =
         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
-      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
+      REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+      REACT_PORTAL_TYPE = Symbol.for('react.portal'),
+      REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+      REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode'),
+      REACT_PROFILER_TYPE = Symbol.for('react.profiler'),
+      REACT_CONSUMER_TYPE = Symbol.for('react.consumer'),
+      REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+      REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+      REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+      REACT_MEMO_TYPE = Symbol.for('react.memo'),
+      REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+      REACT_ACTIVITY_TYPE = Symbol.for('react.activity'),
       MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
       ASYNC_ITERATOR = Symbol.asyncIterator,
       isArrayImpl = Array.isArray,
       getPrototypeOf = Object.getPrototypeOf,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
-      CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"),
+      CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference'),
       ObjectPrototype = Object.prototype,
       knownServerReferences = new WeakMap(),
       fakeServerFunctionIdx = 0,
@@ -4667,19 +4667,19 @@
         /^ {3} at (?:(.+) \((.+):(\d+):(\d+)\)|(?:async )?(.+):(\d+):(\d+))$/,
       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\d+):(\d+)/,
       hasOwnProperty = Object.prototype.hasOwnProperty,
-      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
+      REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference'),
       supportsUserTiming =
-        "undefined" !== typeof console &&
-        "function" === typeof console.timeStamp &&
-        "undefined" !== typeof performance &&
-        "function" === typeof performance.measure,
+        'undefined' !== typeof console &&
+        'function' === typeof console.timeStamp &&
+        'undefined' !== typeof performance &&
+        'function' === typeof performance.measure,
       trackNames =
-        "Primary Parallel Parallel\u200b Parallel\u200b\u200b Parallel\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b".split(
-          " "
+        'Primary Parallel Parallel\u200b Parallel\u200b\u200b Parallel\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b'.split(
+          ' ',
         ),
       prefix,
       suffix;
-    new ("function" === typeof WeakMap ? WeakMap : Map)();
+    new ('function' === typeof WeakMap ? WeakMap : Map)();
     var ReactSharedInteralsServer =
         React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
       ReactSharedInternals =
@@ -4689,10 +4689,10 @@
     ReactPromise.prototype.then = function (resolve, reject) {
       var _this = this;
       switch (this.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(this);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(this);
       }
       var resolveCallback = resolve,
@@ -4709,26 +4709,26 @@
         });
       wrapperPromise.then(resolveCallback, rejectCallback);
       switch (this.status) {
-        case "fulfilled":
-          "function" === typeof resolve && resolve(this.value);
+        case 'fulfilled':
+          'function' === typeof resolve && resolve(this.value);
           break;
-        case "pending":
-        case "blocked":
-          "function" === typeof resolve &&
+        case 'pending':
+        case 'blocked':
+          'function' === typeof resolve &&
             (null === this.value && (this.value = []),
             this.value.push(resolve));
-          "function" === typeof reject &&
+          'function' === typeof reject &&
             (null === this.reason && (this.reason = []),
             this.reason.push(reject));
           break;
-        case "halted":
+        case 'halted':
           break;
         default:
-          "function" === typeof reject && reject(this.reason);
+          'function' === typeof reject && reject(this.reason);
       }
     };
     var debugChannelRegistry =
-        "function" === typeof FinalizationRegistry
+        'function' === typeof FinalizationRegistry
           ? new FinalizationRegistry(closeDebugChannel)
           : null,
       initializingHandler = null,
@@ -4745,13 +4745,13 @@
             stack,
             environmentName,
             !1,
-            fakeJSXCallSite
+            fakeJSXCallSite,
           )();
-        }
+        },
       },
       createFakeJSXCallStackInDEV =
         createFakeJSXCallStack.react_stack_bottom_frame.bind(
-          createFakeJSXCallStack
+          createFakeJSXCallStack,
         ),
       currentOwnerInDEV = null,
       replayConsoleWithCallStack = {
@@ -4768,40 +4768,40 @@
             a: {
               var offset = 0;
               switch (methodName) {
-                case "dir":
-                case "dirxml":
-                case "groupEnd":
-                case "table":
+                case 'dir':
+                case 'dirxml':
+                case 'groupEnd':
+                case 'table':
                   var JSCompiler_inline_result = bind.apply(
                     console[methodName],
-                    [console].concat(payload)
+                    [console].concat(payload),
                   );
                   break a;
-                case "assert":
+                case 'assert':
                   offset = 1;
               }
               var newArgs = payload.slice(0);
-              "string" === typeof newArgs[offset]
+              'string' === typeof newArgs[offset]
                 ? newArgs.splice(
                     offset,
                     1,
-                    "%c%s%c " + newArgs[offset],
-                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
-                    " " + env + " ",
-                    ""
+                    '%c%s%c ' + newArgs[offset],
+                    'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px',
+                    ' ' + env + ' ',
+                    '',
                   )
                 : newArgs.splice(
                     offset,
                     0,
-                    "%c%s%c",
-                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
-                    " " + env + " ",
-                    ""
+                    '%c%s%c',
+                    'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px',
+                    ' ' + env + ' ',
+                    '',
                   );
               newArgs.unshift(console);
               JSCompiler_inline_result = bind.apply(
                 console[methodName],
-                newArgs
+                newArgs,
               );
             }
             var callStack = buildFakeCallStack(
@@ -4809,7 +4809,7 @@
               stackTrace,
               env,
               !1,
-              JSCompiler_inline_result
+              JSCompiler_inline_result,
             );
             if (null != owner) {
               var task = initializeFakeTask(response, owner);
@@ -4825,31 +4825,31 @@
             (currentOwnerInDEV = null),
               (ReactSharedInternals.getCurrentStack = prevStack);
           }
-        }
+        },
       },
       replayConsoleWithCallStackInDEV =
         replayConsoleWithCallStack.react_stack_bottom_frame.bind(
-          replayConsoleWithCallStack
+          replayConsoleWithCallStack,
         );
     (function (internals) {
-      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
+      if ('undefined' === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
       var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
       if (hook.isDisabled || !hook.supportsFlight) return !0;
       try {
         hook.inject(internals);
       } catch (err) {
-        console.error("React instrumentation encountered an error: %o.", err);
+        console.error('React instrumentation encountered an error: %o.', err);
       }
       return hook.checkDCE ? !0 : !1;
     })({
       bundleType: 1,
-      version: "19.2.0",
-      rendererPackageName: "react-server-dom-webpack",
+      version: '19.2.0',
+      rendererPackageName: 'react-server-dom-webpack',
       currentDispatcherRef: ReactSharedInternals,
-      reconcilerVersion: "19.2.0",
+      reconcilerVersion: '19.2.0',
       getCurrentComponentInfo: function () {
         return currentOwnerInDEV;
-      }
+      },
     });
     exports.createFromFetch = function (promiseForResponse, options) {
       var response = createResponseFromOptions(options);
@@ -4867,7 +4867,7 @@
             startReadingFromUniversalStream(
               response,
               options.debugChannel.readable,
-              handleDone
+              handleDone,
             );
             startReadingFromStream(response, r.body, handleDone, r);
           } else
@@ -4875,12 +4875,12 @@
               response,
               r.body,
               close.bind(null, response),
-              r
+              r,
             );
         },
         function (e) {
           reportGlobalError(response, e);
-        }
+        },
       );
       return getRoot(response);
     };
@@ -4894,7 +4894,7 @@
         startReadingFromUniversalStream(
           response,
           options.debugChannel.readable,
-          handleDone
+          handleDone,
         );
         startReadingFromStream(response, stream, handleDone, stream);
       } else
@@ -4902,7 +4902,7 @@
           response,
           stream,
           close.bind(null, response),
-          stream
+          stream,
         );
       return getRoot(response);
     };
@@ -4911,13 +4911,13 @@
       callServer,
       encodeFormAction,
       findSourceMapURL,
-      functionName
+      functionName,
     ) {
       function action() {
         var args = Array.prototype.slice.call(arguments);
         return callServer(id, args);
       }
-      var location = parseStackLocation(Error("react-stack-top-frame"));
+      var location = parseStackLocation(Error('react-stack-top-frame'));
       if (null !== location) {
         encodeFormAction = location[1];
         var line = location[2];
@@ -4925,15 +4925,15 @@
         findSourceMapURL =
           null == findSourceMapURL
             ? null
-            : findSourceMapURL(encodeFormAction, "Client");
+            : findSourceMapURL(encodeFormAction, 'Client');
         action = createFakeServerFunction(
-          functionName || "",
+          functionName || '',
           encodeFormAction,
           findSourceMapURL,
           line,
           location,
-          "Client",
-          action
+          'Client',
+          action,
         );
       }
       registerBoundServerReference(action, id, null);
@@ -4946,12 +4946,12 @@
       return new Promise(function (resolve, reject) {
         var abort = processReply(
           value,
-          "",
+          '',
           options && options.temporaryReferences
             ? options.temporaryReferences
             : void 0,
           resolve,
-          reject
+          reject,
         );
         if (options && options.signal) {
           var signal = options.signal;
@@ -4959,9 +4959,9 @@
           else {
             var listener = function () {
               abort(signal.reason);
-              signal.removeEventListener("abort", listener);
+              signal.removeEventListener('abort', listener);
             };
-            signal.addEventListener("abort", listener);
+            signal.addEventListener('abort', listener);
           }
         }
       });
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.browser.production.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.production.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.browser.production.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.production.js	2025-12-17 14:32:44
@@ -8,8 +8,8 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-var ReactDOM = require("react-dom"),
+'use strict';
+var ReactDOM = require('react-dom'),
   decoderOptions = { stream: !0 };
 function resolveClientReference(bundlerConfig, metadata) {
   if (bundlerConfig) {
@@ -17,12 +17,12 @@
     if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))
       moduleExports = bundlerConfig.name;
     else {
-      bundlerConfig = moduleExports && moduleExports["*"];
+      bundlerConfig = moduleExports && moduleExports['*'];
       if (!bundlerConfig)
         throw Error(
           'Could not find the module "' +
             metadata[0] +
-            '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'
+            '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.',
         );
       moduleExports = metadata[2];
     }
@@ -33,11 +33,11 @@
   return metadata;
 }
 function resolveServerReference(bundlerConfig, id) {
-  var name = "",
+  var name = '',
     resolvedModuleData = bundlerConfig[id];
   if (resolvedModuleData) name = resolvedModuleData.name;
   else {
-    var idx = id.lastIndexOf("#");
+    var idx = id.lastIndexOf('#');
     -1 !== idx &&
       ((name = id.slice(idx + 1)),
       (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -45,7 +45,7 @@
       throw Error(
         'Could not find the module "' +
           id +
-          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
       );
   }
   return resolvedModuleData.async
@@ -55,17 +55,17 @@
 var chunkCache = new Map();
 function requireAsyncModule(id) {
   var promise = __webpack_require__(id);
-  if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+  if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
     return null;
   promise.then(
     function (value) {
-      promise.status = "fulfilled";
+      promise.status = 'fulfilled';
       promise.value = value;
     },
     function (reason) {
-      promise.status = "rejected";
+      promise.status = 'rejected';
       promise.reason = reason;
-    }
+    },
   );
   return promise;
 }
@@ -96,13 +96,13 @@
 }
 function requireModule(metadata) {
   var moduleExports = __webpack_require__(metadata[0]);
-  if (4 === metadata.length && "function" === typeof moduleExports.then)
-    if ("fulfilled" === moduleExports.status)
+  if (4 === metadata.length && 'function' === typeof moduleExports.then)
+    if ('fulfilled' === moduleExports.status)
       moduleExports = moduleExports.value;
     else throw moduleExports.reason;
-  return "*" === metadata[2]
+  return '*' === metadata[2]
     ? moduleExports
-    : "" === metadata[2]
+    : '' === metadata[2]
       ? moduleExports.__esModule
         ? moduleExports.default
         : moduleExports
@@ -118,15 +118,15 @@
 };
 var ReactDOMSharedInternals =
     ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
-  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
+  REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+  REACT_LAZY_TYPE = Symbol.for('react.lazy'),
   MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
 function getIteratorFn(maybeIterable) {
-  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  if (null === maybeIterable || 'object' !== typeof maybeIterable) return null;
   maybeIterable =
     (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-    maybeIterable["@@iterator"];
-  return "function" === typeof maybeIterable ? maybeIterable : null;
+    maybeIterable['@@iterator'];
+  return 'function' === typeof maybeIterable ? maybeIterable : null;
 }
 var ASYNC_ITERATOR = Symbol.asyncIterator,
   isArrayImpl = Array.isArray,
@@ -136,33 +136,33 @@
 function serializeNumber(number) {
   return Number.isFinite(number)
     ? 0 === number && -Infinity === 1 / number
-      ? "$-0"
+      ? '$-0'
       : number
     : Infinity === number
-      ? "$Infinity"
+      ? '$Infinity'
       : -Infinity === number
-        ? "$-Infinity"
-        : "$NaN";
+        ? '$-Infinity'
+        : '$NaN';
 }
 function processReply(
   root,
   formFieldPrefix,
   temporaryReferences,
   resolve,
-  reject
+  reject,
 ) {
   function serializeTypedArray(tag, typedArray) {
     typedArray = new Blob([
       new Uint8Array(
         typedArray.buffer,
         typedArray.byteOffset,
-        typedArray.byteLength
-      )
+        typedArray.byteLength,
+      ),
     ]);
     var blobId = nextPartId++;
     null === formData && (formData = new FormData());
     formData.append(formFieldPrefix + blobId, typedArray);
-    return "$" + tag + blobId.toString(16);
+    return '$' + tag + blobId.toString(16);
   }
   function serializeBinaryReader(reader) {
     function progress(entry) {
@@ -171,9 +171,9 @@
           data.append(formFieldPrefix + entry, new Blob(buffer)),
           data.append(
             formFieldPrefix + streamId,
-            '"$o' + entry.toString(16) + '"'
+            '"$o' + entry.toString(16) + '"',
           ),
-          data.append(formFieldPrefix + streamId, "C"),
+          data.append(formFieldPrefix + streamId, 'C'),
           pendingParts--,
           0 === pendingParts && resolve(data))
         : (buffer.push(entry.value),
@@ -185,12 +185,12 @@
     var streamId = nextPartId++,
       buffer = [];
     reader.read(new Uint8Array(1024)).then(progress, reject);
-    return "$r" + streamId.toString(16);
+    return '$r' + streamId.toString(16);
   }
   function serializeReader(reader) {
     function progress(entry) {
       if (entry.done)
-        data.append(formFieldPrefix + streamId, "C"),
+        data.append(formFieldPrefix + streamId, 'C'),
           pendingParts--,
           0 === pendingParts && resolve(data);
       else
@@ -207,11 +207,11 @@
     pendingParts++;
     var streamId = nextPartId++;
     reader.read().then(progress, reject);
-    return "$R" + streamId.toString(16);
+    return '$R' + streamId.toString(16);
   }
   function serializeReadableStream(stream) {
     try {
-      var binaryReader = stream.getReader({ mode: "byob" });
+      var binaryReader = stream.getReader({ mode: 'byob' });
     } catch (x) {
       return serializeReader(stream.getReader());
     }
@@ -221,11 +221,11 @@
     function progress(entry) {
       if (entry.done) {
         if (void 0 === entry.value)
-          data.append(formFieldPrefix + streamId, "C");
+          data.append(formFieldPrefix + streamId, 'C');
         else
           try {
             var partJSON = JSON.stringify(entry.value, resolveToJSON);
-            data.append(formFieldPrefix + streamId, "C" + partJSON);
+            data.append(formFieldPrefix + streamId, 'C' + partJSON);
           } catch (x) {
             reject(x);
             return;
@@ -247,23 +247,23 @@
     var streamId = nextPartId++;
     iterable = iterable === iterator;
     iterator.next().then(progress, reject);
-    return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+    return '$' + (iterable ? 'x' : 'X') + streamId.toString(16);
   }
   function resolveToJSON(key, value) {
     if (null === value) return null;
-    if ("object" === typeof value) {
+    if ('object' === typeof value) {
       switch (value.$$typeof) {
         case REACT_ELEMENT_TYPE:
-          if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+          if (void 0 !== temporaryReferences && -1 === key.indexOf(':')) {
             var parentReference = writtenObjects.get(this);
             if (void 0 !== parentReference)
               return (
-                temporaryReferences.set(parentReference + ":" + key, value),
-                "$T"
+                temporaryReferences.set(parentReference + ':' + key, value),
+                '$T'
               );
           }
           throw Error(
-            "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+            'React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.',
           );
         case REACT_LAZY_TYPE:
           parentReference = value._payload;
@@ -275,12 +275,12 @@
               lazyId = nextPartId++,
               partJSON = serializeModel(resolvedModel, lazyId);
             formData.append(formFieldPrefix + lazyId, partJSON);
-            return "$" + lazyId.toString(16);
+            return '$' + lazyId.toString(16);
           } catch (x) {
             if (
-              "object" === typeof x &&
+              'object' === typeof x &&
               null !== x &&
-              "function" === typeof x.then
+              'function' === typeof x.then
             ) {
               pendingParts++;
               var lazyId$23 = nextPartId++;
@@ -296,7 +296,7 @@
                 }
               };
               x.then(parentReference, parentReference);
-              return "$" + lazyId$23.toString(16);
+              return '$' + lazyId$23.toString(16);
             }
             reject(x);
             return null;
@@ -304,7 +304,7 @@
             pendingParts--;
           }
       }
-      if ("function" === typeof value.then) {
+      if ('function' === typeof value.then) {
         null === formData && (formData = new FormData());
         pendingParts++;
         var promiseId = nextPartId++;
@@ -319,17 +319,17 @@
             reject(reason);
           }
         }, reject);
-        return "$@" + promiseId.toString(16);
+        return '$@' + promiseId.toString(16);
       }
       parentReference = writtenObjects.get(value);
       if (void 0 !== parentReference)
         if (modelRoot === value) modelRoot = null;
         else return parentReference;
       else
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
           ((parentReference = writtenObjects.get(this)),
           void 0 !== parentReference &&
-            ((key = parentReference + ":" + key),
+            ((key = parentReference + ':' + key),
             writtenObjects.set(value, key),
             void 0 !== temporaryReferences &&
               temporaryReferences.set(key, value)));
@@ -338,11 +338,11 @@
         null === formData && (formData = new FormData());
         var data$31 = formData;
         key = nextPartId++;
-        var prefix = formFieldPrefix + key + "_";
+        var prefix = formFieldPrefix + key + '_';
         value.forEach(function (originalValue, originalKey) {
           data$31.append(prefix + originalKey, originalValue);
         });
-        return "$K" + key.toString(16);
+        return '$K' + key.toString(16);
       }
       if (value instanceof Map)
         return (
@@ -350,7 +350,7 @@
           (parentReference = serializeModel(Array.from(value), key)),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + key, parentReference),
-          "$Q" + key.toString(16)
+          '$Q' + key.toString(16)
         );
       if (value instanceof Set)
         return (
@@ -358,7 +358,7 @@
           (parentReference = serializeModel(Array.from(value), key)),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + key, parentReference),
-          "$W" + key.toString(16)
+          '$W' + key.toString(16)
         );
       if (value instanceof ArrayBuffer)
         return (
@@ -366,29 +366,29 @@
           (parentReference = nextPartId++),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + parentReference, key),
-          "$A" + parentReference.toString(16)
+          '$A' + parentReference.toString(16)
         );
-      if (value instanceof Int8Array) return serializeTypedArray("O", value);
-      if (value instanceof Uint8Array) return serializeTypedArray("o", value);
+      if (value instanceof Int8Array) return serializeTypedArray('O', value);
+      if (value instanceof Uint8Array) return serializeTypedArray('o', value);
       if (value instanceof Uint8ClampedArray)
-        return serializeTypedArray("U", value);
-      if (value instanceof Int16Array) return serializeTypedArray("S", value);
-      if (value instanceof Uint16Array) return serializeTypedArray("s", value);
-      if (value instanceof Int32Array) return serializeTypedArray("L", value);
-      if (value instanceof Uint32Array) return serializeTypedArray("l", value);
-      if (value instanceof Float32Array) return serializeTypedArray("G", value);
-      if (value instanceof Float64Array) return serializeTypedArray("g", value);
+        return serializeTypedArray('U', value);
+      if (value instanceof Int16Array) return serializeTypedArray('S', value);
+      if (value instanceof Uint16Array) return serializeTypedArray('s', value);
+      if (value instanceof Int32Array) return serializeTypedArray('L', value);
+      if (value instanceof Uint32Array) return serializeTypedArray('l', value);
+      if (value instanceof Float32Array) return serializeTypedArray('G', value);
+      if (value instanceof Float64Array) return serializeTypedArray('g', value);
       if (value instanceof BigInt64Array)
-        return serializeTypedArray("M", value);
+        return serializeTypedArray('M', value);
       if (value instanceof BigUint64Array)
-        return serializeTypedArray("m", value);
-      if (value instanceof DataView) return serializeTypedArray("V", value);
-      if ("function" === typeof Blob && value instanceof Blob)
+        return serializeTypedArray('m', value);
+      if (value instanceof DataView) return serializeTypedArray('V', value);
+      if ('function' === typeof Blob && value instanceof Blob)
         return (
           null === formData && (formData = new FormData()),
           (key = nextPartId++),
           formData.append(formFieldPrefix + key, value),
-          "$B" + key.toString(16)
+          '$B' + key.toString(16)
         );
       if ((key = getIteratorFn(value)))
         return (
@@ -397,20 +397,20 @@
             ? ((key = nextPartId++),
               (parentReference = serializeModel(
                 Array.from(parentReference),
-                key
+                key,
               )),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$i" + key.toString(16))
+              '$i' + key.toString(16))
             : Array.from(parentReference)
         );
       if (
-        "function" === typeof ReadableStream &&
+        'function' === typeof ReadableStream &&
         value instanceof ReadableStream
       )
         return serializeReadableStream(value);
       key = value[ASYNC_ITERATOR];
-      if ("function" === typeof key)
+      if ('function' === typeof key)
         return serializeAsyncIterable(value, key.call(value));
       key = getPrototypeOf(value);
       if (
@@ -419,72 +419,72 @@
       ) {
         if (void 0 === temporaryReferences)
           throw Error(
-            "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported."
+            'Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.',
           );
-        return "$T";
+        return '$T';
       }
       return value;
     }
-    if ("string" === typeof value) {
-      if ("Z" === value[value.length - 1] && this[key] instanceof Date)
-        return "$D" + value;
-      key = "$" === value[0] ? "$" + value : value;
+    if ('string' === typeof value) {
+      if ('Z' === value[value.length - 1] && this[key] instanceof Date)
+        return '$D' + value;
+      key = '$' === value[0] ? '$' + value : value;
       return key;
     }
-    if ("boolean" === typeof value) return value;
-    if ("number" === typeof value) return serializeNumber(value);
-    if ("undefined" === typeof value) return "$undefined";
-    if ("function" === typeof value) {
+    if ('boolean' === typeof value) return value;
+    if ('number' === typeof value) return serializeNumber(value);
+    if ('undefined' === typeof value) return '$undefined';
+    if ('function' === typeof value) {
       parentReference = knownServerReferences.get(value);
       if (void 0 !== parentReference)
         return (
           (key = JSON.stringify(
             { id: parentReference.id, bound: parentReference.bound },
-            resolveToJSON
+            resolveToJSON,
           )),
           null === formData && (formData = new FormData()),
           (parentReference = nextPartId++),
           formData.set(formFieldPrefix + parentReference, key),
-          "$F" + parentReference.toString(16)
+          '$F' + parentReference.toString(16)
         );
       if (
         void 0 !== temporaryReferences &&
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
         ((parentReference = writtenObjects.get(this)),
         void 0 !== parentReference)
       )
         return (
-          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+          temporaryReferences.set(parentReference + ':' + key, value), '$T'
         );
       throw Error(
-        "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+        'Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.',
       );
     }
-    if ("symbol" === typeof value) {
+    if ('symbol' === typeof value) {
       if (
         void 0 !== temporaryReferences &&
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
         ((parentReference = writtenObjects.get(this)),
         void 0 !== parentReference)
       )
         return (
-          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+          temporaryReferences.set(parentReference + ':' + key, value), '$T'
         );
       throw Error(
-        "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+        'Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.',
       );
     }
-    if ("bigint" === typeof value) return "$n" + value.toString(10);
+    if ('bigint' === typeof value) return '$n' + value.toString(10);
     throw Error(
-      "Type " +
+      'Type ' +
         typeof value +
-        " is not supported as an argument to a Server Function."
+        ' is not supported as an argument to a Server Function.',
     );
   }
   function serializeModel(model, id) {
-    "object" === typeof model &&
+    'object' === typeof model &&
       null !== model &&
-      ((id = "$" + id.toString(16)),
+      ((id = '$' + id.toString(16)),
       writtenObjects.set(model, id),
       void 0 !== temporaryReferences && temporaryReferences.set(id, model));
     modelRoot = model;
@@ -498,7 +498,7 @@
     json = serializeModel(root, 0);
   null === formData
     ? resolve(json)
-    : (formData.set(formFieldPrefix + "0", json),
+    : (formData.set(formFieldPrefix + '0', json),
       0 === pendingParts && resolve(formData));
   return function () {
     0 < pendingParts &&
@@ -511,14 +511,14 @@
     knownServerReferences.set(reference, {
       id: id,
       originalBind: reference.bind,
-      bound: bound
+      bound: bound,
     });
 }
 function createBoundServerReference(metaData, callServer) {
   function action() {
     var args = Array.prototype.slice.call(arguments);
     return bound
-      ? "fulfilled" === bound.status
+      ? 'fulfilled' === bound.status
         ? callServer(id, bound.value.concat(args))
         : Promise.resolve(bound).then(function (boundArgs) {
             return callServer(id, boundArgs.concat(args));
@@ -538,43 +538,43 @@
 ReactPromise.prototype = Object.create(Promise.prototype);
 ReactPromise.prototype.then = function (resolve, reject) {
   switch (this.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(this);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(this);
   }
   switch (this.status) {
-    case "fulfilled":
-      "function" === typeof resolve && resolve(this.value);
+    case 'fulfilled':
+      'function' === typeof resolve && resolve(this.value);
       break;
-    case "pending":
-    case "blocked":
-      "function" === typeof resolve &&
+    case 'pending':
+    case 'blocked':
+      'function' === typeof resolve &&
         (null === this.value && (this.value = []), this.value.push(resolve));
-      "function" === typeof reject &&
+      'function' === typeof reject &&
         (null === this.reason && (this.reason = []), this.reason.push(reject));
       break;
-    case "halted":
+    case 'halted':
       break;
     default:
-      "function" === typeof reject && reject(this.reason);
+      'function' === typeof reject && reject(this.reason);
   }
 };
 function readChunk(chunk) {
   switch (chunk.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(chunk);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(chunk);
   }
   switch (chunk.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return chunk.value;
-    case "pending":
-    case "blocked":
-    case "halted":
+    case 'pending':
+    case 'blocked':
+    case 'halted':
       throw chunk;
     default:
       throw chunk.reason;
@@ -583,7 +583,7 @@
 function wakeChunk(listeners, value) {
   for (var i = 0; i < listeners.length; i++) {
     var listener = listeners[i];
-    "function" === typeof listener
+    'function' === typeof listener
       ? listener(value)
       : fulfillReference(listener, value);
   }
@@ -591,7 +591,7 @@
 function rejectChunk(listeners, error) {
   for (var i = 0; i < listeners.length; i++) {
     var listener = listeners[i];
-    "function" === typeof listener
+    'function' === typeof listener
       ? listener(error)
       : rejectReference(listener, error);
   }
@@ -609,7 +609,7 @@
     ) {
       var listener = reference[referencedChunk];
       if (
-        "function" !== typeof listener &&
+        'function' !== typeof listener &&
         ((listener = resolveBlockedCycle(resolvedChunk, listener)),
         null !== listener)
       )
@@ -619,13 +619,13 @@
 }
 function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
   switch (chunk.status) {
-    case "fulfilled":
+    case 'fulfilled':
       wakeChunk(resolveListeners, chunk.value);
       break;
-    case "blocked":
+    case 'blocked':
       for (var i = 0; i < resolveListeners.length; i++) {
         var listener = resolveListeners[i];
-        if ("function" !== typeof listener) {
+        if ('function' !== typeof listener) {
           var cyclicHandler = resolveBlockedCycle(chunk, listener);
           null !== cyclicHandler &&
             (fulfillReference(listener, cyclicHandler.value),
@@ -636,7 +636,7 @@
               -1 !== listener && rejectListeners.splice(listener, 1)));
         }
       }
-    case "pending":
+    case 'pending':
       if (chunk.value)
         for (i = 0; i < resolveListeners.length; i++)
           chunk.value.push(resolveListeners[i]);
@@ -651,38 +651,38 @@
             chunk.reason.push(rejectListeners[resolveListeners]);
       } else chunk.reason = rejectListeners;
       break;
-    case "rejected":
+    case 'rejected':
       rejectListeners && rejectChunk(rejectListeners, chunk.reason);
   }
 }
 function triggerErrorOnChunk(response, chunk, error) {
-  "pending" !== chunk.status && "blocked" !== chunk.status
+  'pending' !== chunk.status && 'blocked' !== chunk.status
     ? chunk.reason.error(error)
     : ((response = chunk.reason),
-      (chunk.status = "rejected"),
+      (chunk.status = 'rejected'),
       (chunk.reason = error),
       null !== response && rejectChunk(response, error));
 }
 function createResolvedIteratorResultChunk(response, value, done) {
   return new ReactPromise(
-    "resolved_model",
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
-    response
+    'resolved_model',
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
+    response,
   );
 }
 function resolveIteratorResultChunk(response, chunk, value, done) {
   resolveModelChunk(
     response,
     chunk,
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}"
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
   );
 }
 function resolveModelChunk(response, chunk, value) {
-  if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+  if ('pending' !== chunk.status) chunk.reason.enqueueModel(value);
   else {
     var resolveListeners = chunk.value,
       rejectListeners = chunk.reason;
-    chunk.status = "resolved_model";
+    chunk.status = 'resolved_model';
     chunk.value = value;
     chunk.reason = response;
     null !== resolveListeners &&
@@ -691,10 +691,10 @@
   }
 }
 function resolveModuleChunk(response, chunk, value) {
-  if ("pending" === chunk.status || "blocked" === chunk.status) {
+  if ('pending' === chunk.status || 'blocked' === chunk.status) {
     response = chunk.value;
     var rejectListeners = chunk.reason;
-    chunk.status = "resolved_module";
+    chunk.status = 'resolved_module';
     chunk.value = value;
     null !== response &&
       (initializeModuleChunk(chunk),
@@ -707,7 +707,7 @@
   initializingHandler = null;
   var resolvedModel = chunk.value,
     response = chunk.reason;
-  chunk.status = "blocked";
+  chunk.status = 'blocked';
   chunk.value = null;
   chunk.reason = null;
   try {
@@ -720,7 +720,7 @@
         resolvedModel++
       ) {
         var listener = resolveListeners[resolvedModel];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(value)
           : fulfillReference(listener, value, chunk);
       }
@@ -732,10 +732,10 @@
         return;
       }
     }
-    chunk.status = "fulfilled";
+    chunk.status = 'fulfilled';
     chunk.value = value;
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   } finally {
     initializingHandler = prevHandler;
   }
@@ -743,17 +743,17 @@
 function initializeModuleChunk(chunk) {
   try {
     var value = requireModule(chunk.value);
-    chunk.status = "fulfilled";
+    chunk.status = 'fulfilled';
     chunk.value = value;
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   }
 }
 function reportGlobalError(weakResponse, error) {
   weakResponse._closed = !0;
   weakResponse._closedReason = error;
   weakResponse._chunks.forEach(function (chunk) {
-    "pending" === chunk.status &&
+    'pending' === chunk.status &&
       triggerErrorOnChunk(weakResponse, chunk, error);
   });
 }
@@ -765,8 +765,8 @@
     chunk = chunks.get(id);
   chunk ||
     ((chunk = response._closed
-      ? new ReactPromise("rejected", null, response._closedReason)
-      : new ReactPromise("pending", null, null)),
+      ? new ReactPromise('rejected', null, response._closedReason)
+      : new ReactPromise('pending', null, null)),
     chunks.set(id, chunk));
   return chunk;
 }
@@ -784,7 +784,7 @@
   ) {
     for (
       ;
-      "object" === typeof value &&
+      'object' === typeof value &&
       null !== value &&
       value.$$typeof === REACT_LAZY_TYPE;
 
@@ -793,23 +793,23 @@
         value = handler.value;
       else {
         switch (value.status) {
-          case "resolved_model":
+          case 'resolved_model':
             initializeModelChunk(value);
             break;
-          case "resolved_module":
+          case 'resolved_module':
             initializeModuleChunk(value);
         }
         switch (value.status) {
-          case "fulfilled":
+          case 'fulfilled':
             value = value.value;
             continue;
-          case "blocked":
+          case 'blocked':
             var cyclicHandler = resolveBlockedCycle(value, reference);
             if (null !== cyclicHandler) {
               value = cyclicHandler.value;
               continue;
             }
-          case "pending":
+          case 'pending':
             path.splice(0, i - 1);
             null === value.value
               ? (value.value = [reference])
@@ -818,7 +818,7 @@
               ? (value.reason = [reference])
               : value.reason.push(reference);
             return;
-          case "halted":
+          case 'halted':
             return;
           default:
             rejectReference(reference, value.reason);
@@ -829,7 +829,7 @@
   }
   for (
     ;
-    "object" === typeof value &&
+    'object' === typeof value &&
     null !== value &&
     value.$$typeof === REACT_LAZY_TYPE;
 
@@ -838,14 +838,14 @@
       value = handler.value;
     else {
       switch (reference.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(reference);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(reference);
       }
       switch (reference.status) {
-        case "fulfilled":
+        case 'fulfilled':
           value = reference.value;
           continue;
       }
@@ -853,24 +853,24 @@
     }
   response = map(response, value, parentObject, key);
   parentObject[key] = response;
-  "" === key && null === handler.value && (handler.value = response);
+  '' === key && null === handler.value && (handler.value = response);
   if (
     parentObject[0] === REACT_ELEMENT_TYPE &&
-    "object" === typeof handler.value &&
+    'object' === typeof handler.value &&
     null !== handler.value &&
     handler.value.$$typeof === REACT_ELEMENT_TYPE
   )
     switch (((parentObject = handler.value), key)) {
-      case "3":
+      case '3':
         parentObject.props = response;
     }
   handler.deps--;
   0 === handler.deps &&
     ((key = handler.chunk),
     null !== key &&
-      "blocked" === key.status &&
+      'blocked' === key.status &&
       ((parentObject = key.value),
-      (key.status = "fulfilled"),
+      (key.status = 'fulfilled'),
       (key.value = handler.value),
       (key.reason = handler.reason),
       null !== parentObject && wakeChunk(parentObject, handler.value)));
@@ -884,7 +884,7 @@
     (handler.reason = error),
     (handler = handler.chunk),
     null !== handler &&
-      "blocked" === handler.status &&
+      'blocked' === handler.status &&
       triggerErrorOnChunk(reference, handler, error));
 }
 function waitForReference(
@@ -893,7 +893,7 @@
   key,
   response,
   map,
-  path
+  path,
 ) {
   if (initializingHandler) {
     var handler = initializingHandler;
@@ -905,7 +905,7 @@
       value: null,
       reason: null,
       deps: 1,
-      errored: !1
+      errored: !1,
     };
   parentObject = {
     response: response,
@@ -913,7 +913,7 @@
     parentObject: parentObject,
     key: key,
     map: map,
-    path: path
+    path: path,
   };
   null === referencedChunk.value
     ? (referencedChunk.value = [parentObject])
@@ -928,7 +928,7 @@
     return createBoundServerReference(metaData, response._callServer);
   var serverReference = resolveServerReference(
       response._serverReferenceConfig,
-      metaData.id
+      metaData.id,
     ),
     promise = preloadModule(serverReference);
   if (promise)
@@ -950,7 +950,7 @@
       value: null,
       reason: null,
       deps: 1,
-      errored: !1
+      errored: !1,
     };
   promise.then(
     function () {
@@ -962,24 +962,24 @@
       }
       registerBoundServerReference(resolvedValue, metaData.id, metaData.bound);
       parentObject[key] = resolvedValue;
-      "" === key && null === handler.value && (handler.value = resolvedValue);
+      '' === key && null === handler.value && (handler.value = resolvedValue);
       if (
         parentObject[0] === REACT_ELEMENT_TYPE &&
-        "object" === typeof handler.value &&
+        'object' === typeof handler.value &&
         null !== handler.value &&
         handler.value.$$typeof === REACT_ELEMENT_TYPE
       )
         switch (((boundArgs = handler.value), key)) {
-          case "3":
+          case '3':
             boundArgs.props = resolvedValue;
         }
       handler.deps--;
       0 === handler.deps &&
         ((resolvedValue = handler.chunk),
         null !== resolvedValue &&
-          "blocked" === resolvedValue.status &&
+          'blocked' === resolvedValue.status &&
           ((boundArgs = resolvedValue.value),
-          (resolvedValue.status = "fulfilled"),
+          (resolvedValue.status = 'fulfilled'),
           (resolvedValue.value = handler.value),
           null !== boundArgs && wakeChunk(boundArgs, handler.value)));
     },
@@ -990,58 +990,58 @@
         handler.reason = error;
         var chunk = handler.chunk;
         null !== chunk &&
-          "blocked" === chunk.status &&
+          'blocked' === chunk.status &&
           triggerErrorOnChunk(response, chunk, error);
       }
-    }
+    },
   );
   return null;
 }
 function getOutlinedModel(response, reference, parentObject, key, map) {
-  reference = reference.split(":");
+  reference = reference.split(':');
   var id = parseInt(reference[0], 16);
   id = getChunk(response, id);
   switch (id.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(id);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(id);
   }
   switch (id.status) {
-    case "fulfilled":
+    case 'fulfilled':
       id = id.value;
       for (var i = 1; i < reference.length; i++) {
         for (
           ;
-          "object" === typeof id &&
+          'object' === typeof id &&
           null !== id &&
           id.$$typeof === REACT_LAZY_TYPE;
 
         ) {
           id = id._payload;
           switch (id.status) {
-            case "resolved_model":
+            case 'resolved_model':
               initializeModelChunk(id);
               break;
-            case "resolved_module":
+            case 'resolved_module':
               initializeModuleChunk(id);
           }
           switch (id.status) {
-            case "fulfilled":
+            case 'fulfilled':
               id = id.value;
               break;
-            case "blocked":
-            case "pending":
+            case 'blocked':
+            case 'pending':
               return waitForReference(
                 id,
                 parentObject,
                 key,
                 response,
                 map,
-                reference.slice(i - 1)
+                reference.slice(i - 1),
               );
-            case "halted":
+            case 'halted':
               return (
                 initializingHandler
                   ? ((response = initializingHandler), response.deps++)
@@ -1051,7 +1051,7 @@
                       value: null,
                       reason: null,
                       deps: 1,
-                      errored: !1
+                      errored: !1,
                     }),
                 null
               );
@@ -1067,7 +1067,7 @@
                       value: null,
                       reason: id.reason,
                       deps: 0,
-                      errored: !0
+                      errored: !0,
                     }),
                 null
               );
@@ -1077,31 +1077,31 @@
       }
       for (
         ;
-        "object" === typeof id &&
+        'object' === typeof id &&
         null !== id &&
         id.$$typeof === REACT_LAZY_TYPE;
 
       ) {
         reference = id._payload;
         switch (reference.status) {
-          case "resolved_model":
+          case 'resolved_model':
             initializeModelChunk(reference);
             break;
-          case "resolved_module":
+          case 'resolved_module':
             initializeModuleChunk(reference);
         }
         switch (reference.status) {
-          case "fulfilled":
+          case 'fulfilled':
             id = reference.value;
             continue;
         }
         break;
       }
       return map(response, id, parentObject, key);
-    case "pending":
-    case "blocked":
+    case 'pending':
+    case 'blocked':
       return waitForReference(id, parentObject, key, response, map, reference);
-    case "halted":
+    case 'halted':
       return (
         initializingHandler
           ? ((response = initializingHandler), response.deps++)
@@ -1111,7 +1111,7 @@
               value: null,
               reason: null,
               deps: 1,
-              errored: !1
+              errored: !1,
             }),
         null
       );
@@ -1127,7 +1127,7 @@
               value: null,
               reason: id.reason,
               deps: 0,
-              errored: !0
+              errored: !0,
             }),
         null
       );
@@ -1155,38 +1155,38 @@
   return model;
 }
 function parseModelString(response, parentObject, key, value) {
-  if ("$" === value[0]) {
-    if ("$" === value)
+  if ('$' === value[0]) {
+    if ('$' === value)
       return (
         null !== initializingHandler &&
-          "0" === key &&
+          '0' === key &&
           (initializingHandler = {
             parent: initializingHandler,
             chunk: null,
             value: null,
             reason: null,
             deps: 0,
-            errored: !1
+            errored: !1,
           }),
         REACT_ELEMENT_TYPE
       );
     switch (value[1]) {
-      case "$":
+      case '$':
         return value.slice(1);
-      case "L":
+      case 'L':
         return (
           (parentObject = parseInt(value.slice(2), 16)),
           (response = getChunk(response, parentObject)),
           createLazyChunkWrapper(response)
         );
-      case "@":
+      case '@':
         return (
           (parentObject = parseInt(value.slice(2), 16)),
           getChunk(response, parentObject)
         );
-      case "S":
+      case 'S':
         return Symbol.for(value.slice(2));
-      case "F":
+      case 'F':
         return (
           (value = value.slice(2)),
           getOutlinedModel(
@@ -1194,55 +1194,55 @@
             value,
             parentObject,
             key,
-            loadServerReference
+            loadServerReference,
           )
         );
-      case "T":
-        parentObject = "$" + value.slice(2);
+      case 'T':
+        parentObject = '$' + value.slice(2);
         response = response._tempRefs;
         if (null == response)
           throw Error(
-            "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+            'Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.',
           );
         return response.get(parentObject);
-      case "Q":
+      case 'Q':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createMap)
         );
-      case "W":
+      case 'W':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createSet)
         );
-      case "B":
+      case 'B':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createBlob)
         );
-      case "K":
+      case 'K':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createFormData)
         );
-      case "Z":
+      case 'Z':
         return resolveErrorProd();
-      case "i":
+      case 'i':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, extractIterator)
         );
-      case "I":
+      case 'I':
         return Infinity;
-      case "-":
-        return "$-0" === value ? -0 : -Infinity;
-      case "N":
+      case '-':
+        return '$-0' === value ? -0 : -Infinity;
+      case 'N':
         return NaN;
-      case "u":
+      case 'u':
         return;
-      case "D":
+      case 'D':
         return new Date(Date.parse(value.slice(2)));
-      case "n":
+      case 'n':
         return BigInt(value.slice(2));
       default:
         return (
@@ -1255,7 +1255,7 @@
 }
 function missingCall() {
   throw Error(
-    'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+    'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.',
   );
 }
 function ResponseInstance(
@@ -1265,7 +1265,7 @@
   callServer,
   encodeFormAction,
   nonce,
-  temporaryReferences
+  temporaryReferences,
 ) {
   var chunks = new Map();
   this._bundlerConfig = bundlerConfig;
@@ -1285,9 +1285,9 @@
 function resolveBuffer(response, id, buffer) {
   response = response._chunks;
   var chunk = response.get(id);
-  chunk && "pending" !== chunk.status
+  chunk && 'pending' !== chunk.status
     ? chunk.reason.enqueueValue(buffer)
-    : ((buffer = new ReactPromise("fulfilled", buffer, null)),
+    : ((buffer = new ReactPromise('fulfilled', buffer, null)),
       response.set(id, buffer));
 }
 function resolveModule(response, id, model) {
@@ -1298,9 +1298,9 @@
   if ((model = preloadModule(clientReference))) {
     if (chunk) {
       var blockedChunk = chunk;
-      blockedChunk.status = "blocked";
+      blockedChunk.status = 'blocked';
     } else
-      (blockedChunk = new ReactPromise("blocked", null, null)),
+      (blockedChunk = new ReactPromise('blocked', null, null)),
         chunks.set(id, blockedChunk);
     model.then(
       function () {
@@ -1308,25 +1308,25 @@
       },
       function (error) {
         return triggerErrorOnChunk(response, blockedChunk, error);
-      }
+      },
     );
   } else
     chunk
       ? resolveModuleChunk(response, chunk, clientReference)
-      : ((chunk = new ReactPromise("resolved_module", clientReference, null)),
+      : ((chunk = new ReactPromise('resolved_module', clientReference, null)),
         chunks.set(id, chunk));
 }
 function resolveStream(response, id, stream, controller) {
   response = response._chunks;
   var chunk = response.get(id);
   chunk
-    ? "pending" === chunk.status &&
+    ? 'pending' === chunk.status &&
       ((id = chunk.value),
-      (chunk.status = "fulfilled"),
+      (chunk.status = 'fulfilled'),
       (chunk.value = stream),
       (chunk.reason = controller),
       null !== id && wakeChunk(id, chunk.value))
-    : ((stream = new ReactPromise("fulfilled", stream, controller)),
+    : ((stream = new ReactPromise('fulfilled', stream, controller)),
       response.set(id, stream));
 }
 function startReadableStream(response, id, type) {
@@ -1335,7 +1335,7 @@
     type: type,
     start: function (c) {
       controller = c;
-    }
+    },
   });
   var previousBlockedChunk = null;
   resolveStream(response, id, type, {
@@ -1348,9 +1348,9 @@
     },
     enqueueModel: function (json) {
       if (null === previousBlockedChunk) {
-        var chunk = new ReactPromise("resolved_model", json, response);
+        var chunk = new ReactPromise('resolved_model', json, response);
         initializeModelChunk(chunk);
-        "fulfilled" === chunk.status
+        'fulfilled' === chunk.status
           ? controller.enqueue(chunk.value)
           : (chunk.then(
               function (v) {
@@ -1358,19 +1358,19 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             ),
             (previousBlockedChunk = chunk));
       } else {
         chunk = previousBlockedChunk;
-        var chunk$54 = new ReactPromise("pending", null, null);
+        var chunk$54 = new ReactPromise('pending', null, null);
         chunk$54.then(
           function (v) {
             return controller.enqueue(v);
           },
           function (e) {
             return controller.error(e);
-          }
+          },
         );
         previousBlockedChunk = chunk$54;
         chunk.then(function () {
@@ -1398,7 +1398,7 @@
           return controller.error(error);
         });
       }
-    }
+    },
   });
 }
 function asyncIterator() {
@@ -1419,16 +1419,16 @@
     return createIterator(function (arg) {
       if (void 0 !== arg)
         throw Error(
-          "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+          'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
         );
       if (nextReadIndex === buffer.length) {
         if (closed)
           return new ReactPromise(
-            "fulfilled",
+            'fulfilled',
             { done: !0, value: void 0 },
-            null
+            null,
           );
-        buffer[nextReadIndex] = new ReactPromise("pending", null, null);
+        buffer[nextReadIndex] = new ReactPromise('pending', null, null);
       }
       return buffer[nextReadIndex++];
     });
@@ -1441,15 +1441,15 @@
       enqueueValue: function (value) {
         if (nextWriteIndex === buffer.length)
           buffer[nextWriteIndex] = new ReactPromise(
-            "fulfilled",
+            'fulfilled',
             { done: !1, value: value },
-            null
+            null,
           );
         else {
           var chunk = buffer[nextWriteIndex],
             resolveListeners = chunk.value,
             rejectListeners = chunk.reason;
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = { done: !1, value: value };
           null !== resolveListeners &&
             wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
@@ -1461,13 +1461,13 @@
           ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
               response,
               value,
-              !1
+              !1,
             ))
           : resolveIteratorResultChunk(
               response,
               buffer[nextWriteIndex],
               value,
-              !1
+              !1,
             );
         nextWriteIndex++;
       },
@@ -1477,40 +1477,40 @@
           ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
               response,
               value,
-              !0
+              !0,
             ))
           : resolveIteratorResultChunk(
               response,
               buffer[nextWriteIndex],
               value,
-              !0
+              !0,
             );
         for (nextWriteIndex++; nextWriteIndex < buffer.length; )
           resolveIteratorResultChunk(
             response,
             buffer[nextWriteIndex++],
             '"$undefined"',
-            !0
+            !0,
           );
       },
       error: function (error) {
         closed = !0;
         for (
           nextWriteIndex === buffer.length &&
-          (buffer[nextWriteIndex] = new ReactPromise("pending", null, null));
+          (buffer[nextWriteIndex] = new ReactPromise('pending', null, null));
           nextWriteIndex < buffer.length;
 
         )
           triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);
-      }
-    }
+      },
+    },
   );
 }
 function resolveErrorProd() {
   var error = Error(
-    "An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error."
+    'An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.',
   );
-  error.stack = "Error: " + error.message;
+  error.stack = 'Error: ' + error.message;
   return error;
 }
 function mergeBuffer(buffer, lastChunk) {
@@ -1531,7 +1531,7 @@
   buffer,
   lastChunk,
   constructor,
-  bytesPerElement
+  bytesPerElement,
 ) {
   buffer =
     0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
@@ -1540,7 +1540,7 @@
   constructor = new constructor(
     buffer.buffer,
     buffer.byteOffset,
-    buffer.byteLength / bytesPerElement
+    buffer.byteLength / bytesPerElement,
   );
   resolveBuffer(response, id, constructor);
 }
@@ -1556,7 +1556,7 @@
       resolveBuffer(
         response,
         id,
-        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)
+        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk),
       );
       return;
     case 85:
@@ -1591,7 +1591,7 @@
       return;
   }
   streamState = response._stringDecoder;
-  for (var row = "", i = 0; i < buffer.length; i++)
+  for (var row = '', i = 0; i < buffer.length; i++)
     row += streamState.decode(buffer[i], decoderOptions);
   buffer = row += streamState.decode(chunk);
   switch (tag) {
@@ -1604,42 +1604,42 @@
       response = JSON.parse(buffer, response._fromJSON);
       buffer = ReactDOMSharedInternals.d;
       switch (id) {
-        case "D":
+        case 'D':
           buffer.D(response);
           break;
-        case "C":
-          "string" === typeof response
+        case 'C':
+          'string' === typeof response
             ? buffer.C(response)
             : buffer.C(response[0], response[1]);
           break;
-        case "L":
+        case 'L':
           id = response[0];
           tag = response[1];
           3 === response.length
             ? buffer.L(id, tag, response[2])
             : buffer.L(id, tag);
           break;
-        case "m":
-          "string" === typeof response
+        case 'm':
+          'string' === typeof response
             ? buffer.m(response)
             : buffer.m(response[0], response[1]);
           break;
-        case "X":
-          "string" === typeof response
+        case 'X':
+          'string' === typeof response
             ? buffer.X(response)
             : buffer.X(response[0], response[1]);
           break;
-        case "S":
-          "string" === typeof response
+        case 'S':
+          'string' === typeof response
             ? buffer.S(response)
             : buffer.S(
                 response[0],
                 0 === response[1] ? void 0 : response[1],
-                3 === response.length ? response[2] : void 0
+                3 === response.length ? response[2] : void 0,
               );
           break;
-        case "M":
-          "string" === typeof response
+        case 'M':
+          'string' === typeof response
             ? buffer.M(response)
             : buffer.M(response[0], response[1]);
       }
@@ -1652,14 +1652,14 @@
       streamState.digest = buffer.digest;
       chunk
         ? triggerErrorOnChunk(response, chunk, streamState)
-        : ((response = new ReactPromise("rejected", null, streamState)),
+        : ((response = new ReactPromise('rejected', null, streamState)),
           tag.set(id, response));
       break;
     case 84:
       response = response._chunks;
-      (tag = response.get(id)) && "pending" !== tag.status
+      (tag = response.get(id)) && 'pending' !== tag.status
         ? tag.reason.enqueueValue(buffer)
-        : ((buffer = new ReactPromise("fulfilled", buffer, null)),
+        : ((buffer = new ReactPromise('fulfilled', buffer, null)),
           response.set(id, buffer));
       break;
     case 78:
@@ -1667,13 +1667,13 @@
     case 74:
     case 87:
       throw Error(
-        "Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client."
+        'Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client.',
       );
     case 82:
       startReadableStream(response, id, void 0);
       break;
     case 114:
-      startReadableStream(response, id, "bytes");
+      startReadableStream(response, id, 'bytes');
       break;
     case 88:
       startAsyncIterable(response, id, !1);
@@ -1683,22 +1683,22 @@
       break;
     case 67:
       (id = response._chunks.get(id)) &&
-        "fulfilled" === id.status &&
-        id.reason.close("" === buffer ? '"$undefined"' : buffer);
+        'fulfilled' === id.status &&
+        id.reason.close('' === buffer ? '"$undefined"' : buffer);
       break;
     default:
       (tag = response._chunks),
         (chunk = tag.get(id))
           ? resolveModelChunk(response, chunk, buffer)
-          : ((response = new ReactPromise("resolved_model", buffer, response)),
+          : ((response = new ReactPromise('resolved_model', buffer, response)),
             tag.set(id, response));
   }
 }
 function createFromJSONCallback(response) {
   return function (key, value) {
-    if ("string" === typeof value)
+    if ('string' === typeof value)
       return parseModelString(response, this, key, value);
-    if ("object" === typeof value && null !== value) {
+    if ('object' === typeof value && null !== value) {
       if (value[0] === REACT_ELEMENT_TYPE) {
         if (
           ((key = {
@@ -1706,7 +1706,7 @@
             type: value[1],
             key: value[2],
             ref: null,
-            props: value[3]
+            props: value[3],
           }),
           null !== initializingHandler)
         )
@@ -1715,10 +1715,10 @@
             (initializingHandler = value.parent),
             value.errored)
           )
-            (key = new ReactPromise("rejected", null, value.reason)),
+            (key = new ReactPromise('rejected', null, value.reason)),
               (key = createLazyChunkWrapper(key));
           else if (0 < value.deps) {
-            var blockedChunk = new ReactPromise("blocked", null, null);
+            var blockedChunk = new ReactPromise('blocked', null, null);
             value.value = key;
             value.chunk = blockedChunk;
             key = createLazyChunkWrapper(blockedChunk);
@@ -1730,7 +1730,7 @@
   };
 }
 function close(weakResponse) {
-  reportGlobalError(weakResponse, Error("Connection closed."));
+  reportGlobalError(weakResponse, Error('Connection closed.'));
 }
 function createResponseFromOptions(options) {
   return new ResponseInstance(
@@ -1742,7 +1742,7 @@
     void 0,
     options && options.temporaryReferences
       ? options.temporaryReferences
-      : void 0
+      : void 0,
   );
 }
 function startReadingFromStream(response, stream, onDone) {
@@ -1816,7 +1816,7 @@
             _ref2,
             rowTag,
             buffer,
-            rowLength
+            rowLength,
           ),
           (i = lastIdx),
           3 === rowState && i++,
@@ -1843,7 +1843,7 @@
       _rowID: 0,
       _rowTag: 0,
       _rowLength: 0,
-      _buffer: []
+      _buffer: [],
     },
     reader = stream.getReader();
   reader.read().then(progress).catch(error);
@@ -1856,7 +1856,7 @@
     },
     function (e) {
       reportGlobalError(response, e);
-    }
+    },
   );
   return getChunk(response, 0);
 };
@@ -1880,12 +1880,12 @@
   return new Promise(function (resolve, reject) {
     var abort = processReply(
       value,
-      "",
+      '',
       options && options.temporaryReferences
         ? options.temporaryReferences
         : void 0,
       resolve,
-      reject
+      reject,
     );
     if (options && options.signal) {
       var signal = options.signal;
@@ -1893,9 +1893,9 @@
       else {
         var listener = function () {
           abort(signal.reason);
-          signal.removeEventListener("abort", listener);
+          signal.removeEventListener('abort', listener);
         };
-        signal.addEventListener("abort", listener);
+        signal.addEventListener('abort', listener);
       }
     }
   });
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.edge.development.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.edge.development.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.edge.development.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.edge.development.js	2025-12-17 14:32:44
@@ -8,8 +8,8 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
+'use strict';
+'production' !== process.env.NODE_ENV &&
   (function () {
     function resolveClientReference(bundlerConfig, metadata) {
       if (bundlerConfig) {
@@ -17,12 +17,12 @@
         if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))
           moduleExports = bundlerConfig.name;
         else {
-          bundlerConfig = moduleExports && moduleExports["*"];
+          bundlerConfig = moduleExports && moduleExports['*'];
           if (!bundlerConfig)
             throw Error(
               'Could not find the module "' +
                 metadata[0] +
-                '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'
+                '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.',
             );
           moduleExports = metadata[2];
         }
@@ -33,11 +33,11 @@
       return metadata;
     }
     function resolveServerReference(bundlerConfig, id) {
-      var name = "",
+      var name = '',
         resolvedModuleData = bundlerConfig[id];
       if (resolvedModuleData) name = resolvedModuleData.name;
       else {
-        var idx = id.lastIndexOf("#");
+        var idx = id.lastIndexOf('#');
         -1 !== idx &&
           ((name = id.slice(idx + 1)),
           (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -45,7 +45,7 @@
           throw Error(
             'Could not find the module "' +
               id +
-              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
           );
       }
       return resolvedModuleData.async
@@ -54,17 +54,17 @@
     }
     function requireAsyncModule(id) {
       var promise = __webpack_require__(id);
-      if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+      if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
         return null;
       promise.then(
         function (value) {
-          promise.status = "fulfilled";
+          promise.status = 'fulfilled';
           promise.value = value;
         },
         function (reason) {
-          promise.status = "rejected";
+          promise.status = 'rejected';
           promise.reason = reason;
-        }
+        },
       );
       return promise;
     }
@@ -98,13 +98,13 @@
     }
     function requireModule(metadata) {
       var moduleExports = __webpack_require__(metadata[0]);
-      if (4 === metadata.length && "function" === typeof moduleExports.then)
-        if ("fulfilled" === moduleExports.status)
+      if (4 === metadata.length && 'function' === typeof moduleExports.then)
+        if ('fulfilled' === moduleExports.status)
           moduleExports = moduleExports.value;
         else throw moduleExports.reason;
-      return "*" === metadata[2]
+      return '*' === metadata[2]
         ? moduleExports
-        : "" === metadata[2]
+        : '' === metadata[2]
           ? moduleExports.__esModule
             ? moduleExports.default
             : moduleExports
@@ -113,7 +113,7 @@
     function prepareDestinationWithChunks(
       moduleLoading,
       chunks,
-      nonce$jscomp$0
+      nonce$jscomp$0,
     ) {
       if (null !== moduleLoading)
         for (var i = 1; i < chunks.length; i += 2) {
@@ -123,25 +123,25 @@
             JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];
           var JSCompiler_inline_result = moduleLoading.crossOrigin;
           JSCompiler_inline_result =
-            "string" === typeof JSCompiler_inline_result
-              ? "use-credentials" === JSCompiler_inline_result
+            'string' === typeof JSCompiler_inline_result
+              ? 'use-credentials' === JSCompiler_inline_result
                 ? JSCompiler_inline_result
-                : ""
+                : ''
               : void 0;
           JSCompiler_temp_const$jscomp$0.call(
             JSCompiler_temp_const,
             JSCompiler_temp_const$jscomp$1,
-            { crossOrigin: JSCompiler_inline_result, nonce: nonce }
+            { crossOrigin: JSCompiler_inline_result, nonce: nonce },
           );
         }
     }
     function getIteratorFn(maybeIterable) {
-      if (null === maybeIterable || "object" !== typeof maybeIterable)
+      if (null === maybeIterable || 'object' !== typeof maybeIterable)
         return null;
       maybeIterable =
         (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-        maybeIterable["@@iterator"];
-      return "function" === typeof maybeIterable ? maybeIterable : null;
+        maybeIterable['@@iterator'];
+      return 'function' === typeof maybeIterable ? maybeIterable : null;
     }
     function isObjectPrototype(object) {
       if (!object) return !1;
@@ -164,8 +164,8 @@
         if (
           !descriptor ||
           (!descriptor.enumerable &&
-            (("key" !== names[i] && "ref" !== names[i]) ||
-              "function" !== typeof descriptor.get))
+            (('key' !== names[i] && 'ref' !== names[i]) ||
+              'function' !== typeof descriptor.get))
         )
           return !1;
       }
@@ -181,35 +181,35 @@
     }
     function describeValueForErrorMessage(value) {
       switch (typeof value) {
-        case "string":
+        case 'string':
           return JSON.stringify(
-            10 >= value.length ? value : value.slice(0, 10) + "..."
+            10 >= value.length ? value : value.slice(0, 10) + '...',
           );
-        case "object":
-          if (isArrayImpl(value)) return "[...]";
+        case 'object':
+          if (isArrayImpl(value)) return '[...]';
           if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-            return "client";
+            return 'client';
           value = objectName(value);
-          return "Object" === value ? "{...}" : value;
-        case "function":
+          return 'Object' === value ? '{...}' : value;
+        case 'function':
           return value.$$typeof === CLIENT_REFERENCE_TAG
-            ? "client"
+            ? 'client'
             : (value = value.displayName || value.name)
-              ? "function " + value
-              : "function";
+              ? 'function ' + value
+              : 'function';
         default:
           return String(value);
       }
     }
     function describeElementType(type) {
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (type.$$typeof) {
           case REACT_FORWARD_REF_TYPE:
             return describeElementType(type.render);
@@ -222,74 +222,74 @@
               return describeElementType(type(payload));
             } catch (x) {}
         }
-      return "";
+      return '';
     }
     function describeObjectForErrorMessage(objectOrArray, expandedName) {
       var objKind = objectName(objectOrArray);
-      if ("Object" !== objKind && "Array" !== objKind) return objKind;
+      if ('Object' !== objKind && 'Array' !== objKind) return objKind;
       var start = -1,
         length = 0;
       if (isArrayImpl(objectOrArray))
         if (jsxChildrenParents.has(objectOrArray)) {
           var type = jsxChildrenParents.get(objectOrArray);
-          objKind = "<" + describeElementType(type) + ">";
+          objKind = '<' + describeElementType(type) + '>';
           for (var i = 0; i < objectOrArray.length; i++) {
             var value = objectOrArray[i];
             value =
-              "string" === typeof value
+              'string' === typeof value
                 ? value
-                : "object" === typeof value && null !== value
-                  ? "{" + describeObjectForErrorMessage(value) + "}"
-                  : "{" + describeValueForErrorMessage(value) + "}";
-            "" + i === expandedName
+                : 'object' === typeof value && null !== value
+                  ? '{' + describeObjectForErrorMessage(value) + '}'
+                  : '{' + describeValueForErrorMessage(value) + '}';
+            '' + i === expandedName
               ? ((start = objKind.length),
                 (length = value.length),
                 (objKind += value))
               : (objKind =
                   15 > value.length && 40 > objKind.length + value.length
                     ? objKind + value
-                    : objKind + "{...}");
+                    : objKind + '{...}');
           }
-          objKind += "</" + describeElementType(type) + ">";
+          objKind += '</' + describeElementType(type) + '>';
         } else {
-          objKind = "[";
+          objKind = '[';
           for (type = 0; type < objectOrArray.length; type++)
-            0 < type && (objKind += ", "),
+            0 < type && (objKind += ', '),
               (i = objectOrArray[type]),
               (i =
-                "object" === typeof i && null !== i
+                'object' === typeof i && null !== i
                   ? describeObjectForErrorMessage(i)
                   : describeValueForErrorMessage(i)),
-              "" + type === expandedName
+              '' + type === expandedName
                 ? ((start = objKind.length),
                   (length = i.length),
                   (objKind += i))
                 : (objKind =
                     10 > i.length && 40 > objKind.length + i.length
                       ? objKind + i
-                      : objKind + "...");
-          objKind += "]";
+                      : objKind + '...');
+          objKind += ']';
         }
       else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-        objKind = "<" + describeElementType(objectOrArray.type) + "/>";
+        objKind = '<' + describeElementType(objectOrArray.type) + '/>';
       else {
-        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
         if (jsxPropsParents.has(objectOrArray)) {
           objKind = jsxPropsParents.get(objectOrArray);
-          objKind = "<" + (describeElementType(objKind) || "...");
+          objKind = '<' + (describeElementType(objKind) || '...');
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++) {
-            objKind += " ";
+            objKind += ' ';
             value = type[i];
-            objKind += describeKeyForErrorMessage(value) + "=";
+            objKind += describeKeyForErrorMessage(value) + '=';
             var _value2 = objectOrArray[value];
             var _substr2 =
               value === expandedName &&
-              "object" === typeof _value2 &&
+              'object' === typeof _value2 &&
               null !== _value2
                 ? describeObjectForErrorMessage(_value2)
                 : describeValueForErrorMessage(_value2);
-            "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
+            'string' !== typeof _value2 && (_substr2 = '{' + _substr2 + '}');
             value === expandedName
               ? ((start = objKind.length),
                 (length = _substr2.length),
@@ -297,19 +297,19 @@
               : (objKind =
                   10 > _substr2.length && 40 > objKind.length + _substr2.length
                     ? objKind + _substr2
-                    : objKind + "...");
+                    : objKind + '...');
           }
-          objKind += ">";
+          objKind += '>';
         } else {
-          objKind = "{";
+          objKind = '{';
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++)
-            0 < i && (objKind += ", "),
+            0 < i && (objKind += ', '),
               (value = type[i]),
-              (objKind += describeKeyForErrorMessage(value) + ": "),
+              (objKind += describeKeyForErrorMessage(value) + ': '),
               (_value2 = objectOrArray[value]),
               (_value2 =
-                "object" === typeof _value2 && null !== _value2
+                'object' === typeof _value2 && null !== _value2
                   ? describeObjectForErrorMessage(_value2)
                   : describeValueForErrorMessage(_value2)),
               value === expandedName
@@ -319,47 +319,47 @@
                 : (objKind =
                     10 > _value2.length && 40 > objKind.length + _value2.length
                       ? objKind + _value2
-                      : objKind + "...");
-          objKind += "}";
+                      : objKind + '...');
+          objKind += '}';
         }
       }
       return void 0 === expandedName
         ? objKind
         : -1 < start && 0 < length
-          ? ((objectOrArray = " ".repeat(start) + "^".repeat(length)),
-            "\n  " + objKind + "\n  " + objectOrArray)
-          : "\n  " + objKind;
+          ? ((objectOrArray = ' '.repeat(start) + '^'.repeat(length)),
+            '\n  ' + objKind + '\n  ' + objectOrArray)
+          : '\n  ' + objKind;
     }
     function serializeNumber(number) {
       return Number.isFinite(number)
         ? 0 === number && -Infinity === 1 / number
-          ? "$-0"
+          ? '$-0'
           : number
         : Infinity === number
-          ? "$Infinity"
+          ? '$Infinity'
           : -Infinity === number
-            ? "$-Infinity"
-            : "$NaN";
+            ? '$-Infinity'
+            : '$NaN';
     }
     function processReply(
       root,
       formFieldPrefix,
       temporaryReferences,
       resolve,
-      reject
+      reject,
     ) {
       function serializeTypedArray(tag, typedArray) {
         typedArray = new Blob([
           new Uint8Array(
             typedArray.buffer,
             typedArray.byteOffset,
-            typedArray.byteLength
-          )
+            typedArray.byteLength,
+          ),
         ]);
         var blobId = nextPartId++;
         null === formData && (formData = new FormData());
         formData.append(formFieldPrefix + blobId, typedArray);
-        return "$" + tag + blobId.toString(16);
+        return '$' + tag + blobId.toString(16);
       }
       function serializeBinaryReader(reader) {
         function progress(entry) {
@@ -368,9 +368,9 @@
               data.append(formFieldPrefix + entry, new Blob(buffer)),
               data.append(
                 formFieldPrefix + streamId,
-                '"$o' + entry.toString(16) + '"'
+                '"$o' + entry.toString(16) + '"',
               ),
-              data.append(formFieldPrefix + streamId, "C"),
+              data.append(formFieldPrefix + streamId, 'C'),
               pendingParts--,
               0 === pendingParts && resolve(data))
             : (buffer.push(entry.value),
@@ -382,12 +382,12 @@
         var streamId = nextPartId++,
           buffer = [];
         reader.read(new Uint8Array(1024)).then(progress, reject);
-        return "$r" + streamId.toString(16);
+        return '$r' + streamId.toString(16);
       }
       function serializeReader(reader) {
         function progress(entry) {
           if (entry.done)
-            data.append(formFieldPrefix + streamId, "C"),
+            data.append(formFieldPrefix + streamId, 'C'),
               pendingParts--,
               0 === pendingParts && resolve(data);
           else
@@ -404,11 +404,11 @@
         pendingParts++;
         var streamId = nextPartId++;
         reader.read().then(progress, reject);
-        return "$R" + streamId.toString(16);
+        return '$R' + streamId.toString(16);
       }
       function serializeReadableStream(stream) {
         try {
-          var binaryReader = stream.getReader({ mode: "byob" });
+          var binaryReader = stream.getReader({ mode: 'byob' });
         } catch (x) {
           return serializeReader(stream.getReader());
         }
@@ -418,11 +418,11 @@
         function progress(entry) {
           if (entry.done) {
             if (void 0 === entry.value)
-              data.append(formFieldPrefix + streamId, "C");
+              data.append(formFieldPrefix + streamId, 'C');
             else
               try {
                 var partJSON = JSON.stringify(entry.value, resolveToJSON);
-                data.append(formFieldPrefix + streamId, "C" + partJSON);
+                data.append(formFieldPrefix + streamId, 'C' + partJSON);
               } catch (x) {
                 reject(x);
                 return;
@@ -444,38 +444,38 @@
         var streamId = nextPartId++;
         iterable = iterable === iterator;
         iterator.next().then(progress, reject);
-        return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+        return '$' + (iterable ? 'x' : 'X') + streamId.toString(16);
       }
       function resolveToJSON(key, value) {
         var originalValue = this[key];
-        "object" !== typeof originalValue ||
+        'object' !== typeof originalValue ||
           originalValue === value ||
           originalValue instanceof Date ||
-          ("Object" !== objectName(originalValue)
+          ('Object' !== objectName(originalValue)
             ? console.error(
-                "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                'Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s',
                 objectName(originalValue),
-                describeObjectForErrorMessage(this, key)
+                describeObjectForErrorMessage(this, key),
               )
             : console.error(
-                "Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s",
-                describeObjectForErrorMessage(this, key)
+                'Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s',
+                describeObjectForErrorMessage(this, key),
               ));
         if (null === value) return null;
-        if ("object" === typeof value) {
+        if ('object' === typeof value) {
           switch (value.$$typeof) {
             case REACT_ELEMENT_TYPE:
-              if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+              if (void 0 !== temporaryReferences && -1 === key.indexOf(':')) {
                 var parentReference = writtenObjects.get(this);
                 if (void 0 !== parentReference)
                   return (
-                    temporaryReferences.set(parentReference + ":" + key, value),
-                    "$T"
+                    temporaryReferences.set(parentReference + ':' + key, value),
+                    '$T'
                   );
               }
               throw Error(
-                "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
-                  describeObjectForErrorMessage(this, key)
+                'React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.' +
+                  describeObjectForErrorMessage(this, key),
               );
             case REACT_LAZY_TYPE:
               originalValue = value._payload;
@@ -487,12 +487,12 @@
                 var lazyId = nextPartId++,
                   partJSON = serializeModel(parentReference, lazyId);
                 formData.append(formFieldPrefix + lazyId, partJSON);
-                return "$" + lazyId.toString(16);
+                return '$' + lazyId.toString(16);
               } catch (x) {
                 if (
-                  "object" === typeof x &&
+                  'object' === typeof x &&
                   null !== x &&
-                  "function" === typeof x.then
+                  'function' === typeof x.then
                 ) {
                   pendingParts++;
                   var _lazyId = nextPartId++;
@@ -508,7 +508,7 @@
                     }
                   };
                   x.then(parentReference, parentReference);
-                  return "$" + _lazyId.toString(16);
+                  return '$' + _lazyId.toString(16);
                 }
                 reject(x);
                 return null;
@@ -516,7 +516,7 @@
                 pendingParts--;
               }
           }
-          if ("function" === typeof value.then) {
+          if ('function' === typeof value.then) {
             null === formData && (formData = new FormData());
             pendingParts++;
             var promiseId = nextPartId++;
@@ -531,17 +531,17 @@
                 reject(reason);
               }
             }, reject);
-            return "$@" + promiseId.toString(16);
+            return '$@' + promiseId.toString(16);
           }
           parentReference = writtenObjects.get(value);
           if (void 0 !== parentReference)
             if (modelRoot === value) modelRoot = null;
             else return parentReference;
           else
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
               ((parentReference = writtenObjects.get(this)),
               void 0 !== parentReference &&
-                ((parentReference = parentReference + ":" + key),
+                ((parentReference = parentReference + ':' + key),
                 writtenObjects.set(value, parentReference),
                 void 0 !== temporaryReferences &&
                   temporaryReferences.set(parentReference, value)));
@@ -550,11 +550,11 @@
             null === formData && (formData = new FormData());
             var _data3 = formData;
             key = nextPartId++;
-            var prefix = formFieldPrefix + key + "_";
+            var prefix = formFieldPrefix + key + '_';
             value.forEach(function (originalValue, originalKey) {
               _data3.append(prefix + originalKey, originalValue);
             });
-            return "$K" + key.toString(16);
+            return '$K' + key.toString(16);
           }
           if (value instanceof Map)
             return (
@@ -562,7 +562,7 @@
               (parentReference = serializeModel(Array.from(value), key)),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$Q" + key.toString(16)
+              '$Q' + key.toString(16)
             );
           if (value instanceof Set)
             return (
@@ -570,7 +570,7 @@
               (parentReference = serializeModel(Array.from(value), key)),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$W" + key.toString(16)
+              '$W' + key.toString(16)
             );
           if (value instanceof ArrayBuffer)
             return (
@@ -578,37 +578,37 @@
               (parentReference = nextPartId++),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + parentReference, key),
-              "$A" + parentReference.toString(16)
+              '$A' + parentReference.toString(16)
             );
           if (value instanceof Int8Array)
-            return serializeTypedArray("O", value);
+            return serializeTypedArray('O', value);
           if (value instanceof Uint8Array)
-            return serializeTypedArray("o", value);
+            return serializeTypedArray('o', value);
           if (value instanceof Uint8ClampedArray)
-            return serializeTypedArray("U", value);
+            return serializeTypedArray('U', value);
           if (value instanceof Int16Array)
-            return serializeTypedArray("S", value);
+            return serializeTypedArray('S', value);
           if (value instanceof Uint16Array)
-            return serializeTypedArray("s", value);
+            return serializeTypedArray('s', value);
           if (value instanceof Int32Array)
-            return serializeTypedArray("L", value);
+            return serializeTypedArray('L', value);
           if (value instanceof Uint32Array)
-            return serializeTypedArray("l", value);
+            return serializeTypedArray('l', value);
           if (value instanceof Float32Array)
-            return serializeTypedArray("G", value);
+            return serializeTypedArray('G', value);
           if (value instanceof Float64Array)
-            return serializeTypedArray("g", value);
+            return serializeTypedArray('g', value);
           if (value instanceof BigInt64Array)
-            return serializeTypedArray("M", value);
+            return serializeTypedArray('M', value);
           if (value instanceof BigUint64Array)
-            return serializeTypedArray("m", value);
-          if (value instanceof DataView) return serializeTypedArray("V", value);
-          if ("function" === typeof Blob && value instanceof Blob)
+            return serializeTypedArray('m', value);
+          if (value instanceof DataView) return serializeTypedArray('V', value);
+          if ('function' === typeof Blob && value instanceof Blob)
             return (
               null === formData && (formData = new FormData()),
               (key = nextPartId++),
               formData.append(formFieldPrefix + key, value),
-              "$B" + key.toString(16)
+              '$B' + key.toString(16)
             );
           if ((parentReference = getIteratorFn(value)))
             return (
@@ -617,20 +617,20 @@
                 ? ((key = nextPartId++),
                   (parentReference = serializeModel(
                     Array.from(parentReference),
-                    key
+                    key,
                   )),
                   null === formData && (formData = new FormData()),
                   formData.append(formFieldPrefix + key, parentReference),
-                  "$i" + key.toString(16))
+                  '$i' + key.toString(16))
                 : Array.from(parentReference)
             );
           if (
-            "function" === typeof ReadableStream &&
+            'function' === typeof ReadableStream &&
             value instanceof ReadableStream
           )
             return serializeReadableStream(value);
           parentReference = value[ASYNC_ITERATOR];
-          if ("function" === typeof parentReference)
+          if ('function' === typeof parentReference)
             return serializeAsyncIterable(value, parentReference.call(value));
           parentReference = getPrototypeOf(value);
           if (
@@ -640,98 +640,98 @@
           ) {
             if (void 0 === temporaryReferences)
               throw Error(
-                "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported." +
-                  describeObjectForErrorMessage(this, key)
+                'Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.' +
+                  describeObjectForErrorMessage(this, key),
               );
-            return "$T";
+            return '$T';
           }
           value.$$typeof === REACT_CONTEXT_TYPE
             ? console.error(
-                "React Context Providers cannot be passed to Server Functions from the Client.%s",
-                describeObjectForErrorMessage(this, key)
+                'React Context Providers cannot be passed to Server Functions from the Client.%s',
+                describeObjectForErrorMessage(this, key),
               )
-            : "Object" !== objectName(value)
+            : 'Object' !== objectName(value)
               ? console.error(
-                  "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                  'Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s',
                   objectName(value),
-                  describeObjectForErrorMessage(this, key)
+                  describeObjectForErrorMessage(this, key),
                 )
               : isSimpleObject(value)
                 ? Object.getOwnPropertySymbols &&
                   ((parentReference = Object.getOwnPropertySymbols(value)),
                   0 < parentReference.length &&
                     console.error(
-                      "Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s",
+                      'Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s',
                       parentReference[0].description,
-                      describeObjectForErrorMessage(this, key)
+                      describeObjectForErrorMessage(this, key),
                     ))
                 : console.error(
-                    "Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s",
-                    describeObjectForErrorMessage(this, key)
+                    'Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s',
+                    describeObjectForErrorMessage(this, key),
                   );
           return value;
         }
-        if ("string" === typeof value) {
-          if ("Z" === value[value.length - 1] && this[key] instanceof Date)
-            return "$D" + value;
-          key = "$" === value[0] ? "$" + value : value;
+        if ('string' === typeof value) {
+          if ('Z' === value[value.length - 1] && this[key] instanceof Date)
+            return '$D' + value;
+          key = '$' === value[0] ? '$' + value : value;
           return key;
         }
-        if ("boolean" === typeof value) return value;
-        if ("number" === typeof value) return serializeNumber(value);
-        if ("undefined" === typeof value) return "$undefined";
-        if ("function" === typeof value) {
+        if ('boolean' === typeof value) return value;
+        if ('number' === typeof value) return serializeNumber(value);
+        if ('undefined' === typeof value) return '$undefined';
+        if ('function' === typeof value) {
           parentReference = knownServerReferences.get(value);
           if (void 0 !== parentReference)
             return (
               (key = JSON.stringify(
                 { id: parentReference.id, bound: parentReference.bound },
-                resolveToJSON
+                resolveToJSON,
               )),
               null === formData && (formData = new FormData()),
               (parentReference = nextPartId++),
               formData.set(formFieldPrefix + parentReference, key),
-              "$F" + parentReference.toString(16)
+              '$F' + parentReference.toString(16)
             );
           if (
             void 0 !== temporaryReferences &&
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
             ((parentReference = writtenObjects.get(this)),
             void 0 !== parentReference)
           )
             return (
-              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+              temporaryReferences.set(parentReference + ':' + key, value), '$T'
             );
           throw Error(
-            "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+            'Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.',
           );
         }
-        if ("symbol" === typeof value) {
+        if ('symbol' === typeof value) {
           if (
             void 0 !== temporaryReferences &&
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
             ((parentReference = writtenObjects.get(this)),
             void 0 !== parentReference)
           )
             return (
-              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+              temporaryReferences.set(parentReference + ':' + key, value), '$T'
             );
           throw Error(
-            "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
-              describeObjectForErrorMessage(this, key)
+            'Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.' +
+              describeObjectForErrorMessage(this, key),
           );
         }
-        if ("bigint" === typeof value) return "$n" + value.toString(10);
+        if ('bigint' === typeof value) return '$n' + value.toString(10);
         throw Error(
-          "Type " +
+          'Type ' +
             typeof value +
-            " is not supported as an argument to a Server Function."
+            ' is not supported as an argument to a Server Function.',
         );
       }
       function serializeModel(model, id) {
-        "object" === typeof model &&
+        'object' === typeof model &&
           null !== model &&
-          ((id = "$" + id.toString(16)),
+          ((id = '$' + id.toString(16)),
           writtenObjects.set(model, id),
           void 0 !== temporaryReferences && temporaryReferences.set(id, model));
         modelRoot = model;
@@ -745,7 +745,7 @@
         json = serializeModel(root, 0);
       null === formData
         ? resolve(json)
-        : (formData.set(formFieldPrefix + "0", json),
+        : (formData.set(formFieldPrefix + '0', json),
           0 === pendingParts && resolve(formData));
       return function () {
         0 < pendingParts &&
@@ -762,23 +762,23 @@
         });
       processReply(
         reference,
-        "",
+        '',
         void 0,
         function (body) {
-          if ("string" === typeof body) {
+          if ('string' === typeof body) {
             var data = new FormData();
-            data.append("0", body);
+            data.append('0', body);
             body = data;
           }
-          thenable.status = "fulfilled";
+          thenable.status = 'fulfilled';
           thenable.value = body;
           resolve(body);
         },
         function (e) {
-          thenable.status = "rejected";
+          thenable.status = 'rejected';
           thenable.reason = e;
           reject(e);
-        }
+        },
       );
       return thenable;
     }
@@ -786,7 +786,7 @@
       var referenceClosure = knownServerReferences.get(this);
       if (!referenceClosure)
         throw Error(
-          "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+          'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
         );
       var data = null;
       if (null !== referenceClosure.bound) {
@@ -794,55 +794,55 @@
         data ||
           ((data = encodeFormData({
             id: referenceClosure.id,
-            bound: referenceClosure.bound
+            bound: referenceClosure.bound,
           })),
           boundCache.set(referenceClosure, data));
-        if ("rejected" === data.status) throw data.reason;
-        if ("fulfilled" !== data.status) throw data;
+        if ('rejected' === data.status) throw data.reason;
+        if ('fulfilled' !== data.status) throw data;
         referenceClosure = data.value;
         var prefixedData = new FormData();
         referenceClosure.forEach(function (value, key) {
-          prefixedData.append("$ACTION_" + identifierPrefix + ":" + key, value);
+          prefixedData.append('$ACTION_' + identifierPrefix + ':' + key, value);
         });
         data = prefixedData;
-        referenceClosure = "$ACTION_REF_" + identifierPrefix;
-      } else referenceClosure = "$ACTION_ID_" + referenceClosure.id;
+        referenceClosure = '$ACTION_REF_' + identifierPrefix;
+      } else referenceClosure = '$ACTION_ID_' + referenceClosure.id;
       return {
         name: referenceClosure,
-        method: "POST",
-        encType: "multipart/form-data",
-        data: data
+        method: 'POST',
+        encType: 'multipart/form-data',
+        data: data,
       };
     }
     function isSignatureEqual(referenceId, numberOfBoundArgs) {
       var referenceClosure = knownServerReferences.get(this);
       if (!referenceClosure)
         throw Error(
-          "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+          'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
         );
       if (referenceClosure.id !== referenceId) return !1;
       var boundPromise = referenceClosure.bound;
       if (null === boundPromise) return 0 === numberOfBoundArgs;
       switch (boundPromise.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return boundPromise.value.length === numberOfBoundArgs;
-        case "pending":
+        case 'pending':
           throw boundPromise;
-        case "rejected":
+        case 'rejected':
           throw boundPromise.reason;
         default:
           throw (
-            ("string" !== typeof boundPromise.status &&
-              ((boundPromise.status = "pending"),
+            ('string' !== typeof boundPromise.status &&
+              ((boundPromise.status = 'pending'),
               boundPromise.then(
                 function (boundArgs) {
-                  boundPromise.status = "fulfilled";
+                  boundPromise.status = 'fulfilled';
                   boundPromise.value = boundArgs;
                 },
                 function (error) {
-                  boundPromise.status = "rejected";
+                  boundPromise.status = 'rejected';
                   boundPromise.reason = error;
-                }
+                },
               )),
             boundPromise)
           );
@@ -855,36 +855,36 @@
       line,
       col,
       environmentName,
-      innerFunction
+      innerFunction,
     ) {
-      name || (name = "<anonymous>");
+      name || (name = '<anonymous>');
       var encodedName = JSON.stringify(name);
       1 >= line
         ? ((line = encodedName.length + 7),
           (col =
-            "s=>({" +
+            's=>({' +
             encodedName +
-            " ".repeat(col < line ? 0 : col - line) +
-            ":(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */"))
+            ' '.repeat(col < line ? 0 : col - line) +
+            ':(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */'))
         : (col =
-            "/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */" +
-            "\n".repeat(line - 2) +
-            "server=>({" +
+            '/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */' +
+            '\n'.repeat(line - 2) +
+            'server=>({' +
             encodedName +
-            ":\n" +
-            " ".repeat(1 > col ? 0 : col - 1) +
-            "(...args) => server(...args)})");
-      filename.startsWith("/") && (filename = "file://" + filename);
+            ':\n' +
+            ' '.repeat(1 > col ? 0 : col - 1) +
+            '(...args) => server(...args)})');
+      filename.startsWith('/') && (filename = 'file://' + filename);
       sourceMap
         ? ((col +=
-            "\n//# sourceURL=about://React/" +
+            '\n//# sourceURL=about://React/' +
             encodeURIComponent(environmentName) +
-            "/" +
+            '/' +
             encodeURI(filename) +
-            "?s" +
+            '?s' +
             fakeServerFunctionIdx++),
-          (col += "\n//# sourceMappingURL=" + sourceMap))
-        : filename && (col += "\n//# sourceURL=" + filename);
+          (col += '\n//# sourceMappingURL=' + sourceMap))
+        : filename && (col += '\n//# sourceURL=' + filename);
       try {
         return (0, eval)(col)(innerFunction)[name];
       } catch (x) {
@@ -895,13 +895,13 @@
       reference,
       id,
       bound,
-      encodeFormAction
+      encodeFormAction,
     ) {
       knownServerReferences.has(reference) ||
         (knownServerReferences.set(reference, {
           id: id,
           originalBind: reference.bind,
-          bound: bound
+          bound: bound,
         }),
         Object.defineProperties(reference, {
           $$FORM_ACTION: {
@@ -912,16 +912,16 @@
                     var referenceClosure = knownServerReferences.get(this);
                     if (!referenceClosure)
                       throw Error(
-                        "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+                        'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
                       );
                     var boundPromise = referenceClosure.bound;
                     null === boundPromise &&
                       (boundPromise = Promise.resolve([]));
                     return encodeFormAction(referenceClosure.id, boundPromise);
-                  }
+                  },
           },
           $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-          bind: { value: bind }
+          bind: { value: bind },
         }));
     }
     function bind() {
@@ -930,7 +930,7 @@
       var newFn = referenceClosure.originalBind.apply(this, arguments);
       null != arguments[0] &&
         console.error(
-          'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().'
+          'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().',
         );
       var args = ArraySlice.call(arguments, 1),
         boundPromise = null;
@@ -943,12 +943,12 @@
       knownServerReferences.set(newFn, {
         id: referenceClosure.id,
         originalBind: newFn.bind,
-        bound: boundPromise
+        bound: boundPromise,
       });
       Object.defineProperties(newFn, {
         $$FORM_ACTION: { value: this.$$FORM_ACTION },
         $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-        bind: { value: bind }
+        bind: { value: bind },
       });
       return newFn;
     }
@@ -956,12 +956,12 @@
       metaData,
       callServer,
       encodeFormAction,
-      findSourceMapURL
+      findSourceMapURL,
     ) {
       function action() {
         var args = Array.prototype.slice.call(arguments);
         return bound
-          ? "fulfilled" === bound.status
+          ? 'fulfilled' === bound.status
             ? callServer(id, bound.value.concat(args))
             : Promise.resolve(bound).then(function (boundArgs) {
                 return callServer(id, boundArgs.concat(args));
@@ -972,11 +972,11 @@
         bound = metaData.bound,
         location = metaData.location;
       if (location) {
-        var functionName = metaData.name || "",
+        var functionName = metaData.name || '',
           filename = location[1],
           line = location[2];
         location = location[3];
-        metaData = metaData.env || "Server";
+        metaData = metaData.env || 'Server';
         findSourceMapURL =
           null == findSourceMapURL
             ? null
@@ -988,7 +988,7 @@
           line,
           location,
           metaData,
-          action
+          action,
         );
       }
       registerBoundServerReference(action, id, bound, encodeFormAction);
@@ -996,11 +996,11 @@
     }
     function parseStackLocation(error) {
       error = error.stack;
-      error.startsWith("Error: react-stack-top-frame\n") &&
+      error.startsWith('Error: react-stack-top-frame\n') &&
         (error = error.slice(29));
-      var endOfFirst = error.indexOf("\n");
+      var endOfFirst = error.indexOf('\n');
       if (-1 !== endOfFirst) {
-        var endOfSecond = error.indexOf("\n", endOfFirst + 1);
+        var endOfSecond = error.indexOf('\n', endOfFirst + 1);
         endOfFirst =
           -1 === endOfSecond
             ? error.slice(endOfFirst + 1)
@@ -1012,15 +1012,15 @@
         ((error = jscSpiderMonkeyFrameRegExp.exec(endOfFirst)), !error)
       )
         return null;
-      endOfFirst = error[1] || "";
-      "<anonymous>" === endOfFirst && (endOfFirst = "");
-      endOfSecond = error[2] || error[5] || "";
-      "<anonymous>" === endOfSecond && (endOfSecond = "");
+      endOfFirst = error[1] || '';
+      '<anonymous>' === endOfFirst && (endOfFirst = '');
+      endOfSecond = error[2] || error[5] || '';
+      '<anonymous>' === endOfSecond && (endOfSecond = '');
       return [
         endOfFirst,
         endOfSecond,
         +(error[3] || error[6]),
-        +(error[4] || error[7])
+        +(error[4] || error[7]),
       ];
     }
     function createServerReference$1(
@@ -1028,13 +1028,13 @@
       callServer,
       encodeFormAction,
       findSourceMapURL,
-      functionName
+      functionName,
     ) {
       function action() {
         var args = Array.prototype.slice.call(arguments);
         return callServer(id, args);
       }
-      var location = parseStackLocation(Error("react-stack-top-frame"));
+      var location = parseStackLocation(Error('react-stack-top-frame'));
       if (null !== location) {
         var filename = location[1],
           line = location[2];
@@ -1042,15 +1042,15 @@
         findSourceMapURL =
           null == findSourceMapURL
             ? null
-            : findSourceMapURL(filename, "Client");
+            : findSourceMapURL(filename, 'Client');
         action = createFakeServerFunction(
-          functionName || "",
+          functionName || '',
           filename,
           findSourceMapURL,
           line,
           location,
-          "Client",
-          action
+          'Client',
+          action,
         );
       }
       registerBoundServerReference(action, id, null, encodeFormAction);
@@ -1058,52 +1058,52 @@
     }
     function getComponentNameFromType(type) {
       if (null == type) return null;
-      if ("function" === typeof type)
+      if ('function' === typeof type)
         return type.$$typeof === REACT_CLIENT_REFERENCE
           ? null
           : type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_FRAGMENT_TYPE:
-          return "Fragment";
+          return 'Fragment';
         case REACT_PROFILER_TYPE:
-          return "Profiler";
+          return 'Profiler';
         case REACT_STRICT_MODE_TYPE:
-          return "StrictMode";
+          return 'StrictMode';
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
         case REACT_ACTIVITY_TYPE:
-          return "Activity";
+          return 'Activity';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (
-          ("number" === typeof type.tag &&
+          ('number' === typeof type.tag &&
             console.error(
-              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
+              'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.',
             ),
           type.$$typeof)
         ) {
           case REACT_PORTAL_TYPE:
-            return "Portal";
+            return 'Portal';
           case REACT_CONTEXT_TYPE:
-            return type.displayName || "Context";
+            return type.displayName || 'Context';
           case REACT_CONSUMER_TYPE:
-            return (type._context.displayName || "Context") + ".Consumer";
+            return (type._context.displayName || 'Context') + '.Consumer';
           case REACT_FORWARD_REF_TYPE:
             var innerType = type.render;
             type = type.displayName;
             type ||
-              ((type = innerType.displayName || innerType.name || ""),
-              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
+              ((type = innerType.displayName || innerType.name || ''),
+              (type = '' !== type ? 'ForwardRef(' + type + ')' : 'ForwardRef'));
             return type;
           case REACT_MEMO_TYPE:
             return (
               (innerType = type.displayName || null),
               null !== innerType
                 ? innerType
-                : getComponentNameFromType(type.type) || "Memo"
+                : getComponentNameFromType(type.type) || 'Memo'
             );
           case REACT_LAZY_TYPE:
             innerType = type._payload;
@@ -1117,19 +1117,19 @@
     function getArrayKind(array) {
       for (var kind = 0, i = 0; i < array.length; i++) {
         var value = array[i];
-        if ("object" === typeof value && null !== value)
+        if ('object' === typeof value && null !== value)
           if (
             isArrayImpl(value) &&
             2 === value.length &&
-            "string" === typeof value[0]
+            'string' === typeof value[0]
           ) {
             if (0 !== kind && 3 !== kind) return 1;
             kind = 3;
           } else return 1;
         else {
           if (
-            "function" === typeof value ||
-            ("string" === typeof value && 50 < value.length) ||
+            'function' === typeof value ||
+            ('string' === typeof value && 50 < value.length) ||
             (0 !== kind && 2 !== kind)
           )
             return 1;
@@ -1141,7 +1141,7 @@
     function addObjectToProperties(object, properties, indent, prefix) {
       for (var key in object)
         hasOwnProperty.call(object, key) &&
-          "_" !== key[0] &&
+          '_' !== key[0] &&
           addValueToProperties(key, object[key], properties, indent, prefix);
     }
     function addValueToProperties(
@@ -1149,70 +1149,70 @@
       value,
       properties,
       indent,
-      prefix
+      prefix,
     ) {
       switch (typeof value) {
-        case "object":
+        case 'object':
           if (null === value) {
-            value = "null";
+            value = 'null';
             break;
           } else {
             if (value.$$typeof === REACT_ELEMENT_TYPE) {
-              var typeName = getComponentNameFromType(value.type) || "\u2026",
+              var typeName = getComponentNameFromType(value.type) || '\u2026',
                 key = value.key;
               value = value.props;
               var propsKeys = Object.keys(value),
                 propsLength = propsKeys.length;
               if (null == key && 0 === propsLength) {
-                value = "<" + typeName + " />";
+                value = '<' + typeName + ' />';
                 break;
               }
               if (
                 3 > indent ||
                 (1 === propsLength &&
-                  "children" === propsKeys[0] &&
+                  'children' === propsKeys[0] &&
                   null == key)
               ) {
-                value = "<" + typeName + " \u2026 />";
+                value = '<' + typeName + ' \u2026 />';
                 break;
               }
               properties.push([
-                prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-                "<" + typeName
+                prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+                '<' + typeName,
               ]);
               null !== key &&
                 addValueToProperties(
-                  "key",
+                  'key',
                   key,
                   properties,
                   indent + 1,
-                  prefix
+                  prefix,
                 );
               propertyName = !1;
               for (var propKey in value)
-                "children" === propKey
+                'children' === propKey
                   ? null != value.children &&
                     (!isArrayImpl(value.children) ||
                       0 < value.children.length) &&
                     (propertyName = !0)
                   : hasOwnProperty.call(value, propKey) &&
-                    "_" !== propKey[0] &&
+                    '_' !== propKey[0] &&
                     addValueToProperties(
                       propKey,
                       value[propKey],
                       properties,
                       indent + 1,
-                      prefix
+                      prefix,
                     );
               properties.push([
-                "",
-                propertyName ? ">\u2026</" + typeName + ">" : "/>"
+                '',
+                propertyName ? '>\u2026</' + typeName + '>' : '/>',
               ]);
               return;
             }
             typeName = Object.prototype.toString.call(value);
             typeName = typeName.slice(8, typeName.length - 1);
-            if ("Array" === typeName)
+            if ('Array' === typeName)
               if (
                 ((propKey = getArrayKind(value)),
                 2 === propKey || 0 === propKey)
@@ -1221,8 +1221,8 @@
                 break;
               } else if (3 === propKey) {
                 properties.push([
-                  prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-                  ""
+                  prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+                  '',
                 ]);
                 for (
                   propertyName = 0;
@@ -1235,12 +1235,12 @@
                       typeName[1],
                       properties,
                       indent + 1,
-                      prefix
+                      prefix,
                     );
                 return;
               }
-            if ("Promise" === typeName) {
-              if ("fulfilled" === value.status) {
+            if ('Promise' === typeName) {
+              if ('fulfilled' === value.status) {
                 if (
                   ((typeName = properties.length),
                   addValueToProperties(
@@ -1248,189 +1248,189 @@
                     value.value,
                     properties,
                     indent,
-                    prefix
+                    prefix,
                   ),
                   properties.length > typeName)
                 ) {
                   properties = properties[typeName];
                   properties[1] =
-                    "Promise<" + (properties[1] || "Object") + ">";
+                    'Promise<' + (properties[1] || 'Object') + '>';
                   return;
                 }
               } else if (
-                "rejected" === value.status &&
+                'rejected' === value.status &&
                 ((typeName = properties.length),
                 addValueToProperties(
                   propertyName,
                   value.reason,
                   properties,
                   indent,
-                  prefix
+                  prefix,
                 ),
                 properties.length > typeName)
               ) {
                 properties = properties[typeName];
-                properties[1] = "Rejected Promise<" + properties[1] + ">";
+                properties[1] = 'Rejected Promise<' + properties[1] + '>';
                 return;
               }
               properties.push([
-                "\u00a0\u00a0".repeat(indent) + propertyName,
-                "Promise"
+                '\u00a0\u00a0'.repeat(indent) + propertyName,
+                'Promise',
               ]);
               return;
             }
-            "Object" === typeName &&
+            'Object' === typeName &&
               (propKey = Object.getPrototypeOf(value)) &&
-              "function" === typeof propKey.constructor &&
+              'function' === typeof propKey.constructor &&
               (typeName = propKey.constructor.name);
             properties.push([
-              prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-              "Object" === typeName ? (3 > indent ? "" : "\u2026") : typeName
+              prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+              'Object' === typeName ? (3 > indent ? '' : '\u2026') : typeName,
             ]);
             3 > indent &&
               addObjectToProperties(value, properties, indent + 1, prefix);
             return;
           }
-        case "function":
-          value = "" === value.name ? "() => {}" : value.name + "() {}";
+        case 'function':
+          value = '' === value.name ? '() => {}' : value.name + '() {}';
           break;
-        case "string":
+        case 'string':
           value =
-            "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects." ===
+            'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.' ===
             value
-              ? "\u2026"
+              ? '\u2026'
               : JSON.stringify(value);
           break;
-        case "undefined":
-          value = "undefined";
+        case 'undefined':
+          value = 'undefined';
           break;
-        case "boolean":
-          value = value ? "true" : "false";
+        case 'boolean':
+          value = value ? 'true' : 'false';
           break;
         default:
           value = String(value);
       }
       properties.push([
-        prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-        value
+        prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+        value,
       ]);
     }
     function getIODescription(value) {
       try {
         switch (typeof value) {
-          case "object":
-            if (null === value) return "";
+          case 'object':
+            if (null === value) return '';
             if (value instanceof Error) return String(value.message);
-            if ("string" === typeof value.url) return value.url;
-            if ("string" === typeof value.href) return value.href;
-            if ("string" === typeof value.src) return value.src;
-            if ("string" === typeof value.currentSrc) return value.currentSrc;
-            if ("string" === typeof value.command) return value.command;
+            if ('string' === typeof value.url) return value.url;
+            if ('string' === typeof value.href) return value.href;
+            if ('string' === typeof value.src) return value.src;
+            if ('string' === typeof value.currentSrc) return value.currentSrc;
+            if ('string' === typeof value.command) return value.command;
             if (
-              "object" === typeof value.request &&
+              'object' === typeof value.request &&
               null !== value.request &&
-              "string" === typeof value.request.url
+              'string' === typeof value.request.url
             )
               return value.request.url;
             if (
-              "object" === typeof value.response &&
+              'object' === typeof value.response &&
               null !== value.response &&
-              "string" === typeof value.response.url
+              'string' === typeof value.response.url
             )
               return value.response.url;
             if (
-              "string" === typeof value.id ||
-              "number" === typeof value.id ||
-              "bigint" === typeof value.id
+              'string' === typeof value.id ||
+              'number' === typeof value.id ||
+              'bigint' === typeof value.id
             )
               return String(value.id);
-            if ("string" === typeof value.name) return value.name;
+            if ('string' === typeof value.name) return value.name;
             var str = value.toString();
-            return str.startsWith("[object ") ||
+            return str.startsWith('[object ') ||
               5 > str.length ||
               500 < str.length
-              ? ""
+              ? ''
               : str;
-          case "string":
-            return 5 > value.length || 500 < value.length ? "" : value;
-          case "number":
-          case "bigint":
+          case 'string':
+            return 5 > value.length || 500 < value.length ? '' : value;
+          case 'number':
+          case 'bigint':
             return String(value);
           default:
-            return "";
+            return '';
         }
       } catch (x) {
-        return "";
+        return '';
       }
     }
     function markAllTracksInOrder() {
       supportsUserTiming &&
         (console.timeStamp(
-          "Server Requests Track",
+          'Server Requests Track',
           0.001,
           0.001,
-          "Server Requests \u269b",
+          'Server Requests \u269b',
           void 0,
-          "primary-light"
+          'primary-light',
         ),
         console.timeStamp(
-          "Server Components Track",
+          'Server Components Track',
           0.001,
           0.001,
-          "Primary",
-          "Server Components \u269b",
-          "primary-light"
+          'Primary',
+          'Server Components \u269b',
+          'primary-light',
         ));
     }
     function getIOColor(functionName) {
       switch (functionName.charCodeAt(0) % 3) {
         case 0:
-          return "tertiary-light";
+          return 'tertiary-light';
         case 1:
-          return "tertiary";
+          return 'tertiary';
         default:
-          return "tertiary-dark";
+          return 'tertiary-dark';
       }
     }
     function getIOLongName(ioInfo, description, env, rootEnv) {
       ioInfo = ioInfo.name;
       description =
-        "" === description ? ioInfo : ioInfo + " (" + description + ")";
+        '' === description ? ioInfo : ioInfo + ' (' + description + ')';
       return env === rootEnv || void 0 === env
         ? description
-        : description + " [" + env + "]";
+        : description + ' [' + env + ']';
     }
     function getIOShortName(ioInfo, description, env, rootEnv) {
       ioInfo = ioInfo.name;
-      env = env === rootEnv || void 0 === env ? "" : " [" + env + "]";
-      var desc = "";
+      env = env === rootEnv || void 0 === env ? '' : ' [' + env + ']';
+      var desc = '';
       rootEnv = 30 - ioInfo.length - env.length;
       if (1 < rootEnv) {
         var l = description.length;
-        if (0 < l && l <= rootEnv) desc = " (" + description + ")";
+        if (0 < l && l <= rootEnv) desc = ' (' + description + ')';
         else if (
-          description.startsWith("http://") ||
-          description.startsWith("https://") ||
-          description.startsWith("/")
+          description.startsWith('http://') ||
+          description.startsWith('https://') ||
+          description.startsWith('/')
         ) {
-          var queryIdx = description.indexOf("?");
+          var queryIdx = description.indexOf('?');
           -1 === queryIdx && (queryIdx = description.length);
           47 === description.charCodeAt(queryIdx - 1) && queryIdx--;
-          desc = description.lastIndexOf("/", queryIdx - 1);
+          desc = description.lastIndexOf('/', queryIdx - 1);
           queryIdx - desc < rootEnv
-            ? (desc = " (\u2026" + description.slice(desc, queryIdx) + ")")
+            ? (desc = ' (\u2026' + description.slice(desc, queryIdx) + ')')
             : ((l = description.slice(desc, desc + rootEnv / 2)),
               (description = description.slice(
                 queryIdx - rootEnv / 2,
-                queryIdx
+                queryIdx,
               )),
               (desc =
-                " (" +
-                (0 < desc ? "\u2026" : "") +
+                ' (' +
+                (0 < desc ? '\u2026' : '') +
                 l +
-                "\u2026" +
+                '\u2026' +
                 description +
-                ")"));
+                ')'));
         }
       }
       return ioInfo + desc + env;
@@ -1441,7 +1441,7 @@
       startTime,
       endTime,
       rootEnv,
-      value
+      value,
     ) {
       if (supportsUserTiming && 0 < endTime) {
         var description = getIODescription(value),
@@ -1449,22 +1449,22 @@
             asyncInfo.awaited,
             description,
             asyncInfo.env,
-            rootEnv
+            rootEnv,
           ),
-          entryName = "await " + name;
+          entryName = 'await ' + name;
         name = getIOColor(name);
         var debugTask = asyncInfo.debugTask || asyncInfo.awaited.debugTask;
         if (debugTask) {
           var properties = [];
-          "object" === typeof value && null !== value
-            ? addObjectToProperties(value, properties, 0, "")
+          'object' === typeof value && null !== value
+            ? addObjectToProperties(value, properties, 0, '')
             : void 0 !== value &&
-              addValueToProperties("awaited value", value, properties, 0, "");
+              addValueToProperties('awaited value', value, properties, 0, '');
           asyncInfo = getIOLongName(
             asyncInfo.awaited,
             description,
             asyncInfo.env,
-            rootEnv
+            rootEnv,
           );
           debugTask.run(
             performance.measure.bind(performance, entryName, {
@@ -1474,12 +1474,12 @@
                 devtools: {
                   color: name,
                   track: trackNames[trackIdx],
-                  trackGroup: "Server Components \u269b",
+                  trackGroup: 'Server Components \u269b',
                   properties: properties,
-                  tooltipText: asyncInfo
-                }
-              }
-            })
+                  tooltipText: asyncInfo,
+                },
+              },
+            }),
           );
         } else
           console.timeStamp(
@@ -1487,8 +1487,8 @@
             0 > startTime ? 0 : startTime,
             endTime,
             trackNames[trackIdx],
-            "Server Components \u269b",
-            name
+            'Server Components \u269b',
+            name,
           );
       }
     }
@@ -1502,38 +1502,38 @@
         debugTask
           ? ((error = [
               [
-                "rejected with",
-                "object" === typeof error &&
+                'rejected with',
+                'object' === typeof error &&
                 null !== error &&
-                "string" === typeof error.message
+                'string' === typeof error.message
                   ? String(error.message)
-                  : String(error)
-              ]
+                  : String(error),
+              ],
             ]),
             (ioInfo =
               getIOLongName(ioInfo, description, ioInfo.env, rootEnv) +
-              " Rejected"),
+              ' Rejected'),
             debugTask.run(
-              performance.measure.bind(performance, "\u200b" + entryName, {
+              performance.measure.bind(performance, '\u200b' + entryName, {
                 start: 0 > startTime ? 0 : startTime,
                 end: endTime,
                 detail: {
                   devtools: {
-                    color: "error",
-                    track: "Server Requests \u269b",
+                    color: 'error',
+                    track: 'Server Requests \u269b',
                     properties: error,
-                    tooltipText: ioInfo
-                  }
-                }
-              })
+                    tooltipText: ioInfo,
+                  },
+                },
+              }),
             ))
           : console.timeStamp(
               entryName,
               0 > startTime ? 0 : startTime,
               endTime,
-              "Server Requests \u269b",
+              'Server Requests \u269b',
               void 0,
-              "error"
+              'error',
             );
       }
     }
@@ -1547,40 +1547,40 @@
           debugTask = ioInfo.debugTask;
         if (debugTask) {
           var properties = [];
-          "object" === typeof value && null !== value
-            ? addObjectToProperties(value, properties, 0, "")
+          'object' === typeof value && null !== value
+            ? addObjectToProperties(value, properties, 0, '')
             : void 0 !== value &&
-              addValueToProperties("Resolved", value, properties, 0, "");
+              addValueToProperties('Resolved', value, properties, 0, '');
           ioInfo = getIOLongName(ioInfo, description, ioInfo.env, rootEnv);
           debugTask.run(
-            performance.measure.bind(performance, "\u200b" + entryName, {
+            performance.measure.bind(performance, '\u200b' + entryName, {
               start: 0 > startTime ? 0 : startTime,
               end: endTime,
               detail: {
                 devtools: {
                   color: color,
-                  track: "Server Requests \u269b",
+                  track: 'Server Requests \u269b',
                   properties: properties,
-                  tooltipText: ioInfo
-                }
-              }
-            })
+                  tooltipText: ioInfo,
+                },
+              },
+            }),
           );
         } else
           console.timeStamp(
             entryName,
             0 > startTime ? 0 : startTime,
             endTime,
-            "Server Requests \u269b",
+            'Server Requests \u269b',
             void 0,
-            color
+            color,
           );
       }
     }
     function prepareStackTrace(error, structuredStackTrace) {
-      error = (error.name || "Error") + ": " + (error.message || "");
+      error = (error.name || 'Error') + ': ' + (error.message || '');
       for (var i = 0; i < structuredStackTrace.length; i++)
-        error += "\n    at " + structuredStackTrace[i].toString();
+        error += '\n    at ' + structuredStackTrace[i].toString();
       return error;
     }
     function ReactPromise(status, value, reason) {
@@ -1595,27 +1595,27 @@
       weakResponse = weakResponse.weak.deref();
       if (void 0 === weakResponse)
         throw Error(
-          "We did not expect to receive new data after GC:ing the response."
+          'We did not expect to receive new data after GC:ing the response.',
         );
       return weakResponse;
     }
     function closeDebugChannel(debugChannel) {
-      debugChannel.callback && debugChannel.callback("");
+      debugChannel.callback && debugChannel.callback('');
     }
     function readChunk(chunk) {
       switch (chunk.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(chunk);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(chunk);
       }
       switch (chunk.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return chunk.value;
-        case "pending":
-        case "blocked":
-        case "halted":
+        case 'pending':
+        case 'blocked':
+        case 'halted':
           throw chunk;
         default:
           throw chunk.reason;
@@ -1631,39 +1631,39 @@
         null !== response._pendingInitialRender &&
           (clearTimeout(response._pendingInitialRender),
           (response._pendingInitialRender = null)));
-      return new ReactPromise("pending", null, null);
+      return new ReactPromise('pending', null, null);
     }
     function releasePendingChunk(response, chunk) {
-      "pending" === chunk.status &&
+      'pending' === chunk.status &&
         0 === --response._pendingChunks &&
         ((response._weakResponse.response = null),
         (response._pendingInitialRender = setTimeout(
           flushInitialRenderPerformance.bind(null, response),
-          100
+          100,
         )));
     }
     function moveDebugInfoFromChunkToInnerValue(chunk, value) {
       value = resolveLazy(value);
-      "object" !== typeof value ||
+      'object' !== typeof value ||
         null === value ||
         (!isArrayImpl(value) &&
-          "function" !== typeof value[ASYNC_ITERATOR] &&
+          'function' !== typeof value[ASYNC_ITERATOR] &&
           value.$$typeof !== REACT_ELEMENT_TYPE &&
           value.$$typeof !== REACT_LAZY_TYPE) ||
         ((chunk = chunk._debugInfo.splice(0)),
         isArrayImpl(value._debugInfo)
           ? value._debugInfo.unshift.apply(value._debugInfo, chunk)
-          : Object.defineProperty(value, "_debugInfo", {
+          : Object.defineProperty(value, '_debugInfo', {
               configurable: !1,
               enumerable: !1,
               writable: !0,
-              value: chunk
+              value: chunk,
             }));
     }
     function wakeChunk(listeners, value, chunk) {
       for (var i = 0; i < listeners.length; i++) {
         var listener = listeners[i];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(value)
           : fulfillReference(listener, value, chunk);
       }
@@ -1672,7 +1672,7 @@
     function rejectChunk(listeners, error) {
       for (var i = 0; i < listeners.length; i++) {
         var listener = listeners[i];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(error)
           : rejectReference(listener, error);
       }
@@ -1690,7 +1690,7 @@
         ) {
           var listener = reference[referencedChunk];
           if (
-            "function" !== typeof listener &&
+            'function' !== typeof listener &&
             ((listener = resolveBlockedCycle(resolvedChunk, listener)),
             null !== listener)
           )
@@ -1700,13 +1700,13 @@
     }
     function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
       switch (chunk.status) {
-        case "fulfilled":
+        case 'fulfilled':
           wakeChunk(resolveListeners, chunk.value, chunk);
           break;
-        case "blocked":
+        case 'blocked':
           for (var i = 0; i < resolveListeners.length; i++) {
             var listener = resolveListeners[i];
-            if ("function" !== typeof listener) {
+            if ('function' !== typeof listener) {
               var cyclicHandler = resolveBlockedCycle(chunk, listener);
               null !== cyclicHandler &&
                 (fulfillReference(listener, cyclicHandler.value, chunk),
@@ -1717,7 +1717,7 @@
                   -1 !== listener && rejectListeners.splice(listener, 1)));
             }
           }
-        case "pending":
+        case 'pending':
           if (chunk.value)
             for (i = 0; i < resolveListeners.length; i++)
               chunk.value.push(resolveListeners[i]);
@@ -1732,21 +1732,21 @@
                 chunk.reason.push(rejectListeners[resolveListeners]);
           } else chunk.reason = rejectListeners;
           break;
-        case "rejected":
+        case 'rejected':
           rejectListeners && rejectChunk(rejectListeners, chunk.reason);
       }
     }
     function triggerErrorOnChunk(response, chunk, error) {
-      if ("pending" !== chunk.status && "blocked" !== chunk.status)
+      if ('pending' !== chunk.status && 'blocked' !== chunk.status)
         chunk.reason.error(error);
       else {
         releasePendingChunk(response, chunk);
         var listeners = chunk.reason;
-        if ("pending" === chunk.status && null != chunk._debugChunk) {
+        if ('pending' === chunk.status && null != chunk._debugChunk) {
           var prevHandler = initializingHandler,
             prevChunk = initializingChunk;
           initializingHandler = null;
-          chunk.status = "blocked";
+          chunk.status = 'blocked';
           chunk.value = null;
           chunk.reason = null;
           initializingChunk = chunk;
@@ -1757,21 +1757,21 @@
               (initializingChunk = prevChunk);
           }
         }
-        chunk.status = "rejected";
+        chunk.status = 'rejected';
         chunk.reason = error;
         null !== listeners && rejectChunk(listeners, error);
       }
     }
     function createResolvedModelChunk(response, value) {
-      return new ReactPromise("resolved_model", value, response);
+      return new ReactPromise('resolved_model', value, response);
     }
     function createResolvedIteratorResultChunk(response, value, done) {
       return new ReactPromise(
-        "resolved_model",
+        'resolved_model',
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
-        response
+          '}',
+        response,
       );
     }
     function resolveIteratorResultChunk(response, chunk, value, done) {
@@ -1780,16 +1780,16 @@
         chunk,
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}"
+          '}',
       );
     }
     function resolveModelChunk(response, chunk, value) {
-      if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+      if ('pending' !== chunk.status) chunk.reason.enqueueModel(value);
       else {
         releasePendingChunk(response, chunk);
         var resolveListeners = chunk.value,
           rejectListeners = chunk.reason;
-        chunk.status = "resolved_model";
+        chunk.status = 'resolved_model';
         chunk.value = value;
         chunk.reason = response;
         null !== resolveListeners &&
@@ -1798,11 +1798,11 @@
       }
     }
     function resolveModuleChunk(response, chunk, value) {
-      if ("pending" === chunk.status || "blocked" === chunk.status) {
+      if ('pending' === chunk.status || 'blocked' === chunk.status) {
         releasePendingChunk(response, chunk);
         response = chunk.value;
         var rejectListeners = chunk.reason;
-        chunk.status = "resolved_module";
+        chunk.status = 'resolved_module';
         chunk.value = value;
         value = [];
         null !== value && chunk._debugInfo.push.apply(chunk._debugInfo, value);
@@ -1816,31 +1816,31 @@
       if (null !== debugChunk) {
         var debugInfo = chunk._debugInfo;
         try {
-          if ("resolved_model" === debugChunk.status) {
+          if ('resolved_model' === debugChunk.status) {
             for (
               var idx = debugInfo.length, c = debugChunk._debugChunk;
               null !== c;
 
             )
-              "fulfilled" !== c.status && idx++, (c = c._debugChunk);
+              'fulfilled' !== c.status && idx++, (c = c._debugChunk);
             initializeModelChunk(debugChunk);
             switch (debugChunk.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 debugInfo[idx] = initializeDebugInfo(
                   response,
-                  debugChunk.value
+                  debugChunk.value,
                 );
                 break;
-              case "blocked":
-              case "pending":
+              case 'blocked':
+              case 'pending':
                 waitForReference(
                   debugChunk,
                   debugInfo,
-                  "" + idx,
+                  '' + idx,
                   response,
                   initializeDebugInfo,
-                  [""],
-                  !0
+                  [''],
+                  !0,
                 );
                 break;
               default:
@@ -1848,18 +1848,18 @@
             }
           } else
             switch (debugChunk.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 break;
-              case "blocked":
-              case "pending":
+              case 'blocked':
+              case 'pending':
                 waitForReference(
                   debugChunk,
                   {},
-                  "debug",
+                  'debug',
                   response,
                   initializeDebugInfo,
-                  [""],
-                  !0
+                  [''],
+                  !0,
                 );
                 break;
               default:
@@ -1876,7 +1876,7 @@
       initializingHandler = null;
       var resolvedModel = chunk.value,
         response = chunk.reason;
-      chunk.status = "blocked";
+      chunk.status = 'blocked';
       chunk.value = null;
       chunk.reason = null;
       initializingChunk = chunk;
@@ -1891,7 +1891,7 @@
             resolvedModel++
           ) {
             var listener = resolveListeners[resolvedModel];
-            "function" === typeof listener
+            'function' === typeof listener
               ? listener(value)
               : fulfillReference(listener, value, chunk);
           }
@@ -1903,11 +1903,11 @@
             return;
           }
         }
-        chunk.status = "fulfilled";
+        chunk.status = 'fulfilled';
         chunk.value = value;
         moveDebugInfoFromChunkToInnerValue(chunk, value);
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       } finally {
         (initializingHandler = prevHandler), (initializingChunk = prevChunk);
       }
@@ -1915,10 +1915,10 @@
     function initializeModuleChunk(chunk) {
       try {
         var value = requireModule(chunk.value);
-        chunk.status = "fulfilled";
+        chunk.status = 'fulfilled';
         chunk.value = value;
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       }
     }
     function reportGlobalError(weakResponse, error) {
@@ -1927,7 +1927,7 @@
         response._closed = !0;
         response._closedReason = error;
         response._chunks.forEach(function (chunk) {
-          "pending" === chunk.status &&
+          'pending' === chunk.status &&
             triggerErrorOnChunk(response, chunk, error);
         });
         weakResponse = response._debugChannel;
@@ -1942,19 +1942,19 @@
       return null;
     }
     function getTaskName(type) {
-      if (type === REACT_FRAGMENT_TYPE) return "<>";
-      if ("function" === typeof type) return '"use client"';
+      if (type === REACT_FRAGMENT_TYPE) return '<>';
+      if ('function' === typeof type) return '"use client"';
       if (
-        "object" === typeof type &&
+        'object' === typeof type &&
         null !== type &&
         type.$$typeof === REACT_LAZY_TYPE
       )
-        return type._init === readChunk ? '"use client"' : "<...>";
+        return type._init === readChunk ? '"use client"' : '<...>';
       try {
         var name = getComponentNameFromType(type);
-        return name ? "<" + name + ">" : "<...>";
+        return name ? '<' + name + '>' : '<...>';
       } catch (x) {
-        return "<...>";
+        return '<...>';
       }
     }
     function initializeElement(response, element, lazyNode) {
@@ -1970,7 +1970,7 @@
           (normalizedStackTrace = createFakeJSXCallStackInDEV(
             response,
             stack,
-            env
+            env,
           ));
       element._debugStack = normalizedStackTrace;
       normalizedStackTrace = null;
@@ -1978,14 +1978,14 @@
         null !== stack &&
         ((normalizedStackTrace = console.createTask.bind(
           console,
-          getTaskName(element.type)
+          getTaskName(element.type),
         )),
         (stack = buildFakeCallStack(
           response,
           stack,
           env,
           !1,
-          normalizedStackTrace
+          normalizedStackTrace,
         )),
         (env = null === owner ? null : initializeFakeTask(response, owner)),
         null === env
@@ -1999,16 +1999,16 @@
           lazyNode._store.validated &&
           !element._store.validated &&
           (element._store.validated = lazyNode._store.validated),
-        "fulfilled" === lazyNode._payload.status &&
+        'fulfilled' === lazyNode._payload.status &&
           lazyNode._debugInfo &&
           ((response = lazyNode._debugInfo.splice(0)),
           element._debugInfo
             ? element._debugInfo.unshift.apply(element._debugInfo, response)
-            : Object.defineProperty(element, "_debugInfo", {
+            : Object.defineProperty(element, '_debugInfo', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: response
+                value: response,
               })));
       Object.freeze(element.props);
     }
@@ -2016,7 +2016,7 @@
       var lazyType = {
         $$typeof: REACT_LAZY_TYPE,
         _payload: chunk,
-        _init: readChunk
+        _init: readChunk,
       };
       lazyType._debugInfo = chunk._debugInfo;
       lazyType._store = { validated: validated };
@@ -2027,7 +2027,7 @@
         chunk = chunks.get(id);
       chunk ||
         ((chunk = response._closed
-          ? new ReactPromise("rejected", null, response._closedReason)
+          ? new ReactPromise('rejected', null, response._closedReason)
           : createPendingChunk(response)),
         chunks.set(id, chunk));
       return chunk;
@@ -2046,7 +2046,7 @@
       ) {
         for (
           ;
-          "object" === typeof value &&
+          'object' === typeof value &&
           null !== value &&
           value.$$typeof === REACT_LAZY_TYPE;
 
@@ -2055,23 +2055,23 @@
             value = handler.value;
           else {
             switch (value.status) {
-              case "resolved_model":
+              case 'resolved_model':
                 initializeModelChunk(value);
                 break;
-              case "resolved_module":
+              case 'resolved_module':
                 initializeModuleChunk(value);
             }
             switch (value.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 value = value.value;
                 continue;
-              case "blocked":
+              case 'blocked':
                 var cyclicHandler = resolveBlockedCycle(value, reference);
                 if (null !== cyclicHandler) {
                   value = cyclicHandler.value;
                   continue;
                 }
-              case "pending":
+              case 'pending':
                 path.splice(0, i - 1);
                 null === value.value
                   ? (value.value = [reference])
@@ -2080,7 +2080,7 @@
                   ? (value.reason = [reference])
                   : value.reason.push(reference);
                 return;
-              case "halted":
+              case 'halted':
                 return;
               default:
                 rejectReference(reference, value.reason);
@@ -2091,7 +2091,7 @@
       }
       for (
         ;
-        "object" === typeof value &&
+        'object' === typeof value &&
         null !== value &&
         value.$$typeof === REACT_LAZY_TYPE;
 
@@ -2100,14 +2100,14 @@
           value = handler.value;
         else {
           switch (path.status) {
-            case "resolved_model":
+            case 'resolved_model':
               initializeModelChunk(path);
               break;
-            case "resolved_module":
+            case 'resolved_module':
               initializeModuleChunk(path);
           }
           switch (path.status) {
-            case "fulfilled":
+            case 'fulfilled':
               value = path.value;
               continue;
           }
@@ -2115,22 +2115,22 @@
         }
       response = map(response, value, parentObject, key);
       parentObject[key] = response;
-      "" === key && null === handler.value && (handler.value = response);
+      '' === key && null === handler.value && (handler.value = response);
       if (
         parentObject[0] === REACT_ELEMENT_TYPE &&
-        "object" === typeof handler.value &&
+        'object' === typeof handler.value &&
         null !== handler.value &&
         handler.value.$$typeof === REACT_ELEMENT_TYPE
       )
         switch (((reference = handler.value), key)) {
-          case "3":
+          case '3':
             transferReferencedDebugInfo(handler.chunk, fulfilledChunk);
             reference.props = response;
             break;
-          case "4":
+          case '4':
             reference._owner = response;
             break;
-          case "5":
+          case '5':
             reference._debugStack = response;
             break;
           default:
@@ -2143,9 +2143,9 @@
       0 === handler.deps &&
         ((fulfilledChunk = handler.chunk),
         null !== fulfilledChunk &&
-          "blocked" === fulfilledChunk.status &&
+          'blocked' === fulfilledChunk.status &&
           ((key = fulfilledChunk.value),
-          (fulfilledChunk.status = "fulfilled"),
+          (fulfilledChunk.status = 'fulfilled'),
           (fulfilledChunk.value = handler.value),
           (fulfilledChunk.reason = handler.reason),
           null !== key && wakeChunk(key, handler.value, fulfilledChunk)));
@@ -2159,15 +2159,15 @@
         handler.value = null;
         handler.reason = error;
         handler = handler.chunk;
-        if (null !== handler && "blocked" === handler.status) {
+        if (null !== handler && 'blocked' === handler.status) {
           if (
-            "object" === typeof blockedValue &&
+            'object' === typeof blockedValue &&
             null !== blockedValue &&
             blockedValue.$$typeof === REACT_ELEMENT_TYPE
           ) {
             var erroredComponent = {
-              name: getComponentNameFromType(blockedValue.type) || "",
-              owner: blockedValue._owner
+              name: getComponentNameFromType(blockedValue.type) || '',
+              owner: blockedValue._owner,
             };
             erroredComponent.debugStack = blockedValue._debugStack;
             supportsCreateTask &&
@@ -2185,15 +2185,15 @@
       response,
       map,
       path,
-      isAwaitingDebugInfo
+      isAwaitingDebugInfo,
     ) {
       if (
         !(
           (void 0 !== response._debugChannel &&
             response._debugChannel.hasReadable) ||
-          "pending" !== referencedChunk.status ||
+          'pending' !== referencedChunk.status ||
           parentObject[0] !== REACT_ELEMENT_TYPE ||
-          ("4" !== key && "5" !== key)
+          ('4' !== key && '5' !== key)
         )
       )
         return null;
@@ -2207,7 +2207,7 @@
           value: null,
           reason: null,
           deps: 1,
-          errored: !1
+          errored: !1,
         };
       parentObject = {
         response: response,
@@ -2215,7 +2215,7 @@
         parentObject: parentObject,
         key: key,
         map: map,
-        path: path
+        path: path,
       };
       parentObject.isDebug = isAwaitingDebugInfo;
       null === referencedChunk.value
@@ -2232,11 +2232,11 @@
           metaData,
           response._callServer,
           response._encodeFormAction,
-          response._debugFindSourceMapURL
+          response._debugFindSourceMapURL,
         );
       var serverReference = resolveServerReference(
           response._serverReferenceConfig,
-          metaData.id
+          metaData.id,
         ),
         promise = preloadModule(serverReference);
       if (promise)
@@ -2249,7 +2249,7 @@
             promise,
             metaData.id,
             metaData.bound,
-            response._encodeFormAction
+            response._encodeFormAction,
           ),
           promise
         );
@@ -2263,7 +2263,7 @@
           value: null,
           reason: null,
           deps: 1,
-          errored: !1
+          errored: !1,
         };
       promise.then(
         function () {
@@ -2277,32 +2277,32 @@
             resolvedValue,
             metaData.id,
             metaData.bound,
-            response._encodeFormAction
+            response._encodeFormAction,
           );
           parentObject[key] = resolvedValue;
-          "" === key &&
+          '' === key &&
             null === handler.value &&
             (handler.value = resolvedValue);
           if (
             parentObject[0] === REACT_ELEMENT_TYPE &&
-            "object" === typeof handler.value &&
+            'object' === typeof handler.value &&
             null !== handler.value &&
             handler.value.$$typeof === REACT_ELEMENT_TYPE
           )
             switch (((boundArgs = handler.value), key)) {
-              case "3":
+              case '3':
                 boundArgs.props = resolvedValue;
                 break;
-              case "4":
+              case '4':
                 boundArgs._owner = resolvedValue;
             }
           handler.deps--;
           0 === handler.deps &&
             ((resolvedValue = handler.chunk),
             null !== resolvedValue &&
-              "blocked" === resolvedValue.status &&
+              'blocked' === resolvedValue.status &&
               ((boundArgs = resolvedValue.value),
-              (resolvedValue.status = "fulfilled"),
+              (resolvedValue.status = 'fulfilled'),
               (resolvedValue.value = handler.value),
               null !== boundArgs &&
                 wakeChunk(boundArgs, handler.value, resolvedValue)));
@@ -2314,15 +2314,15 @@
             handler.value = null;
             handler.reason = error;
             var chunk = handler.chunk;
-            if (null !== chunk && "blocked" === chunk.status) {
+            if (null !== chunk && 'blocked' === chunk.status) {
               if (
-                "object" === typeof blockedValue &&
+                'object' === typeof blockedValue &&
                 null !== blockedValue &&
                 blockedValue.$$typeof === REACT_ELEMENT_TYPE
               ) {
                 var erroredComponent = {
-                  name: getComponentNameFromType(blockedValue.type) || "",
-                  owner: blockedValue._owner
+                  name: getComponentNameFromType(blockedValue.type) || '',
+                  owner: blockedValue._owner,
                 };
                 erroredComponent.debugStack = blockedValue._debugStack;
                 supportsCreateTask &&
@@ -2332,20 +2332,20 @@
               triggerErrorOnChunk(response, chunk, error);
             }
           }
-        }
+        },
       );
       return null;
     }
     function resolveLazy(value) {
       for (
         ;
-        "object" === typeof value &&
+        'object' === typeof value &&
         null !== value &&
         value.$$typeof === REACT_LAZY_TYPE;
 
       ) {
         var payload = value._payload;
-        if ("fulfilled" === payload.status) value = payload.value;
+        if ('fulfilled' === payload.status) value = payload.value;
         else break;
       }
       return value;
@@ -2361,43 +2361,43 @@
       }
     }
     function getOutlinedModel(response, reference, parentObject, key, map) {
-      var path = reference.split(":");
+      var path = reference.split(':');
       reference = parseInt(path[0], 16);
       reference = getChunk(response, reference);
       null !== initializingChunk &&
         isArrayImpl(initializingChunk._children) &&
         initializingChunk._children.push(reference);
       switch (reference.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(reference);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(reference);
       }
       switch (reference.status) {
-        case "fulfilled":
+        case 'fulfilled':
           for (var value = reference.value, i = 1; i < path.length; i++) {
             for (
               ;
-              "object" === typeof value &&
+              'object' === typeof value &&
               null !== value &&
               value.$$typeof === REACT_LAZY_TYPE;
 
             ) {
               value = value._payload;
               switch (value.status) {
-                case "resolved_model":
+                case 'resolved_model':
                   initializeModelChunk(value);
                   break;
-                case "resolved_module":
+                case 'resolved_module':
                   initializeModuleChunk(value);
               }
               switch (value.status) {
-                case "fulfilled":
+                case 'fulfilled':
                   value = value.value;
                   break;
-                case "blocked":
-                case "pending":
+                case 'blocked':
+                case 'pending':
                   return waitForReference(
                     value,
                     parentObject,
@@ -2405,9 +2405,9 @@
                     response,
                     map,
                     path.slice(i - 1),
-                    !1
+                    !1,
                   );
-                case "halted":
+                case 'halted':
                   return (
                     initializingHandler
                       ? ((parentObject = initializingHandler),
@@ -2418,7 +2418,7 @@
                           value: null,
                           reason: null,
                           deps: 1,
-                          errored: !1
+                          errored: !1,
                         }),
                     null
                   );
@@ -2434,7 +2434,7 @@
                           value: null,
                           reason: value.reason,
                           deps: 0,
-                          errored: !0
+                          errored: !0,
                         }),
                     null
                   );
@@ -2444,21 +2444,21 @@
           }
           for (
             ;
-            "object" === typeof value &&
+            'object' === typeof value &&
             null !== value &&
             value.$$typeof === REACT_LAZY_TYPE;
 
           ) {
             path = value._payload;
             switch (path.status) {
-              case "resolved_model":
+              case 'resolved_model':
                 initializeModelChunk(path);
                 break;
-              case "resolved_module":
+              case 'resolved_module':
                 initializeModuleChunk(path);
             }
             switch (path.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 value = path.value;
                 continue;
             }
@@ -2466,11 +2466,11 @@
           }
           response = map(response, value, parentObject, key);
           (parentObject[0] !== REACT_ELEMENT_TYPE ||
-            ("4" !== key && "5" !== key)) &&
+            ('4' !== key && '5' !== key)) &&
             transferReferencedDebugInfo(initializingChunk, reference);
           return response;
-        case "pending":
-        case "blocked":
+        case 'pending':
+        case 'blocked':
           return waitForReference(
             reference,
             parentObject,
@@ -2478,9 +2478,9 @@
             response,
             map,
             path,
-            !1
+            !1,
           );
-        case "halted":
+        case 'halted':
           return (
             initializingHandler
               ? ((parentObject = initializingHandler), parentObject.deps++)
@@ -2490,7 +2490,7 @@
                   value: null,
                   reason: null,
                   deps: 1,
-                  errored: !1
+                  errored: !1,
                 }),
             null
           );
@@ -2506,7 +2506,7 @@
                   value: null,
                   reason: reference.reason,
                   deps: 0,
-                  errored: !0
+                  errored: !0,
                 }),
             null
           );
@@ -2533,17 +2533,17 @@
     function defineLazyGetter(response, chunk, parentObject, key) {
       Object.defineProperty(parentObject, key, {
         get: function () {
-          "resolved_model" === chunk.status && initializeModelChunk(chunk);
+          'resolved_model' === chunk.status && initializeModelChunk(chunk);
           switch (chunk.status) {
-            case "fulfilled":
+            case 'fulfilled':
               return chunk.value;
-            case "rejected":
+            case 'rejected':
               throw chunk.reason;
           }
-          return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
+          return 'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.';
         },
         enumerable: !0,
-        configurable: !1
+        configurable: !1,
       });
       return null;
     }
@@ -2554,56 +2554,56 @@
       return model;
     }
     function getInferredFunctionApproximate(code) {
-      code = code.startsWith("Object.defineProperty(")
+      code = code.startsWith('Object.defineProperty(')
         ? code.slice(22)
-        : code.startsWith("(")
+        : code.startsWith('(')
           ? code.slice(1)
           : code;
-      if (code.startsWith("async function")) {
-        var idx = code.indexOf("(", 14);
+      if (code.startsWith('async function')) {
+        var idx = code.indexOf('(', 14);
         if (-1 !== idx)
           return (
             (code = code.slice(14, idx).trim()),
-            (0, eval)("({" + JSON.stringify(code) + ":async function(){}})")[
+            (0, eval)('({' + JSON.stringify(code) + ':async function(){}})')[
               code
             ]
           );
-      } else if (code.startsWith("function")) {
-        if (((idx = code.indexOf("(", 8)), -1 !== idx))
+      } else if (code.startsWith('function')) {
+        if (((idx = code.indexOf('(', 8)), -1 !== idx))
           return (
             (code = code.slice(8, idx).trim()),
-            (0, eval)("({" + JSON.stringify(code) + ":function(){}})")[code]
+            (0, eval)('({' + JSON.stringify(code) + ':function(){}})')[code]
           );
       } else if (
-        code.startsWith("class") &&
-        ((idx = code.indexOf("{", 5)), -1 !== idx)
+        code.startsWith('class') &&
+        ((idx = code.indexOf('{', 5)), -1 !== idx)
       )
         return (
           (code = code.slice(5, idx).trim()),
-          (0, eval)("({" + JSON.stringify(code) + ":class{}})")[code]
+          (0, eval)('({' + JSON.stringify(code) + ':class{}})')[code]
         );
       return function () {};
     }
     function parseModelString(response, parentObject, key, value) {
-      if ("$" === value[0]) {
-        if ("$" === value)
+      if ('$' === value[0]) {
+        if ('$' === value)
           return (
             null !== initializingHandler &&
-              "0" === key &&
+              '0' === key &&
               (initializingHandler = {
                 parent: initializingHandler,
                 chunk: null,
                 value: null,
                 reason: null,
                 deps: 0,
-                errored: !1
+                errored: !1,
               }),
             REACT_ELEMENT_TYPE
           );
         switch (value[1]) {
-          case "$":
+          case '$':
             return value.slice(1);
-          case "L":
+          case 'L':
             return (
               (parentObject = parseInt(value.slice(2), 16)),
               (response = getChunk(response, parentObject)),
@@ -2612,7 +2612,7 @@
                 initializingChunk._children.push(response),
               createLazyChunkWrapper(response, 0)
             );
-          case "@":
+          case '@':
             return (
               (parentObject = parseInt(value.slice(2), 16)),
               (response = getChunk(response, parentObject)),
@@ -2621,46 +2621,46 @@
                 initializingChunk._children.push(response),
               response
             );
-          case "S":
+          case 'S':
             return Symbol.for(value.slice(2));
-          case "F":
+          case 'F':
             var ref = value.slice(2);
             return getOutlinedModel(
               response,
               ref,
               parentObject,
               key,
-              loadServerReference
+              loadServerReference,
             );
-          case "T":
-            parentObject = "$" + value.slice(2);
+          case 'T':
+            parentObject = '$' + value.slice(2);
             response = response._tempRefs;
             if (null == response)
               throw Error(
-                "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+                'Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.',
               );
             return response.get(parentObject);
-          case "Q":
+          case 'Q':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createMap)
             );
-          case "W":
+          case 'W':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createSet)
             );
-          case "B":
+          case 'B':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createBlob)
             );
-          case "K":
+          case 'K':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createFormData)
             );
-          case "Z":
+          case 'Z':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2668,10 +2668,10 @@
                 ref,
                 parentObject,
                 key,
-                resolveErrorDev
+                resolveErrorDev,
               )
             );
-          case "i":
+          case 'i':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2679,22 +2679,22 @@
                 ref,
                 parentObject,
                 key,
-                extractIterator
+                extractIterator,
               )
             );
-          case "I":
+          case 'I':
             return Infinity;
-          case "-":
-            return "$-0" === value ? -0 : -Infinity;
-          case "N":
+          case '-':
+            return '$-0' === value ? -0 : -Infinity;
+          case 'N':
             return NaN;
-          case "u":
+          case 'u':
             return;
-          case "D":
+          case 'D':
             return new Date(Date.parse(value.slice(2)));
-          case "n":
+          case 'n':
             return BigInt(value.slice(2));
-          case "P":
+          case 'P':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2702,10 +2702,10 @@
                 ref,
                 parentObject,
                 key,
-                applyConstructor
+                applyConstructor,
               )
             );
-          case "E":
+          case 'E':
             response = value.slice(2);
             try {
               if (!mightHaveStaticConstructor.test(response))
@@ -2714,46 +2714,46 @@
             try {
               if (
                 ((ref = getInferredFunctionApproximate(response)),
-                response.startsWith("Object.defineProperty("))
+                response.startsWith('Object.defineProperty('))
               ) {
                 var idx = response.lastIndexOf(',"name",{value:"');
                 if (-1 !== idx) {
                   var name = JSON.parse(
-                    response.slice(idx + 16 - 1, response.length - 2)
+                    response.slice(idx + 16 - 1, response.length - 2),
                   );
-                  Object.defineProperty(ref, "name", { value: name });
+                  Object.defineProperty(ref, 'name', { value: name });
                 }
               }
             } catch (_) {
               ref = function () {};
             }
             return ref;
-          case "Y":
+          case 'Y':
             if (
               2 < value.length &&
               (ref = response._debugChannel && response._debugChannel.callback)
             ) {
-              if ("@" === value[2])
+              if ('@' === value[2])
                 return (
                   (parentObject = value.slice(3)),
                   (key = parseInt(parentObject, 16)),
-                  response._chunks.has(key) || ref("P:" + parentObject),
+                  response._chunks.has(key) || ref('P:' + parentObject),
                   getChunk(response, key)
                 );
               value = value.slice(2);
               idx = parseInt(value, 16);
-              response._chunks.has(idx) || ref("Q:" + value);
+              response._chunks.has(idx) || ref('Q:' + value);
               ref = getChunk(response, idx);
-              return "fulfilled" === ref.status
+              return 'fulfilled' === ref.status
                 ? ref.value
                 : defineLazyGetter(response, ref, parentObject, key);
             }
             Object.defineProperty(parentObject, key, {
               get: function () {
-                return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
+                return 'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.';
               },
               enumerable: !0,
-              configurable: !1
+              configurable: !1,
             });
             return null;
           default:
@@ -2767,7 +2767,7 @@
     }
     function missingCall() {
       throw Error(
-        'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+        'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.',
       );
     }
     function ResponseInstance(
@@ -2781,7 +2781,7 @@
       findSourceMapURL,
       replayConsole,
       environmentName,
-      debugChannel
+      debugChannel,
     ) {
       var chunks = new Map();
       this._bundlerConfig = bundlerConfig;
@@ -2806,11 +2806,11 @@
           ? null
           : ReactSharedInteralsServer.A.getOwner();
       this._debugRootStack =
-        null !== bundlerConfig ? Error("react-stack-top-frame") : null;
-      environmentName = void 0 === environmentName ? "Server" : environmentName;
+        null !== bundlerConfig ? Error('react-stack-top-frame') : null;
+      environmentName = void 0 === environmentName ? 'Server' : environmentName;
       supportsCreateTask &&
         (this._debugRootTask = console.createTask(
-          '"use ' + environmentName.toLowerCase() + '"'
+          '"use ' + environmentName.toLowerCase() + '"',
         ));
       this._debugStartTime = performance.now();
       this._debugFindSourceMapURL = findSourceMapURL;
@@ -2831,46 +2831,46 @@
         _rowID: 0,
         _rowTag: 0,
         _rowLength: 0,
-        _buffer: []
+        _buffer: [],
       };
       weakResponse = unwrapWeakResponse(weakResponse);
       var debugValuePromise = Promise.resolve(streamDebugValue);
-      debugValuePromise.status = "fulfilled";
+      debugValuePromise.status = 'fulfilled';
       debugValuePromise.value = streamDebugValue;
       streamState._debugInfo = {
-        name: "RSC stream",
+        name: 'RSC stream',
         start: weakResponse._debugStartTime,
         end: weakResponse._debugStartTime,
         byteSize: 0,
         value: debugValuePromise,
         owner: weakResponse._debugRootOwner,
         debugStack: weakResponse._debugRootStack,
-        debugTask: weakResponse._debugRootTask
+        debugTask: weakResponse._debugRootTask,
       };
       streamState._debugTargetChunkSize = MIN_CHUNK_SIZE;
       return streamState;
     }
     function addDebugInfo(chunk, debugInfo) {
       var value = resolveLazy(chunk.value);
-      "object" !== typeof value ||
+      'object' !== typeof value ||
       null === value ||
       (!isArrayImpl(value) &&
-        "function" !== typeof value[ASYNC_ITERATOR] &&
+        'function' !== typeof value[ASYNC_ITERATOR] &&
         value.$$typeof !== REACT_ELEMENT_TYPE &&
         value.$$typeof !== REACT_LAZY_TYPE)
         ? chunk._debugInfo.push.apply(chunk._debugInfo, debugInfo)
         : isArrayImpl(value._debugInfo)
           ? value._debugInfo.push.apply(value._debugInfo, debugInfo)
-          : Object.defineProperty(value, "_debugInfo", {
+          : Object.defineProperty(value, '_debugInfo', {
               configurable: !1,
               enumerable: !1,
               writable: !0,
-              value: debugInfo
+              value: debugInfo,
             });
     }
     function resolveChunkDebugInfo(streamState, chunk) {
       streamState = [{ awaited: streamState._debugInfo }];
-      "pending" === chunk.status || "blocked" === chunk.status
+      'pending' === chunk.status || 'blocked' === chunk.status
         ? ((streamState = addDebugInfo.bind(null, chunk, streamState)),
           chunk.then(streamState, streamState))
         : addDebugInfo(chunk, streamState);
@@ -2878,10 +2878,10 @@
     function resolveBuffer(response, id, buffer, streamState) {
       var chunks = response._chunks,
         chunk = chunks.get(id);
-      chunk && "pending" !== chunk.status
+      chunk && 'pending' !== chunk.status
         ? chunk.reason.enqueueValue(buffer)
         : (chunk && releasePendingChunk(response, chunk),
-          (response = new ReactPromise("fulfilled", buffer, null)),
+          (response = new ReactPromise('fulfilled', buffer, null)),
           resolveChunkDebugInfo(streamState, response),
           chunks.set(id, response));
     }
@@ -2891,20 +2891,20 @@
       model = JSON.parse(model, response._fromJSON);
       var clientReference = resolveClientReference(
         response._bundlerConfig,
-        model
+        model,
       );
       prepareDestinationWithChunks(
         response._moduleLoading,
         model[1],
-        response._nonce
+        response._nonce,
       );
       if ((model = preloadModule(clientReference))) {
         if (chunk) {
           releasePendingChunk(response, chunk);
           var blockedChunk = chunk;
-          blockedChunk.status = "blocked";
+          blockedChunk.status = 'blocked';
         } else
-          (blockedChunk = new ReactPromise("blocked", null, null)),
+          (blockedChunk = new ReactPromise('blocked', null, null)),
             chunks.set(id, blockedChunk);
         resolveChunkDebugInfo(streamState, blockedChunk);
         model.then(
@@ -2913,16 +2913,16 @@
           },
           function (error) {
             return triggerErrorOnChunk(response, blockedChunk, error);
-          }
+          },
         );
       } else
         chunk
           ? (resolveChunkDebugInfo(streamState, chunk),
             resolveModuleChunk(response, chunk, clientReference))
           : ((chunk = new ReactPromise(
-              "resolved_module",
+              'resolved_module',
               clientReference,
-              null
+              null,
             )),
             resolveChunkDebugInfo(streamState, chunk),
             chunks.set(id, chunk));
@@ -2933,7 +2933,7 @@
       if (chunk) {
         if (
           (resolveChunkDebugInfo(streamState, chunk),
-          "pending" === chunk.status)
+          'pending' === chunk.status)
         ) {
           releasePendingChunk(response, chunk);
           id = chunk.value;
@@ -2941,7 +2941,7 @@
             streamState = initializingHandler;
             chunks = initializingChunk;
             initializingHandler = null;
-            chunk.status = "blocked";
+            chunk.status = 'blocked';
             chunk.value = null;
             chunk.reason = null;
             initializingChunk = chunk;
@@ -2961,13 +2961,13 @@
               (initializingHandler = streamState), (initializingChunk = chunks);
             }
           }
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = stream;
           chunk.reason = controller;
           null !== id && wakeChunk(id, chunk.value, chunk);
         }
       } else
-        (response = new ReactPromise("fulfilled", stream, controller)),
+        (response = new ReactPromise('fulfilled', stream, controller)),
           resolveChunkDebugInfo(streamState, response),
           chunks.set(id, response);
     }
@@ -2977,7 +2977,7 @@
         type: type,
         start: function (c) {
           controller = c;
-        }
+        },
       });
       var previousBlockedChunk = null;
       resolveStream(
@@ -2996,7 +2996,7 @@
             if (null === previousBlockedChunk) {
               var chunk = createResolvedModelChunk(response, json);
               initializeModelChunk(chunk);
-              "fulfilled" === chunk.status
+              'fulfilled' === chunk.status
                 ? controller.enqueue(chunk.value)
                 : (chunk.then(
                     function (v) {
@@ -3004,7 +3004,7 @@
                     },
                     function (e) {
                       return controller.error(e);
-                    }
+                    },
                   ),
                   (previousBlockedChunk = chunk));
             } else {
@@ -3016,7 +3016,7 @@
                 },
                 function (e) {
                   return controller.error(e);
-                }
+                },
               );
               previousBlockedChunk = _chunk3;
               chunk.then(function () {
@@ -3045,9 +3045,9 @@
                 return controller.error(error);
               });
             }
-          }
+          },
         },
-        streamState
+        streamState,
       );
     }
     function asyncIterator() {
@@ -3068,14 +3068,14 @@
         return createIterator(function (arg) {
           if (void 0 !== arg)
             throw Error(
-              "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+              'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
             );
           if (nextReadIndex === buffer.length) {
             if (closed)
               return new ReactPromise(
-                "fulfilled",
+                'fulfilled',
                 { done: !0, value: void 0 },
-                null
+                null,
               );
             buffer[nextReadIndex] = createPendingChunk(response);
           }
@@ -3090,21 +3090,21 @@
           enqueueValue: function (value) {
             if (nextWriteIndex === buffer.length)
               buffer[nextWriteIndex] = new ReactPromise(
-                "fulfilled",
+                'fulfilled',
                 { done: !1, value: value },
-                null
+                null,
               );
             else {
               var chunk = buffer[nextWriteIndex],
                 resolveListeners = chunk.value,
                 rejectListeners = chunk.reason;
-              chunk.status = "fulfilled";
+              chunk.status = 'fulfilled';
               chunk.value = { done: !1, value: value };
               null !== resolveListeners &&
                 wakeChunkIfInitialized(
                   chunk,
                   resolveListeners,
-                  rejectListeners
+                  rejectListeners,
                 );
             }
             nextWriteIndex++;
@@ -3114,13 +3114,13 @@
               ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                   response,
                   value,
-                  !1
+                  !1,
                 ))
               : resolveIteratorResultChunk(
                   response,
                   buffer[nextWriteIndex],
                   value,
-                  !1
+                  !1,
                 );
             nextWriteIndex++;
           },
@@ -3130,20 +3130,20 @@
               ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                   response,
                   value,
-                  !0
+                  !0,
                 ))
               : resolveIteratorResultChunk(
                   response,
                   buffer[nextWriteIndex],
                   value,
-                  !0
+                  !0,
                 );
             for (nextWriteIndex++; nextWriteIndex < buffer.length; )
               resolveIteratorResultChunk(
                 response,
                 buffer[nextWriteIndex++],
                 '"$undefined"',
-                !0
+                !0,
               );
           },
           error: function (error) {
@@ -3155,9 +3155,9 @@
 
             )
               triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);
-          }
+          },
         },
-        streamState
+        streamState,
       );
     }
     function resolveErrorDev(response, errorInfo) {
@@ -3171,8 +3171,8 @@
         Error.bind(
           null,
           errorInfo.message ||
-            "An error occurred in the Server Components render but no message was provided"
-        )
+            'An error occurred in the Server Components render but no message was provided',
+        ),
       );
       var ownerTask = null;
       null != errorInfo.owner &&
@@ -3181,8 +3181,8 @@
           response,
           errorInfo,
           {},
-          "",
-          createModel
+          '',
+          createModel,
         )),
         null !== errorInfo &&
           (ownerTask = initializeFakeTask(response, errorInfo)));
@@ -3202,9 +3202,9 @@
       col,
       enclosingLine,
       enclosingCol,
-      environmentName
+      environmentName,
     ) {
-      name || (name = "<anonymous>");
+      name || (name = '<anonymous>');
       var encodedName = JSON.stringify(name);
       1 > enclosingLine ? (enclosingLine = 0) : enclosingLine--;
       1 > enclosingCol ? (enclosingCol = 0) : enclosingCol--;
@@ -3222,66 +3222,66 @@
           (col = col - enclosingCol - line - 3),
           0 > col && (col = 0),
           (encodedName =
-            "({" +
+            '({' +
             encodedName +
-            ":" +
-            " ".repeat(enclosingCol) +
-            "_=>" +
-            " ".repeat(col) +
-            "_()})"))
+            ':' +
+            ' '.repeat(enclosingCol) +
+            '_=>' +
+            ' '.repeat(col) +
+            '_()})'))
         : 1 > enclosingLine
           ? ((enclosingCol -= encodedName.length + 3),
             0 > enclosingCol && (enclosingCol = 0),
             (encodedName =
-              "({" +
+              '({' +
               encodedName +
-              ":" +
-              " ".repeat(enclosingCol) +
-              "_=>" +
-              "\n".repeat(line - enclosingLine) +
-              " ".repeat(col) +
-              "_()})"))
+              ':' +
+              ' '.repeat(enclosingCol) +
+              '_=>' +
+              '\n'.repeat(line - enclosingLine) +
+              ' '.repeat(col) +
+              '_()})'))
           : enclosingLine === line
             ? ((col = col - enclosingCol - 3),
               0 > col && (col = 0),
               (encodedName =
-                "\n".repeat(enclosingLine - 1) +
-                "({" +
+                '\n'.repeat(enclosingLine - 1) +
+                '({' +
                 encodedName +
-                ":\n" +
-                " ".repeat(enclosingCol) +
-                "_=>" +
-                " ".repeat(col) +
-                "_()})"))
+                ':\n' +
+                ' '.repeat(enclosingCol) +
+                '_=>' +
+                ' '.repeat(col) +
+                '_()})'))
             : (encodedName =
-                "\n".repeat(enclosingLine - 1) +
-                "({" +
+                '\n'.repeat(enclosingLine - 1) +
+                '({' +
                 encodedName +
-                ":\n" +
-                " ".repeat(enclosingCol) +
-                "_=>" +
-                "\n".repeat(line - enclosingLine) +
-                " ".repeat(col) +
-                "_()})");
+                ':\n' +
+                ' '.repeat(enclosingCol) +
+                '_=>' +
+                '\n'.repeat(line - enclosingLine) +
+                ' '.repeat(col) +
+                '_()})');
       encodedName =
         1 > enclosingLine
           ? encodedName +
-            "\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */"
-          : "/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */" +
+            '\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */'
+          : '/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */' +
             encodedName;
-      filename.startsWith("/") && (filename = "file://" + filename);
+      filename.startsWith('/') && (filename = 'file://' + filename);
       sourceMap
         ? ((encodedName +=
-            "\n//# sourceURL=about://React/" +
+            '\n//# sourceURL=about://React/' +
             encodeURIComponent(environmentName) +
-            "/" +
+            '/' +
             encodeURI(filename) +
-            "?" +
+            '?' +
             fakeFunctionIdx++),
-          (encodedName += "\n//# sourceMappingURL=" + sourceMap))
+          (encodedName += '\n//# sourceMappingURL=' + sourceMap))
         : (encodedName = filename
-            ? encodedName + ("\n//# sourceURL=" + encodeURI(filename))
-            : encodedName + "\n//# sourceURL=<anonymous>");
+            ? encodedName + ('\n//# sourceURL=' + encodeURI(filename))
+            : encodedName + '\n//# sourceURL=<anonymous>');
       try {
         var fn = (0, eval)(encodedName)[name];
       } catch (x) {
@@ -3296,15 +3296,15 @@
       stack,
       environmentName,
       useEnclosingLine,
-      innerCall
+      innerCall,
     ) {
       for (var i = 0; i < stack.length; i++) {
         var frame = stack[i],
           frameKey =
-            frame.join("-") +
-            "-" +
+            frame.join('-') +
+            '-' +
             environmentName +
-            (useEnclosingLine ? "-e" : "-n"),
+            (useEnclosingLine ? '-e' : '-n'),
           fn = fakeFunctionCache.get(frameKey);
         if (void 0 === fn) {
           fn = frame[0];
@@ -3325,7 +3325,7 @@
             col,
             useEnclosingLine ? line : enclosingLine,
             useEnclosingLine ? col : frame,
-            environmentName
+            environmentName,
           );
           fakeFunctionCache.set(frameKey, fn);
         }
@@ -3339,7 +3339,7 @@
         ? response._rootEnvironmentName !== childEnvironmentName
           ? ((response = console.createTask.bind(
               console,
-              '"use ' + childEnvironmentName.toLowerCase() + '"'
+              '"use ' + childEnvironmentName.toLowerCase() + '"',
             )),
             rootTask.run(response))
           : rootTask
@@ -3365,17 +3365,17 @@
         env !== cachedEntry
           ? '"use ' + env.toLowerCase() + '"'
           : void 0 !== debugInfo.key
-            ? "<" + (debugInfo.name || "...") + ">"
+            ? '<' + (debugInfo.name || '...') + '>'
             : void 0 !== debugInfo.name
-              ? debugInfo.name || "unknown"
-              : "await " + (debugInfo.awaited.name || "unknown");
+              ? debugInfo.name || 'unknown'
+              : 'await ' + (debugInfo.awaited.name || 'unknown');
       env = console.createTask.bind(console, env);
       useEnclosingLine = buildFakeCallStack(
         response,
         stack,
         cachedEntry,
         useEnclosingLine,
-        env
+        env,
       );
       null === ownerTask
         ? ((response = getRootTask(response, cachedEntry)),
@@ -3387,7 +3387,7 @@
       return (debugInfo.debugTask = response);
     }
     function fakeJSXCallSite() {
-      return Error("react-stack-top-frame");
+      return Error('react-stack-top-frame');
     }
     function initializeFakeStack(response, debugInfo) {
       if (void 0 === debugInfo.debugStack) {
@@ -3395,7 +3395,7 @@
           (debugInfo.debugStack = createFakeJSXCallStackInDEV(
             response,
             debugInfo.stack,
-            null == debugInfo.env ? "" : debugInfo.env
+            null == debugInfo.env ? '' : debugInfo.env,
           ));
         var owner = debugInfo.owner;
         null != owner &&
@@ -3415,16 +3415,16 @@
         _componentInfoOrAsyncInfo.debugTask = response._debugRootTask;
       } else
         void 0 !== debugInfo.stack && initializeFakeStack(response, debugInfo);
-      "number" === typeof debugInfo.time &&
+      'number' === typeof debugInfo.time &&
         (debugInfo = { time: debugInfo.time + response._timeOrigin });
       return debugInfo;
     }
     function getCurrentStackInDEV() {
       var owner = currentOwnerInDEV;
-      if (null === owner) return "";
+      if (null === owner) return '';
       try {
-        var info = "";
-        if (owner.owner || "string" !== typeof owner.name) {
+        var info = '';
+        if (owner.owner || 'string' !== typeof owner.name) {
           for (; owner; ) {
             var ownerStack = owner.debugStack;
             if (null != ownerStack) {
@@ -3435,16 +3435,16 @@
                 Error.prepareStackTrace = prepareStackTrace;
                 var stack = error.stack;
                 Error.prepareStackTrace = prevPrepareStackTrace;
-                stack.startsWith("Error: react-stack-top-frame\n") &&
+                stack.startsWith('Error: react-stack-top-frame\n') &&
                   (stack = stack.slice(29));
-                var idx = stack.indexOf("\n");
+                var idx = stack.indexOf('\n');
                 -1 !== idx && (stack = stack.slice(idx + 1));
-                idx = stack.indexOf("react_stack_bottom_frame");
-                -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
+                idx = stack.indexOf('react_stack_bottom_frame');
+                -1 !== idx && (idx = stack.lastIndexOf('\n', idx));
                 var JSCompiler_inline_result =
-                  -1 !== idx ? (stack = stack.slice(0, idx)) : "";
+                  -1 !== idx ? (stack = stack.slice(0, idx)) : '';
                 info =
-                  JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
+                  JSCompiler_temp_const + ('\n' + JSCompiler_inline_result);
               }
             } else break;
           }
@@ -3457,20 +3457,20 @@
             } catch (x) {
               (prefix =
                 ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) ||
-                ""),
+                ''),
                 (suffix =
-                  -1 < x.stack.indexOf("\n    at")
-                    ? " (<anonymous>)"
-                    : -1 < x.stack.indexOf("@")
-                      ? "@unknown:0:0"
-                      : "");
+                  -1 < x.stack.indexOf('\n    at')
+                    ? ' (<anonymous>)'
+                    : -1 < x.stack.indexOf('@')
+                      ? '@unknown:0:0'
+                      : '');
             }
           JSCompiler_inline_result$jscomp$0 =
-            "\n" + prefix + JSCompiler_temp_const + suffix;
+            '\n' + prefix + JSCompiler_temp_const + suffix;
         }
       } catch (x) {
         JSCompiler_inline_result$jscomp$0 =
-          "\nError generating stack: " + x.message + "\n" + x.stack;
+          '\nError generating stack: ' + x.message + '\n' + x.stack;
       }
       return JSCompiler_inline_result$jscomp$0;
     }
@@ -3480,13 +3480,13 @@
         if (null == blockedChunk)
           (blockedChunk = createResolvedModelChunk(response, json)),
             initializeModelChunk(blockedChunk),
-            "fulfilled" === blockedChunk.status
+            'fulfilled' === blockedChunk.status
               ? replayConsoleWithCallStackInDEV(response, blockedChunk.value)
               : (blockedChunk.then(
                   function (v) {
                     return replayConsoleWithCallStackInDEV(response, v);
                   },
-                  function () {}
+                  function () {},
                 ),
                 (response._blockedConsole = blockedChunk));
         else {
@@ -3495,7 +3495,7 @@
             function (v) {
               return replayConsoleWithCallStackInDEV(response, v);
             },
-            function () {}
+            function () {},
           );
           response._blockedConsole = _chunk4;
           var unblock = function () {
@@ -3518,16 +3518,16 @@
         var promise = ioInfo.value;
         if (promise)
           switch (promise.status) {
-            case "fulfilled":
+            case 'fulfilled':
               logIOInfo(ioInfo, response, promise.value);
               break;
-            case "rejected":
+            case 'rejected':
               logIOInfoErrored(ioInfo, response, promise.reason);
               break;
             default:
               promise.then(
                 logIOInfo.bind(null, ioInfo, response),
-                logIOInfoErrored.bind(null, ioInfo, response)
+                logIOInfoErrored.bind(null, ioInfo, response),
               );
           }
         else logIOInfo(ioInfo, response, void 0);
@@ -3538,17 +3538,17 @@
         chunk = chunks.get(id);
       chunk
         ? (resolveModelChunk(response, chunk, model),
-          "resolved_model" === chunk.status && initializeModelChunk(chunk))
+          'resolved_model' === chunk.status && initializeModelChunk(chunk))
         : ((chunk = createResolvedModelChunk(response, model)),
           chunks.set(id, chunk),
           initializeModelChunk(chunk));
-      "fulfilled" === chunk.status
+      'fulfilled' === chunk.status
         ? initializeIOInfo(response, chunk.value)
         : chunk.then(
             function (v) {
               initializeIOInfo(response, v);
             },
-            function () {}
+            function () {},
           );
     }
     function mergeBuffer(buffer, lastChunk) {
@@ -3574,7 +3574,7 @@
       lastChunk,
       constructor,
       bytesPerElement,
-      streamState
+      streamState,
     ) {
       buffer =
         0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
@@ -3583,7 +3583,7 @@
       constructor = new constructor(
         buffer.buffer,
         buffer.byteOffset,
-        buffer.byteLength / bytesPerElement
+        buffer.byteLength / bytesPerElement,
       );
       resolveBuffer(response, id, constructor, streamState);
     }
@@ -3592,7 +3592,7 @@
       root,
       trackIdx$jscomp$6,
       trackTime,
-      parentEndTime
+      parentEndTime,
     ) {
       if (!isArrayImpl(root._children)) {
         var previousResult = root._children,
@@ -3608,9 +3608,9 @@
           if (supportsUserTiming && 0 <= previousEndTime && 10 > trackIdx) {
             var color =
                 componentInfo.env === response$jscomp$0._rootEnvironmentName
-                  ? "primary-light"
-                  : "secondary-light",
-              entryName = componentInfo.name + " [deduped]",
+                  ? 'primary-light'
+                  : 'secondary-light',
+              entryName = componentInfo.name + ' [deduped]',
               debugTask = componentInfo.debugTask;
             debugTask
               ? debugTask.run(
@@ -3620,17 +3620,17 @@
                     0 > startTime ? 0 : startTime,
                     previousEndTime,
                     trackNames[trackIdx],
-                    "Server Components \u269b",
-                    color
-                  )
+                    'Server Components \u269b',
+                    color,
+                  ),
                 )
               : console.timeStamp(
                   entryName,
                   0 > startTime ? 0 : startTime,
                   previousEndTime,
                   trackNames[trackIdx],
-                  "Server Components \u269b",
-                  color
+                  'Server Components \u269b',
+                  color,
                 );
           }
         }
@@ -3642,8 +3642,8 @@
       if (debugInfo) {
         for (var startTime$jscomp$0 = 0, i = 0; i < debugInfo.length; i++) {
           var info = debugInfo[i];
-          "number" === typeof info.time && (startTime$jscomp$0 = info.time);
-          if ("string" === typeof info.name) {
+          'number' === typeof info.time && (startTime$jscomp$0 = info.time);
+          if ('string' === typeof info.name) {
             startTime$jscomp$0 < trackTime && trackIdx$jscomp$6++;
             trackTime = startTime$jscomp$0;
             break;
@@ -3651,7 +3651,7 @@
         }
         for (var _i4 = debugInfo.length - 1; 0 <= _i4; _i4--) {
           var _info = debugInfo[_i4];
-          if ("number" === typeof _info.time && _info.time > parentEndTime) {
+          if ('number' === typeof _info.time && _info.time > parentEndTime) {
             parentEndTime = _info.time;
             break;
           }
@@ -3660,7 +3660,7 @@
       var result = {
         track: trackIdx$jscomp$6,
         endTime: -Infinity,
-        component: null
+        component: null,
       };
       root._children = result;
       for (
@@ -3676,7 +3676,7 @@
           children[_i5],
           childTrackIdx,
           childTrackTime,
-          parentEndTime
+          parentEndTime,
         );
         null !== childResult.component &&
           (result.component = childResult.component);
@@ -3696,13 +3696,13 @@
           _i6--
         ) {
           var _info2 = debugInfo[_i6];
-          if ("number" === typeof _info2.time) {
+          if ('number' === typeof _info2.time) {
             0 === componentEndTime && (componentEndTime = _info2.time);
             var time = _info2.time;
             if (-1 < endTimeIdx)
               for (var j = endTimeIdx - 1; j > _i6; j--) {
                 var candidateInfo = debugInfo[j];
-                if ("string" === typeof candidateInfo.name) {
+                if ('string' === typeof candidateInfo.name) {
                   componentEndTime > childrenEndTime &&
                     (childrenEndTime = componentEndTime);
                   var componentInfo$jscomp$0 = candidateInfo,
@@ -3714,7 +3714,7 @@
                     childrenEndTime$jscomp$0 = childrenEndTime;
                   if (
                     isLastComponent &&
-                    "rejected" === root.status &&
+                    'rejected' === root.status &&
                     root.reason !== response._closedReason
                   ) {
                     var componentInfo$jscomp$2 = componentInfo$jscomp$1,
@@ -3729,44 +3729,44 @@
                           env === response._rootEnvironmentName ||
                           void 0 === env
                             ? name
-                            : name + " [" + env + "]",
+                            : name + ' [' + env + ']',
                         properties = [
                           [
-                            "Error",
-                            "object" === typeof error &&
+                            'Error',
+                            'object' === typeof error &&
                             null !== error &&
-                            "string" === typeof error.message
+                            'string' === typeof error.message
                               ? String(error.message)
-                              : String(error)
-                          ]
+                              : String(error),
+                          ],
                         ];
                       null != componentInfo$jscomp$2.key &&
                         addValueToProperties(
-                          "key",
+                          'key',
                           componentInfo$jscomp$2.key,
                           properties,
                           0,
-                          ""
+                          '',
                         );
                       null != componentInfo$jscomp$2.props &&
                         addObjectToProperties(
                           componentInfo$jscomp$2.props,
                           properties,
                           0,
-                          ""
+                          '',
                         );
-                      performance.measure("\u200b" + entryName$jscomp$0, {
+                      performance.measure('\u200b' + entryName$jscomp$0, {
                         start: 0 > startTime$jscomp$2 ? 0 : startTime$jscomp$2,
                         end: childrenEndTime$jscomp$1,
                         detail: {
                           devtools: {
-                            color: "error",
+                            color: 'error',
                             track: trackNames[trackIdx$jscomp$1],
-                            trackGroup: "Server Components \u269b",
-                            tooltipText: entryName$jscomp$0 + " Errored",
-                            properties: properties
-                          }
-                        }
+                            trackGroup: 'Server Components \u269b',
+                            tooltipText: entryName$jscomp$0 + ' Errored',
+                            properties: properties,
+                          },
+                        },
                       });
                     }
                   } else {
@@ -3788,43 +3788,43 @@
                         color$jscomp$0 =
                           0.5 > selfTime
                             ? isPrimaryEnv
-                              ? "primary-light"
-                              : "secondary-light"
+                              ? 'primary-light'
+                              : 'secondary-light'
                             : 50 > selfTime
                               ? isPrimaryEnv
-                                ? "primary"
-                                : "secondary"
+                                ? 'primary'
+                                : 'secondary'
                               : 500 > selfTime
                                 ? isPrimaryEnv
-                                  ? "primary-dark"
-                                  : "secondary-dark"
-                                : "error",
+                                  ? 'primary-dark'
+                                  : 'secondary-dark'
+                                : 'error',
                         entryName$jscomp$1 =
                           isPrimaryEnv || void 0 === env$jscomp$0
                             ? name$jscomp$0
-                            : name$jscomp$0 + " [" + env$jscomp$0 + "]",
+                            : name$jscomp$0 + ' [' + env$jscomp$0 + ']',
                         debugTask$jscomp$0 = componentInfo$jscomp$3.debugTask;
                       if (debugTask$jscomp$0) {
                         var properties$jscomp$0 = [];
                         null != componentInfo$jscomp$3.key &&
                           addValueToProperties(
-                            "key",
+                            'key',
                             componentInfo$jscomp$3.key,
                             properties$jscomp$0,
                             0,
-                            ""
+                            '',
                           );
                         null != componentInfo$jscomp$3.props &&
                           addObjectToProperties(
                             componentInfo$jscomp$3.props,
                             properties$jscomp$0,
                             0,
-                            ""
+                            '',
                           );
                         debugTask$jscomp$0.run(
                           performance.measure.bind(
                             performance,
-                            "\u200b" + entryName$jscomp$1,
+                            '\u200b' + entryName$jscomp$1,
                             {
                               start:
                                 0 > startTime$jscomp$3 ? 0 : startTime$jscomp$3,
@@ -3833,21 +3833,21 @@
                                 devtools: {
                                   color: color$jscomp$0,
                                   track: trackNames[trackIdx$jscomp$2],
-                                  trackGroup: "Server Components \u269b",
-                                  properties: properties$jscomp$0
-                                }
-                              }
-                            }
-                          )
+                                  trackGroup: 'Server Components \u269b',
+                                  properties: properties$jscomp$0,
+                                },
+                              },
+                            },
+                          ),
                         );
                       } else
                         console.timeStamp(
-                          "\u200b" + entryName$jscomp$1,
+                          '\u200b' + entryName$jscomp$1,
                           0 > startTime$jscomp$3 ? 0 : startTime$jscomp$3,
                           childrenEndTime$jscomp$2,
                           trackNames[trackIdx$jscomp$2],
-                          "Server Components \u269b",
-                          color$jscomp$0
+                          'Server Components \u269b',
+                          color$jscomp$0,
                         );
                     }
                   }
@@ -3865,17 +3865,17 @@
                   if (promise) {
                     var thenable = promise;
                     switch (thenable.status) {
-                      case "fulfilled":
+                      case 'fulfilled':
                         logComponentAwait(
                           asyncInfo,
                           trackIdx$jscomp$6,
                           time,
                           endTime,
                           env$jscomp$1,
-                          thenable.value
+                          thenable.value,
                         );
                         break;
-                      case "rejected":
+                      case 'rejected':
                         var asyncInfo$jscomp$0 = asyncInfo,
                           trackIdx$jscomp$3 = trackIdx$jscomp$6,
                           startTime$jscomp$4 = time,
@@ -3885,12 +3885,12 @@
                         if (supportsUserTiming && 0 < endTime$jscomp$0) {
                           var description = getIODescription(error$jscomp$0),
                             entryName$jscomp$2 =
-                              "await " +
+                              'await ' +
                               getIOShortName(
                                 asyncInfo$jscomp$0.awaited,
                                 description,
                                 asyncInfo$jscomp$0.env,
-                                rootEnv
+                                rootEnv,
                               ),
                             debugTask$jscomp$1 =
                               asyncInfo$jscomp$0.debugTask ||
@@ -3898,21 +3898,21 @@
                           if (debugTask$jscomp$1) {
                             var properties$jscomp$1 = [
                                 [
-                                  "Rejected",
-                                  "object" === typeof error$jscomp$0 &&
+                                  'Rejected',
+                                  'object' === typeof error$jscomp$0 &&
                                   null !== error$jscomp$0 &&
-                                  "string" === typeof error$jscomp$0.message
+                                  'string' === typeof error$jscomp$0.message
                                     ? String(error$jscomp$0.message)
-                                    : String(error$jscomp$0)
-                                ]
+                                    : String(error$jscomp$0),
+                                ],
                               ],
                               tooltipText =
                                 getIOLongName(
                                   asyncInfo$jscomp$0.awaited,
                                   description,
                                   asyncInfo$jscomp$0.env,
-                                  rootEnv
-                                ) + " Rejected";
+                                  rootEnv,
+                                ) + ' Rejected';
                             debugTask$jscomp$1.run(
                               performance.measure.bind(
                                 performance,
@@ -3925,15 +3925,15 @@
                                   end: endTime$jscomp$0,
                                   detail: {
                                     devtools: {
-                                      color: "error",
+                                      color: 'error',
                                       track: trackNames[trackIdx$jscomp$3],
-                                      trackGroup: "Server Components \u269b",
+                                      trackGroup: 'Server Components \u269b',
                                       properties: properties$jscomp$1,
-                                      tooltipText: tooltipText
-                                    }
-                                  }
-                                }
-                              )
+                                      tooltipText: tooltipText,
+                                    },
+                                  },
+                                },
+                              ),
                             );
                           } else
                             console.timeStamp(
@@ -3941,8 +3941,8 @@
                               0 > startTime$jscomp$4 ? 0 : startTime$jscomp$4,
                               endTime$jscomp$0,
                               trackNames[trackIdx$jscomp$3],
-                              "Server Components \u269b",
-                              "error"
+                              'Server Components \u269b',
+                              'error',
                             );
                         }
                         break;
@@ -3953,7 +3953,7 @@
                           time,
                           endTime,
                           env$jscomp$1,
-                          void 0
+                          void 0,
                         );
                     }
                   } else
@@ -3963,7 +3963,7 @@
                       time,
                       endTime,
                       env$jscomp$1,
-                      void 0
+                      void 0,
                     );
                 }
               }
@@ -3971,7 +3971,7 @@
               endTime = time;
               for (var _j = debugInfo.length - 1; _j > _i6; _j--) {
                 var _candidateInfo = debugInfo[_j];
-                if ("string" === typeof _candidateInfo.name) {
+                if ('string' === typeof _candidateInfo.name) {
                   componentEndTime > childrenEndTime &&
                     (childrenEndTime = componentEndTime);
                   var _componentInfo = _candidateInfo,
@@ -3986,40 +3986,40 @@
                       entryName$jscomp$3 =
                         env$jscomp$2 === _env || void 0 === env$jscomp$2
                           ? name$jscomp$1
-                          : name$jscomp$1 + " [" + env$jscomp$2 + "]",
+                          : name$jscomp$1 + ' [' + env$jscomp$2 + ']',
                       properties$jscomp$2 = [
                         [
-                          "Aborted",
-                          "The stream was aborted before this Component finished rendering."
-                        ]
+                          'Aborted',
+                          'The stream was aborted before this Component finished rendering.',
+                        ],
                       ];
                     null != componentInfo$jscomp$4.key &&
                       addValueToProperties(
-                        "key",
+                        'key',
                         componentInfo$jscomp$4.key,
                         properties$jscomp$2,
                         0,
-                        ""
+                        '',
                       );
                     null != componentInfo$jscomp$4.props &&
                       addObjectToProperties(
                         componentInfo$jscomp$4.props,
                         properties$jscomp$2,
                         0,
-                        ""
+                        '',
                       );
-                    performance.measure("\u200b" + entryName$jscomp$3, {
+                    performance.measure('\u200b' + entryName$jscomp$3, {
                       start: 0 > startTime$jscomp$5 ? 0 : startTime$jscomp$5,
                       end: childrenEndTime$jscomp$3,
                       detail: {
                         devtools: {
-                          color: "warning",
+                          color: 'warning',
                           track: trackNames[trackIdx$jscomp$4],
-                          trackGroup: "Server Components \u269b",
-                          tooltipText: entryName$jscomp$3 + " Aborted",
-                          properties: properties$jscomp$2
-                        }
-                      }
+                          trackGroup: 'Server Components \u269b',
+                          tooltipText: entryName$jscomp$3 + ' Aborted',
+                          properties: properties$jscomp$2,
+                        },
+                      },
                     });
                   }
                   componentEndTime = time;
@@ -4041,12 +4041,12 @@
                     rootEnv$jscomp$0 = _env2;
                   if (supportsUserTiming && 0 < endTime$jscomp$1) {
                     var entryName$jscomp$4 =
-                        "await " +
+                        'await ' +
                         getIOShortName(
                           asyncInfo$jscomp$1.awaited,
-                          "",
+                          '',
                           asyncInfo$jscomp$1.env,
-                          rootEnv$jscomp$0
+                          rootEnv$jscomp$0,
                         ),
                       debugTask$jscomp$2 =
                         asyncInfo$jscomp$1.debugTask ||
@@ -4055,10 +4055,10 @@
                       var tooltipText$jscomp$0 =
                         getIOLongName(
                           asyncInfo$jscomp$1.awaited,
-                          "",
+                          '',
                           asyncInfo$jscomp$1.env,
-                          rootEnv$jscomp$0
-                        ) + " Aborted";
+                          rootEnv$jscomp$0,
+                        ) + ' Aborted';
                       debugTask$jscomp$2.run(
                         performance.measure.bind(
                           performance,
@@ -4069,20 +4069,20 @@
                             end: endTime$jscomp$1,
                             detail: {
                               devtools: {
-                                color: "warning",
+                                color: 'warning',
                                 track: trackNames[trackIdx$jscomp$5],
-                                trackGroup: "Server Components \u269b",
+                                trackGroup: 'Server Components \u269b',
                                 properties: [
                                   [
-                                    "Aborted",
-                                    "The stream was aborted before this Promise resolved."
-                                  ]
+                                    'Aborted',
+                                    'The stream was aborted before this Promise resolved.',
+                                  ],
                                 ],
-                                tooltipText: tooltipText$jscomp$0
-                              }
-                            }
-                          }
-                        )
+                                tooltipText: tooltipText$jscomp$0,
+                              },
+                            },
+                          },
+                        ),
                       );
                     } else
                       console.timeStamp(
@@ -4090,8 +4090,8 @@
                         0 > startTime$jscomp$6 ? 0 : startTime$jscomp$6,
                         endTime$jscomp$1,
                         trackNames[trackIdx$jscomp$5],
-                        "Server Components \u269b",
-                        "warning"
+                        'Server Components \u269b',
+                        'warning',
                       );
                   }
                 }
@@ -4114,7 +4114,7 @@
             rootChunk,
             0,
             -Infinity,
-            -Infinity
+            -Infinity,
           ));
       }
     }
@@ -4124,7 +4124,7 @@
       id,
       tag,
       buffer,
-      chunk
+      chunk,
     ) {
       switch (tag) {
         case 65:
@@ -4132,7 +4132,7 @@
             response,
             id,
             mergeBuffer(buffer, chunk).buffer,
-            streamState
+            streamState,
           );
           return;
         case 79:
@@ -4143,7 +4143,7 @@
             chunk,
             Int8Array,
             1,
-            streamState
+            streamState,
           );
           return;
         case 111:
@@ -4151,7 +4151,7 @@
             response,
             id,
             0 === buffer.length ? chunk : mergeBuffer(buffer, chunk),
-            streamState
+            streamState,
           );
           return;
         case 85:
@@ -4162,7 +4162,7 @@
             chunk,
             Uint8ClampedArray,
             1,
-            streamState
+            streamState,
           );
           return;
         case 83:
@@ -4173,7 +4173,7 @@
             chunk,
             Int16Array,
             2,
-            streamState
+            streamState,
           );
           return;
         case 115:
@@ -4184,7 +4184,7 @@
             chunk,
             Uint16Array,
             2,
-            streamState
+            streamState,
           );
           return;
         case 76:
@@ -4195,7 +4195,7 @@
             chunk,
             Int32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 108:
@@ -4206,7 +4206,7 @@
             chunk,
             Uint32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 71:
@@ -4217,7 +4217,7 @@
             chunk,
             Float32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 103:
@@ -4228,7 +4228,7 @@
             chunk,
             Float64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 77:
@@ -4239,7 +4239,7 @@
             chunk,
             BigInt64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 109:
@@ -4250,7 +4250,7 @@
             chunk,
             BigUint64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 86:
@@ -4261,12 +4261,12 @@
             chunk,
             DataView,
             1,
-            streamState
+            streamState,
           );
           return;
       }
       for (
-        var stringDecoder = response._stringDecoder, row = "", i = 0;
+        var stringDecoder = response._stringDecoder, row = '', i = 0;
         i < buffer.length;
         i++
       )
@@ -4282,42 +4282,42 @@
           response = JSON.parse(streamState, response._fromJSON);
           streamState = ReactDOMSharedInternals.d;
           switch (id) {
-            case "D":
+            case 'D':
               streamState.D(response);
               break;
-            case "C":
-              "string" === typeof response
+            case 'C':
+              'string' === typeof response
                 ? streamState.C(response)
                 : streamState.C(response[0], response[1]);
               break;
-            case "L":
+            case 'L':
               id = response[0];
               buffer = response[1];
               3 === response.length
                 ? streamState.L(id, buffer, response[2])
                 : streamState.L(id, buffer);
               break;
-            case "m":
-              "string" === typeof response
+            case 'm':
+              'string' === typeof response
                 ? streamState.m(response)
                 : streamState.m(response[0], response[1]);
               break;
-            case "X":
-              "string" === typeof response
+            case 'X':
+              'string' === typeof response
                 ? streamState.X(response)
                 : streamState.X(response[0], response[1]);
               break;
-            case "S":
-              "string" === typeof response
+            case 'S':
+              'string' === typeof response
                 ? streamState.S(response)
                 : streamState.S(
                     response[0],
                     0 === response[1] ? void 0 : response[1],
-                    3 === response.length ? response[2] : void 0
+                    3 === response.length ? response[2] : void 0,
                   );
               break;
-            case "M":
-              "string" === typeof response
+            case 'M':
+              'string' === typeof response
                 ? streamState.M(response)
                 : streamState.M(response[0], response[1]);
           }
@@ -4331,16 +4331,16 @@
           chunk
             ? (resolveChunkDebugInfo(streamState, chunk),
               triggerErrorOnChunk(response, chunk, stringDecoder))
-            : ((response = new ReactPromise("rejected", null, stringDecoder)),
+            : ((response = new ReactPromise('rejected', null, stringDecoder)),
               resolveChunkDebugInfo(streamState, response),
               tag.set(id, response));
           break;
         case 84:
           tag = response._chunks;
-          (chunk = tag.get(id)) && "pending" !== chunk.status
+          (chunk = tag.get(id)) && 'pending' !== chunk.status
             ? chunk.reason.enqueueValue(buffer)
             : (chunk && releasePendingChunk(response, chunk),
-              (response = new ReactPromise("fulfilled", buffer, null)),
+              (response = new ReactPromise('fulfilled', buffer, null)),
               resolveChunkDebugInfo(streamState, response),
               tag.set(id, response));
           break;
@@ -4349,24 +4349,24 @@
           break;
         case 68:
           id = getChunk(response, id);
-          "fulfilled" !== id.status &&
-            "rejected" !== id.status &&
-            "halted" !== id.status &&
-            "blocked" !== id.status &&
-            "resolved_module" !== id.status &&
+          'fulfilled' !== id.status &&
+            'rejected' !== id.status &&
+            'halted' !== id.status &&
+            'blocked' !== id.status &&
+            'resolved_module' !== id.status &&
             ((streamState = id._debugChunk),
             (tag = createResolvedModelChunk(response, buffer)),
             (tag._debugChunk = streamState),
             (id._debugChunk = tag),
             initializeDebugChunk(response, id),
-            "blocked" !== tag.status ||
+            'blocked' !== tag.status ||
               (void 0 !== response._debugChannel &&
                 response._debugChannel.hasReadable) ||
               '"' !== buffer[0] ||
-              "$" !== buffer[1] ||
-              ((streamState = buffer.slice(2, buffer.length - 1).split(":")),
+              '$' !== buffer[1] ||
+              ((streamState = buffer.slice(2, buffer.length - 1).split(':')),
               (streamState = parseInt(streamState[0], 16)),
-              "pending" === getChunk(response, streamState).status &&
+              'pending' === getChunk(response, streamState).status &&
                 (id._debugChunk = null)));
           break;
         case 74:
@@ -4379,7 +4379,7 @@
           startReadableStream(response, id, void 0, streamState);
           break;
         case 114:
-          startReadableStream(response, id, "bytes", streamState);
+          startReadableStream(response, id, 'bytes', streamState);
           break;
         case 88:
           startAsyncIterable(response, id, !1, streamState);
@@ -4389,20 +4389,20 @@
           break;
         case 67:
           (response = response._chunks.get(id)) &&
-            "fulfilled" === response.status &&
-            response.reason.close("" === buffer ? '"$undefined"' : buffer);
+            'fulfilled' === response.status &&
+            response.reason.close('' === buffer ? '"$undefined"' : buffer);
           break;
         default:
-          if ("" === buffer) {
+          if ('' === buffer) {
             if (
               ((streamState = response._chunks),
               (buffer = streamState.get(id)) ||
                 streamState.set(id, (buffer = createPendingChunk(response))),
-              "pending" === buffer.status || "blocked" === buffer.status)
+              'pending' === buffer.status || 'blocked' === buffer.status)
             )
               releasePendingChunk(response, buffer),
                 (response = buffer),
-                (response.status = "halted"),
+                (response.status = 'halted'),
                 (response.value = null),
                 (response.reason = null);
           } else
@@ -4417,9 +4417,9 @@
     }
     function createFromJSONCallback(response) {
       return function (key, value) {
-        if ("string" === typeof value)
+        if ('string' === typeof value)
           return parseModelString(response, this, key, value);
-        if ("object" === typeof value && null !== value) {
+        if ('object' === typeof value && null !== value) {
           if (value[0] === REACT_ELEMENT_TYPE)
             b: {
               var owner = value[4],
@@ -4430,46 +4430,46 @@
                 type: value[1],
                 key: value[2],
                 props: value[3],
-                _owner: void 0 === owner ? null : owner
+                _owner: void 0 === owner ? null : owner,
               };
-              Object.defineProperty(value, "ref", {
+              Object.defineProperty(value, 'ref', {
                 enumerable: !1,
-                get: nullRefGetter
+                get: nullRefGetter,
               });
               value._store = {};
-              Object.defineProperty(value._store, "validated", {
+              Object.defineProperty(value._store, 'validated', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: key
+                value: key,
               });
-              Object.defineProperty(value, "_debugInfo", {
+              Object.defineProperty(value, '_debugInfo', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: null
+                value: null,
               });
-              Object.defineProperty(value, "_debugStack", {
+              Object.defineProperty(value, '_debugStack', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: void 0 === stack ? null : stack
+                value: void 0 === stack ? null : stack,
               });
-              Object.defineProperty(value, "_debugTask", {
+              Object.defineProperty(value, '_debugTask', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: null
+                value: null,
               });
               if (null !== initializingHandler) {
                 owner = initializingHandler;
                 initializingHandler = owner.parent;
                 if (owner.errored) {
-                  stack = new ReactPromise("rejected", null, owner.reason);
+                  stack = new ReactPromise('rejected', null, owner.reason);
                   initializeElement(response, value, null);
                   owner = {
-                    name: getComponentNameFromType(value.type) || "",
-                    owner: value._owner
+                    name: getComponentNameFromType(value.type) || '',
+                    owner: value._owner,
                   };
                   owner.debugStack = value._debugStack;
                   supportsCreateTask && (owner.debugTask = value._debugTask);
@@ -4478,7 +4478,7 @@
                   break b;
                 }
                 if (0 < owner.deps) {
-                  stack = new ReactPromise("blocked", null, null);
+                  stack = new ReactPromise('blocked', null, null);
                   owner.value = value;
                   owner.chunk = stack;
                   key = createLazyChunkWrapper(stack, key);
@@ -4497,11 +4497,11 @@
       };
     }
     function close(weakResponse) {
-      reportGlobalError(weakResponse, Error("Connection closed."));
+      reportGlobalError(weakResponse, Error('Connection closed.'));
     }
     function noServerCall() {
       throw Error(
-        "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+        'Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.',
       );
     }
     function createResponseFromOptions(options) {
@@ -4511,7 +4511,7 @@
         options.serverConsumerManifest.moduleLoading,
         noServerCall,
         options.encodeFormAction,
-        "string" === typeof options.nonce ? options.nonce : void 0,
+        'string' === typeof options.nonce ? options.nonce : void 0,
         options && options.temporaryReferences
           ? options.temporaryReferences
           : void 0,
@@ -4521,16 +4521,16 @@
         options && void 0 !== options.debugChannel
           ? {
               hasReadable: void 0 !== options.debugChannel.readable,
-              callback: null
+              callback: null,
             }
-          : void 0
+          : void 0,
       )._weakResponse;
     }
     function startReadingFromStream(
       response$jscomp$0,
       stream,
       onDone,
-      debugValue
+      debugValue,
     ) {
       function progress(_ref) {
         var value = _ref.value;
@@ -4559,7 +4559,7 @@
                 value: debugInfo.value,
                 owner: debugInfo.owner,
                 debugStack: debugInfo.debugStack,
-                debugTask: debugInfo.debugTask
+                debugTask: debugInfo.debugTask,
               }),
               (_ref._debugTargetChunkSize = newByteLength + MIN_CHUNK_SIZE))
             : ((debugInfo.end = endTime), (debugInfo.byteSize = newByteLength));
@@ -4618,7 +4618,7 @@
               (rowLength = new Uint8Array(
                 value.buffer,
                 endTime,
-                debugInfo - i
+                debugInfo - i,
               )),
                 processFullBinaryRow(
                   response,
@@ -4626,7 +4626,7 @@
                   rowID,
                   rowTag,
                   buffer,
-                  rowLength
+                  rowLength,
                 ),
                 (i = debugInfo),
                 3 === rowState && i++,
@@ -4636,7 +4636,7 @@
               value = new Uint8Array(
                 value.buffer,
                 endTime,
-                value.byteLength - i
+                value.byteLength - i,
               );
               buffer.push(value);
               rowLength -= value.byteLength;
@@ -4657,33 +4657,33 @@
         reader = stream.getReader();
       reader.read().then(progress).catch(error);
     }
-    var ReactDOM = require("react-dom"),
-      React = require("react"),
+    var ReactDOM = require('react-dom'),
+      React = require('react'),
       decoderOptions = { stream: !0 },
       bind$1 = Function.prototype.bind,
       chunkCache = new Map(),
       ReactDOMSharedInternals =
         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
-      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
+      REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+      REACT_PORTAL_TYPE = Symbol.for('react.portal'),
+      REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+      REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode'),
+      REACT_PROFILER_TYPE = Symbol.for('react.profiler'),
+      REACT_CONSUMER_TYPE = Symbol.for('react.consumer'),
+      REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+      REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+      REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+      REACT_MEMO_TYPE = Symbol.for('react.memo'),
+      REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+      REACT_ACTIVITY_TYPE = Symbol.for('react.activity'),
       MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
       ASYNC_ITERATOR = Symbol.asyncIterator,
       isArrayImpl = Array.isArray,
       getPrototypeOf = Object.getPrototypeOf,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
-      CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"),
+      CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference'),
       ObjectPrototype = Object.prototype,
       knownServerReferences = new WeakMap(),
       boundCache = new WeakMap(),
@@ -4694,19 +4694,19 @@
         /^ {3} at (?:(.+) \((.+):(\d+):(\d+)\)|(?:async )?(.+):(\d+):(\d+))$/,
       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\d+):(\d+)/,
       hasOwnProperty = Object.prototype.hasOwnProperty,
-      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
+      REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference'),
       supportsUserTiming =
-        "undefined" !== typeof console &&
-        "function" === typeof console.timeStamp &&
-        "undefined" !== typeof performance &&
-        "function" === typeof performance.measure,
+        'undefined' !== typeof console &&
+        'function' === typeof console.timeStamp &&
+        'undefined' !== typeof performance &&
+        'function' === typeof performance.measure,
       trackNames =
-        "Primary Parallel Parallel\u200b Parallel\u200b\u200b Parallel\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b".split(
-          " "
+        'Primary Parallel Parallel\u200b Parallel\u200b\u200b Parallel\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b'.split(
+          ' ',
         ),
       prefix,
       suffix;
-    new ("function" === typeof WeakMap ? WeakMap : Map)();
+    new ('function' === typeof WeakMap ? WeakMap : Map)();
     var ReactSharedInteralsServer =
         React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
       ReactSharedInternals =
@@ -4716,10 +4716,10 @@
     ReactPromise.prototype.then = function (resolve, reject) {
       var _this = this;
       switch (this.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(this);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(this);
       }
       var resolveCallback = resolve,
@@ -4736,26 +4736,26 @@
         });
       wrapperPromise.then(resolveCallback, rejectCallback);
       switch (this.status) {
-        case "fulfilled":
-          "function" === typeof resolve && resolve(this.value);
+        case 'fulfilled':
+          'function' === typeof resolve && resolve(this.value);
           break;
-        case "pending":
-        case "blocked":
-          "function" === typeof resolve &&
+        case 'pending':
+        case 'blocked':
+          'function' === typeof resolve &&
             (null === this.value && (this.value = []),
             this.value.push(resolve));
-          "function" === typeof reject &&
+          'function' === typeof reject &&
             (null === this.reason && (this.reason = []),
             this.reason.push(reject));
           break;
-        case "halted":
+        case 'halted':
           break;
         default:
-          "function" === typeof reject && reject(this.reason);
+          'function' === typeof reject && reject(this.reason);
       }
     };
     var debugChannelRegistry =
-        "function" === typeof FinalizationRegistry
+        'function' === typeof FinalizationRegistry
           ? new FinalizationRegistry(closeDebugChannel)
           : null,
       initializingHandler = null,
@@ -4772,13 +4772,13 @@
             stack,
             environmentName,
             !1,
-            fakeJSXCallSite
+            fakeJSXCallSite,
           )();
-        }
+        },
       },
       createFakeJSXCallStackInDEV =
         createFakeJSXCallStack.react_stack_bottom_frame.bind(
-          createFakeJSXCallStack
+          createFakeJSXCallStack,
         ),
       currentOwnerInDEV = null,
       replayConsoleWithCallStack = {
@@ -4795,40 +4795,40 @@
             a: {
               var offset = 0;
               switch (methodName) {
-                case "dir":
-                case "dirxml":
-                case "groupEnd":
-                case "table":
+                case 'dir':
+                case 'dirxml':
+                case 'groupEnd':
+                case 'table':
                   var JSCompiler_inline_result = bind$1.apply(
                     console[methodName],
-                    [console].concat(payload)
+                    [console].concat(payload),
                   );
                   break a;
-                case "assert":
+                case 'assert':
                   offset = 1;
               }
               var newArgs = payload.slice(0);
-              "string" === typeof newArgs[offset]
+              'string' === typeof newArgs[offset]
                 ? newArgs.splice(
                     offset,
                     1,
-                    "\u001b[0m\u001b[7m%c%s\u001b[0m%c " + newArgs[offset],
-                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
-                    " " + env + " ",
-                    ""
+                    '\u001b[0m\u001b[7m%c%s\u001b[0m%c ' + newArgs[offset],
+                    'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px',
+                    ' ' + env + ' ',
+                    '',
                   )
                 : newArgs.splice(
                     offset,
                     0,
-                    "\u001b[0m\u001b[7m%c%s\u001b[0m%c",
-                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
-                    " " + env + " ",
-                    ""
+                    '\u001b[0m\u001b[7m%c%s\u001b[0m%c',
+                    'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px',
+                    ' ' + env + ' ',
+                    '',
                   );
               newArgs.unshift(console);
               JSCompiler_inline_result = bind$1.apply(
                 console[methodName],
-                newArgs
+                newArgs,
               );
             }
             var callStack = buildFakeCallStack(
@@ -4836,7 +4836,7 @@
               stackTrace,
               env,
               !1,
-              JSCompiler_inline_result
+              JSCompiler_inline_result,
             );
             if (null != owner) {
               var task = initializeFakeTask(response, owner);
@@ -4852,11 +4852,11 @@
             (currentOwnerInDEV = null),
               (ReactSharedInternals.getCurrentStack = prevStack);
           }
-        }
+        },
       },
       replayConsoleWithCallStackInDEV =
         replayConsoleWithCallStack.react_stack_bottom_frame.bind(
-          replayConsoleWithCallStack
+          replayConsoleWithCallStack,
         );
     exports.createFromFetch = function (promiseForResponse, options) {
       var response = createResponseFromOptions(options);
@@ -4874,7 +4874,7 @@
             startReadingFromStream(
               response,
               options.debugChannel.readable,
-              handleDone
+              handleDone,
             );
             startReadingFromStream(response, r.body, handleDone, r);
           } else
@@ -4882,12 +4882,12 @@
               response,
               r.body,
               close.bind(null, response),
-              r
+              r,
             );
         },
         function (e) {
           reportGlobalError(response, e);
-        }
+        },
       );
       return getRoot(response);
     };
@@ -4901,7 +4901,7 @@
         startReadingFromStream(
           response,
           options.debugChannel.readable,
-          handleDone
+          handleDone,
         );
         startReadingFromStream(response, stream, handleDone, stream);
       } else
@@ -4909,7 +4909,7 @@
           response,
           stream,
           close.bind(null, response),
-          stream
+          stream,
         );
       return getRoot(response);
     };
@@ -4923,12 +4923,12 @@
       return new Promise(function (resolve, reject) {
         var abort = processReply(
           value,
-          "",
+          '',
           options && options.temporaryReferences
             ? options.temporaryReferences
             : void 0,
           resolve,
-          reject
+          reject,
         );
         if (options && options.signal) {
           var signal = options.signal;
@@ -4936,9 +4936,9 @@
           else {
             var listener = function () {
               abort(signal.reason);
-              signal.removeEventListener("abort", listener);
+              signal.removeEventListener('abort', listener);
             };
-            signal.addEventListener("abort", listener);
+            signal.addEventListener('abort', listener);
           }
         }
       });
@@ -4946,7 +4946,7 @@
     exports.registerServerReference = function (
       reference,
       id,
-      encodeFormAction
+      encodeFormAction,
     ) {
       registerBoundServerReference(reference, id, null, encodeFormAction);
       return reference;
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.edge.production.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.edge.production.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.edge.production.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.edge.production.js	2025-12-17 14:32:44
@@ -8,8 +8,8 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-var ReactDOM = require("react-dom"),
+'use strict';
+var ReactDOM = require('react-dom'),
   decoderOptions = { stream: !0 };
 function resolveClientReference(bundlerConfig, metadata) {
   if (bundlerConfig) {
@@ -17,12 +17,12 @@
     if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))
       moduleExports = bundlerConfig.name;
     else {
-      bundlerConfig = moduleExports && moduleExports["*"];
+      bundlerConfig = moduleExports && moduleExports['*'];
       if (!bundlerConfig)
         throw Error(
           'Could not find the module "' +
             metadata[0] +
-            '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'
+            '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.',
         );
       moduleExports = metadata[2];
     }
@@ -33,11 +33,11 @@
   return metadata;
 }
 function resolveServerReference(bundlerConfig, id) {
-  var name = "",
+  var name = '',
     resolvedModuleData = bundlerConfig[id];
   if (resolvedModuleData) name = resolvedModuleData.name;
   else {
-    var idx = id.lastIndexOf("#");
+    var idx = id.lastIndexOf('#');
     -1 !== idx &&
       ((name = id.slice(idx + 1)),
       (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -45,7 +45,7 @@
       throw Error(
         'Could not find the module "' +
           id +
-          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
       );
   }
   return resolvedModuleData.async
@@ -55,17 +55,17 @@
 var chunkCache = new Map();
 function requireAsyncModule(id) {
   var promise = __webpack_require__(id);
-  if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+  if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
     return null;
   promise.then(
     function (value) {
-      promise.status = "fulfilled";
+      promise.status = 'fulfilled';
       promise.value = value;
     },
     function (reason) {
-      promise.status = "rejected";
+      promise.status = 'rejected';
       promise.reason = reason;
-    }
+    },
   );
   return promise;
 }
@@ -95,13 +95,13 @@
 }
 function requireModule(metadata) {
   var moduleExports = __webpack_require__(metadata[0]);
-  if (4 === metadata.length && "function" === typeof moduleExports.then)
-    if ("fulfilled" === moduleExports.status)
+  if (4 === metadata.length && 'function' === typeof moduleExports.then)
+    if ('fulfilled' === moduleExports.status)
       moduleExports = moduleExports.value;
     else throw moduleExports.reason;
-  return "*" === metadata[2]
+  return '*' === metadata[2]
     ? moduleExports
-    : "" === metadata[2]
+    : '' === metadata[2]
       ? moduleExports.__esModule
         ? moduleExports.default
         : moduleExports
@@ -116,29 +116,29 @@
         JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];
       var JSCompiler_inline_result = moduleLoading.crossOrigin;
       JSCompiler_inline_result =
-        "string" === typeof JSCompiler_inline_result
-          ? "use-credentials" === JSCompiler_inline_result
+        'string' === typeof JSCompiler_inline_result
+          ? 'use-credentials' === JSCompiler_inline_result
             ? JSCompiler_inline_result
-            : ""
+            : ''
           : void 0;
       JSCompiler_temp_const$jscomp$0.call(
         JSCompiler_temp_const,
         JSCompiler_temp_const$jscomp$1,
-        { crossOrigin: JSCompiler_inline_result, nonce: nonce }
+        { crossOrigin: JSCompiler_inline_result, nonce: nonce },
       );
     }
 }
 var ReactDOMSharedInternals =
     ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
-  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
+  REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+  REACT_LAZY_TYPE = Symbol.for('react.lazy'),
   MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
 function getIteratorFn(maybeIterable) {
-  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  if (null === maybeIterable || 'object' !== typeof maybeIterable) return null;
   maybeIterable =
     (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-    maybeIterable["@@iterator"];
-  return "function" === typeof maybeIterable ? maybeIterable : null;
+    maybeIterable['@@iterator'];
+  return 'function' === typeof maybeIterable ? maybeIterable : null;
 }
 var ASYNC_ITERATOR = Symbol.asyncIterator,
   isArrayImpl = Array.isArray,
@@ -148,33 +148,33 @@
 function serializeNumber(number) {
   return Number.isFinite(number)
     ? 0 === number && -Infinity === 1 / number
-      ? "$-0"
+      ? '$-0'
       : number
     : Infinity === number
-      ? "$Infinity"
+      ? '$Infinity'
       : -Infinity === number
-        ? "$-Infinity"
-        : "$NaN";
+        ? '$-Infinity'
+        : '$NaN';
 }
 function processReply(
   root,
   formFieldPrefix,
   temporaryReferences,
   resolve,
-  reject
+  reject,
 ) {
   function serializeTypedArray(tag, typedArray) {
     typedArray = new Blob([
       new Uint8Array(
         typedArray.buffer,
         typedArray.byteOffset,
-        typedArray.byteLength
-      )
+        typedArray.byteLength,
+      ),
     ]);
     var blobId = nextPartId++;
     null === formData && (formData = new FormData());
     formData.append(formFieldPrefix + blobId, typedArray);
-    return "$" + tag + blobId.toString(16);
+    return '$' + tag + blobId.toString(16);
   }
   function serializeBinaryReader(reader) {
     function progress(entry) {
@@ -183,9 +183,9 @@
           data.append(formFieldPrefix + entry, new Blob(buffer)),
           data.append(
             formFieldPrefix + streamId,
-            '"$o' + entry.toString(16) + '"'
+            '"$o' + entry.toString(16) + '"',
           ),
-          data.append(formFieldPrefix + streamId, "C"),
+          data.append(formFieldPrefix + streamId, 'C'),
           pendingParts--,
           0 === pendingParts && resolve(data))
         : (buffer.push(entry.value),
@@ -197,12 +197,12 @@
     var streamId = nextPartId++,
       buffer = [];
     reader.read(new Uint8Array(1024)).then(progress, reject);
-    return "$r" + streamId.toString(16);
+    return '$r' + streamId.toString(16);
   }
   function serializeReader(reader) {
     function progress(entry) {
       if (entry.done)
-        data.append(formFieldPrefix + streamId, "C"),
+        data.append(formFieldPrefix + streamId, 'C'),
           pendingParts--,
           0 === pendingParts && resolve(data);
       else
@@ -219,11 +219,11 @@
     pendingParts++;
     var streamId = nextPartId++;
     reader.read().then(progress, reject);
-    return "$R" + streamId.toString(16);
+    return '$R' + streamId.toString(16);
   }
   function serializeReadableStream(stream) {
     try {
-      var binaryReader = stream.getReader({ mode: "byob" });
+      var binaryReader = stream.getReader({ mode: 'byob' });
     } catch (x) {
       return serializeReader(stream.getReader());
     }
@@ -233,11 +233,11 @@
     function progress(entry) {
       if (entry.done) {
         if (void 0 === entry.value)
-          data.append(formFieldPrefix + streamId, "C");
+          data.append(formFieldPrefix + streamId, 'C');
         else
           try {
             var partJSON = JSON.stringify(entry.value, resolveToJSON);
-            data.append(formFieldPrefix + streamId, "C" + partJSON);
+            data.append(formFieldPrefix + streamId, 'C' + partJSON);
           } catch (x) {
             reject(x);
             return;
@@ -259,23 +259,23 @@
     var streamId = nextPartId++;
     iterable = iterable === iterator;
     iterator.next().then(progress, reject);
-    return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+    return '$' + (iterable ? 'x' : 'X') + streamId.toString(16);
   }
   function resolveToJSON(key, value) {
     if (null === value) return null;
-    if ("object" === typeof value) {
+    if ('object' === typeof value) {
       switch (value.$$typeof) {
         case REACT_ELEMENT_TYPE:
-          if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+          if (void 0 !== temporaryReferences && -1 === key.indexOf(':')) {
             var parentReference = writtenObjects.get(this);
             if (void 0 !== parentReference)
               return (
-                temporaryReferences.set(parentReference + ":" + key, value),
-                "$T"
+                temporaryReferences.set(parentReference + ':' + key, value),
+                '$T'
               );
           }
           throw Error(
-            "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+            'React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.',
           );
         case REACT_LAZY_TYPE:
           parentReference = value._payload;
@@ -287,12 +287,12 @@
               lazyId = nextPartId++,
               partJSON = serializeModel(resolvedModel, lazyId);
             formData.append(formFieldPrefix + lazyId, partJSON);
-            return "$" + lazyId.toString(16);
+            return '$' + lazyId.toString(16);
           } catch (x) {
             if (
-              "object" === typeof x &&
+              'object' === typeof x &&
               null !== x &&
-              "function" === typeof x.then
+              'function' === typeof x.then
             ) {
               pendingParts++;
               var lazyId$23 = nextPartId++;
@@ -308,7 +308,7 @@
                 }
               };
               x.then(parentReference, parentReference);
-              return "$" + lazyId$23.toString(16);
+              return '$' + lazyId$23.toString(16);
             }
             reject(x);
             return null;
@@ -316,7 +316,7 @@
             pendingParts--;
           }
       }
-      if ("function" === typeof value.then) {
+      if ('function' === typeof value.then) {
         null === formData && (formData = new FormData());
         pendingParts++;
         var promiseId = nextPartId++;
@@ -331,17 +331,17 @@
             reject(reason);
           }
         }, reject);
-        return "$@" + promiseId.toString(16);
+        return '$@' + promiseId.toString(16);
       }
       parentReference = writtenObjects.get(value);
       if (void 0 !== parentReference)
         if (modelRoot === value) modelRoot = null;
         else return parentReference;
       else
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
           ((parentReference = writtenObjects.get(this)),
           void 0 !== parentReference &&
-            ((key = parentReference + ":" + key),
+            ((key = parentReference + ':' + key),
             writtenObjects.set(value, key),
             void 0 !== temporaryReferences &&
               temporaryReferences.set(key, value)));
@@ -350,11 +350,11 @@
         null === formData && (formData = new FormData());
         var data$31 = formData;
         key = nextPartId++;
-        var prefix = formFieldPrefix + key + "_";
+        var prefix = formFieldPrefix + key + '_';
         value.forEach(function (originalValue, originalKey) {
           data$31.append(prefix + originalKey, originalValue);
         });
-        return "$K" + key.toString(16);
+        return '$K' + key.toString(16);
       }
       if (value instanceof Map)
         return (
@@ -362,7 +362,7 @@
           (parentReference = serializeModel(Array.from(value), key)),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + key, parentReference),
-          "$Q" + key.toString(16)
+          '$Q' + key.toString(16)
         );
       if (value instanceof Set)
         return (
@@ -370,7 +370,7 @@
           (parentReference = serializeModel(Array.from(value), key)),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + key, parentReference),
-          "$W" + key.toString(16)
+          '$W' + key.toString(16)
         );
       if (value instanceof ArrayBuffer)
         return (
@@ -378,29 +378,29 @@
           (parentReference = nextPartId++),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + parentReference, key),
-          "$A" + parentReference.toString(16)
+          '$A' + parentReference.toString(16)
         );
-      if (value instanceof Int8Array) return serializeTypedArray("O", value);
-      if (value instanceof Uint8Array) return serializeTypedArray("o", value);
+      if (value instanceof Int8Array) return serializeTypedArray('O', value);
+      if (value instanceof Uint8Array) return serializeTypedArray('o', value);
       if (value instanceof Uint8ClampedArray)
-        return serializeTypedArray("U", value);
-      if (value instanceof Int16Array) return serializeTypedArray("S", value);
-      if (value instanceof Uint16Array) return serializeTypedArray("s", value);
-      if (value instanceof Int32Array) return serializeTypedArray("L", value);
-      if (value instanceof Uint32Array) return serializeTypedArray("l", value);
-      if (value instanceof Float32Array) return serializeTypedArray("G", value);
-      if (value instanceof Float64Array) return serializeTypedArray("g", value);
+        return serializeTypedArray('U', value);
+      if (value instanceof Int16Array) return serializeTypedArray('S', value);
+      if (value instanceof Uint16Array) return serializeTypedArray('s', value);
+      if (value instanceof Int32Array) return serializeTypedArray('L', value);
+      if (value instanceof Uint32Array) return serializeTypedArray('l', value);
+      if (value instanceof Float32Array) return serializeTypedArray('G', value);
+      if (value instanceof Float64Array) return serializeTypedArray('g', value);
       if (value instanceof BigInt64Array)
-        return serializeTypedArray("M", value);
+        return serializeTypedArray('M', value);
       if (value instanceof BigUint64Array)
-        return serializeTypedArray("m", value);
-      if (value instanceof DataView) return serializeTypedArray("V", value);
-      if ("function" === typeof Blob && value instanceof Blob)
+        return serializeTypedArray('m', value);
+      if (value instanceof DataView) return serializeTypedArray('V', value);
+      if ('function' === typeof Blob && value instanceof Blob)
         return (
           null === formData && (formData = new FormData()),
           (key = nextPartId++),
           formData.append(formFieldPrefix + key, value),
-          "$B" + key.toString(16)
+          '$B' + key.toString(16)
         );
       if ((key = getIteratorFn(value)))
         return (
@@ -409,20 +409,20 @@
             ? ((key = nextPartId++),
               (parentReference = serializeModel(
                 Array.from(parentReference),
-                key
+                key,
               )),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$i" + key.toString(16))
+              '$i' + key.toString(16))
             : Array.from(parentReference)
         );
       if (
-        "function" === typeof ReadableStream &&
+        'function' === typeof ReadableStream &&
         value instanceof ReadableStream
       )
         return serializeReadableStream(value);
       key = value[ASYNC_ITERATOR];
-      if ("function" === typeof key)
+      if ('function' === typeof key)
         return serializeAsyncIterable(value, key.call(value));
       key = getPrototypeOf(value);
       if (
@@ -431,72 +431,72 @@
       ) {
         if (void 0 === temporaryReferences)
           throw Error(
-            "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported."
+            'Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.',
           );
-        return "$T";
+        return '$T';
       }
       return value;
     }
-    if ("string" === typeof value) {
-      if ("Z" === value[value.length - 1] && this[key] instanceof Date)
-        return "$D" + value;
-      key = "$" === value[0] ? "$" + value : value;
+    if ('string' === typeof value) {
+      if ('Z' === value[value.length - 1] && this[key] instanceof Date)
+        return '$D' + value;
+      key = '$' === value[0] ? '$' + value : value;
       return key;
     }
-    if ("boolean" === typeof value) return value;
-    if ("number" === typeof value) return serializeNumber(value);
-    if ("undefined" === typeof value) return "$undefined";
-    if ("function" === typeof value) {
+    if ('boolean' === typeof value) return value;
+    if ('number' === typeof value) return serializeNumber(value);
+    if ('undefined' === typeof value) return '$undefined';
+    if ('function' === typeof value) {
       parentReference = knownServerReferences.get(value);
       if (void 0 !== parentReference)
         return (
           (key = JSON.stringify(
             { id: parentReference.id, bound: parentReference.bound },
-            resolveToJSON
+            resolveToJSON,
           )),
           null === formData && (formData = new FormData()),
           (parentReference = nextPartId++),
           formData.set(formFieldPrefix + parentReference, key),
-          "$F" + parentReference.toString(16)
+          '$F' + parentReference.toString(16)
         );
       if (
         void 0 !== temporaryReferences &&
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
         ((parentReference = writtenObjects.get(this)),
         void 0 !== parentReference)
       )
         return (
-          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+          temporaryReferences.set(parentReference + ':' + key, value), '$T'
         );
       throw Error(
-        "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+        'Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.',
       );
     }
-    if ("symbol" === typeof value) {
+    if ('symbol' === typeof value) {
       if (
         void 0 !== temporaryReferences &&
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
         ((parentReference = writtenObjects.get(this)),
         void 0 !== parentReference)
       )
         return (
-          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+          temporaryReferences.set(parentReference + ':' + key, value), '$T'
         );
       throw Error(
-        "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+        'Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.',
       );
     }
-    if ("bigint" === typeof value) return "$n" + value.toString(10);
+    if ('bigint' === typeof value) return '$n' + value.toString(10);
     throw Error(
-      "Type " +
+      'Type ' +
         typeof value +
-        " is not supported as an argument to a Server Function."
+        ' is not supported as an argument to a Server Function.',
     );
   }
   function serializeModel(model, id) {
-    "object" === typeof model &&
+    'object' === typeof model &&
       null !== model &&
-      ((id = "$" + id.toString(16)),
+      ((id = '$' + id.toString(16)),
       writtenObjects.set(model, id),
       void 0 !== temporaryReferences && temporaryReferences.set(id, model));
     modelRoot = model;
@@ -510,7 +510,7 @@
     json = serializeModel(root, 0);
   null === formData
     ? resolve(json)
-    : (formData.set(formFieldPrefix + "0", json),
+    : (formData.set(formFieldPrefix + '0', json),
       0 === pendingParts && resolve(formData));
   return function () {
     0 < pendingParts &&
@@ -528,23 +528,23 @@
     });
   processReply(
     reference,
-    "",
+    '',
     void 0,
     function (body) {
-      if ("string" === typeof body) {
+      if ('string' === typeof body) {
         var data = new FormData();
-        data.append("0", body);
+        data.append('0', body);
         body = data;
       }
-      thenable.status = "fulfilled";
+      thenable.status = 'fulfilled';
       thenable.value = body;
       resolve(body);
     },
     function (e) {
-      thenable.status = "rejected";
+      thenable.status = 'rejected';
       thenable.reason = e;
       reject(e);
-    }
+    },
   );
   return thenable;
 }
@@ -552,7 +552,7 @@
   var referenceClosure = knownServerReferences.get(this);
   if (!referenceClosure)
     throw Error(
-      "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+      'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
     );
   var data = null;
   if (null !== referenceClosure.bound) {
@@ -560,55 +560,55 @@
     data ||
       ((data = encodeFormData({
         id: referenceClosure.id,
-        bound: referenceClosure.bound
+        bound: referenceClosure.bound,
       })),
       boundCache.set(referenceClosure, data));
-    if ("rejected" === data.status) throw data.reason;
-    if ("fulfilled" !== data.status) throw data;
+    if ('rejected' === data.status) throw data.reason;
+    if ('fulfilled' !== data.status) throw data;
     referenceClosure = data.value;
     var prefixedData = new FormData();
     referenceClosure.forEach(function (value, key) {
-      prefixedData.append("$ACTION_" + identifierPrefix + ":" + key, value);
+      prefixedData.append('$ACTION_' + identifierPrefix + ':' + key, value);
     });
     data = prefixedData;
-    referenceClosure = "$ACTION_REF_" + identifierPrefix;
-  } else referenceClosure = "$ACTION_ID_" + referenceClosure.id;
+    referenceClosure = '$ACTION_REF_' + identifierPrefix;
+  } else referenceClosure = '$ACTION_ID_' + referenceClosure.id;
   return {
     name: referenceClosure,
-    method: "POST",
-    encType: "multipart/form-data",
-    data: data
+    method: 'POST',
+    encType: 'multipart/form-data',
+    data: data,
   };
 }
 function isSignatureEqual(referenceId, numberOfBoundArgs) {
   var referenceClosure = knownServerReferences.get(this);
   if (!referenceClosure)
     throw Error(
-      "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+      'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
     );
   if (referenceClosure.id !== referenceId) return !1;
   var boundPromise = referenceClosure.bound;
   if (null === boundPromise) return 0 === numberOfBoundArgs;
   switch (boundPromise.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return boundPromise.value.length === numberOfBoundArgs;
-    case "pending":
+    case 'pending':
       throw boundPromise;
-    case "rejected":
+    case 'rejected':
       throw boundPromise.reason;
     default:
       throw (
-        ("string" !== typeof boundPromise.status &&
-          ((boundPromise.status = "pending"),
+        ('string' !== typeof boundPromise.status &&
+          ((boundPromise.status = 'pending'),
           boundPromise.then(
             function (boundArgs) {
-              boundPromise.status = "fulfilled";
+              boundPromise.status = 'fulfilled';
               boundPromise.value = boundArgs;
             },
             function (error) {
-              boundPromise.status = "rejected";
+              boundPromise.status = 'rejected';
               boundPromise.reason = error;
-            }
+            },
           )),
         boundPromise)
       );
@@ -619,7 +619,7 @@
     (knownServerReferences.set(reference, {
       id: id,
       originalBind: reference.bind,
-      bound: bound
+      bound: bound,
     }),
     Object.defineProperties(reference, {
       $$FORM_ACTION: {
@@ -630,15 +630,15 @@
                 var referenceClosure = knownServerReferences.get(this);
                 if (!referenceClosure)
                   throw Error(
-                    "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+                    'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
                   );
                 var boundPromise = referenceClosure.bound;
                 null === boundPromise && (boundPromise = Promise.resolve([]));
                 return encodeFormAction(referenceClosure.id, boundPromise);
-              }
+              },
       },
       $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-      bind: { value: bind }
+      bind: { value: bind },
     }));
 }
 var FunctionBind = Function.prototype.bind,
@@ -658,12 +658,12 @@
   knownServerReferences.set(newFn, {
     id: referenceClosure.id,
     originalBind: newFn.bind,
-    bound: boundPromise
+    bound: boundPromise,
   });
   Object.defineProperties(newFn, {
     $$FORM_ACTION: { value: this.$$FORM_ACTION },
     $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-    bind: { value: bind }
+    bind: { value: bind },
   });
   return newFn;
 }
@@ -671,7 +671,7 @@
   function action() {
     var args = Array.prototype.slice.call(arguments);
     return bound
-      ? "fulfilled" === bound.status
+      ? 'fulfilled' === bound.status
         ? callServer(id, bound.value.concat(args))
         : Promise.resolve(bound).then(function (boundArgs) {
             return callServer(id, boundArgs.concat(args));
@@ -699,43 +699,43 @@
 ReactPromise.prototype = Object.create(Promise.prototype);
 ReactPromise.prototype.then = function (resolve, reject) {
   switch (this.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(this);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(this);
   }
   switch (this.status) {
-    case "fulfilled":
-      "function" === typeof resolve && resolve(this.value);
+    case 'fulfilled':
+      'function' === typeof resolve && resolve(this.value);
       break;
-    case "pending":
-    case "blocked":
-      "function" === typeof resolve &&
+    case 'pending':
+    case 'blocked':
+      'function' === typeof resolve &&
         (null === this.value && (this.value = []), this.value.push(resolve));
-      "function" === typeof reject &&
+      'function' === typeof reject &&
         (null === this.reason && (this.reason = []), this.reason.push(reject));
       break;
-    case "halted":
+    case 'halted':
       break;
     default:
-      "function" === typeof reject && reject(this.reason);
+      'function' === typeof reject && reject(this.reason);
   }
 };
 function readChunk(chunk) {
   switch (chunk.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(chunk);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(chunk);
   }
   switch (chunk.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return chunk.value;
-    case "pending":
-    case "blocked":
-    case "halted":
+    case 'pending':
+    case 'blocked':
+    case 'halted':
       throw chunk;
     default:
       throw chunk.reason;
@@ -744,7 +744,7 @@
 function wakeChunk(listeners, value) {
   for (var i = 0; i < listeners.length; i++) {
     var listener = listeners[i];
-    "function" === typeof listener
+    'function' === typeof listener
       ? listener(value)
       : fulfillReference(listener, value);
   }
@@ -752,7 +752,7 @@
 function rejectChunk(listeners, error) {
   for (var i = 0; i < listeners.length; i++) {
     var listener = listeners[i];
-    "function" === typeof listener
+    'function' === typeof listener
       ? listener(error)
       : rejectReference(listener, error);
   }
@@ -770,7 +770,7 @@
     ) {
       var listener = reference[referencedChunk];
       if (
-        "function" !== typeof listener &&
+        'function' !== typeof listener &&
         ((listener = resolveBlockedCycle(resolvedChunk, listener)),
         null !== listener)
       )
@@ -780,13 +780,13 @@
 }
 function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
   switch (chunk.status) {
-    case "fulfilled":
+    case 'fulfilled':
       wakeChunk(resolveListeners, chunk.value);
       break;
-    case "blocked":
+    case 'blocked':
       for (var i = 0; i < resolveListeners.length; i++) {
         var listener = resolveListeners[i];
-        if ("function" !== typeof listener) {
+        if ('function' !== typeof listener) {
           var cyclicHandler = resolveBlockedCycle(chunk, listener);
           null !== cyclicHandler &&
             (fulfillReference(listener, cyclicHandler.value),
@@ -797,7 +797,7 @@
               -1 !== listener && rejectListeners.splice(listener, 1)));
         }
       }
-    case "pending":
+    case 'pending':
       if (chunk.value)
         for (i = 0; i < resolveListeners.length; i++)
           chunk.value.push(resolveListeners[i]);
@@ -812,38 +812,38 @@
             chunk.reason.push(rejectListeners[resolveListeners]);
       } else chunk.reason = rejectListeners;
       break;
-    case "rejected":
+    case 'rejected':
       rejectListeners && rejectChunk(rejectListeners, chunk.reason);
   }
 }
 function triggerErrorOnChunk(response, chunk, error) {
-  "pending" !== chunk.status && "blocked" !== chunk.status
+  'pending' !== chunk.status && 'blocked' !== chunk.status
     ? chunk.reason.error(error)
     : ((response = chunk.reason),
-      (chunk.status = "rejected"),
+      (chunk.status = 'rejected'),
       (chunk.reason = error),
       null !== response && rejectChunk(response, error));
 }
 function createResolvedIteratorResultChunk(response, value, done) {
   return new ReactPromise(
-    "resolved_model",
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
-    response
+    'resolved_model',
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
+    response,
   );
 }
 function resolveIteratorResultChunk(response, chunk, value, done) {
   resolveModelChunk(
     response,
     chunk,
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}"
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
   );
 }
 function resolveModelChunk(response, chunk, value) {
-  if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+  if ('pending' !== chunk.status) chunk.reason.enqueueModel(value);
   else {
     var resolveListeners = chunk.value,
       rejectListeners = chunk.reason;
-    chunk.status = "resolved_model";
+    chunk.status = 'resolved_model';
     chunk.value = value;
     chunk.reason = response;
     null !== resolveListeners &&
@@ -852,10 +852,10 @@
   }
 }
 function resolveModuleChunk(response, chunk, value) {
-  if ("pending" === chunk.status || "blocked" === chunk.status) {
+  if ('pending' === chunk.status || 'blocked' === chunk.status) {
     response = chunk.value;
     var rejectListeners = chunk.reason;
-    chunk.status = "resolved_module";
+    chunk.status = 'resolved_module';
     chunk.value = value;
     null !== response &&
       (initializeModuleChunk(chunk),
@@ -868,7 +868,7 @@
   initializingHandler = null;
   var resolvedModel = chunk.value,
     response = chunk.reason;
-  chunk.status = "blocked";
+  chunk.status = 'blocked';
   chunk.value = null;
   chunk.reason = null;
   try {
@@ -881,7 +881,7 @@
         resolvedModel++
       ) {
         var listener = resolveListeners[resolvedModel];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(value)
           : fulfillReference(listener, value, chunk);
       }
@@ -893,10 +893,10 @@
         return;
       }
     }
-    chunk.status = "fulfilled";
+    chunk.status = 'fulfilled';
     chunk.value = value;
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   } finally {
     initializingHandler = prevHandler;
   }
@@ -904,17 +904,17 @@
 function initializeModuleChunk(chunk) {
   try {
     var value = requireModule(chunk.value);
-    chunk.status = "fulfilled";
+    chunk.status = 'fulfilled';
     chunk.value = value;
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   }
 }
 function reportGlobalError(weakResponse, error) {
   weakResponse._closed = !0;
   weakResponse._closedReason = error;
   weakResponse._chunks.forEach(function (chunk) {
-    "pending" === chunk.status &&
+    'pending' === chunk.status &&
       triggerErrorOnChunk(weakResponse, chunk, error);
   });
 }
@@ -926,8 +926,8 @@
     chunk = chunks.get(id);
   chunk ||
     ((chunk = response._closed
-      ? new ReactPromise("rejected", null, response._closedReason)
-      : new ReactPromise("pending", null, null)),
+      ? new ReactPromise('rejected', null, response._closedReason)
+      : new ReactPromise('pending', null, null)),
     chunks.set(id, chunk));
   return chunk;
 }
@@ -945,7 +945,7 @@
   ) {
     for (
       ;
-      "object" === typeof value &&
+      'object' === typeof value &&
       null !== value &&
       value.$$typeof === REACT_LAZY_TYPE;
 
@@ -954,23 +954,23 @@
         value = handler.value;
       else {
         switch (value.status) {
-          case "resolved_model":
+          case 'resolved_model':
             initializeModelChunk(value);
             break;
-          case "resolved_module":
+          case 'resolved_module':
             initializeModuleChunk(value);
         }
         switch (value.status) {
-          case "fulfilled":
+          case 'fulfilled':
             value = value.value;
             continue;
-          case "blocked":
+          case 'blocked':
             var cyclicHandler = resolveBlockedCycle(value, reference);
             if (null !== cyclicHandler) {
               value = cyclicHandler.value;
               continue;
             }
-          case "pending":
+          case 'pending':
             path.splice(0, i - 1);
             null === value.value
               ? (value.value = [reference])
@@ -979,7 +979,7 @@
               ? (value.reason = [reference])
               : value.reason.push(reference);
             return;
-          case "halted":
+          case 'halted':
             return;
           default:
             rejectReference(reference, value.reason);
@@ -990,7 +990,7 @@
   }
   for (
     ;
-    "object" === typeof value &&
+    'object' === typeof value &&
     null !== value &&
     value.$$typeof === REACT_LAZY_TYPE;
 
@@ -999,14 +999,14 @@
       value = handler.value;
     else {
       switch (reference.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(reference);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(reference);
       }
       switch (reference.status) {
-        case "fulfilled":
+        case 'fulfilled':
           value = reference.value;
           continue;
       }
@@ -1014,24 +1014,24 @@
     }
   response = map(response, value, parentObject, key);
   parentObject[key] = response;
-  "" === key && null === handler.value && (handler.value = response);
+  '' === key && null === handler.value && (handler.value = response);
   if (
     parentObject[0] === REACT_ELEMENT_TYPE &&
-    "object" === typeof handler.value &&
+    'object' === typeof handler.value &&
     null !== handler.value &&
     handler.value.$$typeof === REACT_ELEMENT_TYPE
   )
     switch (((parentObject = handler.value), key)) {
-      case "3":
+      case '3':
         parentObject.props = response;
     }
   handler.deps--;
   0 === handler.deps &&
     ((key = handler.chunk),
     null !== key &&
-      "blocked" === key.status &&
+      'blocked' === key.status &&
       ((parentObject = key.value),
-      (key.status = "fulfilled"),
+      (key.status = 'fulfilled'),
       (key.value = handler.value),
       (key.reason = handler.reason),
       null !== parentObject && wakeChunk(parentObject, handler.value)));
@@ -1045,7 +1045,7 @@
     (handler.reason = error),
     (handler = handler.chunk),
     null !== handler &&
-      "blocked" === handler.status &&
+      'blocked' === handler.status &&
       triggerErrorOnChunk(reference, handler, error));
 }
 function waitForReference(
@@ -1054,7 +1054,7 @@
   key,
   response,
   map,
-  path
+  path,
 ) {
   if (initializingHandler) {
     var handler = initializingHandler;
@@ -1066,7 +1066,7 @@
       value: null,
       reason: null,
       deps: 1,
-      errored: !1
+      errored: !1,
     };
   parentObject = {
     response: response,
@@ -1074,7 +1074,7 @@
     parentObject: parentObject,
     key: key,
     map: map,
-    path: path
+    path: path,
   };
   null === referencedChunk.value
     ? (referencedChunk.value = [parentObject])
@@ -1089,11 +1089,11 @@
     return createBoundServerReference(
       metaData,
       response._callServer,
-      response._encodeFormAction
+      response._encodeFormAction,
     );
   var serverReference = resolveServerReference(
       response._serverReferenceConfig,
-      metaData.id
+      metaData.id,
     ),
     promise = preloadModule(serverReference);
   if (promise)
@@ -1106,7 +1106,7 @@
         promise,
         metaData.id,
         metaData.bound,
-        response._encodeFormAction
+        response._encodeFormAction,
       ),
       promise
     );
@@ -1120,7 +1120,7 @@
       value: null,
       reason: null,
       deps: 1,
-      errored: !1
+      errored: !1,
     };
   promise.then(
     function () {
@@ -1134,27 +1134,27 @@
         resolvedValue,
         metaData.id,
         metaData.bound,
-        response._encodeFormAction
+        response._encodeFormAction,
       );
       parentObject[key] = resolvedValue;
-      "" === key && null === handler.value && (handler.value = resolvedValue);
+      '' === key && null === handler.value && (handler.value = resolvedValue);
       if (
         parentObject[0] === REACT_ELEMENT_TYPE &&
-        "object" === typeof handler.value &&
+        'object' === typeof handler.value &&
         null !== handler.value &&
         handler.value.$$typeof === REACT_ELEMENT_TYPE
       )
         switch (((boundArgs = handler.value), key)) {
-          case "3":
+          case '3':
             boundArgs.props = resolvedValue;
         }
       handler.deps--;
       0 === handler.deps &&
         ((resolvedValue = handler.chunk),
         null !== resolvedValue &&
-          "blocked" === resolvedValue.status &&
+          'blocked' === resolvedValue.status &&
           ((boundArgs = resolvedValue.value),
-          (resolvedValue.status = "fulfilled"),
+          (resolvedValue.status = 'fulfilled'),
           (resolvedValue.value = handler.value),
           null !== boundArgs && wakeChunk(boundArgs, handler.value)));
     },
@@ -1165,58 +1165,58 @@
         handler.reason = error;
         var chunk = handler.chunk;
         null !== chunk &&
-          "blocked" === chunk.status &&
+          'blocked' === chunk.status &&
           triggerErrorOnChunk(response, chunk, error);
       }
-    }
+    },
   );
   return null;
 }
 function getOutlinedModel(response, reference, parentObject, key, map) {
-  reference = reference.split(":");
+  reference = reference.split(':');
   var id = parseInt(reference[0], 16);
   id = getChunk(response, id);
   switch (id.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(id);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(id);
   }
   switch (id.status) {
-    case "fulfilled":
+    case 'fulfilled':
       id = id.value;
       for (var i = 1; i < reference.length; i++) {
         for (
           ;
-          "object" === typeof id &&
+          'object' === typeof id &&
           null !== id &&
           id.$$typeof === REACT_LAZY_TYPE;
 
         ) {
           id = id._payload;
           switch (id.status) {
-            case "resolved_model":
+            case 'resolved_model':
               initializeModelChunk(id);
               break;
-            case "resolved_module":
+            case 'resolved_module':
               initializeModuleChunk(id);
           }
           switch (id.status) {
-            case "fulfilled":
+            case 'fulfilled':
               id = id.value;
               break;
-            case "blocked":
-            case "pending":
+            case 'blocked':
+            case 'pending':
               return waitForReference(
                 id,
                 parentObject,
                 key,
                 response,
                 map,
-                reference.slice(i - 1)
+                reference.slice(i - 1),
               );
-            case "halted":
+            case 'halted':
               return (
                 initializingHandler
                   ? ((response = initializingHandler), response.deps++)
@@ -1226,7 +1226,7 @@
                       value: null,
                       reason: null,
                       deps: 1,
-                      errored: !1
+                      errored: !1,
                     }),
                 null
               );
@@ -1242,7 +1242,7 @@
                       value: null,
                       reason: id.reason,
                       deps: 0,
-                      errored: !0
+                      errored: !0,
                     }),
                 null
               );
@@ -1252,31 +1252,31 @@
       }
       for (
         ;
-        "object" === typeof id &&
+        'object' === typeof id &&
         null !== id &&
         id.$$typeof === REACT_LAZY_TYPE;
 
       ) {
         reference = id._payload;
         switch (reference.status) {
-          case "resolved_model":
+          case 'resolved_model':
             initializeModelChunk(reference);
             break;
-          case "resolved_module":
+          case 'resolved_module':
             initializeModuleChunk(reference);
         }
         switch (reference.status) {
-          case "fulfilled":
+          case 'fulfilled':
             id = reference.value;
             continue;
         }
         break;
       }
       return map(response, id, parentObject, key);
-    case "pending":
-    case "blocked":
+    case 'pending':
+    case 'blocked':
       return waitForReference(id, parentObject, key, response, map, reference);
-    case "halted":
+    case 'halted':
       return (
         initializingHandler
           ? ((response = initializingHandler), response.deps++)
@@ -1286,7 +1286,7 @@
               value: null,
               reason: null,
               deps: 1,
-              errored: !1
+              errored: !1,
             }),
         null
       );
@@ -1302,7 +1302,7 @@
               value: null,
               reason: id.reason,
               deps: 0,
-              errored: !0
+              errored: !0,
             }),
         null
       );
@@ -1330,38 +1330,38 @@
   return model;
 }
 function parseModelString(response, parentObject, key, value) {
-  if ("$" === value[0]) {
-    if ("$" === value)
+  if ('$' === value[0]) {
+    if ('$' === value)
       return (
         null !== initializingHandler &&
-          "0" === key &&
+          '0' === key &&
           (initializingHandler = {
             parent: initializingHandler,
             chunk: null,
             value: null,
             reason: null,
             deps: 0,
-            errored: !1
+            errored: !1,
           }),
         REACT_ELEMENT_TYPE
       );
     switch (value[1]) {
-      case "$":
+      case '$':
         return value.slice(1);
-      case "L":
+      case 'L':
         return (
           (parentObject = parseInt(value.slice(2), 16)),
           (response = getChunk(response, parentObject)),
           createLazyChunkWrapper(response)
         );
-      case "@":
+      case '@':
         return (
           (parentObject = parseInt(value.slice(2), 16)),
           getChunk(response, parentObject)
         );
-      case "S":
+      case 'S':
         return Symbol.for(value.slice(2));
-      case "F":
+      case 'F':
         return (
           (value = value.slice(2)),
           getOutlinedModel(
@@ -1369,55 +1369,55 @@
             value,
             parentObject,
             key,
-            loadServerReference
+            loadServerReference,
           )
         );
-      case "T":
-        parentObject = "$" + value.slice(2);
+      case 'T':
+        parentObject = '$' + value.slice(2);
         response = response._tempRefs;
         if (null == response)
           throw Error(
-            "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+            'Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.',
           );
         return response.get(parentObject);
-      case "Q":
+      case 'Q':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createMap)
         );
-      case "W":
+      case 'W':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createSet)
         );
-      case "B":
+      case 'B':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createBlob)
         );
-      case "K":
+      case 'K':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createFormData)
         );
-      case "Z":
+      case 'Z':
         return resolveErrorProd();
-      case "i":
+      case 'i':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, extractIterator)
         );
-      case "I":
+      case 'I':
         return Infinity;
-      case "-":
-        return "$-0" === value ? -0 : -Infinity;
-      case "N":
+      case '-':
+        return '$-0' === value ? -0 : -Infinity;
+      case 'N':
         return NaN;
-      case "u":
+      case 'u':
         return;
-      case "D":
+      case 'D':
         return new Date(Date.parse(value.slice(2)));
-      case "n":
+      case 'n':
         return BigInt(value.slice(2));
       default:
         return (
@@ -1430,7 +1430,7 @@
 }
 function missingCall() {
   throw Error(
-    'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+    'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.',
   );
 }
 function ResponseInstance(
@@ -1440,7 +1440,7 @@
   callServer,
   encodeFormAction,
   nonce,
-  temporaryReferences
+  temporaryReferences,
 ) {
   var chunks = new Map();
   this._bundlerConfig = bundlerConfig;
@@ -1460,9 +1460,9 @@
 function resolveBuffer(response, id, buffer) {
   response = response._chunks;
   var chunk = response.get(id);
-  chunk && "pending" !== chunk.status
+  chunk && 'pending' !== chunk.status
     ? chunk.reason.enqueueValue(buffer)
-    : ((buffer = new ReactPromise("fulfilled", buffer, null)),
+    : ((buffer = new ReactPromise('fulfilled', buffer, null)),
       response.set(id, buffer));
 }
 function resolveModule(response, id, model) {
@@ -1473,14 +1473,14 @@
   prepareDestinationWithChunks(
     response._moduleLoading,
     model[1],
-    response._nonce
+    response._nonce,
   );
   if ((model = preloadModule(clientReference))) {
     if (chunk) {
       var blockedChunk = chunk;
-      blockedChunk.status = "blocked";
+      blockedChunk.status = 'blocked';
     } else
-      (blockedChunk = new ReactPromise("blocked", null, null)),
+      (blockedChunk = new ReactPromise('blocked', null, null)),
         chunks.set(id, blockedChunk);
     model.then(
       function () {
@@ -1488,25 +1488,25 @@
       },
       function (error) {
         return triggerErrorOnChunk(response, blockedChunk, error);
-      }
+      },
     );
   } else
     chunk
       ? resolveModuleChunk(response, chunk, clientReference)
-      : ((chunk = new ReactPromise("resolved_module", clientReference, null)),
+      : ((chunk = new ReactPromise('resolved_module', clientReference, null)),
         chunks.set(id, chunk));
 }
 function resolveStream(response, id, stream, controller) {
   response = response._chunks;
   var chunk = response.get(id);
   chunk
-    ? "pending" === chunk.status &&
+    ? 'pending' === chunk.status &&
       ((id = chunk.value),
-      (chunk.status = "fulfilled"),
+      (chunk.status = 'fulfilled'),
       (chunk.value = stream),
       (chunk.reason = controller),
       null !== id && wakeChunk(id, chunk.value))
-    : ((stream = new ReactPromise("fulfilled", stream, controller)),
+    : ((stream = new ReactPromise('fulfilled', stream, controller)),
       response.set(id, stream));
 }
 function startReadableStream(response, id, type) {
@@ -1515,7 +1515,7 @@
     type: type,
     start: function (c) {
       controller = c;
-    }
+    },
   });
   var previousBlockedChunk = null;
   resolveStream(response, id, type, {
@@ -1528,9 +1528,9 @@
     },
     enqueueModel: function (json) {
       if (null === previousBlockedChunk) {
-        var chunk = new ReactPromise("resolved_model", json, response);
+        var chunk = new ReactPromise('resolved_model', json, response);
         initializeModelChunk(chunk);
-        "fulfilled" === chunk.status
+        'fulfilled' === chunk.status
           ? controller.enqueue(chunk.value)
           : (chunk.then(
               function (v) {
@@ -1538,19 +1538,19 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             ),
             (previousBlockedChunk = chunk));
       } else {
         chunk = previousBlockedChunk;
-        var chunk$54 = new ReactPromise("pending", null, null);
+        var chunk$54 = new ReactPromise('pending', null, null);
         chunk$54.then(
           function (v) {
             return controller.enqueue(v);
           },
           function (e) {
             return controller.error(e);
-          }
+          },
         );
         previousBlockedChunk = chunk$54;
         chunk.then(function () {
@@ -1578,7 +1578,7 @@
           return controller.error(error);
         });
       }
-    }
+    },
   });
 }
 function asyncIterator() {
@@ -1599,16 +1599,16 @@
     return createIterator(function (arg) {
       if (void 0 !== arg)
         throw Error(
-          "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+          'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
         );
       if (nextReadIndex === buffer.length) {
         if (closed)
           return new ReactPromise(
-            "fulfilled",
+            'fulfilled',
             { done: !0, value: void 0 },
-            null
+            null,
           );
-        buffer[nextReadIndex] = new ReactPromise("pending", null, null);
+        buffer[nextReadIndex] = new ReactPromise('pending', null, null);
       }
       return buffer[nextReadIndex++];
     });
@@ -1621,15 +1621,15 @@
       enqueueValue: function (value) {
         if (nextWriteIndex === buffer.length)
           buffer[nextWriteIndex] = new ReactPromise(
-            "fulfilled",
+            'fulfilled',
             { done: !1, value: value },
-            null
+            null,
           );
         else {
           var chunk = buffer[nextWriteIndex],
             resolveListeners = chunk.value,
             rejectListeners = chunk.reason;
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = { done: !1, value: value };
           null !== resolveListeners &&
             wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
@@ -1641,13 +1641,13 @@
           ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
               response,
               value,
-              !1
+              !1,
             ))
           : resolveIteratorResultChunk(
               response,
               buffer[nextWriteIndex],
               value,
-              !1
+              !1,
             );
         nextWriteIndex++;
       },
@@ -1657,40 +1657,40 @@
           ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
               response,
               value,
-              !0
+              !0,
             ))
           : resolveIteratorResultChunk(
               response,
               buffer[nextWriteIndex],
               value,
-              !0
+              !0,
             );
         for (nextWriteIndex++; nextWriteIndex < buffer.length; )
           resolveIteratorResultChunk(
             response,
             buffer[nextWriteIndex++],
             '"$undefined"',
-            !0
+            !0,
           );
       },
       error: function (error) {
         closed = !0;
         for (
           nextWriteIndex === buffer.length &&
-          (buffer[nextWriteIndex] = new ReactPromise("pending", null, null));
+          (buffer[nextWriteIndex] = new ReactPromise('pending', null, null));
           nextWriteIndex < buffer.length;
 
         )
           triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);
-      }
-    }
+      },
+    },
   );
 }
 function resolveErrorProd() {
   var error = Error(
-    "An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error."
+    'An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.',
   );
-  error.stack = "Error: " + error.message;
+  error.stack = 'Error: ' + error.message;
   return error;
 }
 function mergeBuffer(buffer, lastChunk) {
@@ -1711,7 +1711,7 @@
   buffer,
   lastChunk,
   constructor,
-  bytesPerElement
+  bytesPerElement,
 ) {
   buffer =
     0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
@@ -1720,7 +1720,7 @@
   constructor = new constructor(
     buffer.buffer,
     buffer.byteOffset,
-    buffer.byteLength / bytesPerElement
+    buffer.byteLength / bytesPerElement,
   );
   resolveBuffer(response, id, constructor);
 }
@@ -1736,7 +1736,7 @@
       resolveBuffer(
         response,
         id,
-        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)
+        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk),
       );
       return;
     case 85:
@@ -1771,7 +1771,7 @@
       return;
   }
   streamState = response._stringDecoder;
-  for (var row = "", i = 0; i < buffer.length; i++)
+  for (var row = '', i = 0; i < buffer.length; i++)
     row += streamState.decode(buffer[i], decoderOptions);
   buffer = row += streamState.decode(chunk);
   switch (tag) {
@@ -1784,42 +1784,42 @@
       response = JSON.parse(buffer, response._fromJSON);
       buffer = ReactDOMSharedInternals.d;
       switch (id) {
-        case "D":
+        case 'D':
           buffer.D(response);
           break;
-        case "C":
-          "string" === typeof response
+        case 'C':
+          'string' === typeof response
             ? buffer.C(response)
             : buffer.C(response[0], response[1]);
           break;
-        case "L":
+        case 'L':
           id = response[0];
           tag = response[1];
           3 === response.length
             ? buffer.L(id, tag, response[2])
             : buffer.L(id, tag);
           break;
-        case "m":
-          "string" === typeof response
+        case 'm':
+          'string' === typeof response
             ? buffer.m(response)
             : buffer.m(response[0], response[1]);
           break;
-        case "X":
-          "string" === typeof response
+        case 'X':
+          'string' === typeof response
             ? buffer.X(response)
             : buffer.X(response[0], response[1]);
           break;
-        case "S":
-          "string" === typeof response
+        case 'S':
+          'string' === typeof response
             ? buffer.S(response)
             : buffer.S(
                 response[0],
                 0 === response[1] ? void 0 : response[1],
-                3 === response.length ? response[2] : void 0
+                3 === response.length ? response[2] : void 0,
               );
           break;
-        case "M":
-          "string" === typeof response
+        case 'M':
+          'string' === typeof response
             ? buffer.M(response)
             : buffer.M(response[0], response[1]);
       }
@@ -1832,14 +1832,14 @@
       streamState.digest = buffer.digest;
       chunk
         ? triggerErrorOnChunk(response, chunk, streamState)
-        : ((response = new ReactPromise("rejected", null, streamState)),
+        : ((response = new ReactPromise('rejected', null, streamState)),
           tag.set(id, response));
       break;
     case 84:
       response = response._chunks;
-      (tag = response.get(id)) && "pending" !== tag.status
+      (tag = response.get(id)) && 'pending' !== tag.status
         ? tag.reason.enqueueValue(buffer)
-        : ((buffer = new ReactPromise("fulfilled", buffer, null)),
+        : ((buffer = new ReactPromise('fulfilled', buffer, null)),
           response.set(id, buffer));
       break;
     case 78:
@@ -1847,13 +1847,13 @@
     case 74:
     case 87:
       throw Error(
-        "Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client."
+        'Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client.',
       );
     case 82:
       startReadableStream(response, id, void 0);
       break;
     case 114:
-      startReadableStream(response, id, "bytes");
+      startReadableStream(response, id, 'bytes');
       break;
     case 88:
       startAsyncIterable(response, id, !1);
@@ -1863,22 +1863,22 @@
       break;
     case 67:
       (id = response._chunks.get(id)) &&
-        "fulfilled" === id.status &&
-        id.reason.close("" === buffer ? '"$undefined"' : buffer);
+        'fulfilled' === id.status &&
+        id.reason.close('' === buffer ? '"$undefined"' : buffer);
       break;
     default:
       (tag = response._chunks),
         (chunk = tag.get(id))
           ? resolveModelChunk(response, chunk, buffer)
-          : ((response = new ReactPromise("resolved_model", buffer, response)),
+          : ((response = new ReactPromise('resolved_model', buffer, response)),
             tag.set(id, response));
   }
 }
 function createFromJSONCallback(response) {
   return function (key, value) {
-    if ("string" === typeof value)
+    if ('string' === typeof value)
       return parseModelString(response, this, key, value);
-    if ("object" === typeof value && null !== value) {
+    if ('object' === typeof value && null !== value) {
       if (value[0] === REACT_ELEMENT_TYPE) {
         if (
           ((key = {
@@ -1886,7 +1886,7 @@
             type: value[1],
             key: value[2],
             ref: null,
-            props: value[3]
+            props: value[3],
           }),
           null !== initializingHandler)
         )
@@ -1895,10 +1895,10 @@
             (initializingHandler = value.parent),
             value.errored)
           )
-            (key = new ReactPromise("rejected", null, value.reason)),
+            (key = new ReactPromise('rejected', null, value.reason)),
               (key = createLazyChunkWrapper(key));
           else if (0 < value.deps) {
-            var blockedChunk = new ReactPromise("blocked", null, null);
+            var blockedChunk = new ReactPromise('blocked', null, null);
             value.value = key;
             value.chunk = blockedChunk;
             key = createLazyChunkWrapper(blockedChunk);
@@ -1910,11 +1910,11 @@
   };
 }
 function close(weakResponse) {
-  reportGlobalError(weakResponse, Error("Connection closed."));
+  reportGlobalError(weakResponse, Error('Connection closed.'));
 }
 function noServerCall() {
   throw Error(
-    "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+    'Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.',
   );
 }
 function createResponseFromOptions(options) {
@@ -1924,10 +1924,10 @@
     options.serverConsumerManifest.moduleLoading,
     noServerCall,
     options.encodeFormAction,
-    "string" === typeof options.nonce ? options.nonce : void 0,
+    'string' === typeof options.nonce ? options.nonce : void 0,
     options && options.temporaryReferences
       ? options.temporaryReferences
-      : void 0
+      : void 0,
   );
 }
 function startReadingFromStream(response, stream, onDone) {
@@ -2001,7 +2001,7 @@
             _ref,
             rowTag,
             buffer,
-            rowLength
+            rowLength,
           ),
           (i = lastIdx),
           3 === rowState && i++,
@@ -2028,7 +2028,7 @@
       _rowID: 0,
       _rowTag: 0,
       _rowLength: 0,
-      _buffer: []
+      _buffer: [],
     },
     reader = stream.getReader();
   reader.read().then(progress).catch(error);
@@ -2041,7 +2041,7 @@
     },
     function (e) {
       reportGlobalError(response, e);
-    }
+    },
   );
   return getChunk(response, 0);
 };
@@ -2060,12 +2060,12 @@
   return new Promise(function (resolve, reject) {
     var abort = processReply(
       value,
-      "",
+      '',
       options && options.temporaryReferences
         ? options.temporaryReferences
         : void 0,
       resolve,
-      reject
+      reject,
     );
     if (options && options.signal) {
       var signal = options.signal;
@@ -2073,9 +2073,9 @@
       else {
         var listener = function () {
           abort(signal.reason);
-          signal.removeEventListener("abort", listener);
+          signal.removeEventListener('abort', listener);
         };
-        signal.addEventListener("abort", listener);
+        signal.addEventListener('abort', listener);
       }
     }
   });
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.node.development.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.development.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.node.development.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.development.js	2025-12-17 14:32:44
@@ -8,8 +8,8 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
+'use strict';
+'production' !== process.env.NODE_ENV &&
   (function () {
     function resolveClientReference(bundlerConfig, metadata) {
       if (bundlerConfig) {
@@ -17,12 +17,12 @@
         if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))
           moduleExports = bundlerConfig.name;
         else {
-          bundlerConfig = moduleExports && moduleExports["*"];
+          bundlerConfig = moduleExports && moduleExports['*'];
           if (!bundlerConfig)
             throw Error(
               'Could not find the module "' +
                 metadata[0] +
-                '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'
+                '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.',
             );
           moduleExports = metadata[2];
         }
@@ -33,11 +33,11 @@
       return metadata;
     }
     function resolveServerReference(bundlerConfig, id) {
-      var name = "",
+      var name = '',
         resolvedModuleData = bundlerConfig[id];
       if (resolvedModuleData) name = resolvedModuleData.name;
       else {
-        var idx = id.lastIndexOf("#");
+        var idx = id.lastIndexOf('#');
         -1 !== idx &&
           ((name = id.slice(idx + 1)),
           (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -45,7 +45,7 @@
           throw Error(
             'Could not find the module "' +
               id +
-              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
           );
       }
       return resolvedModuleData.async
@@ -54,17 +54,17 @@
     }
     function requireAsyncModule(id) {
       var promise = __webpack_require__(id);
-      if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+      if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
         return null;
       promise.then(
         function (value) {
-          promise.status = "fulfilled";
+          promise.status = 'fulfilled';
           promise.value = value;
         },
         function (reason) {
-          promise.status = "rejected";
+          promise.status = 'rejected';
           promise.reason = reason;
-        }
+        },
       );
       return promise;
     }
@@ -98,13 +98,13 @@
     }
     function requireModule(metadata) {
       var moduleExports = __webpack_require__(metadata[0]);
-      if (4 === metadata.length && "function" === typeof moduleExports.then)
-        if ("fulfilled" === moduleExports.status)
+      if (4 === metadata.length && 'function' === typeof moduleExports.then)
+        if ('fulfilled' === moduleExports.status)
           moduleExports = moduleExports.value;
         else throw moduleExports.reason;
-      return "*" === metadata[2]
+      return '*' === metadata[2]
         ? moduleExports
-        : "" === metadata[2]
+        : '' === metadata[2]
           ? moduleExports.__esModule
             ? moduleExports.default
             : moduleExports
@@ -113,7 +113,7 @@
     function prepareDestinationWithChunks(
       moduleLoading,
       chunks,
-      nonce$jscomp$0
+      nonce$jscomp$0,
     ) {
       if (null !== moduleLoading)
         for (var i = 1; i < chunks.length; i += 2) {
@@ -123,25 +123,25 @@
             JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];
           var JSCompiler_inline_result = moduleLoading.crossOrigin;
           JSCompiler_inline_result =
-            "string" === typeof JSCompiler_inline_result
-              ? "use-credentials" === JSCompiler_inline_result
+            'string' === typeof JSCompiler_inline_result
+              ? 'use-credentials' === JSCompiler_inline_result
                 ? JSCompiler_inline_result
-                : ""
+                : ''
               : void 0;
           JSCompiler_temp_const$jscomp$0.call(
             JSCompiler_temp_const,
             JSCompiler_temp_const$jscomp$1,
-            { crossOrigin: JSCompiler_inline_result, nonce: nonce }
+            { crossOrigin: JSCompiler_inline_result, nonce: nonce },
           );
         }
     }
     function getIteratorFn(maybeIterable) {
-      if (null === maybeIterable || "object" !== typeof maybeIterable)
+      if (null === maybeIterable || 'object' !== typeof maybeIterable)
         return null;
       maybeIterable =
         (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-        maybeIterable["@@iterator"];
-      return "function" === typeof maybeIterable ? maybeIterable : null;
+        maybeIterable['@@iterator'];
+      return 'function' === typeof maybeIterable ? maybeIterable : null;
     }
     function isObjectPrototype(object) {
       if (!object) return !1;
@@ -164,8 +164,8 @@
         if (
           !descriptor ||
           (!descriptor.enumerable &&
-            (("key" !== names[i] && "ref" !== names[i]) ||
-              "function" !== typeof descriptor.get))
+            (('key' !== names[i] && 'ref' !== names[i]) ||
+              'function' !== typeof descriptor.get))
         )
           return !1;
       }
@@ -181,35 +181,35 @@
     }
     function describeValueForErrorMessage(value) {
       switch (typeof value) {
-        case "string":
+        case 'string':
           return JSON.stringify(
-            10 >= value.length ? value : value.slice(0, 10) + "..."
+            10 >= value.length ? value : value.slice(0, 10) + '...',
           );
-        case "object":
-          if (isArrayImpl(value)) return "[...]";
+        case 'object':
+          if (isArrayImpl(value)) return '[...]';
           if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-            return "client";
+            return 'client';
           value = objectName(value);
-          return "Object" === value ? "{...}" : value;
-        case "function":
+          return 'Object' === value ? '{...}' : value;
+        case 'function':
           return value.$$typeof === CLIENT_REFERENCE_TAG
-            ? "client"
+            ? 'client'
             : (value = value.displayName || value.name)
-              ? "function " + value
-              : "function";
+              ? 'function ' + value
+              : 'function';
         default:
           return String(value);
       }
     }
     function describeElementType(type) {
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (type.$$typeof) {
           case REACT_FORWARD_REF_TYPE:
             return describeElementType(type.render);
@@ -222,74 +222,74 @@
               return describeElementType(type(payload));
             } catch (x) {}
         }
-      return "";
+      return '';
     }
     function describeObjectForErrorMessage(objectOrArray, expandedName) {
       var objKind = objectName(objectOrArray);
-      if ("Object" !== objKind && "Array" !== objKind) return objKind;
+      if ('Object' !== objKind && 'Array' !== objKind) return objKind;
       var start = -1,
         length = 0;
       if (isArrayImpl(objectOrArray))
         if (jsxChildrenParents.has(objectOrArray)) {
           var type = jsxChildrenParents.get(objectOrArray);
-          objKind = "<" + describeElementType(type) + ">";
+          objKind = '<' + describeElementType(type) + '>';
           for (var i = 0; i < objectOrArray.length; i++) {
             var value = objectOrArray[i];
             value =
-              "string" === typeof value
+              'string' === typeof value
                 ? value
-                : "object" === typeof value && null !== value
-                  ? "{" + describeObjectForErrorMessage(value) + "}"
-                  : "{" + describeValueForErrorMessage(value) + "}";
-            "" + i === expandedName
+                : 'object' === typeof value && null !== value
+                  ? '{' + describeObjectForErrorMessage(value) + '}'
+                  : '{' + describeValueForErrorMessage(value) + '}';
+            '' + i === expandedName
               ? ((start = objKind.length),
                 (length = value.length),
                 (objKind += value))
               : (objKind =
                   15 > value.length && 40 > objKind.length + value.length
                     ? objKind + value
-                    : objKind + "{...}");
+                    : objKind + '{...}');
           }
-          objKind += "</" + describeElementType(type) + ">";
+          objKind += '</' + describeElementType(type) + '>';
         } else {
-          objKind = "[";
+          objKind = '[';
           for (type = 0; type < objectOrArray.length; type++)
-            0 < type && (objKind += ", "),
+            0 < type && (objKind += ', '),
               (i = objectOrArray[type]),
               (i =
-                "object" === typeof i && null !== i
+                'object' === typeof i && null !== i
                   ? describeObjectForErrorMessage(i)
                   : describeValueForErrorMessage(i)),
-              "" + type === expandedName
+              '' + type === expandedName
                 ? ((start = objKind.length),
                   (length = i.length),
                   (objKind += i))
                 : (objKind =
                     10 > i.length && 40 > objKind.length + i.length
                       ? objKind + i
-                      : objKind + "...");
-          objKind += "]";
+                      : objKind + '...');
+          objKind += ']';
         }
       else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-        objKind = "<" + describeElementType(objectOrArray.type) + "/>";
+        objKind = '<' + describeElementType(objectOrArray.type) + '/>';
       else {
-        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
         if (jsxPropsParents.has(objectOrArray)) {
           objKind = jsxPropsParents.get(objectOrArray);
-          objKind = "<" + (describeElementType(objKind) || "...");
+          objKind = '<' + (describeElementType(objKind) || '...');
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++) {
-            objKind += " ";
+            objKind += ' ';
             value = type[i];
-            objKind += describeKeyForErrorMessage(value) + "=";
+            objKind += describeKeyForErrorMessage(value) + '=';
             var _value2 = objectOrArray[value];
             var _substr2 =
               value === expandedName &&
-              "object" === typeof _value2 &&
+              'object' === typeof _value2 &&
               null !== _value2
                 ? describeObjectForErrorMessage(_value2)
                 : describeValueForErrorMessage(_value2);
-            "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
+            'string' !== typeof _value2 && (_substr2 = '{' + _substr2 + '}');
             value === expandedName
               ? ((start = objKind.length),
                 (length = _substr2.length),
@@ -297,19 +297,19 @@
               : (objKind =
                   10 > _substr2.length && 40 > objKind.length + _substr2.length
                     ? objKind + _substr2
-                    : objKind + "...");
+                    : objKind + '...');
           }
-          objKind += ">";
+          objKind += '>';
         } else {
-          objKind = "{";
+          objKind = '{';
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++)
-            0 < i && (objKind += ", "),
+            0 < i && (objKind += ', '),
               (value = type[i]),
-              (objKind += describeKeyForErrorMessage(value) + ": "),
+              (objKind += describeKeyForErrorMessage(value) + ': '),
               (_value2 = objectOrArray[value]),
               (_value2 =
-                "object" === typeof _value2 && null !== _value2
+                'object' === typeof _value2 && null !== _value2
                   ? describeObjectForErrorMessage(_value2)
                   : describeValueForErrorMessage(_value2)),
               value === expandedName
@@ -319,47 +319,47 @@
                 : (objKind =
                     10 > _value2.length && 40 > objKind.length + _value2.length
                       ? objKind + _value2
-                      : objKind + "...");
-          objKind += "}";
+                      : objKind + '...');
+          objKind += '}';
         }
       }
       return void 0 === expandedName
         ? objKind
         : -1 < start && 0 < length
-          ? ((objectOrArray = " ".repeat(start) + "^".repeat(length)),
-            "\n  " + objKind + "\n  " + objectOrArray)
-          : "\n  " + objKind;
+          ? ((objectOrArray = ' '.repeat(start) + '^'.repeat(length)),
+            '\n  ' + objKind + '\n  ' + objectOrArray)
+          : '\n  ' + objKind;
     }
     function serializeNumber(number) {
       return Number.isFinite(number)
         ? 0 === number && -Infinity === 1 / number
-          ? "$-0"
+          ? '$-0'
           : number
         : Infinity === number
-          ? "$Infinity"
+          ? '$Infinity'
           : -Infinity === number
-            ? "$-Infinity"
-            : "$NaN";
+            ? '$-Infinity'
+            : '$NaN';
     }
     function processReply(
       root,
       formFieldPrefix,
       temporaryReferences,
       resolve,
-      reject
+      reject,
     ) {
       function serializeTypedArray(tag, typedArray) {
         typedArray = new Blob([
           new Uint8Array(
             typedArray.buffer,
             typedArray.byteOffset,
-            typedArray.byteLength
-          )
+            typedArray.byteLength,
+          ),
         ]);
         var blobId = nextPartId++;
         null === formData && (formData = new FormData());
         formData.append(formFieldPrefix + blobId, typedArray);
-        return "$" + tag + blobId.toString(16);
+        return '$' + tag + blobId.toString(16);
       }
       function serializeBinaryReader(reader) {
         function progress(entry) {
@@ -368,9 +368,9 @@
               data.append(formFieldPrefix + entry, new Blob(buffer)),
               data.append(
                 formFieldPrefix + streamId,
-                '"$o' + entry.toString(16) + '"'
+                '"$o' + entry.toString(16) + '"',
               ),
-              data.append(formFieldPrefix + streamId, "C"),
+              data.append(formFieldPrefix + streamId, 'C'),
               pendingParts--,
               0 === pendingParts && resolve(data))
             : (buffer.push(entry.value),
@@ -382,12 +382,12 @@
         var streamId = nextPartId++,
           buffer = [];
         reader.read(new Uint8Array(1024)).then(progress, reject);
-        return "$r" + streamId.toString(16);
+        return '$r' + streamId.toString(16);
       }
       function serializeReader(reader) {
         function progress(entry) {
           if (entry.done)
-            data.append(formFieldPrefix + streamId, "C"),
+            data.append(formFieldPrefix + streamId, 'C'),
               pendingParts--,
               0 === pendingParts && resolve(data);
           else
@@ -404,11 +404,11 @@
         pendingParts++;
         var streamId = nextPartId++;
         reader.read().then(progress, reject);
-        return "$R" + streamId.toString(16);
+        return '$R' + streamId.toString(16);
       }
       function serializeReadableStream(stream) {
         try {
-          var binaryReader = stream.getReader({ mode: "byob" });
+          var binaryReader = stream.getReader({ mode: 'byob' });
         } catch (x) {
           return serializeReader(stream.getReader());
         }
@@ -418,11 +418,11 @@
         function progress(entry) {
           if (entry.done) {
             if (void 0 === entry.value)
-              data.append(formFieldPrefix + streamId, "C");
+              data.append(formFieldPrefix + streamId, 'C');
             else
               try {
                 var partJSON = JSON.stringify(entry.value, resolveToJSON);
-                data.append(formFieldPrefix + streamId, "C" + partJSON);
+                data.append(formFieldPrefix + streamId, 'C' + partJSON);
               } catch (x) {
                 reject(x);
                 return;
@@ -444,38 +444,38 @@
         var streamId = nextPartId++;
         iterable = iterable === iterator;
         iterator.next().then(progress, reject);
-        return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+        return '$' + (iterable ? 'x' : 'X') + streamId.toString(16);
       }
       function resolveToJSON(key, value) {
         var originalValue = this[key];
-        "object" !== typeof originalValue ||
+        'object' !== typeof originalValue ||
           originalValue === value ||
           originalValue instanceof Date ||
-          ("Object" !== objectName(originalValue)
+          ('Object' !== objectName(originalValue)
             ? console.error(
-                "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                'Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s',
                 objectName(originalValue),
-                describeObjectForErrorMessage(this, key)
+                describeObjectForErrorMessage(this, key),
               )
             : console.error(
-                "Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s",
-                describeObjectForErrorMessage(this, key)
+                'Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s',
+                describeObjectForErrorMessage(this, key),
               ));
         if (null === value) return null;
-        if ("object" === typeof value) {
+        if ('object' === typeof value) {
           switch (value.$$typeof) {
             case REACT_ELEMENT_TYPE:
-              if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+              if (void 0 !== temporaryReferences && -1 === key.indexOf(':')) {
                 var parentReference = writtenObjects.get(this);
                 if (void 0 !== parentReference)
                   return (
-                    temporaryReferences.set(parentReference + ":" + key, value),
-                    "$T"
+                    temporaryReferences.set(parentReference + ':' + key, value),
+                    '$T'
                   );
               }
               throw Error(
-                "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
-                  describeObjectForErrorMessage(this, key)
+                'React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.' +
+                  describeObjectForErrorMessage(this, key),
               );
             case REACT_LAZY_TYPE:
               originalValue = value._payload;
@@ -487,12 +487,12 @@
                 var lazyId = nextPartId++,
                   partJSON = serializeModel(parentReference, lazyId);
                 formData.append(formFieldPrefix + lazyId, partJSON);
-                return "$" + lazyId.toString(16);
+                return '$' + lazyId.toString(16);
               } catch (x) {
                 if (
-                  "object" === typeof x &&
+                  'object' === typeof x &&
                   null !== x &&
-                  "function" === typeof x.then
+                  'function' === typeof x.then
                 ) {
                   pendingParts++;
                   var _lazyId = nextPartId++;
@@ -508,7 +508,7 @@
                     }
                   };
                   x.then(parentReference, parentReference);
-                  return "$" + _lazyId.toString(16);
+                  return '$' + _lazyId.toString(16);
                 }
                 reject(x);
                 return null;
@@ -516,7 +516,7 @@
                 pendingParts--;
               }
           }
-          if ("function" === typeof value.then) {
+          if ('function' === typeof value.then) {
             null === formData && (formData = new FormData());
             pendingParts++;
             var promiseId = nextPartId++;
@@ -531,17 +531,17 @@
                 reject(reason);
               }
             }, reject);
-            return "$@" + promiseId.toString(16);
+            return '$@' + promiseId.toString(16);
           }
           parentReference = writtenObjects.get(value);
           if (void 0 !== parentReference)
             if (modelRoot === value) modelRoot = null;
             else return parentReference;
           else
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
               ((parentReference = writtenObjects.get(this)),
               void 0 !== parentReference &&
-                ((parentReference = parentReference + ":" + key),
+                ((parentReference = parentReference + ':' + key),
                 writtenObjects.set(value, parentReference),
                 void 0 !== temporaryReferences &&
                   temporaryReferences.set(parentReference, value)));
@@ -550,11 +550,11 @@
             null === formData && (formData = new FormData());
             var _data3 = formData;
             key = nextPartId++;
-            var prefix = formFieldPrefix + key + "_";
+            var prefix = formFieldPrefix + key + '_';
             value.forEach(function (originalValue, originalKey) {
               _data3.append(prefix + originalKey, originalValue);
             });
-            return "$K" + key.toString(16);
+            return '$K' + key.toString(16);
           }
           if (value instanceof Map)
             return (
@@ -562,7 +562,7 @@
               (parentReference = serializeModel(Array.from(value), key)),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$Q" + key.toString(16)
+              '$Q' + key.toString(16)
             );
           if (value instanceof Set)
             return (
@@ -570,7 +570,7 @@
               (parentReference = serializeModel(Array.from(value), key)),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$W" + key.toString(16)
+              '$W' + key.toString(16)
             );
           if (value instanceof ArrayBuffer)
             return (
@@ -578,37 +578,37 @@
               (parentReference = nextPartId++),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + parentReference, key),
-              "$A" + parentReference.toString(16)
+              '$A' + parentReference.toString(16)
             );
           if (value instanceof Int8Array)
-            return serializeTypedArray("O", value);
+            return serializeTypedArray('O', value);
           if (value instanceof Uint8Array)
-            return serializeTypedArray("o", value);
+            return serializeTypedArray('o', value);
           if (value instanceof Uint8ClampedArray)
-            return serializeTypedArray("U", value);
+            return serializeTypedArray('U', value);
           if (value instanceof Int16Array)
-            return serializeTypedArray("S", value);
+            return serializeTypedArray('S', value);
           if (value instanceof Uint16Array)
-            return serializeTypedArray("s", value);
+            return serializeTypedArray('s', value);
           if (value instanceof Int32Array)
-            return serializeTypedArray("L", value);
+            return serializeTypedArray('L', value);
           if (value instanceof Uint32Array)
-            return serializeTypedArray("l", value);
+            return serializeTypedArray('l', value);
           if (value instanceof Float32Array)
-            return serializeTypedArray("G", value);
+            return serializeTypedArray('G', value);
           if (value instanceof Float64Array)
-            return serializeTypedArray("g", value);
+            return serializeTypedArray('g', value);
           if (value instanceof BigInt64Array)
-            return serializeTypedArray("M", value);
+            return serializeTypedArray('M', value);
           if (value instanceof BigUint64Array)
-            return serializeTypedArray("m", value);
-          if (value instanceof DataView) return serializeTypedArray("V", value);
-          if ("function" === typeof Blob && value instanceof Blob)
+            return serializeTypedArray('m', value);
+          if (value instanceof DataView) return serializeTypedArray('V', value);
+          if ('function' === typeof Blob && value instanceof Blob)
             return (
               null === formData && (formData = new FormData()),
               (key = nextPartId++),
               formData.append(formFieldPrefix + key, value),
-              "$B" + key.toString(16)
+              '$B' + key.toString(16)
             );
           if ((parentReference = getIteratorFn(value)))
             return (
@@ -617,20 +617,20 @@
                 ? ((key = nextPartId++),
                   (parentReference = serializeModel(
                     Array.from(parentReference),
-                    key
+                    key,
                   )),
                   null === formData && (formData = new FormData()),
                   formData.append(formFieldPrefix + key, parentReference),
-                  "$i" + key.toString(16))
+                  '$i' + key.toString(16))
                 : Array.from(parentReference)
             );
           if (
-            "function" === typeof ReadableStream &&
+            'function' === typeof ReadableStream &&
             value instanceof ReadableStream
           )
             return serializeReadableStream(value);
           parentReference = value[ASYNC_ITERATOR];
-          if ("function" === typeof parentReference)
+          if ('function' === typeof parentReference)
             return serializeAsyncIterable(value, parentReference.call(value));
           parentReference = getPrototypeOf(value);
           if (
@@ -640,98 +640,98 @@
           ) {
             if (void 0 === temporaryReferences)
               throw Error(
-                "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported." +
-                  describeObjectForErrorMessage(this, key)
+                'Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.' +
+                  describeObjectForErrorMessage(this, key),
               );
-            return "$T";
+            return '$T';
           }
           value.$$typeof === REACT_CONTEXT_TYPE
             ? console.error(
-                "React Context Providers cannot be passed to Server Functions from the Client.%s",
-                describeObjectForErrorMessage(this, key)
+                'React Context Providers cannot be passed to Server Functions from the Client.%s',
+                describeObjectForErrorMessage(this, key),
               )
-            : "Object" !== objectName(value)
+            : 'Object' !== objectName(value)
               ? console.error(
-                  "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                  'Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s',
                   objectName(value),
-                  describeObjectForErrorMessage(this, key)
+                  describeObjectForErrorMessage(this, key),
                 )
               : isSimpleObject(value)
                 ? Object.getOwnPropertySymbols &&
                   ((parentReference = Object.getOwnPropertySymbols(value)),
                   0 < parentReference.length &&
                     console.error(
-                      "Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s",
+                      'Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s',
                       parentReference[0].description,
-                      describeObjectForErrorMessage(this, key)
+                      describeObjectForErrorMessage(this, key),
                     ))
                 : console.error(
-                    "Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s",
-                    describeObjectForErrorMessage(this, key)
+                    'Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s',
+                    describeObjectForErrorMessage(this, key),
                   );
           return value;
         }
-        if ("string" === typeof value) {
-          if ("Z" === value[value.length - 1] && this[key] instanceof Date)
-            return "$D" + value;
-          key = "$" === value[0] ? "$" + value : value;
+        if ('string' === typeof value) {
+          if ('Z' === value[value.length - 1] && this[key] instanceof Date)
+            return '$D' + value;
+          key = '$' === value[0] ? '$' + value : value;
           return key;
         }
-        if ("boolean" === typeof value) return value;
-        if ("number" === typeof value) return serializeNumber(value);
-        if ("undefined" === typeof value) return "$undefined";
-        if ("function" === typeof value) {
+        if ('boolean' === typeof value) return value;
+        if ('number' === typeof value) return serializeNumber(value);
+        if ('undefined' === typeof value) return '$undefined';
+        if ('function' === typeof value) {
           parentReference = knownServerReferences.get(value);
           if (void 0 !== parentReference)
             return (
               (key = JSON.stringify(
                 { id: parentReference.id, bound: parentReference.bound },
-                resolveToJSON
+                resolveToJSON,
               )),
               null === formData && (formData = new FormData()),
               (parentReference = nextPartId++),
               formData.set(formFieldPrefix + parentReference, key),
-              "$F" + parentReference.toString(16)
+              '$F' + parentReference.toString(16)
             );
           if (
             void 0 !== temporaryReferences &&
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
             ((parentReference = writtenObjects.get(this)),
             void 0 !== parentReference)
           )
             return (
-              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+              temporaryReferences.set(parentReference + ':' + key, value), '$T'
             );
           throw Error(
-            "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+            'Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.',
           );
         }
-        if ("symbol" === typeof value) {
+        if ('symbol' === typeof value) {
           if (
             void 0 !== temporaryReferences &&
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
             ((parentReference = writtenObjects.get(this)),
             void 0 !== parentReference)
           )
             return (
-              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+              temporaryReferences.set(parentReference + ':' + key, value), '$T'
             );
           throw Error(
-            "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
-              describeObjectForErrorMessage(this, key)
+            'Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.' +
+              describeObjectForErrorMessage(this, key),
           );
         }
-        if ("bigint" === typeof value) return "$n" + value.toString(10);
+        if ('bigint' === typeof value) return '$n' + value.toString(10);
         throw Error(
-          "Type " +
+          'Type ' +
             typeof value +
-            " is not supported as an argument to a Server Function."
+            ' is not supported as an argument to a Server Function.',
         );
       }
       function serializeModel(model, id) {
-        "object" === typeof model &&
+        'object' === typeof model &&
           null !== model &&
-          ((id = "$" + id.toString(16)),
+          ((id = '$' + id.toString(16)),
           writtenObjects.set(model, id),
           void 0 !== temporaryReferences && temporaryReferences.set(id, model));
         modelRoot = model;
@@ -745,7 +745,7 @@
         json = serializeModel(root, 0);
       null === formData
         ? resolve(json)
-        : (formData.set(formFieldPrefix + "0", json),
+        : (formData.set(formFieldPrefix + '0', json),
           0 === pendingParts && resolve(formData));
       return function () {
         0 < pendingParts &&
@@ -762,23 +762,23 @@
         });
       processReply(
         reference,
-        "",
+        '',
         void 0,
         function (body) {
-          if ("string" === typeof body) {
+          if ('string' === typeof body) {
             var data = new FormData();
-            data.append("0", body);
+            data.append('0', body);
             body = data;
           }
-          thenable.status = "fulfilled";
+          thenable.status = 'fulfilled';
           thenable.value = body;
           resolve(body);
         },
         function (e) {
-          thenable.status = "rejected";
+          thenable.status = 'rejected';
           thenable.reason = e;
           reject(e);
-        }
+        },
       );
       return thenable;
     }
@@ -786,7 +786,7 @@
       var referenceClosure = knownServerReferences.get(this);
       if (!referenceClosure)
         throw Error(
-          "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+          'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
         );
       var data = null;
       if (null !== referenceClosure.bound) {
@@ -794,55 +794,55 @@
         data ||
           ((data = encodeFormData({
             id: referenceClosure.id,
-            bound: referenceClosure.bound
+            bound: referenceClosure.bound,
           })),
           boundCache.set(referenceClosure, data));
-        if ("rejected" === data.status) throw data.reason;
-        if ("fulfilled" !== data.status) throw data;
+        if ('rejected' === data.status) throw data.reason;
+        if ('fulfilled' !== data.status) throw data;
         referenceClosure = data.value;
         var prefixedData = new FormData();
         referenceClosure.forEach(function (value, key) {
-          prefixedData.append("$ACTION_" + identifierPrefix + ":" + key, value);
+          prefixedData.append('$ACTION_' + identifierPrefix + ':' + key, value);
         });
         data = prefixedData;
-        referenceClosure = "$ACTION_REF_" + identifierPrefix;
-      } else referenceClosure = "$ACTION_ID_" + referenceClosure.id;
+        referenceClosure = '$ACTION_REF_' + identifierPrefix;
+      } else referenceClosure = '$ACTION_ID_' + referenceClosure.id;
       return {
         name: referenceClosure,
-        method: "POST",
-        encType: "multipart/form-data",
-        data: data
+        method: 'POST',
+        encType: 'multipart/form-data',
+        data: data,
       };
     }
     function isSignatureEqual(referenceId, numberOfBoundArgs) {
       var referenceClosure = knownServerReferences.get(this);
       if (!referenceClosure)
         throw Error(
-          "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+          'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
         );
       if (referenceClosure.id !== referenceId) return !1;
       var boundPromise = referenceClosure.bound;
       if (null === boundPromise) return 0 === numberOfBoundArgs;
       switch (boundPromise.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return boundPromise.value.length === numberOfBoundArgs;
-        case "pending":
+        case 'pending':
           throw boundPromise;
-        case "rejected":
+        case 'rejected':
           throw boundPromise.reason;
         default:
           throw (
-            ("string" !== typeof boundPromise.status &&
-              ((boundPromise.status = "pending"),
+            ('string' !== typeof boundPromise.status &&
+              ((boundPromise.status = 'pending'),
               boundPromise.then(
                 function (boundArgs) {
-                  boundPromise.status = "fulfilled";
+                  boundPromise.status = 'fulfilled';
                   boundPromise.value = boundArgs;
                 },
                 function (error) {
-                  boundPromise.status = "rejected";
+                  boundPromise.status = 'rejected';
                   boundPromise.reason = error;
-                }
+                },
               )),
             boundPromise)
           );
@@ -855,36 +855,36 @@
       line,
       col,
       environmentName,
-      innerFunction
+      innerFunction,
     ) {
-      name || (name = "<anonymous>");
+      name || (name = '<anonymous>');
       var encodedName = JSON.stringify(name);
       1 >= line
         ? ((line = encodedName.length + 7),
           (col =
-            "s=>({" +
+            's=>({' +
             encodedName +
-            " ".repeat(col < line ? 0 : col - line) +
-            ":(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */"))
+            ' '.repeat(col < line ? 0 : col - line) +
+            ':(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */'))
         : (col =
-            "/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */" +
-            "\n".repeat(line - 2) +
-            "server=>({" +
+            '/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */' +
+            '\n'.repeat(line - 2) +
+            'server=>({' +
             encodedName +
-            ":\n" +
-            " ".repeat(1 > col ? 0 : col - 1) +
-            "(...args) => server(...args)})");
-      filename.startsWith("/") && (filename = "file://" + filename);
+            ':\n' +
+            ' '.repeat(1 > col ? 0 : col - 1) +
+            '(...args) => server(...args)})');
+      filename.startsWith('/') && (filename = 'file://' + filename);
       sourceMap
         ? ((col +=
-            "\n//# sourceURL=about://React/" +
+            '\n//# sourceURL=about://React/' +
             encodeURIComponent(environmentName) +
-            "/" +
+            '/' +
             encodeURI(filename) +
-            "?s" +
+            '?s' +
             fakeServerFunctionIdx++),
-          (col += "\n//# sourceMappingURL=" + sourceMap))
-        : filename && (col += "\n//# sourceURL=" + filename);
+          (col += '\n//# sourceMappingURL=' + sourceMap))
+        : filename && (col += '\n//# sourceURL=' + filename);
       try {
         return (0, eval)(col)(innerFunction)[name];
       } catch (x) {
@@ -895,13 +895,13 @@
       reference,
       id,
       bound,
-      encodeFormAction
+      encodeFormAction,
     ) {
       knownServerReferences.has(reference) ||
         (knownServerReferences.set(reference, {
           id: id,
           originalBind: reference.bind,
-          bound: bound
+          bound: bound,
         }),
         Object.defineProperties(reference, {
           $$FORM_ACTION: {
@@ -912,16 +912,16 @@
                     var referenceClosure = knownServerReferences.get(this);
                     if (!referenceClosure)
                       throw Error(
-                        "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+                        'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
                       );
                     var boundPromise = referenceClosure.bound;
                     null === boundPromise &&
                       (boundPromise = Promise.resolve([]));
                     return encodeFormAction(referenceClosure.id, boundPromise);
-                  }
+                  },
           },
           $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-          bind: { value: bind }
+          bind: { value: bind },
         }));
     }
     function bind() {
@@ -930,7 +930,7 @@
       var newFn = referenceClosure.originalBind.apply(this, arguments);
       null != arguments[0] &&
         console.error(
-          'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().'
+          'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().',
         );
       var args = ArraySlice.call(arguments, 1),
         boundPromise = null;
@@ -943,12 +943,12 @@
       knownServerReferences.set(newFn, {
         id: referenceClosure.id,
         originalBind: newFn.bind,
-        bound: boundPromise
+        bound: boundPromise,
       });
       Object.defineProperties(newFn, {
         $$FORM_ACTION: { value: this.$$FORM_ACTION },
         $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-        bind: { value: bind }
+        bind: { value: bind },
       });
       return newFn;
     }
@@ -956,12 +956,12 @@
       metaData,
       callServer,
       encodeFormAction,
-      findSourceMapURL
+      findSourceMapURL,
     ) {
       function action() {
         var args = Array.prototype.slice.call(arguments);
         return bound
-          ? "fulfilled" === bound.status
+          ? 'fulfilled' === bound.status
             ? callServer(id, bound.value.concat(args))
             : Promise.resolve(bound).then(function (boundArgs) {
                 return callServer(id, boundArgs.concat(args));
@@ -972,11 +972,11 @@
         bound = metaData.bound,
         location = metaData.location;
       if (location) {
-        var functionName = metaData.name || "",
+        var functionName = metaData.name || '',
           filename = location[1],
           line = location[2];
         location = location[3];
-        metaData = metaData.env || "Server";
+        metaData = metaData.env || 'Server';
         findSourceMapURL =
           null == findSourceMapURL
             ? null
@@ -988,7 +988,7 @@
           line,
           location,
           metaData,
-          action
+          action,
         );
       }
       registerBoundServerReference(action, id, bound, encodeFormAction);
@@ -996,11 +996,11 @@
     }
     function parseStackLocation(error) {
       error = error.stack;
-      error.startsWith("Error: react-stack-top-frame\n") &&
+      error.startsWith('Error: react-stack-top-frame\n') &&
         (error = error.slice(29));
-      var endOfFirst = error.indexOf("\n");
+      var endOfFirst = error.indexOf('\n');
       if (-1 !== endOfFirst) {
-        var endOfSecond = error.indexOf("\n", endOfFirst + 1);
+        var endOfSecond = error.indexOf('\n', endOfFirst + 1);
         endOfFirst =
           -1 === endOfSecond
             ? error.slice(endOfFirst + 1)
@@ -1012,15 +1012,15 @@
         ((error = jscSpiderMonkeyFrameRegExp.exec(endOfFirst)), !error)
       )
         return null;
-      endOfFirst = error[1] || "";
-      "<anonymous>" === endOfFirst && (endOfFirst = "");
-      endOfSecond = error[2] || error[5] || "";
-      "<anonymous>" === endOfSecond && (endOfSecond = "");
+      endOfFirst = error[1] || '';
+      '<anonymous>' === endOfFirst && (endOfFirst = '');
+      endOfSecond = error[2] || error[5] || '';
+      '<anonymous>' === endOfSecond && (endOfSecond = '');
       return [
         endOfFirst,
         endOfSecond,
         +(error[3] || error[6]),
-        +(error[4] || error[7])
+        +(error[4] || error[7]),
       ];
     }
     function createServerReference$1(
@@ -1028,13 +1028,13 @@
       callServer,
       encodeFormAction,
       findSourceMapURL,
-      functionName
+      functionName,
     ) {
       function action() {
         var args = Array.prototype.slice.call(arguments);
         return callServer(id, args);
       }
-      var location = parseStackLocation(Error("react-stack-top-frame"));
+      var location = parseStackLocation(Error('react-stack-top-frame'));
       if (null !== location) {
         var filename = location[1],
           line = location[2];
@@ -1042,15 +1042,15 @@
         findSourceMapURL =
           null == findSourceMapURL
             ? null
-            : findSourceMapURL(filename, "Client");
+            : findSourceMapURL(filename, 'Client');
         action = createFakeServerFunction(
-          functionName || "",
+          functionName || '',
           filename,
           findSourceMapURL,
           line,
           location,
-          "Client",
-          action
+          'Client',
+          action,
         );
       }
       registerBoundServerReference(action, id, null, encodeFormAction);
@@ -1058,52 +1058,52 @@
     }
     function getComponentNameFromType(type) {
       if (null == type) return null;
-      if ("function" === typeof type)
+      if ('function' === typeof type)
         return type.$$typeof === REACT_CLIENT_REFERENCE
           ? null
           : type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_FRAGMENT_TYPE:
-          return "Fragment";
+          return 'Fragment';
         case REACT_PROFILER_TYPE:
-          return "Profiler";
+          return 'Profiler';
         case REACT_STRICT_MODE_TYPE:
-          return "StrictMode";
+          return 'StrictMode';
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
         case REACT_ACTIVITY_TYPE:
-          return "Activity";
+          return 'Activity';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (
-          ("number" === typeof type.tag &&
+          ('number' === typeof type.tag &&
             console.error(
-              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
+              'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.',
             ),
           type.$$typeof)
         ) {
           case REACT_PORTAL_TYPE:
-            return "Portal";
+            return 'Portal';
           case REACT_CONTEXT_TYPE:
-            return type.displayName || "Context";
+            return type.displayName || 'Context';
           case REACT_CONSUMER_TYPE:
-            return (type._context.displayName || "Context") + ".Consumer";
+            return (type._context.displayName || 'Context') + '.Consumer';
           case REACT_FORWARD_REF_TYPE:
             var innerType = type.render;
             type = type.displayName;
             type ||
-              ((type = innerType.displayName || innerType.name || ""),
-              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
+              ((type = innerType.displayName || innerType.name || ''),
+              (type = '' !== type ? 'ForwardRef(' + type + ')' : 'ForwardRef'));
             return type;
           case REACT_MEMO_TYPE:
             return (
               (innerType = type.displayName || null),
               null !== innerType
                 ? innerType
-                : getComponentNameFromType(type.type) || "Memo"
+                : getComponentNameFromType(type.type) || 'Memo'
             );
           case REACT_LAZY_TYPE:
             innerType = type._payload;
@@ -1117,19 +1117,19 @@
     function getArrayKind(array) {
       for (var kind = 0, i = 0; i < array.length; i++) {
         var value = array[i];
-        if ("object" === typeof value && null !== value)
+        if ('object' === typeof value && null !== value)
           if (
             isArrayImpl(value) &&
             2 === value.length &&
-            "string" === typeof value[0]
+            'string' === typeof value[0]
           ) {
             if (0 !== kind && 3 !== kind) return 1;
             kind = 3;
           } else return 1;
         else {
           if (
-            "function" === typeof value ||
-            ("string" === typeof value && 50 < value.length) ||
+            'function' === typeof value ||
+            ('string' === typeof value && 50 < value.length) ||
             (0 !== kind && 2 !== kind)
           )
             return 1;
@@ -1141,7 +1141,7 @@
     function addObjectToProperties(object, properties, indent, prefix) {
       for (var key in object)
         hasOwnProperty.call(object, key) &&
-          "_" !== key[0] &&
+          '_' !== key[0] &&
           addValueToProperties(key, object[key], properties, indent, prefix);
     }
     function addValueToProperties(
@@ -1149,70 +1149,70 @@
       value,
       properties,
       indent,
-      prefix
+      prefix,
     ) {
       switch (typeof value) {
-        case "object":
+        case 'object':
           if (null === value) {
-            value = "null";
+            value = 'null';
             break;
           } else {
             if (value.$$typeof === REACT_ELEMENT_TYPE) {
-              var typeName = getComponentNameFromType(value.type) || "\u2026",
+              var typeName = getComponentNameFromType(value.type) || '\u2026',
                 key = value.key;
               value = value.props;
               var propsKeys = Object.keys(value),
                 propsLength = propsKeys.length;
               if (null == key && 0 === propsLength) {
-                value = "<" + typeName + " />";
+                value = '<' + typeName + ' />';
                 break;
               }
               if (
                 3 > indent ||
                 (1 === propsLength &&
-                  "children" === propsKeys[0] &&
+                  'children' === propsKeys[0] &&
                   null == key)
               ) {
-                value = "<" + typeName + " \u2026 />";
+                value = '<' + typeName + ' \u2026 />';
                 break;
               }
               properties.push([
-                prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-                "<" + typeName
+                prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+                '<' + typeName,
               ]);
               null !== key &&
                 addValueToProperties(
-                  "key",
+                  'key',
                   key,
                   properties,
                   indent + 1,
-                  prefix
+                  prefix,
                 );
               propertyName = !1;
               for (var propKey in value)
-                "children" === propKey
+                'children' === propKey
                   ? null != value.children &&
                     (!isArrayImpl(value.children) ||
                       0 < value.children.length) &&
                     (propertyName = !0)
                   : hasOwnProperty.call(value, propKey) &&
-                    "_" !== propKey[0] &&
+                    '_' !== propKey[0] &&
                     addValueToProperties(
                       propKey,
                       value[propKey],
                       properties,
                       indent + 1,
-                      prefix
+                      prefix,
                     );
               properties.push([
-                "",
-                propertyName ? ">\u2026</" + typeName + ">" : "/>"
+                '',
+                propertyName ? '>\u2026</' + typeName + '>' : '/>',
               ]);
               return;
             }
             typeName = Object.prototype.toString.call(value);
             typeName = typeName.slice(8, typeName.length - 1);
-            if ("Array" === typeName)
+            if ('Array' === typeName)
               if (
                 ((propKey = getArrayKind(value)),
                 2 === propKey || 0 === propKey)
@@ -1221,8 +1221,8 @@
                 break;
               } else if (3 === propKey) {
                 properties.push([
-                  prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-                  ""
+                  prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+                  '',
                 ]);
                 for (
                   propertyName = 0;
@@ -1235,12 +1235,12 @@
                       typeName[1],
                       properties,
                       indent + 1,
-                      prefix
+                      prefix,
                     );
                 return;
               }
-            if ("Promise" === typeName) {
-              if ("fulfilled" === value.status) {
+            if ('Promise' === typeName) {
+              if ('fulfilled' === value.status) {
                 if (
                   ((typeName = properties.length),
                   addValueToProperties(
@@ -1248,189 +1248,189 @@
                     value.value,
                     properties,
                     indent,
-                    prefix
+                    prefix,
                   ),
                   properties.length > typeName)
                 ) {
                   properties = properties[typeName];
                   properties[1] =
-                    "Promise<" + (properties[1] || "Object") + ">";
+                    'Promise<' + (properties[1] || 'Object') + '>';
                   return;
                 }
               } else if (
-                "rejected" === value.status &&
+                'rejected' === value.status &&
                 ((typeName = properties.length),
                 addValueToProperties(
                   propertyName,
                   value.reason,
                   properties,
                   indent,
-                  prefix
+                  prefix,
                 ),
                 properties.length > typeName)
               ) {
                 properties = properties[typeName];
-                properties[1] = "Rejected Promise<" + properties[1] + ">";
+                properties[1] = 'Rejected Promise<' + properties[1] + '>';
                 return;
               }
               properties.push([
-                "\u00a0\u00a0".repeat(indent) + propertyName,
-                "Promise"
+                '\u00a0\u00a0'.repeat(indent) + propertyName,
+                'Promise',
               ]);
               return;
             }
-            "Object" === typeName &&
+            'Object' === typeName &&
               (propKey = Object.getPrototypeOf(value)) &&
-              "function" === typeof propKey.constructor &&
+              'function' === typeof propKey.constructor &&
               (typeName = propKey.constructor.name);
             properties.push([
-              prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-              "Object" === typeName ? (3 > indent ? "" : "\u2026") : typeName
+              prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+              'Object' === typeName ? (3 > indent ? '' : '\u2026') : typeName,
             ]);
             3 > indent &&
               addObjectToProperties(value, properties, indent + 1, prefix);
             return;
           }
-        case "function":
-          value = "" === value.name ? "() => {}" : value.name + "() {}";
+        case 'function':
+          value = '' === value.name ? '() => {}' : value.name + '() {}';
           break;
-        case "string":
+        case 'string':
           value =
-            "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects." ===
+            'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.' ===
             value
-              ? "\u2026"
+              ? '\u2026'
               : JSON.stringify(value);
           break;
-        case "undefined":
-          value = "undefined";
+        case 'undefined':
+          value = 'undefined';
           break;
-        case "boolean":
-          value = value ? "true" : "false";
+        case 'boolean':
+          value = value ? 'true' : 'false';
           break;
         default:
           value = String(value);
       }
       properties.push([
-        prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-        value
+        prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+        value,
       ]);
     }
     function getIODescription(value) {
       try {
         switch (typeof value) {
-          case "object":
-            if (null === value) return "";
+          case 'object':
+            if (null === value) return '';
             if (value instanceof Error) return String(value.message);
-            if ("string" === typeof value.url) return value.url;
-            if ("string" === typeof value.href) return value.href;
-            if ("string" === typeof value.src) return value.src;
-            if ("string" === typeof value.currentSrc) return value.currentSrc;
-            if ("string" === typeof value.command) return value.command;
+            if ('string' === typeof value.url) return value.url;
+            if ('string' === typeof value.href) return value.href;
+            if ('string' === typeof value.src) return value.src;
+            if ('string' === typeof value.currentSrc) return value.currentSrc;
+            if ('string' === typeof value.command) return value.command;
             if (
-              "object" === typeof value.request &&
+              'object' === typeof value.request &&
               null !== value.request &&
-              "string" === typeof value.request.url
+              'string' === typeof value.request.url
             )
               return value.request.url;
             if (
-              "object" === typeof value.response &&
+              'object' === typeof value.response &&
               null !== value.response &&
-              "string" === typeof value.response.url
+              'string' === typeof value.response.url
             )
               return value.response.url;
             if (
-              "string" === typeof value.id ||
-              "number" === typeof value.id ||
-              "bigint" === typeof value.id
+              'string' === typeof value.id ||
+              'number' === typeof value.id ||
+              'bigint' === typeof value.id
             )
               return String(value.id);
-            if ("string" === typeof value.name) return value.name;
+            if ('string' === typeof value.name) return value.name;
             var str = value.toString();
-            return str.startsWith("[object ") ||
+            return str.startsWith('[object ') ||
               5 > str.length ||
               500 < str.length
-              ? ""
+              ? ''
               : str;
-          case "string":
-            return 5 > value.length || 500 < value.length ? "" : value;
-          case "number":
-          case "bigint":
+          case 'string':
+            return 5 > value.length || 500 < value.length ? '' : value;
+          case 'number':
+          case 'bigint':
             return String(value);
           default:
-            return "";
+            return '';
         }
       } catch (x) {
-        return "";
+        return '';
       }
     }
     function markAllTracksInOrder() {
       supportsUserTiming &&
         (console.timeStamp(
-          "Server Requests Track",
+          'Server Requests Track',
           0.001,
           0.001,
-          "Server Requests \u269b",
+          'Server Requests \u269b',
           void 0,
-          "primary-light"
+          'primary-light',
         ),
         console.timeStamp(
-          "Server Components Track",
+          'Server Components Track',
           0.001,
           0.001,
-          "Primary",
-          "Server Components \u269b",
-          "primary-light"
+          'Primary',
+          'Server Components \u269b',
+          'primary-light',
         ));
     }
     function getIOColor(functionName) {
       switch (functionName.charCodeAt(0) % 3) {
         case 0:
-          return "tertiary-light";
+          return 'tertiary-light';
         case 1:
-          return "tertiary";
+          return 'tertiary';
         default:
-          return "tertiary-dark";
+          return 'tertiary-dark';
       }
     }
     function getIOLongName(ioInfo, description, env, rootEnv) {
       ioInfo = ioInfo.name;
       description =
-        "" === description ? ioInfo : ioInfo + " (" + description + ")";
+        '' === description ? ioInfo : ioInfo + ' (' + description + ')';
       return env === rootEnv || void 0 === env
         ? description
-        : description + " [" + env + "]";
+        : description + ' [' + env + ']';
     }
     function getIOShortName(ioInfo, description, env, rootEnv) {
       ioInfo = ioInfo.name;
-      env = env === rootEnv || void 0 === env ? "" : " [" + env + "]";
-      var desc = "";
+      env = env === rootEnv || void 0 === env ? '' : ' [' + env + ']';
+      var desc = '';
       rootEnv = 30 - ioInfo.length - env.length;
       if (1 < rootEnv) {
         var l = description.length;
-        if (0 < l && l <= rootEnv) desc = " (" + description + ")";
+        if (0 < l && l <= rootEnv) desc = ' (' + description + ')';
         else if (
-          description.startsWith("http://") ||
-          description.startsWith("https://") ||
-          description.startsWith("/")
+          description.startsWith('http://') ||
+          description.startsWith('https://') ||
+          description.startsWith('/')
         ) {
-          var queryIdx = description.indexOf("?");
+          var queryIdx = description.indexOf('?');
           -1 === queryIdx && (queryIdx = description.length);
           47 === description.charCodeAt(queryIdx - 1) && queryIdx--;
-          desc = description.lastIndexOf("/", queryIdx - 1);
+          desc = description.lastIndexOf('/', queryIdx - 1);
           queryIdx - desc < rootEnv
-            ? (desc = " (\u2026" + description.slice(desc, queryIdx) + ")")
+            ? (desc = ' (\u2026' + description.slice(desc, queryIdx) + ')')
             : ((l = description.slice(desc, desc + rootEnv / 2)),
               (description = description.slice(
                 queryIdx - rootEnv / 2,
-                queryIdx
+                queryIdx,
               )),
               (desc =
-                " (" +
-                (0 < desc ? "\u2026" : "") +
+                ' (' +
+                (0 < desc ? '\u2026' : '') +
                 l +
-                "\u2026" +
+                '\u2026' +
                 description +
-                ")"));
+                ')'));
         }
       }
       return ioInfo + desc + env;
@@ -1441,7 +1441,7 @@
       startTime,
       endTime,
       rootEnv,
-      value
+      value,
     ) {
       if (supportsUserTiming && 0 < endTime) {
         var description = getIODescription(value),
@@ -1449,22 +1449,22 @@
             asyncInfo.awaited,
             description,
             asyncInfo.env,
-            rootEnv
+            rootEnv,
           ),
-          entryName = "await " + name;
+          entryName = 'await ' + name;
         name = getIOColor(name);
         var debugTask = asyncInfo.debugTask || asyncInfo.awaited.debugTask;
         if (debugTask) {
           var properties = [];
-          "object" === typeof value && null !== value
-            ? addObjectToProperties(value, properties, 0, "")
+          'object' === typeof value && null !== value
+            ? addObjectToProperties(value, properties, 0, '')
             : void 0 !== value &&
-              addValueToProperties("awaited value", value, properties, 0, "");
+              addValueToProperties('awaited value', value, properties, 0, '');
           asyncInfo = getIOLongName(
             asyncInfo.awaited,
             description,
             asyncInfo.env,
-            rootEnv
+            rootEnv,
           );
           debugTask.run(
             performance.measure.bind(performance, entryName, {
@@ -1474,12 +1474,12 @@
                 devtools: {
                   color: name,
                   track: trackNames[trackIdx],
-                  trackGroup: "Server Components \u269b",
+                  trackGroup: 'Server Components \u269b',
                   properties: properties,
-                  tooltipText: asyncInfo
-                }
-              }
-            })
+                  tooltipText: asyncInfo,
+                },
+              },
+            }),
           );
         } else
           console.timeStamp(
@@ -1487,8 +1487,8 @@
             0 > startTime ? 0 : startTime,
             endTime,
             trackNames[trackIdx],
-            "Server Components \u269b",
-            name
+            'Server Components \u269b',
+            name,
           );
       }
     }
@@ -1502,38 +1502,38 @@
         debugTask
           ? ((error = [
               [
-                "rejected with",
-                "object" === typeof error &&
+                'rejected with',
+                'object' === typeof error &&
                 null !== error &&
-                "string" === typeof error.message
+                'string' === typeof error.message
                   ? String(error.message)
-                  : String(error)
-              ]
+                  : String(error),
+              ],
             ]),
             (ioInfo =
               getIOLongName(ioInfo, description, ioInfo.env, rootEnv) +
-              " Rejected"),
+              ' Rejected'),
             debugTask.run(
-              performance.measure.bind(performance, "\u200b" + entryName, {
+              performance.measure.bind(performance, '\u200b' + entryName, {
                 start: 0 > startTime ? 0 : startTime,
                 end: endTime,
                 detail: {
                   devtools: {
-                    color: "error",
-                    track: "Server Requests \u269b",
+                    color: 'error',
+                    track: 'Server Requests \u269b',
                     properties: error,
-                    tooltipText: ioInfo
-                  }
-                }
-              })
+                    tooltipText: ioInfo,
+                  },
+                },
+              }),
             ))
           : console.timeStamp(
               entryName,
               0 > startTime ? 0 : startTime,
               endTime,
-              "Server Requests \u269b",
+              'Server Requests \u269b',
               void 0,
-              "error"
+              'error',
             );
       }
     }
@@ -1547,40 +1547,40 @@
           debugTask = ioInfo.debugTask;
         if (debugTask) {
           var properties = [];
-          "object" === typeof value && null !== value
-            ? addObjectToProperties(value, properties, 0, "")
+          'object' === typeof value && null !== value
+            ? addObjectToProperties(value, properties, 0, '')
             : void 0 !== value &&
-              addValueToProperties("Resolved", value, properties, 0, "");
+              addValueToProperties('Resolved', value, properties, 0, '');
           ioInfo = getIOLongName(ioInfo, description, ioInfo.env, rootEnv);
           debugTask.run(
-            performance.measure.bind(performance, "\u200b" + entryName, {
+            performance.measure.bind(performance, '\u200b' + entryName, {
               start: 0 > startTime ? 0 : startTime,
               end: endTime,
               detail: {
                 devtools: {
                   color: color,
-                  track: "Server Requests \u269b",
+                  track: 'Server Requests \u269b',
                   properties: properties,
-                  tooltipText: ioInfo
-                }
-              }
-            })
+                  tooltipText: ioInfo,
+                },
+              },
+            }),
           );
         } else
           console.timeStamp(
             entryName,
             0 > startTime ? 0 : startTime,
             endTime,
-            "Server Requests \u269b",
+            'Server Requests \u269b',
             void 0,
-            color
+            color,
           );
       }
     }
     function prepareStackTrace(error, structuredStackTrace) {
-      error = (error.name || "Error") + ": " + (error.message || "");
+      error = (error.name || 'Error') + ': ' + (error.message || '');
       for (var i = 0; i < structuredStackTrace.length; i++)
-        error += "\n    at " + structuredStackTrace[i].toString();
+        error += '\n    at ' + structuredStackTrace[i].toString();
       return error;
     }
     function ReactPromise(status, value, reason) {
@@ -1595,27 +1595,27 @@
       weakResponse = weakResponse.weak.deref();
       if (void 0 === weakResponse)
         throw Error(
-          "We did not expect to receive new data after GC:ing the response."
+          'We did not expect to receive new data after GC:ing the response.',
         );
       return weakResponse;
     }
     function closeDebugChannel(debugChannel) {
-      debugChannel.callback && debugChannel.callback("");
+      debugChannel.callback && debugChannel.callback('');
     }
     function readChunk(chunk) {
       switch (chunk.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(chunk);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(chunk);
       }
       switch (chunk.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return chunk.value;
-        case "pending":
-        case "blocked":
-        case "halted":
+        case 'pending':
+        case 'blocked':
+        case 'halted':
           throw chunk;
         default:
           throw chunk.reason;
@@ -1631,39 +1631,39 @@
         null !== response._pendingInitialRender &&
           (clearTimeout(response._pendingInitialRender),
           (response._pendingInitialRender = null)));
-      return new ReactPromise("pending", null, null);
+      return new ReactPromise('pending', null, null);
     }
     function releasePendingChunk(response, chunk) {
-      "pending" === chunk.status &&
+      'pending' === chunk.status &&
         0 === --response._pendingChunks &&
         ((response._weakResponse.response = null),
         (response._pendingInitialRender = setTimeout(
           flushInitialRenderPerformance.bind(null, response),
-          100
+          100,
         )));
     }
     function moveDebugInfoFromChunkToInnerValue(chunk, value) {
       value = resolveLazy(value);
-      "object" !== typeof value ||
+      'object' !== typeof value ||
         null === value ||
         (!isArrayImpl(value) &&
-          "function" !== typeof value[ASYNC_ITERATOR] &&
+          'function' !== typeof value[ASYNC_ITERATOR] &&
           value.$$typeof !== REACT_ELEMENT_TYPE &&
           value.$$typeof !== REACT_LAZY_TYPE) ||
         ((chunk = chunk._debugInfo.splice(0)),
         isArrayImpl(value._debugInfo)
           ? value._debugInfo.unshift.apply(value._debugInfo, chunk)
-          : Object.defineProperty(value, "_debugInfo", {
+          : Object.defineProperty(value, '_debugInfo', {
               configurable: !1,
               enumerable: !1,
               writable: !0,
-              value: chunk
+              value: chunk,
             }));
     }
     function wakeChunk(listeners, value, chunk) {
       for (var i = 0; i < listeners.length; i++) {
         var listener = listeners[i];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(value)
           : fulfillReference(listener, value, chunk);
       }
@@ -1672,7 +1672,7 @@
     function rejectChunk(listeners, error) {
       for (var i = 0; i < listeners.length; i++) {
         var listener = listeners[i];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(error)
           : rejectReference(listener, error);
       }
@@ -1690,7 +1690,7 @@
         ) {
           var listener = reference[referencedChunk];
           if (
-            "function" !== typeof listener &&
+            'function' !== typeof listener &&
             ((listener = resolveBlockedCycle(resolvedChunk, listener)),
             null !== listener)
           )
@@ -1700,13 +1700,13 @@
     }
     function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
       switch (chunk.status) {
-        case "fulfilled":
+        case 'fulfilled':
           wakeChunk(resolveListeners, chunk.value, chunk);
           break;
-        case "blocked":
+        case 'blocked':
           for (var i = 0; i < resolveListeners.length; i++) {
             var listener = resolveListeners[i];
-            if ("function" !== typeof listener) {
+            if ('function' !== typeof listener) {
               var cyclicHandler = resolveBlockedCycle(chunk, listener);
               null !== cyclicHandler &&
                 (fulfillReference(listener, cyclicHandler.value, chunk),
@@ -1717,7 +1717,7 @@
                   -1 !== listener && rejectListeners.splice(listener, 1)));
             }
           }
-        case "pending":
+        case 'pending':
           if (chunk.value)
             for (i = 0; i < resolveListeners.length; i++)
               chunk.value.push(resolveListeners[i]);
@@ -1732,21 +1732,21 @@
                 chunk.reason.push(rejectListeners[resolveListeners]);
           } else chunk.reason = rejectListeners;
           break;
-        case "rejected":
+        case 'rejected':
           rejectListeners && rejectChunk(rejectListeners, chunk.reason);
       }
     }
     function triggerErrorOnChunk(response, chunk, error) {
-      if ("pending" !== chunk.status && "blocked" !== chunk.status)
+      if ('pending' !== chunk.status && 'blocked' !== chunk.status)
         chunk.reason.error(error);
       else {
         releasePendingChunk(response, chunk);
         var listeners = chunk.reason;
-        if ("pending" === chunk.status && null != chunk._debugChunk) {
+        if ('pending' === chunk.status && null != chunk._debugChunk) {
           var prevHandler = initializingHandler,
             prevChunk = initializingChunk;
           initializingHandler = null;
-          chunk.status = "blocked";
+          chunk.status = 'blocked';
           chunk.value = null;
           chunk.reason = null;
           initializingChunk = chunk;
@@ -1757,21 +1757,21 @@
               (initializingChunk = prevChunk);
           }
         }
-        chunk.status = "rejected";
+        chunk.status = 'rejected';
         chunk.reason = error;
         null !== listeners && rejectChunk(listeners, error);
       }
     }
     function createResolvedModelChunk(response, value) {
-      return new ReactPromise("resolved_model", value, response);
+      return new ReactPromise('resolved_model', value, response);
     }
     function createResolvedIteratorResultChunk(response, value, done) {
       return new ReactPromise(
-        "resolved_model",
+        'resolved_model',
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
-        response
+          '}',
+        response,
       );
     }
     function resolveIteratorResultChunk(response, chunk, value, done) {
@@ -1780,16 +1780,16 @@
         chunk,
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}"
+          '}',
       );
     }
     function resolveModelChunk(response, chunk, value) {
-      if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+      if ('pending' !== chunk.status) chunk.reason.enqueueModel(value);
       else {
         releasePendingChunk(response, chunk);
         var resolveListeners = chunk.value,
           rejectListeners = chunk.reason;
-        chunk.status = "resolved_model";
+        chunk.status = 'resolved_model';
         chunk.value = value;
         chunk.reason = response;
         null !== resolveListeners &&
@@ -1798,11 +1798,11 @@
       }
     }
     function resolveModuleChunk(response, chunk, value) {
-      if ("pending" === chunk.status || "blocked" === chunk.status) {
+      if ('pending' === chunk.status || 'blocked' === chunk.status) {
         releasePendingChunk(response, chunk);
         response = chunk.value;
         var rejectListeners = chunk.reason;
-        chunk.status = "resolved_module";
+        chunk.status = 'resolved_module';
         chunk.value = value;
         value = [];
         null !== value && chunk._debugInfo.push.apply(chunk._debugInfo, value);
@@ -1816,31 +1816,31 @@
       if (null !== debugChunk) {
         var debugInfo = chunk._debugInfo;
         try {
-          if ("resolved_model" === debugChunk.status) {
+          if ('resolved_model' === debugChunk.status) {
             for (
               var idx = debugInfo.length, c = debugChunk._debugChunk;
               null !== c;
 
             )
-              "fulfilled" !== c.status && idx++, (c = c._debugChunk);
+              'fulfilled' !== c.status && idx++, (c = c._debugChunk);
             initializeModelChunk(debugChunk);
             switch (debugChunk.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 debugInfo[idx] = initializeDebugInfo(
                   response,
-                  debugChunk.value
+                  debugChunk.value,
                 );
                 break;
-              case "blocked":
-              case "pending":
+              case 'blocked':
+              case 'pending':
                 waitForReference(
                   debugChunk,
                   debugInfo,
-                  "" + idx,
+                  '' + idx,
                   response,
                   initializeDebugInfo,
-                  [""],
-                  !0
+                  [''],
+                  !0,
                 );
                 break;
               default:
@@ -1848,18 +1848,18 @@
             }
           } else
             switch (debugChunk.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 break;
-              case "blocked":
-              case "pending":
+              case 'blocked':
+              case 'pending':
                 waitForReference(
                   debugChunk,
                   {},
-                  "debug",
+                  'debug',
                   response,
                   initializeDebugInfo,
-                  [""],
-                  !0
+                  [''],
+                  !0,
                 );
                 break;
               default:
@@ -1876,7 +1876,7 @@
       initializingHandler = null;
       var resolvedModel = chunk.value,
         response = chunk.reason;
-      chunk.status = "blocked";
+      chunk.status = 'blocked';
       chunk.value = null;
       chunk.reason = null;
       initializingChunk = chunk;
@@ -1891,7 +1891,7 @@
             resolvedModel++
           ) {
             var listener = resolveListeners[resolvedModel];
-            "function" === typeof listener
+            'function' === typeof listener
               ? listener(value)
               : fulfillReference(listener, value, chunk);
           }
@@ -1903,11 +1903,11 @@
             return;
           }
         }
-        chunk.status = "fulfilled";
+        chunk.status = 'fulfilled';
         chunk.value = value;
         moveDebugInfoFromChunkToInnerValue(chunk, value);
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       } finally {
         (initializingHandler = prevHandler), (initializingChunk = prevChunk);
       }
@@ -1915,10 +1915,10 @@
     function initializeModuleChunk(chunk) {
       try {
         var value = requireModule(chunk.value);
-        chunk.status = "fulfilled";
+        chunk.status = 'fulfilled';
         chunk.value = value;
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       }
     }
     function reportGlobalError(weakResponse, error) {
@@ -1927,7 +1927,7 @@
         response._closed = !0;
         response._closedReason = error;
         response._chunks.forEach(function (chunk) {
-          "pending" === chunk.status &&
+          'pending' === chunk.status &&
             triggerErrorOnChunk(response, chunk, error);
         });
         weakResponse = response._debugChannel;
@@ -1942,19 +1942,19 @@
       return null;
     }
     function getTaskName(type) {
-      if (type === REACT_FRAGMENT_TYPE) return "<>";
-      if ("function" === typeof type) return '"use client"';
+      if (type === REACT_FRAGMENT_TYPE) return '<>';
+      if ('function' === typeof type) return '"use client"';
       if (
-        "object" === typeof type &&
+        'object' === typeof type &&
         null !== type &&
         type.$$typeof === REACT_LAZY_TYPE
       )
-        return type._init === readChunk ? '"use client"' : "<...>";
+        return type._init === readChunk ? '"use client"' : '<...>';
       try {
         var name = getComponentNameFromType(type);
-        return name ? "<" + name + ">" : "<...>";
+        return name ? '<' + name + '>' : '<...>';
       } catch (x) {
-        return "<...>";
+        return '<...>';
       }
     }
     function initializeElement(response, element, lazyNode) {
@@ -1970,7 +1970,7 @@
           (normalizedStackTrace = createFakeJSXCallStackInDEV(
             response,
             stack,
-            env
+            env,
           ));
       element._debugStack = normalizedStackTrace;
       normalizedStackTrace = null;
@@ -1978,14 +1978,14 @@
         null !== stack &&
         ((normalizedStackTrace = console.createTask.bind(
           console,
-          getTaskName(element.type)
+          getTaskName(element.type),
         )),
         (stack = buildFakeCallStack(
           response,
           stack,
           env,
           !1,
-          normalizedStackTrace
+          normalizedStackTrace,
         )),
         (env = null === owner ? null : initializeFakeTask(response, owner)),
         null === env
@@ -1999,16 +1999,16 @@
           lazyNode._store.validated &&
           !element._store.validated &&
           (element._store.validated = lazyNode._store.validated),
-        "fulfilled" === lazyNode._payload.status &&
+        'fulfilled' === lazyNode._payload.status &&
           lazyNode._debugInfo &&
           ((response = lazyNode._debugInfo.splice(0)),
           element._debugInfo
             ? element._debugInfo.unshift.apply(element._debugInfo, response)
-            : Object.defineProperty(element, "_debugInfo", {
+            : Object.defineProperty(element, '_debugInfo', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: response
+                value: response,
               })));
       Object.freeze(element.props);
     }
@@ -2016,7 +2016,7 @@
       var lazyType = {
         $$typeof: REACT_LAZY_TYPE,
         _payload: chunk,
-        _init: readChunk
+        _init: readChunk,
       };
       lazyType._debugInfo = chunk._debugInfo;
       lazyType._store = { validated: validated };
@@ -2027,7 +2027,7 @@
         chunk = chunks.get(id);
       chunk ||
         ((chunk = response._closed
-          ? new ReactPromise("rejected", null, response._closedReason)
+          ? new ReactPromise('rejected', null, response._closedReason)
           : createPendingChunk(response)),
         chunks.set(id, chunk));
       return chunk;
@@ -2046,7 +2046,7 @@
       ) {
         for (
           ;
-          "object" === typeof value &&
+          'object' === typeof value &&
           null !== value &&
           value.$$typeof === REACT_LAZY_TYPE;
 
@@ -2055,23 +2055,23 @@
             value = handler.value;
           else {
             switch (value.status) {
-              case "resolved_model":
+              case 'resolved_model':
                 initializeModelChunk(value);
                 break;
-              case "resolved_module":
+              case 'resolved_module':
                 initializeModuleChunk(value);
             }
             switch (value.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 value = value.value;
                 continue;
-              case "blocked":
+              case 'blocked':
                 var cyclicHandler = resolveBlockedCycle(value, reference);
                 if (null !== cyclicHandler) {
                   value = cyclicHandler.value;
                   continue;
                 }
-              case "pending":
+              case 'pending':
                 path.splice(0, i - 1);
                 null === value.value
                   ? (value.value = [reference])
@@ -2080,7 +2080,7 @@
                   ? (value.reason = [reference])
                   : value.reason.push(reference);
                 return;
-              case "halted":
+              case 'halted':
                 return;
               default:
                 rejectReference(reference, value.reason);
@@ -2091,7 +2091,7 @@
       }
       for (
         ;
-        "object" === typeof value &&
+        'object' === typeof value &&
         null !== value &&
         value.$$typeof === REACT_LAZY_TYPE;
 
@@ -2100,14 +2100,14 @@
           value = handler.value;
         else {
           switch (path.status) {
-            case "resolved_model":
+            case 'resolved_model':
               initializeModelChunk(path);
               break;
-            case "resolved_module":
+            case 'resolved_module':
               initializeModuleChunk(path);
           }
           switch (path.status) {
-            case "fulfilled":
+            case 'fulfilled':
               value = path.value;
               continue;
           }
@@ -2115,22 +2115,22 @@
         }
       response = map(response, value, parentObject, key);
       parentObject[key] = response;
-      "" === key && null === handler.value && (handler.value = response);
+      '' === key && null === handler.value && (handler.value = response);
       if (
         parentObject[0] === REACT_ELEMENT_TYPE &&
-        "object" === typeof handler.value &&
+        'object' === typeof handler.value &&
         null !== handler.value &&
         handler.value.$$typeof === REACT_ELEMENT_TYPE
       )
         switch (((reference = handler.value), key)) {
-          case "3":
+          case '3':
             transferReferencedDebugInfo(handler.chunk, fulfilledChunk);
             reference.props = response;
             break;
-          case "4":
+          case '4':
             reference._owner = response;
             break;
-          case "5":
+          case '5':
             reference._debugStack = response;
             break;
           default:
@@ -2143,9 +2143,9 @@
       0 === handler.deps &&
         ((fulfilledChunk = handler.chunk),
         null !== fulfilledChunk &&
-          "blocked" === fulfilledChunk.status &&
+          'blocked' === fulfilledChunk.status &&
           ((key = fulfilledChunk.value),
-          (fulfilledChunk.status = "fulfilled"),
+          (fulfilledChunk.status = 'fulfilled'),
           (fulfilledChunk.value = handler.value),
           (fulfilledChunk.reason = handler.reason),
           null !== key && wakeChunk(key, handler.value, fulfilledChunk)));
@@ -2159,15 +2159,15 @@
         handler.value = null;
         handler.reason = error;
         handler = handler.chunk;
-        if (null !== handler && "blocked" === handler.status) {
+        if (null !== handler && 'blocked' === handler.status) {
           if (
-            "object" === typeof blockedValue &&
+            'object' === typeof blockedValue &&
             null !== blockedValue &&
             blockedValue.$$typeof === REACT_ELEMENT_TYPE
           ) {
             var erroredComponent = {
-              name: getComponentNameFromType(blockedValue.type) || "",
-              owner: blockedValue._owner
+              name: getComponentNameFromType(blockedValue.type) || '',
+              owner: blockedValue._owner,
             };
             erroredComponent.debugStack = blockedValue._debugStack;
             supportsCreateTask &&
@@ -2185,15 +2185,15 @@
       response,
       map,
       path,
-      isAwaitingDebugInfo
+      isAwaitingDebugInfo,
     ) {
       if (
         !(
           (void 0 !== response._debugChannel &&
             response._debugChannel.hasReadable) ||
-          "pending" !== referencedChunk.status ||
+          'pending' !== referencedChunk.status ||
           parentObject[0] !== REACT_ELEMENT_TYPE ||
-          ("4" !== key && "5" !== key)
+          ('4' !== key && '5' !== key)
         )
       )
         return null;
@@ -2207,7 +2207,7 @@
           value: null,
           reason: null,
           deps: 1,
-          errored: !1
+          errored: !1,
         };
       parentObject = {
         response: response,
@@ -2215,7 +2215,7 @@
         parentObject: parentObject,
         key: key,
         map: map,
-        path: path
+        path: path,
       };
       parentObject.isDebug = isAwaitingDebugInfo;
       null === referencedChunk.value
@@ -2232,11 +2232,11 @@
           metaData,
           response._callServer,
           response._encodeFormAction,
-          response._debugFindSourceMapURL
+          response._debugFindSourceMapURL,
         );
       var serverReference = resolveServerReference(
           response._serverReferenceConfig,
-          metaData.id
+          metaData.id,
         ),
         promise = preloadModule(serverReference);
       if (promise)
@@ -2249,7 +2249,7 @@
             promise,
             metaData.id,
             metaData.bound,
-            response._encodeFormAction
+            response._encodeFormAction,
           ),
           promise
         );
@@ -2263,7 +2263,7 @@
           value: null,
           reason: null,
           deps: 1,
-          errored: !1
+          errored: !1,
         };
       promise.then(
         function () {
@@ -2277,32 +2277,32 @@
             resolvedValue,
             metaData.id,
             metaData.bound,
-            response._encodeFormAction
+            response._encodeFormAction,
           );
           parentObject[key] = resolvedValue;
-          "" === key &&
+          '' === key &&
             null === handler.value &&
             (handler.value = resolvedValue);
           if (
             parentObject[0] === REACT_ELEMENT_TYPE &&
-            "object" === typeof handler.value &&
+            'object' === typeof handler.value &&
             null !== handler.value &&
             handler.value.$$typeof === REACT_ELEMENT_TYPE
           )
             switch (((boundArgs = handler.value), key)) {
-              case "3":
+              case '3':
                 boundArgs.props = resolvedValue;
                 break;
-              case "4":
+              case '4':
                 boundArgs._owner = resolvedValue;
             }
           handler.deps--;
           0 === handler.deps &&
             ((resolvedValue = handler.chunk),
             null !== resolvedValue &&
-              "blocked" === resolvedValue.status &&
+              'blocked' === resolvedValue.status &&
               ((boundArgs = resolvedValue.value),
-              (resolvedValue.status = "fulfilled"),
+              (resolvedValue.status = 'fulfilled'),
               (resolvedValue.value = handler.value),
               null !== boundArgs &&
                 wakeChunk(boundArgs, handler.value, resolvedValue)));
@@ -2314,15 +2314,15 @@
             handler.value = null;
             handler.reason = error;
             var chunk = handler.chunk;
-            if (null !== chunk && "blocked" === chunk.status) {
+            if (null !== chunk && 'blocked' === chunk.status) {
               if (
-                "object" === typeof blockedValue &&
+                'object' === typeof blockedValue &&
                 null !== blockedValue &&
                 blockedValue.$$typeof === REACT_ELEMENT_TYPE
               ) {
                 var erroredComponent = {
-                  name: getComponentNameFromType(blockedValue.type) || "",
-                  owner: blockedValue._owner
+                  name: getComponentNameFromType(blockedValue.type) || '',
+                  owner: blockedValue._owner,
                 };
                 erroredComponent.debugStack = blockedValue._debugStack;
                 supportsCreateTask &&
@@ -2332,20 +2332,20 @@
               triggerErrorOnChunk(response, chunk, error);
             }
           }
-        }
+        },
       );
       return null;
     }
     function resolveLazy(value) {
       for (
         ;
-        "object" === typeof value &&
+        'object' === typeof value &&
         null !== value &&
         value.$$typeof === REACT_LAZY_TYPE;
 
       ) {
         var payload = value._payload;
-        if ("fulfilled" === payload.status) value = payload.value;
+        if ('fulfilled' === payload.status) value = payload.value;
         else break;
       }
       return value;
@@ -2361,43 +2361,43 @@
       }
     }
     function getOutlinedModel(response, reference, parentObject, key, map) {
-      var path = reference.split(":");
+      var path = reference.split(':');
       reference = parseInt(path[0], 16);
       reference = getChunk(response, reference);
       null !== initializingChunk &&
         isArrayImpl(initializingChunk._children) &&
         initializingChunk._children.push(reference);
       switch (reference.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(reference);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(reference);
       }
       switch (reference.status) {
-        case "fulfilled":
+        case 'fulfilled':
           for (var value = reference.value, i = 1; i < path.length; i++) {
             for (
               ;
-              "object" === typeof value &&
+              'object' === typeof value &&
               null !== value &&
               value.$$typeof === REACT_LAZY_TYPE;
 
             ) {
               value = value._payload;
               switch (value.status) {
-                case "resolved_model":
+                case 'resolved_model':
                   initializeModelChunk(value);
                   break;
-                case "resolved_module":
+                case 'resolved_module':
                   initializeModuleChunk(value);
               }
               switch (value.status) {
-                case "fulfilled":
+                case 'fulfilled':
                   value = value.value;
                   break;
-                case "blocked":
-                case "pending":
+                case 'blocked':
+                case 'pending':
                   return waitForReference(
                     value,
                     parentObject,
@@ -2405,9 +2405,9 @@
                     response,
                     map,
                     path.slice(i - 1),
-                    !1
+                    !1,
                   );
-                case "halted":
+                case 'halted':
                   return (
                     initializingHandler
                       ? ((parentObject = initializingHandler),
@@ -2418,7 +2418,7 @@
                           value: null,
                           reason: null,
                           deps: 1,
-                          errored: !1
+                          errored: !1,
                         }),
                     null
                   );
@@ -2434,7 +2434,7 @@
                           value: null,
                           reason: value.reason,
                           deps: 0,
-                          errored: !0
+                          errored: !0,
                         }),
                     null
                   );
@@ -2444,21 +2444,21 @@
           }
           for (
             ;
-            "object" === typeof value &&
+            'object' === typeof value &&
             null !== value &&
             value.$$typeof === REACT_LAZY_TYPE;
 
           ) {
             path = value._payload;
             switch (path.status) {
-              case "resolved_model":
+              case 'resolved_model':
                 initializeModelChunk(path);
                 break;
-              case "resolved_module":
+              case 'resolved_module':
                 initializeModuleChunk(path);
             }
             switch (path.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 value = path.value;
                 continue;
             }
@@ -2466,11 +2466,11 @@
           }
           response = map(response, value, parentObject, key);
           (parentObject[0] !== REACT_ELEMENT_TYPE ||
-            ("4" !== key && "5" !== key)) &&
+            ('4' !== key && '5' !== key)) &&
             transferReferencedDebugInfo(initializingChunk, reference);
           return response;
-        case "pending":
-        case "blocked":
+        case 'pending':
+        case 'blocked':
           return waitForReference(
             reference,
             parentObject,
@@ -2478,9 +2478,9 @@
             response,
             map,
             path,
-            !1
+            !1,
           );
-        case "halted":
+        case 'halted':
           return (
             initializingHandler
               ? ((parentObject = initializingHandler), parentObject.deps++)
@@ -2490,7 +2490,7 @@
                   value: null,
                   reason: null,
                   deps: 1,
-                  errored: !1
+                  errored: !1,
                 }),
             null
           );
@@ -2506,7 +2506,7 @@
                   value: null,
                   reason: reference.reason,
                   deps: 0,
-                  errored: !0
+                  errored: !0,
                 }),
             null
           );
@@ -2533,17 +2533,17 @@
     function defineLazyGetter(response, chunk, parentObject, key) {
       Object.defineProperty(parentObject, key, {
         get: function () {
-          "resolved_model" === chunk.status && initializeModelChunk(chunk);
+          'resolved_model' === chunk.status && initializeModelChunk(chunk);
           switch (chunk.status) {
-            case "fulfilled":
+            case 'fulfilled':
               return chunk.value;
-            case "rejected":
+            case 'rejected':
               throw chunk.reason;
           }
-          return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
+          return 'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.';
         },
         enumerable: !0,
-        configurable: !1
+        configurable: !1,
       });
       return null;
     }
@@ -2554,56 +2554,56 @@
       return model;
     }
     function getInferredFunctionApproximate(code) {
-      code = code.startsWith("Object.defineProperty(")
+      code = code.startsWith('Object.defineProperty(')
         ? code.slice(22)
-        : code.startsWith("(")
+        : code.startsWith('(')
           ? code.slice(1)
           : code;
-      if (code.startsWith("async function")) {
-        var idx = code.indexOf("(", 14);
+      if (code.startsWith('async function')) {
+        var idx = code.indexOf('(', 14);
         if (-1 !== idx)
           return (
             (code = code.slice(14, idx).trim()),
-            (0, eval)("({" + JSON.stringify(code) + ":async function(){}})")[
+            (0, eval)('({' + JSON.stringify(code) + ':async function(){}})')[
               code
             ]
           );
-      } else if (code.startsWith("function")) {
-        if (((idx = code.indexOf("(", 8)), -1 !== idx))
+      } else if (code.startsWith('function')) {
+        if (((idx = code.indexOf('(', 8)), -1 !== idx))
           return (
             (code = code.slice(8, idx).trim()),
-            (0, eval)("({" + JSON.stringify(code) + ":function(){}})")[code]
+            (0, eval)('({' + JSON.stringify(code) + ':function(){}})')[code]
           );
       } else if (
-        code.startsWith("class") &&
-        ((idx = code.indexOf("{", 5)), -1 !== idx)
+        code.startsWith('class') &&
+        ((idx = code.indexOf('{', 5)), -1 !== idx)
       )
         return (
           (code = code.slice(5, idx).trim()),
-          (0, eval)("({" + JSON.stringify(code) + ":class{}})")[code]
+          (0, eval)('({' + JSON.stringify(code) + ':class{}})')[code]
         );
       return function () {};
     }
     function parseModelString(response, parentObject, key, value) {
-      if ("$" === value[0]) {
-        if ("$" === value)
+      if ('$' === value[0]) {
+        if ('$' === value)
           return (
             null !== initializingHandler &&
-              "0" === key &&
+              '0' === key &&
               (initializingHandler = {
                 parent: initializingHandler,
                 chunk: null,
                 value: null,
                 reason: null,
                 deps: 0,
-                errored: !1
+                errored: !1,
               }),
             REACT_ELEMENT_TYPE
           );
         switch (value[1]) {
-          case "$":
+          case '$':
             return value.slice(1);
-          case "L":
+          case 'L':
             return (
               (parentObject = parseInt(value.slice(2), 16)),
               (response = getChunk(response, parentObject)),
@@ -2612,7 +2612,7 @@
                 initializingChunk._children.push(response),
               createLazyChunkWrapper(response, 0)
             );
-          case "@":
+          case '@':
             return (
               (parentObject = parseInt(value.slice(2), 16)),
               (response = getChunk(response, parentObject)),
@@ -2621,46 +2621,46 @@
                 initializingChunk._children.push(response),
               response
             );
-          case "S":
+          case 'S':
             return Symbol.for(value.slice(2));
-          case "F":
+          case 'F':
             var ref = value.slice(2);
             return getOutlinedModel(
               response,
               ref,
               parentObject,
               key,
-              loadServerReference
+              loadServerReference,
             );
-          case "T":
-            parentObject = "$" + value.slice(2);
+          case 'T':
+            parentObject = '$' + value.slice(2);
             response = response._tempRefs;
             if (null == response)
               throw Error(
-                "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+                'Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.',
               );
             return response.get(parentObject);
-          case "Q":
+          case 'Q':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createMap)
             );
-          case "W":
+          case 'W':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createSet)
             );
-          case "B":
+          case 'B':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createBlob)
             );
-          case "K":
+          case 'K':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createFormData)
             );
-          case "Z":
+          case 'Z':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2668,10 +2668,10 @@
                 ref,
                 parentObject,
                 key,
-                resolveErrorDev
+                resolveErrorDev,
               )
             );
-          case "i":
+          case 'i':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2679,22 +2679,22 @@
                 ref,
                 parentObject,
                 key,
-                extractIterator
+                extractIterator,
               )
             );
-          case "I":
+          case 'I':
             return Infinity;
-          case "-":
-            return "$-0" === value ? -0 : -Infinity;
-          case "N":
+          case '-':
+            return '$-0' === value ? -0 : -Infinity;
+          case 'N':
             return NaN;
-          case "u":
+          case 'u':
             return;
-          case "D":
+          case 'D':
             return new Date(Date.parse(value.slice(2)));
-          case "n":
+          case 'n':
             return BigInt(value.slice(2));
-          case "P":
+          case 'P':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2702,10 +2702,10 @@
                 ref,
                 parentObject,
                 key,
-                applyConstructor
+                applyConstructor,
               )
             );
-          case "E":
+          case 'E':
             response = value.slice(2);
             try {
               if (!mightHaveStaticConstructor.test(response))
@@ -2714,46 +2714,46 @@
             try {
               if (
                 ((ref = getInferredFunctionApproximate(response)),
-                response.startsWith("Object.defineProperty("))
+                response.startsWith('Object.defineProperty('))
               ) {
                 var idx = response.lastIndexOf(',"name",{value:"');
                 if (-1 !== idx) {
                   var name = JSON.parse(
-                    response.slice(idx + 16 - 1, response.length - 2)
+                    response.slice(idx + 16 - 1, response.length - 2),
                   );
-                  Object.defineProperty(ref, "name", { value: name });
+                  Object.defineProperty(ref, 'name', { value: name });
                 }
               }
             } catch (_) {
               ref = function () {};
             }
             return ref;
-          case "Y":
+          case 'Y':
             if (
               2 < value.length &&
               (ref = response._debugChannel && response._debugChannel.callback)
             ) {
-              if ("@" === value[2])
+              if ('@' === value[2])
                 return (
                   (parentObject = value.slice(3)),
                   (key = parseInt(parentObject, 16)),
-                  response._chunks.has(key) || ref("P:" + parentObject),
+                  response._chunks.has(key) || ref('P:' + parentObject),
                   getChunk(response, key)
                 );
               value = value.slice(2);
               idx = parseInt(value, 16);
-              response._chunks.has(idx) || ref("Q:" + value);
+              response._chunks.has(idx) || ref('Q:' + value);
               ref = getChunk(response, idx);
-              return "fulfilled" === ref.status
+              return 'fulfilled' === ref.status
                 ? ref.value
                 : defineLazyGetter(response, ref, parentObject, key);
             }
             Object.defineProperty(parentObject, key, {
               get: function () {
-                return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
+                return 'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.';
               },
               enumerable: !0,
-              configurable: !1
+              configurable: !1,
             });
             return null;
           default:
@@ -2767,7 +2767,7 @@
     }
     function missingCall() {
       throw Error(
-        'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+        'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.',
       );
     }
     function ResponseInstance(
@@ -2781,7 +2781,7 @@
       findSourceMapURL,
       replayConsole,
       environmentName,
-      debugChannel
+      debugChannel,
     ) {
       var chunks = new Map();
       this._bundlerConfig = bundlerConfig;
@@ -2806,11 +2806,11 @@
           ? null
           : ReactSharedInteralsServer.A.getOwner();
       this._debugRootStack =
-        null !== bundlerConfig ? Error("react-stack-top-frame") : null;
-      environmentName = void 0 === environmentName ? "Server" : environmentName;
+        null !== bundlerConfig ? Error('react-stack-top-frame') : null;
+      environmentName = void 0 === environmentName ? 'Server' : environmentName;
       supportsCreateTask &&
         (this._debugRootTask = console.createTask(
-          '"use ' + environmentName.toLowerCase() + '"'
+          '"use ' + environmentName.toLowerCase() + '"',
         ));
       this._debugStartTime = performance.now();
       this._debugFindSourceMapURL = findSourceMapURL;
@@ -2831,21 +2831,21 @@
         _rowID: 0,
         _rowTag: 0,
         _rowLength: 0,
-        _buffer: []
+        _buffer: [],
       };
       weakResponse = unwrapWeakResponse(weakResponse);
       var debugValuePromise = Promise.resolve(streamDebugValue);
-      debugValuePromise.status = "fulfilled";
+      debugValuePromise.status = 'fulfilled';
       debugValuePromise.value = streamDebugValue;
       streamState._debugInfo = {
-        name: "RSC stream",
+        name: 'RSC stream',
         start: weakResponse._debugStartTime,
         end: weakResponse._debugStartTime,
         byteSize: 0,
         value: debugValuePromise,
         owner: weakResponse._debugRootOwner,
         debugStack: weakResponse._debugRootStack,
-        debugTask: weakResponse._debugRootTask
+        debugTask: weakResponse._debugRootTask,
       };
       streamState._debugTargetChunkSize = MIN_CHUNK_SIZE;
       return streamState;
@@ -2865,32 +2865,32 @@
             value: debugInfo.value,
             owner: debugInfo.owner,
             debugStack: debugInfo.debugStack,
-            debugTask: debugInfo.debugTask
+            debugTask: debugInfo.debugTask,
           }),
           (streamState._debugTargetChunkSize = chunkLength + MIN_CHUNK_SIZE))
         : ((debugInfo.end = endTime), (debugInfo.byteSize = chunkLength));
     }
     function addDebugInfo(chunk, debugInfo) {
       var value = resolveLazy(chunk.value);
-      "object" !== typeof value ||
+      'object' !== typeof value ||
       null === value ||
       (!isArrayImpl(value) &&
-        "function" !== typeof value[ASYNC_ITERATOR] &&
+        'function' !== typeof value[ASYNC_ITERATOR] &&
         value.$$typeof !== REACT_ELEMENT_TYPE &&
         value.$$typeof !== REACT_LAZY_TYPE)
         ? chunk._debugInfo.push.apply(chunk._debugInfo, debugInfo)
         : isArrayImpl(value._debugInfo)
           ? value._debugInfo.push.apply(value._debugInfo, debugInfo)
-          : Object.defineProperty(value, "_debugInfo", {
+          : Object.defineProperty(value, '_debugInfo', {
               configurable: !1,
               enumerable: !1,
               writable: !0,
-              value: debugInfo
+              value: debugInfo,
             });
     }
     function resolveChunkDebugInfo(streamState, chunk) {
       streamState = [{ awaited: streamState._debugInfo }];
-      "pending" === chunk.status || "blocked" === chunk.status
+      'pending' === chunk.status || 'blocked' === chunk.status
         ? ((streamState = addDebugInfo.bind(null, chunk, streamState)),
           chunk.then(streamState, streamState))
         : addDebugInfo(chunk, streamState);
@@ -2898,10 +2898,10 @@
     function resolveBuffer(response, id, buffer, streamState) {
       var chunks = response._chunks,
         chunk = chunks.get(id);
-      chunk && "pending" !== chunk.status
+      chunk && 'pending' !== chunk.status
         ? chunk.reason.enqueueValue(buffer)
         : (chunk && releasePendingChunk(response, chunk),
-          (response = new ReactPromise("fulfilled", buffer, null)),
+          (response = new ReactPromise('fulfilled', buffer, null)),
           resolveChunkDebugInfo(streamState, response),
           chunks.set(id, response));
     }
@@ -2911,20 +2911,20 @@
       model = JSON.parse(model, response._fromJSON);
       var clientReference = resolveClientReference(
         response._bundlerConfig,
-        model
+        model,
       );
       prepareDestinationWithChunks(
         response._moduleLoading,
         model[1],
-        response._nonce
+        response._nonce,
       );
       if ((model = preloadModule(clientReference))) {
         if (chunk) {
           releasePendingChunk(response, chunk);
           var blockedChunk = chunk;
-          blockedChunk.status = "blocked";
+          blockedChunk.status = 'blocked';
         } else
-          (blockedChunk = new ReactPromise("blocked", null, null)),
+          (blockedChunk = new ReactPromise('blocked', null, null)),
             chunks.set(id, blockedChunk);
         resolveChunkDebugInfo(streamState, blockedChunk);
         model.then(
@@ -2933,16 +2933,16 @@
           },
           function (error) {
             return triggerErrorOnChunk(response, blockedChunk, error);
-          }
+          },
         );
       } else
         chunk
           ? (resolveChunkDebugInfo(streamState, chunk),
             resolveModuleChunk(response, chunk, clientReference))
           : ((chunk = new ReactPromise(
-              "resolved_module",
+              'resolved_module',
               clientReference,
-              null
+              null,
             )),
             resolveChunkDebugInfo(streamState, chunk),
             chunks.set(id, chunk));
@@ -2953,7 +2953,7 @@
       if (chunk) {
         if (
           (resolveChunkDebugInfo(streamState, chunk),
-          "pending" === chunk.status)
+          'pending' === chunk.status)
         ) {
           releasePendingChunk(response, chunk);
           id = chunk.value;
@@ -2961,7 +2961,7 @@
             streamState = initializingHandler;
             chunks = initializingChunk;
             initializingHandler = null;
-            chunk.status = "blocked";
+            chunk.status = 'blocked';
             chunk.value = null;
             chunk.reason = null;
             initializingChunk = chunk;
@@ -2981,13 +2981,13 @@
               (initializingHandler = streamState), (initializingChunk = chunks);
             }
           }
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = stream;
           chunk.reason = controller;
           null !== id && wakeChunk(id, chunk.value, chunk);
         }
       } else
-        (response = new ReactPromise("fulfilled", stream, controller)),
+        (response = new ReactPromise('fulfilled', stream, controller)),
           resolveChunkDebugInfo(streamState, response),
           chunks.set(id, response);
     }
@@ -2997,7 +2997,7 @@
         type: type,
         start: function (c) {
           controller = c;
-        }
+        },
       });
       var previousBlockedChunk = null;
       resolveStream(
@@ -3016,7 +3016,7 @@
             if (null === previousBlockedChunk) {
               var chunk = createResolvedModelChunk(response, json);
               initializeModelChunk(chunk);
-              "fulfilled" === chunk.status
+              'fulfilled' === chunk.status
                 ? controller.enqueue(chunk.value)
                 : (chunk.then(
                     function (v) {
@@ -3024,7 +3024,7 @@
                     },
                     function (e) {
                       return controller.error(e);
-                    }
+                    },
                   ),
                   (previousBlockedChunk = chunk));
             } else {
@@ -3036,7 +3036,7 @@
                 },
                 function (e) {
                   return controller.error(e);
-                }
+                },
               );
               previousBlockedChunk = _chunk3;
               chunk.then(function () {
@@ -3065,9 +3065,9 @@
                 return controller.error(error);
               });
             }
-          }
+          },
         },
-        streamState
+        streamState,
       );
     }
     function asyncIterator() {
@@ -3088,14 +3088,14 @@
         return createIterator(function (arg) {
           if (void 0 !== arg)
             throw Error(
-              "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+              'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
             );
           if (nextReadIndex === buffer.length) {
             if (closed)
               return new ReactPromise(
-                "fulfilled",
+                'fulfilled',
                 { done: !0, value: void 0 },
-                null
+                null,
               );
             buffer[nextReadIndex] = createPendingChunk(response);
           }
@@ -3110,21 +3110,21 @@
           enqueueValue: function (value) {
             if (nextWriteIndex === buffer.length)
               buffer[nextWriteIndex] = new ReactPromise(
-                "fulfilled",
+                'fulfilled',
                 { done: !1, value: value },
-                null
+                null,
               );
             else {
               var chunk = buffer[nextWriteIndex],
                 resolveListeners = chunk.value,
                 rejectListeners = chunk.reason;
-              chunk.status = "fulfilled";
+              chunk.status = 'fulfilled';
               chunk.value = { done: !1, value: value };
               null !== resolveListeners &&
                 wakeChunkIfInitialized(
                   chunk,
                   resolveListeners,
-                  rejectListeners
+                  rejectListeners,
                 );
             }
             nextWriteIndex++;
@@ -3134,13 +3134,13 @@
               ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                   response,
                   value,
-                  !1
+                  !1,
                 ))
               : resolveIteratorResultChunk(
                   response,
                   buffer[nextWriteIndex],
                   value,
-                  !1
+                  !1,
                 );
             nextWriteIndex++;
           },
@@ -3150,20 +3150,20 @@
               ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                   response,
                   value,
-                  !0
+                  !0,
                 ))
               : resolveIteratorResultChunk(
                   response,
                   buffer[nextWriteIndex],
                   value,
-                  !0
+                  !0,
                 );
             for (nextWriteIndex++; nextWriteIndex < buffer.length; )
               resolveIteratorResultChunk(
                 response,
                 buffer[nextWriteIndex++],
                 '"$undefined"',
-                !0
+                !0,
               );
           },
           error: function (error) {
@@ -3175,9 +3175,9 @@
 
             )
               triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);
-          }
+          },
         },
-        streamState
+        streamState,
       );
     }
     function resolveErrorDev(response, errorInfo) {
@@ -3191,8 +3191,8 @@
         Error.bind(
           null,
           errorInfo.message ||
-            "An error occurred in the Server Components render but no message was provided"
-        )
+            'An error occurred in the Server Components render but no message was provided',
+        ),
       );
       var ownerTask = null;
       null != errorInfo.owner &&
@@ -3201,8 +3201,8 @@
           response,
           errorInfo,
           {},
-          "",
-          createModel
+          '',
+          createModel,
         )),
         null !== errorInfo &&
           (ownerTask = initializeFakeTask(response, errorInfo)));
@@ -3222,9 +3222,9 @@
       col,
       enclosingLine,
       enclosingCol,
-      environmentName
+      environmentName,
     ) {
-      name || (name = "<anonymous>");
+      name || (name = '<anonymous>');
       var encodedName = JSON.stringify(name);
       1 > enclosingLine ? (enclosingLine = 0) : enclosingLine--;
       1 > enclosingCol ? (enclosingCol = 0) : enclosingCol--;
@@ -3242,66 +3242,66 @@
           (col = col - enclosingCol - line - 3),
           0 > col && (col = 0),
           (encodedName =
-            "({" +
+            '({' +
             encodedName +
-            ":" +
-            " ".repeat(enclosingCol) +
-            "_=>" +
-            " ".repeat(col) +
-            "_()})"))
+            ':' +
+            ' '.repeat(enclosingCol) +
+            '_=>' +
+            ' '.repeat(col) +
+            '_()})'))
         : 1 > enclosingLine
           ? ((enclosingCol -= encodedName.length + 3),
             0 > enclosingCol && (enclosingCol = 0),
             (encodedName =
-              "({" +
+              '({' +
               encodedName +
-              ":" +
-              " ".repeat(enclosingCol) +
-              "_=>" +
-              "\n".repeat(line - enclosingLine) +
-              " ".repeat(col) +
-              "_()})"))
+              ':' +
+              ' '.repeat(enclosingCol) +
+              '_=>' +
+              '\n'.repeat(line - enclosingLine) +
+              ' '.repeat(col) +
+              '_()})'))
           : enclosingLine === line
             ? ((col = col - enclosingCol - 3),
               0 > col && (col = 0),
               (encodedName =
-                "\n".repeat(enclosingLine - 1) +
-                "({" +
+                '\n'.repeat(enclosingLine - 1) +
+                '({' +
                 encodedName +
-                ":\n" +
-                " ".repeat(enclosingCol) +
-                "_=>" +
-                " ".repeat(col) +
-                "_()})"))
+                ':\n' +
+                ' '.repeat(enclosingCol) +
+                '_=>' +
+                ' '.repeat(col) +
+                '_()})'))
             : (encodedName =
-                "\n".repeat(enclosingLine - 1) +
-                "({" +
+                '\n'.repeat(enclosingLine - 1) +
+                '({' +
                 encodedName +
-                ":\n" +
-                " ".repeat(enclosingCol) +
-                "_=>" +
-                "\n".repeat(line - enclosingLine) +
-                " ".repeat(col) +
-                "_()})");
+                ':\n' +
+                ' '.repeat(enclosingCol) +
+                '_=>' +
+                '\n'.repeat(line - enclosingLine) +
+                ' '.repeat(col) +
+                '_()})');
       encodedName =
         1 > enclosingLine
           ? encodedName +
-            "\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */"
-          : "/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */" +
+            '\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */'
+          : '/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */' +
             encodedName;
-      filename.startsWith("/") && (filename = "file://" + filename);
+      filename.startsWith('/') && (filename = 'file://' + filename);
       sourceMap
         ? ((encodedName +=
-            "\n//# sourceURL=about://React/" +
+            '\n//# sourceURL=about://React/' +
             encodeURIComponent(environmentName) +
-            "/" +
+            '/' +
             encodeURI(filename) +
-            "?" +
+            '?' +
             fakeFunctionIdx++),
-          (encodedName += "\n//# sourceMappingURL=" + sourceMap))
+          (encodedName += '\n//# sourceMappingURL=' + sourceMap))
         : (encodedName = filename
-            ? encodedName + ("\n//# sourceURL=" + encodeURI(filename))
-            : encodedName + "\n//# sourceURL=<anonymous>");
+            ? encodedName + ('\n//# sourceURL=' + encodeURI(filename))
+            : encodedName + '\n//# sourceURL=<anonymous>');
       try {
         var fn = (0, eval)(encodedName)[name];
       } catch (x) {
@@ -3316,15 +3316,15 @@
       stack,
       environmentName,
       useEnclosingLine,
-      innerCall
+      innerCall,
     ) {
       for (var i = 0; i < stack.length; i++) {
         var frame = stack[i],
           frameKey =
-            frame.join("-") +
-            "-" +
+            frame.join('-') +
+            '-' +
             environmentName +
-            (useEnclosingLine ? "-e" : "-n"),
+            (useEnclosingLine ? '-e' : '-n'),
           fn = fakeFunctionCache.get(frameKey);
         if (void 0 === fn) {
           fn = frame[0];
@@ -3345,7 +3345,7 @@
             col,
             useEnclosingLine ? line : enclosingLine,
             useEnclosingLine ? col : frame,
-            environmentName
+            environmentName,
           );
           fakeFunctionCache.set(frameKey, fn);
         }
@@ -3359,7 +3359,7 @@
         ? response._rootEnvironmentName !== childEnvironmentName
           ? ((response = console.createTask.bind(
               console,
-              '"use ' + childEnvironmentName.toLowerCase() + '"'
+              '"use ' + childEnvironmentName.toLowerCase() + '"',
             )),
             rootTask.run(response))
           : rootTask
@@ -3385,17 +3385,17 @@
         env !== cachedEntry
           ? '"use ' + env.toLowerCase() + '"'
           : void 0 !== debugInfo.key
-            ? "<" + (debugInfo.name || "...") + ">"
+            ? '<' + (debugInfo.name || '...') + '>'
             : void 0 !== debugInfo.name
-              ? debugInfo.name || "unknown"
-              : "await " + (debugInfo.awaited.name || "unknown");
+              ? debugInfo.name || 'unknown'
+              : 'await ' + (debugInfo.awaited.name || 'unknown');
       env = console.createTask.bind(console, env);
       useEnclosingLine = buildFakeCallStack(
         response,
         stack,
         cachedEntry,
         useEnclosingLine,
-        env
+        env,
       );
       null === ownerTask
         ? ((response = getRootTask(response, cachedEntry)),
@@ -3407,7 +3407,7 @@
       return (debugInfo.debugTask = response);
     }
     function fakeJSXCallSite() {
-      return Error("react-stack-top-frame");
+      return Error('react-stack-top-frame');
     }
     function initializeFakeStack(response, debugInfo) {
       if (void 0 === debugInfo.debugStack) {
@@ -3415,7 +3415,7 @@
           (debugInfo.debugStack = createFakeJSXCallStackInDEV(
             response,
             debugInfo.stack,
-            null == debugInfo.env ? "" : debugInfo.env
+            null == debugInfo.env ? '' : debugInfo.env,
           ));
         var owner = debugInfo.owner;
         null != owner &&
@@ -3435,16 +3435,16 @@
         _componentInfoOrAsyncInfo.debugTask = response._debugRootTask;
       } else
         void 0 !== debugInfo.stack && initializeFakeStack(response, debugInfo);
-      "number" === typeof debugInfo.time &&
+      'number' === typeof debugInfo.time &&
         (debugInfo = { time: debugInfo.time + response._timeOrigin });
       return debugInfo;
     }
     function getCurrentStackInDEV() {
       var owner = currentOwnerInDEV;
-      if (null === owner) return "";
+      if (null === owner) return '';
       try {
-        var info = "";
-        if (owner.owner || "string" !== typeof owner.name) {
+        var info = '';
+        if (owner.owner || 'string' !== typeof owner.name) {
           for (; owner; ) {
             var ownerStack = owner.debugStack;
             if (null != ownerStack) {
@@ -3455,16 +3455,16 @@
                 Error.prepareStackTrace = prepareStackTrace;
                 var stack = error.stack;
                 Error.prepareStackTrace = prevPrepareStackTrace;
-                stack.startsWith("Error: react-stack-top-frame\n") &&
+                stack.startsWith('Error: react-stack-top-frame\n') &&
                   (stack = stack.slice(29));
-                var idx = stack.indexOf("\n");
+                var idx = stack.indexOf('\n');
                 -1 !== idx && (stack = stack.slice(idx + 1));
-                idx = stack.indexOf("react_stack_bottom_frame");
-                -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
+                idx = stack.indexOf('react_stack_bottom_frame');
+                -1 !== idx && (idx = stack.lastIndexOf('\n', idx));
                 var JSCompiler_inline_result =
-                  -1 !== idx ? (stack = stack.slice(0, idx)) : "";
+                  -1 !== idx ? (stack = stack.slice(0, idx)) : '';
                 info =
-                  JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
+                  JSCompiler_temp_const + ('\n' + JSCompiler_inline_result);
               }
             } else break;
           }
@@ -3477,20 +3477,20 @@
             } catch (x) {
               (prefix =
                 ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) ||
-                ""),
+                ''),
                 (suffix =
-                  -1 < x.stack.indexOf("\n    at")
-                    ? " (<anonymous>)"
-                    : -1 < x.stack.indexOf("@")
-                      ? "@unknown:0:0"
-                      : "");
+                  -1 < x.stack.indexOf('\n    at')
+                    ? ' (<anonymous>)'
+                    : -1 < x.stack.indexOf('@')
+                      ? '@unknown:0:0'
+                      : '');
             }
           JSCompiler_inline_result$jscomp$0 =
-            "\n" + prefix + JSCompiler_temp_const + suffix;
+            '\n' + prefix + JSCompiler_temp_const + suffix;
         }
       } catch (x) {
         JSCompiler_inline_result$jscomp$0 =
-          "\nError generating stack: " + x.message + "\n" + x.stack;
+          '\nError generating stack: ' + x.message + '\n' + x.stack;
       }
       return JSCompiler_inline_result$jscomp$0;
     }
@@ -3500,13 +3500,13 @@
         if (null == blockedChunk)
           (blockedChunk = createResolvedModelChunk(response, json)),
             initializeModelChunk(blockedChunk),
-            "fulfilled" === blockedChunk.status
+            'fulfilled' === blockedChunk.status
               ? replayConsoleWithCallStackInDEV(response, blockedChunk.value)
               : (blockedChunk.then(
                   function (v) {
                     return replayConsoleWithCallStackInDEV(response, v);
                   },
-                  function () {}
+                  function () {},
                 ),
                 (response._blockedConsole = blockedChunk));
         else {
@@ -3515,7 +3515,7 @@
             function (v) {
               return replayConsoleWithCallStackInDEV(response, v);
             },
-            function () {}
+            function () {},
           );
           response._blockedConsole = _chunk4;
           var unblock = function () {
@@ -3538,16 +3538,16 @@
         var promise = ioInfo.value;
         if (promise)
           switch (promise.status) {
-            case "fulfilled":
+            case 'fulfilled':
               logIOInfo(ioInfo, response, promise.value);
               break;
-            case "rejected":
+            case 'rejected':
               logIOInfoErrored(ioInfo, response, promise.reason);
               break;
             default:
               promise.then(
                 logIOInfo.bind(null, ioInfo, response),
-                logIOInfoErrored.bind(null, ioInfo, response)
+                logIOInfoErrored.bind(null, ioInfo, response),
               );
           }
         else logIOInfo(ioInfo, response, void 0);
@@ -3558,17 +3558,17 @@
         chunk = chunks.get(id);
       chunk
         ? (resolveModelChunk(response, chunk, model),
-          "resolved_model" === chunk.status && initializeModelChunk(chunk))
+          'resolved_model' === chunk.status && initializeModelChunk(chunk))
         : ((chunk = createResolvedModelChunk(response, model)),
           chunks.set(id, chunk),
           initializeModelChunk(chunk));
-      "fulfilled" === chunk.status
+      'fulfilled' === chunk.status
         ? initializeIOInfo(response, chunk.value)
         : chunk.then(
             function (v) {
               initializeIOInfo(response, v);
             },
-            function () {}
+            function () {},
           );
     }
     function mergeBuffer(buffer, lastChunk) {
@@ -3594,7 +3594,7 @@
       lastChunk,
       constructor,
       bytesPerElement,
-      streamState
+      streamState,
     ) {
       buffer =
         0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
@@ -3603,7 +3603,7 @@
       constructor = new constructor(
         buffer.buffer,
         buffer.byteOffset,
-        buffer.byteLength / bytesPerElement
+        buffer.byteLength / bytesPerElement,
       );
       resolveBuffer(response, id, constructor, streamState);
     }
@@ -3612,7 +3612,7 @@
       root,
       trackIdx$jscomp$6,
       trackTime,
-      parentEndTime
+      parentEndTime,
     ) {
       if (!isArrayImpl(root._children)) {
         var previousResult = root._children,
@@ -3628,9 +3628,9 @@
           if (supportsUserTiming && 0 <= previousEndTime && 10 > trackIdx) {
             var color =
                 componentInfo.env === response$jscomp$0._rootEnvironmentName
-                  ? "primary-light"
-                  : "secondary-light",
-              entryName = componentInfo.name + " [deduped]",
+                  ? 'primary-light'
+                  : 'secondary-light',
+              entryName = componentInfo.name + ' [deduped]',
               debugTask = componentInfo.debugTask;
             debugTask
               ? debugTask.run(
@@ -3640,17 +3640,17 @@
                     0 > startTime ? 0 : startTime,
                     previousEndTime,
                     trackNames[trackIdx],
-                    "Server Components \u269b",
-                    color
-                  )
+                    'Server Components \u269b',
+                    color,
+                  ),
                 )
               : console.timeStamp(
                   entryName,
                   0 > startTime ? 0 : startTime,
                   previousEndTime,
                   trackNames[trackIdx],
-                  "Server Components \u269b",
-                  color
+                  'Server Components \u269b',
+                  color,
                 );
           }
         }
@@ -3662,8 +3662,8 @@
       if (debugInfo) {
         for (var startTime$jscomp$0 = 0, i = 0; i < debugInfo.length; i++) {
           var info = debugInfo[i];
-          "number" === typeof info.time && (startTime$jscomp$0 = info.time);
-          if ("string" === typeof info.name) {
+          'number' === typeof info.time && (startTime$jscomp$0 = info.time);
+          if ('string' === typeof info.name) {
             startTime$jscomp$0 < trackTime && trackIdx$jscomp$6++;
             trackTime = startTime$jscomp$0;
             break;
@@ -3671,7 +3671,7 @@
         }
         for (var _i4 = debugInfo.length - 1; 0 <= _i4; _i4--) {
           var _info = debugInfo[_i4];
-          if ("number" === typeof _info.time && _info.time > parentEndTime) {
+          if ('number' === typeof _info.time && _info.time > parentEndTime) {
             parentEndTime = _info.time;
             break;
           }
@@ -3680,7 +3680,7 @@
       var result = {
         track: trackIdx$jscomp$6,
         endTime: -Infinity,
-        component: null
+        component: null,
       };
       root._children = result;
       for (
@@ -3696,7 +3696,7 @@
           children[_i5],
           childTrackIdx,
           childTrackTime,
-          parentEndTime
+          parentEndTime,
         );
         null !== childResult.component &&
           (result.component = childResult.component);
@@ -3716,13 +3716,13 @@
           _i6--
         ) {
           var _info2 = debugInfo[_i6];
-          if ("number" === typeof _info2.time) {
+          if ('number' === typeof _info2.time) {
             0 === componentEndTime && (componentEndTime = _info2.time);
             var time = _info2.time;
             if (-1 < endTimeIdx)
               for (var j = endTimeIdx - 1; j > _i6; j--) {
                 var candidateInfo = debugInfo[j];
-                if ("string" === typeof candidateInfo.name) {
+                if ('string' === typeof candidateInfo.name) {
                   componentEndTime > childrenEndTime &&
                     (childrenEndTime = componentEndTime);
                   var componentInfo$jscomp$0 = candidateInfo,
@@ -3734,7 +3734,7 @@
                     childrenEndTime$jscomp$0 = childrenEndTime;
                   if (
                     isLastComponent &&
-                    "rejected" === root.status &&
+                    'rejected' === root.status &&
                     root.reason !== response._closedReason
                   ) {
                     var componentInfo$jscomp$2 = componentInfo$jscomp$1,
@@ -3749,44 +3749,44 @@
                           env === response._rootEnvironmentName ||
                           void 0 === env
                             ? name
-                            : name + " [" + env + "]",
+                            : name + ' [' + env + ']',
                         properties = [
                           [
-                            "Error",
-                            "object" === typeof error &&
+                            'Error',
+                            'object' === typeof error &&
                             null !== error &&
-                            "string" === typeof error.message
+                            'string' === typeof error.message
                               ? String(error.message)
-                              : String(error)
-                          ]
+                              : String(error),
+                          ],
                         ];
                       null != componentInfo$jscomp$2.key &&
                         addValueToProperties(
-                          "key",
+                          'key',
                           componentInfo$jscomp$2.key,
                           properties,
                           0,
-                          ""
+                          '',
                         );
                       null != componentInfo$jscomp$2.props &&
                         addObjectToProperties(
                           componentInfo$jscomp$2.props,
                           properties,
                           0,
-                          ""
+                          '',
                         );
-                      performance.measure("\u200b" + entryName$jscomp$0, {
+                      performance.measure('\u200b' + entryName$jscomp$0, {
                         start: 0 > startTime$jscomp$2 ? 0 : startTime$jscomp$2,
                         end: childrenEndTime$jscomp$1,
                         detail: {
                           devtools: {
-                            color: "error",
+                            color: 'error',
                             track: trackNames[trackIdx$jscomp$1],
-                            trackGroup: "Server Components \u269b",
-                            tooltipText: entryName$jscomp$0 + " Errored",
-                            properties: properties
-                          }
-                        }
+                            trackGroup: 'Server Components \u269b',
+                            tooltipText: entryName$jscomp$0 + ' Errored',
+                            properties: properties,
+                          },
+                        },
                       });
                     }
                   } else {
@@ -3808,43 +3808,43 @@
                         color$jscomp$0 =
                           0.5 > selfTime
                             ? isPrimaryEnv
-                              ? "primary-light"
-                              : "secondary-light"
+                              ? 'primary-light'
+                              : 'secondary-light'
                             : 50 > selfTime
                               ? isPrimaryEnv
-                                ? "primary"
-                                : "secondary"
+                                ? 'primary'
+                                : 'secondary'
                               : 500 > selfTime
                                 ? isPrimaryEnv
-                                  ? "primary-dark"
-                                  : "secondary-dark"
-                                : "error",
+                                  ? 'primary-dark'
+                                  : 'secondary-dark'
+                                : 'error',
                         entryName$jscomp$1 =
                           isPrimaryEnv || void 0 === env$jscomp$0
                             ? name$jscomp$0
-                            : name$jscomp$0 + " [" + env$jscomp$0 + "]",
+                            : name$jscomp$0 + ' [' + env$jscomp$0 + ']',
                         debugTask$jscomp$0 = componentInfo$jscomp$3.debugTask;
                       if (debugTask$jscomp$0) {
                         var properties$jscomp$0 = [];
                         null != componentInfo$jscomp$3.key &&
                           addValueToProperties(
-                            "key",
+                            'key',
                             componentInfo$jscomp$3.key,
                             properties$jscomp$0,
                             0,
-                            ""
+                            '',
                           );
                         null != componentInfo$jscomp$3.props &&
                           addObjectToProperties(
                             componentInfo$jscomp$3.props,
                             properties$jscomp$0,
                             0,
-                            ""
+                            '',
                           );
                         debugTask$jscomp$0.run(
                           performance.measure.bind(
                             performance,
-                            "\u200b" + entryName$jscomp$1,
+                            '\u200b' + entryName$jscomp$1,
                             {
                               start:
                                 0 > startTime$jscomp$3 ? 0 : startTime$jscomp$3,
@@ -3853,21 +3853,21 @@
                                 devtools: {
                                   color: color$jscomp$0,
                                   track: trackNames[trackIdx$jscomp$2],
-                                  trackGroup: "Server Components \u269b",
-                                  properties: properties$jscomp$0
-                                }
-                              }
-                            }
-                          )
+                                  trackGroup: 'Server Components \u269b',
+                                  properties: properties$jscomp$0,
+                                },
+                              },
+                            },
+                          ),
                         );
                       } else
                         console.timeStamp(
-                          "\u200b" + entryName$jscomp$1,
+                          '\u200b' + entryName$jscomp$1,
                           0 > startTime$jscomp$3 ? 0 : startTime$jscomp$3,
                           childrenEndTime$jscomp$2,
                           trackNames[trackIdx$jscomp$2],
-                          "Server Components \u269b",
-                          color$jscomp$0
+                          'Server Components \u269b',
+                          color$jscomp$0,
                         );
                     }
                   }
@@ -3885,17 +3885,17 @@
                   if (promise) {
                     var thenable = promise;
                     switch (thenable.status) {
-                      case "fulfilled":
+                      case 'fulfilled':
                         logComponentAwait(
                           asyncInfo,
                           trackIdx$jscomp$6,
                           time,
                           endTime,
                           env$jscomp$1,
-                          thenable.value
+                          thenable.value,
                         );
                         break;
-                      case "rejected":
+                      case 'rejected':
                         var asyncInfo$jscomp$0 = asyncInfo,
                           trackIdx$jscomp$3 = trackIdx$jscomp$6,
                           startTime$jscomp$4 = time,
@@ -3905,12 +3905,12 @@
                         if (supportsUserTiming && 0 < endTime$jscomp$0) {
                           var description = getIODescription(error$jscomp$0),
                             entryName$jscomp$2 =
-                              "await " +
+                              'await ' +
                               getIOShortName(
                                 asyncInfo$jscomp$0.awaited,
                                 description,
                                 asyncInfo$jscomp$0.env,
-                                rootEnv
+                                rootEnv,
                               ),
                             debugTask$jscomp$1 =
                               asyncInfo$jscomp$0.debugTask ||
@@ -3918,21 +3918,21 @@
                           if (debugTask$jscomp$1) {
                             var properties$jscomp$1 = [
                                 [
-                                  "Rejected",
-                                  "object" === typeof error$jscomp$0 &&
+                                  'Rejected',
+                                  'object' === typeof error$jscomp$0 &&
                                   null !== error$jscomp$0 &&
-                                  "string" === typeof error$jscomp$0.message
+                                  'string' === typeof error$jscomp$0.message
                                     ? String(error$jscomp$0.message)
-                                    : String(error$jscomp$0)
-                                ]
+                                    : String(error$jscomp$0),
+                                ],
                               ],
                               tooltipText =
                                 getIOLongName(
                                   asyncInfo$jscomp$0.awaited,
                                   description,
                                   asyncInfo$jscomp$0.env,
-                                  rootEnv
-                                ) + " Rejected";
+                                  rootEnv,
+                                ) + ' Rejected';
                             debugTask$jscomp$1.run(
                               performance.measure.bind(
                                 performance,
@@ -3945,15 +3945,15 @@
                                   end: endTime$jscomp$0,
                                   detail: {
                                     devtools: {
-                                      color: "error",
+                                      color: 'error',
                                       track: trackNames[trackIdx$jscomp$3],
-                                      trackGroup: "Server Components \u269b",
+                                      trackGroup: 'Server Components \u269b',
                                       properties: properties$jscomp$1,
-                                      tooltipText: tooltipText
-                                    }
-                                  }
-                                }
-                              )
+                                      tooltipText: tooltipText,
+                                    },
+                                  },
+                                },
+                              ),
                             );
                           } else
                             console.timeStamp(
@@ -3961,8 +3961,8 @@
                               0 > startTime$jscomp$4 ? 0 : startTime$jscomp$4,
                               endTime$jscomp$0,
                               trackNames[trackIdx$jscomp$3],
-                              "Server Components \u269b",
-                              "error"
+                              'Server Components \u269b',
+                              'error',
                             );
                         }
                         break;
@@ -3973,7 +3973,7 @@
                           time,
                           endTime,
                           env$jscomp$1,
-                          void 0
+                          void 0,
                         );
                     }
                   } else
@@ -3983,7 +3983,7 @@
                       time,
                       endTime,
                       env$jscomp$1,
-                      void 0
+                      void 0,
                     );
                 }
               }
@@ -3991,7 +3991,7 @@
               endTime = time;
               for (var _j = debugInfo.length - 1; _j > _i6; _j--) {
                 var _candidateInfo = debugInfo[_j];
-                if ("string" === typeof _candidateInfo.name) {
+                if ('string' === typeof _candidateInfo.name) {
                   componentEndTime > childrenEndTime &&
                     (childrenEndTime = componentEndTime);
                   var _componentInfo = _candidateInfo,
@@ -4006,40 +4006,40 @@
                       entryName$jscomp$3 =
                         env$jscomp$2 === _env || void 0 === env$jscomp$2
                           ? name$jscomp$1
-                          : name$jscomp$1 + " [" + env$jscomp$2 + "]",
+                          : name$jscomp$1 + ' [' + env$jscomp$2 + ']',
                       properties$jscomp$2 = [
                         [
-                          "Aborted",
-                          "The stream was aborted before this Component finished rendering."
-                        ]
+                          'Aborted',
+                          'The stream was aborted before this Component finished rendering.',
+                        ],
                       ];
                     null != componentInfo$jscomp$4.key &&
                       addValueToProperties(
-                        "key",
+                        'key',
                         componentInfo$jscomp$4.key,
                         properties$jscomp$2,
                         0,
-                        ""
+                        '',
                       );
                     null != componentInfo$jscomp$4.props &&
                       addObjectToProperties(
                         componentInfo$jscomp$4.props,
                         properties$jscomp$2,
                         0,
-                        ""
+                        '',
                       );
-                    performance.measure("\u200b" + entryName$jscomp$3, {
+                    performance.measure('\u200b' + entryName$jscomp$3, {
                       start: 0 > startTime$jscomp$5 ? 0 : startTime$jscomp$5,
                       end: childrenEndTime$jscomp$3,
                       detail: {
                         devtools: {
-                          color: "warning",
+                          color: 'warning',
                           track: trackNames[trackIdx$jscomp$4],
-                          trackGroup: "Server Components \u269b",
-                          tooltipText: entryName$jscomp$3 + " Aborted",
-                          properties: properties$jscomp$2
-                        }
-                      }
+                          trackGroup: 'Server Components \u269b',
+                          tooltipText: entryName$jscomp$3 + ' Aborted',
+                          properties: properties$jscomp$2,
+                        },
+                      },
                     });
                   }
                   componentEndTime = time;
@@ -4061,12 +4061,12 @@
                     rootEnv$jscomp$0 = _env2;
                   if (supportsUserTiming && 0 < endTime$jscomp$1) {
                     var entryName$jscomp$4 =
-                        "await " +
+                        'await ' +
                         getIOShortName(
                           asyncInfo$jscomp$1.awaited,
-                          "",
+                          '',
                           asyncInfo$jscomp$1.env,
-                          rootEnv$jscomp$0
+                          rootEnv$jscomp$0,
                         ),
                       debugTask$jscomp$2 =
                         asyncInfo$jscomp$1.debugTask ||
@@ -4075,10 +4075,10 @@
                       var tooltipText$jscomp$0 =
                         getIOLongName(
                           asyncInfo$jscomp$1.awaited,
-                          "",
+                          '',
                           asyncInfo$jscomp$1.env,
-                          rootEnv$jscomp$0
-                        ) + " Aborted";
+                          rootEnv$jscomp$0,
+                        ) + ' Aborted';
                       debugTask$jscomp$2.run(
                         performance.measure.bind(
                           performance,
@@ -4089,20 +4089,20 @@
                             end: endTime$jscomp$1,
                             detail: {
                               devtools: {
-                                color: "warning",
+                                color: 'warning',
                                 track: trackNames[trackIdx$jscomp$5],
-                                trackGroup: "Server Components \u269b",
+                                trackGroup: 'Server Components \u269b',
                                 properties: [
                                   [
-                                    "Aborted",
-                                    "The stream was aborted before this Promise resolved."
-                                  ]
+                                    'Aborted',
+                                    'The stream was aborted before this Promise resolved.',
+                                  ],
                                 ],
-                                tooltipText: tooltipText$jscomp$0
-                              }
-                            }
-                          }
-                        )
+                                tooltipText: tooltipText$jscomp$0,
+                              },
+                            },
+                          },
+                        ),
                       );
                     } else
                       console.timeStamp(
@@ -4110,8 +4110,8 @@
                         0 > startTime$jscomp$6 ? 0 : startTime$jscomp$6,
                         endTime$jscomp$1,
                         trackNames[trackIdx$jscomp$5],
-                        "Server Components \u269b",
-                        "warning"
+                        'Server Components \u269b',
+                        'warning',
                       );
                   }
                 }
@@ -4134,7 +4134,7 @@
             rootChunk,
             0,
             -Infinity,
-            -Infinity
+            -Infinity,
           ));
       }
     }
@@ -4144,7 +4144,7 @@
       id,
       tag,
       buffer,
-      chunk
+      chunk,
     ) {
       switch (tag) {
         case 65:
@@ -4152,7 +4152,7 @@
             response,
             id,
             mergeBuffer(buffer, chunk).buffer,
-            streamState
+            streamState,
           );
           return;
         case 79:
@@ -4163,7 +4163,7 @@
             chunk,
             Int8Array,
             1,
-            streamState
+            streamState,
           );
           return;
         case 111:
@@ -4171,7 +4171,7 @@
             response,
             id,
             0 === buffer.length ? chunk : mergeBuffer(buffer, chunk),
-            streamState
+            streamState,
           );
           return;
         case 85:
@@ -4182,7 +4182,7 @@
             chunk,
             Uint8ClampedArray,
             1,
-            streamState
+            streamState,
           );
           return;
         case 83:
@@ -4193,7 +4193,7 @@
             chunk,
             Int16Array,
             2,
-            streamState
+            streamState,
           );
           return;
         case 115:
@@ -4204,7 +4204,7 @@
             chunk,
             Uint16Array,
             2,
-            streamState
+            streamState,
           );
           return;
         case 76:
@@ -4215,7 +4215,7 @@
             chunk,
             Int32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 108:
@@ -4226,7 +4226,7 @@
             chunk,
             Uint32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 71:
@@ -4237,7 +4237,7 @@
             chunk,
             Float32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 103:
@@ -4248,7 +4248,7 @@
             chunk,
             Float64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 77:
@@ -4259,7 +4259,7 @@
             chunk,
             BigInt64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 109:
@@ -4270,7 +4270,7 @@
             chunk,
             BigUint64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 86:
@@ -4281,12 +4281,12 @@
             chunk,
             DataView,
             1,
-            streamState
+            streamState,
           );
           return;
       }
       for (
-        var stringDecoder = response._stringDecoder, row = "", i = 0;
+        var stringDecoder = response._stringDecoder, row = '', i = 0;
         i < buffer.length;
         i++
       )
@@ -4305,42 +4305,42 @@
           response = JSON.parse(streamState, response._fromJSON);
           streamState = ReactDOMSharedInternals.d;
           switch (id) {
-            case "D":
+            case 'D':
               streamState.D(response);
               break;
-            case "C":
-              "string" === typeof response
+            case 'C':
+              'string' === typeof response
                 ? streamState.C(response)
                 : streamState.C(response[0], response[1]);
               break;
-            case "L":
+            case 'L':
               id = response[0];
               row = response[1];
               3 === response.length
                 ? streamState.L(id, row, response[2])
                 : streamState.L(id, row);
               break;
-            case "m":
-              "string" === typeof response
+            case 'm':
+              'string' === typeof response
                 ? streamState.m(response)
                 : streamState.m(response[0], response[1]);
               break;
-            case "X":
-              "string" === typeof response
+            case 'X':
+              'string' === typeof response
                 ? streamState.X(response)
                 : streamState.X(response[0], response[1]);
               break;
-            case "S":
-              "string" === typeof response
+            case 'S':
+              'string' === typeof response
                 ? streamState.S(response)
                 : streamState.S(
                     response[0],
                     0 === response[1] ? void 0 : response[1],
-                    3 === response.length ? response[2] : void 0
+                    3 === response.length ? response[2] : void 0,
                   );
               break;
-            case "M":
-              "string" === typeof response
+            case 'M':
+              'string' === typeof response
                 ? streamState.M(response)
                 : streamState.M(response[0], response[1]);
           }
@@ -4354,16 +4354,16 @@
           chunk
             ? (resolveChunkDebugInfo(streamState, chunk),
               triggerErrorOnChunk(response, chunk, error))
-            : ((response = new ReactPromise("rejected", null, error)),
+            : ((response = new ReactPromise('rejected', null, error)),
               resolveChunkDebugInfo(streamState, response),
               tag.set(id, response));
           break;
         case 84:
           tag = response._chunks;
-          (chunk = tag.get(id)) && "pending" !== chunk.status
+          (chunk = tag.get(id)) && 'pending' !== chunk.status
             ? chunk.reason.enqueueValue(row)
             : (chunk && releasePendingChunk(response, chunk),
-              (response = new ReactPromise("fulfilled", row, null)),
+              (response = new ReactPromise('fulfilled', row, null)),
               resolveChunkDebugInfo(streamState, response),
               tag.set(id, response));
           break;
@@ -4372,24 +4372,24 @@
           break;
         case 68:
           id = getChunk(response, id);
-          "fulfilled" !== id.status &&
-            "rejected" !== id.status &&
-            "halted" !== id.status &&
-            "blocked" !== id.status &&
-            "resolved_module" !== id.status &&
+          'fulfilled' !== id.status &&
+            'rejected' !== id.status &&
+            'halted' !== id.status &&
+            'blocked' !== id.status &&
+            'resolved_module' !== id.status &&
             ((streamState = id._debugChunk),
             (tag = createResolvedModelChunk(response, row)),
             (tag._debugChunk = streamState),
             (id._debugChunk = tag),
             initializeDebugChunk(response, id),
-            "blocked" !== tag.status ||
+            'blocked' !== tag.status ||
               (void 0 !== response._debugChannel &&
                 response._debugChannel.hasReadable) ||
               '"' !== row[0] ||
-              "$" !== row[1] ||
-              ((streamState = row.slice(2, row.length - 1).split(":")),
+              '$' !== row[1] ||
+              ((streamState = row.slice(2, row.length - 1).split(':')),
               (streamState = parseInt(streamState[0], 16)),
-              "pending" === getChunk(response, streamState).status &&
+              'pending' === getChunk(response, streamState).status &&
                 (id._debugChunk = null)));
           break;
         case 74:
@@ -4402,7 +4402,7 @@
           startReadableStream(response, id, void 0, streamState);
           break;
         case 114:
-          startReadableStream(response, id, "bytes", streamState);
+          startReadableStream(response, id, 'bytes', streamState);
           break;
         case 88:
           startAsyncIterable(response, id, !1, streamState);
@@ -4412,20 +4412,20 @@
           break;
         case 67:
           (response = response._chunks.get(id)) &&
-            "fulfilled" === response.status &&
-            response.reason.close("" === row ? '"$undefined"' : row);
+            'fulfilled' === response.status &&
+            response.reason.close('' === row ? '"$undefined"' : row);
           break;
         default:
-          if ("" === row) {
+          if ('' === row) {
             if (
               ((streamState = response._chunks),
               (row = streamState.get(id)) ||
                 streamState.set(id, (row = createPendingChunk(response))),
-              "pending" === row.status || "blocked" === row.status)
+              'pending' === row.status || 'blocked' === row.status)
             )
               releasePendingChunk(response, row),
                 (response = row),
-                (response.status = "halted"),
+                (response.status = 'halted'),
                 (response.value = null),
                 (response.reason = null);
           } else
@@ -4511,7 +4511,7 @@
                 weakResponse,
                 rowTag,
                 buffer,
-                rowLength
+                rowLength,
               ),
               (i = lastIdx),
               3 === rowState && i++,
@@ -4532,9 +4532,9 @@
     }
     function createFromJSONCallback(response) {
       return function (key, value) {
-        if ("string" === typeof value)
+        if ('string' === typeof value)
           return parseModelString(response, this, key, value);
-        if ("object" === typeof value && null !== value) {
+        if ('object' === typeof value && null !== value) {
           if (value[0] === REACT_ELEMENT_TYPE)
             b: {
               var owner = value[4],
@@ -4545,46 +4545,46 @@
                 type: value[1],
                 key: value[2],
                 props: value[3],
-                _owner: void 0 === owner ? null : owner
+                _owner: void 0 === owner ? null : owner,
               };
-              Object.defineProperty(value, "ref", {
+              Object.defineProperty(value, 'ref', {
                 enumerable: !1,
-                get: nullRefGetter
+                get: nullRefGetter,
               });
               value._store = {};
-              Object.defineProperty(value._store, "validated", {
+              Object.defineProperty(value._store, 'validated', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: key
+                value: key,
               });
-              Object.defineProperty(value, "_debugInfo", {
+              Object.defineProperty(value, '_debugInfo', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: null
+                value: null,
               });
-              Object.defineProperty(value, "_debugStack", {
+              Object.defineProperty(value, '_debugStack', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: void 0 === stack ? null : stack
+                value: void 0 === stack ? null : stack,
               });
-              Object.defineProperty(value, "_debugTask", {
+              Object.defineProperty(value, '_debugTask', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: null
+                value: null,
               });
               if (null !== initializingHandler) {
                 owner = initializingHandler;
                 initializingHandler = owner.parent;
                 if (owner.errored) {
-                  stack = new ReactPromise("rejected", null, owner.reason);
+                  stack = new ReactPromise('rejected', null, owner.reason);
                   initializeElement(response, value, null);
                   owner = {
-                    name: getComponentNameFromType(value.type) || "",
-                    owner: value._owner
+                    name: getComponentNameFromType(value.type) || '',
+                    owner: value._owner,
                   };
                   owner.debugStack = value._debugStack;
                   supportsCreateTask && (owner.debugTask = value._debugTask);
@@ -4593,7 +4593,7 @@
                   break b;
                 }
                 if (0 < owner.deps) {
-                  stack = new ReactPromise("blocked", null, null);
+                  stack = new ReactPromise('blocked', null, null);
                   owner.value = value;
                   owner.chunk = stack;
                   key = createLazyChunkWrapper(stack, key);
@@ -4612,11 +4612,11 @@
       };
     }
     function close(weakResponse) {
-      reportGlobalError(weakResponse, Error("Connection closed."));
+      reportGlobalError(weakResponse, Error('Connection closed.'));
     }
     function noServerCall$1() {
       throw Error(
-        "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+        'Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.',
       );
     }
     function createResponseFromOptions(options) {
@@ -4626,7 +4626,7 @@
         options.serverConsumerManifest.moduleLoading,
         noServerCall$1,
         options.encodeFormAction,
-        "string" === typeof options.nonce ? options.nonce : void 0,
+        'string' === typeof options.nonce ? options.nonce : void 0,
         options && options.temporaryReferences
           ? options.temporaryReferences
           : void 0,
@@ -4636,9 +4636,9 @@
         options && void 0 !== options.debugChannel
           ? {
               hasReadable: void 0 !== options.debugChannel.readable,
-              callback: null
+              callback: null,
             }
-          : void 0
+          : void 0,
       )._weakResponse;
     }
     function startReadingFromStream$1(response, stream, onDone, debugValue) {
@@ -4657,13 +4657,13 @@
     }
     function noServerCall() {
       throw Error(
-        "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+        'Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.',
       );
     }
     function startReadingFromStream(response$jscomp$0, stream, onEnd) {
       var streamState = createStreamState(response$jscomp$0, stream);
-      stream.on("data", function (chunk) {
-        if ("string" === typeof chunk) {
+      stream.on('data', function (chunk) {
+        if ('string' === typeof chunk) {
           if (void 0 !== response$jscomp$0.weak.deref()) {
             var response = unwrapWeakResponse(response$jscomp$0),
               i = 0,
@@ -4720,23 +4720,23 @@
                         (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
                   continue;
                 case 3:
-                  lastIdx = chunk.indexOf("\n", i);
+                  lastIdx = chunk.indexOf('\n', i);
                   break;
                 case 4:
                   if (84 !== rowTag)
                     throw Error(
-                      "Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams."
+                      'Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams.',
                     );
                   if (rowLength < chunk.length || chunk.length > 3 * rowLength)
                     throw Error(
-                      "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+                      'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
                     );
                   lastIdx = chunk.length;
               }
               if (-1 < lastIdx) {
                 if (0 < buffer.length)
                   throw Error(
-                    "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+                    'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
                   );
                 i = chunk.slice(i, lastIdx);
                 processFullStringRow(response, streamState, rowID, rowTag, i);
@@ -4746,7 +4746,7 @@
                 buffer.length = 0;
               } else if (chunk.length !== i)
                 throw Error(
-                  "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+                  'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
                 );
             }
             streamState._rowState = rowState;
@@ -4756,39 +4756,39 @@
           }
         } else processBinaryChunk(response$jscomp$0, streamState, chunk);
       });
-      stream.on("error", function (error) {
+      stream.on('error', function (error) {
         reportGlobalError(response$jscomp$0, error);
       });
-      stream.on("end", onEnd);
+      stream.on('end', onEnd);
     }
-    var util = require("util"),
-      ReactDOM = require("react-dom"),
-      React = require("react"),
+    var util = require('util'),
+      ReactDOM = require('react-dom'),
+      React = require('react'),
       decoderOptions = { stream: !0 },
       bind$1 = Function.prototype.bind,
       chunkCache = new Map(),
       ReactDOMSharedInternals =
         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
-      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
+      REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+      REACT_PORTAL_TYPE = Symbol.for('react.portal'),
+      REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+      REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode'),
+      REACT_PROFILER_TYPE = Symbol.for('react.profiler'),
+      REACT_CONSUMER_TYPE = Symbol.for('react.consumer'),
+      REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+      REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+      REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+      REACT_MEMO_TYPE = Symbol.for('react.memo'),
+      REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+      REACT_ACTIVITY_TYPE = Symbol.for('react.activity'),
       MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
       ASYNC_ITERATOR = Symbol.asyncIterator,
       isArrayImpl = Array.isArray,
       getPrototypeOf = Object.getPrototypeOf,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
-      CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"),
+      CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference'),
       ObjectPrototype = Object.prototype,
       knownServerReferences = new WeakMap(),
       boundCache = new WeakMap(),
@@ -4799,19 +4799,19 @@
         /^ {3} at (?:(.+) \((.+):(\d+):(\d+)\)|(?:async )?(.+):(\d+):(\d+))$/,
       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\d+):(\d+)/,
       hasOwnProperty = Object.prototype.hasOwnProperty,
-      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
+      REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference'),
       supportsUserTiming =
-        "undefined" !== typeof console &&
-        "function" === typeof console.timeStamp &&
-        "undefined" !== typeof performance &&
-        "function" === typeof performance.measure,
+        'undefined' !== typeof console &&
+        'function' === typeof console.timeStamp &&
+        'undefined' !== typeof performance &&
+        'function' === typeof performance.measure,
       trackNames =
-        "Primary Parallel Parallel\u200b Parallel\u200b\u200b Parallel\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b".split(
-          " "
+        'Primary Parallel Parallel\u200b Parallel\u200b\u200b Parallel\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b'.split(
+          ' ',
         ),
       prefix,
       suffix;
-    new ("function" === typeof WeakMap ? WeakMap : Map)();
+    new ('function' === typeof WeakMap ? WeakMap : Map)();
     var ReactSharedInteralsServer =
         React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
       ReactSharedInternals =
@@ -4821,10 +4821,10 @@
     ReactPromise.prototype.then = function (resolve, reject) {
       var _this = this;
       switch (this.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(this);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(this);
       }
       var resolveCallback = resolve,
@@ -4841,26 +4841,26 @@
         });
       wrapperPromise.then(resolveCallback, rejectCallback);
       switch (this.status) {
-        case "fulfilled":
-          "function" === typeof resolve && resolve(this.value);
+        case 'fulfilled':
+          'function' === typeof resolve && resolve(this.value);
           break;
-        case "pending":
-        case "blocked":
-          "function" === typeof resolve &&
+        case 'pending':
+        case 'blocked':
+          'function' === typeof resolve &&
             (null === this.value && (this.value = []),
             this.value.push(resolve));
-          "function" === typeof reject &&
+          'function' === typeof reject &&
             (null === this.reason && (this.reason = []),
             this.reason.push(reject));
           break;
-        case "halted":
+        case 'halted':
           break;
         default:
-          "function" === typeof reject && reject(this.reason);
+          'function' === typeof reject && reject(this.reason);
       }
     };
     var debugChannelRegistry =
-        "function" === typeof FinalizationRegistry
+        'function' === typeof FinalizationRegistry
           ? new FinalizationRegistry(closeDebugChannel)
           : null,
       initializingHandler = null,
@@ -4877,13 +4877,13 @@
             stack,
             environmentName,
             !1,
-            fakeJSXCallSite
+            fakeJSXCallSite,
           )();
-        }
+        },
       },
       createFakeJSXCallStackInDEV =
         createFakeJSXCallStack.react_stack_bottom_frame.bind(
-          createFakeJSXCallStack
+          createFakeJSXCallStack,
         ),
       currentOwnerInDEV = null,
       replayConsoleWithCallStack = {
@@ -4900,40 +4900,40 @@
             a: {
               var offset = 0;
               switch (methodName) {
-                case "dir":
-                case "dirxml":
-                case "groupEnd":
-                case "table":
+                case 'dir':
+                case 'dirxml':
+                case 'groupEnd':
+                case 'table':
                   var JSCompiler_inline_result = bind$1.apply(
                     console[methodName],
-                    [console].concat(payload)
+                    [console].concat(payload),
                   );
                   break a;
-                case "assert":
+                case 'assert':
                   offset = 1;
               }
               var newArgs = payload.slice(0);
-              "string" === typeof newArgs[offset]
+              'string' === typeof newArgs[offset]
                 ? newArgs.splice(
                     offset,
                     1,
-                    "\u001b[0m\u001b[7m%c%s\u001b[0m%c " + newArgs[offset],
-                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
-                    " " + env + " ",
-                    ""
+                    '\u001b[0m\u001b[7m%c%s\u001b[0m%c ' + newArgs[offset],
+                    'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px',
+                    ' ' + env + ' ',
+                    '',
                   )
                 : newArgs.splice(
                     offset,
                     0,
-                    "\u001b[0m\u001b[7m%c%s\u001b[0m%c",
-                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
-                    " " + env + " ",
-                    ""
+                    '\u001b[0m\u001b[7m%c%s\u001b[0m%c',
+                    'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px',
+                    ' ' + env + ' ',
+                    '',
                   );
               newArgs.unshift(console);
               JSCompiler_inline_result = bind$1.apply(
                 console[methodName],
-                newArgs
+                newArgs,
               );
             }
             var callStack = buildFakeCallStack(
@@ -4941,7 +4941,7 @@
               stackTrace,
               env,
               !1,
-              JSCompiler_inline_result
+              JSCompiler_inline_result,
             );
             if (null != owner) {
               var task = initializeFakeTask(response, owner);
@@ -4957,11 +4957,11 @@
             (currentOwnerInDEV = null),
               (ReactSharedInternals.getCurrentStack = prevStack);
           }
-        }
+        },
       },
       replayConsoleWithCallStackInDEV =
         replayConsoleWithCallStack.react_stack_bottom_frame.bind(
-          replayConsoleWithCallStack
+          replayConsoleWithCallStack,
         );
     exports.createFromFetch = function (promiseForResponse, options) {
       var response = createResponseFromOptions(options);
@@ -4979,7 +4979,7 @@
             startReadingFromStream$1(
               response,
               options.debugChannel.readable,
-              handleDone
+              handleDone,
             );
             startReadingFromStream$1(response, r.body, handleDone, r);
           } else
@@ -4987,19 +4987,19 @@
               response,
               r.body,
               close.bind(null, response),
-              r
+              r,
             );
         },
         function (e) {
           reportGlobalError(response, e);
-        }
+        },
       );
       return getRoot(response);
     };
     exports.createFromNodeStream = function (
       stream,
       serverConsumerManifest,
-      options
+      options,
     ) {
       var response = new ResponseInstance(
         serverConsumerManifest.moduleMap,
@@ -5007,7 +5007,7 @@
         serverConsumerManifest.moduleLoading,
         noServerCall,
         options ? options.encodeFormAction : void 0,
-        options && "string" === typeof options.nonce ? options.nonce : void 0,
+        options && 'string' === typeof options.nonce ? options.nonce : void 0,
         void 0,
         options && options.findSourceMapURL ? options.findSourceMapURL : void 0,
         options ? !0 === options.replayConsoleLogs : !1,
@@ -5015,9 +5015,9 @@
         options && void 0 !== options.debugChannel
           ? {
               hasReadable: void 0 !== options.debugChannel.readable,
-              callback: null
+              callback: null,
             }
-          : void 0
+          : void 0,
       )._weakResponse;
       if (options && options.debugChannel) {
         var streamEndedCount = 0;
@@ -5027,7 +5027,7 @@
         startReadingFromStream(
           response,
           options.debugChannel,
-          serverConsumerManifest
+          serverConsumerManifest,
         );
         startReadingFromStream(response, stream, serverConsumerManifest);
       } else
@@ -5044,7 +5044,7 @@
         startReadingFromStream$1(
           response,
           options.debugChannel.readable,
-          handleDone
+          handleDone,
         );
         startReadingFromStream$1(response, stream, handleDone, stream);
       } else
@@ -5052,7 +5052,7 @@
           response,
           stream,
           close.bind(null, response),
-          stream
+          stream,
         );
       return getRoot(response);
     };
@@ -5066,12 +5066,12 @@
       return new Promise(function (resolve, reject) {
         var abort = processReply(
           value,
-          "",
+          '',
           options && options.temporaryReferences
             ? options.temporaryReferences
             : void 0,
           resolve,
-          reject
+          reject,
         );
         if (options && options.signal) {
           var signal = options.signal;
@@ -5079,9 +5079,9 @@
           else {
             var listener = function () {
               abort(signal.reason);
-              signal.removeEventListener("abort", listener);
+              signal.removeEventListener('abort', listener);
             };
-            signal.addEventListener("abort", listener);
+            signal.addEventListener('abort', listener);
           }
         }
       });
@@ -5089,7 +5089,7 @@
     exports.registerServerReference = function (
       reference,
       id,
-      encodeFormAction
+      encodeFormAction,
     ) {
       registerBoundServerReference(reference, id, null, encodeFormAction);
       return reference;
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.node.production.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.production.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.node.production.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.production.js	2025-12-17 14:32:44
@@ -8,9 +8,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-var util = require("util"),
-  ReactDOM = require("react-dom"),
+'use strict';
+var util = require('util'),
+  ReactDOM = require('react-dom'),
   decoderOptions = { stream: !0 };
 function resolveClientReference(bundlerConfig, metadata) {
   if (bundlerConfig) {
@@ -18,12 +18,12 @@
     if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))
       moduleExports = bundlerConfig.name;
     else {
-      bundlerConfig = moduleExports && moduleExports["*"];
+      bundlerConfig = moduleExports && moduleExports['*'];
       if (!bundlerConfig)
         throw Error(
           'Could not find the module "' +
             metadata[0] +
-            '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'
+            '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.',
         );
       moduleExports = metadata[2];
     }
@@ -34,11 +34,11 @@
   return metadata;
 }
 function resolveServerReference(bundlerConfig, id) {
-  var name = "",
+  var name = '',
     resolvedModuleData = bundlerConfig[id];
   if (resolvedModuleData) name = resolvedModuleData.name;
   else {
-    var idx = id.lastIndexOf("#");
+    var idx = id.lastIndexOf('#');
     -1 !== idx &&
       ((name = id.slice(idx + 1)),
       (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -46,7 +46,7 @@
       throw Error(
         'Could not find the module "' +
           id +
-          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
       );
   }
   return resolvedModuleData.async
@@ -56,17 +56,17 @@
 var chunkCache = new Map();
 function requireAsyncModule(id) {
   var promise = __webpack_require__(id);
-  if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+  if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
     return null;
   promise.then(
     function (value) {
-      promise.status = "fulfilled";
+      promise.status = 'fulfilled';
       promise.value = value;
     },
     function (reason) {
-      promise.status = "rejected";
+      promise.status = 'rejected';
       promise.reason = reason;
-    }
+    },
   );
   return promise;
 }
@@ -96,13 +96,13 @@
 }
 function requireModule(metadata) {
   var moduleExports = __webpack_require__(metadata[0]);
-  if (4 === metadata.length && "function" === typeof moduleExports.then)
-    if ("fulfilled" === moduleExports.status)
+  if (4 === metadata.length && 'function' === typeof moduleExports.then)
+    if ('fulfilled' === moduleExports.status)
       moduleExports = moduleExports.value;
     else throw moduleExports.reason;
-  return "*" === metadata[2]
+  return '*' === metadata[2]
     ? moduleExports
-    : "" === metadata[2]
+    : '' === metadata[2]
       ? moduleExports.__esModule
         ? moduleExports.default
         : moduleExports
@@ -117,29 +117,29 @@
         JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];
       var JSCompiler_inline_result = moduleLoading.crossOrigin;
       JSCompiler_inline_result =
-        "string" === typeof JSCompiler_inline_result
-          ? "use-credentials" === JSCompiler_inline_result
+        'string' === typeof JSCompiler_inline_result
+          ? 'use-credentials' === JSCompiler_inline_result
             ? JSCompiler_inline_result
-            : ""
+            : ''
           : void 0;
       JSCompiler_temp_const$jscomp$0.call(
         JSCompiler_temp_const,
         JSCompiler_temp_const$jscomp$1,
-        { crossOrigin: JSCompiler_inline_result, nonce: nonce }
+        { crossOrigin: JSCompiler_inline_result, nonce: nonce },
       );
     }
 }
 var ReactDOMSharedInternals =
     ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
-  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
+  REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+  REACT_LAZY_TYPE = Symbol.for('react.lazy'),
   MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
 function getIteratorFn(maybeIterable) {
-  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  if (null === maybeIterable || 'object' !== typeof maybeIterable) return null;
   maybeIterable =
     (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-    maybeIterable["@@iterator"];
-  return "function" === typeof maybeIterable ? maybeIterable : null;
+    maybeIterable['@@iterator'];
+  return 'function' === typeof maybeIterable ? maybeIterable : null;
 }
 var ASYNC_ITERATOR = Symbol.asyncIterator,
   isArrayImpl = Array.isArray,
@@ -149,33 +149,33 @@
 function serializeNumber(number) {
   return Number.isFinite(number)
     ? 0 === number && -Infinity === 1 / number
-      ? "$-0"
+      ? '$-0'
       : number
     : Infinity === number
-      ? "$Infinity"
+      ? '$Infinity'
       : -Infinity === number
-        ? "$-Infinity"
-        : "$NaN";
+        ? '$-Infinity'
+        : '$NaN';
 }
 function processReply(
   root,
   formFieldPrefix,
   temporaryReferences,
   resolve,
-  reject
+  reject,
 ) {
   function serializeTypedArray(tag, typedArray) {
     typedArray = new Blob([
       new Uint8Array(
         typedArray.buffer,
         typedArray.byteOffset,
-        typedArray.byteLength
-      )
+        typedArray.byteLength,
+      ),
     ]);
     var blobId = nextPartId++;
     null === formData && (formData = new FormData());
     formData.append(formFieldPrefix + blobId, typedArray);
-    return "$" + tag + blobId.toString(16);
+    return '$' + tag + blobId.toString(16);
   }
   function serializeBinaryReader(reader) {
     function progress(entry) {
@@ -184,9 +184,9 @@
           data.append(formFieldPrefix + entry, new Blob(buffer)),
           data.append(
             formFieldPrefix + streamId,
-            '"$o' + entry.toString(16) + '"'
+            '"$o' + entry.toString(16) + '"',
           ),
-          data.append(formFieldPrefix + streamId, "C"),
+          data.append(formFieldPrefix + streamId, 'C'),
           pendingParts--,
           0 === pendingParts && resolve(data))
         : (buffer.push(entry.value),
@@ -198,12 +198,12 @@
     var streamId = nextPartId++,
       buffer = [];
     reader.read(new Uint8Array(1024)).then(progress, reject);
-    return "$r" + streamId.toString(16);
+    return '$r' + streamId.toString(16);
   }
   function serializeReader(reader) {
     function progress(entry) {
       if (entry.done)
-        data.append(formFieldPrefix + streamId, "C"),
+        data.append(formFieldPrefix + streamId, 'C'),
           pendingParts--,
           0 === pendingParts && resolve(data);
       else
@@ -220,11 +220,11 @@
     pendingParts++;
     var streamId = nextPartId++;
     reader.read().then(progress, reject);
-    return "$R" + streamId.toString(16);
+    return '$R' + streamId.toString(16);
   }
   function serializeReadableStream(stream) {
     try {
-      var binaryReader = stream.getReader({ mode: "byob" });
+      var binaryReader = stream.getReader({ mode: 'byob' });
     } catch (x) {
       return serializeReader(stream.getReader());
     }
@@ -234,11 +234,11 @@
     function progress(entry) {
       if (entry.done) {
         if (void 0 === entry.value)
-          data.append(formFieldPrefix + streamId, "C");
+          data.append(formFieldPrefix + streamId, 'C');
         else
           try {
             var partJSON = JSON.stringify(entry.value, resolveToJSON);
-            data.append(formFieldPrefix + streamId, "C" + partJSON);
+            data.append(formFieldPrefix + streamId, 'C' + partJSON);
           } catch (x) {
             reject(x);
             return;
@@ -260,23 +260,23 @@
     var streamId = nextPartId++;
     iterable = iterable === iterator;
     iterator.next().then(progress, reject);
-    return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+    return '$' + (iterable ? 'x' : 'X') + streamId.toString(16);
   }
   function resolveToJSON(key, value) {
     if (null === value) return null;
-    if ("object" === typeof value) {
+    if ('object' === typeof value) {
       switch (value.$$typeof) {
         case REACT_ELEMENT_TYPE:
-          if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+          if (void 0 !== temporaryReferences && -1 === key.indexOf(':')) {
             var parentReference = writtenObjects.get(this);
             if (void 0 !== parentReference)
               return (
-                temporaryReferences.set(parentReference + ":" + key, value),
-                "$T"
+                temporaryReferences.set(parentReference + ':' + key, value),
+                '$T'
               );
           }
           throw Error(
-            "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+            'React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.',
           );
         case REACT_LAZY_TYPE:
           parentReference = value._payload;
@@ -288,12 +288,12 @@
               lazyId = nextPartId++,
               partJSON = serializeModel(resolvedModel, lazyId);
             formData.append(formFieldPrefix + lazyId, partJSON);
-            return "$" + lazyId.toString(16);
+            return '$' + lazyId.toString(16);
           } catch (x) {
             if (
-              "object" === typeof x &&
+              'object' === typeof x &&
               null !== x &&
-              "function" === typeof x.then
+              'function' === typeof x.then
             ) {
               pendingParts++;
               var lazyId$23 = nextPartId++;
@@ -309,7 +309,7 @@
                 }
               };
               x.then(parentReference, parentReference);
-              return "$" + lazyId$23.toString(16);
+              return '$' + lazyId$23.toString(16);
             }
             reject(x);
             return null;
@@ -317,7 +317,7 @@
             pendingParts--;
           }
       }
-      if ("function" === typeof value.then) {
+      if ('function' === typeof value.then) {
         null === formData && (formData = new FormData());
         pendingParts++;
         var promiseId = nextPartId++;
@@ -332,17 +332,17 @@
             reject(reason);
           }
         }, reject);
-        return "$@" + promiseId.toString(16);
+        return '$@' + promiseId.toString(16);
       }
       parentReference = writtenObjects.get(value);
       if (void 0 !== parentReference)
         if (modelRoot === value) modelRoot = null;
         else return parentReference;
       else
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
           ((parentReference = writtenObjects.get(this)),
           void 0 !== parentReference &&
-            ((key = parentReference + ":" + key),
+            ((key = parentReference + ':' + key),
             writtenObjects.set(value, key),
             void 0 !== temporaryReferences &&
               temporaryReferences.set(key, value)));
@@ -351,11 +351,11 @@
         null === formData && (formData = new FormData());
         var data$31 = formData;
         key = nextPartId++;
-        var prefix = formFieldPrefix + key + "_";
+        var prefix = formFieldPrefix + key + '_';
         value.forEach(function (originalValue, originalKey) {
           data$31.append(prefix + originalKey, originalValue);
         });
-        return "$K" + key.toString(16);
+        return '$K' + key.toString(16);
       }
       if (value instanceof Map)
         return (
@@ -363,7 +363,7 @@
           (parentReference = serializeModel(Array.from(value), key)),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + key, parentReference),
-          "$Q" + key.toString(16)
+          '$Q' + key.toString(16)
         );
       if (value instanceof Set)
         return (
@@ -371,7 +371,7 @@
           (parentReference = serializeModel(Array.from(value), key)),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + key, parentReference),
-          "$W" + key.toString(16)
+          '$W' + key.toString(16)
         );
       if (value instanceof ArrayBuffer)
         return (
@@ -379,29 +379,29 @@
           (parentReference = nextPartId++),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + parentReference, key),
-          "$A" + parentReference.toString(16)
+          '$A' + parentReference.toString(16)
         );
-      if (value instanceof Int8Array) return serializeTypedArray("O", value);
-      if (value instanceof Uint8Array) return serializeTypedArray("o", value);
+      if (value instanceof Int8Array) return serializeTypedArray('O', value);
+      if (value instanceof Uint8Array) return serializeTypedArray('o', value);
       if (value instanceof Uint8ClampedArray)
-        return serializeTypedArray("U", value);
-      if (value instanceof Int16Array) return serializeTypedArray("S", value);
-      if (value instanceof Uint16Array) return serializeTypedArray("s", value);
-      if (value instanceof Int32Array) return serializeTypedArray("L", value);
-      if (value instanceof Uint32Array) return serializeTypedArray("l", value);
-      if (value instanceof Float32Array) return serializeTypedArray("G", value);
-      if (value instanceof Float64Array) return serializeTypedArray("g", value);
+        return serializeTypedArray('U', value);
+      if (value instanceof Int16Array) return serializeTypedArray('S', value);
+      if (value instanceof Uint16Array) return serializeTypedArray('s', value);
+      if (value instanceof Int32Array) return serializeTypedArray('L', value);
+      if (value instanceof Uint32Array) return serializeTypedArray('l', value);
+      if (value instanceof Float32Array) return serializeTypedArray('G', value);
+      if (value instanceof Float64Array) return serializeTypedArray('g', value);
       if (value instanceof BigInt64Array)
-        return serializeTypedArray("M", value);
+        return serializeTypedArray('M', value);
       if (value instanceof BigUint64Array)
-        return serializeTypedArray("m", value);
-      if (value instanceof DataView) return serializeTypedArray("V", value);
-      if ("function" === typeof Blob && value instanceof Blob)
+        return serializeTypedArray('m', value);
+      if (value instanceof DataView) return serializeTypedArray('V', value);
+      if ('function' === typeof Blob && value instanceof Blob)
         return (
           null === formData && (formData = new FormData()),
           (key = nextPartId++),
           formData.append(formFieldPrefix + key, value),
-          "$B" + key.toString(16)
+          '$B' + key.toString(16)
         );
       if ((key = getIteratorFn(value)))
         return (
@@ -410,20 +410,20 @@
             ? ((key = nextPartId++),
               (parentReference = serializeModel(
                 Array.from(parentReference),
-                key
+                key,
               )),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$i" + key.toString(16))
+              '$i' + key.toString(16))
             : Array.from(parentReference)
         );
       if (
-        "function" === typeof ReadableStream &&
+        'function' === typeof ReadableStream &&
         value instanceof ReadableStream
       )
         return serializeReadableStream(value);
       key = value[ASYNC_ITERATOR];
-      if ("function" === typeof key)
+      if ('function' === typeof key)
         return serializeAsyncIterable(value, key.call(value));
       key = getPrototypeOf(value);
       if (
@@ -432,72 +432,72 @@
       ) {
         if (void 0 === temporaryReferences)
           throw Error(
-            "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported."
+            'Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.',
           );
-        return "$T";
+        return '$T';
       }
       return value;
     }
-    if ("string" === typeof value) {
-      if ("Z" === value[value.length - 1] && this[key] instanceof Date)
-        return "$D" + value;
-      key = "$" === value[0] ? "$" + value : value;
+    if ('string' === typeof value) {
+      if ('Z' === value[value.length - 1] && this[key] instanceof Date)
+        return '$D' + value;
+      key = '$' === value[0] ? '$' + value : value;
       return key;
     }
-    if ("boolean" === typeof value) return value;
-    if ("number" === typeof value) return serializeNumber(value);
-    if ("undefined" === typeof value) return "$undefined";
-    if ("function" === typeof value) {
+    if ('boolean' === typeof value) return value;
+    if ('number' === typeof value) return serializeNumber(value);
+    if ('undefined' === typeof value) return '$undefined';
+    if ('function' === typeof value) {
       parentReference = knownServerReferences.get(value);
       if (void 0 !== parentReference)
         return (
           (key = JSON.stringify(
             { id: parentReference.id, bound: parentReference.bound },
-            resolveToJSON
+            resolveToJSON,
           )),
           null === formData && (formData = new FormData()),
           (parentReference = nextPartId++),
           formData.set(formFieldPrefix + parentReference, key),
-          "$F" + parentReference.toString(16)
+          '$F' + parentReference.toString(16)
         );
       if (
         void 0 !== temporaryReferences &&
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
         ((parentReference = writtenObjects.get(this)),
         void 0 !== parentReference)
       )
         return (
-          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+          temporaryReferences.set(parentReference + ':' + key, value), '$T'
         );
       throw Error(
-        "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+        'Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.',
       );
     }
-    if ("symbol" === typeof value) {
+    if ('symbol' === typeof value) {
       if (
         void 0 !== temporaryReferences &&
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
         ((parentReference = writtenObjects.get(this)),
         void 0 !== parentReference)
       )
         return (
-          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+          temporaryReferences.set(parentReference + ':' + key, value), '$T'
         );
       throw Error(
-        "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+        'Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.',
       );
     }
-    if ("bigint" === typeof value) return "$n" + value.toString(10);
+    if ('bigint' === typeof value) return '$n' + value.toString(10);
     throw Error(
-      "Type " +
+      'Type ' +
         typeof value +
-        " is not supported as an argument to a Server Function."
+        ' is not supported as an argument to a Server Function.',
     );
   }
   function serializeModel(model, id) {
-    "object" === typeof model &&
+    'object' === typeof model &&
       null !== model &&
-      ((id = "$" + id.toString(16)),
+      ((id = '$' + id.toString(16)),
       writtenObjects.set(model, id),
       void 0 !== temporaryReferences && temporaryReferences.set(id, model));
     modelRoot = model;
@@ -511,7 +511,7 @@
     json = serializeModel(root, 0);
   null === formData
     ? resolve(json)
-    : (formData.set(formFieldPrefix + "0", json),
+    : (formData.set(formFieldPrefix + '0', json),
       0 === pendingParts && resolve(formData));
   return function () {
     0 < pendingParts &&
@@ -529,23 +529,23 @@
     });
   processReply(
     reference,
-    "",
+    '',
     void 0,
     function (body) {
-      if ("string" === typeof body) {
+      if ('string' === typeof body) {
         var data = new FormData();
-        data.append("0", body);
+        data.append('0', body);
         body = data;
       }
-      thenable.status = "fulfilled";
+      thenable.status = 'fulfilled';
       thenable.value = body;
       resolve(body);
     },
     function (e) {
-      thenable.status = "rejected";
+      thenable.status = 'rejected';
       thenable.reason = e;
       reject(e);
-    }
+    },
   );
   return thenable;
 }
@@ -553,7 +553,7 @@
   var referenceClosure = knownServerReferences.get(this);
   if (!referenceClosure)
     throw Error(
-      "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+      'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
     );
   var data = null;
   if (null !== referenceClosure.bound) {
@@ -561,55 +561,55 @@
     data ||
       ((data = encodeFormData({
         id: referenceClosure.id,
-        bound: referenceClosure.bound
+        bound: referenceClosure.bound,
       })),
       boundCache.set(referenceClosure, data));
-    if ("rejected" === data.status) throw data.reason;
-    if ("fulfilled" !== data.status) throw data;
+    if ('rejected' === data.status) throw data.reason;
+    if ('fulfilled' !== data.status) throw data;
     referenceClosure = data.value;
     var prefixedData = new FormData();
     referenceClosure.forEach(function (value, key) {
-      prefixedData.append("$ACTION_" + identifierPrefix + ":" + key, value);
+      prefixedData.append('$ACTION_' + identifierPrefix + ':' + key, value);
     });
     data = prefixedData;
-    referenceClosure = "$ACTION_REF_" + identifierPrefix;
-  } else referenceClosure = "$ACTION_ID_" + referenceClosure.id;
+    referenceClosure = '$ACTION_REF_' + identifierPrefix;
+  } else referenceClosure = '$ACTION_ID_' + referenceClosure.id;
   return {
     name: referenceClosure,
-    method: "POST",
-    encType: "multipart/form-data",
-    data: data
+    method: 'POST',
+    encType: 'multipart/form-data',
+    data: data,
   };
 }
 function isSignatureEqual(referenceId, numberOfBoundArgs) {
   var referenceClosure = knownServerReferences.get(this);
   if (!referenceClosure)
     throw Error(
-      "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+      'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
     );
   if (referenceClosure.id !== referenceId) return !1;
   var boundPromise = referenceClosure.bound;
   if (null === boundPromise) return 0 === numberOfBoundArgs;
   switch (boundPromise.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return boundPromise.value.length === numberOfBoundArgs;
-    case "pending":
+    case 'pending':
       throw boundPromise;
-    case "rejected":
+    case 'rejected':
       throw boundPromise.reason;
     default:
       throw (
-        ("string" !== typeof boundPromise.status &&
-          ((boundPromise.status = "pending"),
+        ('string' !== typeof boundPromise.status &&
+          ((boundPromise.status = 'pending'),
           boundPromise.then(
             function (boundArgs) {
-              boundPromise.status = "fulfilled";
+              boundPromise.status = 'fulfilled';
               boundPromise.value = boundArgs;
             },
             function (error) {
-              boundPromise.status = "rejected";
+              boundPromise.status = 'rejected';
               boundPromise.reason = error;
-            }
+            },
           )),
         boundPromise)
       );
@@ -620,7 +620,7 @@
     (knownServerReferences.set(reference, {
       id: id,
       originalBind: reference.bind,
-      bound: bound
+      bound: bound,
     }),
     Object.defineProperties(reference, {
       $$FORM_ACTION: {
@@ -631,15 +631,15 @@
                 var referenceClosure = knownServerReferences.get(this);
                 if (!referenceClosure)
                   throw Error(
-                    "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+                    'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
                   );
                 var boundPromise = referenceClosure.bound;
                 null === boundPromise && (boundPromise = Promise.resolve([]));
                 return encodeFormAction(referenceClosure.id, boundPromise);
-              }
+              },
       },
       $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-      bind: { value: bind }
+      bind: { value: bind },
     }));
 }
 var FunctionBind = Function.prototype.bind,
@@ -659,12 +659,12 @@
   knownServerReferences.set(newFn, {
     id: referenceClosure.id,
     originalBind: newFn.bind,
-    bound: boundPromise
+    bound: boundPromise,
   });
   Object.defineProperties(newFn, {
     $$FORM_ACTION: { value: this.$$FORM_ACTION },
     $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-    bind: { value: bind }
+    bind: { value: bind },
   });
   return newFn;
 }
@@ -672,7 +672,7 @@
   function action() {
     var args = Array.prototype.slice.call(arguments);
     return bound
-      ? "fulfilled" === bound.status
+      ? 'fulfilled' === bound.status
         ? callServer(id, bound.value.concat(args))
         : Promise.resolve(bound).then(function (boundArgs) {
             return callServer(id, boundArgs.concat(args));
@@ -700,43 +700,43 @@
 ReactPromise.prototype = Object.create(Promise.prototype);
 ReactPromise.prototype.then = function (resolve, reject) {
   switch (this.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(this);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(this);
   }
   switch (this.status) {
-    case "fulfilled":
-      "function" === typeof resolve && resolve(this.value);
+    case 'fulfilled':
+      'function' === typeof resolve && resolve(this.value);
       break;
-    case "pending":
-    case "blocked":
-      "function" === typeof resolve &&
+    case 'pending':
+    case 'blocked':
+      'function' === typeof resolve &&
         (null === this.value && (this.value = []), this.value.push(resolve));
-      "function" === typeof reject &&
+      'function' === typeof reject &&
         (null === this.reason && (this.reason = []), this.reason.push(reject));
       break;
-    case "halted":
+    case 'halted':
       break;
     default:
-      "function" === typeof reject && reject(this.reason);
+      'function' === typeof reject && reject(this.reason);
   }
 };
 function readChunk(chunk) {
   switch (chunk.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(chunk);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(chunk);
   }
   switch (chunk.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return chunk.value;
-    case "pending":
-    case "blocked":
-    case "halted":
+    case 'pending':
+    case 'blocked':
+    case 'halted':
       throw chunk;
     default:
       throw chunk.reason;
@@ -745,7 +745,7 @@
 function wakeChunk(listeners, value) {
   for (var i = 0; i < listeners.length; i++) {
     var listener = listeners[i];
-    "function" === typeof listener
+    'function' === typeof listener
       ? listener(value)
       : fulfillReference(listener, value);
   }
@@ -753,7 +753,7 @@
 function rejectChunk(listeners, error) {
   for (var i = 0; i < listeners.length; i++) {
     var listener = listeners[i];
-    "function" === typeof listener
+    'function' === typeof listener
       ? listener(error)
       : rejectReference(listener, error);
   }
@@ -771,7 +771,7 @@
     ) {
       var listener = reference[referencedChunk];
       if (
-        "function" !== typeof listener &&
+        'function' !== typeof listener &&
         ((listener = resolveBlockedCycle(resolvedChunk, listener)),
         null !== listener)
       )
@@ -781,13 +781,13 @@
 }
 function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
   switch (chunk.status) {
-    case "fulfilled":
+    case 'fulfilled':
       wakeChunk(resolveListeners, chunk.value);
       break;
-    case "blocked":
+    case 'blocked':
       for (var i = 0; i < resolveListeners.length; i++) {
         var listener = resolveListeners[i];
-        if ("function" !== typeof listener) {
+        if ('function' !== typeof listener) {
           var cyclicHandler = resolveBlockedCycle(chunk, listener);
           null !== cyclicHandler &&
             (fulfillReference(listener, cyclicHandler.value),
@@ -798,7 +798,7 @@
               -1 !== listener && rejectListeners.splice(listener, 1)));
         }
       }
-    case "pending":
+    case 'pending':
       if (chunk.value)
         for (i = 0; i < resolveListeners.length; i++)
           chunk.value.push(resolveListeners[i]);
@@ -813,38 +813,38 @@
             chunk.reason.push(rejectListeners[resolveListeners]);
       } else chunk.reason = rejectListeners;
       break;
-    case "rejected":
+    case 'rejected':
       rejectListeners && rejectChunk(rejectListeners, chunk.reason);
   }
 }
 function triggerErrorOnChunk(response, chunk, error) {
-  "pending" !== chunk.status && "blocked" !== chunk.status
+  'pending' !== chunk.status && 'blocked' !== chunk.status
     ? chunk.reason.error(error)
     : ((response = chunk.reason),
-      (chunk.status = "rejected"),
+      (chunk.status = 'rejected'),
       (chunk.reason = error),
       null !== response && rejectChunk(response, error));
 }
 function createResolvedIteratorResultChunk(response, value, done) {
   return new ReactPromise(
-    "resolved_model",
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
-    response
+    'resolved_model',
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
+    response,
   );
 }
 function resolveIteratorResultChunk(response, chunk, value, done) {
   resolveModelChunk(
     response,
     chunk,
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}"
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
   );
 }
 function resolveModelChunk(response, chunk, value) {
-  if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+  if ('pending' !== chunk.status) chunk.reason.enqueueModel(value);
   else {
     var resolveListeners = chunk.value,
       rejectListeners = chunk.reason;
-    chunk.status = "resolved_model";
+    chunk.status = 'resolved_model';
     chunk.value = value;
     chunk.reason = response;
     null !== resolveListeners &&
@@ -853,10 +853,10 @@
   }
 }
 function resolveModuleChunk(response, chunk, value) {
-  if ("pending" === chunk.status || "blocked" === chunk.status) {
+  if ('pending' === chunk.status || 'blocked' === chunk.status) {
     response = chunk.value;
     var rejectListeners = chunk.reason;
-    chunk.status = "resolved_module";
+    chunk.status = 'resolved_module';
     chunk.value = value;
     null !== response &&
       (initializeModuleChunk(chunk),
@@ -869,7 +869,7 @@
   initializingHandler = null;
   var resolvedModel = chunk.value,
     response = chunk.reason;
-  chunk.status = "blocked";
+  chunk.status = 'blocked';
   chunk.value = null;
   chunk.reason = null;
   try {
@@ -882,7 +882,7 @@
         resolvedModel++
       ) {
         var listener = resolveListeners[resolvedModel];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(value)
           : fulfillReference(listener, value, chunk);
       }
@@ -894,10 +894,10 @@
         return;
       }
     }
-    chunk.status = "fulfilled";
+    chunk.status = 'fulfilled';
     chunk.value = value;
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   } finally {
     initializingHandler = prevHandler;
   }
@@ -905,17 +905,17 @@
 function initializeModuleChunk(chunk) {
   try {
     var value = requireModule(chunk.value);
-    chunk.status = "fulfilled";
+    chunk.status = 'fulfilled';
     chunk.value = value;
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   }
 }
 function reportGlobalError(weakResponse, error) {
   weakResponse._closed = !0;
   weakResponse._closedReason = error;
   weakResponse._chunks.forEach(function (chunk) {
-    "pending" === chunk.status &&
+    'pending' === chunk.status &&
       triggerErrorOnChunk(weakResponse, chunk, error);
   });
 }
@@ -927,8 +927,8 @@
     chunk = chunks.get(id);
   chunk ||
     ((chunk = response._closed
-      ? new ReactPromise("rejected", null, response._closedReason)
-      : new ReactPromise("pending", null, null)),
+      ? new ReactPromise('rejected', null, response._closedReason)
+      : new ReactPromise('pending', null, null)),
     chunks.set(id, chunk));
   return chunk;
 }
@@ -946,7 +946,7 @@
   ) {
     for (
       ;
-      "object" === typeof value &&
+      'object' === typeof value &&
       null !== value &&
       value.$$typeof === REACT_LAZY_TYPE;
 
@@ -955,23 +955,23 @@
         value = handler.value;
       else {
         switch (value.status) {
-          case "resolved_model":
+          case 'resolved_model':
             initializeModelChunk(value);
             break;
-          case "resolved_module":
+          case 'resolved_module':
             initializeModuleChunk(value);
         }
         switch (value.status) {
-          case "fulfilled":
+          case 'fulfilled':
             value = value.value;
             continue;
-          case "blocked":
+          case 'blocked':
             var cyclicHandler = resolveBlockedCycle(value, reference);
             if (null !== cyclicHandler) {
               value = cyclicHandler.value;
               continue;
             }
-          case "pending":
+          case 'pending':
             path.splice(0, i - 1);
             null === value.value
               ? (value.value = [reference])
@@ -980,7 +980,7 @@
               ? (value.reason = [reference])
               : value.reason.push(reference);
             return;
-          case "halted":
+          case 'halted':
             return;
           default:
             rejectReference(reference, value.reason);
@@ -991,7 +991,7 @@
   }
   for (
     ;
-    "object" === typeof value &&
+    'object' === typeof value &&
     null !== value &&
     value.$$typeof === REACT_LAZY_TYPE;
 
@@ -1000,14 +1000,14 @@
       value = handler.value;
     else {
       switch (reference.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(reference);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(reference);
       }
       switch (reference.status) {
-        case "fulfilled":
+        case 'fulfilled':
           value = reference.value;
           continue;
       }
@@ -1015,24 +1015,24 @@
     }
   response = map(response, value, parentObject, key);
   parentObject[key] = response;
-  "" === key && null === handler.value && (handler.value = response);
+  '' === key && null === handler.value && (handler.value = response);
   if (
     parentObject[0] === REACT_ELEMENT_TYPE &&
-    "object" === typeof handler.value &&
+    'object' === typeof handler.value &&
     null !== handler.value &&
     handler.value.$$typeof === REACT_ELEMENT_TYPE
   )
     switch (((parentObject = handler.value), key)) {
-      case "3":
+      case '3':
         parentObject.props = response;
     }
   handler.deps--;
   0 === handler.deps &&
     ((key = handler.chunk),
     null !== key &&
-      "blocked" === key.status &&
+      'blocked' === key.status &&
       ((parentObject = key.value),
-      (key.status = "fulfilled"),
+      (key.status = 'fulfilled'),
       (key.value = handler.value),
       (key.reason = handler.reason),
       null !== parentObject && wakeChunk(parentObject, handler.value)));
@@ -1046,7 +1046,7 @@
     (handler.reason = error),
     (handler = handler.chunk),
     null !== handler &&
-      "blocked" === handler.status &&
+      'blocked' === handler.status &&
       triggerErrorOnChunk(reference, handler, error));
 }
 function waitForReference(
@@ -1055,7 +1055,7 @@
   key,
   response,
   map,
-  path
+  path,
 ) {
   if (initializingHandler) {
     var handler = initializingHandler;
@@ -1067,7 +1067,7 @@
       value: null,
       reason: null,
       deps: 1,
-      errored: !1
+      errored: !1,
     };
   parentObject = {
     response: response,
@@ -1075,7 +1075,7 @@
     parentObject: parentObject,
     key: key,
     map: map,
-    path: path
+    path: path,
   };
   null === referencedChunk.value
     ? (referencedChunk.value = [parentObject])
@@ -1090,11 +1090,11 @@
     return createBoundServerReference(
       metaData,
       response._callServer,
-      response._encodeFormAction
+      response._encodeFormAction,
     );
   var serverReference = resolveServerReference(
       response._serverReferenceConfig,
-      metaData.id
+      metaData.id,
     ),
     promise = preloadModule(serverReference);
   if (promise)
@@ -1107,7 +1107,7 @@
         promise,
         metaData.id,
         metaData.bound,
-        response._encodeFormAction
+        response._encodeFormAction,
       ),
       promise
     );
@@ -1121,7 +1121,7 @@
       value: null,
       reason: null,
       deps: 1,
-      errored: !1
+      errored: !1,
     };
   promise.then(
     function () {
@@ -1135,27 +1135,27 @@
         resolvedValue,
         metaData.id,
         metaData.bound,
-        response._encodeFormAction
+        response._encodeFormAction,
       );
       parentObject[key] = resolvedValue;
-      "" === key && null === handler.value && (handler.value = resolvedValue);
+      '' === key && null === handler.value && (handler.value = resolvedValue);
       if (
         parentObject[0] === REACT_ELEMENT_TYPE &&
-        "object" === typeof handler.value &&
+        'object' === typeof handler.value &&
         null !== handler.value &&
         handler.value.$$typeof === REACT_ELEMENT_TYPE
       )
         switch (((boundArgs = handler.value), key)) {
-          case "3":
+          case '3':
             boundArgs.props = resolvedValue;
         }
       handler.deps--;
       0 === handler.deps &&
         ((resolvedValue = handler.chunk),
         null !== resolvedValue &&
-          "blocked" === resolvedValue.status &&
+          'blocked' === resolvedValue.status &&
           ((boundArgs = resolvedValue.value),
-          (resolvedValue.status = "fulfilled"),
+          (resolvedValue.status = 'fulfilled'),
           (resolvedValue.value = handler.value),
           null !== boundArgs && wakeChunk(boundArgs, handler.value)));
     },
@@ -1166,58 +1166,58 @@
         handler.reason = error;
         var chunk = handler.chunk;
         null !== chunk &&
-          "blocked" === chunk.status &&
+          'blocked' === chunk.status &&
           triggerErrorOnChunk(response, chunk, error);
       }
-    }
+    },
   );
   return null;
 }
 function getOutlinedModel(response, reference, parentObject, key, map) {
-  reference = reference.split(":");
+  reference = reference.split(':');
   var id = parseInt(reference[0], 16);
   id = getChunk(response, id);
   switch (id.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(id);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(id);
   }
   switch (id.status) {
-    case "fulfilled":
+    case 'fulfilled':
       id = id.value;
       for (var i = 1; i < reference.length; i++) {
         for (
           ;
-          "object" === typeof id &&
+          'object' === typeof id &&
           null !== id &&
           id.$$typeof === REACT_LAZY_TYPE;
 
         ) {
           id = id._payload;
           switch (id.status) {
-            case "resolved_model":
+            case 'resolved_model':
               initializeModelChunk(id);
               break;
-            case "resolved_module":
+            case 'resolved_module':
               initializeModuleChunk(id);
           }
           switch (id.status) {
-            case "fulfilled":
+            case 'fulfilled':
               id = id.value;
               break;
-            case "blocked":
-            case "pending":
+            case 'blocked':
+            case 'pending':
               return waitForReference(
                 id,
                 parentObject,
                 key,
                 response,
                 map,
-                reference.slice(i - 1)
+                reference.slice(i - 1),
               );
-            case "halted":
+            case 'halted':
               return (
                 initializingHandler
                   ? ((response = initializingHandler), response.deps++)
@@ -1227,7 +1227,7 @@
                       value: null,
                       reason: null,
                       deps: 1,
-                      errored: !1
+                      errored: !1,
                     }),
                 null
               );
@@ -1243,7 +1243,7 @@
                       value: null,
                       reason: id.reason,
                       deps: 0,
-                      errored: !0
+                      errored: !0,
                     }),
                 null
               );
@@ -1253,31 +1253,31 @@
       }
       for (
         ;
-        "object" === typeof id &&
+        'object' === typeof id &&
         null !== id &&
         id.$$typeof === REACT_LAZY_TYPE;
 
       ) {
         reference = id._payload;
         switch (reference.status) {
-          case "resolved_model":
+          case 'resolved_model':
             initializeModelChunk(reference);
             break;
-          case "resolved_module":
+          case 'resolved_module':
             initializeModuleChunk(reference);
         }
         switch (reference.status) {
-          case "fulfilled":
+          case 'fulfilled':
             id = reference.value;
             continue;
         }
         break;
       }
       return map(response, id, parentObject, key);
-    case "pending":
-    case "blocked":
+    case 'pending':
+    case 'blocked':
       return waitForReference(id, parentObject, key, response, map, reference);
-    case "halted":
+    case 'halted':
       return (
         initializingHandler
           ? ((response = initializingHandler), response.deps++)
@@ -1287,7 +1287,7 @@
               value: null,
               reason: null,
               deps: 1,
-              errored: !1
+              errored: !1,
             }),
         null
       );
@@ -1303,7 +1303,7 @@
               value: null,
               reason: id.reason,
               deps: 0,
-              errored: !0
+              errored: !0,
             }),
         null
       );
@@ -1331,38 +1331,38 @@
   return model;
 }
 function parseModelString(response, parentObject, key, value) {
-  if ("$" === value[0]) {
-    if ("$" === value)
+  if ('$' === value[0]) {
+    if ('$' === value)
       return (
         null !== initializingHandler &&
-          "0" === key &&
+          '0' === key &&
           (initializingHandler = {
             parent: initializingHandler,
             chunk: null,
             value: null,
             reason: null,
             deps: 0,
-            errored: !1
+            errored: !1,
           }),
         REACT_ELEMENT_TYPE
       );
     switch (value[1]) {
-      case "$":
+      case '$':
         return value.slice(1);
-      case "L":
+      case 'L':
         return (
           (parentObject = parseInt(value.slice(2), 16)),
           (response = getChunk(response, parentObject)),
           createLazyChunkWrapper(response)
         );
-      case "@":
+      case '@':
         return (
           (parentObject = parseInt(value.slice(2), 16)),
           getChunk(response, parentObject)
         );
-      case "S":
+      case 'S':
         return Symbol.for(value.slice(2));
-      case "F":
+      case 'F':
         return (
           (value = value.slice(2)),
           getOutlinedModel(
@@ -1370,55 +1370,55 @@
             value,
             parentObject,
             key,
-            loadServerReference
+            loadServerReference,
           )
         );
-      case "T":
-        parentObject = "$" + value.slice(2);
+      case 'T':
+        parentObject = '$' + value.slice(2);
         response = response._tempRefs;
         if (null == response)
           throw Error(
-            "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+            'Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.',
           );
         return response.get(parentObject);
-      case "Q":
+      case 'Q':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createMap)
         );
-      case "W":
+      case 'W':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createSet)
         );
-      case "B":
+      case 'B':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createBlob)
         );
-      case "K":
+      case 'K':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createFormData)
         );
-      case "Z":
+      case 'Z':
         return resolveErrorProd();
-      case "i":
+      case 'i':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, extractIterator)
         );
-      case "I":
+      case 'I':
         return Infinity;
-      case "-":
-        return "$-0" === value ? -0 : -Infinity;
-      case "N":
+      case '-':
+        return '$-0' === value ? -0 : -Infinity;
+      case 'N':
         return NaN;
-      case "u":
+      case 'u':
         return;
-      case "D":
+      case 'D':
         return new Date(Date.parse(value.slice(2)));
-      case "n":
+      case 'n':
         return BigInt(value.slice(2));
       default:
         return (
@@ -1431,7 +1431,7 @@
 }
 function missingCall() {
   throw Error(
-    'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+    'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.',
   );
 }
 function ResponseInstance(
@@ -1441,7 +1441,7 @@
   callServer,
   encodeFormAction,
   nonce,
-  temporaryReferences
+  temporaryReferences,
 ) {
   var chunks = new Map();
   this._bundlerConfig = bundlerConfig;
@@ -1464,9 +1464,9 @@
 function resolveBuffer(response, id, buffer) {
   response = response._chunks;
   var chunk = response.get(id);
-  chunk && "pending" !== chunk.status
+  chunk && 'pending' !== chunk.status
     ? chunk.reason.enqueueValue(buffer)
-    : ((buffer = new ReactPromise("fulfilled", buffer, null)),
+    : ((buffer = new ReactPromise('fulfilled', buffer, null)),
       response.set(id, buffer));
 }
 function resolveModule(response, id, model) {
@@ -1477,14 +1477,14 @@
   prepareDestinationWithChunks(
     response._moduleLoading,
     model[1],
-    response._nonce
+    response._nonce,
   );
   if ((model = preloadModule(clientReference))) {
     if (chunk) {
       var blockedChunk = chunk;
-      blockedChunk.status = "blocked";
+      blockedChunk.status = 'blocked';
     } else
-      (blockedChunk = new ReactPromise("blocked", null, null)),
+      (blockedChunk = new ReactPromise('blocked', null, null)),
         chunks.set(id, blockedChunk);
     model.then(
       function () {
@@ -1492,25 +1492,25 @@
       },
       function (error) {
         return triggerErrorOnChunk(response, blockedChunk, error);
-      }
+      },
     );
   } else
     chunk
       ? resolveModuleChunk(response, chunk, clientReference)
-      : ((chunk = new ReactPromise("resolved_module", clientReference, null)),
+      : ((chunk = new ReactPromise('resolved_module', clientReference, null)),
         chunks.set(id, chunk));
 }
 function resolveStream(response, id, stream, controller) {
   response = response._chunks;
   var chunk = response.get(id);
   chunk
-    ? "pending" === chunk.status &&
+    ? 'pending' === chunk.status &&
       ((id = chunk.value),
-      (chunk.status = "fulfilled"),
+      (chunk.status = 'fulfilled'),
       (chunk.value = stream),
       (chunk.reason = controller),
       null !== id && wakeChunk(id, chunk.value))
-    : ((stream = new ReactPromise("fulfilled", stream, controller)),
+    : ((stream = new ReactPromise('fulfilled', stream, controller)),
       response.set(id, stream));
 }
 function startReadableStream(response, id, type) {
@@ -1519,7 +1519,7 @@
     type: type,
     start: function (c) {
       controller = c;
-    }
+    },
   });
   var previousBlockedChunk = null;
   resolveStream(response, id, type, {
@@ -1532,9 +1532,9 @@
     },
     enqueueModel: function (json) {
       if (null === previousBlockedChunk) {
-        var chunk = new ReactPromise("resolved_model", json, response);
+        var chunk = new ReactPromise('resolved_model', json, response);
         initializeModelChunk(chunk);
-        "fulfilled" === chunk.status
+        'fulfilled' === chunk.status
           ? controller.enqueue(chunk.value)
           : (chunk.then(
               function (v) {
@@ -1542,19 +1542,19 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             ),
             (previousBlockedChunk = chunk));
       } else {
         chunk = previousBlockedChunk;
-        var chunk$54 = new ReactPromise("pending", null, null);
+        var chunk$54 = new ReactPromise('pending', null, null);
         chunk$54.then(
           function (v) {
             return controller.enqueue(v);
           },
           function (e) {
             return controller.error(e);
-          }
+          },
         );
         previousBlockedChunk = chunk$54;
         chunk.then(function () {
@@ -1582,7 +1582,7 @@
           return controller.error(error);
         });
       }
-    }
+    },
   });
 }
 function asyncIterator() {
@@ -1603,16 +1603,16 @@
     return createIterator(function (arg) {
       if (void 0 !== arg)
         throw Error(
-          "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+          'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
         );
       if (nextReadIndex === buffer.length) {
         if (closed)
           return new ReactPromise(
-            "fulfilled",
+            'fulfilled',
             { done: !0, value: void 0 },
-            null
+            null,
           );
-        buffer[nextReadIndex] = new ReactPromise("pending", null, null);
+        buffer[nextReadIndex] = new ReactPromise('pending', null, null);
       }
       return buffer[nextReadIndex++];
     });
@@ -1625,15 +1625,15 @@
       enqueueValue: function (value) {
         if (nextWriteIndex === buffer.length)
           buffer[nextWriteIndex] = new ReactPromise(
-            "fulfilled",
+            'fulfilled',
             { done: !1, value: value },
-            null
+            null,
           );
         else {
           var chunk = buffer[nextWriteIndex],
             resolveListeners = chunk.value,
             rejectListeners = chunk.reason;
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = { done: !1, value: value };
           null !== resolveListeners &&
             wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
@@ -1645,13 +1645,13 @@
           ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
               response,
               value,
-              !1
+              !1,
             ))
           : resolveIteratorResultChunk(
               response,
               buffer[nextWriteIndex],
               value,
-              !1
+              !1,
             );
         nextWriteIndex++;
       },
@@ -1661,40 +1661,40 @@
           ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
               response,
               value,
-              !0
+              !0,
             ))
           : resolveIteratorResultChunk(
               response,
               buffer[nextWriteIndex],
               value,
-              !0
+              !0,
             );
         for (nextWriteIndex++; nextWriteIndex < buffer.length; )
           resolveIteratorResultChunk(
             response,
             buffer[nextWriteIndex++],
             '"$undefined"',
-            !0
+            !0,
           );
       },
       error: function (error) {
         closed = !0;
         for (
           nextWriteIndex === buffer.length &&
-          (buffer[nextWriteIndex] = new ReactPromise("pending", null, null));
+          (buffer[nextWriteIndex] = new ReactPromise('pending', null, null));
           nextWriteIndex < buffer.length;
 
         )
           triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);
-      }
-    }
+      },
+    },
   );
 }
 function resolveErrorProd() {
   var error = Error(
-    "An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error."
+    'An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.',
   );
-  error.stack = "Error: " + error.message;
+  error.stack = 'Error: ' + error.message;
   return error;
 }
 function mergeBuffer(buffer, lastChunk) {
@@ -1715,7 +1715,7 @@
   buffer,
   lastChunk,
   constructor,
-  bytesPerElement
+  bytesPerElement,
 ) {
   buffer =
     0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
@@ -1724,7 +1724,7 @@
   constructor = new constructor(
     buffer.buffer,
     buffer.byteOffset,
-    buffer.byteLength / bytesPerElement
+    buffer.byteLength / bytesPerElement,
   );
   resolveBuffer(response, id, constructor);
 }
@@ -1740,7 +1740,7 @@
       resolveBuffer(
         response,
         id,
-        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)
+        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk),
       );
       return;
     case 85:
@@ -1775,7 +1775,7 @@
       return;
   }
   for (
-    var stringDecoder = response._stringDecoder, row = "", i = 0;
+    var stringDecoder = response._stringDecoder, row = '', i = 0;
     i < buffer.length;
     i++
   )
@@ -1794,42 +1794,42 @@
       response = JSON.parse(row, response._fromJSON);
       row = ReactDOMSharedInternals.d;
       switch (id) {
-        case "D":
+        case 'D':
           row.D(response);
           break;
-        case "C":
-          "string" === typeof response
+        case 'C':
+          'string' === typeof response
             ? row.C(response)
             : row.C(response[0], response[1]);
           break;
-        case "L":
+        case 'L':
           id = response[0];
           streamState = response[1];
           3 === response.length
             ? row.L(id, streamState, response[2])
             : row.L(id, streamState);
           break;
-        case "m":
-          "string" === typeof response
+        case 'm':
+          'string' === typeof response
             ? row.m(response)
             : row.m(response[0], response[1]);
           break;
-        case "X":
-          "string" === typeof response
+        case 'X':
+          'string' === typeof response
             ? row.X(response)
             : row.X(response[0], response[1]);
           break;
-        case "S":
-          "string" === typeof response
+        case 'S':
+          'string' === typeof response
             ? row.S(response)
             : row.S(
                 response[0],
                 0 === response[1] ? void 0 : response[1],
-                3 === response.length ? response[2] : void 0
+                3 === response.length ? response[2] : void 0,
               );
           break;
-        case "M":
-          "string" === typeof response
+        case 'M':
+          'string' === typeof response
             ? row.M(response)
             : row.M(response[0], response[1]);
       }
@@ -1842,14 +1842,14 @@
       error.digest = row.digest;
       tag
         ? triggerErrorOnChunk(response, tag, error)
-        : ((response = new ReactPromise("rejected", null, error)),
+        : ((response = new ReactPromise('rejected', null, error)),
           streamState.set(id, response));
       break;
     case 84:
       response = response._chunks;
-      (streamState = response.get(id)) && "pending" !== streamState.status
+      (streamState = response.get(id)) && 'pending' !== streamState.status
         ? streamState.reason.enqueueValue(row)
-        : ((row = new ReactPromise("fulfilled", row, null)),
+        : ((row = new ReactPromise('fulfilled', row, null)),
           response.set(id, row));
       break;
     case 78:
@@ -1857,13 +1857,13 @@
     case 74:
     case 87:
       throw Error(
-        "Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client."
+        'Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client.',
       );
     case 82:
       startReadableStream(response, id, void 0);
       break;
     case 114:
-      startReadableStream(response, id, "bytes");
+      startReadableStream(response, id, 'bytes');
       break;
     case 88:
       startAsyncIterable(response, id, !1);
@@ -1873,14 +1873,14 @@
       break;
     case 67:
       (id = response._chunks.get(id)) &&
-        "fulfilled" === id.status &&
-        id.reason.close("" === row ? '"$undefined"' : row);
+        'fulfilled' === id.status &&
+        id.reason.close('' === row ? '"$undefined"' : row);
       break;
     default:
       (streamState = response._chunks),
         (tag = streamState.get(id))
           ? resolveModelChunk(response, tag, row)
-          : ((response = new ReactPromise("resolved_model", row, response)),
+          : ((response = new ReactPromise('resolved_model', row, response)),
             streamState.set(id, response));
   }
 }
@@ -1951,7 +1951,7 @@
           rowID,
           rowTag,
           buffer,
-          rowLength
+          rowLength,
         ),
         (i = lastIdx),
         3 === rowState && i++,
@@ -1971,9 +1971,9 @@
 }
 function createFromJSONCallback(response) {
   return function (key, value) {
-    if ("string" === typeof value)
+    if ('string' === typeof value)
       return parseModelString(response, this, key, value);
-    if ("object" === typeof value && null !== value) {
+    if ('object' === typeof value && null !== value) {
       if (value[0] === REACT_ELEMENT_TYPE) {
         if (
           ((key = {
@@ -1981,7 +1981,7 @@
             type: value[1],
             key: value[2],
             ref: null,
-            props: value[3]
+            props: value[3],
           }),
           null !== initializingHandler)
         )
@@ -1990,10 +1990,10 @@
             (initializingHandler = value.parent),
             value.errored)
           )
-            (key = new ReactPromise("rejected", null, value.reason)),
+            (key = new ReactPromise('rejected', null, value.reason)),
               (key = createLazyChunkWrapper(key));
           else if (0 < value.deps) {
-            var blockedChunk = new ReactPromise("blocked", null, null);
+            var blockedChunk = new ReactPromise('blocked', null, null);
             value.value = key;
             value.chunk = blockedChunk;
             key = createLazyChunkWrapper(blockedChunk);
@@ -2005,11 +2005,11 @@
   };
 }
 function close(weakResponse) {
-  reportGlobalError(weakResponse, Error("Connection closed."));
+  reportGlobalError(weakResponse, Error('Connection closed.'));
 }
 function noServerCall$1() {
   throw Error(
-    "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+    'Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.',
   );
 }
 function createResponseFromOptions(options) {
@@ -2019,10 +2019,10 @@
     options.serverConsumerManifest.moduleLoading,
     noServerCall$1,
     options.encodeFormAction,
-    "string" === typeof options.nonce ? options.nonce : void 0,
+    'string' === typeof options.nonce ? options.nonce : void 0,
     options && options.temporaryReferences
       ? options.temporaryReferences
-      : void 0
+      : void 0,
   );
 }
 function startReadingFromStream$1(response, stream, onDone) {
@@ -2041,13 +2041,13 @@
 }
 function noServerCall() {
   throw Error(
-    "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+    'Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.',
   );
 }
 function startReadingFromStream(response, stream, onEnd) {
   var streamState = createStreamState();
-  stream.on("data", function (chunk) {
-    if ("string" === typeof chunk) {
+  stream.on('data', function (chunk) {
+    if ('string' === typeof chunk) {
       for (
         var i = 0,
           rowState = streamState._rowState,
@@ -2100,23 +2100,23 @@
                   (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
             continue;
           case 3:
-            lastIdx = chunk.indexOf("\n", i);
+            lastIdx = chunk.indexOf('\n', i);
             break;
           case 4:
             if (84 !== rowTag)
               throw Error(
-                "Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams."
+                'Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams.',
               );
             if (rowLength < chunk.length || chunk.length > 3 * rowLength)
               throw Error(
-                "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+                'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
               );
             lastIdx = chunk.length;
         }
         if (-1 < lastIdx) {
           if (0 < buffer.length)
             throw Error(
-              "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+              'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
             );
           i = chunk.slice(i, lastIdx);
           processFullStringRow(response, streamState, rowID, rowTag, i);
@@ -2126,7 +2126,7 @@
           buffer.length = 0;
         } else if (chunk.length !== i)
           throw Error(
-            "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+            'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
           );
       }
       streamState._rowState = rowState;
@@ -2135,10 +2135,10 @@
       streamState._rowLength = rowLength;
     } else processBinaryChunk(response, streamState, chunk);
   });
-  stream.on("error", function (error) {
+  stream.on('error', function (error) {
     reportGlobalError(response, error);
   });
-  stream.on("end", onEnd);
+  stream.on('end', onEnd);
 }
 exports.createFromFetch = function (promiseForResponse, options) {
   var response = createResponseFromOptions(options);
@@ -2148,14 +2148,14 @@
     },
     function (e) {
       reportGlobalError(response, e);
-    }
+    },
   );
   return getChunk(response, 0);
 };
 exports.createFromNodeStream = function (
   stream,
   serverConsumerManifest,
-  options
+  options,
 ) {
   serverConsumerManifest = new ResponseInstance(
     serverConsumerManifest.moduleMap,
@@ -2163,13 +2163,13 @@
     serverConsumerManifest.moduleLoading,
     noServerCall,
     options ? options.encodeFormAction : void 0,
-    options && "string" === typeof options.nonce ? options.nonce : void 0,
-    void 0
+    options && 'string' === typeof options.nonce ? options.nonce : void 0,
+    void 0,
   );
   startReadingFromStream(
     serverConsumerManifest,
     stream,
-    close.bind(null, serverConsumerManifest)
+    close.bind(null, serverConsumerManifest),
   );
   return getChunk(serverConsumerManifest, 0);
 };
@@ -2188,12 +2188,12 @@
   return new Promise(function (resolve, reject) {
     var abort = processReply(
       value,
-      "",
+      '',
       options && options.temporaryReferences
         ? options.temporaryReferences
         : void 0,
       resolve,
-      reject
+      reject,
     );
     if (options && options.signal) {
       var signal = options.signal;
@@ -2201,9 +2201,9 @@
       else {
         var listener = function () {
           abort(signal.reason);
-          signal.removeEventListener("abort", listener);
+          signal.removeEventListener('abort', listener);
         };
-        signal.addEventListener("abort", listener);
+        signal.addEventListener('abort', listener);
       }
     }
   });
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.node.unbundled.development.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.unbundled.development.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.node.unbundled.development.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.unbundled.development.js	2025-12-17 14:32:44
@@ -8,31 +8,31 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
+'use strict';
+'production' !== process.env.NODE_ENV &&
   (function () {
     function resolveClientReference(bundlerConfig, metadata) {
       var moduleExports = bundlerConfig[metadata[0]];
       if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))
         moduleExports = bundlerConfig.name;
       else {
-        bundlerConfig = moduleExports && moduleExports["*"];
+        bundlerConfig = moduleExports && moduleExports['*'];
         if (!bundlerConfig)
           throw Error(
             'Could not find the module "' +
               metadata[0] +
-              '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'
+              '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.',
           );
         moduleExports = metadata[2];
       }
       return {
         specifier: bundlerConfig.specifier,
         name: moduleExports,
-        async: 4 === metadata.length
+        async: 4 === metadata.length,
       };
     }
     function resolveServerReference(bundlerConfig, id) {
-      var idx = id.lastIndexOf("#");
+      var idx = id.lastIndexOf('#');
       bundlerConfig = id.slice(0, idx);
       id = id.slice(idx + 1);
       return { specifier: bundlerConfig, name: id };
@@ -40,7 +40,7 @@
     function preloadModule(metadata) {
       var existingPromise = asyncModuleCache.get(metadata.specifier);
       if (existingPromise)
-        return "fulfilled" === existingPromise.status ? null : existingPromise;
+        return 'fulfilled' === existingPromise.status ? null : existingPromise;
       var modulePromise = import(metadata.specifier);
       metadata.async &&
         (modulePromise = modulePromise.then(function (value) {
@@ -49,33 +49,33 @@
       modulePromise.then(
         function (value) {
           var fulfilledThenable = modulePromise;
-          fulfilledThenable.status = "fulfilled";
+          fulfilledThenable.status = 'fulfilled';
           fulfilledThenable.value = value;
         },
         function (reason) {
           var rejectedThenable = modulePromise;
-          rejectedThenable.status = "rejected";
+          rejectedThenable.status = 'rejected';
           rejectedThenable.reason = reason;
-        }
+        },
       );
       asyncModuleCache.set(metadata.specifier, modulePromise);
       return modulePromise;
     }
     function requireModule(metadata) {
       var moduleExports = asyncModuleCache.get(metadata.specifier);
-      if ("fulfilled" === moduleExports.status)
+      if ('fulfilled' === moduleExports.status)
         moduleExports = moduleExports.value;
       else throw moduleExports.reason;
-      return "*" === metadata.name
+      return '*' === metadata.name
         ? moduleExports
-        : "" === metadata.name
+        : '' === metadata.name
           ? moduleExports.default
           : moduleExports[metadata.name];
     }
     function prepareDestinationWithChunks(
       moduleLoading,
       chunks,
-      nonce$jscomp$0
+      nonce$jscomp$0,
     ) {
       if (null !== moduleLoading)
         for (var i = 1; i < chunks.length; i += 2) {
@@ -85,25 +85,25 @@
             JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];
           var JSCompiler_inline_result = moduleLoading.crossOrigin;
           JSCompiler_inline_result =
-            "string" === typeof JSCompiler_inline_result
-              ? "use-credentials" === JSCompiler_inline_result
+            'string' === typeof JSCompiler_inline_result
+              ? 'use-credentials' === JSCompiler_inline_result
                 ? JSCompiler_inline_result
-                : ""
+                : ''
               : void 0;
           JSCompiler_temp_const$jscomp$0.call(
             JSCompiler_temp_const,
             JSCompiler_temp_const$jscomp$1,
-            { crossOrigin: JSCompiler_inline_result, nonce: nonce }
+            { crossOrigin: JSCompiler_inline_result, nonce: nonce },
           );
         }
     }
     function getIteratorFn(maybeIterable) {
-      if (null === maybeIterable || "object" !== typeof maybeIterable)
+      if (null === maybeIterable || 'object' !== typeof maybeIterable)
         return null;
       maybeIterable =
         (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-        maybeIterable["@@iterator"];
-      return "function" === typeof maybeIterable ? maybeIterable : null;
+        maybeIterable['@@iterator'];
+      return 'function' === typeof maybeIterable ? maybeIterable : null;
     }
     function isObjectPrototype(object) {
       if (!object) return !1;
@@ -126,8 +126,8 @@
         if (
           !descriptor ||
           (!descriptor.enumerable &&
-            (("key" !== names[i] && "ref" !== names[i]) ||
-              "function" !== typeof descriptor.get))
+            (('key' !== names[i] && 'ref' !== names[i]) ||
+              'function' !== typeof descriptor.get))
         )
           return !1;
       }
@@ -143,35 +143,35 @@
     }
     function describeValueForErrorMessage(value) {
       switch (typeof value) {
-        case "string":
+        case 'string':
           return JSON.stringify(
-            10 >= value.length ? value : value.slice(0, 10) + "..."
+            10 >= value.length ? value : value.slice(0, 10) + '...',
           );
-        case "object":
-          if (isArrayImpl(value)) return "[...]";
+        case 'object':
+          if (isArrayImpl(value)) return '[...]';
           if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-            return "client";
+            return 'client';
           value = objectName(value);
-          return "Object" === value ? "{...}" : value;
-        case "function":
+          return 'Object' === value ? '{...}' : value;
+        case 'function':
           return value.$$typeof === CLIENT_REFERENCE_TAG
-            ? "client"
+            ? 'client'
             : (value = value.displayName || value.name)
-              ? "function " + value
-              : "function";
+              ? 'function ' + value
+              : 'function';
         default:
           return String(value);
       }
     }
     function describeElementType(type) {
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (type.$$typeof) {
           case REACT_FORWARD_REF_TYPE:
             return describeElementType(type.render);
@@ -184,74 +184,74 @@
               return describeElementType(type(payload));
             } catch (x) {}
         }
-      return "";
+      return '';
     }
     function describeObjectForErrorMessage(objectOrArray, expandedName) {
       var objKind = objectName(objectOrArray);
-      if ("Object" !== objKind && "Array" !== objKind) return objKind;
+      if ('Object' !== objKind && 'Array' !== objKind) return objKind;
       var start = -1,
         length = 0;
       if (isArrayImpl(objectOrArray))
         if (jsxChildrenParents.has(objectOrArray)) {
           var type = jsxChildrenParents.get(objectOrArray);
-          objKind = "<" + describeElementType(type) + ">";
+          objKind = '<' + describeElementType(type) + '>';
           for (var i = 0; i < objectOrArray.length; i++) {
             var value = objectOrArray[i];
             value =
-              "string" === typeof value
+              'string' === typeof value
                 ? value
-                : "object" === typeof value && null !== value
-                  ? "{" + describeObjectForErrorMessage(value) + "}"
-                  : "{" + describeValueForErrorMessage(value) + "}";
-            "" + i === expandedName
+                : 'object' === typeof value && null !== value
+                  ? '{' + describeObjectForErrorMessage(value) + '}'
+                  : '{' + describeValueForErrorMessage(value) + '}';
+            '' + i === expandedName
               ? ((start = objKind.length),
                 (length = value.length),
                 (objKind += value))
               : (objKind =
                   15 > value.length && 40 > objKind.length + value.length
                     ? objKind + value
-                    : objKind + "{...}");
+                    : objKind + '{...}');
           }
-          objKind += "</" + describeElementType(type) + ">";
+          objKind += '</' + describeElementType(type) + '>';
         } else {
-          objKind = "[";
+          objKind = '[';
           for (type = 0; type < objectOrArray.length; type++)
-            0 < type && (objKind += ", "),
+            0 < type && (objKind += ', '),
               (i = objectOrArray[type]),
               (i =
-                "object" === typeof i && null !== i
+                'object' === typeof i && null !== i
                   ? describeObjectForErrorMessage(i)
                   : describeValueForErrorMessage(i)),
-              "" + type === expandedName
+              '' + type === expandedName
                 ? ((start = objKind.length),
                   (length = i.length),
                   (objKind += i))
                 : (objKind =
                     10 > i.length && 40 > objKind.length + i.length
                       ? objKind + i
-                      : objKind + "...");
-          objKind += "]";
+                      : objKind + '...');
+          objKind += ']';
         }
       else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-        objKind = "<" + describeElementType(objectOrArray.type) + "/>";
+        objKind = '<' + describeElementType(objectOrArray.type) + '/>';
       else {
-        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
         if (jsxPropsParents.has(objectOrArray)) {
           objKind = jsxPropsParents.get(objectOrArray);
-          objKind = "<" + (describeElementType(objKind) || "...");
+          objKind = '<' + (describeElementType(objKind) || '...');
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++) {
-            objKind += " ";
+            objKind += ' ';
             value = type[i];
-            objKind += describeKeyForErrorMessage(value) + "=";
+            objKind += describeKeyForErrorMessage(value) + '=';
             var _value2 = objectOrArray[value];
             var _substr2 =
               value === expandedName &&
-              "object" === typeof _value2 &&
+              'object' === typeof _value2 &&
               null !== _value2
                 ? describeObjectForErrorMessage(_value2)
                 : describeValueForErrorMessage(_value2);
-            "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
+            'string' !== typeof _value2 && (_substr2 = '{' + _substr2 + '}');
             value === expandedName
               ? ((start = objKind.length),
                 (length = _substr2.length),
@@ -259,19 +259,19 @@
               : (objKind =
                   10 > _substr2.length && 40 > objKind.length + _substr2.length
                     ? objKind + _substr2
-                    : objKind + "...");
+                    : objKind + '...');
           }
-          objKind += ">";
+          objKind += '>';
         } else {
-          objKind = "{";
+          objKind = '{';
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++)
-            0 < i && (objKind += ", "),
+            0 < i && (objKind += ', '),
               (value = type[i]),
-              (objKind += describeKeyForErrorMessage(value) + ": "),
+              (objKind += describeKeyForErrorMessage(value) + ': '),
               (_value2 = objectOrArray[value]),
               (_value2 =
-                "object" === typeof _value2 && null !== _value2
+                'object' === typeof _value2 && null !== _value2
                   ? describeObjectForErrorMessage(_value2)
                   : describeValueForErrorMessage(_value2)),
               value === expandedName
@@ -281,47 +281,47 @@
                 : (objKind =
                     10 > _value2.length && 40 > objKind.length + _value2.length
                       ? objKind + _value2
-                      : objKind + "...");
-          objKind += "}";
+                      : objKind + '...');
+          objKind += '}';
         }
       }
       return void 0 === expandedName
         ? objKind
         : -1 < start && 0 < length
-          ? ((objectOrArray = " ".repeat(start) + "^".repeat(length)),
-            "\n  " + objKind + "\n  " + objectOrArray)
-          : "\n  " + objKind;
+          ? ((objectOrArray = ' '.repeat(start) + '^'.repeat(length)),
+            '\n  ' + objKind + '\n  ' + objectOrArray)
+          : '\n  ' + objKind;
     }
     function serializeNumber(number) {
       return Number.isFinite(number)
         ? 0 === number && -Infinity === 1 / number
-          ? "$-0"
+          ? '$-0'
           : number
         : Infinity === number
-          ? "$Infinity"
+          ? '$Infinity'
           : -Infinity === number
-            ? "$-Infinity"
-            : "$NaN";
+            ? '$-Infinity'
+            : '$NaN';
     }
     function processReply(
       root,
       formFieldPrefix,
       temporaryReferences,
       resolve,
-      reject
+      reject,
     ) {
       function serializeTypedArray(tag, typedArray) {
         typedArray = new Blob([
           new Uint8Array(
             typedArray.buffer,
             typedArray.byteOffset,
-            typedArray.byteLength
-          )
+            typedArray.byteLength,
+          ),
         ]);
         var blobId = nextPartId++;
         null === formData && (formData = new FormData());
         formData.append(formFieldPrefix + blobId, typedArray);
-        return "$" + tag + blobId.toString(16);
+        return '$' + tag + blobId.toString(16);
       }
       function serializeBinaryReader(reader) {
         function progress(entry) {
@@ -330,9 +330,9 @@
               data.append(formFieldPrefix + entry, new Blob(buffer)),
               data.append(
                 formFieldPrefix + streamId,
-                '"$o' + entry.toString(16) + '"'
+                '"$o' + entry.toString(16) + '"',
               ),
-              data.append(formFieldPrefix + streamId, "C"),
+              data.append(formFieldPrefix + streamId, 'C'),
               pendingParts--,
               0 === pendingParts && resolve(data))
             : (buffer.push(entry.value),
@@ -344,12 +344,12 @@
         var streamId = nextPartId++,
           buffer = [];
         reader.read(new Uint8Array(1024)).then(progress, reject);
-        return "$r" + streamId.toString(16);
+        return '$r' + streamId.toString(16);
       }
       function serializeReader(reader) {
         function progress(entry) {
           if (entry.done)
-            data.append(formFieldPrefix + streamId, "C"),
+            data.append(formFieldPrefix + streamId, 'C'),
               pendingParts--,
               0 === pendingParts && resolve(data);
           else
@@ -366,11 +366,11 @@
         pendingParts++;
         var streamId = nextPartId++;
         reader.read().then(progress, reject);
-        return "$R" + streamId.toString(16);
+        return '$R' + streamId.toString(16);
       }
       function serializeReadableStream(stream) {
         try {
-          var binaryReader = stream.getReader({ mode: "byob" });
+          var binaryReader = stream.getReader({ mode: 'byob' });
         } catch (x) {
           return serializeReader(stream.getReader());
         }
@@ -380,11 +380,11 @@
         function progress(entry) {
           if (entry.done) {
             if (void 0 === entry.value)
-              data.append(formFieldPrefix + streamId, "C");
+              data.append(formFieldPrefix + streamId, 'C');
             else
               try {
                 var partJSON = JSON.stringify(entry.value, resolveToJSON);
-                data.append(formFieldPrefix + streamId, "C" + partJSON);
+                data.append(formFieldPrefix + streamId, 'C' + partJSON);
               } catch (x) {
                 reject(x);
                 return;
@@ -406,38 +406,38 @@
         var streamId = nextPartId++;
         iterable = iterable === iterator;
         iterator.next().then(progress, reject);
-        return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+        return '$' + (iterable ? 'x' : 'X') + streamId.toString(16);
       }
       function resolveToJSON(key, value) {
         var originalValue = this[key];
-        "object" !== typeof originalValue ||
+        'object' !== typeof originalValue ||
           originalValue === value ||
           originalValue instanceof Date ||
-          ("Object" !== objectName(originalValue)
+          ('Object' !== objectName(originalValue)
             ? console.error(
-                "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                'Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s',
                 objectName(originalValue),
-                describeObjectForErrorMessage(this, key)
+                describeObjectForErrorMessage(this, key),
               )
             : console.error(
-                "Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s",
-                describeObjectForErrorMessage(this, key)
+                'Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s',
+                describeObjectForErrorMessage(this, key),
               ));
         if (null === value) return null;
-        if ("object" === typeof value) {
+        if ('object' === typeof value) {
           switch (value.$$typeof) {
             case REACT_ELEMENT_TYPE:
-              if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+              if (void 0 !== temporaryReferences && -1 === key.indexOf(':')) {
                 var parentReference = writtenObjects.get(this);
                 if (void 0 !== parentReference)
                   return (
-                    temporaryReferences.set(parentReference + ":" + key, value),
-                    "$T"
+                    temporaryReferences.set(parentReference + ':' + key, value),
+                    '$T'
                   );
               }
               throw Error(
-                "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
-                  describeObjectForErrorMessage(this, key)
+                'React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.' +
+                  describeObjectForErrorMessage(this, key),
               );
             case REACT_LAZY_TYPE:
               originalValue = value._payload;
@@ -449,12 +449,12 @@
                 var lazyId = nextPartId++,
                   partJSON = serializeModel(parentReference, lazyId);
                 formData.append(formFieldPrefix + lazyId, partJSON);
-                return "$" + lazyId.toString(16);
+                return '$' + lazyId.toString(16);
               } catch (x) {
                 if (
-                  "object" === typeof x &&
+                  'object' === typeof x &&
                   null !== x &&
-                  "function" === typeof x.then
+                  'function' === typeof x.then
                 ) {
                   pendingParts++;
                   var _lazyId = nextPartId++;
@@ -470,7 +470,7 @@
                     }
                   };
                   x.then(parentReference, parentReference);
-                  return "$" + _lazyId.toString(16);
+                  return '$' + _lazyId.toString(16);
                 }
                 reject(x);
                 return null;
@@ -478,7 +478,7 @@
                 pendingParts--;
               }
           }
-          if ("function" === typeof value.then) {
+          if ('function' === typeof value.then) {
             null === formData && (formData = new FormData());
             pendingParts++;
             var promiseId = nextPartId++;
@@ -493,17 +493,17 @@
                 reject(reason);
               }
             }, reject);
-            return "$@" + promiseId.toString(16);
+            return '$@' + promiseId.toString(16);
           }
           parentReference = writtenObjects.get(value);
           if (void 0 !== parentReference)
             if (modelRoot === value) modelRoot = null;
             else return parentReference;
           else
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
               ((parentReference = writtenObjects.get(this)),
               void 0 !== parentReference &&
-                ((parentReference = parentReference + ":" + key),
+                ((parentReference = parentReference + ':' + key),
                 writtenObjects.set(value, parentReference),
                 void 0 !== temporaryReferences &&
                   temporaryReferences.set(parentReference, value)));
@@ -512,11 +512,11 @@
             null === formData && (formData = new FormData());
             var _data3 = formData;
             key = nextPartId++;
-            var prefix = formFieldPrefix + key + "_";
+            var prefix = formFieldPrefix + key + '_';
             value.forEach(function (originalValue, originalKey) {
               _data3.append(prefix + originalKey, originalValue);
             });
-            return "$K" + key.toString(16);
+            return '$K' + key.toString(16);
           }
           if (value instanceof Map)
             return (
@@ -524,7 +524,7 @@
               (parentReference = serializeModel(Array.from(value), key)),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$Q" + key.toString(16)
+              '$Q' + key.toString(16)
             );
           if (value instanceof Set)
             return (
@@ -532,7 +532,7 @@
               (parentReference = serializeModel(Array.from(value), key)),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$W" + key.toString(16)
+              '$W' + key.toString(16)
             );
           if (value instanceof ArrayBuffer)
             return (
@@ -540,37 +540,37 @@
               (parentReference = nextPartId++),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + parentReference, key),
-              "$A" + parentReference.toString(16)
+              '$A' + parentReference.toString(16)
             );
           if (value instanceof Int8Array)
-            return serializeTypedArray("O", value);
+            return serializeTypedArray('O', value);
           if (value instanceof Uint8Array)
-            return serializeTypedArray("o", value);
+            return serializeTypedArray('o', value);
           if (value instanceof Uint8ClampedArray)
-            return serializeTypedArray("U", value);
+            return serializeTypedArray('U', value);
           if (value instanceof Int16Array)
-            return serializeTypedArray("S", value);
+            return serializeTypedArray('S', value);
           if (value instanceof Uint16Array)
-            return serializeTypedArray("s", value);
+            return serializeTypedArray('s', value);
           if (value instanceof Int32Array)
-            return serializeTypedArray("L", value);
+            return serializeTypedArray('L', value);
           if (value instanceof Uint32Array)
-            return serializeTypedArray("l", value);
+            return serializeTypedArray('l', value);
           if (value instanceof Float32Array)
-            return serializeTypedArray("G", value);
+            return serializeTypedArray('G', value);
           if (value instanceof Float64Array)
-            return serializeTypedArray("g", value);
+            return serializeTypedArray('g', value);
           if (value instanceof BigInt64Array)
-            return serializeTypedArray("M", value);
+            return serializeTypedArray('M', value);
           if (value instanceof BigUint64Array)
-            return serializeTypedArray("m", value);
-          if (value instanceof DataView) return serializeTypedArray("V", value);
-          if ("function" === typeof Blob && value instanceof Blob)
+            return serializeTypedArray('m', value);
+          if (value instanceof DataView) return serializeTypedArray('V', value);
+          if ('function' === typeof Blob && value instanceof Blob)
             return (
               null === formData && (formData = new FormData()),
               (key = nextPartId++),
               formData.append(formFieldPrefix + key, value),
-              "$B" + key.toString(16)
+              '$B' + key.toString(16)
             );
           if ((parentReference = getIteratorFn(value)))
             return (
@@ -579,20 +579,20 @@
                 ? ((key = nextPartId++),
                   (parentReference = serializeModel(
                     Array.from(parentReference),
-                    key
+                    key,
                   )),
                   null === formData && (formData = new FormData()),
                   formData.append(formFieldPrefix + key, parentReference),
-                  "$i" + key.toString(16))
+                  '$i' + key.toString(16))
                 : Array.from(parentReference)
             );
           if (
-            "function" === typeof ReadableStream &&
+            'function' === typeof ReadableStream &&
             value instanceof ReadableStream
           )
             return serializeReadableStream(value);
           parentReference = value[ASYNC_ITERATOR];
-          if ("function" === typeof parentReference)
+          if ('function' === typeof parentReference)
             return serializeAsyncIterable(value, parentReference.call(value));
           parentReference = getPrototypeOf(value);
           if (
@@ -602,98 +602,98 @@
           ) {
             if (void 0 === temporaryReferences)
               throw Error(
-                "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported." +
-                  describeObjectForErrorMessage(this, key)
+                'Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.' +
+                  describeObjectForErrorMessage(this, key),
               );
-            return "$T";
+            return '$T';
           }
           value.$$typeof === REACT_CONTEXT_TYPE
             ? console.error(
-                "React Context Providers cannot be passed to Server Functions from the Client.%s",
-                describeObjectForErrorMessage(this, key)
+                'React Context Providers cannot be passed to Server Functions from the Client.%s',
+                describeObjectForErrorMessage(this, key),
               )
-            : "Object" !== objectName(value)
+            : 'Object' !== objectName(value)
               ? console.error(
-                  "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                  'Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s',
                   objectName(value),
-                  describeObjectForErrorMessage(this, key)
+                  describeObjectForErrorMessage(this, key),
                 )
               : isSimpleObject(value)
                 ? Object.getOwnPropertySymbols &&
                   ((parentReference = Object.getOwnPropertySymbols(value)),
                   0 < parentReference.length &&
                     console.error(
-                      "Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s",
+                      'Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s',
                       parentReference[0].description,
-                      describeObjectForErrorMessage(this, key)
+                      describeObjectForErrorMessage(this, key),
                     ))
                 : console.error(
-                    "Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s",
-                    describeObjectForErrorMessage(this, key)
+                    'Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s',
+                    describeObjectForErrorMessage(this, key),
                   );
           return value;
         }
-        if ("string" === typeof value) {
-          if ("Z" === value[value.length - 1] && this[key] instanceof Date)
-            return "$D" + value;
-          key = "$" === value[0] ? "$" + value : value;
+        if ('string' === typeof value) {
+          if ('Z' === value[value.length - 1] && this[key] instanceof Date)
+            return '$D' + value;
+          key = '$' === value[0] ? '$' + value : value;
           return key;
         }
-        if ("boolean" === typeof value) return value;
-        if ("number" === typeof value) return serializeNumber(value);
-        if ("undefined" === typeof value) return "$undefined";
-        if ("function" === typeof value) {
+        if ('boolean' === typeof value) return value;
+        if ('number' === typeof value) return serializeNumber(value);
+        if ('undefined' === typeof value) return '$undefined';
+        if ('function' === typeof value) {
           parentReference = knownServerReferences.get(value);
           if (void 0 !== parentReference)
             return (
               (key = JSON.stringify(
                 { id: parentReference.id, bound: parentReference.bound },
-                resolveToJSON
+                resolveToJSON,
               )),
               null === formData && (formData = new FormData()),
               (parentReference = nextPartId++),
               formData.set(formFieldPrefix + parentReference, key),
-              "$F" + parentReference.toString(16)
+              '$F' + parentReference.toString(16)
             );
           if (
             void 0 !== temporaryReferences &&
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
             ((parentReference = writtenObjects.get(this)),
             void 0 !== parentReference)
           )
             return (
-              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+              temporaryReferences.set(parentReference + ':' + key, value), '$T'
             );
           throw Error(
-            "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+            'Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.',
           );
         }
-        if ("symbol" === typeof value) {
+        if ('symbol' === typeof value) {
           if (
             void 0 !== temporaryReferences &&
-            -1 === key.indexOf(":") &&
+            -1 === key.indexOf(':') &&
             ((parentReference = writtenObjects.get(this)),
             void 0 !== parentReference)
           )
             return (
-              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+              temporaryReferences.set(parentReference + ':' + key, value), '$T'
             );
           throw Error(
-            "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
-              describeObjectForErrorMessage(this, key)
+            'Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.' +
+              describeObjectForErrorMessage(this, key),
           );
         }
-        if ("bigint" === typeof value) return "$n" + value.toString(10);
+        if ('bigint' === typeof value) return '$n' + value.toString(10);
         throw Error(
-          "Type " +
+          'Type ' +
             typeof value +
-            " is not supported as an argument to a Server Function."
+            ' is not supported as an argument to a Server Function.',
         );
       }
       function serializeModel(model, id) {
-        "object" === typeof model &&
+        'object' === typeof model &&
           null !== model &&
-          ((id = "$" + id.toString(16)),
+          ((id = '$' + id.toString(16)),
           writtenObjects.set(model, id),
           void 0 !== temporaryReferences && temporaryReferences.set(id, model));
         modelRoot = model;
@@ -707,7 +707,7 @@
         json = serializeModel(root, 0);
       null === formData
         ? resolve(json)
-        : (formData.set(formFieldPrefix + "0", json),
+        : (formData.set(formFieldPrefix + '0', json),
           0 === pendingParts && resolve(formData));
       return function () {
         0 < pendingParts &&
@@ -724,23 +724,23 @@
         });
       processReply(
         reference,
-        "",
+        '',
         void 0,
         function (body) {
-          if ("string" === typeof body) {
+          if ('string' === typeof body) {
             var data = new FormData();
-            data.append("0", body);
+            data.append('0', body);
             body = data;
           }
-          thenable.status = "fulfilled";
+          thenable.status = 'fulfilled';
           thenable.value = body;
           resolve(body);
         },
         function (e) {
-          thenable.status = "rejected";
+          thenable.status = 'rejected';
           thenable.reason = e;
           reject(e);
-        }
+        },
       );
       return thenable;
     }
@@ -748,7 +748,7 @@
       var referenceClosure = knownServerReferences.get(this);
       if (!referenceClosure)
         throw Error(
-          "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+          'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
         );
       var data = null;
       if (null !== referenceClosure.bound) {
@@ -756,55 +756,55 @@
         data ||
           ((data = encodeFormData({
             id: referenceClosure.id,
-            bound: referenceClosure.bound
+            bound: referenceClosure.bound,
           })),
           boundCache.set(referenceClosure, data));
-        if ("rejected" === data.status) throw data.reason;
-        if ("fulfilled" !== data.status) throw data;
+        if ('rejected' === data.status) throw data.reason;
+        if ('fulfilled' !== data.status) throw data;
         referenceClosure = data.value;
         var prefixedData = new FormData();
         referenceClosure.forEach(function (value, key) {
-          prefixedData.append("$ACTION_" + identifierPrefix + ":" + key, value);
+          prefixedData.append('$ACTION_' + identifierPrefix + ':' + key, value);
         });
         data = prefixedData;
-        referenceClosure = "$ACTION_REF_" + identifierPrefix;
-      } else referenceClosure = "$ACTION_ID_" + referenceClosure.id;
+        referenceClosure = '$ACTION_REF_' + identifierPrefix;
+      } else referenceClosure = '$ACTION_ID_' + referenceClosure.id;
       return {
         name: referenceClosure,
-        method: "POST",
-        encType: "multipart/form-data",
-        data: data
+        method: 'POST',
+        encType: 'multipart/form-data',
+        data: data,
       };
     }
     function isSignatureEqual(referenceId, numberOfBoundArgs) {
       var referenceClosure = knownServerReferences.get(this);
       if (!referenceClosure)
         throw Error(
-          "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+          'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
         );
       if (referenceClosure.id !== referenceId) return !1;
       var boundPromise = referenceClosure.bound;
       if (null === boundPromise) return 0 === numberOfBoundArgs;
       switch (boundPromise.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return boundPromise.value.length === numberOfBoundArgs;
-        case "pending":
+        case 'pending':
           throw boundPromise;
-        case "rejected":
+        case 'rejected':
           throw boundPromise.reason;
         default:
           throw (
-            ("string" !== typeof boundPromise.status &&
-              ((boundPromise.status = "pending"),
+            ('string' !== typeof boundPromise.status &&
+              ((boundPromise.status = 'pending'),
               boundPromise.then(
                 function (boundArgs) {
-                  boundPromise.status = "fulfilled";
+                  boundPromise.status = 'fulfilled';
                   boundPromise.value = boundArgs;
                 },
                 function (error) {
-                  boundPromise.status = "rejected";
+                  boundPromise.status = 'rejected';
                   boundPromise.reason = error;
-                }
+                },
               )),
             boundPromise)
           );
@@ -817,36 +817,36 @@
       line,
       col,
       environmentName,
-      innerFunction
+      innerFunction,
     ) {
-      name || (name = "<anonymous>");
+      name || (name = '<anonymous>');
       var encodedName = JSON.stringify(name);
       1 >= line
         ? ((line = encodedName.length + 7),
           (col =
-            "s=>({" +
+            's=>({' +
             encodedName +
-            " ".repeat(col < line ? 0 : col - line) +
-            ":(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */"))
+            ' '.repeat(col < line ? 0 : col - line) +
+            ':(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */'))
         : (col =
-            "/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */" +
-            "\n".repeat(line - 2) +
-            "server=>({" +
+            '/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */' +
+            '\n'.repeat(line - 2) +
+            'server=>({' +
             encodedName +
-            ":\n" +
-            " ".repeat(1 > col ? 0 : col - 1) +
-            "(...args) => server(...args)})");
-      filename.startsWith("/") && (filename = "file://" + filename);
+            ':\n' +
+            ' '.repeat(1 > col ? 0 : col - 1) +
+            '(...args) => server(...args)})');
+      filename.startsWith('/') && (filename = 'file://' + filename);
       sourceMap
         ? ((col +=
-            "\n//# sourceURL=about://React/" +
+            '\n//# sourceURL=about://React/' +
             encodeURIComponent(environmentName) +
-            "/" +
+            '/' +
             encodeURI(filename) +
-            "?s" +
+            '?s' +
             fakeServerFunctionIdx++),
-          (col += "\n//# sourceMappingURL=" + sourceMap))
-        : filename && (col += "\n//# sourceURL=" + filename);
+          (col += '\n//# sourceMappingURL=' + sourceMap))
+        : filename && (col += '\n//# sourceURL=' + filename);
       try {
         return (0, eval)(col)(innerFunction)[name];
       } catch (x) {
@@ -857,13 +857,13 @@
       reference,
       id,
       bound,
-      encodeFormAction
+      encodeFormAction,
     ) {
       knownServerReferences.has(reference) ||
         (knownServerReferences.set(reference, {
           id: id,
           originalBind: reference.bind,
-          bound: bound
+          bound: bound,
         }),
         Object.defineProperties(reference, {
           $$FORM_ACTION: {
@@ -874,16 +874,16 @@
                     var referenceClosure = knownServerReferences.get(this);
                     if (!referenceClosure)
                       throw Error(
-                        "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+                        'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
                       );
                     var boundPromise = referenceClosure.bound;
                     null === boundPromise &&
                       (boundPromise = Promise.resolve([]));
                     return encodeFormAction(referenceClosure.id, boundPromise);
-                  }
+                  },
           },
           $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-          bind: { value: bind }
+          bind: { value: bind },
         }));
     }
     function bind() {
@@ -892,7 +892,7 @@
       var newFn = referenceClosure.originalBind.apply(this, arguments);
       null != arguments[0] &&
         console.error(
-          'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().'
+          'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().',
         );
       var args = ArraySlice.call(arguments, 1),
         boundPromise = null;
@@ -905,12 +905,12 @@
       knownServerReferences.set(newFn, {
         id: referenceClosure.id,
         originalBind: newFn.bind,
-        bound: boundPromise
+        bound: boundPromise,
       });
       Object.defineProperties(newFn, {
         $$FORM_ACTION: { value: this.$$FORM_ACTION },
         $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-        bind: { value: bind }
+        bind: { value: bind },
       });
       return newFn;
     }
@@ -918,12 +918,12 @@
       metaData,
       callServer,
       encodeFormAction,
-      findSourceMapURL
+      findSourceMapURL,
     ) {
       function action() {
         var args = Array.prototype.slice.call(arguments);
         return bound
-          ? "fulfilled" === bound.status
+          ? 'fulfilled' === bound.status
             ? callServer(id, bound.value.concat(args))
             : Promise.resolve(bound).then(function (boundArgs) {
                 return callServer(id, boundArgs.concat(args));
@@ -934,11 +934,11 @@
         bound = metaData.bound,
         location = metaData.location;
       if (location) {
-        var functionName = metaData.name || "",
+        var functionName = metaData.name || '',
           filename = location[1],
           line = location[2];
         location = location[3];
-        metaData = metaData.env || "Server";
+        metaData = metaData.env || 'Server';
         findSourceMapURL =
           null == findSourceMapURL
             ? null
@@ -950,7 +950,7 @@
           line,
           location,
           metaData,
-          action
+          action,
         );
       }
       registerBoundServerReference(action, id, bound, encodeFormAction);
@@ -958,11 +958,11 @@
     }
     function parseStackLocation(error) {
       error = error.stack;
-      error.startsWith("Error: react-stack-top-frame\n") &&
+      error.startsWith('Error: react-stack-top-frame\n') &&
         (error = error.slice(29));
-      var endOfFirst = error.indexOf("\n");
+      var endOfFirst = error.indexOf('\n');
       if (-1 !== endOfFirst) {
-        var endOfSecond = error.indexOf("\n", endOfFirst + 1);
+        var endOfSecond = error.indexOf('\n', endOfFirst + 1);
         endOfFirst =
           -1 === endOfSecond
             ? error.slice(endOfFirst + 1)
@@ -974,15 +974,15 @@
         ((error = jscSpiderMonkeyFrameRegExp.exec(endOfFirst)), !error)
       )
         return null;
-      endOfFirst = error[1] || "";
-      "<anonymous>" === endOfFirst && (endOfFirst = "");
-      endOfSecond = error[2] || error[5] || "";
-      "<anonymous>" === endOfSecond && (endOfSecond = "");
+      endOfFirst = error[1] || '';
+      '<anonymous>' === endOfFirst && (endOfFirst = '');
+      endOfSecond = error[2] || error[5] || '';
+      '<anonymous>' === endOfSecond && (endOfSecond = '');
       return [
         endOfFirst,
         endOfSecond,
         +(error[3] || error[6]),
-        +(error[4] || error[7])
+        +(error[4] || error[7]),
       ];
     }
     function createServerReference$1(
@@ -990,13 +990,13 @@
       callServer,
       encodeFormAction,
       findSourceMapURL,
-      functionName
+      functionName,
     ) {
       function action() {
         var args = Array.prototype.slice.call(arguments);
         return callServer(id, args);
       }
-      var location = parseStackLocation(Error("react-stack-top-frame"));
+      var location = parseStackLocation(Error('react-stack-top-frame'));
       if (null !== location) {
         var filename = location[1],
           line = location[2];
@@ -1004,15 +1004,15 @@
         findSourceMapURL =
           null == findSourceMapURL
             ? null
-            : findSourceMapURL(filename, "Client");
+            : findSourceMapURL(filename, 'Client');
         action = createFakeServerFunction(
-          functionName || "",
+          functionName || '',
           filename,
           findSourceMapURL,
           line,
           location,
-          "Client",
-          action
+          'Client',
+          action,
         );
       }
       registerBoundServerReference(action, id, null, encodeFormAction);
@@ -1020,52 +1020,52 @@
     }
     function getComponentNameFromType(type) {
       if (null == type) return null;
-      if ("function" === typeof type)
+      if ('function' === typeof type)
         return type.$$typeof === REACT_CLIENT_REFERENCE
           ? null
           : type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_FRAGMENT_TYPE:
-          return "Fragment";
+          return 'Fragment';
         case REACT_PROFILER_TYPE:
-          return "Profiler";
+          return 'Profiler';
         case REACT_STRICT_MODE_TYPE:
-          return "StrictMode";
+          return 'StrictMode';
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
         case REACT_ACTIVITY_TYPE:
-          return "Activity";
+          return 'Activity';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (
-          ("number" === typeof type.tag &&
+          ('number' === typeof type.tag &&
             console.error(
-              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
+              'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.',
             ),
           type.$$typeof)
         ) {
           case REACT_PORTAL_TYPE:
-            return "Portal";
+            return 'Portal';
           case REACT_CONTEXT_TYPE:
-            return type.displayName || "Context";
+            return type.displayName || 'Context';
           case REACT_CONSUMER_TYPE:
-            return (type._context.displayName || "Context") + ".Consumer";
+            return (type._context.displayName || 'Context') + '.Consumer';
           case REACT_FORWARD_REF_TYPE:
             var innerType = type.render;
             type = type.displayName;
             type ||
-              ((type = innerType.displayName || innerType.name || ""),
-              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
+              ((type = innerType.displayName || innerType.name || ''),
+              (type = '' !== type ? 'ForwardRef(' + type + ')' : 'ForwardRef'));
             return type;
           case REACT_MEMO_TYPE:
             return (
               (innerType = type.displayName || null),
               null !== innerType
                 ? innerType
-                : getComponentNameFromType(type.type) || "Memo"
+                : getComponentNameFromType(type.type) || 'Memo'
             );
           case REACT_LAZY_TYPE:
             innerType = type._payload;
@@ -1079,19 +1079,19 @@
     function getArrayKind(array) {
       for (var kind = 0, i = 0; i < array.length; i++) {
         var value = array[i];
-        if ("object" === typeof value && null !== value)
+        if ('object' === typeof value && null !== value)
           if (
             isArrayImpl(value) &&
             2 === value.length &&
-            "string" === typeof value[0]
+            'string' === typeof value[0]
           ) {
             if (0 !== kind && 3 !== kind) return 1;
             kind = 3;
           } else return 1;
         else {
           if (
-            "function" === typeof value ||
-            ("string" === typeof value && 50 < value.length) ||
+            'function' === typeof value ||
+            ('string' === typeof value && 50 < value.length) ||
             (0 !== kind && 2 !== kind)
           )
             return 1;
@@ -1103,7 +1103,7 @@
     function addObjectToProperties(object, properties, indent, prefix) {
       for (var key in object)
         hasOwnProperty.call(object, key) &&
-          "_" !== key[0] &&
+          '_' !== key[0] &&
           addValueToProperties(key, object[key], properties, indent, prefix);
     }
     function addValueToProperties(
@@ -1111,70 +1111,70 @@
       value,
       properties,
       indent,
-      prefix
+      prefix,
     ) {
       switch (typeof value) {
-        case "object":
+        case 'object':
           if (null === value) {
-            value = "null";
+            value = 'null';
             break;
           } else {
             if (value.$$typeof === REACT_ELEMENT_TYPE) {
-              var typeName = getComponentNameFromType(value.type) || "\u2026",
+              var typeName = getComponentNameFromType(value.type) || '\u2026',
                 key = value.key;
               value = value.props;
               var propsKeys = Object.keys(value),
                 propsLength = propsKeys.length;
               if (null == key && 0 === propsLength) {
-                value = "<" + typeName + " />";
+                value = '<' + typeName + ' />';
                 break;
               }
               if (
                 3 > indent ||
                 (1 === propsLength &&
-                  "children" === propsKeys[0] &&
+                  'children' === propsKeys[0] &&
                   null == key)
               ) {
-                value = "<" + typeName + " \u2026 />";
+                value = '<' + typeName + ' \u2026 />';
                 break;
               }
               properties.push([
-                prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-                "<" + typeName
+                prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+                '<' + typeName,
               ]);
               null !== key &&
                 addValueToProperties(
-                  "key",
+                  'key',
                   key,
                   properties,
                   indent + 1,
-                  prefix
+                  prefix,
                 );
               propertyName = !1;
               for (var propKey in value)
-                "children" === propKey
+                'children' === propKey
                   ? null != value.children &&
                     (!isArrayImpl(value.children) ||
                       0 < value.children.length) &&
                     (propertyName = !0)
                   : hasOwnProperty.call(value, propKey) &&
-                    "_" !== propKey[0] &&
+                    '_' !== propKey[0] &&
                     addValueToProperties(
                       propKey,
                       value[propKey],
                       properties,
                       indent + 1,
-                      prefix
+                      prefix,
                     );
               properties.push([
-                "",
-                propertyName ? ">\u2026</" + typeName + ">" : "/>"
+                '',
+                propertyName ? '>\u2026</' + typeName + '>' : '/>',
               ]);
               return;
             }
             typeName = Object.prototype.toString.call(value);
             typeName = typeName.slice(8, typeName.length - 1);
-            if ("Array" === typeName)
+            if ('Array' === typeName)
               if (
                 ((propKey = getArrayKind(value)),
                 2 === propKey || 0 === propKey)
@@ -1183,8 +1183,8 @@
                 break;
               } else if (3 === propKey) {
                 properties.push([
-                  prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-                  ""
+                  prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+                  '',
                 ]);
                 for (
                   propertyName = 0;
@@ -1197,12 +1197,12 @@
                       typeName[1],
                       properties,
                       indent + 1,
-                      prefix
+                      prefix,
                     );
                 return;
               }
-            if ("Promise" === typeName) {
-              if ("fulfilled" === value.status) {
+            if ('Promise' === typeName) {
+              if ('fulfilled' === value.status) {
                 if (
                   ((typeName = properties.length),
                   addValueToProperties(
@@ -1210,189 +1210,189 @@
                     value.value,
                     properties,
                     indent,
-                    prefix
+                    prefix,
                   ),
                   properties.length > typeName)
                 ) {
                   properties = properties[typeName];
                   properties[1] =
-                    "Promise<" + (properties[1] || "Object") + ">";
+                    'Promise<' + (properties[1] || 'Object') + '>';
                   return;
                 }
               } else if (
-                "rejected" === value.status &&
+                'rejected' === value.status &&
                 ((typeName = properties.length),
                 addValueToProperties(
                   propertyName,
                   value.reason,
                   properties,
                   indent,
-                  prefix
+                  prefix,
                 ),
                 properties.length > typeName)
               ) {
                 properties = properties[typeName];
-                properties[1] = "Rejected Promise<" + properties[1] + ">";
+                properties[1] = 'Rejected Promise<' + properties[1] + '>';
                 return;
               }
               properties.push([
-                "\u00a0\u00a0".repeat(indent) + propertyName,
-                "Promise"
+                '\u00a0\u00a0'.repeat(indent) + propertyName,
+                'Promise',
               ]);
               return;
             }
-            "Object" === typeName &&
+            'Object' === typeName &&
               (propKey = Object.getPrototypeOf(value)) &&
-              "function" === typeof propKey.constructor &&
+              'function' === typeof propKey.constructor &&
               (typeName = propKey.constructor.name);
             properties.push([
-              prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-              "Object" === typeName ? (3 > indent ? "" : "\u2026") : typeName
+              prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+              'Object' === typeName ? (3 > indent ? '' : '\u2026') : typeName,
             ]);
             3 > indent &&
               addObjectToProperties(value, properties, indent + 1, prefix);
             return;
           }
-        case "function":
-          value = "" === value.name ? "() => {}" : value.name + "() {}";
+        case 'function':
+          value = '' === value.name ? '() => {}' : value.name + '() {}';
           break;
-        case "string":
+        case 'string':
           value =
-            "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects." ===
+            'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.' ===
             value
-              ? "\u2026"
+              ? '\u2026'
               : JSON.stringify(value);
           break;
-        case "undefined":
-          value = "undefined";
+        case 'undefined':
+          value = 'undefined';
           break;
-        case "boolean":
-          value = value ? "true" : "false";
+        case 'boolean':
+          value = value ? 'true' : 'false';
           break;
         default:
           value = String(value);
       }
       properties.push([
-        prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
-        value
+        prefix + '\u00a0\u00a0'.repeat(indent) + propertyName,
+        value,
       ]);
     }
     function getIODescription(value) {
       try {
         switch (typeof value) {
-          case "object":
-            if (null === value) return "";
+          case 'object':
+            if (null === value) return '';
             if (value instanceof Error) return String(value.message);
-            if ("string" === typeof value.url) return value.url;
-            if ("string" === typeof value.href) return value.href;
-            if ("string" === typeof value.src) return value.src;
-            if ("string" === typeof value.currentSrc) return value.currentSrc;
-            if ("string" === typeof value.command) return value.command;
+            if ('string' === typeof value.url) return value.url;
+            if ('string' === typeof value.href) return value.href;
+            if ('string' === typeof value.src) return value.src;
+            if ('string' === typeof value.currentSrc) return value.currentSrc;
+            if ('string' === typeof value.command) return value.command;
             if (
-              "object" === typeof value.request &&
+              'object' === typeof value.request &&
               null !== value.request &&
-              "string" === typeof value.request.url
+              'string' === typeof value.request.url
             )
               return value.request.url;
             if (
-              "object" === typeof value.response &&
+              'object' === typeof value.response &&
               null !== value.response &&
-              "string" === typeof value.response.url
+              'string' === typeof value.response.url
             )
               return value.response.url;
             if (
-              "string" === typeof value.id ||
-              "number" === typeof value.id ||
-              "bigint" === typeof value.id
+              'string' === typeof value.id ||
+              'number' === typeof value.id ||
+              'bigint' === typeof value.id
             )
               return String(value.id);
-            if ("string" === typeof value.name) return value.name;
+            if ('string' === typeof value.name) return value.name;
             var str = value.toString();
-            return str.startsWith("[object ") ||
+            return str.startsWith('[object ') ||
               5 > str.length ||
               500 < str.length
-              ? ""
+              ? ''
               : str;
-          case "string":
-            return 5 > value.length || 500 < value.length ? "" : value;
-          case "number":
-          case "bigint":
+          case 'string':
+            return 5 > value.length || 500 < value.length ? '' : value;
+          case 'number':
+          case 'bigint':
             return String(value);
           default:
-            return "";
+            return '';
         }
       } catch (x) {
-        return "";
+        return '';
       }
     }
     function markAllTracksInOrder() {
       supportsUserTiming &&
         (console.timeStamp(
-          "Server Requests Track",
+          'Server Requests Track',
           0.001,
           0.001,
-          "Server Requests \u269b",
+          'Server Requests \u269b',
           void 0,
-          "primary-light"
+          'primary-light',
         ),
         console.timeStamp(
-          "Server Components Track",
+          'Server Components Track',
           0.001,
           0.001,
-          "Primary",
-          "Server Components \u269b",
-          "primary-light"
+          'Primary',
+          'Server Components \u269b',
+          'primary-light',
         ));
     }
     function getIOColor(functionName) {
       switch (functionName.charCodeAt(0) % 3) {
         case 0:
-          return "tertiary-light";
+          return 'tertiary-light';
         case 1:
-          return "tertiary";
+          return 'tertiary';
         default:
-          return "tertiary-dark";
+          return 'tertiary-dark';
       }
     }
     function getIOLongName(ioInfo, description, env, rootEnv) {
       ioInfo = ioInfo.name;
       description =
-        "" === description ? ioInfo : ioInfo + " (" + description + ")";
+        '' === description ? ioInfo : ioInfo + ' (' + description + ')';
       return env === rootEnv || void 0 === env
         ? description
-        : description + " [" + env + "]";
+        : description + ' [' + env + ']';
     }
     function getIOShortName(ioInfo, description, env, rootEnv) {
       ioInfo = ioInfo.name;
-      env = env === rootEnv || void 0 === env ? "" : " [" + env + "]";
-      var desc = "";
+      env = env === rootEnv || void 0 === env ? '' : ' [' + env + ']';
+      var desc = '';
       rootEnv = 30 - ioInfo.length - env.length;
       if (1 < rootEnv) {
         var l = description.length;
-        if (0 < l && l <= rootEnv) desc = " (" + description + ")";
+        if (0 < l && l <= rootEnv) desc = ' (' + description + ')';
         else if (
-          description.startsWith("http://") ||
-          description.startsWith("https://") ||
-          description.startsWith("/")
+          description.startsWith('http://') ||
+          description.startsWith('https://') ||
+          description.startsWith('/')
         ) {
-          var queryIdx = description.indexOf("?");
+          var queryIdx = description.indexOf('?');
           -1 === queryIdx && (queryIdx = description.length);
           47 === description.charCodeAt(queryIdx - 1) && queryIdx--;
-          desc = description.lastIndexOf("/", queryIdx - 1);
+          desc = description.lastIndexOf('/', queryIdx - 1);
           queryIdx - desc < rootEnv
-            ? (desc = " (\u2026" + description.slice(desc, queryIdx) + ")")
+            ? (desc = ' (\u2026' + description.slice(desc, queryIdx) + ')')
             : ((l = description.slice(desc, desc + rootEnv / 2)),
               (description = description.slice(
                 queryIdx - rootEnv / 2,
-                queryIdx
+                queryIdx,
               )),
               (desc =
-                " (" +
-                (0 < desc ? "\u2026" : "") +
+                ' (' +
+                (0 < desc ? '\u2026' : '') +
                 l +
-                "\u2026" +
+                '\u2026' +
                 description +
-                ")"));
+                ')'));
         }
       }
       return ioInfo + desc + env;
@@ -1403,7 +1403,7 @@
       startTime,
       endTime,
       rootEnv,
-      value
+      value,
     ) {
       if (supportsUserTiming && 0 < endTime) {
         var description = getIODescription(value),
@@ -1411,22 +1411,22 @@
             asyncInfo.awaited,
             description,
             asyncInfo.env,
-            rootEnv
+            rootEnv,
           ),
-          entryName = "await " + name;
+          entryName = 'await ' + name;
         name = getIOColor(name);
         var debugTask = asyncInfo.debugTask || asyncInfo.awaited.debugTask;
         if (debugTask) {
           var properties = [];
-          "object" === typeof value && null !== value
-            ? addObjectToProperties(value, properties, 0, "")
+          'object' === typeof value && null !== value
+            ? addObjectToProperties(value, properties, 0, '')
             : void 0 !== value &&
-              addValueToProperties("awaited value", value, properties, 0, "");
+              addValueToProperties('awaited value', value, properties, 0, '');
           asyncInfo = getIOLongName(
             asyncInfo.awaited,
             description,
             asyncInfo.env,
-            rootEnv
+            rootEnv,
           );
           debugTask.run(
             performance.measure.bind(performance, entryName, {
@@ -1436,12 +1436,12 @@
                 devtools: {
                   color: name,
                   track: trackNames[trackIdx],
-                  trackGroup: "Server Components \u269b",
+                  trackGroup: 'Server Components \u269b',
                   properties: properties,
-                  tooltipText: asyncInfo
-                }
-              }
-            })
+                  tooltipText: asyncInfo,
+                },
+              },
+            }),
           );
         } else
           console.timeStamp(
@@ -1449,8 +1449,8 @@
             0 > startTime ? 0 : startTime,
             endTime,
             trackNames[trackIdx],
-            "Server Components \u269b",
-            name
+            'Server Components \u269b',
+            name,
           );
       }
     }
@@ -1464,38 +1464,38 @@
         debugTask
           ? ((error = [
               [
-                "rejected with",
-                "object" === typeof error &&
+                'rejected with',
+                'object' === typeof error &&
                 null !== error &&
-                "string" === typeof error.message
+                'string' === typeof error.message
                   ? String(error.message)
-                  : String(error)
-              ]
+                  : String(error),
+              ],
             ]),
             (ioInfo =
               getIOLongName(ioInfo, description, ioInfo.env, rootEnv) +
-              " Rejected"),
+              ' Rejected'),
             debugTask.run(
-              performance.measure.bind(performance, "\u200b" + entryName, {
+              performance.measure.bind(performance, '\u200b' + entryName, {
                 start: 0 > startTime ? 0 : startTime,
                 end: endTime,
                 detail: {
                   devtools: {
-                    color: "error",
-                    track: "Server Requests \u269b",
+                    color: 'error',
+                    track: 'Server Requests \u269b',
                     properties: error,
-                    tooltipText: ioInfo
-                  }
-                }
-              })
+                    tooltipText: ioInfo,
+                  },
+                },
+              }),
             ))
           : console.timeStamp(
               entryName,
               0 > startTime ? 0 : startTime,
               endTime,
-              "Server Requests \u269b",
+              'Server Requests \u269b',
               void 0,
-              "error"
+              'error',
             );
       }
     }
@@ -1509,40 +1509,40 @@
           debugTask = ioInfo.debugTask;
         if (debugTask) {
           var properties = [];
-          "object" === typeof value && null !== value
-            ? addObjectToProperties(value, properties, 0, "")
+          'object' === typeof value && null !== value
+            ? addObjectToProperties(value, properties, 0, '')
             : void 0 !== value &&
-              addValueToProperties("Resolved", value, properties, 0, "");
+              addValueToProperties('Resolved', value, properties, 0, '');
           ioInfo = getIOLongName(ioInfo, description, ioInfo.env, rootEnv);
           debugTask.run(
-            performance.measure.bind(performance, "\u200b" + entryName, {
+            performance.measure.bind(performance, '\u200b' + entryName, {
               start: 0 > startTime ? 0 : startTime,
               end: endTime,
               detail: {
                 devtools: {
                   color: color,
-                  track: "Server Requests \u269b",
+                  track: 'Server Requests \u269b',
                   properties: properties,
-                  tooltipText: ioInfo
-                }
-              }
-            })
+                  tooltipText: ioInfo,
+                },
+              },
+            }),
           );
         } else
           console.timeStamp(
             entryName,
             0 > startTime ? 0 : startTime,
             endTime,
-            "Server Requests \u269b",
+            'Server Requests \u269b',
             void 0,
-            color
+            color,
           );
       }
     }
     function prepareStackTrace(error, structuredStackTrace) {
-      error = (error.name || "Error") + ": " + (error.message || "");
+      error = (error.name || 'Error') + ': ' + (error.message || '');
       for (var i = 0; i < structuredStackTrace.length; i++)
-        error += "\n    at " + structuredStackTrace[i].toString();
+        error += '\n    at ' + structuredStackTrace[i].toString();
       return error;
     }
     function ReactPromise(status, value, reason) {
@@ -1557,27 +1557,27 @@
       weakResponse = weakResponse.weak.deref();
       if (void 0 === weakResponse)
         throw Error(
-          "We did not expect to receive new data after GC:ing the response."
+          'We did not expect to receive new data after GC:ing the response.',
         );
       return weakResponse;
     }
     function closeDebugChannel(debugChannel) {
-      debugChannel.callback && debugChannel.callback("");
+      debugChannel.callback && debugChannel.callback('');
     }
     function readChunk(chunk) {
       switch (chunk.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(chunk);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(chunk);
       }
       switch (chunk.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return chunk.value;
-        case "pending":
-        case "blocked":
-        case "halted":
+        case 'pending':
+        case 'blocked':
+        case 'halted':
           throw chunk;
         default:
           throw chunk.reason;
@@ -1593,39 +1593,39 @@
         null !== response._pendingInitialRender &&
           (clearTimeout(response._pendingInitialRender),
           (response._pendingInitialRender = null)));
-      return new ReactPromise("pending", null, null);
+      return new ReactPromise('pending', null, null);
     }
     function releasePendingChunk(response, chunk) {
-      "pending" === chunk.status &&
+      'pending' === chunk.status &&
         0 === --response._pendingChunks &&
         ((response._weakResponse.response = null),
         (response._pendingInitialRender = setTimeout(
           flushInitialRenderPerformance.bind(null, response),
-          100
+          100,
         )));
     }
     function moveDebugInfoFromChunkToInnerValue(chunk, value) {
       value = resolveLazy(value);
-      "object" !== typeof value ||
+      'object' !== typeof value ||
         null === value ||
         (!isArrayImpl(value) &&
-          "function" !== typeof value[ASYNC_ITERATOR] &&
+          'function' !== typeof value[ASYNC_ITERATOR] &&
           value.$$typeof !== REACT_ELEMENT_TYPE &&
           value.$$typeof !== REACT_LAZY_TYPE) ||
         ((chunk = chunk._debugInfo.splice(0)),
         isArrayImpl(value._debugInfo)
           ? value._debugInfo.unshift.apply(value._debugInfo, chunk)
-          : Object.defineProperty(value, "_debugInfo", {
+          : Object.defineProperty(value, '_debugInfo', {
               configurable: !1,
               enumerable: !1,
               writable: !0,
-              value: chunk
+              value: chunk,
             }));
     }
     function wakeChunk(listeners, value, chunk) {
       for (var i = 0; i < listeners.length; i++) {
         var listener = listeners[i];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(value)
           : fulfillReference(listener, value, chunk);
       }
@@ -1634,7 +1634,7 @@
     function rejectChunk(listeners, error) {
       for (var i = 0; i < listeners.length; i++) {
         var listener = listeners[i];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(error)
           : rejectReference(listener, error);
       }
@@ -1652,7 +1652,7 @@
         ) {
           var listener = reference[referencedChunk];
           if (
-            "function" !== typeof listener &&
+            'function' !== typeof listener &&
             ((listener = resolveBlockedCycle(resolvedChunk, listener)),
             null !== listener)
           )
@@ -1662,13 +1662,13 @@
     }
     function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
       switch (chunk.status) {
-        case "fulfilled":
+        case 'fulfilled':
           wakeChunk(resolveListeners, chunk.value, chunk);
           break;
-        case "blocked":
+        case 'blocked':
           for (var i = 0; i < resolveListeners.length; i++) {
             var listener = resolveListeners[i];
-            if ("function" !== typeof listener) {
+            if ('function' !== typeof listener) {
               var cyclicHandler = resolveBlockedCycle(chunk, listener);
               null !== cyclicHandler &&
                 (fulfillReference(listener, cyclicHandler.value, chunk),
@@ -1679,7 +1679,7 @@
                   -1 !== listener && rejectListeners.splice(listener, 1)));
             }
           }
-        case "pending":
+        case 'pending':
           if (chunk.value)
             for (i = 0; i < resolveListeners.length; i++)
               chunk.value.push(resolveListeners[i]);
@@ -1694,21 +1694,21 @@
                 chunk.reason.push(rejectListeners[resolveListeners]);
           } else chunk.reason = rejectListeners;
           break;
-        case "rejected":
+        case 'rejected':
           rejectListeners && rejectChunk(rejectListeners, chunk.reason);
       }
     }
     function triggerErrorOnChunk(response, chunk, error) {
-      if ("pending" !== chunk.status && "blocked" !== chunk.status)
+      if ('pending' !== chunk.status && 'blocked' !== chunk.status)
         chunk.reason.error(error);
       else {
         releasePendingChunk(response, chunk);
         var listeners = chunk.reason;
-        if ("pending" === chunk.status && null != chunk._debugChunk) {
+        if ('pending' === chunk.status && null != chunk._debugChunk) {
           var prevHandler = initializingHandler,
             prevChunk = initializingChunk;
           initializingHandler = null;
-          chunk.status = "blocked";
+          chunk.status = 'blocked';
           chunk.value = null;
           chunk.reason = null;
           initializingChunk = chunk;
@@ -1719,21 +1719,21 @@
               (initializingChunk = prevChunk);
           }
         }
-        chunk.status = "rejected";
+        chunk.status = 'rejected';
         chunk.reason = error;
         null !== listeners && rejectChunk(listeners, error);
       }
     }
     function createResolvedModelChunk(response, value) {
-      return new ReactPromise("resolved_model", value, response);
+      return new ReactPromise('resolved_model', value, response);
     }
     function createResolvedIteratorResultChunk(response, value, done) {
       return new ReactPromise(
-        "resolved_model",
+        'resolved_model',
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
-        response
+          '}',
+        response,
       );
     }
     function resolveIteratorResultChunk(response, chunk, value, done) {
@@ -1742,16 +1742,16 @@
         chunk,
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}"
+          '}',
       );
     }
     function resolveModelChunk(response, chunk, value) {
-      if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+      if ('pending' !== chunk.status) chunk.reason.enqueueModel(value);
       else {
         releasePendingChunk(response, chunk);
         var resolveListeners = chunk.value,
           rejectListeners = chunk.reason;
-        chunk.status = "resolved_model";
+        chunk.status = 'resolved_model';
         chunk.value = value;
         chunk.reason = response;
         null !== resolveListeners &&
@@ -1760,11 +1760,11 @@
       }
     }
     function resolveModuleChunk(response, chunk, value) {
-      if ("pending" === chunk.status || "blocked" === chunk.status) {
+      if ('pending' === chunk.status || 'blocked' === chunk.status) {
         releasePendingChunk(response, chunk);
         response = chunk.value;
         var rejectListeners = chunk.reason;
-        chunk.status = "resolved_module";
+        chunk.status = 'resolved_module';
         chunk.value = value;
         null !== response &&
           (initializeModuleChunk(chunk),
@@ -1776,31 +1776,31 @@
       if (null !== debugChunk) {
         var debugInfo = chunk._debugInfo;
         try {
-          if ("resolved_model" === debugChunk.status) {
+          if ('resolved_model' === debugChunk.status) {
             for (
               var idx = debugInfo.length, c = debugChunk._debugChunk;
               null !== c;
 
             )
-              "fulfilled" !== c.status && idx++, (c = c._debugChunk);
+              'fulfilled' !== c.status && idx++, (c = c._debugChunk);
             initializeModelChunk(debugChunk);
             switch (debugChunk.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 debugInfo[idx] = initializeDebugInfo(
                   response,
-                  debugChunk.value
+                  debugChunk.value,
                 );
                 break;
-              case "blocked":
-              case "pending":
+              case 'blocked':
+              case 'pending':
                 waitForReference(
                   debugChunk,
                   debugInfo,
-                  "" + idx,
+                  '' + idx,
                   response,
                   initializeDebugInfo,
-                  [""],
-                  !0
+                  [''],
+                  !0,
                 );
                 break;
               default:
@@ -1808,18 +1808,18 @@
             }
           } else
             switch (debugChunk.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 break;
-              case "blocked":
-              case "pending":
+              case 'blocked':
+              case 'pending':
                 waitForReference(
                   debugChunk,
                   {},
-                  "debug",
+                  'debug',
                   response,
                   initializeDebugInfo,
-                  [""],
-                  !0
+                  [''],
+                  !0,
                 );
                 break;
               default:
@@ -1836,7 +1836,7 @@
       initializingHandler = null;
       var resolvedModel = chunk.value,
         response = chunk.reason;
-      chunk.status = "blocked";
+      chunk.status = 'blocked';
       chunk.value = null;
       chunk.reason = null;
       initializingChunk = chunk;
@@ -1851,7 +1851,7 @@
             resolvedModel++
           ) {
             var listener = resolveListeners[resolvedModel];
-            "function" === typeof listener
+            'function' === typeof listener
               ? listener(value)
               : fulfillReference(listener, value, chunk);
           }
@@ -1863,11 +1863,11 @@
             return;
           }
         }
-        chunk.status = "fulfilled";
+        chunk.status = 'fulfilled';
         chunk.value = value;
         moveDebugInfoFromChunkToInnerValue(chunk, value);
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       } finally {
         (initializingHandler = prevHandler), (initializingChunk = prevChunk);
       }
@@ -1875,10 +1875,10 @@
     function initializeModuleChunk(chunk) {
       try {
         var value = requireModule(chunk.value);
-        chunk.status = "fulfilled";
+        chunk.status = 'fulfilled';
         chunk.value = value;
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       }
     }
     function reportGlobalError(weakResponse, error) {
@@ -1887,7 +1887,7 @@
         response._closed = !0;
         response._closedReason = error;
         response._chunks.forEach(function (chunk) {
-          "pending" === chunk.status &&
+          'pending' === chunk.status &&
             triggerErrorOnChunk(response, chunk, error);
         });
         weakResponse = response._debugChannel;
@@ -1902,19 +1902,19 @@
       return null;
     }
     function getTaskName(type) {
-      if (type === REACT_FRAGMENT_TYPE) return "<>";
-      if ("function" === typeof type) return '"use client"';
+      if (type === REACT_FRAGMENT_TYPE) return '<>';
+      if ('function' === typeof type) return '"use client"';
       if (
-        "object" === typeof type &&
+        'object' === typeof type &&
         null !== type &&
         type.$$typeof === REACT_LAZY_TYPE
       )
-        return type._init === readChunk ? '"use client"' : "<...>";
+        return type._init === readChunk ? '"use client"' : '<...>';
       try {
         var name = getComponentNameFromType(type);
-        return name ? "<" + name + ">" : "<...>";
+        return name ? '<' + name + '>' : '<...>';
       } catch (x) {
-        return "<...>";
+        return '<...>';
       }
     }
     function initializeElement(response, element, lazyNode) {
@@ -1930,7 +1930,7 @@
           (normalizedStackTrace = createFakeJSXCallStackInDEV(
             response,
             stack,
-            env
+            env,
           ));
       element._debugStack = normalizedStackTrace;
       normalizedStackTrace = null;
@@ -1938,14 +1938,14 @@
         null !== stack &&
         ((normalizedStackTrace = console.createTask.bind(
           console,
-          getTaskName(element.type)
+          getTaskName(element.type),
         )),
         (stack = buildFakeCallStack(
           response,
           stack,
           env,
           !1,
-          normalizedStackTrace
+          normalizedStackTrace,
         )),
         (env = null === owner ? null : initializeFakeTask(response, owner)),
         null === env
@@ -1959,16 +1959,16 @@
           lazyNode._store.validated &&
           !element._store.validated &&
           (element._store.validated = lazyNode._store.validated),
-        "fulfilled" === lazyNode._payload.status &&
+        'fulfilled' === lazyNode._payload.status &&
           lazyNode._debugInfo &&
           ((response = lazyNode._debugInfo.splice(0)),
           element._debugInfo
             ? element._debugInfo.unshift.apply(element._debugInfo, response)
-            : Object.defineProperty(element, "_debugInfo", {
+            : Object.defineProperty(element, '_debugInfo', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: response
+                value: response,
               })));
       Object.freeze(element.props);
     }
@@ -1976,7 +1976,7 @@
       var lazyType = {
         $$typeof: REACT_LAZY_TYPE,
         _payload: chunk,
-        _init: readChunk
+        _init: readChunk,
       };
       lazyType._debugInfo = chunk._debugInfo;
       lazyType._store = { validated: validated };
@@ -1987,7 +1987,7 @@
         chunk = chunks.get(id);
       chunk ||
         ((chunk = response._closed
-          ? new ReactPromise("rejected", null, response._closedReason)
+          ? new ReactPromise('rejected', null, response._closedReason)
           : createPendingChunk(response)),
         chunks.set(id, chunk));
       return chunk;
@@ -2006,7 +2006,7 @@
       ) {
         for (
           ;
-          "object" === typeof value &&
+          'object' === typeof value &&
           null !== value &&
           value.$$typeof === REACT_LAZY_TYPE;
 
@@ -2015,23 +2015,23 @@
             value = handler.value;
           else {
             switch (value.status) {
-              case "resolved_model":
+              case 'resolved_model':
                 initializeModelChunk(value);
                 break;
-              case "resolved_module":
+              case 'resolved_module':
                 initializeModuleChunk(value);
             }
             switch (value.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 value = value.value;
                 continue;
-              case "blocked":
+              case 'blocked':
                 var cyclicHandler = resolveBlockedCycle(value, reference);
                 if (null !== cyclicHandler) {
                   value = cyclicHandler.value;
                   continue;
                 }
-              case "pending":
+              case 'pending':
                 path.splice(0, i - 1);
                 null === value.value
                   ? (value.value = [reference])
@@ -2040,7 +2040,7 @@
                   ? (value.reason = [reference])
                   : value.reason.push(reference);
                 return;
-              case "halted":
+              case 'halted':
                 return;
               default:
                 rejectReference(reference, value.reason);
@@ -2051,7 +2051,7 @@
       }
       for (
         ;
-        "object" === typeof value &&
+        'object' === typeof value &&
         null !== value &&
         value.$$typeof === REACT_LAZY_TYPE;
 
@@ -2060,14 +2060,14 @@
           value = handler.value;
         else {
           switch (path.status) {
-            case "resolved_model":
+            case 'resolved_model':
               initializeModelChunk(path);
               break;
-            case "resolved_module":
+            case 'resolved_module':
               initializeModuleChunk(path);
           }
           switch (path.status) {
-            case "fulfilled":
+            case 'fulfilled':
               value = path.value;
               continue;
           }
@@ -2075,22 +2075,22 @@
         }
       response = map(response, value, parentObject, key);
       parentObject[key] = response;
-      "" === key && null === handler.value && (handler.value = response);
+      '' === key && null === handler.value && (handler.value = response);
       if (
         parentObject[0] === REACT_ELEMENT_TYPE &&
-        "object" === typeof handler.value &&
+        'object' === typeof handler.value &&
         null !== handler.value &&
         handler.value.$$typeof === REACT_ELEMENT_TYPE
       )
         switch (((reference = handler.value), key)) {
-          case "3":
+          case '3':
             transferReferencedDebugInfo(handler.chunk, fulfilledChunk);
             reference.props = response;
             break;
-          case "4":
+          case '4':
             reference._owner = response;
             break;
-          case "5":
+          case '5':
             reference._debugStack = response;
             break;
           default:
@@ -2103,9 +2103,9 @@
       0 === handler.deps &&
         ((fulfilledChunk = handler.chunk),
         null !== fulfilledChunk &&
-          "blocked" === fulfilledChunk.status &&
+          'blocked' === fulfilledChunk.status &&
           ((key = fulfilledChunk.value),
-          (fulfilledChunk.status = "fulfilled"),
+          (fulfilledChunk.status = 'fulfilled'),
           (fulfilledChunk.value = handler.value),
           (fulfilledChunk.reason = handler.reason),
           null !== key && wakeChunk(key, handler.value, fulfilledChunk)));
@@ -2119,15 +2119,15 @@
         handler.value = null;
         handler.reason = error;
         handler = handler.chunk;
-        if (null !== handler && "blocked" === handler.status) {
+        if (null !== handler && 'blocked' === handler.status) {
           if (
-            "object" === typeof blockedValue &&
+            'object' === typeof blockedValue &&
             null !== blockedValue &&
             blockedValue.$$typeof === REACT_ELEMENT_TYPE
           ) {
             var erroredComponent = {
-              name: getComponentNameFromType(blockedValue.type) || "",
-              owner: blockedValue._owner
+              name: getComponentNameFromType(blockedValue.type) || '',
+              owner: blockedValue._owner,
             };
             erroredComponent.debugStack = blockedValue._debugStack;
             supportsCreateTask &&
@@ -2145,15 +2145,15 @@
       response,
       map,
       path,
-      isAwaitingDebugInfo
+      isAwaitingDebugInfo,
     ) {
       if (
         !(
           (void 0 !== response._debugChannel &&
             response._debugChannel.hasReadable) ||
-          "pending" !== referencedChunk.status ||
+          'pending' !== referencedChunk.status ||
           parentObject[0] !== REACT_ELEMENT_TYPE ||
-          ("4" !== key && "5" !== key)
+          ('4' !== key && '5' !== key)
         )
       )
         return null;
@@ -2167,7 +2167,7 @@
           value: null,
           reason: null,
           deps: 1,
-          errored: !1
+          errored: !1,
         };
       parentObject = {
         response: response,
@@ -2175,7 +2175,7 @@
         parentObject: parentObject,
         key: key,
         map: map,
-        path: path
+        path: path,
       };
       parentObject.isDebug = isAwaitingDebugInfo;
       null === referencedChunk.value
@@ -2192,11 +2192,11 @@
           metaData,
           response._callServer,
           response._encodeFormAction,
-          response._debugFindSourceMapURL
+          response._debugFindSourceMapURL,
         );
       var serverReference = resolveServerReference(
           response._serverReferenceConfig,
-          metaData.id
+          metaData.id,
         ),
         promise = preloadModule(serverReference);
       if (promise)
@@ -2209,7 +2209,7 @@
             promise,
             metaData.id,
             metaData.bound,
-            response._encodeFormAction
+            response._encodeFormAction,
           ),
           promise
         );
@@ -2223,7 +2223,7 @@
           value: null,
           reason: null,
           deps: 1,
-          errored: !1
+          errored: !1,
         };
       promise.then(
         function () {
@@ -2237,32 +2237,32 @@
             resolvedValue,
             metaData.id,
             metaData.bound,
-            response._encodeFormAction
+            response._encodeFormAction,
           );
           parentObject[key] = resolvedValue;
-          "" === key &&
+          '' === key &&
             null === handler.value &&
             (handler.value = resolvedValue);
           if (
             parentObject[0] === REACT_ELEMENT_TYPE &&
-            "object" === typeof handler.value &&
+            'object' === typeof handler.value &&
             null !== handler.value &&
             handler.value.$$typeof === REACT_ELEMENT_TYPE
           )
             switch (((boundArgs = handler.value), key)) {
-              case "3":
+              case '3':
                 boundArgs.props = resolvedValue;
                 break;
-              case "4":
+              case '4':
                 boundArgs._owner = resolvedValue;
             }
           handler.deps--;
           0 === handler.deps &&
             ((resolvedValue = handler.chunk),
             null !== resolvedValue &&
-              "blocked" === resolvedValue.status &&
+              'blocked' === resolvedValue.status &&
               ((boundArgs = resolvedValue.value),
-              (resolvedValue.status = "fulfilled"),
+              (resolvedValue.status = 'fulfilled'),
               (resolvedValue.value = handler.value),
               null !== boundArgs &&
                 wakeChunk(boundArgs, handler.value, resolvedValue)));
@@ -2274,15 +2274,15 @@
             handler.value = null;
             handler.reason = error;
             var chunk = handler.chunk;
-            if (null !== chunk && "blocked" === chunk.status) {
+            if (null !== chunk && 'blocked' === chunk.status) {
               if (
-                "object" === typeof blockedValue &&
+                'object' === typeof blockedValue &&
                 null !== blockedValue &&
                 blockedValue.$$typeof === REACT_ELEMENT_TYPE
               ) {
                 var erroredComponent = {
-                  name: getComponentNameFromType(blockedValue.type) || "",
-                  owner: blockedValue._owner
+                  name: getComponentNameFromType(blockedValue.type) || '',
+                  owner: blockedValue._owner,
                 };
                 erroredComponent.debugStack = blockedValue._debugStack;
                 supportsCreateTask &&
@@ -2292,20 +2292,20 @@
               triggerErrorOnChunk(response, chunk, error);
             }
           }
-        }
+        },
       );
       return null;
     }
     function resolveLazy(value) {
       for (
         ;
-        "object" === typeof value &&
+        'object' === typeof value &&
         null !== value &&
         value.$$typeof === REACT_LAZY_TYPE;
 
       ) {
         var payload = value._payload;
-        if ("fulfilled" === payload.status) value = payload.value;
+        if ('fulfilled' === payload.status) value = payload.value;
         else break;
       }
       return value;
@@ -2321,43 +2321,43 @@
       }
     }
     function getOutlinedModel(response, reference, parentObject, key, map) {
-      var path = reference.split(":");
+      var path = reference.split(':');
       reference = parseInt(path[0], 16);
       reference = getChunk(response, reference);
       null !== initializingChunk &&
         isArrayImpl(initializingChunk._children) &&
         initializingChunk._children.push(reference);
       switch (reference.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(reference);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(reference);
       }
       switch (reference.status) {
-        case "fulfilled":
+        case 'fulfilled':
           for (var value = reference.value, i = 1; i < path.length; i++) {
             for (
               ;
-              "object" === typeof value &&
+              'object' === typeof value &&
               null !== value &&
               value.$$typeof === REACT_LAZY_TYPE;
 
             ) {
               value = value._payload;
               switch (value.status) {
-                case "resolved_model":
+                case 'resolved_model':
                   initializeModelChunk(value);
                   break;
-                case "resolved_module":
+                case 'resolved_module':
                   initializeModuleChunk(value);
               }
               switch (value.status) {
-                case "fulfilled":
+                case 'fulfilled':
                   value = value.value;
                   break;
-                case "blocked":
-                case "pending":
+                case 'blocked':
+                case 'pending':
                   return waitForReference(
                     value,
                     parentObject,
@@ -2365,9 +2365,9 @@
                     response,
                     map,
                     path.slice(i - 1),
-                    !1
+                    !1,
                   );
-                case "halted":
+                case 'halted':
                   return (
                     initializingHandler
                       ? ((parentObject = initializingHandler),
@@ -2378,7 +2378,7 @@
                           value: null,
                           reason: null,
                           deps: 1,
-                          errored: !1
+                          errored: !1,
                         }),
                     null
                   );
@@ -2394,7 +2394,7 @@
                           value: null,
                           reason: value.reason,
                           deps: 0,
-                          errored: !0
+                          errored: !0,
                         }),
                     null
                   );
@@ -2404,21 +2404,21 @@
           }
           for (
             ;
-            "object" === typeof value &&
+            'object' === typeof value &&
             null !== value &&
             value.$$typeof === REACT_LAZY_TYPE;
 
           ) {
             path = value._payload;
             switch (path.status) {
-              case "resolved_model":
+              case 'resolved_model':
                 initializeModelChunk(path);
                 break;
-              case "resolved_module":
+              case 'resolved_module':
                 initializeModuleChunk(path);
             }
             switch (path.status) {
-              case "fulfilled":
+              case 'fulfilled':
                 value = path.value;
                 continue;
             }
@@ -2426,11 +2426,11 @@
           }
           response = map(response, value, parentObject, key);
           (parentObject[0] !== REACT_ELEMENT_TYPE ||
-            ("4" !== key && "5" !== key)) &&
+            ('4' !== key && '5' !== key)) &&
             transferReferencedDebugInfo(initializingChunk, reference);
           return response;
-        case "pending":
-        case "blocked":
+        case 'pending':
+        case 'blocked':
           return waitForReference(
             reference,
             parentObject,
@@ -2438,9 +2438,9 @@
             response,
             map,
             path,
-            !1
+            !1,
           );
-        case "halted":
+        case 'halted':
           return (
             initializingHandler
               ? ((parentObject = initializingHandler), parentObject.deps++)
@@ -2450,7 +2450,7 @@
                   value: null,
                   reason: null,
                   deps: 1,
-                  errored: !1
+                  errored: !1,
                 }),
             null
           );
@@ -2466,7 +2466,7 @@
                   value: null,
                   reason: reference.reason,
                   deps: 0,
-                  errored: !0
+                  errored: !0,
                 }),
             null
           );
@@ -2493,17 +2493,17 @@
     function defineLazyGetter(response, chunk, parentObject, key) {
       Object.defineProperty(parentObject, key, {
         get: function () {
-          "resolved_model" === chunk.status && initializeModelChunk(chunk);
+          'resolved_model' === chunk.status && initializeModelChunk(chunk);
           switch (chunk.status) {
-            case "fulfilled":
+            case 'fulfilled':
               return chunk.value;
-            case "rejected":
+            case 'rejected':
               throw chunk.reason;
           }
-          return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
+          return 'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.';
         },
         enumerable: !0,
-        configurable: !1
+        configurable: !1,
       });
       return null;
     }
@@ -2514,56 +2514,56 @@
       return model;
     }
     function getInferredFunctionApproximate(code) {
-      code = code.startsWith("Object.defineProperty(")
+      code = code.startsWith('Object.defineProperty(')
         ? code.slice(22)
-        : code.startsWith("(")
+        : code.startsWith('(')
           ? code.slice(1)
           : code;
-      if (code.startsWith("async function")) {
-        var idx = code.indexOf("(", 14);
+      if (code.startsWith('async function')) {
+        var idx = code.indexOf('(', 14);
         if (-1 !== idx)
           return (
             (code = code.slice(14, idx).trim()),
-            (0, eval)("({" + JSON.stringify(code) + ":async function(){}})")[
+            (0, eval)('({' + JSON.stringify(code) + ':async function(){}})')[
               code
             ]
           );
-      } else if (code.startsWith("function")) {
-        if (((idx = code.indexOf("(", 8)), -1 !== idx))
+      } else if (code.startsWith('function')) {
+        if (((idx = code.indexOf('(', 8)), -1 !== idx))
           return (
             (code = code.slice(8, idx).trim()),
-            (0, eval)("({" + JSON.stringify(code) + ":function(){}})")[code]
+            (0, eval)('({' + JSON.stringify(code) + ':function(){}})')[code]
           );
       } else if (
-        code.startsWith("class") &&
-        ((idx = code.indexOf("{", 5)), -1 !== idx)
+        code.startsWith('class') &&
+        ((idx = code.indexOf('{', 5)), -1 !== idx)
       )
         return (
           (code = code.slice(5, idx).trim()),
-          (0, eval)("({" + JSON.stringify(code) + ":class{}})")[code]
+          (0, eval)('({' + JSON.stringify(code) + ':class{}})')[code]
         );
       return function () {};
     }
     function parseModelString(response, parentObject, key, value) {
-      if ("$" === value[0]) {
-        if ("$" === value)
+      if ('$' === value[0]) {
+        if ('$' === value)
           return (
             null !== initializingHandler &&
-              "0" === key &&
+              '0' === key &&
               (initializingHandler = {
                 parent: initializingHandler,
                 chunk: null,
                 value: null,
                 reason: null,
                 deps: 0,
-                errored: !1
+                errored: !1,
               }),
             REACT_ELEMENT_TYPE
           );
         switch (value[1]) {
-          case "$":
+          case '$':
             return value.slice(1);
-          case "L":
+          case 'L':
             return (
               (parentObject = parseInt(value.slice(2), 16)),
               (response = getChunk(response, parentObject)),
@@ -2572,7 +2572,7 @@
                 initializingChunk._children.push(response),
               createLazyChunkWrapper(response, 0)
             );
-          case "@":
+          case '@':
             return (
               (parentObject = parseInt(value.slice(2), 16)),
               (response = getChunk(response, parentObject)),
@@ -2581,46 +2581,46 @@
                 initializingChunk._children.push(response),
               response
             );
-          case "S":
+          case 'S':
             return Symbol.for(value.slice(2));
-          case "F":
+          case 'F':
             var ref = value.slice(2);
             return getOutlinedModel(
               response,
               ref,
               parentObject,
               key,
-              loadServerReference
+              loadServerReference,
             );
-          case "T":
-            parentObject = "$" + value.slice(2);
+          case 'T':
+            parentObject = '$' + value.slice(2);
             response = response._tempRefs;
             if (null == response)
               throw Error(
-                "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+                'Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.',
               );
             return response.get(parentObject);
-          case "Q":
+          case 'Q':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createMap)
             );
-          case "W":
+          case 'W':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createSet)
             );
-          case "B":
+          case 'B':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createBlob)
             );
-          case "K":
+          case 'K':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(response, ref, parentObject, key, createFormData)
             );
-          case "Z":
+          case 'Z':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2628,10 +2628,10 @@
                 ref,
                 parentObject,
                 key,
-                resolveErrorDev
+                resolveErrorDev,
               )
             );
-          case "i":
+          case 'i':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2639,22 +2639,22 @@
                 ref,
                 parentObject,
                 key,
-                extractIterator
+                extractIterator,
               )
             );
-          case "I":
+          case 'I':
             return Infinity;
-          case "-":
-            return "$-0" === value ? -0 : -Infinity;
-          case "N":
+          case '-':
+            return '$-0' === value ? -0 : -Infinity;
+          case 'N':
             return NaN;
-          case "u":
+          case 'u':
             return;
-          case "D":
+          case 'D':
             return new Date(Date.parse(value.slice(2)));
-          case "n":
+          case 'n':
             return BigInt(value.slice(2));
-          case "P":
+          case 'P':
             return (
               (ref = value.slice(2)),
               getOutlinedModel(
@@ -2662,10 +2662,10 @@
                 ref,
                 parentObject,
                 key,
-                applyConstructor
+                applyConstructor,
               )
             );
-          case "E":
+          case 'E':
             response = value.slice(2);
             try {
               if (!mightHaveStaticConstructor.test(response))
@@ -2674,46 +2674,46 @@
             try {
               if (
                 ((ref = getInferredFunctionApproximate(response)),
-                response.startsWith("Object.defineProperty("))
+                response.startsWith('Object.defineProperty('))
               ) {
                 var idx = response.lastIndexOf(',"name",{value:"');
                 if (-1 !== idx) {
                   var name = JSON.parse(
-                    response.slice(idx + 16 - 1, response.length - 2)
+                    response.slice(idx + 16 - 1, response.length - 2),
                   );
-                  Object.defineProperty(ref, "name", { value: name });
+                  Object.defineProperty(ref, 'name', { value: name });
                 }
               }
             } catch (_) {
               ref = function () {};
             }
             return ref;
-          case "Y":
+          case 'Y':
             if (
               2 < value.length &&
               (ref = response._debugChannel && response._debugChannel.callback)
             ) {
-              if ("@" === value[2])
+              if ('@' === value[2])
                 return (
                   (parentObject = value.slice(3)),
                   (key = parseInt(parentObject, 16)),
-                  response._chunks.has(key) || ref("P:" + parentObject),
+                  response._chunks.has(key) || ref('P:' + parentObject),
                   getChunk(response, key)
                 );
               value = value.slice(2);
               idx = parseInt(value, 16);
-              response._chunks.has(idx) || ref("Q:" + value);
+              response._chunks.has(idx) || ref('Q:' + value);
               ref = getChunk(response, idx);
-              return "fulfilled" === ref.status
+              return 'fulfilled' === ref.status
                 ? ref.value
                 : defineLazyGetter(response, ref, parentObject, key);
             }
             Object.defineProperty(parentObject, key, {
               get: function () {
-                return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
+                return 'This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.';
               },
               enumerable: !0,
-              configurable: !1
+              configurable: !1,
             });
             return null;
           default:
@@ -2727,7 +2727,7 @@
     }
     function missingCall() {
       throw Error(
-        'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+        'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.',
       );
     }
     function ResponseInstance(
@@ -2741,7 +2741,7 @@
       findSourceMapURL,
       replayConsole,
       environmentName,
-      debugChannel
+      debugChannel,
     ) {
       var chunks = new Map();
       this._bundlerConfig = bundlerConfig;
@@ -2766,11 +2766,11 @@
           ? null
           : ReactSharedInteralsServer.A.getOwner();
       this._debugRootStack =
-        null !== bundlerConfig ? Error("react-stack-top-frame") : null;
-      environmentName = void 0 === environmentName ? "Server" : environmentName;
+        null !== bundlerConfig ? Error('react-stack-top-frame') : null;
+      environmentName = void 0 === environmentName ? 'Server' : environmentName;
       supportsCreateTask &&
         (this._debugRootTask = console.createTask(
-          '"use ' + environmentName.toLowerCase() + '"'
+          '"use ' + environmentName.toLowerCase() + '"',
         ));
       this._debugStartTime = performance.now();
       this._debugFindSourceMapURL = findSourceMapURL;
@@ -2791,21 +2791,21 @@
         _rowID: 0,
         _rowTag: 0,
         _rowLength: 0,
-        _buffer: []
+        _buffer: [],
       };
       weakResponse = unwrapWeakResponse(weakResponse);
       var debugValuePromise = Promise.resolve(streamDebugValue);
-      debugValuePromise.status = "fulfilled";
+      debugValuePromise.status = 'fulfilled';
       debugValuePromise.value = streamDebugValue;
       streamState._debugInfo = {
-        name: "RSC stream",
+        name: 'RSC stream',
         start: weakResponse._debugStartTime,
         end: weakResponse._debugStartTime,
         byteSize: 0,
         value: debugValuePromise,
         owner: weakResponse._debugRootOwner,
         debugStack: weakResponse._debugRootStack,
-        debugTask: weakResponse._debugRootTask
+        debugTask: weakResponse._debugRootTask,
       };
       streamState._debugTargetChunkSize = MIN_CHUNK_SIZE;
       return streamState;
@@ -2825,32 +2825,32 @@
             value: debugInfo.value,
             owner: debugInfo.owner,
             debugStack: debugInfo.debugStack,
-            debugTask: debugInfo.debugTask
+            debugTask: debugInfo.debugTask,
           }),
           (streamState._debugTargetChunkSize = chunkLength + MIN_CHUNK_SIZE))
         : ((debugInfo.end = endTime), (debugInfo.byteSize = chunkLength));
     }
     function addDebugInfo(chunk, debugInfo) {
       var value = resolveLazy(chunk.value);
-      "object" !== typeof value ||
+      'object' !== typeof value ||
       null === value ||
       (!isArrayImpl(value) &&
-        "function" !== typeof value[ASYNC_ITERATOR] &&
+        'function' !== typeof value[ASYNC_ITERATOR] &&
         value.$$typeof !== REACT_ELEMENT_TYPE &&
         value.$$typeof !== REACT_LAZY_TYPE)
         ? chunk._debugInfo.push.apply(chunk._debugInfo, debugInfo)
         : isArrayImpl(value._debugInfo)
           ? value._debugInfo.push.apply(value._debugInfo, debugInfo)
-          : Object.defineProperty(value, "_debugInfo", {
+          : Object.defineProperty(value, '_debugInfo', {
               configurable: !1,
               enumerable: !1,
               writable: !0,
-              value: debugInfo
+              value: debugInfo,
             });
     }
     function resolveChunkDebugInfo(streamState, chunk) {
       streamState = [{ awaited: streamState._debugInfo }];
-      "pending" === chunk.status || "blocked" === chunk.status
+      'pending' === chunk.status || 'blocked' === chunk.status
         ? ((streamState = addDebugInfo.bind(null, chunk, streamState)),
           chunk.then(streamState, streamState))
         : addDebugInfo(chunk, streamState);
@@ -2858,10 +2858,10 @@
     function resolveBuffer(response, id, buffer, streamState) {
       var chunks = response._chunks,
         chunk = chunks.get(id);
-      chunk && "pending" !== chunk.status
+      chunk && 'pending' !== chunk.status
         ? chunk.reason.enqueueValue(buffer)
         : (chunk && releasePendingChunk(response, chunk),
-          (response = new ReactPromise("fulfilled", buffer, null)),
+          (response = new ReactPromise('fulfilled', buffer, null)),
           resolveChunkDebugInfo(streamState, response),
           chunks.set(id, response));
     }
@@ -2871,20 +2871,20 @@
       model = JSON.parse(model, response._fromJSON);
       var clientReference = resolveClientReference(
         response._bundlerConfig,
-        model
+        model,
       );
       prepareDestinationWithChunks(
         response._moduleLoading,
         model[1],
-        response._nonce
+        response._nonce,
       );
       if ((model = preloadModule(clientReference))) {
         if (chunk) {
           releasePendingChunk(response, chunk);
           var blockedChunk = chunk;
-          blockedChunk.status = "blocked";
+          blockedChunk.status = 'blocked';
         } else
-          (blockedChunk = new ReactPromise("blocked", null, null)),
+          (blockedChunk = new ReactPromise('blocked', null, null)),
             chunks.set(id, blockedChunk);
         resolveChunkDebugInfo(streamState, blockedChunk);
         model.then(
@@ -2893,16 +2893,16 @@
           },
           function (error) {
             return triggerErrorOnChunk(response, blockedChunk, error);
-          }
+          },
         );
       } else
         chunk
           ? (resolveChunkDebugInfo(streamState, chunk),
             resolveModuleChunk(response, chunk, clientReference))
           : ((chunk = new ReactPromise(
-              "resolved_module",
+              'resolved_module',
               clientReference,
-              null
+              null,
             )),
             resolveChunkDebugInfo(streamState, chunk),
             chunks.set(id, chunk));
@@ -2913,7 +2913,7 @@
       if (chunk) {
         if (
           (resolveChunkDebugInfo(streamState, chunk),
-          "pending" === chunk.status)
+          'pending' === chunk.status)
         ) {
           releasePendingChunk(response, chunk);
           id = chunk.value;
@@ -2921,7 +2921,7 @@
             streamState = initializingHandler;
             chunks = initializingChunk;
             initializingHandler = null;
-            chunk.status = "blocked";
+            chunk.status = 'blocked';
             chunk.value = null;
             chunk.reason = null;
             initializingChunk = chunk;
@@ -2941,13 +2941,13 @@
               (initializingHandler = streamState), (initializingChunk = chunks);
             }
           }
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = stream;
           chunk.reason = controller;
           null !== id && wakeChunk(id, chunk.value, chunk);
         }
       } else
-        (response = new ReactPromise("fulfilled", stream, controller)),
+        (response = new ReactPromise('fulfilled', stream, controller)),
           resolveChunkDebugInfo(streamState, response),
           chunks.set(id, response);
     }
@@ -2957,7 +2957,7 @@
         type: type,
         start: function (c) {
           controller = c;
-        }
+        },
       });
       var previousBlockedChunk = null;
       resolveStream(
@@ -2976,7 +2976,7 @@
             if (null === previousBlockedChunk) {
               var chunk = createResolvedModelChunk(response, json);
               initializeModelChunk(chunk);
-              "fulfilled" === chunk.status
+              'fulfilled' === chunk.status
                 ? controller.enqueue(chunk.value)
                 : (chunk.then(
                     function (v) {
@@ -2984,7 +2984,7 @@
                     },
                     function (e) {
                       return controller.error(e);
-                    }
+                    },
                   ),
                   (previousBlockedChunk = chunk));
             } else {
@@ -2996,7 +2996,7 @@
                 },
                 function (e) {
                   return controller.error(e);
-                }
+                },
               );
               previousBlockedChunk = _chunk3;
               chunk.then(function () {
@@ -3025,9 +3025,9 @@
                 return controller.error(error);
               });
             }
-          }
+          },
         },
-        streamState
+        streamState,
       );
     }
     function asyncIterator() {
@@ -3048,14 +3048,14 @@
         return createIterator(function (arg) {
           if (void 0 !== arg)
             throw Error(
-              "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+              'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
             );
           if (nextReadIndex === buffer.length) {
             if (closed)
               return new ReactPromise(
-                "fulfilled",
+                'fulfilled',
                 { done: !0, value: void 0 },
-                null
+                null,
               );
             buffer[nextReadIndex] = createPendingChunk(response);
           }
@@ -3070,21 +3070,21 @@
           enqueueValue: function (value) {
             if (nextWriteIndex === buffer.length)
               buffer[nextWriteIndex] = new ReactPromise(
-                "fulfilled",
+                'fulfilled',
                 { done: !1, value: value },
-                null
+                null,
               );
             else {
               var chunk = buffer[nextWriteIndex],
                 resolveListeners = chunk.value,
                 rejectListeners = chunk.reason;
-              chunk.status = "fulfilled";
+              chunk.status = 'fulfilled';
               chunk.value = { done: !1, value: value };
               null !== resolveListeners &&
                 wakeChunkIfInitialized(
                   chunk,
                   resolveListeners,
-                  rejectListeners
+                  rejectListeners,
                 );
             }
             nextWriteIndex++;
@@ -3094,13 +3094,13 @@
               ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                   response,
                   value,
-                  !1
+                  !1,
                 ))
               : resolveIteratorResultChunk(
                   response,
                   buffer[nextWriteIndex],
                   value,
-                  !1
+                  !1,
                 );
             nextWriteIndex++;
           },
@@ -3110,20 +3110,20 @@
               ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                   response,
                   value,
-                  !0
+                  !0,
                 ))
               : resolveIteratorResultChunk(
                   response,
                   buffer[nextWriteIndex],
                   value,
-                  !0
+                  !0,
                 );
             for (nextWriteIndex++; nextWriteIndex < buffer.length; )
               resolveIteratorResultChunk(
                 response,
                 buffer[nextWriteIndex++],
                 '"$undefined"',
-                !0
+                !0,
               );
           },
           error: function (error) {
@@ -3135,9 +3135,9 @@
 
             )
               triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);
-          }
+          },
         },
-        streamState
+        streamState,
       );
     }
     function resolveErrorDev(response, errorInfo) {
@@ -3151,8 +3151,8 @@
         Error.bind(
           null,
           errorInfo.message ||
-            "An error occurred in the Server Components render but no message was provided"
-        )
+            'An error occurred in the Server Components render but no message was provided',
+        ),
       );
       var ownerTask = null;
       null != errorInfo.owner &&
@@ -3161,8 +3161,8 @@
           response,
           errorInfo,
           {},
-          "",
-          createModel
+          '',
+          createModel,
         )),
         null !== errorInfo &&
           (ownerTask = initializeFakeTask(response, errorInfo)));
@@ -3182,9 +3182,9 @@
       col,
       enclosingLine,
       enclosingCol,
-      environmentName
+      environmentName,
     ) {
-      name || (name = "<anonymous>");
+      name || (name = '<anonymous>');
       var encodedName = JSON.stringify(name);
       1 > enclosingLine ? (enclosingLine = 0) : enclosingLine--;
       1 > enclosingCol ? (enclosingCol = 0) : enclosingCol--;
@@ -3202,66 +3202,66 @@
           (col = col - enclosingCol - line - 3),
           0 > col && (col = 0),
           (encodedName =
-            "({" +
+            '({' +
             encodedName +
-            ":" +
-            " ".repeat(enclosingCol) +
-            "_=>" +
-            " ".repeat(col) +
-            "_()})"))
+            ':' +
+            ' '.repeat(enclosingCol) +
+            '_=>' +
+            ' '.repeat(col) +
+            '_()})'))
         : 1 > enclosingLine
           ? ((enclosingCol -= encodedName.length + 3),
             0 > enclosingCol && (enclosingCol = 0),
             (encodedName =
-              "({" +
+              '({' +
               encodedName +
-              ":" +
-              " ".repeat(enclosingCol) +
-              "_=>" +
-              "\n".repeat(line - enclosingLine) +
-              " ".repeat(col) +
-              "_()})"))
+              ':' +
+              ' '.repeat(enclosingCol) +
+              '_=>' +
+              '\n'.repeat(line - enclosingLine) +
+              ' '.repeat(col) +
+              '_()})'))
           : enclosingLine === line
             ? ((col = col - enclosingCol - 3),
               0 > col && (col = 0),
               (encodedName =
-                "\n".repeat(enclosingLine - 1) +
-                "({" +
+                '\n'.repeat(enclosingLine - 1) +
+                '({' +
                 encodedName +
-                ":\n" +
-                " ".repeat(enclosingCol) +
-                "_=>" +
-                " ".repeat(col) +
-                "_()})"))
+                ':\n' +
+                ' '.repeat(enclosingCol) +
+                '_=>' +
+                ' '.repeat(col) +
+                '_()})'))
             : (encodedName =
-                "\n".repeat(enclosingLine - 1) +
-                "({" +
+                '\n'.repeat(enclosingLine - 1) +
+                '({' +
                 encodedName +
-                ":\n" +
-                " ".repeat(enclosingCol) +
-                "_=>" +
-                "\n".repeat(line - enclosingLine) +
-                " ".repeat(col) +
-                "_()})");
+                ':\n' +
+                ' '.repeat(enclosingCol) +
+                '_=>' +
+                '\n'.repeat(line - enclosingLine) +
+                ' '.repeat(col) +
+                '_()})');
       encodedName =
         1 > enclosingLine
           ? encodedName +
-            "\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */"
-          : "/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */" +
+            '\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */'
+          : '/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */' +
             encodedName;
-      filename.startsWith("/") && (filename = "file://" + filename);
+      filename.startsWith('/') && (filename = 'file://' + filename);
       sourceMap
         ? ((encodedName +=
-            "\n//# sourceURL=about://React/" +
+            '\n//# sourceURL=about://React/' +
             encodeURIComponent(environmentName) +
-            "/" +
+            '/' +
             encodeURI(filename) +
-            "?" +
+            '?' +
             fakeFunctionIdx++),
-          (encodedName += "\n//# sourceMappingURL=" + sourceMap))
+          (encodedName += '\n//# sourceMappingURL=' + sourceMap))
         : (encodedName = filename
-            ? encodedName + ("\n//# sourceURL=" + encodeURI(filename))
-            : encodedName + "\n//# sourceURL=<anonymous>");
+            ? encodedName + ('\n//# sourceURL=' + encodeURI(filename))
+            : encodedName + '\n//# sourceURL=<anonymous>');
       try {
         var fn = (0, eval)(encodedName)[name];
       } catch (x) {
@@ -3276,15 +3276,15 @@
       stack,
       environmentName,
       useEnclosingLine,
-      innerCall
+      innerCall,
     ) {
       for (var i = 0; i < stack.length; i++) {
         var frame = stack[i],
           frameKey =
-            frame.join("-") +
-            "-" +
+            frame.join('-') +
+            '-' +
             environmentName +
-            (useEnclosingLine ? "-e" : "-n"),
+            (useEnclosingLine ? '-e' : '-n'),
           fn = fakeFunctionCache.get(frameKey);
         if (void 0 === fn) {
           fn = frame[0];
@@ -3305,7 +3305,7 @@
             col,
             useEnclosingLine ? line : enclosingLine,
             useEnclosingLine ? col : frame,
-            environmentName
+            environmentName,
           );
           fakeFunctionCache.set(frameKey, fn);
         }
@@ -3319,7 +3319,7 @@
         ? response._rootEnvironmentName !== childEnvironmentName
           ? ((response = console.createTask.bind(
               console,
-              '"use ' + childEnvironmentName.toLowerCase() + '"'
+              '"use ' + childEnvironmentName.toLowerCase() + '"',
             )),
             rootTask.run(response))
           : rootTask
@@ -3345,17 +3345,17 @@
         env !== cachedEntry
           ? '"use ' + env.toLowerCase() + '"'
           : void 0 !== debugInfo.key
-            ? "<" + (debugInfo.name || "...") + ">"
+            ? '<' + (debugInfo.name || '...') + '>'
             : void 0 !== debugInfo.name
-              ? debugInfo.name || "unknown"
-              : "await " + (debugInfo.awaited.name || "unknown");
+              ? debugInfo.name || 'unknown'
+              : 'await ' + (debugInfo.awaited.name || 'unknown');
       env = console.createTask.bind(console, env);
       useEnclosingLine = buildFakeCallStack(
         response,
         stack,
         cachedEntry,
         useEnclosingLine,
-        env
+        env,
       );
       null === ownerTask
         ? ((response = getRootTask(response, cachedEntry)),
@@ -3367,7 +3367,7 @@
       return (debugInfo.debugTask = response);
     }
     function fakeJSXCallSite() {
-      return Error("react-stack-top-frame");
+      return Error('react-stack-top-frame');
     }
     function initializeFakeStack(response, debugInfo) {
       if (void 0 === debugInfo.debugStack) {
@@ -3375,7 +3375,7 @@
           (debugInfo.debugStack = createFakeJSXCallStackInDEV(
             response,
             debugInfo.stack,
-            null == debugInfo.env ? "" : debugInfo.env
+            null == debugInfo.env ? '' : debugInfo.env,
           ));
         var owner = debugInfo.owner;
         null != owner &&
@@ -3395,16 +3395,16 @@
         _componentInfoOrAsyncInfo.debugTask = response._debugRootTask;
       } else
         void 0 !== debugInfo.stack && initializeFakeStack(response, debugInfo);
-      "number" === typeof debugInfo.time &&
+      'number' === typeof debugInfo.time &&
         (debugInfo = { time: debugInfo.time + response._timeOrigin });
       return debugInfo;
     }
     function getCurrentStackInDEV() {
       var owner = currentOwnerInDEV;
-      if (null === owner) return "";
+      if (null === owner) return '';
       try {
-        var info = "";
-        if (owner.owner || "string" !== typeof owner.name) {
+        var info = '';
+        if (owner.owner || 'string' !== typeof owner.name) {
           for (; owner; ) {
             var ownerStack = owner.debugStack;
             if (null != ownerStack) {
@@ -3415,16 +3415,16 @@
                 Error.prepareStackTrace = prepareStackTrace;
                 var stack = error.stack;
                 Error.prepareStackTrace = prevPrepareStackTrace;
-                stack.startsWith("Error: react-stack-top-frame\n") &&
+                stack.startsWith('Error: react-stack-top-frame\n') &&
                   (stack = stack.slice(29));
-                var idx = stack.indexOf("\n");
+                var idx = stack.indexOf('\n');
                 -1 !== idx && (stack = stack.slice(idx + 1));
-                idx = stack.indexOf("react_stack_bottom_frame");
-                -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
+                idx = stack.indexOf('react_stack_bottom_frame');
+                -1 !== idx && (idx = stack.lastIndexOf('\n', idx));
                 var JSCompiler_inline_result =
-                  -1 !== idx ? (stack = stack.slice(0, idx)) : "";
+                  -1 !== idx ? (stack = stack.slice(0, idx)) : '';
                 info =
-                  JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
+                  JSCompiler_temp_const + ('\n' + JSCompiler_inline_result);
               }
             } else break;
           }
@@ -3437,20 +3437,20 @@
             } catch (x) {
               (prefix =
                 ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) ||
-                ""),
+                ''),
                 (suffix =
-                  -1 < x.stack.indexOf("\n    at")
-                    ? " (<anonymous>)"
-                    : -1 < x.stack.indexOf("@")
-                      ? "@unknown:0:0"
-                      : "");
+                  -1 < x.stack.indexOf('\n    at')
+                    ? ' (<anonymous>)'
+                    : -1 < x.stack.indexOf('@')
+                      ? '@unknown:0:0'
+                      : '');
             }
           JSCompiler_inline_result$jscomp$0 =
-            "\n" + prefix + JSCompiler_temp_const + suffix;
+            '\n' + prefix + JSCompiler_temp_const + suffix;
         }
       } catch (x) {
         JSCompiler_inline_result$jscomp$0 =
-          "\nError generating stack: " + x.message + "\n" + x.stack;
+          '\nError generating stack: ' + x.message + '\n' + x.stack;
       }
       return JSCompiler_inline_result$jscomp$0;
     }
@@ -3460,13 +3460,13 @@
         if (null == blockedChunk)
           (blockedChunk = createResolvedModelChunk(response, json)),
             initializeModelChunk(blockedChunk),
-            "fulfilled" === blockedChunk.status
+            'fulfilled' === blockedChunk.status
               ? replayConsoleWithCallStackInDEV(response, blockedChunk.value)
               : (blockedChunk.then(
                   function (v) {
                     return replayConsoleWithCallStackInDEV(response, v);
                   },
-                  function () {}
+                  function () {},
                 ),
                 (response._blockedConsole = blockedChunk));
         else {
@@ -3475,7 +3475,7 @@
             function (v) {
               return replayConsoleWithCallStackInDEV(response, v);
             },
-            function () {}
+            function () {},
           );
           response._blockedConsole = _chunk4;
           var unblock = function () {
@@ -3498,16 +3498,16 @@
         var promise = ioInfo.value;
         if (promise)
           switch (promise.status) {
-            case "fulfilled":
+            case 'fulfilled':
               logIOInfo(ioInfo, response, promise.value);
               break;
-            case "rejected":
+            case 'rejected':
               logIOInfoErrored(ioInfo, response, promise.reason);
               break;
             default:
               promise.then(
                 logIOInfo.bind(null, ioInfo, response),
-                logIOInfoErrored.bind(null, ioInfo, response)
+                logIOInfoErrored.bind(null, ioInfo, response),
               );
           }
         else logIOInfo(ioInfo, response, void 0);
@@ -3518,17 +3518,17 @@
         chunk = chunks.get(id);
       chunk
         ? (resolveModelChunk(response, chunk, model),
-          "resolved_model" === chunk.status && initializeModelChunk(chunk))
+          'resolved_model' === chunk.status && initializeModelChunk(chunk))
         : ((chunk = createResolvedModelChunk(response, model)),
           chunks.set(id, chunk),
           initializeModelChunk(chunk));
-      "fulfilled" === chunk.status
+      'fulfilled' === chunk.status
         ? initializeIOInfo(response, chunk.value)
         : chunk.then(
             function (v) {
               initializeIOInfo(response, v);
             },
-            function () {}
+            function () {},
           );
     }
     function mergeBuffer(buffer, lastChunk) {
@@ -3554,7 +3554,7 @@
       lastChunk,
       constructor,
       bytesPerElement,
-      streamState
+      streamState,
     ) {
       buffer =
         0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
@@ -3563,7 +3563,7 @@
       constructor = new constructor(
         buffer.buffer,
         buffer.byteOffset,
-        buffer.byteLength / bytesPerElement
+        buffer.byteLength / bytesPerElement,
       );
       resolveBuffer(response, id, constructor, streamState);
     }
@@ -3572,7 +3572,7 @@
       root,
       trackIdx$jscomp$6,
       trackTime,
-      parentEndTime
+      parentEndTime,
     ) {
       if (!isArrayImpl(root._children)) {
         var previousResult = root._children,
@@ -3588,9 +3588,9 @@
           if (supportsUserTiming && 0 <= previousEndTime && 10 > trackIdx) {
             var color =
                 componentInfo.env === response$jscomp$0._rootEnvironmentName
-                  ? "primary-light"
-                  : "secondary-light",
-              entryName = componentInfo.name + " [deduped]",
+                  ? 'primary-light'
+                  : 'secondary-light',
+              entryName = componentInfo.name + ' [deduped]',
               debugTask = componentInfo.debugTask;
             debugTask
               ? debugTask.run(
@@ -3600,17 +3600,17 @@
                     0 > startTime ? 0 : startTime,
                     previousEndTime,
                     trackNames[trackIdx],
-                    "Server Components \u269b",
-                    color
-                  )
+                    'Server Components \u269b',
+                    color,
+                  ),
                 )
               : console.timeStamp(
                   entryName,
                   0 > startTime ? 0 : startTime,
                   previousEndTime,
                   trackNames[trackIdx],
-                  "Server Components \u269b",
-                  color
+                  'Server Components \u269b',
+                  color,
                 );
           }
         }
@@ -3622,8 +3622,8 @@
       if (debugInfo) {
         for (var startTime$jscomp$0 = 0, i = 0; i < debugInfo.length; i++) {
           var info = debugInfo[i];
-          "number" === typeof info.time && (startTime$jscomp$0 = info.time);
-          if ("string" === typeof info.name) {
+          'number' === typeof info.time && (startTime$jscomp$0 = info.time);
+          if ('string' === typeof info.name) {
             startTime$jscomp$0 < trackTime && trackIdx$jscomp$6++;
             trackTime = startTime$jscomp$0;
             break;
@@ -3631,7 +3631,7 @@
         }
         for (var _i4 = debugInfo.length - 1; 0 <= _i4; _i4--) {
           var _info = debugInfo[_i4];
-          if ("number" === typeof _info.time && _info.time > parentEndTime) {
+          if ('number' === typeof _info.time && _info.time > parentEndTime) {
             parentEndTime = _info.time;
             break;
           }
@@ -3640,7 +3640,7 @@
       var result = {
         track: trackIdx$jscomp$6,
         endTime: -Infinity,
-        component: null
+        component: null,
       };
       root._children = result;
       for (
@@ -3656,7 +3656,7 @@
           children[_i5],
           childTrackIdx,
           childTrackTime,
-          parentEndTime
+          parentEndTime,
         );
         null !== childResult.component &&
           (result.component = childResult.component);
@@ -3676,13 +3676,13 @@
           _i6--
         ) {
           var _info2 = debugInfo[_i6];
-          if ("number" === typeof _info2.time) {
+          if ('number' === typeof _info2.time) {
             0 === componentEndTime && (componentEndTime = _info2.time);
             var time = _info2.time;
             if (-1 < endTimeIdx)
               for (var j = endTimeIdx - 1; j > _i6; j--) {
                 var candidateInfo = debugInfo[j];
-                if ("string" === typeof candidateInfo.name) {
+                if ('string' === typeof candidateInfo.name) {
                   componentEndTime > childrenEndTime &&
                     (childrenEndTime = componentEndTime);
                   var componentInfo$jscomp$0 = candidateInfo,
@@ -3694,7 +3694,7 @@
                     childrenEndTime$jscomp$0 = childrenEndTime;
                   if (
                     isLastComponent &&
-                    "rejected" === root.status &&
+                    'rejected' === root.status &&
                     root.reason !== response._closedReason
                   ) {
                     var componentInfo$jscomp$2 = componentInfo$jscomp$1,
@@ -3709,44 +3709,44 @@
                           env === response._rootEnvironmentName ||
                           void 0 === env
                             ? name
-                            : name + " [" + env + "]",
+                            : name + ' [' + env + ']',
                         properties = [
                           [
-                            "Error",
-                            "object" === typeof error &&
+                            'Error',
+                            'object' === typeof error &&
                             null !== error &&
-                            "string" === typeof error.message
+                            'string' === typeof error.message
                               ? String(error.message)
-                              : String(error)
-                          ]
+                              : String(error),
+                          ],
                         ];
                       null != componentInfo$jscomp$2.key &&
                         addValueToProperties(
-                          "key",
+                          'key',
                           componentInfo$jscomp$2.key,
                           properties,
                           0,
-                          ""
+                          '',
                         );
                       null != componentInfo$jscomp$2.props &&
                         addObjectToProperties(
                           componentInfo$jscomp$2.props,
                           properties,
                           0,
-                          ""
+                          '',
                         );
-                      performance.measure("\u200b" + entryName$jscomp$0, {
+                      performance.measure('\u200b' + entryName$jscomp$0, {
                         start: 0 > startTime$jscomp$2 ? 0 : startTime$jscomp$2,
                         end: childrenEndTime$jscomp$1,
                         detail: {
                           devtools: {
-                            color: "error",
+                            color: 'error',
                             track: trackNames[trackIdx$jscomp$1],
-                            trackGroup: "Server Components \u269b",
-                            tooltipText: entryName$jscomp$0 + " Errored",
-                            properties: properties
-                          }
-                        }
+                            trackGroup: 'Server Components \u269b',
+                            tooltipText: entryName$jscomp$0 + ' Errored',
+                            properties: properties,
+                          },
+                        },
                       });
                     }
                   } else {
@@ -3768,43 +3768,43 @@
                         color$jscomp$0 =
                           0.5 > selfTime
                             ? isPrimaryEnv
-                              ? "primary-light"
-                              : "secondary-light"
+                              ? 'primary-light'
+                              : 'secondary-light'
                             : 50 > selfTime
                               ? isPrimaryEnv
-                                ? "primary"
-                                : "secondary"
+                                ? 'primary'
+                                : 'secondary'
                               : 500 > selfTime
                                 ? isPrimaryEnv
-                                  ? "primary-dark"
-                                  : "secondary-dark"
-                                : "error",
+                                  ? 'primary-dark'
+                                  : 'secondary-dark'
+                                : 'error',
                         entryName$jscomp$1 =
                           isPrimaryEnv || void 0 === env$jscomp$0
                             ? name$jscomp$0
-                            : name$jscomp$0 + " [" + env$jscomp$0 + "]",
+                            : name$jscomp$0 + ' [' + env$jscomp$0 + ']',
                         debugTask$jscomp$0 = componentInfo$jscomp$3.debugTask;
                       if (debugTask$jscomp$0) {
                         var properties$jscomp$0 = [];
                         null != componentInfo$jscomp$3.key &&
                           addValueToProperties(
-                            "key",
+                            'key',
                             componentInfo$jscomp$3.key,
                             properties$jscomp$0,
                             0,
-                            ""
+                            '',
                           );
                         null != componentInfo$jscomp$3.props &&
                           addObjectToProperties(
                             componentInfo$jscomp$3.props,
                             properties$jscomp$0,
                             0,
-                            ""
+                            '',
                           );
                         debugTask$jscomp$0.run(
                           performance.measure.bind(
                             performance,
-                            "\u200b" + entryName$jscomp$1,
+                            '\u200b' + entryName$jscomp$1,
                             {
                               start:
                                 0 > startTime$jscomp$3 ? 0 : startTime$jscomp$3,
@@ -3813,21 +3813,21 @@
                                 devtools: {
                                   color: color$jscomp$0,
                                   track: trackNames[trackIdx$jscomp$2],
-                                  trackGroup: "Server Components \u269b",
-                                  properties: properties$jscomp$0
-                                }
-                              }
-                            }
-                          )
+                                  trackGroup: 'Server Components \u269b',
+                                  properties: properties$jscomp$0,
+                                },
+                              },
+                            },
+                          ),
                         );
                       } else
                         console.timeStamp(
-                          "\u200b" + entryName$jscomp$1,
+                          '\u200b' + entryName$jscomp$1,
                           0 > startTime$jscomp$3 ? 0 : startTime$jscomp$3,
                           childrenEndTime$jscomp$2,
                           trackNames[trackIdx$jscomp$2],
-                          "Server Components \u269b",
-                          color$jscomp$0
+                          'Server Components \u269b',
+                          color$jscomp$0,
                         );
                     }
                   }
@@ -3845,17 +3845,17 @@
                   if (promise) {
                     var thenable = promise;
                     switch (thenable.status) {
-                      case "fulfilled":
+                      case 'fulfilled':
                         logComponentAwait(
                           asyncInfo,
                           trackIdx$jscomp$6,
                           time,
                           endTime,
                           env$jscomp$1,
-                          thenable.value
+                          thenable.value,
                         );
                         break;
-                      case "rejected":
+                      case 'rejected':
                         var asyncInfo$jscomp$0 = asyncInfo,
                           trackIdx$jscomp$3 = trackIdx$jscomp$6,
                           startTime$jscomp$4 = time,
@@ -3865,12 +3865,12 @@
                         if (supportsUserTiming && 0 < endTime$jscomp$0) {
                           var description = getIODescription(error$jscomp$0),
                             entryName$jscomp$2 =
-                              "await " +
+                              'await ' +
                               getIOShortName(
                                 asyncInfo$jscomp$0.awaited,
                                 description,
                                 asyncInfo$jscomp$0.env,
-                                rootEnv
+                                rootEnv,
                               ),
                             debugTask$jscomp$1 =
                               asyncInfo$jscomp$0.debugTask ||
@@ -3878,21 +3878,21 @@
                           if (debugTask$jscomp$1) {
                             var properties$jscomp$1 = [
                                 [
-                                  "Rejected",
-                                  "object" === typeof error$jscomp$0 &&
+                                  'Rejected',
+                                  'object' === typeof error$jscomp$0 &&
                                   null !== error$jscomp$0 &&
-                                  "string" === typeof error$jscomp$0.message
+                                  'string' === typeof error$jscomp$0.message
                                     ? String(error$jscomp$0.message)
-                                    : String(error$jscomp$0)
-                                ]
+                                    : String(error$jscomp$0),
+                                ],
                               ],
                               tooltipText =
                                 getIOLongName(
                                   asyncInfo$jscomp$0.awaited,
                                   description,
                                   asyncInfo$jscomp$0.env,
-                                  rootEnv
-                                ) + " Rejected";
+                                  rootEnv,
+                                ) + ' Rejected';
                             debugTask$jscomp$1.run(
                               performance.measure.bind(
                                 performance,
@@ -3905,15 +3905,15 @@
                                   end: endTime$jscomp$0,
                                   detail: {
                                     devtools: {
-                                      color: "error",
+                                      color: 'error',
                                       track: trackNames[trackIdx$jscomp$3],
-                                      trackGroup: "Server Components \u269b",
+                                      trackGroup: 'Server Components \u269b',
                                       properties: properties$jscomp$1,
-                                      tooltipText: tooltipText
-                                    }
-                                  }
-                                }
-                              )
+                                      tooltipText: tooltipText,
+                                    },
+                                  },
+                                },
+                              ),
                             );
                           } else
                             console.timeStamp(
@@ -3921,8 +3921,8 @@
                               0 > startTime$jscomp$4 ? 0 : startTime$jscomp$4,
                               endTime$jscomp$0,
                               trackNames[trackIdx$jscomp$3],
-                              "Server Components \u269b",
-                              "error"
+                              'Server Components \u269b',
+                              'error',
                             );
                         }
                         break;
@@ -3933,7 +3933,7 @@
                           time,
                           endTime,
                           env$jscomp$1,
-                          void 0
+                          void 0,
                         );
                     }
                   } else
@@ -3943,7 +3943,7 @@
                       time,
                       endTime,
                       env$jscomp$1,
-                      void 0
+                      void 0,
                     );
                 }
               }
@@ -3951,7 +3951,7 @@
               endTime = time;
               for (var _j = debugInfo.length - 1; _j > _i6; _j--) {
                 var _candidateInfo = debugInfo[_j];
-                if ("string" === typeof _candidateInfo.name) {
+                if ('string' === typeof _candidateInfo.name) {
                   componentEndTime > childrenEndTime &&
                     (childrenEndTime = componentEndTime);
                   var _componentInfo = _candidateInfo,
@@ -3966,40 +3966,40 @@
                       entryName$jscomp$3 =
                         env$jscomp$2 === _env || void 0 === env$jscomp$2
                           ? name$jscomp$1
-                          : name$jscomp$1 + " [" + env$jscomp$2 + "]",
+                          : name$jscomp$1 + ' [' + env$jscomp$2 + ']',
                       properties$jscomp$2 = [
                         [
-                          "Aborted",
-                          "The stream was aborted before this Component finished rendering."
-                        ]
+                          'Aborted',
+                          'The stream was aborted before this Component finished rendering.',
+                        ],
                       ];
                     null != componentInfo$jscomp$4.key &&
                       addValueToProperties(
-                        "key",
+                        'key',
                         componentInfo$jscomp$4.key,
                         properties$jscomp$2,
                         0,
-                        ""
+                        '',
                       );
                     null != componentInfo$jscomp$4.props &&
                       addObjectToProperties(
                         componentInfo$jscomp$4.props,
                         properties$jscomp$2,
                         0,
-                        ""
+                        '',
                       );
-                    performance.measure("\u200b" + entryName$jscomp$3, {
+                    performance.measure('\u200b' + entryName$jscomp$3, {
                       start: 0 > startTime$jscomp$5 ? 0 : startTime$jscomp$5,
                       end: childrenEndTime$jscomp$3,
                       detail: {
                         devtools: {
-                          color: "warning",
+                          color: 'warning',
                           track: trackNames[trackIdx$jscomp$4],
-                          trackGroup: "Server Components \u269b",
-                          tooltipText: entryName$jscomp$3 + " Aborted",
-                          properties: properties$jscomp$2
-                        }
-                      }
+                          trackGroup: 'Server Components \u269b',
+                          tooltipText: entryName$jscomp$3 + ' Aborted',
+                          properties: properties$jscomp$2,
+                        },
+                      },
                     });
                   }
                   componentEndTime = time;
@@ -4021,12 +4021,12 @@
                     rootEnv$jscomp$0 = _env2;
                   if (supportsUserTiming && 0 < endTime$jscomp$1) {
                     var entryName$jscomp$4 =
-                        "await " +
+                        'await ' +
                         getIOShortName(
                           asyncInfo$jscomp$1.awaited,
-                          "",
+                          '',
                           asyncInfo$jscomp$1.env,
-                          rootEnv$jscomp$0
+                          rootEnv$jscomp$0,
                         ),
                       debugTask$jscomp$2 =
                         asyncInfo$jscomp$1.debugTask ||
@@ -4035,10 +4035,10 @@
                       var tooltipText$jscomp$0 =
                         getIOLongName(
                           asyncInfo$jscomp$1.awaited,
-                          "",
+                          '',
                           asyncInfo$jscomp$1.env,
-                          rootEnv$jscomp$0
-                        ) + " Aborted";
+                          rootEnv$jscomp$0,
+                        ) + ' Aborted';
                       debugTask$jscomp$2.run(
                         performance.measure.bind(
                           performance,
@@ -4049,20 +4049,20 @@
                             end: endTime$jscomp$1,
                             detail: {
                               devtools: {
-                                color: "warning",
+                                color: 'warning',
                                 track: trackNames[trackIdx$jscomp$5],
-                                trackGroup: "Server Components \u269b",
+                                trackGroup: 'Server Components \u269b',
                                 properties: [
                                   [
-                                    "Aborted",
-                                    "The stream was aborted before this Promise resolved."
-                                  ]
+                                    'Aborted',
+                                    'The stream was aborted before this Promise resolved.',
+                                  ],
                                 ],
-                                tooltipText: tooltipText$jscomp$0
-                              }
-                            }
-                          }
-                        )
+                                tooltipText: tooltipText$jscomp$0,
+                              },
+                            },
+                          },
+                        ),
                       );
                     } else
                       console.timeStamp(
@@ -4070,8 +4070,8 @@
                         0 > startTime$jscomp$6 ? 0 : startTime$jscomp$6,
                         endTime$jscomp$1,
                         trackNames[trackIdx$jscomp$5],
-                        "Server Components \u269b",
-                        "warning"
+                        'Server Components \u269b',
+                        'warning',
                       );
                   }
                 }
@@ -4094,7 +4094,7 @@
             rootChunk,
             0,
             -Infinity,
-            -Infinity
+            -Infinity,
           ));
       }
     }
@@ -4104,7 +4104,7 @@
       id,
       tag,
       buffer,
-      chunk
+      chunk,
     ) {
       switch (tag) {
         case 65:
@@ -4112,7 +4112,7 @@
             response,
             id,
             mergeBuffer(buffer, chunk).buffer,
-            streamState
+            streamState,
           );
           return;
         case 79:
@@ -4123,7 +4123,7 @@
             chunk,
             Int8Array,
             1,
-            streamState
+            streamState,
           );
           return;
         case 111:
@@ -4131,7 +4131,7 @@
             response,
             id,
             0 === buffer.length ? chunk : mergeBuffer(buffer, chunk),
-            streamState
+            streamState,
           );
           return;
         case 85:
@@ -4142,7 +4142,7 @@
             chunk,
             Uint8ClampedArray,
             1,
-            streamState
+            streamState,
           );
           return;
         case 83:
@@ -4153,7 +4153,7 @@
             chunk,
             Int16Array,
             2,
-            streamState
+            streamState,
           );
           return;
         case 115:
@@ -4164,7 +4164,7 @@
             chunk,
             Uint16Array,
             2,
-            streamState
+            streamState,
           );
           return;
         case 76:
@@ -4175,7 +4175,7 @@
             chunk,
             Int32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 108:
@@ -4186,7 +4186,7 @@
             chunk,
             Uint32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 71:
@@ -4197,7 +4197,7 @@
             chunk,
             Float32Array,
             4,
-            streamState
+            streamState,
           );
           return;
         case 103:
@@ -4208,7 +4208,7 @@
             chunk,
             Float64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 77:
@@ -4219,7 +4219,7 @@
             chunk,
             BigInt64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 109:
@@ -4230,7 +4230,7 @@
             chunk,
             BigUint64Array,
             8,
-            streamState
+            streamState,
           );
           return;
         case 86:
@@ -4241,12 +4241,12 @@
             chunk,
             DataView,
             1,
-            streamState
+            streamState,
           );
           return;
       }
       for (
-        var stringDecoder = response._stringDecoder, row = "", i = 0;
+        var stringDecoder = response._stringDecoder, row = '', i = 0;
         i < buffer.length;
         i++
       )
@@ -4265,42 +4265,42 @@
           response = JSON.parse(streamState, response._fromJSON);
           streamState = ReactDOMSharedInternals.d;
           switch (id) {
-            case "D":
+            case 'D':
               streamState.D(response);
               break;
-            case "C":
-              "string" === typeof response
+            case 'C':
+              'string' === typeof response
                 ? streamState.C(response)
                 : streamState.C(response[0], response[1]);
               break;
-            case "L":
+            case 'L':
               id = response[0];
               row = response[1];
               3 === response.length
                 ? streamState.L(id, row, response[2])
                 : streamState.L(id, row);
               break;
-            case "m":
-              "string" === typeof response
+            case 'm':
+              'string' === typeof response
                 ? streamState.m(response)
                 : streamState.m(response[0], response[1]);
               break;
-            case "X":
-              "string" === typeof response
+            case 'X':
+              'string' === typeof response
                 ? streamState.X(response)
                 : streamState.X(response[0], response[1]);
               break;
-            case "S":
-              "string" === typeof response
+            case 'S':
+              'string' === typeof response
                 ? streamState.S(response)
                 : streamState.S(
                     response[0],
                     0 === response[1] ? void 0 : response[1],
-                    3 === response.length ? response[2] : void 0
+                    3 === response.length ? response[2] : void 0,
                   );
               break;
-            case "M":
-              "string" === typeof response
+            case 'M':
+              'string' === typeof response
                 ? streamState.M(response)
                 : streamState.M(response[0], response[1]);
           }
@@ -4314,16 +4314,16 @@
           chunk
             ? (resolveChunkDebugInfo(streamState, chunk),
               triggerErrorOnChunk(response, chunk, error))
-            : ((response = new ReactPromise("rejected", null, error)),
+            : ((response = new ReactPromise('rejected', null, error)),
               resolveChunkDebugInfo(streamState, response),
               tag.set(id, response));
           break;
         case 84:
           tag = response._chunks;
-          (chunk = tag.get(id)) && "pending" !== chunk.status
+          (chunk = tag.get(id)) && 'pending' !== chunk.status
             ? chunk.reason.enqueueValue(row)
             : (chunk && releasePendingChunk(response, chunk),
-              (response = new ReactPromise("fulfilled", row, null)),
+              (response = new ReactPromise('fulfilled', row, null)),
               resolveChunkDebugInfo(streamState, response),
               tag.set(id, response));
           break;
@@ -4332,24 +4332,24 @@
           break;
         case 68:
           id = getChunk(response, id);
-          "fulfilled" !== id.status &&
-            "rejected" !== id.status &&
-            "halted" !== id.status &&
-            "blocked" !== id.status &&
-            "resolved_module" !== id.status &&
+          'fulfilled' !== id.status &&
+            'rejected' !== id.status &&
+            'halted' !== id.status &&
+            'blocked' !== id.status &&
+            'resolved_module' !== id.status &&
             ((streamState = id._debugChunk),
             (tag = createResolvedModelChunk(response, row)),
             (tag._debugChunk = streamState),
             (id._debugChunk = tag),
             initializeDebugChunk(response, id),
-            "blocked" !== tag.status ||
+            'blocked' !== tag.status ||
               (void 0 !== response._debugChannel &&
                 response._debugChannel.hasReadable) ||
               '"' !== row[0] ||
-              "$" !== row[1] ||
-              ((streamState = row.slice(2, row.length - 1).split(":")),
+              '$' !== row[1] ||
+              ((streamState = row.slice(2, row.length - 1).split(':')),
               (streamState = parseInt(streamState[0], 16)),
-              "pending" === getChunk(response, streamState).status &&
+              'pending' === getChunk(response, streamState).status &&
                 (id._debugChunk = null)));
           break;
         case 74:
@@ -4362,7 +4362,7 @@
           startReadableStream(response, id, void 0, streamState);
           break;
         case 114:
-          startReadableStream(response, id, "bytes", streamState);
+          startReadableStream(response, id, 'bytes', streamState);
           break;
         case 88:
           startAsyncIterable(response, id, !1, streamState);
@@ -4372,20 +4372,20 @@
           break;
         case 67:
           (response = response._chunks.get(id)) &&
-            "fulfilled" === response.status &&
-            response.reason.close("" === row ? '"$undefined"' : row);
+            'fulfilled' === response.status &&
+            response.reason.close('' === row ? '"$undefined"' : row);
           break;
         default:
-          if ("" === row) {
+          if ('' === row) {
             if (
               ((streamState = response._chunks),
               (row = streamState.get(id)) ||
                 streamState.set(id, (row = createPendingChunk(response))),
-              "pending" === row.status || "blocked" === row.status)
+              'pending' === row.status || 'blocked' === row.status)
             )
               releasePendingChunk(response, row),
                 (response = row),
-                (response.status = "halted"),
+                (response.status = 'halted'),
                 (response.value = null),
                 (response.reason = null);
           } else
@@ -4471,7 +4471,7 @@
                 weakResponse,
                 rowTag,
                 buffer,
-                rowLength
+                rowLength,
               ),
               (i = lastIdx),
               3 === rowState && i++,
@@ -4492,9 +4492,9 @@
     }
     function createFromJSONCallback(response) {
       return function (key, value) {
-        if ("string" === typeof value)
+        if ('string' === typeof value)
           return parseModelString(response, this, key, value);
-        if ("object" === typeof value && null !== value) {
+        if ('object' === typeof value && null !== value) {
           if (value[0] === REACT_ELEMENT_TYPE)
             b: {
               var owner = value[4],
@@ -4505,46 +4505,46 @@
                 type: value[1],
                 key: value[2],
                 props: value[3],
-                _owner: void 0 === owner ? null : owner
+                _owner: void 0 === owner ? null : owner,
               };
-              Object.defineProperty(value, "ref", {
+              Object.defineProperty(value, 'ref', {
                 enumerable: !1,
-                get: nullRefGetter
+                get: nullRefGetter,
               });
               value._store = {};
-              Object.defineProperty(value._store, "validated", {
+              Object.defineProperty(value._store, 'validated', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: key
+                value: key,
               });
-              Object.defineProperty(value, "_debugInfo", {
+              Object.defineProperty(value, '_debugInfo', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: null
+                value: null,
               });
-              Object.defineProperty(value, "_debugStack", {
+              Object.defineProperty(value, '_debugStack', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: void 0 === stack ? null : stack
+                value: void 0 === stack ? null : stack,
               });
-              Object.defineProperty(value, "_debugTask", {
+              Object.defineProperty(value, '_debugTask', {
                 configurable: !1,
                 enumerable: !1,
                 writable: !0,
-                value: null
+                value: null,
               });
               if (null !== initializingHandler) {
                 owner = initializingHandler;
                 initializingHandler = owner.parent;
                 if (owner.errored) {
-                  stack = new ReactPromise("rejected", null, owner.reason);
+                  stack = new ReactPromise('rejected', null, owner.reason);
                   initializeElement(response, value, null);
                   owner = {
-                    name: getComponentNameFromType(value.type) || "",
-                    owner: value._owner
+                    name: getComponentNameFromType(value.type) || '',
+                    owner: value._owner,
                   };
                   owner.debugStack = value._debugStack;
                   supportsCreateTask && (owner.debugTask = value._debugTask);
@@ -4553,7 +4553,7 @@
                   break b;
                 }
                 if (0 < owner.deps) {
-                  stack = new ReactPromise("blocked", null, null);
+                  stack = new ReactPromise('blocked', null, null);
                   owner.value = value;
                   owner.chunk = stack;
                   key = createLazyChunkWrapper(stack, key);
@@ -4572,11 +4572,11 @@
       };
     }
     function close(weakResponse) {
-      reportGlobalError(weakResponse, Error("Connection closed."));
+      reportGlobalError(weakResponse, Error('Connection closed.'));
     }
     function noServerCall$1() {
       throw Error(
-        "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+        'Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.',
       );
     }
     function createResponseFromOptions(options) {
@@ -4586,7 +4586,7 @@
         options.serverConsumerManifest.moduleLoading,
         noServerCall$1,
         options.encodeFormAction,
-        "string" === typeof options.nonce ? options.nonce : void 0,
+        'string' === typeof options.nonce ? options.nonce : void 0,
         options && options.temporaryReferences
           ? options.temporaryReferences
           : void 0,
@@ -4596,9 +4596,9 @@
         options && void 0 !== options.debugChannel
           ? {
               hasReadable: void 0 !== options.debugChannel.readable,
-              callback: null
+              callback: null,
             }
-          : void 0
+          : void 0,
       )._weakResponse;
     }
     function startReadingFromStream$1(response, stream, onDone, debugValue) {
@@ -4617,13 +4617,13 @@
     }
     function noServerCall() {
       throw Error(
-        "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+        'Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.',
       );
     }
     function startReadingFromStream(response$jscomp$0, stream, onEnd) {
       var streamState = createStreamState(response$jscomp$0, stream);
-      stream.on("data", function (chunk) {
-        if ("string" === typeof chunk) {
+      stream.on('data', function (chunk) {
+        if ('string' === typeof chunk) {
           if (void 0 !== response$jscomp$0.weak.deref()) {
             var response = unwrapWeakResponse(response$jscomp$0),
               i = 0,
@@ -4680,23 +4680,23 @@
                         (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
                   continue;
                 case 3:
-                  lastIdx = chunk.indexOf("\n", i);
+                  lastIdx = chunk.indexOf('\n', i);
                   break;
                 case 4:
                   if (84 !== rowTag)
                     throw Error(
-                      "Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams."
+                      'Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams.',
                     );
                   if (rowLength < chunk.length || chunk.length > 3 * rowLength)
                     throw Error(
-                      "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+                      'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
                     );
                   lastIdx = chunk.length;
               }
               if (-1 < lastIdx) {
                 if (0 < buffer.length)
                   throw Error(
-                    "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+                    'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
                   );
                 i = chunk.slice(i, lastIdx);
                 processFullStringRow(response, streamState, rowID, rowTag, i);
@@ -4706,7 +4706,7 @@
                 buffer.length = 0;
               } else if (chunk.length !== i)
                 throw Error(
-                  "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+                  'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
                 );
             }
             streamState._rowState = rowState;
@@ -4716,39 +4716,39 @@
           }
         } else processBinaryChunk(response$jscomp$0, streamState, chunk);
       });
-      stream.on("error", function (error) {
+      stream.on('error', function (error) {
         reportGlobalError(response$jscomp$0, error);
       });
-      stream.on("end", onEnd);
+      stream.on('end', onEnd);
     }
-    var util = require("util"),
-      ReactDOM = require("react-dom"),
-      React = require("react"),
+    var util = require('util'),
+      ReactDOM = require('react-dom'),
+      React = require('react'),
       decoderOptions = { stream: !0 },
       bind$1 = Function.prototype.bind,
       asyncModuleCache = new Map(),
       ReactDOMSharedInternals =
         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
-      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
+      REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+      REACT_PORTAL_TYPE = Symbol.for('react.portal'),
+      REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+      REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode'),
+      REACT_PROFILER_TYPE = Symbol.for('react.profiler'),
+      REACT_CONSUMER_TYPE = Symbol.for('react.consumer'),
+      REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+      REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+      REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+      REACT_MEMO_TYPE = Symbol.for('react.memo'),
+      REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+      REACT_ACTIVITY_TYPE = Symbol.for('react.activity'),
       MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
       ASYNC_ITERATOR = Symbol.asyncIterator,
       isArrayImpl = Array.isArray,
       getPrototypeOf = Object.getPrototypeOf,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
-      CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"),
+      CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference'),
       ObjectPrototype = Object.prototype,
       knownServerReferences = new WeakMap(),
       boundCache = new WeakMap(),
@@ -4759,19 +4759,19 @@
         /^ {3} at (?:(.+) \((.+):(\d+):(\d+)\)|(?:async )?(.+):(\d+):(\d+))$/,
       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\d+):(\d+)/,
       hasOwnProperty = Object.prototype.hasOwnProperty,
-      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
+      REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference'),
       supportsUserTiming =
-        "undefined" !== typeof console &&
-        "function" === typeof console.timeStamp &&
-        "undefined" !== typeof performance &&
-        "function" === typeof performance.measure,
+        'undefined' !== typeof console &&
+        'function' === typeof console.timeStamp &&
+        'undefined' !== typeof performance &&
+        'function' === typeof performance.measure,
       trackNames =
-        "Primary Parallel Parallel\u200b Parallel\u200b\u200b Parallel\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b".split(
-          " "
+        'Primary Parallel Parallel\u200b Parallel\u200b\u200b Parallel\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b'.split(
+          ' ',
         ),
       prefix,
       suffix;
-    new ("function" === typeof WeakMap ? WeakMap : Map)();
+    new ('function' === typeof WeakMap ? WeakMap : Map)();
     var ReactSharedInteralsServer =
         React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
       ReactSharedInternals =
@@ -4781,10 +4781,10 @@
     ReactPromise.prototype.then = function (resolve, reject) {
       var _this = this;
       switch (this.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(this);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(this);
       }
       var resolveCallback = resolve,
@@ -4801,26 +4801,26 @@
         });
       wrapperPromise.then(resolveCallback, rejectCallback);
       switch (this.status) {
-        case "fulfilled":
-          "function" === typeof resolve && resolve(this.value);
+        case 'fulfilled':
+          'function' === typeof resolve && resolve(this.value);
           break;
-        case "pending":
-        case "blocked":
-          "function" === typeof resolve &&
+        case 'pending':
+        case 'blocked':
+          'function' === typeof resolve &&
             (null === this.value && (this.value = []),
             this.value.push(resolve));
-          "function" === typeof reject &&
+          'function' === typeof reject &&
             (null === this.reason && (this.reason = []),
             this.reason.push(reject));
           break;
-        case "halted":
+        case 'halted':
           break;
         default:
-          "function" === typeof reject && reject(this.reason);
+          'function' === typeof reject && reject(this.reason);
       }
     };
     var debugChannelRegistry =
-        "function" === typeof FinalizationRegistry
+        'function' === typeof FinalizationRegistry
           ? new FinalizationRegistry(closeDebugChannel)
           : null,
       initializingHandler = null,
@@ -4837,13 +4837,13 @@
             stack,
             environmentName,
             !1,
-            fakeJSXCallSite
+            fakeJSXCallSite,
           )();
-        }
+        },
       },
       createFakeJSXCallStackInDEV =
         createFakeJSXCallStack.react_stack_bottom_frame.bind(
-          createFakeJSXCallStack
+          createFakeJSXCallStack,
         ),
       currentOwnerInDEV = null,
       replayConsoleWithCallStack = {
@@ -4860,40 +4860,40 @@
             a: {
               var offset = 0;
               switch (methodName) {
-                case "dir":
-                case "dirxml":
-                case "groupEnd":
-                case "table":
+                case 'dir':
+                case 'dirxml':
+                case 'groupEnd':
+                case 'table':
                   var JSCompiler_inline_result = bind$1.apply(
                     console[methodName],
-                    [console].concat(payload)
+                    [console].concat(payload),
                   );
                   break a;
-                case "assert":
+                case 'assert':
                   offset = 1;
               }
               var newArgs = payload.slice(0);
-              "string" === typeof newArgs[offset]
+              'string' === typeof newArgs[offset]
                 ? newArgs.splice(
                     offset,
                     1,
-                    "\u001b[0m\u001b[7m%c%s\u001b[0m%c " + newArgs[offset],
-                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
-                    " " + env + " ",
-                    ""
+                    '\u001b[0m\u001b[7m%c%s\u001b[0m%c ' + newArgs[offset],
+                    'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px',
+                    ' ' + env + ' ',
+                    '',
                   )
                 : newArgs.splice(
                     offset,
                     0,
-                    "\u001b[0m\u001b[7m%c%s\u001b[0m%c",
-                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
-                    " " + env + " ",
-                    ""
+                    '\u001b[0m\u001b[7m%c%s\u001b[0m%c',
+                    'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px',
+                    ' ' + env + ' ',
+                    '',
                   );
               newArgs.unshift(console);
               JSCompiler_inline_result = bind$1.apply(
                 console[methodName],
-                newArgs
+                newArgs,
               );
             }
             var callStack = buildFakeCallStack(
@@ -4901,7 +4901,7 @@
               stackTrace,
               env,
               !1,
-              JSCompiler_inline_result
+              JSCompiler_inline_result,
             );
             if (null != owner) {
               var task = initializeFakeTask(response, owner);
@@ -4917,11 +4917,11 @@
             (currentOwnerInDEV = null),
               (ReactSharedInternals.getCurrentStack = prevStack);
           }
-        }
+        },
       },
       replayConsoleWithCallStackInDEV =
         replayConsoleWithCallStack.react_stack_bottom_frame.bind(
-          replayConsoleWithCallStack
+          replayConsoleWithCallStack,
         );
     exports.createFromFetch = function (promiseForResponse, options) {
       var response = createResponseFromOptions(options);
@@ -4939,7 +4939,7 @@
             startReadingFromStream$1(
               response,
               options.debugChannel.readable,
-              handleDone
+              handleDone,
             );
             startReadingFromStream$1(response, r.body, handleDone, r);
           } else
@@ -4947,19 +4947,19 @@
               response,
               r.body,
               close.bind(null, response),
-              r
+              r,
             );
         },
         function (e) {
           reportGlobalError(response, e);
-        }
+        },
       );
       return getRoot(response);
     };
     exports.createFromNodeStream = function (
       stream,
       serverConsumerManifest,
-      options
+      options,
     ) {
       var response = new ResponseInstance(
         serverConsumerManifest.moduleMap,
@@ -4967,7 +4967,7 @@
         serverConsumerManifest.moduleLoading,
         noServerCall,
         options ? options.encodeFormAction : void 0,
-        options && "string" === typeof options.nonce ? options.nonce : void 0,
+        options && 'string' === typeof options.nonce ? options.nonce : void 0,
         void 0,
         options && options.findSourceMapURL ? options.findSourceMapURL : void 0,
         options ? !0 === options.replayConsoleLogs : !1,
@@ -4975,9 +4975,9 @@
         options && void 0 !== options.debugChannel
           ? {
               hasReadable: void 0 !== options.debugChannel.readable,
-              callback: null
+              callback: null,
             }
-          : void 0
+          : void 0,
       )._weakResponse;
       if (options && options.debugChannel) {
         var streamEndedCount = 0;
@@ -4987,7 +4987,7 @@
         startReadingFromStream(
           response,
           options.debugChannel,
-          serverConsumerManifest
+          serverConsumerManifest,
         );
         startReadingFromStream(response, stream, serverConsumerManifest);
       } else
@@ -5004,7 +5004,7 @@
         startReadingFromStream$1(
           response,
           options.debugChannel.readable,
-          handleDone
+          handleDone,
         );
         startReadingFromStream$1(response, stream, handleDone, stream);
       } else
@@ -5012,7 +5012,7 @@
           response,
           stream,
           close.bind(null, response),
-          stream
+          stream,
         );
       return getRoot(response);
     };
@@ -5026,12 +5026,12 @@
       return new Promise(function (resolve, reject) {
         var abort = processReply(
           value,
-          "",
+          '',
           options && options.temporaryReferences
             ? options.temporaryReferences
             : void 0,
           resolve,
-          reject
+          reject,
         );
         if (options && options.signal) {
           var signal = options.signal;
@@ -5039,9 +5039,9 @@
           else {
             var listener = function () {
               abort(signal.reason);
-              signal.removeEventListener("abort", listener);
+              signal.removeEventListener('abort', listener);
             };
-            signal.addEventListener("abort", listener);
+            signal.addEventListener('abort', listener);
           }
         }
       });
@@ -5049,7 +5049,7 @@
     exports.registerServerReference = function (
       reference,
       id,
-      encodeFormAction
+      encodeFormAction,
     ) {
       registerBoundServerReference(reference, id, null, encodeFormAction);
       return reference;
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.node.unbundled.production.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.unbundled.production.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-client.node.unbundled.production.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.unbundled.production.js	2025-12-17 14:32:44
@@ -8,32 +8,32 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-var util = require("util"),
-  ReactDOM = require("react-dom"),
+'use strict';
+var util = require('util'),
+  ReactDOM = require('react-dom'),
   decoderOptions = { stream: !0 };
 function resolveClientReference(bundlerConfig, metadata) {
   var moduleExports = bundlerConfig[metadata[0]];
   if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))
     moduleExports = bundlerConfig.name;
   else {
-    bundlerConfig = moduleExports && moduleExports["*"];
+    bundlerConfig = moduleExports && moduleExports['*'];
     if (!bundlerConfig)
       throw Error(
         'Could not find the module "' +
           metadata[0] +
-          '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'
+          '" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.',
       );
     moduleExports = metadata[2];
   }
   return {
     specifier: bundlerConfig.specifier,
     name: moduleExports,
-    async: 4 === metadata.length
+    async: 4 === metadata.length,
   };
 }
 function resolveServerReference(bundlerConfig, id) {
-  var idx = id.lastIndexOf("#");
+  var idx = id.lastIndexOf('#');
   bundlerConfig = id.slice(0, idx);
   id = id.slice(idx + 1);
   return { specifier: bundlerConfig, name: id };
@@ -42,7 +42,7 @@
 function preloadModule(metadata) {
   var existingPromise = asyncModuleCache.get(metadata.specifier);
   if (existingPromise)
-    return "fulfilled" === existingPromise.status ? null : existingPromise;
+    return 'fulfilled' === existingPromise.status ? null : existingPromise;
   var modulePromise = import(metadata.specifier);
   metadata.async &&
     (modulePromise = modulePromise.then(function (value) {
@@ -51,25 +51,25 @@
   modulePromise.then(
     function (value) {
       var fulfilledThenable = modulePromise;
-      fulfilledThenable.status = "fulfilled";
+      fulfilledThenable.status = 'fulfilled';
       fulfilledThenable.value = value;
     },
     function (reason) {
       var rejectedThenable = modulePromise;
-      rejectedThenable.status = "rejected";
+      rejectedThenable.status = 'rejected';
       rejectedThenable.reason = reason;
-    }
+    },
   );
   asyncModuleCache.set(metadata.specifier, modulePromise);
   return modulePromise;
 }
 function requireModule(metadata) {
   var moduleExports = asyncModuleCache.get(metadata.specifier);
-  if ("fulfilled" === moduleExports.status) moduleExports = moduleExports.value;
+  if ('fulfilled' === moduleExports.status) moduleExports = moduleExports.value;
   else throw moduleExports.reason;
-  return "*" === metadata.name
+  return '*' === metadata.name
     ? moduleExports
-    : "" === metadata.name
+    : '' === metadata.name
       ? moduleExports.default
       : moduleExports[metadata.name];
 }
@@ -82,29 +82,29 @@
         JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];
       var JSCompiler_inline_result = moduleLoading.crossOrigin;
       JSCompiler_inline_result =
-        "string" === typeof JSCompiler_inline_result
-          ? "use-credentials" === JSCompiler_inline_result
+        'string' === typeof JSCompiler_inline_result
+          ? 'use-credentials' === JSCompiler_inline_result
             ? JSCompiler_inline_result
-            : ""
+            : ''
           : void 0;
       JSCompiler_temp_const$jscomp$0.call(
         JSCompiler_temp_const,
         JSCompiler_temp_const$jscomp$1,
-        { crossOrigin: JSCompiler_inline_result, nonce: nonce }
+        { crossOrigin: JSCompiler_inline_result, nonce: nonce },
       );
     }
 }
 var ReactDOMSharedInternals =
     ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
-  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
+  REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+  REACT_LAZY_TYPE = Symbol.for('react.lazy'),
   MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
 function getIteratorFn(maybeIterable) {
-  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  if (null === maybeIterable || 'object' !== typeof maybeIterable) return null;
   maybeIterable =
     (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-    maybeIterable["@@iterator"];
-  return "function" === typeof maybeIterable ? maybeIterable : null;
+    maybeIterable['@@iterator'];
+  return 'function' === typeof maybeIterable ? maybeIterable : null;
 }
 var ASYNC_ITERATOR = Symbol.asyncIterator,
   isArrayImpl = Array.isArray,
@@ -114,33 +114,33 @@
 function serializeNumber(number) {
   return Number.isFinite(number)
     ? 0 === number && -Infinity === 1 / number
-      ? "$-0"
+      ? '$-0'
       : number
     : Infinity === number
-      ? "$Infinity"
+      ? '$Infinity'
       : -Infinity === number
-        ? "$-Infinity"
-        : "$NaN";
+        ? '$-Infinity'
+        : '$NaN';
 }
 function processReply(
   root,
   formFieldPrefix,
   temporaryReferences,
   resolve,
-  reject
+  reject,
 ) {
   function serializeTypedArray(tag, typedArray) {
     typedArray = new Blob([
       new Uint8Array(
         typedArray.buffer,
         typedArray.byteOffset,
-        typedArray.byteLength
-      )
+        typedArray.byteLength,
+      ),
     ]);
     var blobId = nextPartId++;
     null === formData && (formData = new FormData());
     formData.append(formFieldPrefix + blobId, typedArray);
-    return "$" + tag + blobId.toString(16);
+    return '$' + tag + blobId.toString(16);
   }
   function serializeBinaryReader(reader) {
     function progress(entry) {
@@ -149,9 +149,9 @@
           data.append(formFieldPrefix + entry, new Blob(buffer)),
           data.append(
             formFieldPrefix + streamId,
-            '"$o' + entry.toString(16) + '"'
+            '"$o' + entry.toString(16) + '"',
           ),
-          data.append(formFieldPrefix + streamId, "C"),
+          data.append(formFieldPrefix + streamId, 'C'),
           pendingParts--,
           0 === pendingParts && resolve(data))
         : (buffer.push(entry.value),
@@ -163,12 +163,12 @@
     var streamId = nextPartId++,
       buffer = [];
     reader.read(new Uint8Array(1024)).then(progress, reject);
-    return "$r" + streamId.toString(16);
+    return '$r' + streamId.toString(16);
   }
   function serializeReader(reader) {
     function progress(entry) {
       if (entry.done)
-        data.append(formFieldPrefix + streamId, "C"),
+        data.append(formFieldPrefix + streamId, 'C'),
           pendingParts--,
           0 === pendingParts && resolve(data);
       else
@@ -185,11 +185,11 @@
     pendingParts++;
     var streamId = nextPartId++;
     reader.read().then(progress, reject);
-    return "$R" + streamId.toString(16);
+    return '$R' + streamId.toString(16);
   }
   function serializeReadableStream(stream) {
     try {
-      var binaryReader = stream.getReader({ mode: "byob" });
+      var binaryReader = stream.getReader({ mode: 'byob' });
     } catch (x) {
       return serializeReader(stream.getReader());
     }
@@ -199,11 +199,11 @@
     function progress(entry) {
       if (entry.done) {
         if (void 0 === entry.value)
-          data.append(formFieldPrefix + streamId, "C");
+          data.append(formFieldPrefix + streamId, 'C');
         else
           try {
             var partJSON = JSON.stringify(entry.value, resolveToJSON);
-            data.append(formFieldPrefix + streamId, "C" + partJSON);
+            data.append(formFieldPrefix + streamId, 'C' + partJSON);
           } catch (x) {
             reject(x);
             return;
@@ -225,23 +225,23 @@
     var streamId = nextPartId++;
     iterable = iterable === iterator;
     iterator.next().then(progress, reject);
-    return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+    return '$' + (iterable ? 'x' : 'X') + streamId.toString(16);
   }
   function resolveToJSON(key, value) {
     if (null === value) return null;
-    if ("object" === typeof value) {
+    if ('object' === typeof value) {
       switch (value.$$typeof) {
         case REACT_ELEMENT_TYPE:
-          if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+          if (void 0 !== temporaryReferences && -1 === key.indexOf(':')) {
             var parentReference = writtenObjects.get(this);
             if (void 0 !== parentReference)
               return (
-                temporaryReferences.set(parentReference + ":" + key, value),
-                "$T"
+                temporaryReferences.set(parentReference + ':' + key, value),
+                '$T'
               );
           }
           throw Error(
-            "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+            'React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.',
           );
         case REACT_LAZY_TYPE:
           parentReference = value._payload;
@@ -253,12 +253,12 @@
               lazyId = nextPartId++,
               partJSON = serializeModel(resolvedModel, lazyId);
             formData.append(formFieldPrefix + lazyId, partJSON);
-            return "$" + lazyId.toString(16);
+            return '$' + lazyId.toString(16);
           } catch (x) {
             if (
-              "object" === typeof x &&
+              'object' === typeof x &&
               null !== x &&
-              "function" === typeof x.then
+              'function' === typeof x.then
             ) {
               pendingParts++;
               var lazyId$23 = nextPartId++;
@@ -274,7 +274,7 @@
                 }
               };
               x.then(parentReference, parentReference);
-              return "$" + lazyId$23.toString(16);
+              return '$' + lazyId$23.toString(16);
             }
             reject(x);
             return null;
@@ -282,7 +282,7 @@
             pendingParts--;
           }
       }
-      if ("function" === typeof value.then) {
+      if ('function' === typeof value.then) {
         null === formData && (formData = new FormData());
         pendingParts++;
         var promiseId = nextPartId++;
@@ -297,17 +297,17 @@
             reject(reason);
           }
         }, reject);
-        return "$@" + promiseId.toString(16);
+        return '$@' + promiseId.toString(16);
       }
       parentReference = writtenObjects.get(value);
       if (void 0 !== parentReference)
         if (modelRoot === value) modelRoot = null;
         else return parentReference;
       else
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
           ((parentReference = writtenObjects.get(this)),
           void 0 !== parentReference &&
-            ((key = parentReference + ":" + key),
+            ((key = parentReference + ':' + key),
             writtenObjects.set(value, key),
             void 0 !== temporaryReferences &&
               temporaryReferences.set(key, value)));
@@ -316,11 +316,11 @@
         null === formData && (formData = new FormData());
         var data$31 = formData;
         key = nextPartId++;
-        var prefix = formFieldPrefix + key + "_";
+        var prefix = formFieldPrefix + key + '_';
         value.forEach(function (originalValue, originalKey) {
           data$31.append(prefix + originalKey, originalValue);
         });
-        return "$K" + key.toString(16);
+        return '$K' + key.toString(16);
       }
       if (value instanceof Map)
         return (
@@ -328,7 +328,7 @@
           (parentReference = serializeModel(Array.from(value), key)),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + key, parentReference),
-          "$Q" + key.toString(16)
+          '$Q' + key.toString(16)
         );
       if (value instanceof Set)
         return (
@@ -336,7 +336,7 @@
           (parentReference = serializeModel(Array.from(value), key)),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + key, parentReference),
-          "$W" + key.toString(16)
+          '$W' + key.toString(16)
         );
       if (value instanceof ArrayBuffer)
         return (
@@ -344,29 +344,29 @@
           (parentReference = nextPartId++),
           null === formData && (formData = new FormData()),
           formData.append(formFieldPrefix + parentReference, key),
-          "$A" + parentReference.toString(16)
+          '$A' + parentReference.toString(16)
         );
-      if (value instanceof Int8Array) return serializeTypedArray("O", value);
-      if (value instanceof Uint8Array) return serializeTypedArray("o", value);
+      if (value instanceof Int8Array) return serializeTypedArray('O', value);
+      if (value instanceof Uint8Array) return serializeTypedArray('o', value);
       if (value instanceof Uint8ClampedArray)
-        return serializeTypedArray("U", value);
-      if (value instanceof Int16Array) return serializeTypedArray("S", value);
-      if (value instanceof Uint16Array) return serializeTypedArray("s", value);
-      if (value instanceof Int32Array) return serializeTypedArray("L", value);
-      if (value instanceof Uint32Array) return serializeTypedArray("l", value);
-      if (value instanceof Float32Array) return serializeTypedArray("G", value);
-      if (value instanceof Float64Array) return serializeTypedArray("g", value);
+        return serializeTypedArray('U', value);
+      if (value instanceof Int16Array) return serializeTypedArray('S', value);
+      if (value instanceof Uint16Array) return serializeTypedArray('s', value);
+      if (value instanceof Int32Array) return serializeTypedArray('L', value);
+      if (value instanceof Uint32Array) return serializeTypedArray('l', value);
+      if (value instanceof Float32Array) return serializeTypedArray('G', value);
+      if (value instanceof Float64Array) return serializeTypedArray('g', value);
       if (value instanceof BigInt64Array)
-        return serializeTypedArray("M", value);
+        return serializeTypedArray('M', value);
       if (value instanceof BigUint64Array)
-        return serializeTypedArray("m", value);
-      if (value instanceof DataView) return serializeTypedArray("V", value);
-      if ("function" === typeof Blob && value instanceof Blob)
+        return serializeTypedArray('m', value);
+      if (value instanceof DataView) return serializeTypedArray('V', value);
+      if ('function' === typeof Blob && value instanceof Blob)
         return (
           null === formData && (formData = new FormData()),
           (key = nextPartId++),
           formData.append(formFieldPrefix + key, value),
-          "$B" + key.toString(16)
+          '$B' + key.toString(16)
         );
       if ((key = getIteratorFn(value)))
         return (
@@ -375,20 +375,20 @@
             ? ((key = nextPartId++),
               (parentReference = serializeModel(
                 Array.from(parentReference),
-                key
+                key,
               )),
               null === formData && (formData = new FormData()),
               formData.append(formFieldPrefix + key, parentReference),
-              "$i" + key.toString(16))
+              '$i' + key.toString(16))
             : Array.from(parentReference)
         );
       if (
-        "function" === typeof ReadableStream &&
+        'function' === typeof ReadableStream &&
         value instanceof ReadableStream
       )
         return serializeReadableStream(value);
       key = value[ASYNC_ITERATOR];
-      if ("function" === typeof key)
+      if ('function' === typeof key)
         return serializeAsyncIterable(value, key.call(value));
       key = getPrototypeOf(value);
       if (
@@ -397,72 +397,72 @@
       ) {
         if (void 0 === temporaryReferences)
           throw Error(
-            "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported."
+            'Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.',
           );
-        return "$T";
+        return '$T';
       }
       return value;
     }
-    if ("string" === typeof value) {
-      if ("Z" === value[value.length - 1] && this[key] instanceof Date)
-        return "$D" + value;
-      key = "$" === value[0] ? "$" + value : value;
+    if ('string' === typeof value) {
+      if ('Z' === value[value.length - 1] && this[key] instanceof Date)
+        return '$D' + value;
+      key = '$' === value[0] ? '$' + value : value;
       return key;
     }
-    if ("boolean" === typeof value) return value;
-    if ("number" === typeof value) return serializeNumber(value);
-    if ("undefined" === typeof value) return "$undefined";
-    if ("function" === typeof value) {
+    if ('boolean' === typeof value) return value;
+    if ('number' === typeof value) return serializeNumber(value);
+    if ('undefined' === typeof value) return '$undefined';
+    if ('function' === typeof value) {
       parentReference = knownServerReferences.get(value);
       if (void 0 !== parentReference)
         return (
           (key = JSON.stringify(
             { id: parentReference.id, bound: parentReference.bound },
-            resolveToJSON
+            resolveToJSON,
           )),
           null === formData && (formData = new FormData()),
           (parentReference = nextPartId++),
           formData.set(formFieldPrefix + parentReference, key),
-          "$F" + parentReference.toString(16)
+          '$F' + parentReference.toString(16)
         );
       if (
         void 0 !== temporaryReferences &&
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
         ((parentReference = writtenObjects.get(this)),
         void 0 !== parentReference)
       )
         return (
-          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+          temporaryReferences.set(parentReference + ':' + key, value), '$T'
         );
       throw Error(
-        "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+        'Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.',
       );
     }
-    if ("symbol" === typeof value) {
+    if ('symbol' === typeof value) {
       if (
         void 0 !== temporaryReferences &&
-        -1 === key.indexOf(":") &&
+        -1 === key.indexOf(':') &&
         ((parentReference = writtenObjects.get(this)),
         void 0 !== parentReference)
       )
         return (
-          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+          temporaryReferences.set(parentReference + ':' + key, value), '$T'
         );
       throw Error(
-        "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+        'Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.',
       );
     }
-    if ("bigint" === typeof value) return "$n" + value.toString(10);
+    if ('bigint' === typeof value) return '$n' + value.toString(10);
     throw Error(
-      "Type " +
+      'Type ' +
         typeof value +
-        " is not supported as an argument to a Server Function."
+        ' is not supported as an argument to a Server Function.',
     );
   }
   function serializeModel(model, id) {
-    "object" === typeof model &&
+    'object' === typeof model &&
       null !== model &&
-      ((id = "$" + id.toString(16)),
+      ((id = '$' + id.toString(16)),
       writtenObjects.set(model, id),
       void 0 !== temporaryReferences && temporaryReferences.set(id, model));
     modelRoot = model;
@@ -476,7 +476,7 @@
     json = serializeModel(root, 0);
   null === formData
     ? resolve(json)
-    : (formData.set(formFieldPrefix + "0", json),
+    : (formData.set(formFieldPrefix + '0', json),
       0 === pendingParts && resolve(formData));
   return function () {
     0 < pendingParts &&
@@ -494,23 +494,23 @@
     });
   processReply(
     reference,
-    "",
+    '',
     void 0,
     function (body) {
-      if ("string" === typeof body) {
+      if ('string' === typeof body) {
         var data = new FormData();
-        data.append("0", body);
+        data.append('0', body);
         body = data;
       }
-      thenable.status = "fulfilled";
+      thenable.status = 'fulfilled';
       thenable.value = body;
       resolve(body);
     },
     function (e) {
-      thenable.status = "rejected";
+      thenable.status = 'rejected';
       thenable.reason = e;
       reject(e);
-    }
+    },
   );
   return thenable;
 }
@@ -518,7 +518,7 @@
   var referenceClosure = knownServerReferences.get(this);
   if (!referenceClosure)
     throw Error(
-      "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+      'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
     );
   var data = null;
   if (null !== referenceClosure.bound) {
@@ -526,55 +526,55 @@
     data ||
       ((data = encodeFormData({
         id: referenceClosure.id,
-        bound: referenceClosure.bound
+        bound: referenceClosure.bound,
       })),
       boundCache.set(referenceClosure, data));
-    if ("rejected" === data.status) throw data.reason;
-    if ("fulfilled" !== data.status) throw data;
+    if ('rejected' === data.status) throw data.reason;
+    if ('fulfilled' !== data.status) throw data;
     referenceClosure = data.value;
     var prefixedData = new FormData();
     referenceClosure.forEach(function (value, key) {
-      prefixedData.append("$ACTION_" + identifierPrefix + ":" + key, value);
+      prefixedData.append('$ACTION_' + identifierPrefix + ':' + key, value);
     });
     data = prefixedData;
-    referenceClosure = "$ACTION_REF_" + identifierPrefix;
-  } else referenceClosure = "$ACTION_ID_" + referenceClosure.id;
+    referenceClosure = '$ACTION_REF_' + identifierPrefix;
+  } else referenceClosure = '$ACTION_ID_' + referenceClosure.id;
   return {
     name: referenceClosure,
-    method: "POST",
-    encType: "multipart/form-data",
-    data: data
+    method: 'POST',
+    encType: 'multipart/form-data',
+    data: data,
   };
 }
 function isSignatureEqual(referenceId, numberOfBoundArgs) {
   var referenceClosure = knownServerReferences.get(this);
   if (!referenceClosure)
     throw Error(
-      "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+      'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
     );
   if (referenceClosure.id !== referenceId) return !1;
   var boundPromise = referenceClosure.bound;
   if (null === boundPromise) return 0 === numberOfBoundArgs;
   switch (boundPromise.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return boundPromise.value.length === numberOfBoundArgs;
-    case "pending":
+    case 'pending':
       throw boundPromise;
-    case "rejected":
+    case 'rejected':
       throw boundPromise.reason;
     default:
       throw (
-        ("string" !== typeof boundPromise.status &&
-          ((boundPromise.status = "pending"),
+        ('string' !== typeof boundPromise.status &&
+          ((boundPromise.status = 'pending'),
           boundPromise.then(
             function (boundArgs) {
-              boundPromise.status = "fulfilled";
+              boundPromise.status = 'fulfilled';
               boundPromise.value = boundArgs;
             },
             function (error) {
-              boundPromise.status = "rejected";
+              boundPromise.status = 'rejected';
               boundPromise.reason = error;
-            }
+            },
           )),
         boundPromise)
       );
@@ -585,7 +585,7 @@
     (knownServerReferences.set(reference, {
       id: id,
       originalBind: reference.bind,
-      bound: bound
+      bound: bound,
     }),
     Object.defineProperties(reference, {
       $$FORM_ACTION: {
@@ -596,15 +596,15 @@
                 var referenceClosure = knownServerReferences.get(this);
                 if (!referenceClosure)
                   throw Error(
-                    "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+                    'Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.',
                   );
                 var boundPromise = referenceClosure.bound;
                 null === boundPromise && (boundPromise = Promise.resolve([]));
                 return encodeFormAction(referenceClosure.id, boundPromise);
-              }
+              },
       },
       $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-      bind: { value: bind }
+      bind: { value: bind },
     }));
 }
 var FunctionBind = Function.prototype.bind,
@@ -624,12 +624,12 @@
   knownServerReferences.set(newFn, {
     id: referenceClosure.id,
     originalBind: newFn.bind,
-    bound: boundPromise
+    bound: boundPromise,
   });
   Object.defineProperties(newFn, {
     $$FORM_ACTION: { value: this.$$FORM_ACTION },
     $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
-    bind: { value: bind }
+    bind: { value: bind },
   });
   return newFn;
 }
@@ -637,7 +637,7 @@
   function action() {
     var args = Array.prototype.slice.call(arguments);
     return bound
-      ? "fulfilled" === bound.status
+      ? 'fulfilled' === bound.status
         ? callServer(id, bound.value.concat(args))
         : Promise.resolve(bound).then(function (boundArgs) {
             return callServer(id, boundArgs.concat(args));
@@ -665,43 +665,43 @@
 ReactPromise.prototype = Object.create(Promise.prototype);
 ReactPromise.prototype.then = function (resolve, reject) {
   switch (this.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(this);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(this);
   }
   switch (this.status) {
-    case "fulfilled":
-      "function" === typeof resolve && resolve(this.value);
+    case 'fulfilled':
+      'function' === typeof resolve && resolve(this.value);
       break;
-    case "pending":
-    case "blocked":
-      "function" === typeof resolve &&
+    case 'pending':
+    case 'blocked':
+      'function' === typeof resolve &&
         (null === this.value && (this.value = []), this.value.push(resolve));
-      "function" === typeof reject &&
+      'function' === typeof reject &&
         (null === this.reason && (this.reason = []), this.reason.push(reject));
       break;
-    case "halted":
+    case 'halted':
       break;
     default:
-      "function" === typeof reject && reject(this.reason);
+      'function' === typeof reject && reject(this.reason);
   }
 };
 function readChunk(chunk) {
   switch (chunk.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(chunk);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(chunk);
   }
   switch (chunk.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return chunk.value;
-    case "pending":
-    case "blocked":
-    case "halted":
+    case 'pending':
+    case 'blocked':
+    case 'halted':
       throw chunk;
     default:
       throw chunk.reason;
@@ -710,7 +710,7 @@
 function wakeChunk(listeners, value) {
   for (var i = 0; i < listeners.length; i++) {
     var listener = listeners[i];
-    "function" === typeof listener
+    'function' === typeof listener
       ? listener(value)
       : fulfillReference(listener, value);
   }
@@ -718,7 +718,7 @@
 function rejectChunk(listeners, error) {
   for (var i = 0; i < listeners.length; i++) {
     var listener = listeners[i];
-    "function" === typeof listener
+    'function' === typeof listener
       ? listener(error)
       : rejectReference(listener, error);
   }
@@ -736,7 +736,7 @@
     ) {
       var listener = reference[referencedChunk];
       if (
-        "function" !== typeof listener &&
+        'function' !== typeof listener &&
         ((listener = resolveBlockedCycle(resolvedChunk, listener)),
         null !== listener)
       )
@@ -746,13 +746,13 @@
 }
 function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
   switch (chunk.status) {
-    case "fulfilled":
+    case 'fulfilled':
       wakeChunk(resolveListeners, chunk.value);
       break;
-    case "blocked":
+    case 'blocked':
       for (var i = 0; i < resolveListeners.length; i++) {
         var listener = resolveListeners[i];
-        if ("function" !== typeof listener) {
+        if ('function' !== typeof listener) {
           var cyclicHandler = resolveBlockedCycle(chunk, listener);
           null !== cyclicHandler &&
             (fulfillReference(listener, cyclicHandler.value),
@@ -763,7 +763,7 @@
               -1 !== listener && rejectListeners.splice(listener, 1)));
         }
       }
-    case "pending":
+    case 'pending':
       if (chunk.value)
         for (i = 0; i < resolveListeners.length; i++)
           chunk.value.push(resolveListeners[i]);
@@ -778,38 +778,38 @@
             chunk.reason.push(rejectListeners[resolveListeners]);
       } else chunk.reason = rejectListeners;
       break;
-    case "rejected":
+    case 'rejected':
       rejectListeners && rejectChunk(rejectListeners, chunk.reason);
   }
 }
 function triggerErrorOnChunk(response, chunk, error) {
-  "pending" !== chunk.status && "blocked" !== chunk.status
+  'pending' !== chunk.status && 'blocked' !== chunk.status
     ? chunk.reason.error(error)
     : ((response = chunk.reason),
-      (chunk.status = "rejected"),
+      (chunk.status = 'rejected'),
       (chunk.reason = error),
       null !== response && rejectChunk(response, error));
 }
 function createResolvedIteratorResultChunk(response, value, done) {
   return new ReactPromise(
-    "resolved_model",
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
-    response
+    'resolved_model',
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
+    response,
   );
 }
 function resolveIteratorResultChunk(response, chunk, value, done) {
   resolveModelChunk(
     response,
     chunk,
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}"
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
   );
 }
 function resolveModelChunk(response, chunk, value) {
-  if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+  if ('pending' !== chunk.status) chunk.reason.enqueueModel(value);
   else {
     var resolveListeners = chunk.value,
       rejectListeners = chunk.reason;
-    chunk.status = "resolved_model";
+    chunk.status = 'resolved_model';
     chunk.value = value;
     chunk.reason = response;
     null !== resolveListeners &&
@@ -818,10 +818,10 @@
   }
 }
 function resolveModuleChunk(response, chunk, value) {
-  if ("pending" === chunk.status || "blocked" === chunk.status) {
+  if ('pending' === chunk.status || 'blocked' === chunk.status) {
     response = chunk.value;
     var rejectListeners = chunk.reason;
-    chunk.status = "resolved_module";
+    chunk.status = 'resolved_module';
     chunk.value = value;
     null !== response &&
       (initializeModuleChunk(chunk),
@@ -834,7 +834,7 @@
   initializingHandler = null;
   var resolvedModel = chunk.value,
     response = chunk.reason;
-  chunk.status = "blocked";
+  chunk.status = 'blocked';
   chunk.value = null;
   chunk.reason = null;
   try {
@@ -847,7 +847,7 @@
         resolvedModel++
       ) {
         var listener = resolveListeners[resolvedModel];
-        "function" === typeof listener
+        'function' === typeof listener
           ? listener(value)
           : fulfillReference(listener, value, chunk);
       }
@@ -859,10 +859,10 @@
         return;
       }
     }
-    chunk.status = "fulfilled";
+    chunk.status = 'fulfilled';
     chunk.value = value;
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   } finally {
     initializingHandler = prevHandler;
   }
@@ -870,17 +870,17 @@
 function initializeModuleChunk(chunk) {
   try {
     var value = requireModule(chunk.value);
-    chunk.status = "fulfilled";
+    chunk.status = 'fulfilled';
     chunk.value = value;
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   }
 }
 function reportGlobalError(weakResponse, error) {
   weakResponse._closed = !0;
   weakResponse._closedReason = error;
   weakResponse._chunks.forEach(function (chunk) {
-    "pending" === chunk.status &&
+    'pending' === chunk.status &&
       triggerErrorOnChunk(weakResponse, chunk, error);
   });
 }
@@ -892,8 +892,8 @@
     chunk = chunks.get(id);
   chunk ||
     ((chunk = response._closed
-      ? new ReactPromise("rejected", null, response._closedReason)
-      : new ReactPromise("pending", null, null)),
+      ? new ReactPromise('rejected', null, response._closedReason)
+      : new ReactPromise('pending', null, null)),
     chunks.set(id, chunk));
   return chunk;
 }
@@ -911,7 +911,7 @@
   ) {
     for (
       ;
-      "object" === typeof value &&
+      'object' === typeof value &&
       null !== value &&
       value.$$typeof === REACT_LAZY_TYPE;
 
@@ -920,23 +920,23 @@
         value = handler.value;
       else {
         switch (value.status) {
-          case "resolved_model":
+          case 'resolved_model':
             initializeModelChunk(value);
             break;
-          case "resolved_module":
+          case 'resolved_module':
             initializeModuleChunk(value);
         }
         switch (value.status) {
-          case "fulfilled":
+          case 'fulfilled':
             value = value.value;
             continue;
-          case "blocked":
+          case 'blocked':
             var cyclicHandler = resolveBlockedCycle(value, reference);
             if (null !== cyclicHandler) {
               value = cyclicHandler.value;
               continue;
             }
-          case "pending":
+          case 'pending':
             path.splice(0, i - 1);
             null === value.value
               ? (value.value = [reference])
@@ -945,7 +945,7 @@
               ? (value.reason = [reference])
               : value.reason.push(reference);
             return;
-          case "halted":
+          case 'halted':
             return;
           default:
             rejectReference(reference, value.reason);
@@ -956,7 +956,7 @@
   }
   for (
     ;
-    "object" === typeof value &&
+    'object' === typeof value &&
     null !== value &&
     value.$$typeof === REACT_LAZY_TYPE;
 
@@ -965,14 +965,14 @@
       value = handler.value;
     else {
       switch (reference.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(reference);
           break;
-        case "resolved_module":
+        case 'resolved_module':
           initializeModuleChunk(reference);
       }
       switch (reference.status) {
-        case "fulfilled":
+        case 'fulfilled':
           value = reference.value;
           continue;
       }
@@ -980,24 +980,24 @@
     }
   response = map(response, value, parentObject, key);
   parentObject[key] = response;
-  "" === key && null === handler.value && (handler.value = response);
+  '' === key && null === handler.value && (handler.value = response);
   if (
     parentObject[0] === REACT_ELEMENT_TYPE &&
-    "object" === typeof handler.value &&
+    'object' === typeof handler.value &&
     null !== handler.value &&
     handler.value.$$typeof === REACT_ELEMENT_TYPE
   )
     switch (((parentObject = handler.value), key)) {
-      case "3":
+      case '3':
         parentObject.props = response;
     }
   handler.deps--;
   0 === handler.deps &&
     ((key = handler.chunk),
     null !== key &&
-      "blocked" === key.status &&
+      'blocked' === key.status &&
       ((parentObject = key.value),
-      (key.status = "fulfilled"),
+      (key.status = 'fulfilled'),
       (key.value = handler.value),
       (key.reason = handler.reason),
       null !== parentObject && wakeChunk(parentObject, handler.value)));
@@ -1011,7 +1011,7 @@
     (handler.reason = error),
     (handler = handler.chunk),
     null !== handler &&
-      "blocked" === handler.status &&
+      'blocked' === handler.status &&
       triggerErrorOnChunk(reference, handler, error));
 }
 function waitForReference(
@@ -1020,7 +1020,7 @@
   key,
   response,
   map,
-  path
+  path,
 ) {
   if (initializingHandler) {
     var handler = initializingHandler;
@@ -1032,7 +1032,7 @@
       value: null,
       reason: null,
       deps: 1,
-      errored: !1
+      errored: !1,
     };
   parentObject = {
     response: response,
@@ -1040,7 +1040,7 @@
     parentObject: parentObject,
     key: key,
     map: map,
-    path: path
+    path: path,
   };
   null === referencedChunk.value
     ? (referencedChunk.value = [parentObject])
@@ -1055,11 +1055,11 @@
     return createBoundServerReference(
       metaData,
       response._callServer,
-      response._encodeFormAction
+      response._encodeFormAction,
     );
   var serverReference = resolveServerReference(
       response._serverReferenceConfig,
-      metaData.id
+      metaData.id,
     ),
     promise = preloadModule(serverReference);
   if (promise)
@@ -1072,7 +1072,7 @@
         promise,
         metaData.id,
         metaData.bound,
-        response._encodeFormAction
+        response._encodeFormAction,
       ),
       promise
     );
@@ -1086,7 +1086,7 @@
       value: null,
       reason: null,
       deps: 1,
-      errored: !1
+      errored: !1,
     };
   promise.then(
     function () {
@@ -1100,27 +1100,27 @@
         resolvedValue,
         metaData.id,
         metaData.bound,
-        response._encodeFormAction
+        response._encodeFormAction,
       );
       parentObject[key] = resolvedValue;
-      "" === key && null === handler.value && (handler.value = resolvedValue);
+      '' === key && null === handler.value && (handler.value = resolvedValue);
       if (
         parentObject[0] === REACT_ELEMENT_TYPE &&
-        "object" === typeof handler.value &&
+        'object' === typeof handler.value &&
         null !== handler.value &&
         handler.value.$$typeof === REACT_ELEMENT_TYPE
       )
         switch (((boundArgs = handler.value), key)) {
-          case "3":
+          case '3':
             boundArgs.props = resolvedValue;
         }
       handler.deps--;
       0 === handler.deps &&
         ((resolvedValue = handler.chunk),
         null !== resolvedValue &&
-          "blocked" === resolvedValue.status &&
+          'blocked' === resolvedValue.status &&
           ((boundArgs = resolvedValue.value),
-          (resolvedValue.status = "fulfilled"),
+          (resolvedValue.status = 'fulfilled'),
           (resolvedValue.value = handler.value),
           null !== boundArgs && wakeChunk(boundArgs, handler.value)));
     },
@@ -1131,58 +1131,58 @@
         handler.reason = error;
         var chunk = handler.chunk;
         null !== chunk &&
-          "blocked" === chunk.status &&
+          'blocked' === chunk.status &&
           triggerErrorOnChunk(response, chunk, error);
       }
-    }
+    },
   );
   return null;
 }
 function getOutlinedModel(response, reference, parentObject, key, map) {
-  reference = reference.split(":");
+  reference = reference.split(':');
   var id = parseInt(reference[0], 16);
   id = getChunk(response, id);
   switch (id.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(id);
       break;
-    case "resolved_module":
+    case 'resolved_module':
       initializeModuleChunk(id);
   }
   switch (id.status) {
-    case "fulfilled":
+    case 'fulfilled':
       id = id.value;
       for (var i = 1; i < reference.length; i++) {
         for (
           ;
-          "object" === typeof id &&
+          'object' === typeof id &&
           null !== id &&
           id.$$typeof === REACT_LAZY_TYPE;
 
         ) {
           id = id._payload;
           switch (id.status) {
-            case "resolved_model":
+            case 'resolved_model':
               initializeModelChunk(id);
               break;
-            case "resolved_module":
+            case 'resolved_module':
               initializeModuleChunk(id);
           }
           switch (id.status) {
-            case "fulfilled":
+            case 'fulfilled':
               id = id.value;
               break;
-            case "blocked":
-            case "pending":
+            case 'blocked':
+            case 'pending':
               return waitForReference(
                 id,
                 parentObject,
                 key,
                 response,
                 map,
-                reference.slice(i - 1)
+                reference.slice(i - 1),
               );
-            case "halted":
+            case 'halted':
               return (
                 initializingHandler
                   ? ((response = initializingHandler), response.deps++)
@@ -1192,7 +1192,7 @@
                       value: null,
                       reason: null,
                       deps: 1,
-                      errored: !1
+                      errored: !1,
                     }),
                 null
               );
@@ -1208,7 +1208,7 @@
                       value: null,
                       reason: id.reason,
                       deps: 0,
-                      errored: !0
+                      errored: !0,
                     }),
                 null
               );
@@ -1218,31 +1218,31 @@
       }
       for (
         ;
-        "object" === typeof id &&
+        'object' === typeof id &&
         null !== id &&
         id.$$typeof === REACT_LAZY_TYPE;
 
       ) {
         reference = id._payload;
         switch (reference.status) {
-          case "resolved_model":
+          case 'resolved_model':
             initializeModelChunk(reference);
             break;
-          case "resolved_module":
+          case 'resolved_module':
             initializeModuleChunk(reference);
         }
         switch (reference.status) {
-          case "fulfilled":
+          case 'fulfilled':
             id = reference.value;
             continue;
         }
         break;
       }
       return map(response, id, parentObject, key);
-    case "pending":
-    case "blocked":
+    case 'pending':
+    case 'blocked':
       return waitForReference(id, parentObject, key, response, map, reference);
-    case "halted":
+    case 'halted':
       return (
         initializingHandler
           ? ((response = initializingHandler), response.deps++)
@@ -1252,7 +1252,7 @@
               value: null,
               reason: null,
               deps: 1,
-              errored: !1
+              errored: !1,
             }),
         null
       );
@@ -1268,7 +1268,7 @@
               value: null,
               reason: id.reason,
               deps: 0,
-              errored: !0
+              errored: !0,
             }),
         null
       );
@@ -1296,38 +1296,38 @@
   return model;
 }
 function parseModelString(response, parentObject, key, value) {
-  if ("$" === value[0]) {
-    if ("$" === value)
+  if ('$' === value[0]) {
+    if ('$' === value)
       return (
         null !== initializingHandler &&
-          "0" === key &&
+          '0' === key &&
           (initializingHandler = {
             parent: initializingHandler,
             chunk: null,
             value: null,
             reason: null,
             deps: 0,
-            errored: !1
+            errored: !1,
           }),
         REACT_ELEMENT_TYPE
       );
     switch (value[1]) {
-      case "$":
+      case '$':
         return value.slice(1);
-      case "L":
+      case 'L':
         return (
           (parentObject = parseInt(value.slice(2), 16)),
           (response = getChunk(response, parentObject)),
           createLazyChunkWrapper(response)
         );
-      case "@":
+      case '@':
         return (
           (parentObject = parseInt(value.slice(2), 16)),
           getChunk(response, parentObject)
         );
-      case "S":
+      case 'S':
         return Symbol.for(value.slice(2));
-      case "F":
+      case 'F':
         return (
           (value = value.slice(2)),
           getOutlinedModel(
@@ -1335,55 +1335,55 @@
             value,
             parentObject,
             key,
-            loadServerReference
+            loadServerReference,
           )
         );
-      case "T":
-        parentObject = "$" + value.slice(2);
+      case 'T':
+        parentObject = '$' + value.slice(2);
         response = response._tempRefs;
         if (null == response)
           throw Error(
-            "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+            'Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.',
           );
         return response.get(parentObject);
-      case "Q":
+      case 'Q':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createMap)
         );
-      case "W":
+      case 'W':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createSet)
         );
-      case "B":
+      case 'B':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createBlob)
         );
-      case "K":
+      case 'K':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, createFormData)
         );
-      case "Z":
+      case 'Z':
         return resolveErrorProd();
-      case "i":
+      case 'i':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, parentObject, key, extractIterator)
         );
-      case "I":
+      case 'I':
         return Infinity;
-      case "-":
-        return "$-0" === value ? -0 : -Infinity;
-      case "N":
+      case '-':
+        return '$-0' === value ? -0 : -Infinity;
+      case 'N':
         return NaN;
-      case "u":
+      case 'u':
         return;
-      case "D":
+      case 'D':
         return new Date(Date.parse(value.slice(2)));
-      case "n":
+      case 'n':
         return BigInt(value.slice(2));
       default:
         return (
@@ -1396,7 +1396,7 @@
 }
 function missingCall() {
   throw Error(
-    'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+    'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.',
   );
 }
 function ResponseInstance(
@@ -1406,7 +1406,7 @@
   callServer,
   encodeFormAction,
   nonce,
-  temporaryReferences
+  temporaryReferences,
 ) {
   var chunks = new Map();
   this._bundlerConfig = bundlerConfig;
@@ -1429,9 +1429,9 @@
 function resolveBuffer(response, id, buffer) {
   response = response._chunks;
   var chunk = response.get(id);
-  chunk && "pending" !== chunk.status
+  chunk && 'pending' !== chunk.status
     ? chunk.reason.enqueueValue(buffer)
-    : ((buffer = new ReactPromise("fulfilled", buffer, null)),
+    : ((buffer = new ReactPromise('fulfilled', buffer, null)),
       response.set(id, buffer));
 }
 function resolveModule(response, id, model) {
@@ -1442,14 +1442,14 @@
   prepareDestinationWithChunks(
     response._moduleLoading,
     model[1],
-    response._nonce
+    response._nonce,
   );
   if ((model = preloadModule(clientReference))) {
     if (chunk) {
       var blockedChunk = chunk;
-      blockedChunk.status = "blocked";
+      blockedChunk.status = 'blocked';
     } else
-      (blockedChunk = new ReactPromise("blocked", null, null)),
+      (blockedChunk = new ReactPromise('blocked', null, null)),
         chunks.set(id, blockedChunk);
     model.then(
       function () {
@@ -1457,25 +1457,25 @@
       },
       function (error) {
         return triggerErrorOnChunk(response, blockedChunk, error);
-      }
+      },
     );
   } else
     chunk
       ? resolveModuleChunk(response, chunk, clientReference)
-      : ((chunk = new ReactPromise("resolved_module", clientReference, null)),
+      : ((chunk = new ReactPromise('resolved_module', clientReference, null)),
         chunks.set(id, chunk));
 }
 function resolveStream(response, id, stream, controller) {
   response = response._chunks;
   var chunk = response.get(id);
   chunk
-    ? "pending" === chunk.status &&
+    ? 'pending' === chunk.status &&
       ((id = chunk.value),
-      (chunk.status = "fulfilled"),
+      (chunk.status = 'fulfilled'),
       (chunk.value = stream),
       (chunk.reason = controller),
       null !== id && wakeChunk(id, chunk.value))
-    : ((stream = new ReactPromise("fulfilled", stream, controller)),
+    : ((stream = new ReactPromise('fulfilled', stream, controller)),
       response.set(id, stream));
 }
 function startReadableStream(response, id, type) {
@@ -1484,7 +1484,7 @@
     type: type,
     start: function (c) {
       controller = c;
-    }
+    },
   });
   var previousBlockedChunk = null;
   resolveStream(response, id, type, {
@@ -1497,9 +1497,9 @@
     },
     enqueueModel: function (json) {
       if (null === previousBlockedChunk) {
-        var chunk = new ReactPromise("resolved_model", json, response);
+        var chunk = new ReactPromise('resolved_model', json, response);
         initializeModelChunk(chunk);
-        "fulfilled" === chunk.status
+        'fulfilled' === chunk.status
           ? controller.enqueue(chunk.value)
           : (chunk.then(
               function (v) {
@@ -1507,19 +1507,19 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             ),
             (previousBlockedChunk = chunk));
       } else {
         chunk = previousBlockedChunk;
-        var chunk$54 = new ReactPromise("pending", null, null);
+        var chunk$54 = new ReactPromise('pending', null, null);
         chunk$54.then(
           function (v) {
             return controller.enqueue(v);
           },
           function (e) {
             return controller.error(e);
-          }
+          },
         );
         previousBlockedChunk = chunk$54;
         chunk.then(function () {
@@ -1547,7 +1547,7 @@
           return controller.error(error);
         });
       }
-    }
+    },
   });
 }
 function asyncIterator() {
@@ -1568,16 +1568,16 @@
     return createIterator(function (arg) {
       if (void 0 !== arg)
         throw Error(
-          "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+          'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
         );
       if (nextReadIndex === buffer.length) {
         if (closed)
           return new ReactPromise(
-            "fulfilled",
+            'fulfilled',
             { done: !0, value: void 0 },
-            null
+            null,
           );
-        buffer[nextReadIndex] = new ReactPromise("pending", null, null);
+        buffer[nextReadIndex] = new ReactPromise('pending', null, null);
       }
       return buffer[nextReadIndex++];
     });
@@ -1590,15 +1590,15 @@
       enqueueValue: function (value) {
         if (nextWriteIndex === buffer.length)
           buffer[nextWriteIndex] = new ReactPromise(
-            "fulfilled",
+            'fulfilled',
             { done: !1, value: value },
-            null
+            null,
           );
         else {
           var chunk = buffer[nextWriteIndex],
             resolveListeners = chunk.value,
             rejectListeners = chunk.reason;
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = { done: !1, value: value };
           null !== resolveListeners &&
             wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
@@ -1610,13 +1610,13 @@
           ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
               response,
               value,
-              !1
+              !1,
             ))
           : resolveIteratorResultChunk(
               response,
               buffer[nextWriteIndex],
               value,
-              !1
+              !1,
             );
         nextWriteIndex++;
       },
@@ -1626,40 +1626,40 @@
           ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
               response,
               value,
-              !0
+              !0,
             ))
           : resolveIteratorResultChunk(
               response,
               buffer[nextWriteIndex],
               value,
-              !0
+              !0,
             );
         for (nextWriteIndex++; nextWriteIndex < buffer.length; )
           resolveIteratorResultChunk(
             response,
             buffer[nextWriteIndex++],
             '"$undefined"',
-            !0
+            !0,
           );
       },
       error: function (error) {
         closed = !0;
         for (
           nextWriteIndex === buffer.length &&
-          (buffer[nextWriteIndex] = new ReactPromise("pending", null, null));
+          (buffer[nextWriteIndex] = new ReactPromise('pending', null, null));
           nextWriteIndex < buffer.length;
 
         )
           triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);
-      }
-    }
+      },
+    },
   );
 }
 function resolveErrorProd() {
   var error = Error(
-    "An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error."
+    'An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.',
   );
-  error.stack = "Error: " + error.message;
+  error.stack = 'Error: ' + error.message;
   return error;
 }
 function mergeBuffer(buffer, lastChunk) {
@@ -1680,7 +1680,7 @@
   buffer,
   lastChunk,
   constructor,
-  bytesPerElement
+  bytesPerElement,
 ) {
   buffer =
     0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
@@ -1689,7 +1689,7 @@
   constructor = new constructor(
     buffer.buffer,
     buffer.byteOffset,
-    buffer.byteLength / bytesPerElement
+    buffer.byteLength / bytesPerElement,
   );
   resolveBuffer(response, id, constructor);
 }
@@ -1705,7 +1705,7 @@
       resolveBuffer(
         response,
         id,
-        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)
+        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk),
       );
       return;
     case 85:
@@ -1740,7 +1740,7 @@
       return;
   }
   for (
-    var stringDecoder = response._stringDecoder, row = "", i = 0;
+    var stringDecoder = response._stringDecoder, row = '', i = 0;
     i < buffer.length;
     i++
   )
@@ -1759,42 +1759,42 @@
       response = JSON.parse(row, response._fromJSON);
       row = ReactDOMSharedInternals.d;
       switch (id) {
-        case "D":
+        case 'D':
           row.D(response);
           break;
-        case "C":
-          "string" === typeof response
+        case 'C':
+          'string' === typeof response
             ? row.C(response)
             : row.C(response[0], response[1]);
           break;
-        case "L":
+        case 'L':
           id = response[0];
           streamState = response[1];
           3 === response.length
             ? row.L(id, streamState, response[2])
             : row.L(id, streamState);
           break;
-        case "m":
-          "string" === typeof response
+        case 'm':
+          'string' === typeof response
             ? row.m(response)
             : row.m(response[0], response[1]);
           break;
-        case "X":
-          "string" === typeof response
+        case 'X':
+          'string' === typeof response
             ? row.X(response)
             : row.X(response[0], response[1]);
           break;
-        case "S":
-          "string" === typeof response
+        case 'S':
+          'string' === typeof response
             ? row.S(response)
             : row.S(
                 response[0],
                 0 === response[1] ? void 0 : response[1],
-                3 === response.length ? response[2] : void 0
+                3 === response.length ? response[2] : void 0,
               );
           break;
-        case "M":
-          "string" === typeof response
+        case 'M':
+          'string' === typeof response
             ? row.M(response)
             : row.M(response[0], response[1]);
       }
@@ -1807,14 +1807,14 @@
       error.digest = row.digest;
       tag
         ? triggerErrorOnChunk(response, tag, error)
-        : ((response = new ReactPromise("rejected", null, error)),
+        : ((response = new ReactPromise('rejected', null, error)),
           streamState.set(id, response));
       break;
     case 84:
       response = response._chunks;
-      (streamState = response.get(id)) && "pending" !== streamState.status
+      (streamState = response.get(id)) && 'pending' !== streamState.status
         ? streamState.reason.enqueueValue(row)
-        : ((row = new ReactPromise("fulfilled", row, null)),
+        : ((row = new ReactPromise('fulfilled', row, null)),
           response.set(id, row));
       break;
     case 78:
@@ -1822,13 +1822,13 @@
     case 74:
     case 87:
       throw Error(
-        "Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client."
+        'Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client.',
       );
     case 82:
       startReadableStream(response, id, void 0);
       break;
     case 114:
-      startReadableStream(response, id, "bytes");
+      startReadableStream(response, id, 'bytes');
       break;
     case 88:
       startAsyncIterable(response, id, !1);
@@ -1838,14 +1838,14 @@
       break;
     case 67:
       (id = response._chunks.get(id)) &&
-        "fulfilled" === id.status &&
-        id.reason.close("" === row ? '"$undefined"' : row);
+        'fulfilled' === id.status &&
+        id.reason.close('' === row ? '"$undefined"' : row);
       break;
     default:
       (streamState = response._chunks),
         (tag = streamState.get(id))
           ? resolveModelChunk(response, tag, row)
-          : ((response = new ReactPromise("resolved_model", row, response)),
+          : ((response = new ReactPromise('resolved_model', row, response)),
             streamState.set(id, response));
   }
 }
@@ -1916,7 +1916,7 @@
           rowID,
           rowTag,
           buffer,
-          rowLength
+          rowLength,
         ),
         (i = lastIdx),
         3 === rowState && i++,
@@ -1936,9 +1936,9 @@
 }
 function createFromJSONCallback(response) {
   return function (key, value) {
-    if ("string" === typeof value)
+    if ('string' === typeof value)
       return parseModelString(response, this, key, value);
-    if ("object" === typeof value && null !== value) {
+    if ('object' === typeof value && null !== value) {
       if (value[0] === REACT_ELEMENT_TYPE) {
         if (
           ((key = {
@@ -1946,7 +1946,7 @@
             type: value[1],
             key: value[2],
             ref: null,
-            props: value[3]
+            props: value[3],
           }),
           null !== initializingHandler)
         )
@@ -1955,10 +1955,10 @@
             (initializingHandler = value.parent),
             value.errored)
           )
-            (key = new ReactPromise("rejected", null, value.reason)),
+            (key = new ReactPromise('rejected', null, value.reason)),
               (key = createLazyChunkWrapper(key));
           else if (0 < value.deps) {
-            var blockedChunk = new ReactPromise("blocked", null, null);
+            var blockedChunk = new ReactPromise('blocked', null, null);
             value.value = key;
             value.chunk = blockedChunk;
             key = createLazyChunkWrapper(blockedChunk);
@@ -1970,11 +1970,11 @@
   };
 }
 function close(weakResponse) {
-  reportGlobalError(weakResponse, Error("Connection closed."));
+  reportGlobalError(weakResponse, Error('Connection closed.'));
 }
 function noServerCall$1() {
   throw Error(
-    "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+    'Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.',
   );
 }
 function createResponseFromOptions(options) {
@@ -1984,10 +1984,10 @@
     options.serverConsumerManifest.moduleLoading,
     noServerCall$1,
     options.encodeFormAction,
-    "string" === typeof options.nonce ? options.nonce : void 0,
+    'string' === typeof options.nonce ? options.nonce : void 0,
     options && options.temporaryReferences
       ? options.temporaryReferences
-      : void 0
+      : void 0,
   );
 }
 function startReadingFromStream$1(response, stream, onDone) {
@@ -2006,13 +2006,13 @@
 }
 function noServerCall() {
   throw Error(
-    "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+    'Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.',
   );
 }
 function startReadingFromStream(response, stream, onEnd) {
   var streamState = createStreamState();
-  stream.on("data", function (chunk) {
-    if ("string" === typeof chunk) {
+  stream.on('data', function (chunk) {
+    if ('string' === typeof chunk) {
       for (
         var i = 0,
           rowState = streamState._rowState,
@@ -2065,23 +2065,23 @@
                   (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
             continue;
           case 3:
-            lastIdx = chunk.indexOf("\n", i);
+            lastIdx = chunk.indexOf('\n', i);
             break;
           case 4:
             if (84 !== rowTag)
               throw Error(
-                "Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams."
+                'Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams.',
               );
             if (rowLength < chunk.length || chunk.length > 3 * rowLength)
               throw Error(
-                "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+                'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
               );
             lastIdx = chunk.length;
         }
         if (-1 < lastIdx) {
           if (0 < buffer.length)
             throw Error(
-              "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+              'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
             );
           i = chunk.slice(i, lastIdx);
           processFullStringRow(response, streamState, rowID, rowTag, i);
@@ -2091,7 +2091,7 @@
           buffer.length = 0;
         } else if (chunk.length !== i)
           throw Error(
-            "String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams."
+            'String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.',
           );
       }
       streamState._rowState = rowState;
@@ -2100,10 +2100,10 @@
       streamState._rowLength = rowLength;
     } else processBinaryChunk(response, streamState, chunk);
   });
-  stream.on("error", function (error) {
+  stream.on('error', function (error) {
     reportGlobalError(response, error);
   });
-  stream.on("end", onEnd);
+  stream.on('end', onEnd);
 }
 exports.createFromFetch = function (promiseForResponse, options) {
   var response = createResponseFromOptions(options);
@@ -2113,14 +2113,14 @@
     },
     function (e) {
       reportGlobalError(response, e);
-    }
+    },
   );
   return getChunk(response, 0);
 };
 exports.createFromNodeStream = function (
   stream,
   serverConsumerManifest,
-  options
+  options,
 ) {
   serverConsumerManifest = new ResponseInstance(
     serverConsumerManifest.moduleMap,
@@ -2128,13 +2128,13 @@
     serverConsumerManifest.moduleLoading,
     noServerCall,
     options ? options.encodeFormAction : void 0,
-    options && "string" === typeof options.nonce ? options.nonce : void 0,
-    void 0
+    options && 'string' === typeof options.nonce ? options.nonce : void 0,
+    void 0,
   );
   startReadingFromStream(
     serverConsumerManifest,
     stream,
-    close.bind(null, serverConsumerManifest)
+    close.bind(null, serverConsumerManifest),
   );
   return getChunk(serverConsumerManifest, 0);
 };
@@ -2153,12 +2153,12 @@
   return new Promise(function (resolve, reject) {
     var abort = processReply(
       value,
-      "",
+      '',
       options && options.temporaryReferences
         ? options.temporaryReferences
         : void 0,
       resolve,
-      reject
+      reject,
     );
     if (options && options.signal) {
       var signal = options.signal;
@@ -2166,9 +2166,9 @@
       else {
         var listener = function () {
           abort(signal.reason);
-          signal.removeEventListener("abort", listener);
+          signal.removeEventListener('abort', listener);
         };
-        signal.addEventListener("abort", listener);
+        signal.addEventListener('abort', listener);
       }
     }
   });
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-node-register.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-node-register.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-node-register.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-node-register.js	2025-12-17 14:32:44
@@ -8,62 +8,212 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-const acorn = require("acorn-loose"),
-  url = require("url"),
-  Module = require("module");
+'use strict';
+const acorn = require('acorn-loose'),
+  url = require('url'),
+  Module = require('module');
+
+/**
+ * Check if a function body starts with 'use server' directive
+ */
+function hasUseServerDirective(body) {
+  if (
+    !body ||
+    body.type !== 'BlockStatement' ||
+    !body.body ||
+    body.body.length === 0
+  ) {
+    return false;
+  }
+  const firstStmt = body.body[0];
+  return (
+    firstStmt.type === 'ExpressionStatement' &&
+    firstStmt.expression &&
+    firstStmt.expression.type === 'Literal' &&
+    firstStmt.expression.value === 'use server'
+  );
+}
+
+/**
+ * Find all inline server action functions in the source AST
+ * Returns array of { name, start, end } for each action
+ */
+function findInlineServerActions(content) {
+  const actions = [];
+  let ast;
+
+  try {
+    ast = acorn.parse(content, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+  } catch (x) {
+    return actions;
+  }
+
+  function visit(node) {
+    if (!node || typeof node !== 'object') return;
+
+    // Check function declarations with 'use server' in body
+    if (
+      node.type === 'FunctionDeclaration' &&
+      node.id &&
+      hasUseServerDirective(node.body)
+    ) {
+      actions.push({
+        name: node.id.name,
+        start: node.start,
+        end: node.end,
+        bodyStart: node.body.start,
+      });
+    }
+
+    // Check variable declarations with function expressions
+    if (node.type === 'VariableDeclaration') {
+      for (const decl of node.declarations) {
+        if (decl.init && decl.id && decl.id.type === 'Identifier') {
+          const init = decl.init;
+          if (
+            (init.type === 'FunctionExpression' ||
+              init.type === 'ArrowFunctionExpression') &&
+            hasUseServerDirective(init.body)
+          ) {
+            actions.push({
+              name: decl.id.name,
+              start: node.start,
+              end: node.end,
+              bodyStart: init.body.start,
+            });
+          }
+        }
+      }
+    }
+
+    // Recurse into child nodes
+    for (const key in node) {
+      if (key === 'parent') continue;
+      const child = node[key];
+      if (Array.isArray(child)) {
+        for (const c of child) {
+          visit(c);
+        }
+      } else if (child && typeof child === 'object' && child.type) {
+        visit(child);
+      }
+    }
+  }
+
+  visit(ast);
+  return actions;
+}
+
+/**
+ * Transform source code to register inline server actions
+ * Adds registerServerReference calls after each inline action definition
+ */
+function transformInlineServerActions(content, filename, inlineActions) {
+  const moduleUrl = url.pathToFileURL(filename).href;
+
+  // Sort by position descending so we can insert from end to beginning
+  // without messing up positions
+  const sorted = [...inlineActions].sort((a, b) => b.end - a.end);
+
+  let result = content;
+
+  for (const action of sorted) {
+    // Insert registration after the function definition
+    const registration = `\n;(function(){if(typeof ${action.name}==='function'){require('react-server-dom-webpack/server').registerServerReference(${action.name},'${moduleUrl}','${action.name}');}})();`;
+
+    result =
+      result.slice(0, action.end) + registration + result.slice(action.end);
+  }
+
+  return result;
+}
+
 module.exports = function () {
-  const Server = require("react-server-dom-webpack/server"),
+  const Server = require('react-server-dom-webpack/server'),
     registerServerReference = Server.registerServerReference,
     createClientModuleProxy = Server.createClientModuleProxy,
     originalCompile = Module.prototype._compile;
+
   Module.prototype._compile = function (content, filename) {
+    // Quick check for any potential directives
     if (
-      -1 === content.indexOf("use client") &&
-      -1 === content.indexOf("use server")
+      -1 === content.indexOf('use client') &&
+      -1 === content.indexOf('use server')
     )
       return originalCompile.apply(this, arguments);
+
+    let body;
     try {
-      var body = acorn.parse(content, {
-        ecmaVersion: "2024",
-        sourceType: "source"
+      body = acorn.parse(content, {
+        ecmaVersion: '2024',
+        sourceType: 'module',
       }).body;
     } catch (x) {
-      return (
-        console.error("Error parsing %s %s", url, x.message),
-        originalCompile.apply(this, arguments)
-      );
+      console.error('Error parsing %s %s', filename, x.message);
+      return originalCompile.apply(this, arguments);
     }
-    var useClient = !1,
-      useServer = !1;
-    for (var i = 0; i < body.length; i++) {
-      var node = body[i];
-      if ("ExpressionStatement" !== node.type || !node.directive) break;
-      "use client" === node.directive && (useClient = !0);
-      "use server" === node.directive && (useServer = !0);
+
+    // Check for file-level directives
+    let useClient = false,
+      useServer = false;
+    for (let i = 0; i < body.length; i++) {
+      const node = body[i];
+      if ('ExpressionStatement' !== node.type || !node.directive) break;
+      if ('use client' === node.directive) useClient = true;
+      if ('use server' === node.directive) useServer = true;
     }
-    if (!useClient && !useServer) return originalCompile.apply(this, arguments);
-    if (useClient && useServer)
+
+    if (useClient && useServer) {
       throw Error(
-        'Cannot have both "use client" and "use server" directives in the same file.'
+        'Cannot have both "use client" and "use server" directives in the same file.',
       );
-    useClient &&
-      ((body = url.pathToFileURL(filename).href),
-      (this.exports = createClientModuleProxy(body)));
-    if (useServer)
-      if (
-        (originalCompile.apply(this, arguments),
-        (useServer = url.pathToFileURL(filename).href),
-        (body = this.exports),
-        "function" === typeof body)
-      )
-        registerServerReference(body, useServer, null);
-      else
-        for (useClient = Object.keys(body), i = 0; i < useClient.length; i++) {
-          node = useClient[i];
-          const value = body[useClient[i]];
-          "function" === typeof value &&
-            registerServerReference(value, useServer, node);
+    }
+
+    // Handle 'use client' modules
+    if (useClient) {
+      const moduleUrl = url.pathToFileURL(filename).href;
+      this.exports = createClientModuleProxy(moduleUrl);
+      return;
+    }
+
+    // Handle file-level 'use server' modules
+    if (useServer) {
+      originalCompile.apply(this, arguments);
+      const moduleUrl = url.pathToFileURL(filename).href;
+      const exports = this.exports;
+
+      if ('function' === typeof exports) {
+        registerServerReference(exports, moduleUrl, 'default');
+      } else {
+        for (const key of Object.keys(exports)) {
+          const value = exports[key];
+          if ('function' === typeof value) {
+            registerServerReference(value, moduleUrl, key);
+          }
         }
+      }
+      return;
+    }
+
+    // Check for inline 'use server' functions in this file
+    const inlineActions = findInlineServerActions(content);
+
+    if (inlineActions.length > 0) {
+      // Transform the source to add registration calls
+      const transformedContent = transformInlineServerActions(
+        content,
+        filename,
+        inlineActions,
+      );
+
+      // Compile the transformed source
+      return originalCompile.call(this, transformedContent, filename);
+    }
+
+    // No directives - pass through unchanged
+    return originalCompile.apply(this, arguments);
   };
 };
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-plugin.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-plugin.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-plugin.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-plugin.js	2025-12-17 14:32:44
@@ -8,22 +8,24 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-var path = require("path"),
-  url = require("url"),
-  asyncLib = require("neo-async"),
-  acorn = require("acorn-loose"),
-  ModuleDependency = require("webpack/lib/dependencies/ModuleDependency"),
-  NullDependency = require("webpack/lib/dependencies/NullDependency"),
-  Template = require("webpack/lib/Template"),
-  webpack = require("webpack");
+'use strict';
+var path = require('path'),
+  url = require('url'),
+  asyncLib = require('neo-async'),
+  acorn = require('acorn-loose'),
+  ModuleDependency = require('webpack/lib/dependencies/ModuleDependency'),
+  NullDependency = require('webpack/lib/dependencies/NullDependency'),
+  Template = require('webpack/lib/Template'),
+  webpack = require('webpack'),
+  fs = require('fs');
+
 function _unsupportedIterableToArray(o, minLen) {
   if (o) {
-    if ("string" === typeof o) return _arrayLikeToArray(o, minLen);
+    if ('string' === typeof o) return _arrayLikeToArray(o, minLen);
     var n = Object.prototype.toString.call(o).slice(8, -1);
-    "Object" === n && o.constructor && (n = o.constructor.name);
-    if ("Map" === n || "Set" === n) return Array.from(o);
-    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    'Object' === n && o.constructor && (n = o.constructor.name);
+    if ('Map' === n || 'Set' === n) return Array.from(o);
+    if ('Arguments' === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
       return _arrayLikeToArray(o, minLen);
   }
 }
@@ -34,12 +36,12 @@
 }
 function _createForOfIteratorHelper(o, allowArrayLike) {
   var it =
-    ("undefined" !== typeof Symbol && o[Symbol.iterator]) || o["@@iterator"];
+    ('undefined' !== typeof Symbol && o[Symbol.iterator]) || o['@@iterator'];
   if (!it) {
     if (
       Array.isArray(o) ||
       (it = _unsupportedIterableToArray(o)) ||
-      (allowArrayLike && o && "number" === typeof o.length)
+      (allowArrayLike && o && 'number' === typeof o.length)
     ) {
       it && (o = it);
       var i = 0;
@@ -52,11 +54,11 @@
         e: function (e) {
           throw e;
         },
-        f: allowArrayLike
+        f: allowArrayLike,
       };
     }
     throw new TypeError(
-      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+      'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
     );
   }
   var normalCompletion = !0,
@@ -81,59 +83,344 @@
       } finally {
         if (didErr) throw err;
       }
-    }
+    },
   };
 }
+
 const isArrayImpl = Array.isArray;
+
 class ClientReferenceDependency extends ModuleDependency {
   constructor(request) {
     super(request);
   }
   get type() {
-    return "client-reference";
+    return 'client-reference';
   }
 }
-const clientFileName = require.resolve("../client.browser.js");
+
+class ServerReferenceDependency extends ModuleDependency {
+  constructor(request) {
+    super(request);
+  }
+  get type() {
+    return 'server-reference';
+  }
+}
+
+const clientFileName = require.resolve('../client.browser.js');
+
+function hasDirective(source, directive) {
+  if (-1 === source.indexOf(directive)) return false;
+  let body;
+  try {
+    body = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    }).body;
+  } catch (x) {
+    return false;
+  }
+  for (let i = 0; i < body.length; i++) {
+    const node = body[i];
+    if ('ExpressionStatement' !== node.type || !node.directive) break;
+    if (directive === node.directive) return true;
+  }
+  return false;
+}
+
+function getExports(source) {
+  const exports = [];
+  let body;
+  try {
+    body = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    }).body;
+  } catch (x) {
+    return exports;
+  }
+  for (const node of body) {
+    if (node.type === 'ExportNamedDeclaration' && node.declaration) {
+      if (
+        node.declaration.type === 'FunctionDeclaration' &&
+        node.declaration.id
+      ) {
+        exports.push(node.declaration.id.name);
+      }
+      if (node.declaration.type === 'VariableDeclaration') {
+        for (const decl of node.declaration.declarations) {
+          if (decl.id && decl.id.type === 'Identifier') {
+            exports.push(decl.id.name);
+          }
+        }
+      }
+    }
+    if (node.type === 'ExportDefaultDeclaration') {
+      exports.push('default');
+    }
+  }
+  return exports;
+}
+
 class ReactFlightWebpackPlugin {
   constructor(options) {
     this.serverConsumerManifestFilename =
       this.clientManifestFilename =
+      this.serverActionsManifestFilename =
       this.chunkName =
       this.clientReferences =
+      this.serverReferences =
         void 0;
-    if (!options || "boolean" !== typeof options.isServer)
+
+    if (!options || 'boolean' !== typeof options.isServer)
       throw Error(
-        "React Server Plugin: You must specify the isServer option as a boolean."
+        'ReactFlightPlugin: You must specify the isServer option as a boolean.',
       );
-    if (options.isServer) throw Error("TODO: Implement the server compiler.");
+
+    this.isServer = options.isServer;
+
+    // Client references config (for client compiler)
     options.clientReferences
-      ? "string" !== typeof options.clientReferences &&
+      ? 'string' !== typeof options.clientReferences &&
         isArrayImpl(options.clientReferences)
         ? (this.clientReferences = options.clientReferences)
         : (this.clientReferences = [options.clientReferences])
       : (this.clientReferences = [
-          { directory: ".", recursive: !0, include: /\.(js|ts|jsx|tsx)$/ }
+          { directory: '.', recursive: !0, include: /\.(js|ts|jsx|tsx)$/ },
         ]);
-    "string" === typeof options.chunkName
+
+    // Server references config (for server compiler)
+    options.serverReferences
+      ? 'string' !== typeof options.serverReferences &&
+        isArrayImpl(options.serverReferences)
+        ? (this.serverReferences = options.serverReferences)
+        : (this.serverReferences = [options.serverReferences])
+      : (this.serverReferences = [
+          { directory: '.', recursive: !0, include: /\.(js|ts|jsx|tsx)$/ },
+        ]);
+
+    'string' === typeof options.chunkName
       ? ((this.chunkName = options.chunkName),
         /\[(index|request)\]/.test(this.chunkName) ||
-          (this.chunkName += "[index]"))
-      : (this.chunkName = "client[index]");
+          (this.chunkName += '[index]'))
+      : (this.chunkName = 'client[index]');
+
     this.clientManifestFilename =
-      options.clientManifestFilename || "react-client-manifest.json";
+      options.clientManifestFilename || 'react-client-manifest.json';
     this.serverConsumerManifestFilename =
-      options.serverConsumerManifestFilename || "react-ssr-manifest.json";
+      options.serverConsumerManifestFilename || 'react-ssr-manifest.json';
+    this.serverActionsManifestFilename =
+      options.serverActionsManifestFilename ||
+      'react-server-actions-manifest.json';
+    this.extraServerActionsManifests =
+      options.extraServerActionsManifests || [];
+    this.discoveredClientRefs = options.discoveredClientRefs || [];
   }
+
   apply(compiler) {
+    if (this.isServer) {
+      this.applyServer(compiler);
+    } else {
+      this.applyClient(compiler);
+    }
+  }
+
+  applyServer(compiler) {
     const _this = this;
+    const serverActions = new Map();
+
+    // Helper to get serverReferencesMap at runtime (after loaders have populated it)
+    function getServerReferencesMap() {
+      try {
+        return require('./rsc-client-loader').serverReferencesMap;
+      } catch (e) {
+        return new Map();
+      }
+    }
+
+    // Helper to get inlineServerActionsMap from server loader
+    function getInlineServerActionsMap() {
+      try {
+        return require('./rsc-server-loader').inlineServerActionsMap;
+      } catch (e) {
+        return new Map();
+      }
+    }
+
+    // Scan for 'use server' modules during compilation
+    compiler.hooks.thisCompilation.tap(
+      'ReactFlightPlugin',
+      (compilation, { normalModuleFactory }) => {
+        compilation.dependencyFactories.set(
+          ServerReferenceDependency,
+          normalModuleFactory,
+        );
+        compilation.dependencyTemplates.set(
+          ServerReferenceDependency,
+          new NullDependency.Template(),
+        );
+
+        const handler = (parser) => {
+          parser.hooks.program.tap('ReactFlightPlugin', (ast) => {
+            const module = parser.state.module;
+            if (!module.resource) return;
+
+            // Check for 'use server' directive
+            let hasUseServer = false;
+            for (const node of ast.body) {
+              if (node.type !== 'ExpressionStatement' || !node.directive) break;
+              if (node.directive === 'use server') {
+                hasUseServer = true;
+                break;
+              }
+            }
+
+            if (!hasUseServer) return;
+
+            // Collect exports from this module
+            const exports = [];
+            for (const node of ast.body) {
+              if (node.type === 'ExportNamedDeclaration' && node.declaration) {
+                if (
+                  node.declaration.type === 'FunctionDeclaration' &&
+                  node.declaration.id
+                ) {
+                  exports.push(node.declaration.id.name);
+                }
+                if (node.declaration.type === 'VariableDeclaration') {
+                  for (const decl of node.declaration.declarations) {
+                    if (decl.id && decl.id.type === 'Identifier') {
+                      exports.push(decl.id.name);
+                    }
+                  }
+                }
+              }
+              if (node.type === 'ExportDefaultDeclaration') {
+                exports.push('default');
+              }
+            }
+
+            if (exports.length > 0) {
+              serverActions.set(module.resource, exports);
+            }
+          });
+        };
+
+        normalModuleFactory.hooks.parser
+          .for('javascript/auto')
+          .tap('ReactFlightPlugin', handler);
+        normalModuleFactory.hooks.parser
+          .for('javascript/esm')
+          .tap('ReactFlightPlugin', handler);
+        normalModuleFactory.hooks.parser
+          .for('javascript/dynamic')
+          .tap('ReactFlightPlugin', handler);
+      },
+    );
+
+    // Generate server actions manifest
+    compiler.hooks.make.tap('ReactFlightPlugin', (compilation) => {
+      compilation.hooks.processAssets.tap(
+        {
+          name: 'ReactFlightPlugin',
+          // Emit server-actions manifest early so downstream plugins (e.g. MF additionalData
+          // at OPTIMIZE_TRANSFER/3000) can read it. SUMMARIZE is 1000.
+          stage: webpack.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
+        },
+        function () {
+          const manifest = {};
+
+          // Include actions detected by AST parsing
+          for (const [resourcePath, exports] of serverActions) {
+            const moduleUrl = url.pathToFileURL(resourcePath).href;
+
+            for (const exportName of exports) {
+              const actionId =
+                exportName === 'default'
+                  ? `${moduleUrl}#default`
+                  : `${moduleUrl}#${exportName}`;
+
+              manifest[actionId] = {
+                id: moduleUrl,
+                name: exportName,
+                chunks: [],
+              };
+            }
+          }
+
+          // Include actions registered by the client loader via shared map
+          const serverReferencesMap = getServerReferencesMap();
+          if (serverReferencesMap && serverReferencesMap.size > 0) {
+            for (const [actionId, entry] of serverReferencesMap) {
+              if (!manifest[actionId]) {
+                manifest[actionId] = entry;
+              }
+            }
+          }
+
+          // Include inline server actions registered by the server loader
+          const inlineServerActionsMap = getInlineServerActionsMap();
+          if (inlineServerActionsMap && inlineServerActionsMap.size > 0) {
+            for (const [actionId, entry] of inlineServerActionsMap) {
+              if (!manifest[actionId]) {
+                manifest[actionId] = entry;
+              }
+            }
+          }
+
+          // Merge any extra server action manifests (e.g. from MF remotes)
+          if (Array.isArray(_this.extraServerActionsManifests)) {
+            for (const manifestPath of _this.extraServerActionsManifests) {
+              if (!manifestPath) continue;
+              try {
+                if (!fs.existsSync(manifestPath)) continue;
+                const json = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
+                for (const [actionId, entry] of Object.entries(json)) {
+                  if (!manifest[actionId]) {
+                    manifest[actionId] = entry;
+                  }
+                }
+              } catch (e) {
+                compilation.warnings.push(
+                  new webpack.WebpackError(
+                    'ReactFlightPlugin: Failed to merge server actions manifest from ' +
+                      manifestPath +
+                      ': ' +
+                      e.message,
+                  ),
+                );
+              }
+            }
+          }
+
+          const output = JSON.stringify(manifest, null, 2);
+          compilation.emitAsset(
+            _this.serverActionsManifestFilename,
+            new webpack.sources.RawSource(output, false),
+          );
+
+          const actionCount = Object.keys(manifest).length;
+          if (actionCount > 0) {
+            console.log(
+              `[ReactFlightPlugin] Generated ${_this.serverActionsManifestFilename} with ${actionCount} action(s)`,
+            );
+          }
+        },
+      );
+    });
+  }
+
+  applyClient(compiler) {
+    const _this = this;
     let resolvedClientReferences,
       clientFileNameFound = !1;
+
     compiler.hooks.beforeCompile.tapAsync(
-      "React Server Plugin",
+      'ReactFlightPlugin',
       (_ref, callback) => {
         _ref = _ref.contextModuleFactory;
-        const contextResolver = compiler.resolverFactory.get("context", {}),
-          normalResolver = compiler.resolverFactory.get("normal");
+        const contextResolver = compiler.resolverFactory.get('context', {}),
+          normalResolver = compiler.resolverFactory.get('normal');
         _this.resolveAllClientFiles(
           compiler.context,
           contextResolver,
@@ -144,21 +431,22 @@
             err
               ? callback(err)
               : ((resolvedClientReferences = resolvedClientRefs), callback());
-          }
+          },
         );
-      }
+      },
     );
+
     compiler.hooks.thisCompilation.tap(
-      "React Server Plugin",
+      'ReactFlightPlugin',
       (compilation, _ref2) => {
         _ref2 = _ref2.normalModuleFactory;
         compilation.dependencyFactories.set(ClientReferenceDependency, _ref2);
         compilation.dependencyTemplates.set(
           ClientReferenceDependency,
-          new NullDependency.Template()
+          new NullDependency.Template(),
         );
         compilation = (parser) => {
-          parser.hooks.program.tap("React Server Plugin", () => {
+          parser.hooks.program.tap('ReactFlightPlugin', () => {
             const module = parser.state.module;
             if (
               module.resource === clientFileName &&
@@ -167,12 +455,12 @@
               for (let i = 0; i < resolvedClientReferences.length; i++) {
                 const dep = resolvedClientReferences[i];
                 var chunkName = _this.chunkName
-                  .replace(/\[index\]/g, "" + i)
+                  .replace(/\[index\]/g, '' + i)
                   .replace(/\[request\]/g, Template.toPath(dep.userRequest));
                 chunkName = new webpack.AsyncDependenciesBlock(
                   { name: chunkName },
                   null,
-                  dep.request
+                  dep.request,
                 );
                 chunkName.addDependency(dep);
                 module.addBlock(chunkName);
@@ -180,51 +468,59 @@
           });
         };
         _ref2.hooks.parser
-          .for("javascript/auto")
-          .tap("HarmonyModulesPlugin", compilation);
+          .for('javascript/auto')
+          .tap('HarmonyModulesPlugin', compilation);
         _ref2.hooks.parser
-          .for("javascript/esm")
-          .tap("HarmonyModulesPlugin", compilation);
+          .for('javascript/esm')
+          .tap('HarmonyModulesPlugin', compilation);
         _ref2.hooks.parser
-          .for("javascript/dynamic")
-          .tap("HarmonyModulesPlugin", compilation);
-      }
+          .for('javascript/dynamic')
+          .tap('HarmonyModulesPlugin', compilation);
+      },
     );
-    compiler.hooks.make.tap("React Server Plugin", (compilation) => {
+
+    compiler.hooks.make.tap('ReactFlightPlugin', (compilation) => {
       compilation.hooks.processAssets.tap(
         {
-          name: "React Server Plugin",
-          stage: webpack.Compilation.PROCESS_ASSETS_STAGE_REPORT
+          name: 'ReactFlightPlugin',
+          // Use SUMMARIZE (1000) instead of REPORT (5000) so react-client-manifest.json
+          // is available for MF's additionalData hook at OPTIMIZE_TRANSFER (3000)
+          stage: webpack.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
         },
         function () {
           if (!1 === clientFileNameFound)
             compilation.warnings.push(
               new webpack.WebpackError(
-                "Client runtime at react-server-dom-webpack/client was not found. React Server Components module map file " +
+                'Client runtime at react-server-dom-webpack/client was not found. React Server Components module map file ' +
                   _this.clientManifestFilename +
-                  " was not created."
-              )
+                  ' was not created.',
+              ),
             );
           else {
             var configuredCrossOriginLoading =
               compilation.outputOptions.crossOriginLoading;
             configuredCrossOriginLoading =
-              "string" === typeof configuredCrossOriginLoading
-                ? "use-credentials" === configuredCrossOriginLoading
+              'string' === typeof configuredCrossOriginLoading
+                ? 'use-credentials' === configuredCrossOriginLoading
                   ? configuredCrossOriginLoading
-                  : "anonymous"
+                  : 'anonymous'
                 : null;
             var resolvedClientFiles = new Set(
-                (resolvedClientReferences || []).map((ref) => ref.request)
+                (resolvedClientReferences || []).map((ref) => ref.request),
               ),
+              discoveredClientRefs = new Set(
+                Array.isArray(_this.discoveredClientRefs)
+                  ? _this.discoveredClientRefs
+                  : [],
+              ),
               clientManifest = {},
               moduleMap = {};
             configuredCrossOriginLoading = {
               moduleLoading: {
-                prefix: compilation.outputOptions.publicPath || "",
-                crossOrigin: configuredCrossOriginLoading
+                prefix: compilation.outputOptions.publicPath || '',
+                crossOrigin: configuredCrossOriginLoading,
               },
-              moduleMap
+              moduleMap,
             };
             var runtimeChunkFiles = new Set();
             compilation.entrypoints.forEach((entrypoint) => {
@@ -235,16 +531,35 @@
             });
             compilation.chunkGroups.forEach(function (chunkGroup) {
               function recordModule(id, module) {
-                if (
-                  resolvedClientFiles.has(module.resource) &&
-                  ((module = url.pathToFileURL(module.resource).href),
-                  void 0 !== module)
-                ) {
-                  const ssrExports = {};
-                  clientManifest[module] = { id, chunks, name: "*" };
-                  ssrExports["*"] = { specifier: module, name: "*" };
-                  moduleMap[id] = ssrExports;
+                if (!module) return;
+
+                function visit(mod) {
+                  if (!mod) return;
+                  const isClient =
+                    mod.buildInfo &&
+                    mod.buildInfo.rscDirective === 'use client';
+
+                  if (
+                    isClient ||
+                    (mod.resource && discoveredClientRefs.has(mod.resource)) ||
+                    (mod.resource && resolvedClientFiles.has(mod.resource))
+                  ) {
+                    const resource = mod.resource;
+                    if (resource) {
+                      const href = url.pathToFileURL(resource).href;
+                      const ssrExports = {};
+                      clientManifest[href] = { id, chunks, name: '*' };
+                      ssrExports['*'] = { specifier: href, name: '*' };
+                      moduleMap[id] = ssrExports;
+                    }
+                  }
+
+                  if (mod.modules && Array.isArray(mod.modules)) {
+                    mod.modules.forEach(visit);
+                  }
                 }
+
+                visit(module);
               }
               const chunks = [];
               chunkGroup.chunks.forEach(function (c) {
@@ -253,10 +568,10 @@
                 try {
                   for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                     const file = _step.value;
-                    if (!file.endsWith(".js") && !file.endsWith(".mjs")) break;
+                    if (!file.endsWith('.js') && !file.endsWith('.mjs')) break;
                     if (
-                      file.endsWith(".hot-update.js") ||
-                      file.endsWith(".hot-update.mjs")
+                      file.endsWith('.hot-update.js') ||
+                      file.endsWith('.hot-update.mjs')
                     )
                       break;
                     chunks.push(c.id, file);
@@ -283,52 +598,38 @@
             var clientOutput = JSON.stringify(clientManifest, null, 2);
             compilation.emitAsset(
               _this.clientManifestFilename,
-              new webpack.sources.RawSource(clientOutput, !1)
+              new webpack.sources.RawSource(clientOutput, !1),
             );
             configuredCrossOriginLoading = JSON.stringify(
               configuredCrossOriginLoading,
               null,
-              2
+              2,
             );
             compilation.emitAsset(
               _this.serverConsumerManifestFilename,
-              new webpack.sources.RawSource(configuredCrossOriginLoading, !1)
+              new webpack.sources.RawSource(configuredCrossOriginLoading, !1),
             );
           }
-        }
+        },
       );
     });
   }
+
   resolveAllClientFiles(
     context,
     contextResolver,
     normalResolver,
     fs,
     contextModuleFactory,
-    callback
+    callback,
   ) {
     function hasUseClientDirective(source) {
-      if (-1 === source.indexOf("use client")) return !1;
-      let body;
-      try {
-        body = acorn.parse(source, {
-          ecmaVersion: "2024",
-          sourceType: "module"
-        }).body;
-      } catch (x) {
-        return !1;
-      }
-      for (source = 0; source < body.length; source++) {
-        const node = body[source];
-        if ("ExpressionStatement" !== node.type || !node.directive) break;
-        if ("use client" === node.directive) return !0;
-      }
-      return !1;
+      return hasDirective(source, 'use client');
     }
     asyncLib.map(
       this.clientReferences,
       (clientReferencePath, cb) => {
-        "string" === typeof clientReferencePath
+        'string' === typeof clientReferencePath
           ? cb(null, [new ClientReferenceDependency(clientReferencePath)])
           : contextResolver.resolve(
               {},
@@ -341,21 +642,21 @@
                   fs,
                   {
                     resource: resolvedDirectory,
-                    resourceQuery: "",
+                    resourceQuery: '',
                     recursive:
                       void 0 === clientReferencePath.recursive
                         ? !0
                         : clientReferencePath.recursive,
                     regExp: clientReferencePath.include,
                     include: void 0,
-                    exclude: clientReferencePath.exclude
+                    exclude: clientReferencePath.exclude,
                   },
                   (err2, deps) => {
                     if (err2) return cb(err2);
                     err2 = deps.map((dep) => {
                       var request = path.join(
                         resolvedDirectory,
-                        dep.userRequest
+                        dep.userRequest,
                       );
                       request = new ClientReferenceDependency(request);
                       request.userRequest = dep.userRequest;
@@ -370,26 +671,26 @@
                           clientRefDep.request,
                           {},
                           (err3, resolvedPath) => {
-                            if (err3 || "string" !== typeof resolvedPath)
+                            if (err3 || 'string' !== typeof resolvedPath)
                               return filterCb(null, !1);
                             fs.readFile(
                               resolvedPath,
-                              "utf-8",
+                              'utf-8',
                               (err4, content) => {
-                                if (err4 || "string" !== typeof content)
+                                if (err4 || 'string' !== typeof content)
                                   return filterCb(null, !1);
                                 err4 = hasUseClientDirective(content);
                                 filterCb(null, err4);
-                              }
+                              },
                             );
-                          }
+                          },
                         );
                       },
-                      cb
+                      cb,
                     );
-                  }
+                  },
                 );
-              }
+              },
             );
       },
       (err, result) => {
@@ -397,8 +698,9 @@
         err = [];
         for (let i = 0; i < result.length; i++) err.push.apply(err, result[i]);
         callback(null, err);
-      }
+      },
     );
   }
 }
+
 module.exports = ReactFlightWebpackPlugin;
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.browser.development.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.browser.development.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.browser.development.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.browser.development.js	2025-12-17 14:32:44
@@ -8,27 +8,27 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
+'use strict';
+'production' !== process.env.NODE_ENV &&
   (function () {
     function voidHandler() {}
     function _defineProperty(obj, key, value) {
-      a: if ("object" == typeof key && key) {
+      a: if ('object' == typeof key && key) {
         var e = key[Symbol.toPrimitive];
         if (void 0 !== e) {
-          key = e.call(key, "string");
-          if ("object" != typeof key) break a;
-          throw new TypeError("@@toPrimitive must return a primitive value.");
+          key = e.call(key, 'string');
+          if ('object' != typeof key) break a;
+          throw new TypeError('@@toPrimitive must return a primitive value.');
         }
         key = String(key);
       }
-      key = "symbol" == typeof key ? key : key + "";
+      key = 'symbol' == typeof key ? key : key + '';
       key in obj
         ? Object.defineProperty(obj, key, {
             value: value,
             enumerable: !0,
             configurable: !0,
-            writable: !0
+            writable: !0,
           })
         : (obj[key] = value);
       return obj;
@@ -47,7 +47,7 @@
         if (2048 < chunk.byteLength)
           0 < writtenBytes &&
             (destination.enqueue(
-              new Uint8Array(currentView.buffer, 0, writtenBytes)
+              new Uint8Array(currentView.buffer, 0, writtenBytes),
             ),
             (currentView = new Uint8Array(2048)),
             (writtenBytes = 0)),
@@ -59,7 +59,7 @@
               ? destination.enqueue(currentView)
               : (currentView.set(
                   chunk.subarray(0, allowableBytes),
-                  writtenBytes
+                  writtenBytes,
                 ),
                 destination.enqueue(currentView),
                 (chunk = chunk.subarray(allowableBytes))),
@@ -74,7 +74,7 @@
       currentView &&
         0 < writtenBytes &&
         (destination.enqueue(
-          new Uint8Array(currentView.buffer, 0, writtenBytes)
+          new Uint8Array(currentView.buffer, 0, writtenBytes),
         ),
         (currentView = null),
         (writtenBytes = 0));
@@ -86,7 +86,7 @@
       return chunk.byteLength;
     }
     function closeWithError(destination, error) {
-      "function" === typeof destination.error
+      'function' === typeof destination.error
         ? destination.error(error)
         : destination.close();
     }
@@ -97,7 +97,7 @@
       return Object.defineProperties(proxyImplementation, {
         $$typeof: { value: CLIENT_REFERENCE_TAG$1 },
         $$id: { value: id },
-        $$async: { value: async }
+        $$async: { value: async },
       });
     }
     function bind() {
@@ -105,7 +105,7 @@
       if (this.$$typeof === SERVER_REFERENCE_TAG) {
         null != arguments[0] &&
           console.error(
-            'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().'
+            'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().',
           );
         var args = ArraySlice.call(arguments, 1),
           $$typeof = { value: SERVER_REFERENCE_TAG },
@@ -116,95 +116,95 @@
           $$id: $$id,
           $$bound: args,
           $$location: { value: this.$$location, configurable: !0 },
-          bind: { value: bind, configurable: !0 }
+          bind: { value: bind, configurable: !0 },
         });
       }
       return newFn;
     }
     function getReference(target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "$$id":
+        case '$$id':
           return target.$$id;
-        case "$$async":
+        case '$$async':
           return target.$$async;
-        case "name":
+        case 'name':
           return target.name;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "__esModule":
+        case '__esModule':
           var moduleId = target.$$id;
           target.default = registerClientReferenceImpl(
             function () {
               throw Error(
-                "Attempted to call the default export of " +
+                'Attempted to call the default export of ' +
                   moduleId +
-                  " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+                  " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
               );
             },
-            target.$$id + "#",
-            target.$$async
+            target.$$id + '#',
+            target.$$async,
           );
           return !0;
-        case "then":
+        case 'then':
           if (target.then) return target.then;
           if (target.$$async) return;
           var clientReference = registerClientReferenceImpl(
               {},
               target.$$id,
-              !0
+              !0,
             ),
             proxy = new Proxy(clientReference, proxyHandlers$1);
-          target.status = "fulfilled";
+          target.status = 'fulfilled';
           target.value = proxy;
           return (target.then = registerClientReferenceImpl(
             function (resolve) {
               return Promise.resolve(resolve(proxy));
             },
-            target.$$id + "#then",
-            !1
+            target.$$id + '#then',
+            !1,
           ));
       }
-      if ("symbol" === typeof name)
+      if ('symbol' === typeof name)
         throw Error(
-          "Cannot read Symbol exports. Only named exports are supported on a client module imported on the server."
+          'Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.',
         );
       clientReference = target[name];
       clientReference ||
         ((clientReference = registerClientReferenceImpl(
           function () {
             throw Error(
-              "Attempted to call " +
+              'Attempted to call ' +
                 String(name) +
-                "() from the server but " +
+                '() from the server but ' +
                 String(name) +
-                " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+                " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
             );
           },
-          target.$$id + "#" + name,
-          target.$$async
+          target.$$id + '#' + name,
+          target.$$async,
         )),
-        Object.defineProperty(clientReference, "name", { value: name }),
+        Object.defineProperty(clientReference, 'name', { value: name }),
         (clientReference = target[name] =
           new Proxy(clientReference, deepProxyHandlers)));
       return clientReference;
     }
     function resolveClientReferenceMetadata(config, clientReference) {
       var modulePath = clientReference.$$id,
-        name = "",
+        name = '',
         resolvedModuleData = config[modulePath];
       if (resolvedModuleData) name = resolvedModuleData.name;
       else {
-        var idx = modulePath.lastIndexOf("#");
+        var idx = modulePath.lastIndexOf('#');
         -1 !== idx &&
           ((name = modulePath.slice(idx + 1)),
           (resolvedModuleData = config[modulePath.slice(0, idx)]));
@@ -212,55 +212,55 @@
           throw Error(
             'Could not find the module "' +
               modulePath +
-              '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.'
+              '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.',
           );
       }
       if (!0 === resolvedModuleData.async && !0 === clientReference.$$async)
         throw Error(
           'The module "' +
             modulePath +
-            '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.'
+            '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.',
         );
       return !0 === resolvedModuleData.async || !0 === clientReference.$$async
         ? [resolvedModuleData.id, resolvedModuleData.chunks, name, 1]
         : [resolvedModuleData.id, resolvedModuleData.chunks, name];
     }
     function preload(href, as, options) {
-      if ("string" === typeof href) {
+      if ('string' === typeof href) {
         var request = resolveRequest();
         if (request) {
           var hints = request.hints,
-            key = "L";
-          if ("image" === as && options) {
+            key = 'L';
+          if ('image' === as && options) {
             var imageSrcSet = options.imageSrcSet,
               imageSizes = options.imageSizes,
-              uniquePart = "";
-            "string" === typeof imageSrcSet && "" !== imageSrcSet
-              ? ((uniquePart += "[" + imageSrcSet + "]"),
-                "string" === typeof imageSizes &&
-                  (uniquePart += "[" + imageSizes + "]"))
-              : (uniquePart += "[][]" + href);
-            key += "[image]" + uniquePart;
-          } else key += "[" + as + "]" + href;
+              uniquePart = '';
+            'string' === typeof imageSrcSet && '' !== imageSrcSet
+              ? ((uniquePart += '[' + imageSrcSet + ']'),
+                'string' === typeof imageSizes &&
+                  (uniquePart += '[' + imageSizes + ']'))
+              : (uniquePart += '[][]' + href);
+            key += '[image]' + uniquePart;
+          } else key += '[' + as + ']' + href;
           hints.has(key) ||
             (hints.add(key),
             (options = trimOptions(options))
-              ? emitHint(request, "L", [href, as, options])
-              : emitHint(request, "L", [href, as]));
+              ? emitHint(request, 'L', [href, as, options])
+              : emitHint(request, 'L', [href, as]));
         } else previousDispatcher.L(href, as, options);
       }
     }
     function preloadModule$1(href, options) {
-      if ("string" === typeof href) {
+      if ('string' === typeof href) {
         var request = resolveRequest();
         if (request) {
           var hints = request.hints,
-            key = "m|" + href;
+            key = 'm|' + href;
           if (hints.has(key)) return;
           hints.add(key);
           return (options = trimOptions(options))
-            ? emitHint(request, "m", [href, options])
-            : emitHint(request, "m", href);
+            ? emitHint(request, 'm', [href, options])
+            : emitHint(request, 'm', href);
         }
         previousDispatcher.m(href, options);
       }
@@ -277,63 +277,63 @@
     }
     function getChildFormatContext(parentContext, type, props) {
       switch (type) {
-        case "img":
+        case 'img':
           type = props.src;
           var srcSet = props.srcSet;
           if (
             !(
-              "lazy" === props.loading ||
+              'lazy' === props.loading ||
               (!type && !srcSet) ||
-              ("string" !== typeof type && null != type) ||
-              ("string" !== typeof srcSet && null != srcSet) ||
-              "low" === props.fetchPriority ||
+              ('string' !== typeof type && null != type) ||
+              ('string' !== typeof srcSet && null != srcSet) ||
+              'low' === props.fetchPriority ||
               parentContext & 3
             ) &&
-            ("string" !== typeof type ||
-              ":" !== type[4] ||
-              ("d" !== type[0] && "D" !== type[0]) ||
-              ("a" !== type[1] && "A" !== type[1]) ||
-              ("t" !== type[2] && "T" !== type[2]) ||
-              ("a" !== type[3] && "A" !== type[3])) &&
-            ("string" !== typeof srcSet ||
-              ":" !== srcSet[4] ||
-              ("d" !== srcSet[0] && "D" !== srcSet[0]) ||
-              ("a" !== srcSet[1] && "A" !== srcSet[1]) ||
-              ("t" !== srcSet[2] && "T" !== srcSet[2]) ||
-              ("a" !== srcSet[3] && "A" !== srcSet[3]))
+            ('string' !== typeof type ||
+              ':' !== type[4] ||
+              ('d' !== type[0] && 'D' !== type[0]) ||
+              ('a' !== type[1] && 'A' !== type[1]) ||
+              ('t' !== type[2] && 'T' !== type[2]) ||
+              ('a' !== type[3] && 'A' !== type[3])) &&
+            ('string' !== typeof srcSet ||
+              ':' !== srcSet[4] ||
+              ('d' !== srcSet[0] && 'D' !== srcSet[0]) ||
+              ('a' !== srcSet[1] && 'A' !== srcSet[1]) ||
+              ('t' !== srcSet[2] && 'T' !== srcSet[2]) ||
+              ('a' !== srcSet[3] && 'A' !== srcSet[3]))
           ) {
-            var sizes = "string" === typeof props.sizes ? props.sizes : void 0;
+            var sizes = 'string' === typeof props.sizes ? props.sizes : void 0;
             var input = props.crossOrigin;
-            preload(type || "", "image", {
+            preload(type || '', 'image', {
               imageSrcSet: srcSet,
               imageSizes: sizes,
               crossOrigin:
-                "string" === typeof input
-                  ? "use-credentials" === input
+                'string' === typeof input
+                  ? 'use-credentials' === input
                     ? input
-                    : ""
+                    : ''
                   : void 0,
               integrity: props.integrity,
               type: props.type,
               fetchPriority: props.fetchPriority,
-              referrerPolicy: props.referrerPolicy
+              referrerPolicy: props.referrerPolicy,
             });
           }
           return parentContext;
-        case "link":
+        case 'link':
           type = props.rel;
           srcSet = props.href;
           if (
             !(
               parentContext & 1 ||
               null != props.itemProp ||
-              "string" !== typeof type ||
-              "string" !== typeof srcSet ||
-              "" === srcSet
+              'string' !== typeof type ||
+              'string' !== typeof srcSet ||
+              '' === srcSet
             )
           )
             switch (type) {
-              case "preload":
+              case 'preload':
                 preload(srcSet, props.as, {
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
@@ -343,32 +343,32 @@
                   referrerPolicy: props.referrerPolicy,
                   imageSrcSet: props.imageSrcSet,
                   imageSizes: props.imageSizes,
-                  media: props.media
+                  media: props.media,
                 });
                 break;
-              case "modulepreload":
+              case 'modulepreload':
                 preloadModule$1(srcSet, {
                   as: props.as,
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
-                  nonce: props.nonce
+                  nonce: props.nonce,
                 });
                 break;
-              case "stylesheet":
-                preload(srcSet, "stylesheet", {
+              case 'stylesheet':
+                preload(srcSet, 'stylesheet', {
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
                   nonce: props.nonce,
                   type: props.type,
                   fetchPriority: props.fetchPriority,
                   referrerPolicy: props.referrerPolicy,
-                  media: props.media
+                  media: props.media,
                 });
             }
           return parentContext;
-        case "picture":
+        case 'picture':
           return parentContext | 2;
-        case "noscript":
+        case 'noscript':
           return parentContext | 1;
         default:
           return parentContext;
@@ -378,51 +378,51 @@
       error = [];
       for (var i = framesToSkip; i < structuredStackTrace.length; i++) {
         var callSite = structuredStackTrace[i],
-          name = callSite.getFunctionName() || "<anonymous>";
-        if (name.includes("react_stack_bottom_frame")) break;
+          name = callSite.getFunctionName() || '<anonymous>';
+        if (name.includes('react_stack_bottom_frame')) break;
         else if (callSite.isNative())
           (callSite = callSite.isAsync()),
-            error.push([name, "", 0, 0, 0, 0, callSite]);
+            error.push([name, '', 0, 0, 0, 0, callSite]);
         else {
-          if (callSite.isConstructor()) name = "new " + name;
+          if (callSite.isConstructor()) name = 'new ' + name;
           else if (!callSite.isToplevel()) {
             var callSite$jscomp$0 = callSite;
             name = callSite$jscomp$0.getTypeName();
             var methodName = callSite$jscomp$0.getMethodName();
             callSite$jscomp$0 = callSite$jscomp$0.getFunctionName();
-            var result = "";
+            var result = '';
             callSite$jscomp$0
               ? (name &&
                   identifierRegExp.test(callSite$jscomp$0) &&
                   callSite$jscomp$0 !== name &&
-                  (result += name + "."),
+                  (result += name + '.'),
                 (result += callSite$jscomp$0),
                 !methodName ||
                   callSite$jscomp$0 === methodName ||
-                  callSite$jscomp$0.endsWith("." + methodName) ||
-                  callSite$jscomp$0.endsWith(" " + methodName) ||
-                  (result += " [as " + methodName + "]"))
-              : (name && (result += name + "."),
+                  callSite$jscomp$0.endsWith('.' + methodName) ||
+                  callSite$jscomp$0.endsWith(' ' + methodName) ||
+                  (result += ' [as ' + methodName + ']'))
+              : (name && (result += name + '.'),
                 (result = methodName
                   ? result + methodName
-                  : result + "<anonymous>"));
+                  : result + '<anonymous>'));
             name = result;
           }
-          "<anonymous>" === name && (name = "");
-          methodName = callSite.getScriptNameOrSourceURL() || "<anonymous>";
-          "<anonymous>" === methodName &&
-            ((methodName = ""),
+          '<anonymous>' === name && (name = '');
+          methodName = callSite.getScriptNameOrSourceURL() || '<anonymous>';
+          '<anonymous>' === methodName &&
+            ((methodName = ''),
             callSite.isEval() &&
               (callSite$jscomp$0 = callSite.getEvalOrigin()) &&
-              (methodName = callSite$jscomp$0.toString() + ", <anonymous>"));
+              (methodName = callSite$jscomp$0.toString() + ', <anonymous>'));
           callSite$jscomp$0 = callSite.getLineNumber() || 0;
           result = callSite.getColumnNumber() || 0;
           var enclosingLine =
-              "function" === typeof callSite.getEnclosingLineNumber
+              'function' === typeof callSite.getEnclosingLineNumber
                 ? callSite.getEnclosingLineNumber() || 0
                 : 0,
             enclosingCol =
-              "function" === typeof callSite.getEnclosingColumnNumber
+              'function' === typeof callSite.getEnclosingColumnNumber
                 ? callSite.getEnclosingColumnNumber() || 0
                 : 0;
           callSite = callSite.isAsync();
@@ -433,18 +433,18 @@
             result,
             enclosingLine,
             enclosingCol,
-            callSite
+            callSite,
           ]);
         }
       }
       collectedStackTrace = error;
-      return "";
+      return '';
     }
     function collectStackTrace(error, structuredStackTrace) {
       collectStackTracePrivate(error, structuredStackTrace);
-      error = (error.name || "Error") + ": " + (error.message || "");
+      error = (error.name || 'Error') + ': ' + (error.message || '');
       for (var i = 0; i < structuredStackTrace.length; i++)
-        error += "\n    at " + structuredStackTrace[i].toString();
+        error += '\n    at ' + structuredStackTrace[i].toString();
       return error;
     }
     function parseStackTrace(error, skipFrames) {
@@ -466,23 +466,23 @@
           stackTraceCache.set(error, stack),
           stack
         );
-      stack.startsWith("Error: react-stack-top-frame\n") &&
+      stack.startsWith('Error: react-stack-top-frame\n') &&
         (stack = stack.slice(29));
-      existing = stack.indexOf("react_stack_bottom_frame");
-      -1 !== existing && (existing = stack.lastIndexOf("\n", existing));
+      existing = stack.indexOf('react_stack_bottom_frame');
+      -1 !== existing && (existing = stack.lastIndexOf('\n', existing));
       -1 !== existing && (stack = stack.slice(0, existing));
-      stack = stack.split("\n");
+      stack = stack.split('\n');
       for (existing = []; skipFrames < stack.length; skipFrames++) {
         var parsed = frameRegExp.exec(stack[skipFrames]);
         if (parsed) {
-          var name = parsed[1] || "",
-            isAsync = "async " === parsed[8];
-          "<anonymous>" === name
-            ? (name = "")
-            : name.startsWith("async ") &&
+          var name = parsed[1] || '',
+            isAsync = 'async ' === parsed[8];
+          '<anonymous>' === name
+            ? (name = '')
+            : name.startsWith('async ') &&
               ((name = name.slice(5)), (isAsync = !0));
-          var filename = parsed[2] || parsed[5] || "";
-          "<anonymous>" === filename && (filename = "");
+          var filename = parsed[2] || parsed[5] || '';
+          '<anonymous>' === filename && (filename = '');
           existing.push([
             name,
             filename,
@@ -490,7 +490,7 @@
             +(parsed[4] || parsed[7]),
             0,
             0,
-            isAsync
+            isAsync,
           ]);
         }
       }
@@ -501,22 +501,22 @@
       var reference = Object.defineProperties(
         function () {
           throw Error(
-            "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+            "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
           );
         },
-        { $$typeof: { value: TEMPORARY_REFERENCE_TAG } }
+        { $$typeof: { value: TEMPORARY_REFERENCE_TAG } },
       );
       reference = new Proxy(reference, proxyHandlers);
       temporaryReferences.set(reference, id);
       return reference;
     }
     function getIteratorFn(maybeIterable) {
-      if (null === maybeIterable || "object" !== typeof maybeIterable)
+      if (null === maybeIterable || 'object' !== typeof maybeIterable)
         return null;
       maybeIterable =
         (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-        maybeIterable["@@iterator"];
-      return "function" === typeof maybeIterable ? maybeIterable : null;
+        maybeIterable['@@iterator'];
+      return 'function' === typeof maybeIterable ? maybeIterable : null;
     }
     function noop() {}
     function trackUsedThenable(thenableState, thenable, index) {
@@ -526,35 +526,35 @@
           (thenableState._stacks || (thenableState._stacks = [])).push(Error()))
         : index !== thenable && (thenable.then(noop, noop), (thenable = index));
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return thenable.value;
-        case "rejected":
+        case 'rejected':
           throw thenable.reason;
         default:
-          "string" === typeof thenable.status
+          'string' === typeof thenable.status
             ? thenable.then(noop, noop)
             : ((thenableState = thenable),
-              (thenableState.status = "pending"),
+              (thenableState.status = 'pending'),
               thenableState.then(
                 function (fulfilledValue) {
-                  if ("pending" === thenable.status) {
+                  if ('pending' === thenable.status) {
                     var fulfilledThenable = thenable;
-                    fulfilledThenable.status = "fulfilled";
+                    fulfilledThenable.status = 'fulfilled';
                     fulfilledThenable.value = fulfilledValue;
                   }
                 },
                 function (error) {
-                  if ("pending" === thenable.status) {
+                  if ('pending' === thenable.status) {
                     var rejectedThenable = thenable;
-                    rejectedThenable.status = "rejected";
+                    rejectedThenable.status = 'rejected';
                     rejectedThenable.reason = error;
                   }
-                }
+                },
               ));
           switch (thenable.status) {
-            case "fulfilled":
+            case 'fulfilled':
               return thenable.value;
-            case "rejected":
+            case 'rejected':
               throw thenable.reason;
           }
           suspendedThenable = thenable;
@@ -564,7 +564,7 @@
     function getSuspendedThenable() {
       if (null === suspendedThenable)
         throw Error(
-          "Expected a suspended thenable. This is a bug in React. Please file an issue."
+          'Expected a suspended thenable. This is a bug in React. Please file an issue.',
         );
       var thenable = suspendedThenable;
       suspendedThenable = null;
@@ -577,15 +577,15 @@
       return state;
     }
     function unsupportedHook() {
-      throw Error("This Hook is not supported in Server Components.");
+      throw Error('This Hook is not supported in Server Components.');
     }
     function unsupportedRefresh() {
       throw Error(
-        "Refreshing the cache is not supported in Server Components."
+        'Refreshing the cache is not supported in Server Components.',
       );
     }
     function unsupportedContext() {
-      throw Error("Cannot read a Client Context from a Server Component.");
+      throw Error('Cannot read a Client Context from a Server Component.');
     }
     function resolveOwner() {
       return currentOwner ? currentOwner : null;
@@ -611,7 +611,7 @@
       var descriptor = Object.getOwnPropertyDescriptor(object, name);
       return void 0 === descriptor
         ? isGetter(getPrototypeOf(object), name)
-        : "function" === typeof descriptor.get;
+        : 'function' === typeof descriptor.get;
     }
     function isSimpleObject(object) {
       if (!isObjectPrototype(getPrototypeOf(object))) return !1;
@@ -624,8 +624,8 @@
         if (
           !descriptor ||
           (!descriptor.enumerable &&
-            (("key" !== names[i] && "ref" !== names[i]) ||
-              "function" !== typeof descriptor.get))
+            (('key' !== names[i] && 'ref' !== names[i]) ||
+              'function' !== typeof descriptor.get))
         )
           return !1;
       }
@@ -641,35 +641,35 @@
     }
     function describeValueForErrorMessage(value) {
       switch (typeof value) {
-        case "string":
+        case 'string':
           return JSON.stringify(
-            10 >= value.length ? value : value.slice(0, 10) + "..."
+            10 >= value.length ? value : value.slice(0, 10) + '...',
           );
-        case "object":
-          if (isArrayImpl(value)) return "[...]";
+        case 'object':
+          if (isArrayImpl(value)) return '[...]';
           if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-            return "client";
+            return 'client';
           value = objectName(value);
-          return "Object" === value ? "{...}" : value;
-        case "function":
+          return 'Object' === value ? '{...}' : value;
+        case 'function':
           return value.$$typeof === CLIENT_REFERENCE_TAG
-            ? "client"
+            ? 'client'
             : (value = value.displayName || value.name)
-              ? "function " + value
-              : "function";
+              ? 'function ' + value
+              : 'function';
         default:
           return String(value);
       }
     }
     function describeElementType(type) {
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (type.$$typeof) {
           case REACT_FORWARD_REF_TYPE:
             return describeElementType(type.render);
@@ -682,74 +682,74 @@
               return describeElementType(type(payload));
             } catch (x) {}
         }
-      return "";
+      return '';
     }
     function describeObjectForErrorMessage(objectOrArray, expandedName) {
       var objKind = objectName(objectOrArray);
-      if ("Object" !== objKind && "Array" !== objKind) return objKind;
+      if ('Object' !== objKind && 'Array' !== objKind) return objKind;
       var start = -1,
         length = 0;
       if (isArrayImpl(objectOrArray))
         if (jsxChildrenParents.has(objectOrArray)) {
           var type = jsxChildrenParents.get(objectOrArray);
-          objKind = "<" + describeElementType(type) + ">";
+          objKind = '<' + describeElementType(type) + '>';
           for (var i = 0; i < objectOrArray.length; i++) {
             var value = objectOrArray[i];
             value =
-              "string" === typeof value
+              'string' === typeof value
                 ? value
-                : "object" === typeof value && null !== value
-                  ? "{" + describeObjectForErrorMessage(value) + "}"
-                  : "{" + describeValueForErrorMessage(value) + "}";
-            "" + i === expandedName
+                : 'object' === typeof value && null !== value
+                  ? '{' + describeObjectForErrorMessage(value) + '}'
+                  : '{' + describeValueForErrorMessage(value) + '}';
+            '' + i === expandedName
               ? ((start = objKind.length),
                 (length = value.length),
                 (objKind += value))
               : (objKind =
                   15 > value.length && 40 > objKind.length + value.length
                     ? objKind + value
-                    : objKind + "{...}");
+                    : objKind + '{...}');
           }
-          objKind += "</" + describeElementType(type) + ">";
+          objKind += '</' + describeElementType(type) + '>';
         } else {
-          objKind = "[";
+          objKind = '[';
           for (type = 0; type < objectOrArray.length; type++)
-            0 < type && (objKind += ", "),
+            0 < type && (objKind += ', '),
               (i = objectOrArray[type]),
               (i =
-                "object" === typeof i && null !== i
+                'object' === typeof i && null !== i
                   ? describeObjectForErrorMessage(i)
                   : describeValueForErrorMessage(i)),
-              "" + type === expandedName
+              '' + type === expandedName
                 ? ((start = objKind.length),
                   (length = i.length),
                   (objKind += i))
                 : (objKind =
                     10 > i.length && 40 > objKind.length + i.length
                       ? objKind + i
-                      : objKind + "...");
-          objKind += "]";
+                      : objKind + '...');
+          objKind += ']';
         }
       else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-        objKind = "<" + describeElementType(objectOrArray.type) + "/>";
+        objKind = '<' + describeElementType(objectOrArray.type) + '/>';
       else {
-        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
         if (jsxPropsParents.has(objectOrArray)) {
           objKind = jsxPropsParents.get(objectOrArray);
-          objKind = "<" + (describeElementType(objKind) || "...");
+          objKind = '<' + (describeElementType(objKind) || '...');
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++) {
-            objKind += " ";
+            objKind += ' ';
             value = type[i];
-            objKind += describeKeyForErrorMessage(value) + "=";
+            objKind += describeKeyForErrorMessage(value) + '=';
             var _value2 = objectOrArray[value];
             var _substr2 =
               value === expandedName &&
-              "object" === typeof _value2 &&
+              'object' === typeof _value2 &&
               null !== _value2
                 ? describeObjectForErrorMessage(_value2)
                 : describeValueForErrorMessage(_value2);
-            "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
+            'string' !== typeof _value2 && (_substr2 = '{' + _substr2 + '}');
             value === expandedName
               ? ((start = objKind.length),
                 (length = _substr2.length),
@@ -757,19 +757,19 @@
               : (objKind =
                   10 > _substr2.length && 40 > objKind.length + _substr2.length
                     ? objKind + _substr2
-                    : objKind + "...");
+                    : objKind + '...');
           }
-          objKind += ">";
+          objKind += '>';
         } else {
-          objKind = "{";
+          objKind = '{';
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++)
-            0 < i && (objKind += ", "),
+            0 < i && (objKind += ', '),
               (value = type[i]),
-              (objKind += describeKeyForErrorMessage(value) + ": "),
+              (objKind += describeKeyForErrorMessage(value) + ': '),
               (_value2 = objectOrArray[value]),
               (_value2 =
-                "object" === typeof _value2 && null !== _value2
+                'object' === typeof _value2 && null !== _value2
                   ? describeObjectForErrorMessage(_value2)
                   : describeValueForErrorMessage(_value2)),
               value === expandedName
@@ -779,22 +779,22 @@
                 : (objKind =
                     10 > _value2.length && 40 > objKind.length + _value2.length
                       ? objKind + _value2
-                      : objKind + "...");
-          objKind += "}";
+                      : objKind + '...');
+          objKind += '}';
         }
       }
       return void 0 === expandedName
         ? objKind
         : -1 < start && 0 < length
-          ? ((objectOrArray = " ".repeat(start) + "^".repeat(length)),
-            "\n  " + objKind + "\n  " + objectOrArray)
-          : "\n  " + objKind;
+          ? ((objectOrArray = ' '.repeat(start) + '^'.repeat(length)),
+            '\n  ' + objKind + '\n  ' + objectOrArray)
+          : '\n  ' + objKind;
     }
     function defaultFilterStackFrame(filename) {
       return (
-        "" !== filename &&
-        !filename.startsWith("node:") &&
-        !filename.includes("node_modules")
+        '' !== filename &&
+        !filename.startsWith('node:') &&
+        !filename.includes('node_modules')
       );
     }
     function filterStackTrace(request, stack) {
@@ -803,9 +803,9 @@
         var callsite = stack[i],
           functionName = callsite[0];
         var url = callsite[1];
-        if (url.startsWith("about://React/")) {
-          var envIdx = url.indexOf("/", 14),
-            suffixIdx = url.lastIndexOf("?");
+        if (url.startsWith('about://React/')) {
+          var envIdx = url.indexOf('/', 14),
+            suffixIdx = url.lastIndexOf('?');
           -1 < envIdx &&
             -1 < suffixIdx &&
             (url = decodeURI(url.slice(envIdx + 1, suffixIdx)));
@@ -822,21 +822,21 @@
       if (
         descriptor &&
         (descriptor.configurable || descriptor.writable) &&
-        "function" === typeof descriptor.value
+        'function' === typeof descriptor.value
       ) {
         var originalMethod = descriptor.value;
-        descriptor = Object.getOwnPropertyDescriptor(originalMethod, "name");
+        descriptor = Object.getOwnPropertyDescriptor(originalMethod, 'name');
         var wrapperMethod = function () {
           var request = resolveRequest();
-          if (("assert" !== methodName || !arguments[0]) && null !== request) {
+          if (('assert' !== methodName || !arguments[0]) && null !== request) {
             a: {
-              var error = Error("react-stack-top-frame");
+              var error = Error('react-stack-top-frame');
               collectedStackTrace = null;
               framesToSkip = 1;
               var previousPrepare = Error.prepareStackTrace;
               Error.prepareStackTrace = collectStackTracePrivate;
               try {
-                if ("" !== error.stack) {
+                if ('' !== error.stack) {
                   var JSCompiler_inline_result = null;
                   break a;
                 }
@@ -847,7 +847,7 @@
             }
             JSCompiler_inline_result = filterStackTrace(
               request,
-              JSCompiler_inline_result || []
+              JSCompiler_inline_result || [],
             );
             request.pendingDebugChunks++;
             error = resolveOwner();
@@ -855,25 +855,25 @@
             a: {
               var env = 0;
               switch (methodName) {
-                case "dir":
-                case "dirxml":
-                case "groupEnd":
-                case "table":
+                case 'dir':
+                case 'dirxml':
+                case 'groupEnd':
+                case 'table':
                   env = null;
                   break a;
-                case "assert":
+                case 'assert':
                   env = 1;
               }
               var format = previousPrepare[env],
                 style = previousPrepare[env + 1],
                 badge = previousPrepare[env + 2];
-              "string" === typeof format &&
-              format.startsWith("%c%s%c") &&
-              "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px" ===
+              'string' === typeof format &&
+              format.startsWith('%c%s%c') &&
+              'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px' ===
                 style &&
-              "string" === typeof badge
+              'string' === typeof badge
                 ? ((format = format.slice(6)),
-                  " " === format[0] && (format = format.slice(1)),
+                  ' ' === format[0] && (format = format.slice(1)),
                   previousPrepare.splice(env, 4, format),
                   (env = badge.slice(1, badge.length - 1)))
                 : (env = null);
@@ -886,9 +886,9 @@
               request,
               (null === request.deferredDebugObjects ? 500 : 10) +
                 JSCompiler_inline_result.length,
-              badge
+              badge,
             );
-            "[" !== previousPrepare[0] &&
+            '[' !== previousPrepare[0] &&
               (previousPrepare = serializeDebugModel(
                 request,
                 10 + JSCompiler_inline_result.length,
@@ -897,28 +897,28 @@
                   JSCompiler_inline_result,
                   error,
                   env,
-                  "Unknown Value: React could not send it from the server."
-                ]
+                  'Unknown Value: React could not send it from the server.',
+                ],
               ));
             JSCompiler_inline_result = stringToChunk(
-              ":W" + previousPrepare + "\n"
+              ':W' + previousPrepare + '\n',
             );
             request.completedDebugChunks.push(JSCompiler_inline_result);
           }
           return originalMethod.apply(this, arguments);
         };
-        descriptor && Object.defineProperty(wrapperMethod, "name", descriptor);
+        descriptor && Object.defineProperty(wrapperMethod, 'name', descriptor);
         Object.defineProperty(consoleInst, methodName, {
-          value: wrapperMethod
+          value: wrapperMethod,
         });
       }
     }
     function getCurrentStackInDEV() {
       var owner = resolveOwner();
-      if (null === owner) return "";
+      if (null === owner) return '';
       try {
-        var info = "";
-        if (owner.owner || "string" !== typeof owner.name) {
+        var info = '';
+        if (owner.owner || 'string' !== typeof owner.name) {
           for (; owner; ) {
             var ownerStack = owner.debugStack;
             if (null != ownerStack) {
@@ -929,16 +929,16 @@
                 Error.prepareStackTrace = void 0;
                 var stack = error.stack;
                 Error.prepareStackTrace = prevPrepareStackTrace;
-                stack.startsWith("Error: react-stack-top-frame\n") &&
+                stack.startsWith('Error: react-stack-top-frame\n') &&
                   (stack = stack.slice(29));
-                var idx = stack.indexOf("\n");
+                var idx = stack.indexOf('\n');
                 -1 !== idx && (stack = stack.slice(idx + 1));
-                idx = stack.indexOf("react_stack_bottom_frame");
-                -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
+                idx = stack.indexOf('react_stack_bottom_frame');
+                -1 !== idx && (idx = stack.lastIndexOf('\n', idx));
                 var JSCompiler_inline_result =
-                  -1 !== idx ? (stack = stack.slice(0, idx)) : "";
+                  -1 !== idx ? (stack = stack.slice(0, idx)) : '';
                 info =
-                  JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
+                  JSCompiler_temp_const + ('\n' + JSCompiler_inline_result);
               }
             } else break;
           }
@@ -951,20 +951,20 @@
             } catch (x) {
               (prefix =
                 ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) ||
-                ""),
+                ''),
                 (suffix =
-                  -1 < x.stack.indexOf("\n    at")
-                    ? " (<anonymous>)"
-                    : -1 < x.stack.indexOf("@")
-                      ? "@unknown:0:0"
-                      : "");
+                  -1 < x.stack.indexOf('\n    at')
+                    ? ' (<anonymous>)'
+                    : -1 < x.stack.indexOf('@')
+                      ? '@unknown:0:0'
+                      : '');
             }
           JSCompiler_inline_result$jscomp$0 =
-            "\n" + prefix + JSCompiler_temp_const + suffix;
+            '\n' + prefix + JSCompiler_temp_const + suffix;
         }
       } catch (x) {
         JSCompiler_inline_result$jscomp$0 =
-          "\nError generating stack: " + x.message + "\n" + x.stack;
+          '\nError generating stack: ' + x.message + '\n' + x.stack;
       }
       return JSCompiler_inline_result$jscomp$0;
     }
@@ -983,14 +983,14 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       if (
         null !== ReactSharedInternalsServer.A &&
         ReactSharedInternalsServer.A !== DefaultAsyncDispatcher
       )
         throw Error(
-          "Currently React only supports one RSC renderer at a time."
+          'Currently React only supports one RSC renderer at a time.',
         );
       ReactSharedInternalsServer.A = DefaultAsyncDispatcher;
       ReactSharedInternalsServer.getCurrentStack = getCurrentStackInDEV;
@@ -1017,7 +1017,7 @@
       this.writtenServerReferences = new Map();
       this.writtenObjects = new WeakMap();
       this.temporaryReferences = temporaryReferences;
-      this.identifierPrefix = identifierPrefix || "";
+      this.identifierPrefix = identifierPrefix || '';
       this.identifierCount = 1;
       this.taintCleanupQueue = [];
       this.onError = void 0 === onError ? defaultErrorHandler : onError;
@@ -1031,9 +1031,9 @@
       this.environmentName =
         void 0 === environmentName
           ? function () {
-              return "Server";
+              return 'Server';
             }
-          : "function" !== typeof environmentName
+          : 'function' !== typeof environmentName
             ? function () {
                 return environmentName;
               }
@@ -1060,7 +1060,7 @@
         type,
         null,
         null,
-        null
+        null,
       );
       pingedTasks.push(model);
     }
@@ -1073,7 +1073,7 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       resetOwnerStackLimit();
       return new RequestInstance(
@@ -1088,7 +1088,7 @@
         temporaryReferences,
         environmentName,
         filterStackFrame,
-        keepDebugAlive
+        keepDebugAlive,
       );
     }
     function createPrerenderRequest(
@@ -1102,7 +1102,7 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       resetOwnerStackLimit();
       return new RequestInstance(
@@ -1117,7 +1117,7 @@
         temporaryReferences,
         environmentName,
         filterStackFrame,
-        keepDebugAlive
+        keepDebugAlive,
       );
     }
     function resolveRequest() {
@@ -1126,17 +1126,17 @@
     function serializeDebugThenable(request, counter, thenable) {
       request.pendingDebugChunks++;
       var id = request.nextChunkId++,
-        ref = "$@" + id.toString(16);
+        ref = '$@' + id.toString(16);
       request.writtenDebugObjects.set(thenable, ref);
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             emitOutlinedDebugModelChunk(request, id, counter, thenable.value),
             ref
           );
-        case "rejected":
+        case 'rejected':
           return (
-            emitErrorChunk(request, id, "", thenable.reason, !0, null), ref
+            emitErrorChunk(request, id, '', thenable.reason, !0, null), ref
           );
       }
       if (request.status === ABORTING)
@@ -1145,7 +1145,7 @@
       if (null !== deferredDebugObjects)
         return (
           deferredDebugObjects.retained.set(id, thenable),
-          (ref = "$Y@" + id.toString(16)),
+          (ref = '$Y@' + id.toString(16)),
           request.writtenDebugObjects.set(thenable, ref),
           ref
         );
@@ -1164,9 +1164,9 @@
             ((cancelled = !0),
             request.status === ABORTING
               ? emitDebugHaltChunk(request, id)
-              : emitErrorChunk(request, id, "", reason, !0, null),
+              : emitErrorChunk(request, id, '', reason, !0, null),
             enqueueFlush(request));
-        }
+        },
       );
       Promise.resolve().then(function () {
         cancelled ||
@@ -1188,9 +1188,9 @@
         function (reason) {
           request.status === ABORTING
             ? emitDebugHaltChunk(request, id)
-            : emitErrorChunk(request, id, "", reason, !0, null);
+            : emitErrorChunk(request, id, '', reason, !0, null);
           enqueueFlush(request);
-        }
+        },
       );
     }
     function serializeThenable(request, task, thenable) {
@@ -1204,30 +1204,30 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             forwardDebugInfoFromThenable(
               request,
               newTask,
               thenable,
               null,
-              null
+              null,
             ),
             (newTask.model = thenable.value),
             pingTask(request, newTask),
             newTask.id
           );
-        case "rejected":
+        case 'rejected':
           return (
             forwardDebugInfoFromThenable(
               request,
               newTask,
               thenable,
               null,
-              null
+              null,
             ),
             erroredTask(request, newTask, thenable.reason),
             newTask.id
@@ -1243,18 +1243,18 @@
                   finishAbortedTask(newTask, request, task)),
               newTask.id
             );
-          "string" !== typeof thenable.status &&
-            ((thenable.status = "pending"),
+          'string' !== typeof thenable.status &&
+            ((thenable.status = 'pending'),
             thenable.then(
               function (fulfilledValue) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "fulfilled"),
+                'pending' === thenable.status &&
+                  ((thenable.status = 'fulfilled'),
                   (thenable.value = fulfilledValue));
               },
               function (error) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "rejected"), (thenable.reason = error));
-              }
+                'pending' === thenable.status &&
+                  ((thenable.status = 'rejected'), (thenable.reason = error));
+              },
             ));
       }
       thenable.then(
@@ -1268,7 +1268,7 @@
             ((newTask.timed = !0),
             erroredTask(request, newTask, reason),
             enqueueFlush(request));
-        }
+        },
       );
       return newTask.id;
     }
@@ -1277,12 +1277,12 @@
         if (0 === streamTask.status)
           if (entry.done)
             (streamTask.status = 1),
-              (entry = streamTask.id.toString(16) + ":C\n"),
+              (entry = streamTask.id.toString(16) + ':C\n'),
               request.completedRegularChunks.push(stringToChunk(entry)),
               request.abortableTasks.delete(streamTask),
               request.cacheController.signal.removeEventListener(
-                "abort",
-                abortStream
+                'abort',
+                abortStream,
               ),
               enqueueFlush(request),
               callOnAllReadyIfReady(request);
@@ -1300,8 +1300,8 @@
       function error(reason) {
         0 === streamTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortStream
+            'abort',
+            abortStream,
           ),
           erroredTask(request, streamTask, reason),
           enqueueFlush(request),
@@ -1310,7 +1310,7 @@
       function abortStream() {
         if (0 === streamTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortStream);
+          signal.removeEventListener('abort', abortStream);
           signal = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(streamTask),
@@ -1323,7 +1323,7 @@
       var supportsBYOB = stream.supportsBYOB;
       if (void 0 === supportsBYOB)
         try {
-          stream.getReader({ mode: "byob" }).releaseLock(), (supportsBYOB = !0);
+          stream.getReader({ mode: 'byob' }).releaseLock(), (supportsBYOB = !0);
         } catch (x) {
           supportsBYOB = !1;
         }
@@ -1338,13 +1338,13 @@
           task.time,
           task.debugOwner,
           task.debugStack,
-          task.debugTask
+          task.debugTask,
         );
       request.pendingChunks++;
       task =
-        streamTask.id.toString(16) + ":" + (supportsBYOB ? "r" : "R") + "\n";
+        streamTask.id.toString(16) + ':' + (supportsBYOB ? 'r' : 'R') + '\n';
       request.completedRegularChunks.push(stringToChunk(task));
-      request.cacheController.signal.addEventListener("abort", abortStream);
+      request.cacheController.signal.addEventListener('abort', abortStream);
       reader.read().then(progress, error);
       return serializeByValueID(streamTask.id);
     }
@@ -1354,15 +1354,15 @@
           if (entry.done) {
             streamTask.status = 1;
             if (void 0 === entry.value)
-              var endStreamRow = streamTask.id.toString(16) + ":C\n";
+              var endStreamRow = streamTask.id.toString(16) + ':C\n';
             else
               try {
                 var chunkId = outlineModel(request, entry.value);
                 endStreamRow =
                   streamTask.id.toString(16) +
-                  ":C" +
+                  ':C' +
                   stringify(serializeByValueID(chunkId)) +
-                  "\n";
+                  '\n';
               } catch (x) {
                 error(x);
                 return;
@@ -1370,8 +1370,8 @@
             request.completedRegularChunks.push(stringToChunk(endStreamRow));
             request.abortableTasks.delete(streamTask);
             request.cacheController.signal.removeEventListener(
-              "abort",
-              abortIterable
+              'abort',
+              abortIterable,
             );
             enqueueFlush(request);
             callOnAllReadyIfReady(request);
@@ -1389,18 +1389,18 @@
       function error(reason) {
         0 === streamTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortIterable
+            'abort',
+            abortIterable,
           ),
           erroredTask(request, streamTask, reason),
           enqueueFlush(request),
-          "function" === typeof iterator.throw &&
+          'function' === typeof iterator.throw &&
             iterator.throw(reason).then(error, error));
       }
       function abortIterable() {
         if (0 === streamTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortIterable);
+          signal.removeEventListener('abort', abortIterable);
           var reason = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(streamTask),
@@ -1408,7 +1408,7 @@
               finishHaltedTask(streamTask, request))
             : (erroredTask(request, streamTask, signal.reason),
               enqueueFlush(request));
-          "function" === typeof iterator.throw &&
+          'function' === typeof iterator.throw &&
             iterator.throw(reason).then(error, error);
         }
       }
@@ -1423,68 +1423,68 @@
           task.time,
           task.debugOwner,
           task.debugStack,
-          task.debugTask
+          task.debugTask,
         );
       (task = iterable._debugInfo) &&
         forwardDebugInfo(request, streamTask, task);
       request.pendingChunks++;
       isIterator =
-        streamTask.id.toString(16) + ":" + (isIterator ? "x" : "X") + "\n";
+        streamTask.id.toString(16) + ':' + (isIterator ? 'x' : 'X') + '\n';
       request.completedRegularChunks.push(stringToChunk(isIterator));
-      request.cacheController.signal.addEventListener("abort", abortIterable);
+      request.cacheController.signal.addEventListener('abort', abortIterable);
       callIteratorInDEV(iterator, progress, error);
       return serializeByValueID(streamTask.id);
     }
     function emitHint(request, code, model) {
       model = stringify(model);
-      code = stringToChunk(":H" + code + model + "\n");
+      code = stringToChunk(':H' + code + model + '\n');
       request.completedHintChunks.push(code);
       enqueueFlush(request);
     }
     function readThenable(thenable) {
-      if ("fulfilled" === thenable.status) return thenable.value;
-      if ("rejected" === thenable.status) throw thenable.reason;
+      if ('fulfilled' === thenable.status) return thenable.value;
+      if ('rejected' === thenable.status) throw thenable.reason;
       throw thenable;
     }
     function createLazyWrapperAroundWakeable(request, task, wakeable) {
       switch (wakeable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             forwardDebugInfoFromThenable(request, task, wakeable, null, null),
             wakeable.value
           );
-        case "rejected":
+        case 'rejected':
           forwardDebugInfoFromThenable(request, task, wakeable, null, null);
           break;
         default:
-          "string" !== typeof wakeable.status &&
-            ((wakeable.status = "pending"),
+          'string' !== typeof wakeable.status &&
+            ((wakeable.status = 'pending'),
             wakeable.then(
               function (fulfilledValue) {
                 forwardDebugInfoFromCurrentContext(request, task, wakeable);
-                "pending" === wakeable.status &&
-                  ((wakeable.status = "fulfilled"),
+                'pending' === wakeable.status &&
+                  ((wakeable.status = 'fulfilled'),
                   (wakeable.value = fulfilledValue));
               },
               function (error) {
                 forwardDebugInfoFromCurrentContext(request, task, wakeable);
-                "pending" === wakeable.status &&
-                  ((wakeable.status = "rejected"), (wakeable.reason = error));
-              }
+                'pending' === wakeable.status &&
+                  ((wakeable.status = 'rejected'), (wakeable.reason = error));
+              },
             ));
       }
       return {
         $$typeof: REACT_LAZY_TYPE,
         _payload: wakeable,
-        _init: readThenable
+        _init: readThenable,
       };
     }
     function callWithDebugContextInDEV(request, task, callback, arg) {
       var componentDebugInfo = {
-        name: "",
+        name: '',
         env: task.environmentName,
         key: null,
-        owner: task.debugOwner
+        owner: task.debugOwner,
       };
       componentDebugInfo.stack =
         null === task.debugStack
@@ -1503,18 +1503,18 @@
       request,
       task,
       Component,
-      result
+      result,
     ) {
       if (
-        "object" !== typeof result ||
+        'object' !== typeof result ||
         null === result ||
         isClientReference(result)
       )
         return result;
-      if ("function" === typeof result.then)
+      if ('function' === typeof result.then)
         return (
           result.then(function (resolvedValue) {
-            "object" === typeof resolvedValue &&
+            'object' === typeof resolvedValue &&
               null !== resolvedValue &&
               resolvedValue.$$typeof === REACT_ELEMENT_TYPE &&
               (resolvedValue._store.validated = 1);
@@ -1527,13 +1527,13 @@
         var multiShot = _defineProperty({}, Symbol.iterator, function () {
           var iterator = iteratorFn.call(result);
           iterator !== result ||
-            ("[object GeneratorFunction]" ===
+            ('[object GeneratorFunction]' ===
               Object.prototype.toString.call(Component) &&
-              "[object Generator]" ===
+              '[object Generator]' ===
                 Object.prototype.toString.call(result)) ||
             callWithDebugContextInDEV(request, task, function () {
               console.error(
-                "Returning an Iterator from a Server Component is not supported since it cannot be looped over more than once. "
+                'Returning an Iterator from a Server Component is not supported since it cannot be looped over more than once. ',
               );
             });
           return iterator;
@@ -1541,20 +1541,20 @@
         multiShot._debugInfo = result._debugInfo;
         return multiShot;
       }
-      return "function" !== typeof result[ASYNC_ITERATOR] ||
-        ("function" === typeof ReadableStream &&
+      return 'function' !== typeof result[ASYNC_ITERATOR] ||
+        ('function' === typeof ReadableStream &&
           result instanceof ReadableStream)
         ? result
         : ((multiShot = _defineProperty({}, ASYNC_ITERATOR, function () {
             var iterator = result[ASYNC_ITERATOR]();
             iterator !== result ||
-              ("[object AsyncGeneratorFunction]" ===
+              ('[object AsyncGeneratorFunction]' ===
                 Object.prototype.toString.call(Component) &&
-                "[object AsyncGenerator]" ===
+                '[object AsyncGenerator]' ===
                   Object.prototype.toString.call(result)) ||
               callWithDebugContextInDEV(request, task, function () {
                 console.error(
-                  "Returning an AsyncIterator from a Server Component is not supported since it cannot be looped over more than once. "
+                  'Returning an AsyncIterator from a Server Component is not supported since it cannot be looped over more than once. ',
                 );
               });
             return iterator;
@@ -1568,7 +1568,7 @@
       key,
       Component,
       props,
-      validated
+      validated,
     ) {
       var prevThenableState = task.thenableState;
       task.thenableState = null;
@@ -1577,14 +1577,14 @@
           var componentDebugInfo = prevThenableState._componentDebugInfo;
         else {
           var componentDebugID = task.id;
-          componentDebugInfo = Component.displayName || Component.name || "";
+          componentDebugInfo = Component.displayName || Component.name || '';
           var componentEnv = (0, request.environmentName)();
           request.pendingChunks++;
           componentDebugInfo = {
             name: componentDebugInfo,
             env: componentEnv,
             key: key,
-            owner: task.debugOwner
+            owner: task.debugOwner,
           };
           componentDebugInfo.stack =
             null === task.debugStack
@@ -1611,14 +1611,14 @@
       currentComponentDebugInfo = componentDebugInfo;
       props = task.debugTask
         ? task.debugTask.run(
-            callComponentInDEV.bind(null, Component, props, componentDebugInfo)
+            callComponentInDEV.bind(null, Component, props, componentDebugInfo),
           )
         : callComponentInDEV(Component, props, componentDebugInfo);
       if (request.status === ABORTING)
         throw (
-          ("object" !== typeof props ||
+          ('object' !== typeof props ||
             null === props ||
-            "function" !== typeof props.then ||
+            'function' !== typeof props.then ||
             isClientReference(props) ||
             props.then(voidHandler, voidHandler),
           null)
@@ -1636,13 +1636,13 @@
             task,
             validated[componentDebugID],
             componentDebugInfo,
-            prevThenableState[componentDebugID]
+            prevThenableState[componentDebugID],
           );
       props = processServerComponentReturnValue(
         request,
         task,
         Component,
-        props
+        props,
       );
       task.debugOwner = componentDebugInfo;
       task.debugStack = null;
@@ -1650,9 +1650,9 @@
       Component = task.keyPath;
       componentDebugInfo = task.implicitSlot;
       null !== key
-        ? (task.keyPath = null === Component ? key : Component + "," + key)
+        ? (task.keyPath = null === Component ? key : Component + ',' + key)
         : null === Component && (task.implicitSlot = !0);
-      request = renderModelDestructive(request, task, emptyRoot, "", props);
+      request = renderModelDestructive(request, task, emptyRoot, '', props);
       task.keyPath = Component;
       task.implicitSlot = componentDebugInfo;
       return request;
@@ -1661,8 +1661,8 @@
       function logKeyError() {
         console.error(
           'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
-          "",
-          ""
+          '',
+          '',
         );
       }
       key = request.didWarnForKey;
@@ -1674,7 +1674,12 @@
       }
       debugTask
         ? debugTask.run(
-            callComponentInDEV.bind(null, logKeyError, null, componentDebugInfo)
+            callComponentInDEV.bind(
+              null,
+              logKeyError,
+              null,
+              componentDebugInfo,
+            ),
           )
         : callComponentInDEV(logKeyError, null, componentDebugInfo);
     }
@@ -1682,7 +1687,7 @@
       for (var i = 0; i < children.length; i++) {
         var child = children[i];
         null === child ||
-          "object" !== typeof child ||
+          'object' !== typeof child ||
           child.$$typeof !== REACT_ELEMENT_TYPE ||
           null !== child.key ||
           child._store.validated ||
@@ -1697,7 +1702,7 @@
             { children: children },
             null,
             null,
-            0
+            0,
           ]),
           task.implicitSlot ? [request] : request
         );
@@ -1718,7 +1723,7 @@
             { children: children },
             null,
             null,
-            0
+            0,
           ]),
           task.implicitSlot ? [request] : request
         );
@@ -1736,7 +1741,7 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       pingTask(request, task);
       return serializeLazyID(task.id);
@@ -1752,7 +1757,7 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       retryTask(request, task);
       return 1 === task.status
@@ -1762,14 +1767,14 @@
     function renderElement(request, task, type, key, ref, props, validated) {
       if (null !== ref && void 0 !== ref)
         throw Error(
-          "Refs cannot be used in Server Components, nor passed to Client Components."
+          'Refs cannot be used in Server Components, nor passed to Client Components.',
         );
       jsxPropsParents.set(props, type);
-      "object" === typeof props.children &&
+      'object' === typeof props.children &&
         null !== props.children &&
         jsxChildrenParents.set(props.children, type);
       if (
-        "function" !== typeof type ||
+        'function' !== typeof type ||
         isClientReference(type) ||
         type.$$typeof === TEMPORARY_REFERENCE_TAG
       ) {
@@ -1777,7 +1782,7 @@
           return (
             2 === validated &&
               ((validated = {
-                name: "Fragment",
+                name: 'Fragment',
                 env: (0, request.environmentName)(),
                 key: key,
                 owner: task.debugOwner,
@@ -1786,11 +1791,11 @@
                     ? null
                     : filterStackTrace(
                         request,
-                        parseStackTrace(task.debugStack, 1)
+                        parseStackTrace(task.debugStack, 1),
                       ),
                 props: props,
                 debugStack: task.debugStack,
-                debugTask: task.debugTask
+                debugTask: task.debugTask,
               }),
               warnForMissingKey(request, key, validated, task.debugTask)),
             (validated = task.implicitSlot),
@@ -1799,15 +1804,15 @@
               request,
               task,
               emptyRoot,
-              "",
-              props.children
+              '',
+              props.children,
             )),
             (task.implicitSlot = validated),
             request
           );
         if (
           null != type &&
-          "object" === typeof type &&
+          'object' === typeof type &&
           !isClientReference(type)
         )
           switch (type.$$typeof) {
@@ -1821,7 +1826,7 @@
                 key,
                 ref,
                 props,
-                validated
+                validated,
               );
             case REACT_FORWARD_REF_TYPE:
               return renderFunctionComponent(
@@ -1830,7 +1835,7 @@
                 key,
                 type.render,
                 props,
-                validated
+                validated,
               );
             case REACT_MEMO_TYPE:
               return renderElement(
@@ -1840,12 +1845,12 @@
                 key,
                 ref,
                 props,
-                validated
+                validated,
               );
             case REACT_ELEMENT_TYPE:
               type._store.validated = 1;
           }
-        else if ("string" === typeof type) {
+        else if ('string' === typeof type) {
           ref = task.formatContext;
           var newFormatContext = getChildFormatContext(ref, type, props);
           ref !== newFormatContext &&
@@ -1853,7 +1858,7 @@
             outlineModelWithFormatContext(
               request,
               props.children,
-              newFormatContext
+              newFormatContext,
             );
         }
       } else
@@ -1863,22 +1868,22 @@
           key,
           type,
           props,
-          validated
+          validated,
         );
       ref = task.keyPath;
-      null === key ? (key = ref) : null !== ref && (key = ref + "," + key);
+      null === key ? (key = ref) : null !== ref && (key = ref + ',' + key);
       newFormatContext = null;
       ref = task.debugOwner;
       null !== ref && outlineComponentInfo(request, ref);
       if (null !== task.debugStack) {
         newFormatContext = filterStackTrace(
           request,
-          parseStackTrace(task.debugStack, 1)
+          parseStackTrace(task.debugStack, 1),
         );
         var id = outlineDebugModel(
           request,
           { objectLimit: 2 * newFormatContext.length + 1 },
-          newFormatContext
+          newFormatContext,
         );
         request.writtenObjects.set(newFormatContext, serializeByValueID(id));
       }
@@ -1889,7 +1894,7 @@
         props,
         ref,
         newFormatContext,
-        validated
+        validated,
       ];
       task = task.implicitSlot && null !== key ? [request] : request;
       return task;
@@ -1918,11 +1923,11 @@
       lastTimestamp,
       debugOwner,
       debugStack,
-      debugTask
+      debugTask,
     ) {
       request.pendingChunks++;
       var id = request.nextChunkId++;
-      "object" !== typeof model ||
+      'object' !== typeof model ||
         null === model ||
         null !== keyPath ||
         implicitSlot ||
@@ -1940,31 +1945,31 @@
         toJSON: function (parentPropertyName, value) {
           var parent = this,
             originalValue = parent[parentPropertyName];
-          "object" !== typeof originalValue ||
+          'object' !== typeof originalValue ||
             originalValue === value ||
             originalValue instanceof Date ||
             callWithDebugContextInDEV(request, task, function () {
-              "Object" !== objectName(originalValue)
-                ? "string" === typeof jsxChildrenParents.get(parent)
+              'Object' !== objectName(originalValue)
+                ? 'string' === typeof jsxChildrenParents.get(parent)
                   ? console.error(
-                      "%s objects cannot be rendered as text children. Try formatting it using toString().%s",
+                      '%s objects cannot be rendered as text children. Try formatting it using toString().%s',
                       objectName(originalValue),
-                      describeObjectForErrorMessage(parent, parentPropertyName)
+                      describeObjectForErrorMessage(parent, parentPropertyName),
                     )
                   : console.error(
-                      "Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s",
+                      'Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s',
                       objectName(originalValue),
-                      describeObjectForErrorMessage(parent, parentPropertyName)
+                      describeObjectForErrorMessage(parent, parentPropertyName),
                     )
                 : console.error(
-                    "Only plain objects can be passed to Client Components from Server Components. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s",
-                    describeObjectForErrorMessage(parent, parentPropertyName)
+                    'Only plain objects can be passed to Client Components from Server Components. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s',
+                    describeObjectForErrorMessage(parent, parentPropertyName),
                   );
             });
           return renderModel(request, task, parent, parentPropertyName, value);
         },
         thenableState: null,
-        timed: !1
+        timed: !1,
       };
       task.time = lastTimestamp;
       task.environmentName = request.environmentName();
@@ -1975,10 +1980,10 @@
       return task;
     }
     function serializeByValueID(id) {
-      return "$" + id.toString(16);
+      return '$' + id.toString(16);
     }
     function serializeLazyID(id) {
-      return "$L" + id.toString(16);
+      return '$L' + id.toString(16);
     }
     function serializeDeferredObject(request, value) {
       var deferredDebugObjects = request.deferredDebugObjects;
@@ -1987,50 +1992,50 @@
           (request = request.nextChunkId++),
           deferredDebugObjects.existing.set(value, request),
           deferredDebugObjects.retained.set(request, value),
-          "$Y" + request.toString(16))
-        : "$Y";
+          '$Y' + request.toString(16))
+        : '$Y';
     }
     function serializeNumber(number) {
       return Number.isFinite(number)
         ? 0 === number && -Infinity === 1 / number
-          ? "$-0"
+          ? '$-0'
           : number
         : Infinity === number
-          ? "$Infinity"
+          ? '$Infinity'
           : -Infinity === number
-            ? "$-Infinity"
-            : "$NaN";
+            ? '$-Infinity'
+            : '$NaN';
     }
     function encodeReferenceChunk(request, id, reference) {
       request = stringify(reference);
-      id = id.toString(16) + ":" + request + "\n";
+      id = id.toString(16) + ':' + request + '\n';
       return stringToChunk(id);
     }
     function serializeClientReference(
       request,
       parent,
       parentPropertyName,
-      clientReference
+      clientReference,
     ) {
       var clientReferenceKey = clientReference.$$async
-          ? clientReference.$$id + "#async"
+          ? clientReference.$$id + '#async'
           : clientReference.$$id,
         writtenClientReferences = request.writtenClientReferences,
         existingId = writtenClientReferences.get(clientReferenceKey);
       if (void 0 !== existingId)
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(existingId)
           : serializeByValueID(existingId);
       try {
         var clientReferenceMetadata = resolveClientReferenceMetadata(
           request.bundlerConfig,
-          clientReference
+          clientReference,
         );
         request.pendingChunks++;
         var importId = request.nextChunkId++;
         emitImportChunk(request, importId, clientReferenceMetadata, !1);
         writtenClientReferences.set(clientReferenceKey, importId);
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(importId)
           : serializeByValueID(importId);
       } catch (x) {
@@ -2047,26 +2052,26 @@
       request,
       parent,
       parentPropertyName,
-      clientReference
+      clientReference,
     ) {
       var existingId = request.writtenClientReferences.get(
         clientReference.$$async
-          ? clientReference.$$id + "#async"
-          : clientReference.$$id
+          ? clientReference.$$id + '#async'
+          : clientReference.$$id,
       );
       if (void 0 !== existingId)
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(existingId)
           : serializeByValueID(existingId);
       try {
         var clientReferenceMetadata = resolveClientReferenceMetadata(
           request.bundlerConfig,
-          clientReference
+          clientReference,
         );
         request.pendingDebugChunks++;
         var importId = request.nextChunkId++;
         emitImportChunk(request, importId, clientReferenceMetadata, !0);
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(importId)
           : serializeByValueID(importId);
       } catch (x) {
@@ -2093,7 +2098,7 @@
         performance.now(),
         null,
         null,
-        null
+        null,
       );
       retryTask(request, value);
       return value.id;
@@ -2101,7 +2106,7 @@
     function serializeServerReference(request, serverReference) {
       var writtenServerReferences = request.writtenServerReferences,
         existingId = writtenServerReferences.get(serverReference);
-      if (void 0 !== existingId) return "$F" + existingId.toString(16);
+      if (void 0 !== existingId) return '$F' + existingId.toString(16);
       existingId = serverReference.$$bound;
       existingId = null === existingId ? null : Promise.resolve(existingId);
       var id = serverReference.$$id,
@@ -2118,16 +2123,16 @@
               id: id,
               bound: existingId,
               name:
-                "function" === typeof serverReference
+                'function' === typeof serverReference
                   ? serverReference.name
-                  : "",
+                  : '',
               env: (0, request.environmentName)(),
-              location: location
+              location: location,
             }
           : { id: id, bound: existingId };
       request = outlineModel(request, existingId);
       writtenServerReferences.set(serverReference, request);
-      return "$F" + request.toString(16);
+      return '$F' + request.toString(16);
     }
     function serializeLargeTextString(request, text) {
       request.pendingChunks++;
@@ -2137,15 +2142,15 @@
     }
     function serializeMap(request, map) {
       map = Array.from(map);
-      return "$Q" + outlineModel(request, map).toString(16);
+      return '$Q' + outlineModel(request, map).toString(16);
     }
     function serializeFormData(request, formData) {
       formData = Array.from(formData.entries());
-      return "$K" + outlineModel(request, formData).toString(16);
+      return '$K' + outlineModel(request, formData).toString(16);
     }
     function serializeSet(request, set) {
       set = Array.from(set);
-      return "$W" + outlineModel(request, set).toString(16);
+      return '$W' + outlineModel(request, set).toString(16);
     }
     function serializeTypedArray(request, tag, typedArray) {
       request.pendingChunks++;
@@ -2166,7 +2171,7 @@
             request,
             id,
             { objectLimit: model.length + 2 },
-            model
+            model,
           ),
             enqueueFlush(request);
         else
@@ -2175,7 +2180,7 @@
           );
       }
       function error(reason) {
-        emitErrorChunk(request, id, "", reason, !0, null);
+        emitErrorChunk(request, id, '', reason, !0, null);
         enqueueFlush(request);
         reader.cancel(reason).then(noop, noop);
       }
@@ -2184,15 +2189,15 @@
       request.pendingDebugChunks++;
       var id = request.nextChunkId++;
       reader.read().then(progress).catch(error);
-      return "$B" + id.toString(16);
+      return '$B' + id.toString(16);
     }
     function serializeBlob(request, blob) {
       function progress(entry) {
         if (0 === newTask.status)
           if (entry.done)
             request.cacheController.signal.removeEventListener(
-              "abort",
-              abortBlob
+              'abort',
+              abortBlob,
             ),
               pingTask(request, newTask);
           else
@@ -2203,8 +2208,8 @@
       function error(reason) {
         0 === newTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortBlob
+            'abort',
+            abortBlob,
           ),
           erroredTask(request, newTask, reason),
           enqueueFlush(request),
@@ -2213,7 +2218,7 @@
       function abortBlob() {
         if (0 === newTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortBlob);
+          signal.removeEventListener('abort', abortBlob);
           signal = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(newTask),
@@ -2234,12 +2239,12 @@
           performance.now(),
           null,
           null,
-          null
+          null,
         ),
         reader = blob.stream().getReader();
-      request.cacheController.signal.addEventListener("abort", abortBlob);
+      request.cacheController.signal.addEventListener('abort', abortBlob);
       reader.read().then(progress).catch(error);
-      return "$B" + newTask.id.toString(16);
+      return '$B' + newTask.id.toString(16);
     }
     function renderModel(request, task, parent, key, value) {
       serializedSize += key.length;
@@ -2250,7 +2255,7 @@
       } catch (thrownValue) {
         parent = task.model;
         parent =
-          "object" === typeof parent &&
+          'object' === typeof parent &&
           null !== parent &&
           (parent.$$typeof === REACT_ELEMENT_TYPE ||
             parent.$$typeof === REACT_LAZY_TYPE);
@@ -2272,9 +2277,9 @@
             ? getSuspendedThenable()
             : thrownValue;
         if (
-          "object" === typeof key &&
+          'object' === typeof key &&
           null !== key &&
-          "function" === typeof key.then
+          'function' === typeof key.then
         )
           return (
             (request = createTask(
@@ -2287,7 +2292,7 @@
               task.time,
               task.debugOwner,
               task.debugStack,
-              task.debugTask
+              task.debugTask,
             )),
             (value = request.ping),
             key.then(value, value),
@@ -2309,7 +2314,7 @@
           prevImplicitSlot,
           key,
           !1,
-          task.debugOwner
+          task.debugOwner,
         );
         return parent
           ? serializeLazyID(prevKeyPath)
@@ -2321,12 +2326,12 @@
       task,
       parent,
       parentPropertyName,
-      value
+      value,
     ) {
       task.model = value;
-      if (value === REACT_ELEMENT_TYPE) return "$";
+      if (value === REACT_ELEMENT_TYPE) return '$';
       if (null === value) return null;
-      if ("object" === typeof value) {
+      if ('object' === typeof value) {
         switch (value.$$typeof) {
           case REACT_ELEMENT_TYPE:
             var elementReference = null,
@@ -2337,11 +2342,11 @@
                 if (modelRoot === value) modelRoot = null;
                 else return _existingReference;
               else
-                -1 === parentPropertyName.indexOf(":") &&
+                -1 === parentPropertyName.indexOf(':') &&
                   ((_existingReference = _writtenObjects.get(parent)),
                   void 0 !== _existingReference &&
                     ((elementReference =
-                      _existingReference + ":" + parentPropertyName),
+                      _existingReference + ':' + parentPropertyName),
                     _writtenObjects.set(value, elementReference)));
             }
             if (serializedSize > MAX_ROW_SIZE) return deferTask(request, task);
@@ -2360,13 +2365,13 @@
               void 0 === value._debugStack ||
               void 0 === value._debugTask
             ) {
-              var key = "";
+              var key = '';
               null !== value.key && (key = ' key="' + value.key + '"');
               console.error(
-                "Attempted to render <%s%s> without development properties. This is not supported. It can happen if:\n- The element is created with a production version of React but rendered in development.\n- The element was cloned with a custom function instead of `React.cloneElement`.\nThe props of this element may help locate this element: %o",
+                'Attempted to render <%s%s> without development properties. This is not supported. It can happen if:\n- The element is created with a production version of React but rendered in development.\n- The element was cloned with a custom function instead of `React.cloneElement`.\nThe props of this element may help locate this element: %o',
                 value.type,
                 key,
-                value.props
+                value.props,
               );
             }
             request = renderElement(
@@ -2376,9 +2381,9 @@
               value.key,
               refProp,
               _existingReference,
-              value._store.validated
+              value._store.validated,
             );
-            "object" === typeof request &&
+            'object' === typeof request &&
               null !== request &&
               null !== elementReference &&
               (_writtenObjects.has(request) ||
@@ -2397,12 +2402,12 @@
               request,
               task,
               emptyRoot,
-              "",
-              elementReference
+              '',
+              elementReference,
             );
           case REACT_LEGACY_ELEMENT_TYPE:
             throw Error(
-              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
+              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.',
             );
         }
         if (isClientReference(value))
@@ -2410,26 +2415,26 @@
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (
           void 0 !== request.temporaryReferences &&
           ((elementReference = request.temporaryReferences.get(value)),
           void 0 !== elementReference)
         )
-          return "$T" + elementReference;
+          return '$T' + elementReference;
         elementReference = request.writtenObjects;
         _writtenObjects = elementReference.get(value);
-        if ("function" === typeof value.then) {
+        if ('function' === typeof value.then) {
           if (void 0 !== _writtenObjects) {
             if (null !== task.keyPath || task.implicitSlot)
               return (
-                "$@" + serializeThenable(request, task, value).toString(16)
+                '$@' + serializeThenable(request, task, value).toString(16)
               );
             if (modelRoot === value) modelRoot = null;
             else return _writtenObjects;
           }
-          request = "$@" + serializeThenable(request, task, value).toString(16);
+          request = '$@' + serializeThenable(request, task, value).toString(16);
           elementReference.set(value, request);
           return request;
         }
@@ -2440,81 +2445,81 @@
             modelRoot = null;
           } else return _writtenObjects;
         else if (
-          -1 === parentPropertyName.indexOf(":") &&
+          -1 === parentPropertyName.indexOf(':') &&
           ((_writtenObjects = elementReference.get(parent)),
           void 0 !== _writtenObjects)
         ) {
           _existingReference = parentPropertyName;
           if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
             switch (parentPropertyName) {
-              case "1":
-                _existingReference = "type";
+              case '1':
+                _existingReference = 'type';
                 break;
-              case "2":
-                _existingReference = "key";
+              case '2':
+                _existingReference = 'key';
                 break;
-              case "3":
-                _existingReference = "props";
+              case '3':
+                _existingReference = 'props';
                 break;
-              case "4":
-                _existingReference = "_owner";
+              case '4':
+                _existingReference = '_owner';
             }
           elementReference.set(
             value,
-            _writtenObjects + ":" + _existingReference
+            _writtenObjects + ':' + _existingReference,
           );
         }
         if (isArrayImpl(value)) return renderFragment(request, task, value);
         if (value instanceof Map) return serializeMap(request, value);
         if (value instanceof Set) return serializeSet(request, value);
-        if ("function" === typeof FormData && value instanceof FormData)
+        if ('function' === typeof FormData && value instanceof FormData)
           return serializeFormData(request, value);
         if (value instanceof Error) return serializeErrorValue(request, value);
         if (value instanceof ArrayBuffer)
-          return serializeTypedArray(request, "A", new Uint8Array(value));
+          return serializeTypedArray(request, 'A', new Uint8Array(value));
         if (value instanceof Int8Array)
-          return serializeTypedArray(request, "O", value);
+          return serializeTypedArray(request, 'O', value);
         if (value instanceof Uint8Array)
-          return serializeTypedArray(request, "o", value);
+          return serializeTypedArray(request, 'o', value);
         if (value instanceof Uint8ClampedArray)
-          return serializeTypedArray(request, "U", value);
+          return serializeTypedArray(request, 'U', value);
         if (value instanceof Int16Array)
-          return serializeTypedArray(request, "S", value);
+          return serializeTypedArray(request, 'S', value);
         if (value instanceof Uint16Array)
-          return serializeTypedArray(request, "s", value);
+          return serializeTypedArray(request, 's', value);
         if (value instanceof Int32Array)
-          return serializeTypedArray(request, "L", value);
+          return serializeTypedArray(request, 'L', value);
         if (value instanceof Uint32Array)
-          return serializeTypedArray(request, "l", value);
+          return serializeTypedArray(request, 'l', value);
         if (value instanceof Float32Array)
-          return serializeTypedArray(request, "G", value);
+          return serializeTypedArray(request, 'G', value);
         if (value instanceof Float64Array)
-          return serializeTypedArray(request, "g", value);
+          return serializeTypedArray(request, 'g', value);
         if (value instanceof BigInt64Array)
-          return serializeTypedArray(request, "M", value);
+          return serializeTypedArray(request, 'M', value);
         if (value instanceof BigUint64Array)
-          return serializeTypedArray(request, "m", value);
+          return serializeTypedArray(request, 'm', value);
         if (value instanceof DataView)
-          return serializeTypedArray(request, "V", value);
-        if ("function" === typeof Blob && value instanceof Blob)
+          return serializeTypedArray(request, 'V', value);
+        if ('function' === typeof Blob && value instanceof Blob)
           return serializeBlob(request, value);
         if ((elementReference = getIteratorFn(value)))
           return (
             (elementReference = elementReference.call(value)),
             elementReference === value
-              ? "$i" +
+              ? '$i' +
                 outlineModel(request, Array.from(elementReference)).toString(16)
               : renderFragment(request, task, Array.from(elementReference))
           );
         if (
-          "function" === typeof ReadableStream &&
+          'function' === typeof ReadableStream &&
           value instanceof ReadableStream
         )
           return serializeReadableStream(request, task, value);
         elementReference = value[ASYNC_ITERATOR];
-        if ("function" === typeof elementReference)
+        if ('function' === typeof elementReference)
           return renderAsyncFragment(request, task, value, elementReference);
-        if (value instanceof Date) return "$D" + value.toJSON();
+        if (value instanceof Date) return '$D' + value.toJSON();
         elementReference = getPrototypeOf(value);
         if (
           elementReference !== ObjectPrototype &&
@@ -2522,22 +2527,22 @@
             null !== getPrototypeOf(elementReference))
         )
           throw Error(
-            "Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported." +
-              describeObjectForErrorMessage(parent, parentPropertyName)
+            'Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.' +
+              describeObjectForErrorMessage(parent, parentPropertyName),
           );
-        if ("Object" !== objectName(value))
+        if ('Object' !== objectName(value))
           callWithDebugContextInDEV(request, task, function () {
             console.error(
-              "Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s",
+              'Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s',
               objectName(value),
-              describeObjectForErrorMessage(parent, parentPropertyName)
+              describeObjectForErrorMessage(parent, parentPropertyName),
             );
           });
         else if (!isSimpleObject(value))
           callWithDebugContextInDEV(request, task, function () {
             console.error(
-              "Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.%s",
-              describeObjectForErrorMessage(parent, parentPropertyName)
+              'Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.%s',
+              describeObjectForErrorMessage(parent, parentPropertyName),
             );
           });
         else if (Object.getOwnPropertySymbols) {
@@ -2545,36 +2550,36 @@
           0 < symbols.length &&
             callWithDebugContextInDEV(request, task, function () {
               console.error(
-                "Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like %s are not supported.%s",
+                'Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like %s are not supported.%s',
                 symbols[0].description,
-                describeObjectForErrorMessage(parent, parentPropertyName)
+                describeObjectForErrorMessage(parent, parentPropertyName),
               );
             });
         }
         return value;
       }
-      if ("string" === typeof value)
+      if ('string' === typeof value)
         return (
           (serializedSize += value.length),
-          "Z" === value[value.length - 1] &&
+          'Z' === value[value.length - 1] &&
           parent[parentPropertyName] instanceof Date
-            ? "$D" + value
+            ? '$D' + value
             : 1024 <= value.length && null !== byteLengthOfChunk
               ? serializeLargeTextString(request, value)
-              : "$" === value[0]
-                ? "$" + value
+              : '$' === value[0]
+                ? '$' + value
                 : value
         );
-      if ("boolean" === typeof value) return value;
-      if ("number" === typeof value) return serializeNumber(value);
-      if ("undefined" === typeof value) return "$undefined";
-      if ("function" === typeof value) {
+      if ('boolean' === typeof value) return value;
+      if ('number' === typeof value) return serializeNumber(value);
+      if ('undefined' === typeof value) return '$undefined';
+      if ('function' === typeof value) {
         if (isClientReference(value))
           return serializeClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (value.$$typeof === SERVER_REFERENCE_TAG)
           return serializeServerReference(request, value);
@@ -2583,38 +2588,38 @@
           ((request = request.temporaryReferences.get(value)),
           void 0 !== request)
         )
-          return "$T" + request;
+          return '$T' + request;
         if (value.$$typeof === TEMPORARY_REFERENCE_TAG)
           throw Error(
-            "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+            'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
           );
         if (/^on[A-Z]/.test(parentPropertyName))
           throw Error(
-            "Event handlers cannot be passed to Client Component props." +
+            'Event handlers cannot be passed to Client Component props.' +
               describeObjectForErrorMessage(parent, parentPropertyName) +
-              "\nIf you need interactivity, consider converting part of this to a Client Component."
+              '\nIf you need interactivity, consider converting part of this to a Client Component.',
           );
         if (
           jsxChildrenParents.has(parent) ||
-          (jsxPropsParents.has(parent) && "children" === parentPropertyName)
+          (jsxPropsParents.has(parent) && 'children' === parentPropertyName)
         )
           throw (
-            ((request = value.displayName || value.name || "Component"),
+            ((request = value.displayName || value.name || 'Component'),
             Error(
-              "Functions are not valid as a child of Client Components. This may happen if you return " +
+              'Functions are not valid as a child of Client Components. This may happen if you return ' +
                 request +
-                " instead of <" +
+                ' instead of <' +
                 request +
-                " /> from render. Or maybe you meant to call this function rather than return it." +
-                describeObjectForErrorMessage(parent, parentPropertyName)
+                ' /> from render. Or maybe you meant to call this function rather than return it.' +
+                describeObjectForErrorMessage(parent, parentPropertyName),
             ))
           );
         throw Error(
           'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.' +
-            describeObjectForErrorMessage(parent, parentPropertyName)
+            describeObjectForErrorMessage(parent, parentPropertyName),
         );
       }
-      if ("symbol" === typeof value) {
+      if ('symbol' === typeof value) {
         task = request.writtenSymbols;
         elementReference = task.get(value);
         if (void 0 !== elementReference)
@@ -2622,9 +2627,9 @@
         elementReference = value.description;
         if (Symbol.for(elementReference) !== value)
           throw Error(
-            "Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" +
-              (value.description + ") cannot be found among global symbols.") +
-              describeObjectForErrorMessage(parent, parentPropertyName)
+            'Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(' +
+              (value.description + ') cannot be found among global symbols.') +
+              describeObjectForErrorMessage(parent, parentPropertyName),
           );
         request.pendingChunks++;
         _writtenObjects = request.nextChunkId++;
@@ -2632,12 +2637,12 @@
         task.set(value, _writtenObjects);
         return serializeByValueID(_writtenObjects);
       }
-      if ("bigint" === typeof value) return "$n" + value.toString(10);
+      if ('bigint' === typeof value) return '$n' + value.toString(10);
       throw Error(
-        "Type " +
+        'Type ' +
           typeof value +
-          " is not supported in Client Component props." +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+          ' is not supported in Client Component props.' +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     }
     function logRecoverableError(request, error, task) {
@@ -2652,13 +2657,13 @@
       } finally {
         currentRequest = prevRequest;
       }
-      if (null != errorDigest && "string" !== typeof errorDigest)
+      if (null != errorDigest && 'string' !== typeof errorDigest)
         throw Error(
           'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
             typeof errorDigest +
-            '" instead'
+            '" instead',
         );
-      return errorDigest || "";
+      return errorDigest || '';
     }
     function fatalError(request, error) {
       var onFatalError = request.onFatalError;
@@ -2668,35 +2673,35 @@
           closeWithError(request.destination, error))
         : ((request.status = 13), (request.fatalError = error));
       request.cacheController.abort(
-        Error("The render was aborted due to a fatal error.", { cause: error })
+        Error('The render was aborted due to a fatal error.', { cause: error }),
       );
     }
     function serializeErrorValue(request, error) {
-      var name = "Error",
+      var name = 'Error',
         env = (0, request.environmentName)();
       try {
         name = error.name;
         var message = String(error.message);
         var stack = filterStackTrace(request, parseStackTrace(error, 0));
         var errorEnv = error.environmentName;
-        "string" === typeof errorEnv && (env = errorEnv);
+        'string' === typeof errorEnv && (env = errorEnv);
       } catch (x) {
         (message =
-          "An error occurred but serializing the error message failed."),
+          'An error occurred but serializing the error message failed.'),
           (stack = []);
       }
       return (
-        "$Z" +
+        '$Z' +
         outlineModel(request, {
           name: name,
           message: message,
           stack: stack,
-          env: env
+          env: env,
         }).toString(16)
       );
     }
     function emitErrorChunk(request, id, digest, error, debug, owner) {
-      var name = "Error",
+      var name = 'Error',
         env = (0, request.environmentName)();
       try {
         if (error instanceof Error) {
@@ -2704,16 +2709,16 @@
           var message = String(error.message);
           var stack = filterStackTrace(request, parseStackTrace(error, 0));
           var errorEnv = error.environmentName;
-          "string" === typeof errorEnv && (env = errorEnv);
+          'string' === typeof errorEnv && (env = errorEnv);
         } else
           (message =
-            "object" === typeof error && null !== error
+            'object' === typeof error && null !== error
               ? describeObjectForErrorMessage(error)
               : String(error)),
             (stack = []);
       } catch (x) {
         (message =
-          "An error occurred but serializing the error message failed."),
+          'An error occurred but serializing the error message failed.'),
           (stack = []);
       }
       error = null == owner ? null : outlineComponentInfo(request, owner);
@@ -2723,9 +2728,9 @@
         message: message,
         stack: stack,
         env: env,
-        owner: error
+        owner: error,
       };
-      id = id.toString(16) + ":E" + stringify(digest) + "\n";
+      id = id.toString(16) + ':E' + stringify(digest) + '\n';
       id = stringToChunk(id);
       debug
         ? request.completedDebugChunks.push(id)
@@ -2733,23 +2738,23 @@
     }
     function emitImportChunk(request, id, clientReferenceMetadata, debug) {
       clientReferenceMetadata = stringify(clientReferenceMetadata);
-      id = id.toString(16) + ":I" + clientReferenceMetadata + "\n";
+      id = id.toString(16) + ':I' + clientReferenceMetadata + '\n';
       id = stringToChunk(id);
       debug
         ? request.completedDebugChunks.push(id)
         : request.completedImportChunks.push(id);
     }
     function emitSymbolChunk(request, id, name) {
-      id = encodeReferenceChunk(request, id, "$S" + name);
+      id = encodeReferenceChunk(request, id, '$S' + name);
       request.completedImportChunks.push(id);
     }
     function emitModelChunk(request, id, json) {
-      id = id.toString(16) + ":" + json + "\n";
+      id = id.toString(16) + ':' + json + '\n';
       id = stringToChunk(id);
       request.completedRegularChunks.push(id);
     }
     function emitDebugHaltChunk(request, id) {
-      id = id.toString(16) + ":\n";
+      id = id.toString(16) + ':\n';
       id = stringToChunk(id);
       request.completedDebugChunks.push(id);
     }
@@ -2757,12 +2762,12 @@
       var json = serializeDebugModel(request, 500, debugInfo);
       null !== request.debugDestination
         ? ((debugInfo = request.nextChunkId++),
-          (json = debugInfo.toString(16) + ":" + json + "\n"),
+          (json = debugInfo.toString(16) + ':' + json + '\n'),
           request.pendingDebugChunks++,
           request.completedDebugChunks.push(stringToChunk(json)),
           (id = id.toString(16) + ':D"$' + debugInfo.toString(16) + '"\n'),
           request.completedRegularChunks.push(stringToChunk(id)))
-        : ((id = id.toString(16) + ":D" + json + "\n"),
+        : ((id = id.toString(16) + ':D' + json + '\n'),
           request.completedRegularChunks.push(stringToChunk(id)));
     }
     function outlineComponentInfo(request, componentInfo) {
@@ -2776,7 +2781,7 @@
       existingRef = { objectLimit: existingRef };
       var componentDebugInfo = {
         name: componentInfo.name,
-        key: componentInfo.key
+        key: componentInfo.key,
       };
       null != componentInfo.env && (componentDebugInfo.env = componentInfo.env);
       null != componentInfo.owner &&
@@ -2784,7 +2789,7 @@
       null == componentInfo.stack && null != componentInfo.debugStack
         ? (componentDebugInfo.stack = filterStackTrace(
             request,
-            parseStackTrace(componentInfo.debugStack, 1)
+            parseStackTrace(componentInfo.debugStack, 1),
           ))
         : null != componentInfo.stack &&
           (componentDebugInfo.stack = componentInfo.stack);
@@ -2800,11 +2805,11 @@
       var buffer = new Uint8Array(
         typedArray.buffer,
         typedArray.byteOffset,
-        typedArray.byteLength
+        typedArray.byteLength,
       );
       typedArray = 2048 < typedArray.byteLength ? buffer.slice() : buffer;
       buffer = typedArray.byteLength;
-      id = id.toString(16) + ":" + tag + buffer.toString(16) + ",";
+      id = id.toString(16) + ':' + tag + buffer.toString(16) + ',';
       id = stringToChunk(id);
       debug
         ? request.completedDebugChunks.push(id, typedArray)
@@ -2813,12 +2818,12 @@
     function emitTextChunk(request, id, text, debug) {
       if (null === byteLengthOfChunk)
         throw Error(
-          "Existence of byteLengthOfChunk should have already been checked. This is a bug in React."
+          'Existence of byteLengthOfChunk should have already been checked. This is a bug in React.',
         );
       debug ? request.pendingDebugChunks++ : request.pendingChunks++;
       text = stringToChunk(text);
       var binaryLength = text.byteLength;
-      id = id.toString(16) + ":T" + binaryLength.toString(16) + ",";
+      id = id.toString(16) + ':T' + binaryLength.toString(16) + ',';
       id = stringToChunk(id);
       debug
         ? request.completedDebugChunks.push(id, text)
@@ -2829,17 +2834,17 @@
       counter,
       parent,
       parentPropertyName,
-      value
+      value,
     ) {
       if (null === value) return null;
-      if (value === REACT_ELEMENT_TYPE) return "$";
-      if ("object" === typeof value) {
+      if (value === REACT_ELEMENT_TYPE) return '$';
+      if ('object' === typeof value) {
         if (isClientReference(value))
           return serializeDebugClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (value.$$typeof === CONSTRUCTOR_MARKER) {
           value = value.constructor;
@@ -2847,18 +2852,18 @@
           void 0 === ref &&
             ((request = outlineDebugModel(request, counter, value)),
             (ref = serializeByValueID(request)));
-          return "$P" + ref.slice(1);
+          return '$P' + ref.slice(1);
         }
         if (void 0 !== request.temporaryReferences) {
           var tempRef = request.temporaryReferences.get(value);
-          if (void 0 !== tempRef) return "$T" + tempRef;
+          if (void 0 !== tempRef) return '$T' + tempRef;
         }
         tempRef = request.writtenDebugObjects;
         var existingDebugReference = tempRef.get(value);
         if (void 0 !== existingDebugReference)
           if (debugModelRoot === value) debugModelRoot = null;
           else return existingDebugReference;
-        else if (-1 === parentPropertyName.indexOf(":"))
+        else if (-1 === parentPropertyName.indexOf(':'))
           if (
             ((existingDebugReference = tempRef.get(parent)),
             void 0 !== existingDebugReference)
@@ -2868,21 +2873,21 @@
             var propertyName = parentPropertyName;
             if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
               switch (parentPropertyName) {
-                case "1":
-                  propertyName = "type";
+                case '1':
+                  propertyName = 'type';
                   break;
-                case "2":
-                  propertyName = "key";
+                case '2':
+                  propertyName = 'key';
                   break;
-                case "3":
-                  propertyName = "props";
+                case '3':
+                  propertyName = 'props';
                   break;
-                case "4":
-                  propertyName = "_owner";
+                case '4':
+                  propertyName = '_owner';
               }
-            tempRef.set(value, existingDebugReference + ":" + propertyName);
+            tempRef.set(value, existingDebugReference + ':' + propertyName);
           } else if (debugNoOutline !== value) {
-            if ("function" === typeof value.then)
+            if ('function' === typeof value.then)
               return serializeDebugThenable(request, counter, value);
             request = outlineDebugModel(request, counter, value);
             return serializeByValueID(request);
@@ -2905,17 +2910,17 @@
               request,
               parentPropertyName,
               counter,
-              value
+              value,
             ),
             serializeByValueID(parentPropertyName)
           );
         switch (value.$$typeof) {
           case REACT_ELEMENT_TYPE:
             null != value._owner && outlineComponentInfo(request, value._owner);
-            "object" === typeof value.type &&
+            'object' === typeof value.type &&
               null !== value.type &&
               doNotLimit.add(value.type);
-            "object" === typeof value.key &&
+            'object' === typeof value.key &&
               null !== value.key &&
               doNotLimit.add(value.key);
             doNotLimit.add(value.props);
@@ -2925,7 +2930,7 @@
               for (
                 counter = filterStackTrace(
                   request,
-                  parseStackTrace(value._debugStack, 1)
+                  parseStackTrace(value._debugStack, 1),
                 ),
                   doNotLimit.add(counter),
                   request = 0;
@@ -2940,18 +2945,18 @@
               value.props,
               value._owner,
               counter,
-              value._store.validated
+              value._store.validated,
             ];
           case REACT_LAZY_TYPE:
             value = value._payload;
-            if (null !== value && "object" === typeof value) {
+            if (null !== value && 'object' === typeof value) {
               switch (value._status) {
                 case 1:
                   return (
                     (request = outlineDebugModel(
                       request,
                       counter,
-                      value._result
+                      value._result,
                     )),
                     serializeLazyID(request)
                   );
@@ -2961,34 +2966,34 @@
                     emitErrorChunk(
                       request,
                       counter,
-                      "",
+                      '',
                       value._result,
                       !0,
-                      null
+                      null,
                     ),
                     serializeLazyID(counter)
                   );
               }
               switch (value.status) {
-                case "fulfilled":
+                case 'fulfilled':
                   return (
                     (request = outlineDebugModel(
                       request,
                       counter,
-                      value.value
+                      value.value,
                     )),
                     serializeLazyID(request)
                   );
-                case "rejected":
+                case 'rejected':
                   return (
                     (counter = request.nextChunkId++),
                     emitErrorChunk(
                       request,
                       counter,
-                      "",
+                      '',
                       value.reason,
                       !0,
-                      null
+                      null,
                     ),
                     serializeLazyID(counter)
                   );
@@ -2999,7 +3004,7 @@
             emitDebugHaltChunk(request, value);
             return serializeLazyID(value);
         }
-        if ("function" === typeof value.then)
+        if ('function' === typeof value.then)
           return serializeDebugThenable(request, counter, value);
         if (isArrayImpl(value)) return value;
         if (value instanceof Map) {
@@ -3010,81 +3015,81 @@
             doNotLimit.add(entry);
             var key = entry[0];
             entry = entry[1];
-            "object" === typeof key && null !== key && doNotLimit.add(key);
-            "object" === typeof entry &&
+            'object' === typeof key && null !== key && doNotLimit.add(key);
+            'object' === typeof entry &&
               null !== entry &&
               doNotLimit.add(entry);
           }
-          return "$Q" + outlineDebugModel(request, counter, value).toString(16);
+          return '$Q' + outlineDebugModel(request, counter, value).toString(16);
         }
         if (value instanceof Set) {
           value = Array.from(value);
           counter.objectLimit++;
           for (ref = 0; ref < value.length; ref++)
             (key = value[ref]),
-              "object" === typeof key && null !== key && doNotLimit.add(key);
-          return "$W" + outlineDebugModel(request, counter, value).toString(16);
+              'object' === typeof key && null !== key && doNotLimit.add(key);
+          return '$W' + outlineDebugModel(request, counter, value).toString(16);
         }
-        if ("function" === typeof FormData && value instanceof FormData)
+        if ('function' === typeof FormData && value instanceof FormData)
           return (
             (value = Array.from(value.entries())),
-            "$K" +
+            '$K' +
               outlineDebugModel(
                 request,
                 { objectLimit: 2 * value.length + 1 },
-                value
+                value,
               ).toString(16)
           );
         if (value instanceof Error) {
-          counter = "Error";
+          counter = 'Error';
           var env = (0, request.environmentName)();
           try {
             (counter = value.name),
               (ref = String(value.message)),
               (key = filterStackTrace(request, parseStackTrace(value, 0))),
               (entry = value.environmentName),
-              "string" === typeof entry && (env = entry);
+              'string' === typeof entry && (env = entry);
           } catch (x) {
             (ref =
-              "An error occurred but serializing the error message failed."),
+              'An error occurred but serializing the error message failed.'),
               (key = []);
           }
           request =
-            "$Z" +
+            '$Z' +
             outlineDebugModel(
               request,
               { objectLimit: 2 * key.length + 1 },
-              { name: counter, message: ref, stack: key, env: env }
+              { name: counter, message: ref, stack: key, env: env },
             ).toString(16);
           return request;
         }
         if (value instanceof ArrayBuffer)
-          return serializeDebugTypedArray(request, "A", new Uint8Array(value));
+          return serializeDebugTypedArray(request, 'A', new Uint8Array(value));
         if (value instanceof Int8Array)
-          return serializeDebugTypedArray(request, "O", value);
+          return serializeDebugTypedArray(request, 'O', value);
         if (value instanceof Uint8Array)
-          return serializeDebugTypedArray(request, "o", value);
+          return serializeDebugTypedArray(request, 'o', value);
         if (value instanceof Uint8ClampedArray)
-          return serializeDebugTypedArray(request, "U", value);
+          return serializeDebugTypedArray(request, 'U', value);
         if (value instanceof Int16Array)
-          return serializeDebugTypedArray(request, "S", value);
+          return serializeDebugTypedArray(request, 'S', value);
         if (value instanceof Uint16Array)
-          return serializeDebugTypedArray(request, "s", value);
+          return serializeDebugTypedArray(request, 's', value);
         if (value instanceof Int32Array)
-          return serializeDebugTypedArray(request, "L", value);
+          return serializeDebugTypedArray(request, 'L', value);
         if (value instanceof Uint32Array)
-          return serializeDebugTypedArray(request, "l", value);
+          return serializeDebugTypedArray(request, 'l', value);
         if (value instanceof Float32Array)
-          return serializeDebugTypedArray(request, "G", value);
+          return serializeDebugTypedArray(request, 'G', value);
         if (value instanceof Float64Array)
-          return serializeDebugTypedArray(request, "g", value);
+          return serializeDebugTypedArray(request, 'g', value);
         if (value instanceof BigInt64Array)
-          return serializeDebugTypedArray(request, "M", value);
+          return serializeDebugTypedArray(request, 'M', value);
         if (value instanceof BigUint64Array)
-          return serializeDebugTypedArray(request, "m", value);
+          return serializeDebugTypedArray(request, 'm', value);
         if (value instanceof DataView)
-          return serializeDebugTypedArray(request, "V", value);
-        if ("function" === typeof Blob && value instanceof Blob)
+          return serializeDebugTypedArray(request, 'V', value);
+        if ('function' === typeof Blob && value instanceof Blob)
           return serializeDebugBlob(request, value);
         if (getIteratorFn(value)) return Array.from(value);
         request = getPrototypeOf(value);
@@ -3094,21 +3099,21 @@
             if (hasOwnProperty.call(value, env) || isGetter(request, env))
               counter[env] = value[env];
           ref = request.constructor;
-          "function" !== typeof ref ||
+          'function' !== typeof ref ||
             ref.prototype !== request ||
-            hasOwnProperty.call(value, "") ||
-            isGetter(request, "") ||
-            (counter[""] = { $$typeof: CONSTRUCTOR_MARKER, constructor: ref });
+            hasOwnProperty.call(value, '') ||
+            isGetter(request, '') ||
+            (counter[''] = { $$typeof: CONSTRUCTOR_MARKER, constructor: ref });
           return counter;
         }
         return value;
       }
-      if ("string" === typeof value) {
+      if ('string' === typeof value) {
         if (
-          "Z" === value[value.length - 1] &&
+          'Z' === value[value.length - 1] &&
           parent[parentPropertyName] instanceof Date
         )
-          return "$D" + value;
+          return '$D' + value;
         if (1024 <= value.length) {
           if (0 >= counter.objectLimit)
             return serializeDeferredObject(request, value);
@@ -3118,39 +3123,39 @@
           emitTextChunk(request, counter, value, !0);
           return serializeByValueID(counter);
         }
-        return "$" === value[0] ? "$" + value : value;
+        return '$' === value[0] ? '$' + value : value;
       }
-      if ("boolean" === typeof value) return value;
-      if ("number" === typeof value) return serializeNumber(value);
-      if ("undefined" === typeof value) return "$undefined";
-      if ("function" === typeof value) {
+      if ('boolean' === typeof value) return value;
+      if ('number' === typeof value) return serializeNumber(value);
+      if ('undefined' === typeof value) return '$undefined';
+      if ('function' === typeof value) {
         if (isClientReference(value))
           return serializeDebugClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (
           void 0 !== request.temporaryReferences &&
           ((counter = request.temporaryReferences.get(value)),
           void 0 !== counter)
         )
-          return "$T" + counter;
+          return '$T' + counter;
         counter = request.writtenDebugObjects;
         ref = counter.get(value);
         if (void 0 !== ref) return ref;
         ref = Function.prototype.toString.call(value);
         key = value.name;
         key =
-          "$E" +
-          ("string" === typeof key
-            ? "Object.defineProperty(" +
+          '$E' +
+          ('string' === typeof key
+            ? 'Object.defineProperty(' +
               ref +
               ',"name",{value:' +
               JSON.stringify(key) +
-              "})"
-            : "(" + ref + ")");
+              '})'
+            : '(' + ref + ')');
         request.pendingDebugChunks++;
         ref = request.nextChunkId++;
         key = encodeReferenceChunk(request, ref, key);
@@ -3159,7 +3164,7 @@
         counter.set(value, request);
         return request;
       }
-      if ("symbol" === typeof value) {
+      if ('symbol' === typeof value) {
         counter = request.writtenSymbols.get(value);
         if (void 0 !== counter) return serializeByValueID(counter);
         value = value.description;
@@ -3168,11 +3173,11 @@
         emitSymbolChunk(request, counter, value);
         return serializeByValueID(counter);
       }
-      return "bigint" === typeof value
-        ? "$n" + value.toString(10)
+      return 'bigint' === typeof value
+        ? '$n' + value.toString(10)
         : value instanceof Date
-          ? "$D" + value.toJSON()
-          : "unknown type " + typeof value;
+          ? '$D' + value.toJSON()
+          : 'unknown type ' + typeof value;
     }
     function serializeDebugModel(request, objectLimit, model) {
       function replacer(parentPropertyName, value) {
@@ -3182,11 +3187,11 @@
             counter,
             this,
             parentPropertyName,
-            value
+            value,
           );
         } catch (x) {
           return (
-            "Unknown Value: React could not send it from the server.\n" +
+            'Unknown Value: React could not send it from the server.\n' +
             x.message
           );
         }
@@ -3198,8 +3203,8 @@
         return stringify(model, replacer);
       } catch (x) {
         return stringify(
-          "Unknown Value: React could not send it from the server.\n" +
-            x.message
+          'Unknown Value: React could not send it from the server.\n' +
+            x.message,
         );
       } finally {
         debugNoOutline = objectLimit;
@@ -3213,32 +3218,32 @@
             counter,
             this,
             parentPropertyName,
-            value
+            value,
           );
         } catch (x) {
           return (
-            "Unknown Value: React could not send it from the server.\n" +
+            'Unknown Value: React could not send it from the server.\n' +
             x.message
           );
         }
       }
-      "object" === typeof model && null !== model && doNotLimit.add(model);
+      'object' === typeof model && null !== model && doNotLimit.add(model);
       var prevModelRoot = debugModelRoot;
       debugModelRoot = model;
-      "object" === typeof model &&
+      'object' === typeof model &&
         null !== model &&
         request.writtenDebugObjects.set(model, serializeByValueID(id));
       try {
         var json = stringify(model, replacer);
       } catch (x) {
         json = stringify(
-          "Unknown Value: React could not send it from the server.\n" +
-            x.message
+          'Unknown Value: React could not send it from the server.\n' +
+            x.message,
         );
       } finally {
         debugModelRoot = prevModelRoot;
       }
-      id = id.toString(16) + ":" + json + "\n";
+      id = id.toString(16) + ':' + json + '\n';
       id = stringToChunk(id);
       request.completedDebugChunks.push(id);
     }
@@ -3250,15 +3255,15 @@
     }
     function emitTimeOriginChunk(request, timeOrigin) {
       request.pendingDebugChunks++;
-      timeOrigin = stringToChunk(":N" + timeOrigin + "\n");
+      timeOrigin = stringToChunk(':N' + timeOrigin + '\n');
       request.completedDebugChunks.push(timeOrigin);
     }
     function forwardDebugInfo(request$jscomp$1, task, debugInfo) {
       for (var id = task.id, i = 0; i < debugInfo.length; i++) {
         var info = debugInfo[i];
-        if ("number" === typeof info.time)
+        if ('number' === typeof info.time)
           markOperationEndTime(request$jscomp$1, task, info.time);
-        else if ("string" === typeof info.name)
+        else if ('string' === typeof info.name)
           outlineComponentInfo(request$jscomp$1, info),
             request$jscomp$1.pendingChunks++,
             emitDebugChunk(request$jscomp$1, id, info);
@@ -3277,7 +3282,7 @@
                 null != ioInfo$jscomp$0.debugStack
                   ? filterStackTrace(
                       request,
-                      parseStackTrace(ioInfo$jscomp$0.debugStack, 1)
+                      parseStackTrace(ioInfo$jscomp$0.debugStack, 1),
                     )
                   : ioInfo$jscomp$0.stack;
               var request$jscomp$0 = request,
@@ -3289,7 +3294,7 @@
               var debugIOInfo = {
                 name: ioInfo$jscomp$0.name,
                 start: ioInfo$jscomp$0.start - request$jscomp$0.timeOrigin,
-                end: ioInfo$jscomp$0.end - request$jscomp$0.timeOrigin
+                end: ioInfo$jscomp$0.end - request$jscomp$0.timeOrigin,
               };
               null != env && (debugIOInfo.env = env);
               null != debugStack && (debugIOInfo.stack = debugStack);
@@ -3298,14 +3303,14 @@
               value = serializeDebugModel(
                 request$jscomp$0,
                 objectLimit,
-                debugIOInfo
+                debugIOInfo,
               );
-              id$jscomp$1 = id$jscomp$1.toString(16) + ":J" + value + "\n";
+              id$jscomp$1 = id$jscomp$1.toString(16) + ':J' + value + '\n';
               id$jscomp$1 = stringToChunk(id$jscomp$1);
               request$jscomp$0.completedDebugChunks.push(id$jscomp$1);
               request.writtenDebugObjects.set(
                 ioInfo$jscomp$0,
-                serializeByValueID(id$jscomp$0)
+                serializeByValueID(id$jscomp$0),
               );
             }
             null != info.owner &&
@@ -3314,7 +3319,7 @@
               null == info.stack && null != info.debugStack
                 ? filterStackTrace(
                     request$jscomp$1,
-                    parseStackTrace(info.debugStack, 1)
+                    parseStackTrace(info.debugStack, 1),
                   )
                 : info.stack;
             ioInfo = { awaited: ioInfo };
@@ -3339,22 +3344,22 @@
     }
     function forwardDebugInfoFromAbortedTask(request, task) {
       var model = task.model;
-      "object" === typeof model &&
+      'object' === typeof model &&
         null !== model &&
         (model = model._debugInfo) &&
         forwardDebugInfo(request, task, model);
     }
     function emitTimingChunk(request, id, timestamp) {
       request.pendingChunks++;
-      var json = '{"time":' + (timestamp - request.timeOrigin) + "}";
+      var json = '{"time":' + (timestamp - request.timeOrigin) + '}';
       null !== request.debugDestination
         ? ((timestamp = request.nextChunkId++),
-          (json = timestamp.toString(16) + ":" + json + "\n"),
+          (json = timestamp.toString(16) + ':' + json + '\n'),
           request.pendingDebugChunks++,
           request.completedDebugChunks.push(stringToChunk(json)),
           (id = id.toString(16) + ':D"$' + timestamp.toString(16) + '"\n'),
           request.completedRegularChunks.push(stringToChunk(id)))
-        : ((id = id.toString(16) + ":D" + json + "\n"),
+        : ((id = id.toString(16) + ':D' + json + '\n'),
           request.completedRegularChunks.push(stringToChunk(id)));
     }
     function markOperationEndTime(request, task, timestamp) {
@@ -3366,45 +3371,45 @@
     }
     function emitChunk(request, task, value) {
       var id = task.id;
-      "string" === typeof value && null !== byteLengthOfChunk
+      'string' === typeof value && null !== byteLengthOfChunk
         ? emitTextChunk(request, id, value, !1)
         : value instanceof ArrayBuffer
-          ? emitTypedArrayChunk(request, id, "A", new Uint8Array(value), !1)
+          ? emitTypedArrayChunk(request, id, 'A', new Uint8Array(value), !1)
           : value instanceof Int8Array
-            ? emitTypedArrayChunk(request, id, "O", value, !1)
+            ? emitTypedArrayChunk(request, id, 'O', value, !1)
             : value instanceof Uint8Array
-              ? emitTypedArrayChunk(request, id, "o", value, !1)
+              ? emitTypedArrayChunk(request, id, 'o', value, !1)
               : value instanceof Uint8ClampedArray
-                ? emitTypedArrayChunk(request, id, "U", value, !1)
+                ? emitTypedArrayChunk(request, id, 'U', value, !1)
                 : value instanceof Int16Array
-                  ? emitTypedArrayChunk(request, id, "S", value, !1)
+                  ? emitTypedArrayChunk(request, id, 'S', value, !1)
                   : value instanceof Uint16Array
-                    ? emitTypedArrayChunk(request, id, "s", value, !1)
+                    ? emitTypedArrayChunk(request, id, 's', value, !1)
                     : value instanceof Int32Array
-                      ? emitTypedArrayChunk(request, id, "L", value, !1)
+                      ? emitTypedArrayChunk(request, id, 'L', value, !1)
                       : value instanceof Uint32Array
-                        ? emitTypedArrayChunk(request, id, "l", value, !1)
+                        ? emitTypedArrayChunk(request, id, 'l', value, !1)
                         : value instanceof Float32Array
-                          ? emitTypedArrayChunk(request, id, "G", value, !1)
+                          ? emitTypedArrayChunk(request, id, 'G', value, !1)
                           : value instanceof Float64Array
-                            ? emitTypedArrayChunk(request, id, "g", value, !1)
+                            ? emitTypedArrayChunk(request, id, 'g', value, !1)
                             : value instanceof BigInt64Array
-                              ? emitTypedArrayChunk(request, id, "M", value, !1)
+                              ? emitTypedArrayChunk(request, id, 'M', value, !1)
                               : value instanceof BigUint64Array
                                 ? emitTypedArrayChunk(
                                     request,
                                     id,
-                                    "m",
+                                    'm',
                                     value,
-                                    !1
+                                    !1,
                                   )
                                 : value instanceof DataView
                                   ? emitTypedArrayChunk(
                                       request,
                                       id,
-                                      "V",
+                                      'V',
                                       value,
-                                      !1
+                                      !1,
                                     )
                                   : ((value = stringify(value, task.toJSON)),
                                     emitModelChunk(request, task.id, value));
@@ -3429,8 +3434,8 @@
             request,
             task,
             emptyRoot,
-            "",
-            task.model
+            '',
+            task.model,
           );
           canEmitDebugInfo = !1;
           modelRoot = resolvedModel;
@@ -3441,10 +3446,10 @@
             (request.pendingChunks++,
             emitDebugChunk(request, task.id, { env: currentEnv }));
           task.timed && markOperationEndTime(request, task, performance.now());
-          if ("object" === typeof resolvedModel && null !== resolvedModel)
+          if ('object' === typeof resolvedModel && null !== resolvedModel)
             request.writtenObjects.set(
               resolvedModel,
-              serializeByValueID(task.id)
+              serializeByValueID(task.id),
             ),
               emitChunk(request, task, resolvedModel);
           else {
@@ -3473,9 +3478,9 @@
                 ? getSuspendedThenable()
                 : thrownValue;
             if (
-              "object" === typeof x &&
+              'object' === typeof x &&
               null !== x &&
-              "function" === typeof x.then
+              'function' === typeof x.then
             ) {
               task.status = 0;
               task.thenableState = getThenableStateAfterSuspending();
@@ -3571,7 +3576,7 @@
               (request.pendingChunks--,
               !writeChunkAndReturn(
                 debugDestination,
-                importsChunks[debugChunks]
+                importsChunks[debugChunks],
               ))
             ) {
               request.destination = null;
@@ -3600,7 +3605,7 @@
                 (request.pendingDebugChunks--,
                 !writeChunkAndReturn(
                   debugDestination,
-                  _debugChunks[debugChunks]
+                  _debugChunks[debugChunks],
                 ))
               ) {
                 request.destination = null;
@@ -3619,7 +3624,7 @@
               (request.pendingChunks--,
               !writeChunkAndReturn(
                 debugDestination,
-                regularChunks[debugChunks]
+                regularChunks[debugChunks],
               ))
             ) {
               request.destination = null;
@@ -3650,8 +3655,8 @@
             request.status < ABORTING &&
               request.cacheController.abort(
                 Error(
-                  "This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources."
-                )
+                  'This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources.',
+                ),
               ),
             null !== request.destination &&
               ((request.status = CLOSED),
@@ -3745,13 +3750,13 @@
               var error =
                   void 0 === reason
                     ? Error(
-                        "The render was aborted by the server without a reason."
+                        'The render was aborted by the server without a reason.',
                       )
-                    : "object" === typeof reason &&
+                    : 'object' === typeof reason &&
                         null !== reason &&
-                        "function" === typeof reason.then
+                        'function' === typeof reason.then
                       ? Error(
-                          "The render was aborted by the server with a promise."
+                          'The render was aborted by the server with a promise.',
                         )
                       : reason,
                 digest = logRecoverableError(request, error, null),
@@ -3783,7 +3788,7 @@
       var deferredDebugObjects = request.deferredDebugObjects;
       if (null === deferredDebugObjects)
         throw Error(
-          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React."
+          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React.",
         );
       deferredDebugObjects.retained.forEach(function (value, id) {
         request.pendingDebugChunks--;
@@ -3793,11 +3798,11 @@
       enqueueFlush(request);
     }
     function resolveServerReference(bundlerConfig, id) {
-      var name = "",
+      var name = '',
         resolvedModuleData = bundlerConfig[id];
       if (resolvedModuleData) name = resolvedModuleData.name;
       else {
-        var idx = id.lastIndexOf("#");
+        var idx = id.lastIndexOf('#');
         -1 !== idx &&
           ((name = id.slice(idx + 1)),
           (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -3805,7 +3810,7 @@
           throw Error(
             'Could not find the module "' +
               id +
-              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
           );
       }
       return resolvedModuleData.async
@@ -3814,17 +3819,17 @@
     }
     function requireAsyncModule(id) {
       var promise = __webpack_require__(id);
-      if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+      if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
         return null;
       promise.then(
         function (value) {
-          promise.status = "fulfilled";
+          promise.status = 'fulfilled';
           promise.value = value;
         },
         function (reason) {
-          promise.status = "rejected";
+          promise.status = 'rejected';
           promise.reason = reason;
-        }
+        },
       );
       return promise;
     }
@@ -3858,13 +3863,13 @@
     }
     function requireModule(metadata) {
       var moduleExports = __webpack_require__(metadata[0]);
-      if (4 === metadata.length && "function" === typeof moduleExports.then)
-        if ("fulfilled" === moduleExports.status)
+      if (4 === metadata.length && 'function' === typeof moduleExports.then)
+        if ('fulfilled' === moduleExports.status)
           moduleExports = moduleExports.value;
         else throw moduleExports.reason;
-      return "*" === metadata[2]
+      return '*' === metadata[2]
         ? moduleExports
-        : "" === metadata[2]
+        : '' === metadata[2]
           ? moduleExports.__esModule
             ? moduleExports.default
             : moduleExports
@@ -3881,41 +3886,41 @@
       this._response = response;
     }
     function createPendingChunk(response) {
-      return new Chunk("pending", null, null, response);
+      return new Chunk('pending', null, null, response);
     }
     function wakeChunk(listeners, value) {
       for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
     }
     function triggerErrorOnChunk(chunk, error) {
-      if ("pending" !== chunk.status && "blocked" !== chunk.status)
+      if ('pending' !== chunk.status && 'blocked' !== chunk.status)
         chunk.reason.error(error);
       else {
         var listeners = chunk.reason;
-        chunk.status = "rejected";
+        chunk.status = 'rejected';
         chunk.reason = error;
         null !== listeners && wakeChunk(listeners, error);
       }
     }
     function resolveModelChunk(chunk, value, id) {
-      if ("pending" !== chunk.status)
+      if ('pending' !== chunk.status)
         (chunk = chunk.reason),
-          "C" === value[0]
-            ? chunk.close("C" === value ? '"$undefined"' : value.slice(1))
+          'C' === value[0]
+            ? chunk.close('C' === value ? '"$undefined"' : value.slice(1))
             : chunk.enqueueModel(value);
       else {
         var resolveListeners = chunk.value,
           rejectListeners = chunk.reason;
-        chunk.status = "resolved_model";
+        chunk.status = 'resolved_model';
         chunk.value = value;
         chunk.reason = id;
         if (null !== resolveListeners)
           switch ((initializeModelChunk(chunk), chunk.status)) {
-            case "fulfilled":
+            case 'fulfilled':
               wakeChunk(resolveListeners, chunk.value);
               break;
-            case "pending":
-            case "blocked":
-            case "cyclic":
+            case 'pending':
+            case 'blocked':
+            case 'cyclic':
               if (chunk.value)
                 for (value = 0; value < resolveListeners.length; value++)
                   chunk.value.push(resolveListeners[value]);
@@ -3926,19 +3931,19 @@
                     chunk.reason.push(rejectListeners[value]);
               } else chunk.reason = rejectListeners;
               break;
-            case "rejected":
+            case 'rejected':
               rejectListeners && wakeChunk(rejectListeners, chunk.reason);
           }
       }
     }
     function createResolvedIteratorResultChunk(response, value, done) {
       return new Chunk(
-        "resolved_model",
+        'resolved_model',
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
+          '}',
         -1,
-        response
+        response,
       );
     }
     function resolveIteratorResultChunk(chunk, value, done) {
@@ -3946,8 +3951,8 @@
         chunk,
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
-        -1
+          '}',
+        -1,
       );
     }
     function loadServerReference$1(
@@ -3956,7 +3961,7 @@
       bound,
       parentChunk,
       parentObject,
-      key
+      key,
     ) {
       var serverReference = resolveServerReference(response._bundlerConfig, id);
       id = preloadModule(serverReference);
@@ -3979,22 +3984,22 @@
           !1,
           response,
           createModel,
-          []
+          [],
         ),
-        createModelReject(parentChunk)
+        createModelReject(parentChunk),
       );
       return null;
     }
     function reviveModel(response, parentObj, parentKey, value, reference) {
-      if ("string" === typeof value)
+      if ('string' === typeof value)
         return parseModelString(
           response,
           parentObj,
           parentKey,
           value,
-          reference
+          reference,
         );
-      if ("object" === typeof value && null !== value)
+      if ('object' === typeof value && null !== value)
         if (
           (void 0 !== reference &&
             void 0 !== response._temporaryReferences &&
@@ -4005,23 +4010,23 @@
             value[i] = reviveModel(
               response,
               value,
-              "" + i,
+              '' + i,
               value[i],
-              void 0 !== reference ? reference + ":" + i : void 0
+              void 0 !== reference ? reference + ':' + i : void 0,
             );
         else
           for (i in value)
             hasOwnProperty.call(value, i) &&
               ((parentObj =
-                void 0 !== reference && -1 === i.indexOf(":")
-                  ? reference + ":" + i
+                void 0 !== reference && -1 === i.indexOf(':')
+                  ? reference + ':' + i
                   : void 0),
               (parentObj = reviveModel(
                 response,
                 value,
                 i,
                 value[i],
-                parentObj
+                parentObj,
               )),
               void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);
       return value;
@@ -4034,32 +4039,32 @@
       var rootReference =
           -1 === chunk.reason ? void 0 : chunk.reason.toString(16),
         resolvedModel = chunk.value;
-      chunk.status = "cyclic";
+      chunk.status = 'cyclic';
       chunk.value = null;
       chunk.reason = null;
       try {
         var rawModel = JSON.parse(resolvedModel),
           value = reviveModel(
             chunk._response,
-            { "": rawModel },
-            "",
+            { '': rawModel },
+            '',
             rawModel,
-            rootReference
+            rootReference,
           );
         if (
           null !== initializingChunkBlockedModel &&
           0 < initializingChunkBlockedModel.deps
         )
           (initializingChunkBlockedModel.value = value),
-            (chunk.status = "blocked");
+            (chunk.status = 'blocked');
         else {
           var resolveListeners = chunk.value;
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = value;
           null !== resolveListeners && wakeChunk(resolveListeners, value);
         }
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       } finally {
         (initializingChunk = prevChunk),
           (initializingChunkBlockedModel = prevBlocked);
@@ -4069,7 +4074,7 @@
       response._closed = !0;
       response._closedReason = error;
       response._chunks.forEach(function (chunk) {
-        "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+        'pending' === chunk.status && triggerErrorOnChunk(chunk, error);
       });
     }
     function getChunk(response, id) {
@@ -4079,9 +4084,9 @@
         ((chunk = response._formData.get(response._prefix + id)),
         (chunk =
           null != chunk
-            ? new Chunk("resolved_model", chunk, id, response)
+            ? new Chunk('resolved_model', chunk, id, response)
             : response._closed
-              ? new Chunk("rejected", null, response._closedReason, response)
+              ? new Chunk('rejected', null, response._closedReason, response)
               : createPendingChunk(response)),
         chunks.set(id, chunk));
       return chunk;
@@ -4093,7 +4098,7 @@
       cyclic,
       response,
       map,
-      path
+      path,
     ) {
       if (initializingChunkBlockedModel) {
         var blocked = initializingChunkBlockedModel;
@@ -4101,19 +4106,19 @@
       } else
         blocked = initializingChunkBlockedModel = {
           deps: cyclic ? 0 : 1,
-          value: null
+          value: null,
         };
       return function (value) {
         for (var i = 1; i < path.length; i++) value = value[path[i]];
         parentObject[key] = map(response, value);
-        "" === key &&
+        '' === key &&
           null === blocked.value &&
           (blocked.value = parentObject[key]);
         blocked.deps--;
         0 === blocked.deps &&
-          "blocked" === chunk.status &&
+          'blocked' === chunk.status &&
           ((value = chunk.value),
-          (chunk.status = "fulfilled"),
+          (chunk.status = 'fulfilled'),
           (chunk.value = blocked.value),
           null !== value && wakeChunk(value, blocked.value));
       };
@@ -4124,34 +4129,34 @@
       };
     }
     function getOutlinedModel(response, reference, parentObject, key, map) {
-      reference = reference.split(":");
+      reference = reference.split(':');
       var id = parseInt(reference[0], 16);
       id = getChunk(response, id);
       switch (id.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(id);
       }
       switch (id.status) {
-        case "fulfilled":
+        case 'fulfilled':
           parentObject = id.value;
           for (key = 1; key < reference.length; key++)
             parentObject = parentObject[reference[key]];
           return map(response, parentObject);
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           var parentChunk = initializingChunk;
           id.then(
             createModelResolver(
               parentChunk,
               parentObject,
               key,
-              "cyclic" === id.status,
+              'cyclic' === id.status,
               response,
               map,
-              reference
+              reference,
             ),
-            createModelReject(parentChunk)
+            createModelReject(parentChunk),
           );
           return null;
         default:
@@ -4176,7 +4181,7 @@
       constructor,
       bytesPerElement,
       parentObject,
-      parentKey
+      parentKey,
     ) {
       reference = parseInt(reference.slice(2), 16);
       reference = response._formData.get(response._prefix + reference);
@@ -4195,22 +4200,22 @@
           !1,
           response,
           createModel,
-          []
+          [],
         ),
-        createModelReject(bytesPerElement)
+        createModelReject(bytesPerElement),
       );
       return null;
     }
     function resolveStream(response, id, stream, controller) {
       var chunks = response._chunks;
-      stream = new Chunk("fulfilled", stream, controller, response);
+      stream = new Chunk('fulfilled', stream, controller, response);
       chunks.set(id, stream);
       response = response._formData.getAll(response._prefix + id);
       for (id = 0; id < response.length; id++)
         (chunks = response[id]),
-          "C" === chunks[0]
+          'C' === chunks[0]
             ? controller.close(
-                "C" === chunks ? '"$undefined"' : chunks.slice(1)
+                'C' === chunks ? '"$undefined"' : chunks.slice(1),
               )
             : controller.enqueueModel(chunks);
     }
@@ -4221,15 +4226,15 @@
         type: type,
         start: function (c) {
           controller = c;
-        }
+        },
       });
       var previousBlockedChunk = null;
       resolveStream(response, reference, type, {
         enqueueModel: function (json) {
           if (null === previousBlockedChunk) {
-            var chunk = new Chunk("resolved_model", json, -1, response);
+            var chunk = new Chunk('resolved_model', json, -1, response);
             initializeModelChunk(chunk);
-            "fulfilled" === chunk.status
+            'fulfilled' === chunk.status
               ? controller.enqueue(chunk.value)
               : (chunk.then(
                   function (v) {
@@ -4237,7 +4242,7 @@
                   },
                   function (e) {
                     return controller.error(e);
-                  }
+                  },
                 ),
                 (previousBlockedChunk = chunk));
           } else {
@@ -4249,7 +4254,7 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             );
             previousBlockedChunk = _chunk;
             chunk.then(function () {
@@ -4277,7 +4282,7 @@
               return controller.error(error);
             });
           }
-        }
+        },
       });
       return type;
     }
@@ -4299,15 +4304,15 @@
           return createIterator(function (arg) {
             if (void 0 !== arg)
               throw Error(
-                "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+                'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
               );
             if (nextReadIndex === buffer.length) {
               if (closed)
                 return new Chunk(
-                  "fulfilled",
+                  'fulfilled',
                   { done: !0, value: void 0 },
                   null,
-                  response
+                  response,
                 );
               buffer[nextReadIndex] = createPendingChunk(response);
             }
@@ -4321,7 +4326,7 @@
             ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                 response,
                 value,
-                !1
+                !1,
               ))
             : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
           nextWriteIndex++;
@@ -4332,14 +4337,14 @@
             ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                 response,
                 value,
-                !0
+                !0,
               ))
             : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
           for (nextWriteIndex++; nextWriteIndex < buffer.length; )
             resolveIteratorResultChunk(
               buffer[nextWriteIndex++],
               '"$undefined"',
-              !0
+              !0,
             );
         },
         error: function (error) {
@@ -4351,20 +4356,20 @@
 
           )
             triggerErrorOnChunk(buffer[nextWriteIndex++], error);
-        }
+        },
       });
       return iterator;
     }
     function parseModelString(response, obj, key, value, reference) {
-      if ("$" === value[0]) {
+      if ('$' === value[0]) {
         switch (value[1]) {
-          case "$":
+          case '$':
             return value.slice(1);
-          case "@":
+          case '@':
             return (
               (obj = parseInt(value.slice(2), 16)), getChunk(response, obj)
             );
-          case "F":
+          case 'F':
             return (
               (value = value.slice(2)),
               (value = getOutlinedModel(
@@ -4372,7 +4377,7 @@
                 value,
                 obj,
                 key,
-                createModel
+                createModel,
               )),
               loadServerReference$1(
                 response,
@@ -4380,113 +4385,113 @@
                 value.bound,
                 initializingChunk,
                 obj,
-                key
+                key,
               )
             );
-          case "T":
+          case 'T':
             if (
               void 0 === reference ||
               void 0 === response._temporaryReferences
             )
               throw Error(
-                "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+                'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
               );
             return createTemporaryReference(
               response._temporaryReferences,
-              reference
+              reference,
             );
-          case "Q":
+          case 'Q':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, createMap)
             );
-          case "W":
+          case 'W':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, createSet)
             );
-          case "K":
+          case 'K':
             obj = value.slice(2);
-            var formPrefix = response._prefix + obj + "_",
+            var formPrefix = response._prefix + obj + '_',
               data = new FormData();
             response._formData.forEach(function (entry, entryKey) {
               entryKey.startsWith(formPrefix) &&
                 data.append(entryKey.slice(formPrefix.length), entry);
             });
             return data;
-          case "i":
+          case 'i':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, extractIterator)
             );
-          case "I":
+          case 'I':
             return Infinity;
-          case "-":
-            return "$-0" === value ? -0 : -Infinity;
-          case "N":
+          case '-':
+            return '$-0' === value ? -0 : -Infinity;
+          case 'N':
             return NaN;
-          case "u":
+          case 'u':
             return;
-          case "D":
+          case 'D':
             return new Date(Date.parse(value.slice(2)));
-          case "n":
+          case 'n':
             return BigInt(value.slice(2));
         }
         switch (value[1]) {
-          case "A":
+          case 'A':
             return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);
-          case "O":
+          case 'O':
             return parseTypedArray(response, value, Int8Array, 1, obj, key);
-          case "o":
+          case 'o':
             return parseTypedArray(response, value, Uint8Array, 1, obj, key);
-          case "U":
+          case 'U':
             return parseTypedArray(
               response,
               value,
               Uint8ClampedArray,
               1,
               obj,
-              key
+              key,
             );
-          case "S":
+          case 'S':
             return parseTypedArray(response, value, Int16Array, 2, obj, key);
-          case "s":
+          case 's':
             return parseTypedArray(response, value, Uint16Array, 2, obj, key);
-          case "L":
+          case 'L':
             return parseTypedArray(response, value, Int32Array, 4, obj, key);
-          case "l":
+          case 'l':
             return parseTypedArray(response, value, Uint32Array, 4, obj, key);
-          case "G":
+          case 'G':
             return parseTypedArray(response, value, Float32Array, 4, obj, key);
-          case "g":
+          case 'g':
             return parseTypedArray(response, value, Float64Array, 8, obj, key);
-          case "M":
+          case 'M':
             return parseTypedArray(response, value, BigInt64Array, 8, obj, key);
-          case "m":
+          case 'm':
             return parseTypedArray(
               response,
               value,
               BigUint64Array,
               8,
               obj,
-              key
+              key,
             );
-          case "V":
+          case 'V':
             return parseTypedArray(response, value, DataView, 1, obj, key);
-          case "B":
+          case 'B':
             return (
               (obj = parseInt(value.slice(2), 16)),
               response._formData.get(response._prefix + obj)
             );
         }
         switch (value[1]) {
-          case "R":
+          case 'R':
             return parseReadableStream(response, value, void 0);
-          case "r":
-            return parseReadableStream(response, value, "bytes");
-          case "X":
+          case 'r':
+            return parseReadableStream(response, value, 'bytes');
+          case 'X':
             return parseAsyncIterable(response, value, !1);
-          case "x":
+          case 'x':
             return parseAsyncIterable(response, value, !0);
         }
         value = value.slice(1);
@@ -4497,7 +4502,7 @@
     function createResponse(
       bundlerConfig,
       formFieldPrefix,
-      temporaryReferences
+      temporaryReferences,
     ) {
       var backingFormData =
           3 < arguments.length && void 0 !== arguments[3]
@@ -4511,11 +4516,11 @@
         _chunks: chunks,
         _closed: !1,
         _closedReason: null,
-        _temporaryReferences: temporaryReferences
+        _temporaryReferences: temporaryReferences,
       };
     }
     function close(response) {
-      reportGlobalError(response, Error("Connection closed."));
+      reportGlobalError(response, Error('Connection closed.'));
     }
     function loadServerReference(bundlerConfig, id, bound) {
       var serverReference = resolveServerReference(bundlerConfig, id);
@@ -4537,12 +4542,12 @@
       close(body);
       body = getChunk(body, 0);
       body.then(function () {});
-      if ("fulfilled" !== body.status) throw body.reason;
+      if ('fulfilled' !== body.status) throw body.reason;
       return body.value;
     }
     function startReadingFromDebugChannelReadableStream(
       request$jscomp$0,
-      stream
+      stream,
     ) {
       function progress(_ref) {
         var done = _ref.done,
@@ -4553,19 +4558,19 @@
             (buffer = stringDecoder.decode(buffer)))
           : (buffer = stringDecoder.decode(buffer, decoderOptions));
         stringBuffer = _ref + buffer;
-        _ref = stringBuffer.split("\n");
+        _ref = stringBuffer.split('\n');
         for (buffer = 0; buffer < _ref.length - 1; buffer++) {
           var request = request$jscomp$0,
             message = _ref[buffer],
             deferredDebugObjects = request.deferredDebugObjects;
           if (null === deferredDebugObjects)
             throw Error(
-              "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React."
+              "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React.",
             );
-          if ("" === message) closeDebugChannel(request);
+          if ('' === message) closeDebugChannel(request);
           else {
             var command = message.charCodeAt(0);
-            message = message.slice(2).split(",").map(fromHex);
+            message = message.slice(2).split(',').map(fromHex);
             switch (command) {
               case 82:
                 for (command = 0; command < message.length; command++) {
@@ -4589,7 +4594,7 @@
                         request,
                         id,
                         { objectLimit: 10 },
-                        retainedValue
+                        retainedValue,
                       ),
                       enqueueFlush(request));
                 break;
@@ -4603,12 +4608,12 @@
                         request,
                         id,
                         { objectLimit: 10 },
-                        retainedValue
+                        retainedValue,
                       ));
                 break;
               default:
                 throw Error(
-                  "Unknown command. The debugChannel was not wired up properly."
+                  'Unknown command. The debugChannel was not wired up properly.',
                 );
             }
           }
@@ -4620,16 +4625,16 @@
       function error(e) {
         abort(
           request$jscomp$0,
-          Error("Lost connection to the Debug Channel.", { cause: e })
+          Error('Lost connection to the Debug Channel.', { cause: e }),
         );
       }
       var reader = stream.getReader(),
         stringDecoder = new TextDecoder(),
-        stringBuffer = "";
+        stringBuffer = '';
       reader.read().then(progress).catch(error);
     }
-    var ReactDOM = require("react-dom"),
-      React = require("react"),
+    var ReactDOM = require('react-dom'),
+      React = require('react'),
       channel = new MessageChannel(),
       taskQueue = [];
     channel.port1.onmessage = function () {
@@ -4638,7 +4643,7 @@
     };
     var LocalPromise = Promise,
       scheduleMicrotask =
-        "function" === typeof queueMicrotask
+        'function' === typeof queueMicrotask
           ? queueMicrotask
           : function (callback) {
               LocalPromise.resolve(null)
@@ -4648,52 +4653,52 @@
       currentView = null,
       writtenBytes = 0,
       textEncoder = new TextEncoder(),
-      CLIENT_REFERENCE_TAG$1 = Symbol.for("react.client.reference"),
-      SERVER_REFERENCE_TAG = Symbol.for("react.server.reference"),
+      CLIENT_REFERENCE_TAG$1 = Symbol.for('react.client.reference'),
+      SERVER_REFERENCE_TAG = Symbol.for('react.server.reference'),
       FunctionBind = Function.prototype.bind,
       ArraySlice = Array.prototype.slice,
       PROMISE_PROTOTYPE = Promise.prototype,
       deepProxyHandlers = {
         get: function (target, name) {
           switch (name) {
-            case "$$typeof":
+            case '$$typeof':
               return target.$$typeof;
-            case "$$id":
+            case '$$id':
               return target.$$id;
-            case "$$async":
+            case '$$async':
               return target.$$async;
-            case "name":
+            case 'name':
               return target.name;
-            case "displayName":
+            case 'displayName':
               return;
-            case "defaultProps":
+            case 'defaultProps':
               return;
-            case "_debugInfo":
+            case '_debugInfo':
               return;
-            case "toJSON":
+            case 'toJSON':
               return;
             case Symbol.toPrimitive:
               return Object.prototype[Symbol.toPrimitive];
             case Symbol.toStringTag:
               return Object.prototype[Symbol.toStringTag];
-            case "Provider":
+            case 'Provider':
               throw Error(
-                "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+                'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
               );
-            case "then":
+            case 'then':
               throw Error(
-                "Cannot await or return from a thenable. You cannot await a client module from a server component."
+                'Cannot await or return from a thenable. You cannot await a client module from a server component.',
               );
           }
           throw Error(
-            "Cannot access " +
-              (String(target.name) + "." + String(name)) +
-              " on the server. You cannot dot into a client module from a server component. You can only pass the imported name through."
+            'Cannot access ' +
+              (String(target.name) + '.' + String(name)) +
+              ' on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.',
           );
         },
         set: function () {
-          throw Error("Cannot assign to a client module from a server module.");
-        }
+          throw Error('Cannot assign to a client module from a server module.');
+        },
       },
       proxyHandlers$1 = {
         get: function (target, name) {
@@ -4706,7 +4711,7 @@
               value: getReference(target, name),
               writable: !1,
               configurable: !1,
-              enumerable: !1
+              enumerable: !1,
             }),
             Object.defineProperty(target, name, descriptor));
           return descriptor;
@@ -4715,8 +4720,8 @@
           return PROMISE_PROTOTYPE;
         },
         set: function () {
-          throw Error("Cannot assign to a client module from a server module.");
-        }
+          throw Error('Cannot assign to a client module from a server module.');
+        },
       },
       ReactDOMSharedInternals =
         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
@@ -4725,86 +4730,86 @@
       f: previousDispatcher.f,
       r: previousDispatcher.r,
       D: function (href) {
-        if ("string" === typeof href && href) {
+        if ('string' === typeof href && href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "D|" + href;
-            hints.has(key) || (hints.add(key), emitHint(request, "D", href));
+              key = 'D|' + href;
+            hints.has(key) || (hints.add(key), emitHint(request, 'D', href));
           } else previousDispatcher.D(href);
         }
       },
       C: function (href, crossOrigin) {
-        if ("string" === typeof href) {
+        if ('string' === typeof href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
               key =
-                "C|" +
-                (null == crossOrigin ? "null" : crossOrigin) +
-                "|" +
+                'C|' +
+                (null == crossOrigin ? 'null' : crossOrigin) +
+                '|' +
                 href;
             hints.has(key) ||
               (hints.add(key),
-              "string" === typeof crossOrigin
-                ? emitHint(request, "C", [href, crossOrigin])
-                : emitHint(request, "C", href));
+              'string' === typeof crossOrigin
+                ? emitHint(request, 'C', [href, crossOrigin])
+                : emitHint(request, 'C', href));
           } else previousDispatcher.C(href, crossOrigin);
         }
       },
       L: preload,
       m: preloadModule$1,
       X: function (src, options) {
-        if ("string" === typeof src) {
+        if ('string' === typeof src) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "X|" + src;
+              key = 'X|' + src;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "X", [src, options])
-              : emitHint(request, "X", src);
+              ? emitHint(request, 'X', [src, options])
+              : emitHint(request, 'X', src);
           }
           previousDispatcher.X(src, options);
         }
       },
       S: function (href, precedence, options) {
-        if ("string" === typeof href) {
+        if ('string' === typeof href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "S|" + href;
+              key = 'S|' + href;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "S", [
+              ? emitHint(request, 'S', [
                   href,
-                  "string" === typeof precedence ? precedence : 0,
-                  options
+                  'string' === typeof precedence ? precedence : 0,
+                  options,
                 ])
-              : "string" === typeof precedence
-                ? emitHint(request, "S", [href, precedence])
-                : emitHint(request, "S", href);
+              : 'string' === typeof precedence
+                ? emitHint(request, 'S', [href, precedence])
+                : emitHint(request, 'S', href);
           }
           previousDispatcher.S(href, precedence, options);
         }
       },
       M: function (src, options) {
-        if ("string" === typeof src) {
+        if ('string' === typeof src) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "M|" + src;
+              key = 'M|' + src;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "M", [src, options])
-              : emitHint(request, "M", src);
+              ? emitHint(request, 'M', [src, options])
+              : emitHint(request, 'M', src);
           }
           previousDispatcher.M(src, options);
         }
-      }
+      },
     };
     var framesToSkip = 0,
       collectedStackTrace = null,
@@ -4812,60 +4817,60 @@
       frameRegExp =
         /^ {3} at (?:(.+) \((?:(.+):(\d+):(\d+)|<anonymous>)\)|(?:async )?(.+):(\d+):(\d+)|<anonymous>)$/,
       stackTraceCache = new WeakMap(),
-      TEMPORARY_REFERENCE_TAG = Symbol.for("react.temporary.reference"),
+      TEMPORARY_REFERENCE_TAG = Symbol.for('react.temporary.reference'),
       proxyHandlers = {
         get: function (target, name) {
           switch (name) {
-            case "$$typeof":
+            case '$$typeof':
               return target.$$typeof;
-            case "name":
+            case 'name':
               return;
-            case "displayName":
+            case 'displayName':
               return;
-            case "defaultProps":
+            case 'defaultProps':
               return;
-            case "_debugInfo":
+            case '_debugInfo':
               return;
-            case "toJSON":
+            case 'toJSON':
               return;
             case Symbol.toPrimitive:
               return Object.prototype[Symbol.toPrimitive];
             case Symbol.toStringTag:
               return Object.prototype[Symbol.toStringTag];
-            case "Provider":
+            case 'Provider':
               throw Error(
-                "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+                'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
               );
-            case "then":
+            case 'then':
               return;
           }
           throw Error(
-            "Cannot access " +
+            'Cannot access ' +
               String(name) +
-              " on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client."
+              ' on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client.',
           );
         },
         set: function () {
           throw Error(
-            "Cannot assign to a temporary client reference from a server module."
+            'Cannot assign to a temporary client reference from a server module.',
           );
-        }
+        },
       },
-      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-    Symbol.for("react.postpone");
+      REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element'),
+      REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+      REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+      REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+      REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+      REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+      REACT_MEMO_TYPE = Symbol.for('react.memo'),
+      REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+      REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
+    Symbol.for('react.postpone');
     var MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
       ASYNC_ITERATOR = Symbol.asyncIterator,
       SuspenseException = Error(
-        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
+        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.",
       ),
       suspendedThenable = null,
       currentRequest$1 = null,
@@ -4876,10 +4881,10 @@
         readContext: unsupportedContext,
         use: function (usable) {
           if (
-            (null !== usable && "object" === typeof usable) ||
-            "function" === typeof usable
+            (null !== usable && 'object' === typeof usable) ||
+            'function' === typeof usable
           ) {
-            if ("function" === typeof usable.then) {
+            if ('function' === typeof usable.then) {
               var index = thenableIndexCounter;
               thenableIndexCounter += 1;
               null === thenableState && (thenableState = []);
@@ -4893,12 +4898,12 @@
               usable.value.$$typeof === REACT_CONTEXT_TYPE
             )
               throw Error(
-                "Cannot read a Client Context from a Server Component."
+                'Cannot read a Client Context from a Server Component.',
               );
-            throw Error("Cannot use() an already resolved Client Reference.");
+            throw Error('Cannot use() an already resolved Client Reference.');
           }
           throw Error(
-            "An unsupported type was passed to use(): " + String(usable)
+            'An unsupported type was passed to use(): ' + String(usable),
           );
         },
         useCallback: function (callback) {
@@ -4921,14 +4926,14 @@
         useSyncExternalStore: unsupportedHook,
         useId: function () {
           if (null === currentRequest$1)
-            throw Error("useId can only be used while React is rendering");
+            throw Error('useId can only be used while React is rendering');
           var id = currentRequest$1.identifierCount++;
           return (
-            "_" +
+            '_' +
             currentRequest$1.identifierPrefix +
-            "S_" +
+            'S_' +
             id.toString(32) +
-            "_"
+            '_'
           );
         },
         useHostTransitionStatus: unsupportedHook,
@@ -4942,7 +4947,7 @@
         },
         useCacheRefresh: function () {
           return unsupportedRefresh;
-        }
+        },
       };
     HooksDispatcher.useEffectEvent = unsupportedHook;
     var currentOwner = null,
@@ -4957,21 +4962,21 @@
         cacheSignal: function () {
           var request = resolveRequest();
           return request ? request.cacheController.signal : null;
-        }
+        },
       };
     DefaultAsyncDispatcher.getOwner = resolveOwner;
     var ReactSharedInternalsServer =
       React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
     if (!ReactSharedInternalsServer)
       throw Error(
-        'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
+        'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.',
       );
     var prefix, suffix;
-    new ("function" === typeof WeakMap ? WeakMap : Map)();
+    new ('function' === typeof WeakMap ? WeakMap : Map)();
     var lastResetTime = 0;
     if (
-      "object" === typeof performance &&
-      "function" === typeof performance.now
+      'object' === typeof performance &&
+      'function' === typeof performance.now
     ) {
       var localPerformance = performance;
       var getCurrentTime = function () {
@@ -4987,7 +4992,7 @@
         react_stack_bottom_frame: function (
           Component,
           props,
-          componentDebugInfo
+          componentDebugInfo,
         ) {
           currentOwner = componentDebugInfo;
           try {
@@ -4995,7 +5000,7 @@
           } finally {
             currentOwner = null;
           }
-        }
+        },
       },
       callComponentInDEV =
         callComponent.react_stack_bottom_frame.bind(callComponent),
@@ -5003,14 +5008,14 @@
         react_stack_bottom_frame: function (lazy) {
           var init = lazy._init;
           return init(lazy._payload);
-        }
+        },
       },
       callLazyInitInDEV =
         callLazyInit.react_stack_bottom_frame.bind(callLazyInit),
       callIterator = {
         react_stack_bottom_frame: function (iterator, progress, error) {
           iterator.next().then(progress, error);
-        }
+        },
       },
       callIteratorInDEV =
         callIterator.react_stack_bottom_frame.bind(callIterator),
@@ -5018,24 +5023,24 @@
       getPrototypeOf = Object.getPrototypeOf,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
-      CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"),
+      CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference'),
       hasOwnProperty = Object.prototype.hasOwnProperty,
       doNotLimit = new WeakSet();
-    "object" === typeof console &&
+    'object' === typeof console &&
       null !== console &&
-      (patchConsole(console, "assert"),
-      patchConsole(console, "debug"),
-      patchConsole(console, "dir"),
-      patchConsole(console, "dirxml"),
-      patchConsole(console, "error"),
-      patchConsole(console, "group"),
-      patchConsole(console, "groupCollapsed"),
-      patchConsole(console, "groupEnd"),
-      patchConsole(console, "info"),
-      patchConsole(console, "log"),
-      patchConsole(console, "table"),
-      patchConsole(console, "trace"),
-      patchConsole(console, "warn"));
+      (patchConsole(console, 'assert'),
+      patchConsole(console, 'debug'),
+      patchConsole(console, 'dir'),
+      patchConsole(console, 'dirxml'),
+      patchConsole(console, 'error'),
+      patchConsole(console, 'group'),
+      patchConsole(console, 'groupCollapsed'),
+      patchConsole(console, 'groupEnd'),
+      patchConsole(console, 'info'),
+      patchConsole(console, 'log'),
+      patchConsole(console, 'table'),
+      patchConsole(console, 'trace'),
+      patchConsole(console, 'warn'));
     var ObjectPrototype = Object.prototype,
       stringify = JSON.stringify,
       ABORTING = 12,
@@ -5063,16 +5068,16 @@
     Chunk.prototype = Object.create(Promise.prototype);
     Chunk.prototype.then = function (resolve, reject) {
       switch (this.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(this);
       }
       switch (this.status) {
-        case "fulfilled":
+        case 'fulfilled':
           resolve(this.value);
           break;
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           resolve &&
             (null === this.value && (this.value = []),
             this.value.push(resolve));
@@ -5097,16 +5102,16 @@
       var formData = new FormData(),
         action = null;
       body.forEach(function (value, key) {
-        key.startsWith("$ACTION_")
-          ? key.startsWith("$ACTION_REF_")
-            ? ((value = "$ACTION_" + key.slice(12) + ":"),
+        key.startsWith('$ACTION_')
+          ? key.startsWith('$ACTION_REF_')
+            ? ((value = '$ACTION_' + key.slice(12) + ':'),
               (value = decodeBoundActionMetaData(body, serverManifest, value)),
               (action = loadServerReference(
                 serverManifest,
                 value.id,
-                value.bound
+                value.bound,
               )))
-            : key.startsWith("$ACTION_ID_") &&
+            : key.startsWith('$ACTION_ID_') &&
               ((value = key.slice(11)),
               (action = loadServerReference(serverManifest, value, null)))
           : formData.append(key, value);
@@ -5118,12 +5123,12 @@
           });
     };
     exports.decodeFormState = function (actionResult, body, serverManifest) {
-      var keyPath = body.get("$ACTION_KEY");
-      if ("string" !== typeof keyPath) return Promise.resolve(null);
+      var keyPath = body.get('$ACTION_KEY');
+      if ('string' !== typeof keyPath) return Promise.resolve(null);
       var metaData = null;
       body.forEach(function (value, key) {
-        key.startsWith("$ACTION_REF_") &&
-          ((value = "$ACTION_" + key.slice(12) + ":"),
+        key.startsWith('$ACTION_REF_') &&
+          ((value = '$ACTION_' + key.slice(12) + ':'),
           (metaData = decodeBoundActionMetaData(body, serverManifest, value)));
       });
       if (null === metaData) return Promise.resolve(null);
@@ -5135,16 +5140,16 @@
       });
     };
     exports.decodeReply = function (body, webpackMap, options) {
-      if ("string" === typeof body) {
+      if ('string' === typeof body) {
         var form = new FormData();
-        form.append("0", body);
+        form.append('0', body);
         body = form;
       }
       body = createResponse(
         webpackMap,
-        "",
+        '',
         options ? options.temporaryReferences : void 0,
-        body
+        body,
       );
       webpackMap = getChunk(body, 0);
       close(body);
@@ -5158,16 +5163,16 @@
           function () {
             var stream = new ReadableStream(
               {
-                type: "bytes",
+                type: 'bytes',
                 pull: function (controller) {
                   startFlowing(request, controller);
                 },
                 cancel: function (reason) {
                   request.destination = null;
                   abort(request, reason);
-                }
+                },
               },
-              { highWaterMark: 0 }
+              { highWaterMark: 0 },
             );
             resolve({ prelude: stream });
           },
@@ -5178,7 +5183,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          !1
+          !1,
         );
         if (options && options.signal) {
           var signal = options.signal;
@@ -5186,9 +5191,9 @@
           else {
             var listener = function () {
               abort(request, signal.reason);
-              signal.removeEventListener("abort", listener);
+              signal.removeEventListener('abort', listener);
             };
-            signal.addEventListener("abort", listener);
+            signal.addEventListener('abort', listener);
           }
         }
         startWork(request);
@@ -5197,24 +5202,24 @@
     exports.registerClientReference = function (
       proxyImplementation,
       id,
-      exportName
+      exportName,
     ) {
       return registerClientReferenceImpl(
         proxyImplementation,
-        id + "#" + exportName,
-        !1
+        id + '#' + exportName,
+        !1,
       );
     };
     exports.registerServerReference = function (reference, id, exportName) {
       return Object.defineProperties(reference, {
         $$typeof: { value: SERVER_REFERENCE_TAG },
         $$id: {
-          value: null === exportName ? id : id + "#" + exportName,
-          configurable: !0
+          value: null === exportName ? id : id + '#' + exportName,
+          configurable: !0,
         },
         $$bound: { value: null, configurable: !0 },
-        $$location: { value: Error("react-stack-top-frame"), configurable: !0 },
-        bind: { value: bind, configurable: !0 }
+        $$location: { value: Error('react-stack-top-frame'), configurable: !0 },
+        bind: { value: bind, configurable: !0 },
       });
     };
     exports.renderToReadableStream = function (model, webpackMap, options) {
@@ -5235,7 +5240,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          void 0 !== debugChannelReadable
+          void 0 !== debugChannelReadable,
         );
       if (options && options.signal) {
         var signal = options.signal;
@@ -5243,15 +5248,15 @@
         else {
           var listener = function () {
             abort(request, signal.reason);
-            signal.removeEventListener("abort", listener);
+            signal.removeEventListener('abort', listener);
           };
-          signal.addEventListener("abort", listener);
+          signal.addEventListener('abort', listener);
         }
       }
       void 0 !== debugChannelWritable &&
         new ReadableStream(
           {
-            type: "bytes",
+            type: 'bytes',
             pull: function (controller) {
               if (13 === request.status)
                 (request.status = CLOSED),
@@ -5268,18 +5273,18 @@
                     fatalError(request, error);
                 }
               }
-            }
+            },
           },
-          { highWaterMark: 0 }
+          { highWaterMark: 0 },
         ).pipeTo(debugChannelWritable);
       void 0 !== debugChannelReadable &&
         startReadingFromDebugChannelReadableStream(
           request,
-          debugChannelReadable
+          debugChannelReadable,
         );
       return new ReadableStream(
         {
-          type: "bytes",
+          type: 'bytes',
           start: function () {
             startWork(request);
           },
@@ -5289,9 +5294,9 @@
           cancel: function (reason) {
             request.destination = null;
             abort(request, reason);
-          }
+          },
         },
-        { highWaterMark: 0 }
+        { highWaterMark: 0 },
       );
     };
   })();
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.browser.production.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.browser.production.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.browser.production.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.browser.production.js	2025-12-17 14:32:44
@@ -8,9 +8,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-var ReactDOM = require("react-dom"),
-  React = require("react"),
+'use strict';
+var ReactDOM = require('react-dom'),
+  React = require('react'),
   channel = new MessageChannel(),
   taskQueue = [];
 channel.port1.onmessage = function () {
@@ -28,7 +28,7 @@
 }
 var LocalPromise = Promise,
   scheduleMicrotask =
-    "function" === typeof queueMicrotask
+    'function' === typeof queueMicrotask
       ? queueMicrotask
       : function (callback) {
           LocalPromise.resolve(null)
@@ -42,7 +42,7 @@
     if (2048 < chunk.byteLength)
       0 < writtenBytes &&
         (destination.enqueue(
-          new Uint8Array(currentView.buffer, 0, writtenBytes)
+          new Uint8Array(currentView.buffer, 0, writtenBytes),
         ),
         (currentView = new Uint8Array(2048)),
         (writtenBytes = 0)),
@@ -70,17 +70,17 @@
   return chunk.byteLength;
 }
 function closeWithError(destination, error) {
-  "function" === typeof destination.error
+  'function' === typeof destination.error
     ? destination.error(error)
     : destination.close();
 }
-var CLIENT_REFERENCE_TAG$1 = Symbol.for("react.client.reference"),
-  SERVER_REFERENCE_TAG = Symbol.for("react.server.reference");
+var CLIENT_REFERENCE_TAG$1 = Symbol.for('react.client.reference'),
+  SERVER_REFERENCE_TAG = Symbol.for('react.server.reference');
 function registerClientReferenceImpl(proxyImplementation, id, async) {
   return Object.defineProperties(proxyImplementation, {
     $$typeof: { value: CLIENT_REFERENCE_TAG$1 },
     $$id: { value: id },
-    $$async: { value: async }
+    $$async: { value: async },
   });
 }
 var FunctionBind = Function.prototype.bind,
@@ -96,7 +96,7 @@
       $$typeof: $$typeof,
       $$id: $$id,
       $$bound: args,
-      bind: { value: bind, configurable: !0 }
+      bind: { value: bind, configurable: !0 },
     });
   }
   return newFn;
@@ -105,114 +105,114 @@
   deepProxyHandlers = {
     get: function (target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "$$id":
+        case '$$id':
           return target.$$id;
-        case "$$async":
+        case '$$async':
           return target.$$async;
-        case "name":
+        case 'name':
           return target.name;
-        case "displayName":
+        case 'displayName':
           return;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "Provider":
+        case 'Provider':
           throw Error(
-            "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+            'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
           );
-        case "then":
+        case 'then':
           throw Error(
-            "Cannot await or return from a thenable. You cannot await a client module from a server component."
+            'Cannot await or return from a thenable. You cannot await a client module from a server component.',
           );
       }
       throw Error(
-        "Cannot access " +
-          (String(target.name) + "." + String(name)) +
-          " on the server. You cannot dot into a client module from a server component. You can only pass the imported name through."
+        'Cannot access ' +
+          (String(target.name) + '.' + String(name)) +
+          ' on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.',
       );
     },
     set: function () {
-      throw Error("Cannot assign to a client module from a server module.");
-    }
+      throw Error('Cannot assign to a client module from a server module.');
+    },
   };
 function getReference(target, name) {
   switch (name) {
-    case "$$typeof":
+    case '$$typeof':
       return target.$$typeof;
-    case "$$id":
+    case '$$id':
       return target.$$id;
-    case "$$async":
+    case '$$async':
       return target.$$async;
-    case "name":
+    case 'name':
       return target.name;
-    case "defaultProps":
+    case 'defaultProps':
       return;
-    case "_debugInfo":
+    case '_debugInfo':
       return;
-    case "toJSON":
+    case 'toJSON':
       return;
     case Symbol.toPrimitive:
       return Object.prototype[Symbol.toPrimitive];
     case Symbol.toStringTag:
       return Object.prototype[Symbol.toStringTag];
-    case "__esModule":
+    case '__esModule':
       var moduleId = target.$$id;
       target.default = registerClientReferenceImpl(
         function () {
           throw Error(
-            "Attempted to call the default export of " +
+            'Attempted to call the default export of ' +
               moduleId +
-              " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+              " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
           );
         },
-        target.$$id + "#",
-        target.$$async
+        target.$$id + '#',
+        target.$$async,
       );
       return !0;
-    case "then":
+    case 'then':
       if (target.then) return target.then;
       if (target.$$async) return;
       var clientReference = registerClientReferenceImpl({}, target.$$id, !0),
         proxy = new Proxy(clientReference, proxyHandlers$1);
-      target.status = "fulfilled";
+      target.status = 'fulfilled';
       target.value = proxy;
       return (target.then = registerClientReferenceImpl(
         function (resolve) {
           return Promise.resolve(resolve(proxy));
         },
-        target.$$id + "#then",
-        !1
+        target.$$id + '#then',
+        !1,
       ));
   }
-  if ("symbol" === typeof name)
+  if ('symbol' === typeof name)
     throw Error(
-      "Cannot read Symbol exports. Only named exports are supported on a client module imported on the server."
+      'Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.',
     );
   clientReference = target[name];
   clientReference ||
     ((clientReference = registerClientReferenceImpl(
       function () {
         throw Error(
-          "Attempted to call " +
+          'Attempted to call ' +
             String(name) +
-            "() from the server but " +
+            '() from the server but ' +
             String(name) +
-            " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+            " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
         );
       },
-      target.$$id + "#" + name,
-      target.$$async
+      target.$$id + '#' + name,
+      target.$$async,
     )),
-    Object.defineProperty(clientReference, "name", { value: name }),
+    Object.defineProperty(clientReference, 'name', { value: name }),
     (clientReference = target[name] =
       new Proxy(clientReference, deepProxyHandlers)));
   return clientReference;
@@ -228,7 +228,7 @@
           value: getReference(target, name),
           writable: !1,
           configurable: !1,
-          enumerable: !1
+          enumerable: !1,
         }),
         Object.defineProperty(target, name, descriptor));
       return descriptor;
@@ -237,8 +237,8 @@
       return PROMISE_PROTOTYPE;
     },
     set: function () {
-      throw Error("Cannot assign to a client module from a server module.");
-    }
+      throw Error('Cannot assign to a client module from a server module.');
+    },
   },
   ReactDOMSharedInternals =
     ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
@@ -252,119 +252,119 @@
   m: preloadModule$1,
   X: preinitScript,
   S: preinitStyle,
-  M: preinitModuleScript
+  M: preinitModuleScript,
 };
 function prefetchDNS(href) {
-  if ("string" === typeof href && href) {
+  if ('string' === typeof href && href) {
     var request = currentRequest ? currentRequest : null;
     if (request) {
       var hints = request.hints,
-        key = "D|" + href;
-      hints.has(key) || (hints.add(key), emitHint(request, "D", href));
+        key = 'D|' + href;
+      hints.has(key) || (hints.add(key), emitHint(request, 'D', href));
     } else previousDispatcher.D(href);
   }
 }
 function preconnect(href, crossOrigin) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = currentRequest ? currentRequest : null;
     if (request) {
       var hints = request.hints,
-        key = "C|" + (null == crossOrigin ? "null" : crossOrigin) + "|" + href;
+        key = 'C|' + (null == crossOrigin ? 'null' : crossOrigin) + '|' + href;
       hints.has(key) ||
         (hints.add(key),
-        "string" === typeof crossOrigin
-          ? emitHint(request, "C", [href, crossOrigin])
-          : emitHint(request, "C", href));
+        'string' === typeof crossOrigin
+          ? emitHint(request, 'C', [href, crossOrigin])
+          : emitHint(request, 'C', href));
     } else previousDispatcher.C(href, crossOrigin);
   }
 }
 function preload(href, as, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = currentRequest ? currentRequest : null;
     if (request) {
       var hints = request.hints,
-        key = "L";
-      if ("image" === as && options) {
+        key = 'L';
+      if ('image' === as && options) {
         var imageSrcSet = options.imageSrcSet,
           imageSizes = options.imageSizes,
-          uniquePart = "";
-        "string" === typeof imageSrcSet && "" !== imageSrcSet
-          ? ((uniquePart += "[" + imageSrcSet + "]"),
-            "string" === typeof imageSizes &&
-              (uniquePart += "[" + imageSizes + "]"))
-          : (uniquePart += "[][]" + href);
-        key += "[image]" + uniquePart;
-      } else key += "[" + as + "]" + href;
+          uniquePart = '';
+        'string' === typeof imageSrcSet && '' !== imageSrcSet
+          ? ((uniquePart += '[' + imageSrcSet + ']'),
+            'string' === typeof imageSizes &&
+              (uniquePart += '[' + imageSizes + ']'))
+          : (uniquePart += '[][]' + href);
+        key += '[image]' + uniquePart;
+      } else key += '[' + as + ']' + href;
       hints.has(key) ||
         (hints.add(key),
         (options = trimOptions(options))
-          ? emitHint(request, "L", [href, as, options])
-          : emitHint(request, "L", [href, as]));
+          ? emitHint(request, 'L', [href, as, options])
+          : emitHint(request, 'L', [href, as]));
     } else previousDispatcher.L(href, as, options);
   }
 }
 function preloadModule$1(href, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = currentRequest ? currentRequest : null;
     if (request) {
       var hints = request.hints,
-        key = "m|" + href;
+        key = 'm|' + href;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "m", [href, options])
-        : emitHint(request, "m", href);
+        ? emitHint(request, 'm', [href, options])
+        : emitHint(request, 'm', href);
     }
     previousDispatcher.m(href, options);
   }
 }
 function preinitStyle(href, precedence, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = currentRequest ? currentRequest : null;
     if (request) {
       var hints = request.hints,
-        key = "S|" + href;
+        key = 'S|' + href;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "S", [
+        ? emitHint(request, 'S', [
             href,
-            "string" === typeof precedence ? precedence : 0,
-            options
+            'string' === typeof precedence ? precedence : 0,
+            options,
           ])
-        : "string" === typeof precedence
-          ? emitHint(request, "S", [href, precedence])
-          : emitHint(request, "S", href);
+        : 'string' === typeof precedence
+          ? emitHint(request, 'S', [href, precedence])
+          : emitHint(request, 'S', href);
     }
     previousDispatcher.S(href, precedence, options);
   }
 }
 function preinitScript(src, options) {
-  if ("string" === typeof src) {
+  if ('string' === typeof src) {
     var request = currentRequest ? currentRequest : null;
     if (request) {
       var hints = request.hints,
-        key = "X|" + src;
+        key = 'X|' + src;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "X", [src, options])
-        : emitHint(request, "X", src);
+        ? emitHint(request, 'X', [src, options])
+        : emitHint(request, 'X', src);
     }
     previousDispatcher.X(src, options);
   }
 }
 function preinitModuleScript(src, options) {
-  if ("string" === typeof src) {
+  if ('string' === typeof src) {
     var request = currentRequest ? currentRequest : null;
     if (request) {
       var hints = request.hints,
-        key = "M|" + src;
+        key = 'M|' + src;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "M", [src, options])
-        : emitHint(request, "M", src);
+        ? emitHint(request, 'M', [src, options])
+        : emitHint(request, 'M', src);
     }
     previousDispatcher.M(src, options);
   }
@@ -381,63 +381,63 @@
 }
 function getChildFormatContext(parentContext, type, props) {
   switch (type) {
-    case "img":
+    case 'img':
       type = props.src;
       var srcSet = props.srcSet;
       if (
         !(
-          "lazy" === props.loading ||
+          'lazy' === props.loading ||
           (!type && !srcSet) ||
-          ("string" !== typeof type && null != type) ||
-          ("string" !== typeof srcSet && null != srcSet) ||
-          "low" === props.fetchPriority ||
+          ('string' !== typeof type && null != type) ||
+          ('string' !== typeof srcSet && null != srcSet) ||
+          'low' === props.fetchPriority ||
           parentContext & 3
         ) &&
-        ("string" !== typeof type ||
-          ":" !== type[4] ||
-          ("d" !== type[0] && "D" !== type[0]) ||
-          ("a" !== type[1] && "A" !== type[1]) ||
-          ("t" !== type[2] && "T" !== type[2]) ||
-          ("a" !== type[3] && "A" !== type[3])) &&
-        ("string" !== typeof srcSet ||
-          ":" !== srcSet[4] ||
-          ("d" !== srcSet[0] && "D" !== srcSet[0]) ||
-          ("a" !== srcSet[1] && "A" !== srcSet[1]) ||
-          ("t" !== srcSet[2] && "T" !== srcSet[2]) ||
-          ("a" !== srcSet[3] && "A" !== srcSet[3]))
+        ('string' !== typeof type ||
+          ':' !== type[4] ||
+          ('d' !== type[0] && 'D' !== type[0]) ||
+          ('a' !== type[1] && 'A' !== type[1]) ||
+          ('t' !== type[2] && 'T' !== type[2]) ||
+          ('a' !== type[3] && 'A' !== type[3])) &&
+        ('string' !== typeof srcSet ||
+          ':' !== srcSet[4] ||
+          ('d' !== srcSet[0] && 'D' !== srcSet[0]) ||
+          ('a' !== srcSet[1] && 'A' !== srcSet[1]) ||
+          ('t' !== srcSet[2] && 'T' !== srcSet[2]) ||
+          ('a' !== srcSet[3] && 'A' !== srcSet[3]))
       ) {
-        var sizes = "string" === typeof props.sizes ? props.sizes : void 0;
+        var sizes = 'string' === typeof props.sizes ? props.sizes : void 0;
         var input = props.crossOrigin;
-        preload(type || "", "image", {
+        preload(type || '', 'image', {
           imageSrcSet: srcSet,
           imageSizes: sizes,
           crossOrigin:
-            "string" === typeof input
-              ? "use-credentials" === input
+            'string' === typeof input
+              ? 'use-credentials' === input
                 ? input
-                : ""
+                : ''
               : void 0,
           integrity: props.integrity,
           type: props.type,
           fetchPriority: props.fetchPriority,
-          referrerPolicy: props.referrerPolicy
+          referrerPolicy: props.referrerPolicy,
         });
       }
       return parentContext;
-    case "link":
+    case 'link':
       type = props.rel;
       srcSet = props.href;
       if (
         !(
           parentContext & 1 ||
           null != props.itemProp ||
-          "string" !== typeof type ||
-          "string" !== typeof srcSet ||
-          "" === srcSet
+          'string' !== typeof type ||
+          'string' !== typeof srcSet ||
+          '' === srcSet
         )
       )
         switch (type) {
-          case "preload":
+          case 'preload':
             preload(srcSet, props.as, {
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
@@ -447,112 +447,112 @@
               referrerPolicy: props.referrerPolicy,
               imageSrcSet: props.imageSrcSet,
               imageSizes: props.imageSizes,
-              media: props.media
+              media: props.media,
             });
             break;
-          case "modulepreload":
+          case 'modulepreload':
             preloadModule$1(srcSet, {
               as: props.as,
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
-              nonce: props.nonce
+              nonce: props.nonce,
             });
             break;
-          case "stylesheet":
-            preload(srcSet, "stylesheet", {
+          case 'stylesheet':
+            preload(srcSet, 'stylesheet', {
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
               nonce: props.nonce,
               type: props.type,
               fetchPriority: props.fetchPriority,
               referrerPolicy: props.referrerPolicy,
-              media: props.media
+              media: props.media,
             });
         }
       return parentContext;
-    case "picture":
+    case 'picture':
       return parentContext | 2;
-    case "noscript":
+    case 'noscript':
       return parentContext | 1;
     default:
       return parentContext;
   }
 }
-var TEMPORARY_REFERENCE_TAG = Symbol.for("react.temporary.reference"),
+var TEMPORARY_REFERENCE_TAG = Symbol.for('react.temporary.reference'),
   proxyHandlers = {
     get: function (target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "name":
+        case 'name':
           return;
-        case "displayName":
+        case 'displayName':
           return;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "Provider":
+        case 'Provider':
           throw Error(
-            "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+            'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
           );
-        case "then":
+        case 'then':
           return;
       }
       throw Error(
-        "Cannot access " +
+        'Cannot access ' +
           String(name) +
-          " on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client."
+          ' on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client.',
       );
     },
     set: function () {
       throw Error(
-        "Cannot assign to a temporary client reference from a server module."
+        'Cannot assign to a temporary client reference from a server module.',
       );
-    }
+    },
   };
 function createTemporaryReference(temporaryReferences, id) {
   var reference = Object.defineProperties(
     function () {
       throw Error(
-        "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+        "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
       );
     },
-    { $$typeof: { value: TEMPORARY_REFERENCE_TAG } }
+    { $$typeof: { value: TEMPORARY_REFERENCE_TAG } },
   );
   reference = new Proxy(reference, proxyHandlers);
   temporaryReferences.set(reference, id);
   return reference;
 }
-var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
-  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-  REACT_MEMO_TYPE = Symbol.for("react.memo"),
-  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-Symbol.for("react.postpone");
+var REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element'),
+  REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+  REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+  REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+  REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+  REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+  REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+  REACT_MEMO_TYPE = Symbol.for('react.memo'),
+  REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+  REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
+Symbol.for('react.postpone');
 var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
 function getIteratorFn(maybeIterable) {
-  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  if (null === maybeIterable || 'object' !== typeof maybeIterable) return null;
   maybeIterable =
     (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-    maybeIterable["@@iterator"];
-  return "function" === typeof maybeIterable ? maybeIterable : null;
+    maybeIterable['@@iterator'];
+  return 'function' === typeof maybeIterable ? maybeIterable : null;
 }
 var ASYNC_ITERATOR = Symbol.asyncIterator;
 function noop() {}
 var SuspenseException = Error(
-  "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
+  "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.",
 );
 function trackUsedThenable(thenableState, thenable, index) {
   index = thenableState[index];
@@ -560,35 +560,35 @@
     ? thenableState.push(thenable)
     : index !== thenable && (thenable.then(noop, noop), (thenable = index));
   switch (thenable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return thenable.value;
-    case "rejected":
+    case 'rejected':
       throw thenable.reason;
     default:
-      "string" === typeof thenable.status
+      'string' === typeof thenable.status
         ? thenable.then(noop, noop)
         : ((thenableState = thenable),
-          (thenableState.status = "pending"),
+          (thenableState.status = 'pending'),
           thenableState.then(
             function (fulfilledValue) {
-              if ("pending" === thenable.status) {
+              if ('pending' === thenable.status) {
                 var fulfilledThenable = thenable;
-                fulfilledThenable.status = "fulfilled";
+                fulfilledThenable.status = 'fulfilled';
                 fulfilledThenable.value = fulfilledValue;
               }
             },
             function (error) {
-              if ("pending" === thenable.status) {
+              if ('pending' === thenable.status) {
                 var rejectedThenable = thenable;
-                rejectedThenable.status = "rejected";
+                rejectedThenable.status = 'rejected';
                 rejectedThenable.reason = error;
               }
-            }
+            },
           ));
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return thenable.value;
-        case "rejected":
+        case 'rejected':
           throw thenable.reason;
       }
       suspendedThenable = thenable;
@@ -599,7 +599,7 @@
 function getSuspendedThenable() {
   if (null === suspendedThenable)
     throw Error(
-      "Expected a suspended thenable. This is a bug in React. Please file an issue."
+      'Expected a suspended thenable. This is a bug in React. Please file an issue.',
     );
   var thenable = suspendedThenable;
   suspendedThenable = null;
@@ -646,30 +646,30 @@
   },
   useCacheRefresh: function () {
     return unsupportedRefresh;
-  }
+  },
 };
 HooksDispatcher.useEffectEvent = unsupportedHook;
 function unsupportedHook() {
-  throw Error("This Hook is not supported in Server Components.");
+  throw Error('This Hook is not supported in Server Components.');
 }
 function unsupportedRefresh() {
-  throw Error("Refreshing the cache is not supported in Server Components.");
+  throw Error('Refreshing the cache is not supported in Server Components.');
 }
 function unsupportedContext() {
-  throw Error("Cannot read a Client Context from a Server Component.");
+  throw Error('Cannot read a Client Context from a Server Component.');
 }
 function useId() {
   if (null === currentRequest$1)
-    throw Error("useId can only be used while React is rendering");
+    throw Error('useId can only be used while React is rendering');
   var id = currentRequest$1.identifierCount++;
-  return "_" + currentRequest$1.identifierPrefix + "S_" + id.toString(32) + "_";
+  return '_' + currentRequest$1.identifierPrefix + 'S_' + id.toString(32) + '_';
 }
 function use(usable) {
   if (
-    (null !== usable && "object" === typeof usable) ||
-    "function" === typeof usable
+    (null !== usable && 'object' === typeof usable) ||
+    'function' === typeof usable
   ) {
-    if ("function" === typeof usable.then) {
+    if ('function' === typeof usable.then) {
       var index = thenableIndexCounter;
       thenableIndexCounter += 1;
       null === thenableState && (thenableState = []);
@@ -679,10 +679,10 @@
   }
   if (usable.$$typeof === CLIENT_REFERENCE_TAG$1) {
     if (null != usable.value && usable.value.$$typeof === REACT_CONTEXT_TYPE)
-      throw Error("Cannot read a Client Context from a Server Component.");
-    throw Error("Cannot use() an already resolved Client Reference.");
+      throw Error('Cannot read a Client Context from a Server Component.');
+    throw Error('Cannot use() an already resolved Client Reference.');
   }
-  throw Error("An unsupported type was passed to use(): " + String(usable));
+  throw Error('An unsupported type was passed to use(): ' + String(usable));
 }
 var DefaultAsyncDispatcher = {
     getCacheForType: function (resourceType) {
@@ -700,13 +700,13 @@
     cacheSignal: function () {
       var request = currentRequest ? currentRequest : null;
       return request ? request.cacheController.signal : null;
-    }
+    },
   },
   ReactSharedInternalsServer =
     React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
 if (!ReactSharedInternalsServer)
   throw Error(
-    'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
+    'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.',
   );
 var isArrayImpl = Array.isArray,
   getPrototypeOf = Object.getPrototypeOf;
@@ -716,35 +716,35 @@
 }
 function describeValueForErrorMessage(value) {
   switch (typeof value) {
-    case "string":
+    case 'string':
       return JSON.stringify(
-        10 >= value.length ? value : value.slice(0, 10) + "..."
+        10 >= value.length ? value : value.slice(0, 10) + '...',
       );
-    case "object":
-      if (isArrayImpl(value)) return "[...]";
+    case 'object':
+      if (isArrayImpl(value)) return '[...]';
       if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-        return "client";
+        return 'client';
       value = objectName(value);
-      return "Object" === value ? "{...}" : value;
-    case "function":
+      return 'Object' === value ? '{...}' : value;
+    case 'function':
       return value.$$typeof === CLIENT_REFERENCE_TAG
-        ? "client"
+        ? 'client'
         : (value = value.displayName || value.name)
-          ? "function " + value
-          : "function";
+          ? 'function ' + value
+          : 'function';
     default:
       return String(value);
   }
 }
 function describeElementType(type) {
-  if ("string" === typeof type) return type;
+  if ('string' === typeof type) return type;
   switch (type) {
     case REACT_SUSPENSE_TYPE:
-      return "Suspense";
+      return 'Suspense';
     case REACT_SUSPENSE_LIST_TYPE:
-      return "SuspenseList";
+      return 'SuspenseList';
   }
-  if ("object" === typeof type)
+  if ('object' === typeof type)
     switch (type.$$typeof) {
       case REACT_FORWARD_REF_TYPE:
         return describeElementType(type.render);
@@ -757,45 +757,45 @@
           return describeElementType(type(payload));
         } catch (x) {}
     }
-  return "";
+  return '';
 }
-var CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference");
+var CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference');
 function describeObjectForErrorMessage(objectOrArray, expandedName) {
   var objKind = objectName(objectOrArray);
-  if ("Object" !== objKind && "Array" !== objKind) return objKind;
+  if ('Object' !== objKind && 'Array' !== objKind) return objKind;
   objKind = -1;
   var length = 0;
   if (isArrayImpl(objectOrArray)) {
-    var str = "[";
+    var str = '[';
     for (var i = 0; i < objectOrArray.length; i++) {
-      0 < i && (str += ", ");
+      0 < i && (str += ', ');
       var value = objectOrArray[i];
       value =
-        "object" === typeof value && null !== value
+        'object' === typeof value && null !== value
           ? describeObjectForErrorMessage(value)
           : describeValueForErrorMessage(value);
-      "" + i === expandedName
+      '' + i === expandedName
         ? ((objKind = str.length), (length = value.length), (str += value))
         : (str =
             10 > value.length && 40 > str.length + value.length
               ? str + value
-              : str + "...");
+              : str + '...');
     }
-    str += "]";
+    str += ']';
   } else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-    str = "<" + describeElementType(objectOrArray.type) + "/>";
+    str = '<' + describeElementType(objectOrArray.type) + '/>';
   else {
-    if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
-    str = "{";
+    if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
+    str = '{';
     i = Object.keys(objectOrArray);
     for (value = 0; value < i.length; value++) {
-      0 < value && (str += ", ");
+      0 < value && (str += ', ');
       var name = i[value],
         encodedKey = JSON.stringify(name);
-      str += ('"' + name + '"' === encodedKey ? name : encodedKey) + ": ";
+      str += ('"' + name + '"' === encodedKey ? name : encodedKey) + ': ';
       encodedKey = objectOrArray[name];
       encodedKey =
-        "object" === typeof encodedKey && null !== encodedKey
+        'object' === typeof encodedKey && null !== encodedKey
           ? describeObjectForErrorMessage(encodedKey)
           : describeValueForErrorMessage(encodedKey);
       name === expandedName
@@ -805,16 +805,16 @@
         : (str =
             10 > encodedKey.length && 40 > str.length + encodedKey.length
               ? str + encodedKey
-              : str + "...");
+              : str + '...');
     }
-    str += "}";
+    str += '}';
   }
   return void 0 === expandedName
     ? str
     : -1 < objKind && 0 < length
-      ? ((objectOrArray = " ".repeat(objKind) + "^".repeat(length)),
-        "\n  " + str + "\n  " + objectOrArray)
-      : "\n  " + str;
+      ? ((objectOrArray = ' '.repeat(objKind) + '^'.repeat(length)),
+        '\n  ' + str + '\n  ' + objectOrArray)
+      : '\n  ' + str;
 }
 var hasOwnProperty = Object.prototype.hasOwnProperty,
   ObjectPrototype = Object.prototype,
@@ -831,13 +831,13 @@
   onAllReady,
   onFatalError,
   identifierPrefix,
-  temporaryReferences
+  temporaryReferences,
 ) {
   if (
     null !== ReactSharedInternalsServer.A &&
     ReactSharedInternalsServer.A !== DefaultAsyncDispatcher
   )
-    throw Error("Currently React only supports one RSC renderer at a time.");
+    throw Error('Currently React only supports one RSC renderer at a time.');
   ReactSharedInternalsServer.A = DefaultAsyncDispatcher;
   var abortSet = new Set(),
     pingedTasks = [],
@@ -862,7 +862,7 @@
   this.writtenServerReferences = new Map();
   this.writtenObjects = new WeakMap();
   this.temporaryReferences = temporaryReferences;
-  this.identifierPrefix = identifierPrefix || "";
+  this.identifierPrefix = identifierPrefix || '';
   this.identifierCount = 1;
   this.taintCleanupQueue = [];
   this.onError = void 0 === onError ? defaultErrorHandler : onError;
@@ -880,14 +880,14 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   switch (thenable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return (
         (newTask.model = thenable.value), pingTask(request, newTask), newTask.id
       );
-    case "rejected":
+    case 'rejected':
       return erroredTask(request, newTask, thenable.reason), newTask.id;
     default:
       if (12 === request.status)
@@ -900,18 +900,18 @@
               finishAbortedTask(newTask, request, task)),
           newTask.id
         );
-      "string" !== typeof thenable.status &&
-        ((thenable.status = "pending"),
+      'string' !== typeof thenable.status &&
+        ((thenable.status = 'pending'),
         thenable.then(
           function (fulfilledValue) {
-            "pending" === thenable.status &&
-              ((thenable.status = "fulfilled"),
+            'pending' === thenable.status &&
+              ((thenable.status = 'fulfilled'),
               (thenable.value = fulfilledValue));
           },
           function (error) {
-            "pending" === thenable.status &&
-              ((thenable.status = "rejected"), (thenable.reason = error));
-          }
+            'pending' === thenable.status &&
+              ((thenable.status = 'rejected'), (thenable.reason = error));
+          },
         ));
   }
   thenable.then(
@@ -922,7 +922,7 @@
     function (reason) {
       0 === newTask.status &&
         (erroredTask(request, newTask, reason), enqueueFlush(request));
-    }
+    },
   );
   return newTask.id;
 }
@@ -931,12 +931,12 @@
     if (0 === streamTask.status)
       if (entry.done)
         (streamTask.status = 1),
-          (entry = streamTask.id.toString(16) + ":C\n"),
+          (entry = streamTask.id.toString(16) + ':C\n'),
           request.completedRegularChunks.push(stringToChunk(entry)),
           request.abortableTasks.delete(streamTask),
           request.cacheController.signal.removeEventListener(
-            "abort",
-            abortStream
+            'abort',
+            abortStream,
           ),
           enqueueFlush(request),
           callOnAllReadyIfReady(request);
@@ -953,7 +953,7 @@
   }
   function error(reason) {
     0 === streamTask.status &&
-      (request.cacheController.signal.removeEventListener("abort", abortStream),
+      (request.cacheController.signal.removeEventListener('abort', abortStream),
       erroredTask(request, streamTask, reason),
       enqueueFlush(request),
       reader.cancel(reason).then(error, error));
@@ -961,7 +961,7 @@
   function abortStream() {
     if (0 === streamTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortStream);
+      signal.removeEventListener('abort', abortStream);
       signal = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(streamTask),
@@ -974,7 +974,7 @@
   var supportsBYOB = stream.supportsBYOB;
   if (void 0 === supportsBYOB)
     try {
-      stream.getReader({ mode: "byob" }).releaseLock(), (supportsBYOB = !0);
+      stream.getReader({ mode: 'byob' }).releaseLock(), (supportsBYOB = !0);
     } catch (x) {
       supportsBYOB = !1;
     }
@@ -985,12 +985,12 @@
       task.keyPath,
       task.implicitSlot,
       task.formatContext,
-      request.abortableTasks
+      request.abortableTasks,
     );
   request.pendingChunks++;
-  task = streamTask.id.toString(16) + ":" + (supportsBYOB ? "r" : "R") + "\n";
+  task = streamTask.id.toString(16) + ':' + (supportsBYOB ? 'r' : 'R') + '\n';
   request.completedRegularChunks.push(stringToChunk(task));
-  request.cacheController.signal.addEventListener("abort", abortStream);
+  request.cacheController.signal.addEventListener('abort', abortStream);
   reader.read().then(progress, error);
   return serializeByValueID(streamTask.id);
 }
@@ -1000,19 +1000,19 @@
       if (entry.done) {
         streamTask.status = 1;
         if (void 0 === entry.value)
-          var endStreamRow = streamTask.id.toString(16) + ":C\n";
+          var endStreamRow = streamTask.id.toString(16) + ':C\n';
         else
           try {
             var chunkId = outlineModelWithFormatContext(
               request,
               entry.value,
-              0
+              0,
             );
             endStreamRow =
               streamTask.id.toString(16) +
-              ":C" +
+              ':C' +
               stringify(serializeByValueID(chunkId)) +
-              "\n";
+              '\n';
           } catch (x) {
             error(x);
             return;
@@ -1020,8 +1020,8 @@
         request.completedRegularChunks.push(stringToChunk(endStreamRow));
         request.abortableTasks.delete(streamTask);
         request.cacheController.signal.removeEventListener(
-          "abort",
-          abortIterable
+          'abort',
+          abortIterable,
         );
         enqueueFlush(request);
         callOnAllReadyIfReady(request);
@@ -1039,18 +1039,18 @@
   function error(reason) {
     0 === streamTask.status &&
       (request.cacheController.signal.removeEventListener(
-        "abort",
-        abortIterable
+        'abort',
+        abortIterable,
       ),
       erroredTask(request, streamTask, reason),
       enqueueFlush(request),
-      "function" === typeof iterator.throw &&
+      'function' === typeof iterator.throw &&
         iterator.throw(reason).then(error, error));
   }
   function abortIterable() {
     if (0 === streamTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortIterable);
+      signal.removeEventListener('abort', abortIterable);
       var reason = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(streamTask),
@@ -1058,7 +1058,7 @@
           finishHaltedTask(streamTask, request))
         : (erroredTask(request, streamTask, signal.reason),
           enqueueFlush(request));
-      "function" === typeof iterator.throw &&
+      'function' === typeof iterator.throw &&
         iterator.throw(reason).then(error, error);
     }
   }
@@ -1069,45 +1069,45 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   request.pendingChunks++;
-  task = streamTask.id.toString(16) + ":" + (iterable ? "x" : "X") + "\n";
+  task = streamTask.id.toString(16) + ':' + (iterable ? 'x' : 'X') + '\n';
   request.completedRegularChunks.push(stringToChunk(task));
-  request.cacheController.signal.addEventListener("abort", abortIterable);
+  request.cacheController.signal.addEventListener('abort', abortIterable);
   iterator.next().then(progress, error);
   return serializeByValueID(streamTask.id);
 }
 function emitHint(request, code, model) {
   model = stringify(model);
-  code = stringToChunk(":H" + code + model + "\n");
+  code = stringToChunk(':H' + code + model + '\n');
   request.completedHintChunks.push(code);
   enqueueFlush(request);
 }
 function readThenable(thenable) {
-  if ("fulfilled" === thenable.status) return thenable.value;
-  if ("rejected" === thenable.status) throw thenable.reason;
+  if ('fulfilled' === thenable.status) return thenable.value;
+  if ('rejected' === thenable.status) throw thenable.reason;
   throw thenable;
 }
 function createLazyWrapperAroundWakeable(request, task, wakeable) {
   switch (wakeable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return wakeable.value;
-    case "rejected":
+    case 'rejected':
       break;
     default:
-      "string" !== typeof wakeable.status &&
-        ((wakeable.status = "pending"),
+      'string' !== typeof wakeable.status &&
+        ((wakeable.status = 'pending'),
         wakeable.then(
           function (fulfilledValue) {
-            "pending" === wakeable.status &&
-              ((wakeable.status = "fulfilled"),
+            'pending' === wakeable.status &&
+              ((wakeable.status = 'fulfilled'),
               (wakeable.value = fulfilledValue));
           },
           function (error) {
-            "pending" === wakeable.status &&
-              ((wakeable.status = "rejected"), (wakeable.reason = error));
-          }
+            'pending' === wakeable.status &&
+              ((wakeable.status = 'rejected'), (wakeable.reason = error));
+          },
         ));
   }
   return { $$typeof: REACT_LAZY_TYPE, _payload: wakeable, _init: readThenable };
@@ -1115,12 +1115,12 @@
 function voidHandler() {}
 function processServerComponentReturnValue(request, task, Component, result) {
   if (
-    "object" !== typeof result ||
+    'object' !== typeof result ||
     null === result ||
     result.$$typeof === CLIENT_REFERENCE_TAG$1
   )
     return result;
-  if ("function" === typeof result.then)
+  if ('function' === typeof result.then)
     return createLazyWrapperAroundWakeable(request, task, result);
   var iteratorFn = getIteratorFn(result);
   return iteratorFn
@@ -1129,8 +1129,8 @@
         return iteratorFn.call(result);
       }),
       request)
-    : "function" !== typeof result[ASYNC_ITERATOR] ||
-        ("function" === typeof ReadableStream &&
+    : 'function' !== typeof result[ASYNC_ITERATOR] ||
+        ('function' === typeof ReadableStream &&
           result instanceof ReadableStream)
       ? result
       : ((request = {}),
@@ -1147,9 +1147,9 @@
   props = Component(props, void 0);
   if (12 === request.status)
     throw (
-      ("object" === typeof props &&
+      ('object' === typeof props &&
         null !== props &&
-        "function" === typeof props.then &&
+        'function' === typeof props.then &&
         props.$$typeof !== CLIENT_REFERENCE_TAG$1 &&
         props.then(voidHandler, voidHandler),
       null)
@@ -1158,9 +1158,9 @@
   Component = task.keyPath;
   prevThenableState = task.implicitSlot;
   null !== key
-    ? (task.keyPath = null === Component ? key : Component + "," + key)
+    ? (task.keyPath = null === Component ? key : Component + ',' + key)
     : null === Component && (task.implicitSlot = !0);
-  request = renderModelDestructive(request, task, emptyRoot, "", props);
+  request = renderModelDestructive(request, task, emptyRoot, '', props);
   task.keyPath = Component;
   task.implicitSlot = prevThenableState;
   return request;
@@ -1171,7 +1171,7 @@
         REACT_ELEMENT_TYPE,
         REACT_FRAGMENT_TYPE,
         task.keyPath,
-        { children: children }
+        { children: children },
       ]),
       task.implicitSlot ? [request] : request)
     : children;
@@ -1184,7 +1184,7 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   pingTask(request, task);
   return serializeLazyID(task.id);
@@ -1192,10 +1192,10 @@
 function renderElement(request, task, type, key, ref, props) {
   if (null !== ref && void 0 !== ref)
     throw Error(
-      "Refs cannot be used in Server Components, nor passed to Client Components."
+      'Refs cannot be used in Server Components, nor passed to Client Components.',
     );
   if (
-    "function" === typeof type &&
+    'function' === typeof type &&
     type.$$typeof !== CLIENT_REFERENCE_TAG$1 &&
     type.$$typeof !== TEMPORARY_REFERENCE_TAG
   )
@@ -1208,15 +1208,15 @@
         request,
         task,
         emptyRoot,
-        "",
-        props.children
+        '',
+        props.children,
       )),
       (task.implicitSlot = type),
       props
     );
   if (
     null != type &&
-    "object" === typeof type &&
+    'object' === typeof type &&
     type.$$typeof !== CLIENT_REFERENCE_TAG$1
   )
     switch (type.$$typeof) {
@@ -1231,7 +1231,7 @@
         return renderElement(request, task, type.type, key, ref, props);
     }
   else
-    "string" === typeof type &&
+    'string' === typeof type &&
       ((ref = task.formatContext),
       (init = getChildFormatContext(ref, type, props)),
       ref !== init &&
@@ -1241,7 +1241,7 @@
   key = task.keyPath;
   null === request
     ? (request = key)
-    : null !== key && (request = key + "," + request);
+    : null !== key && (request = key + ',' + request);
   props = [REACT_ELEMENT_TYPE, type, request, props];
   task = task.implicitSlot && null !== request ? [props] : props;
   return task;
@@ -1265,11 +1265,11 @@
   keyPath,
   implicitSlot,
   formatContext,
-  abortSet
+  abortSet,
 ) {
   request.pendingChunks++;
   var id = request.nextChunkId++;
-  "object" !== typeof model ||
+  'object' !== typeof model ||
     null === model ||
     null !== keyPath ||
     implicitSlot ||
@@ -1294,13 +1294,13 @@
           task,
           this,
           parentPropertyName,
-          value
+          value,
         );
       } catch (thrownValue) {
         if (
           ((parentPropertyName = task.model),
           (parentPropertyName =
-            "object" === typeof parentPropertyName &&
+            'object' === typeof parentPropertyName &&
             null !== parentPropertyName &&
             (parentPropertyName.$$typeof === REACT_ELEMENT_TYPE ||
               parentPropertyName.$$typeof === REACT_LAZY_TYPE)),
@@ -1322,9 +1322,9 @@
             thrownValue === SuspenseException
               ? getSuspendedThenable()
               : thrownValue),
-          "object" === typeof value &&
+          'object' === typeof value &&
             null !== value &&
-            "function" === typeof value.then)
+            'function' === typeof value.then)
         ) {
           JSCompiler_inline_result = createTask(
             request,
@@ -1332,7 +1332,7 @@
             task.keyPath,
             task.implicitSlot,
             task.formatContext,
-            request.abortableTasks
+            request.abortableTasks,
           );
           var ping = JSCompiler_inline_result.ping;
           value.then(ping, ping);
@@ -1356,45 +1356,45 @@
       }
       return JSCompiler_inline_result;
     },
-    thenableState: null
+    thenableState: null,
   };
   abortSet.add(task);
   return task;
 }
 function serializeByValueID(id) {
-  return "$" + id.toString(16);
+  return '$' + id.toString(16);
 }
 function serializeLazyID(id) {
-  return "$L" + id.toString(16);
+  return '$L' + id.toString(16);
 }
 function encodeReferenceChunk(request, id, reference) {
   request = stringify(reference);
-  id = id.toString(16) + ":" + request + "\n";
+  id = id.toString(16) + ':' + request + '\n';
   return stringToChunk(id);
 }
 function serializeClientReference(
   request,
   parent,
   parentPropertyName,
-  clientReference
+  clientReference,
 ) {
   var clientReferenceKey = clientReference.$$async
-      ? clientReference.$$id + "#async"
+      ? clientReference.$$id + '#async'
       : clientReference.$$id,
     writtenClientReferences = request.writtenClientReferences,
     existingId = writtenClientReferences.get(clientReferenceKey);
   if (void 0 !== existingId)
-    return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+    return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
       ? serializeLazyID(existingId)
       : serializeByValueID(existingId);
   try {
     var config = request.bundlerConfig,
       modulePath = clientReference.$$id;
-    existingId = "";
+    existingId = '';
     var resolvedModuleData = config[modulePath];
     if (resolvedModuleData) existingId = resolvedModuleData.name;
     else {
-      var idx = modulePath.lastIndexOf("#");
+      var idx = modulePath.lastIndexOf('#');
       -1 !== idx &&
         ((existingId = modulePath.slice(idx + 1)),
         (resolvedModuleData = config[modulePath.slice(0, idx)]));
@@ -1402,14 +1402,14 @@
         throw Error(
           'Could not find the module "' +
             modulePath +
-            '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.'
+            '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.',
         );
     }
     if (!0 === resolvedModuleData.async && !0 === clientReference.$$async)
       throw Error(
         'The module "' +
           modulePath +
-          '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.'
+          '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.',
       );
     var JSCompiler_inline_result =
       !0 === resolvedModuleData.async || !0 === clientReference.$$async
@@ -1418,11 +1418,11 @@
     request.pendingChunks++;
     var importId = request.nextChunkId++,
       json = stringify(JSCompiler_inline_result),
-      row = importId.toString(16) + ":I" + json + "\n",
+      row = importId.toString(16) + ':I' + json + '\n',
       processedChunk = stringToChunk(row);
     request.completedImportChunks.push(processedChunk);
     writtenClientReferences.set(clientReferenceKey, importId);
-    return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+    return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
       ? serializeLazyID(importId)
       : serializeByValueID(importId);
   } catch (x) {
@@ -1442,7 +1442,7 @@
     null,
     !1,
     formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   retryTask(request, value);
   return value.id;
@@ -1457,7 +1457,7 @@
   function progress(entry) {
     if (0 === newTask.status)
       if (entry.done)
-        request.cacheController.signal.removeEventListener("abort", abortBlob),
+        request.cacheController.signal.removeEventListener('abort', abortBlob),
           pingTask(request, newTask);
       else
         return (
@@ -1466,7 +1466,7 @@
   }
   function error(reason) {
     0 === newTask.status &&
-      (request.cacheController.signal.removeEventListener("abort", abortBlob),
+      (request.cacheController.signal.removeEventListener('abort', abortBlob),
       erroredTask(request, newTask, reason),
       enqueueFlush(request),
       reader.cancel(reason).then(error, error));
@@ -1474,7 +1474,7 @@
   function abortBlob() {
     if (0 === newTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortBlob);
+      signal.removeEventListener('abort', abortBlob);
       signal = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(newTask),
@@ -1487,9 +1487,9 @@
   var model = [blob.type],
     newTask = createTask(request, model, null, !1, 0, request.abortableTasks),
     reader = blob.stream().getReader();
-  request.cacheController.signal.addEventListener("abort", abortBlob);
+  request.cacheController.signal.addEventListener('abort', abortBlob);
   reader.read().then(progress).catch(error);
-  return "$B" + newTask.id.toString(16);
+  return '$B' + newTask.id.toString(16);
 }
 var modelRoot = !1;
 function renderModelDestructive(
@@ -1497,12 +1497,12 @@
   task,
   parent,
   parentPropertyName,
-  value
+  value,
 ) {
   task.model = value;
-  if (value === REACT_ELEMENT_TYPE) return "$";
+  if (value === REACT_ELEMENT_TYPE) return '$';
   if (null === value) return null;
-  if ("object" === typeof value) {
+  if ('object' === typeof value) {
     switch (value.$$typeof) {
       case REACT_ELEMENT_TYPE:
         var elementReference = null,
@@ -1513,10 +1513,10 @@
             if (modelRoot === value) modelRoot = null;
             else return existingReference;
           else
-            -1 === parentPropertyName.indexOf(":") &&
+            -1 === parentPropertyName.indexOf(':') &&
               ((parent = writtenObjects.get(parent)),
               void 0 !== parent &&
-                ((elementReference = parent + ":" + parentPropertyName),
+                ((elementReference = parent + ':' + parentPropertyName),
                 writtenObjects.set(value, elementReference)));
         }
         if (3200 < serializedSize) return deferTask(request, task);
@@ -1528,9 +1528,9 @@
           value.type,
           value.key,
           void 0 !== parent ? parent : null,
-          parentPropertyName
+          parentPropertyName,
         );
-        "object" === typeof request &&
+        'object' === typeof request &&
           null !== request &&
           null !== elementReference &&
           (writtenObjects.has(request) ||
@@ -1542,10 +1542,10 @@
         parentPropertyName = value._init;
         value = parentPropertyName(value._payload);
         if (12 === request.status) throw null;
-        return renderModelDestructive(request, task, emptyRoot, "", value);
+        return renderModelDestructive(request, task, emptyRoot, '', value);
       case REACT_LEGACY_ELEMENT_TYPE:
         throw Error(
-          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
+          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.',
         );
     }
     if (value.$$typeof === CLIENT_REFERENCE_TAG$1)
@@ -1553,24 +1553,24 @@
         request,
         parent,
         parentPropertyName,
-        value
+        value,
       );
     if (
       void 0 !== request.temporaryReferences &&
       ((elementReference = request.temporaryReferences.get(value)),
       void 0 !== elementReference)
     )
-      return "$T" + elementReference;
+      return '$T' + elementReference;
     elementReference = request.writtenObjects;
     writtenObjects = elementReference.get(value);
-    if ("function" === typeof value.then) {
+    if ('function' === typeof value.then) {
       if (void 0 !== writtenObjects) {
         if (null !== task.keyPath || task.implicitSlot)
-          return "$@" + serializeThenable(request, task, value).toString(16);
+          return '$@' + serializeThenable(request, task, value).toString(16);
         if (modelRoot === value) modelRoot = null;
         else return writtenObjects;
       }
-      request = "$@" + serializeThenable(request, task, value).toString(16);
+      request = '$@' + serializeThenable(request, task, value).toString(16);
       elementReference.set(value, request);
       return request;
     }
@@ -1581,92 +1581,92 @@
         modelRoot = null;
       } else return writtenObjects;
     else if (
-      -1 === parentPropertyName.indexOf(":") &&
+      -1 === parentPropertyName.indexOf(':') &&
       ((writtenObjects = elementReference.get(parent)),
       void 0 !== writtenObjects)
     ) {
       existingReference = parentPropertyName;
       if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
         switch (parentPropertyName) {
-          case "1":
-            existingReference = "type";
+          case '1':
+            existingReference = 'type';
             break;
-          case "2":
-            existingReference = "key";
+          case '2':
+            existingReference = 'key';
             break;
-          case "3":
-            existingReference = "props";
+          case '3':
+            existingReference = 'props';
             break;
-          case "4":
-            existingReference = "_owner";
+          case '4':
+            existingReference = '_owner';
         }
-      elementReference.set(value, writtenObjects + ":" + existingReference);
+      elementReference.set(value, writtenObjects + ':' + existingReference);
     }
     if (isArrayImpl(value)) return renderFragment(request, task, value);
     if (value instanceof Map)
       return (
         (value = Array.from(value)),
-        "$Q" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$Q' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
     if (value instanceof Set)
       return (
         (value = Array.from(value)),
-        "$W" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$W' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
-    if ("function" === typeof FormData && value instanceof FormData)
+    if ('function' === typeof FormData && value instanceof FormData)
       return (
         (value = Array.from(value.entries())),
-        "$K" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$K' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
-    if (value instanceof Error) return "$Z";
+    if (value instanceof Error) return '$Z';
     if (value instanceof ArrayBuffer)
-      return serializeTypedArray(request, "A", new Uint8Array(value));
+      return serializeTypedArray(request, 'A', new Uint8Array(value));
     if (value instanceof Int8Array)
-      return serializeTypedArray(request, "O", value);
+      return serializeTypedArray(request, 'O', value);
     if (value instanceof Uint8Array)
-      return serializeTypedArray(request, "o", value);
+      return serializeTypedArray(request, 'o', value);
     if (value instanceof Uint8ClampedArray)
-      return serializeTypedArray(request, "U", value);
+      return serializeTypedArray(request, 'U', value);
     if (value instanceof Int16Array)
-      return serializeTypedArray(request, "S", value);
+      return serializeTypedArray(request, 'S', value);
     if (value instanceof Uint16Array)
-      return serializeTypedArray(request, "s", value);
+      return serializeTypedArray(request, 's', value);
     if (value instanceof Int32Array)
-      return serializeTypedArray(request, "L", value);
+      return serializeTypedArray(request, 'L', value);
     if (value instanceof Uint32Array)
-      return serializeTypedArray(request, "l", value);
+      return serializeTypedArray(request, 'l', value);
     if (value instanceof Float32Array)
-      return serializeTypedArray(request, "G", value);
+      return serializeTypedArray(request, 'G', value);
     if (value instanceof Float64Array)
-      return serializeTypedArray(request, "g", value);
+      return serializeTypedArray(request, 'g', value);
     if (value instanceof BigInt64Array)
-      return serializeTypedArray(request, "M", value);
+      return serializeTypedArray(request, 'M', value);
     if (value instanceof BigUint64Array)
-      return serializeTypedArray(request, "m", value);
+      return serializeTypedArray(request, 'm', value);
     if (value instanceof DataView)
-      return serializeTypedArray(request, "V", value);
-    if ("function" === typeof Blob && value instanceof Blob)
+      return serializeTypedArray(request, 'V', value);
+    if ('function' === typeof Blob && value instanceof Blob)
       return serializeBlob(request, value);
     if ((elementReference = getIteratorFn(value)))
       return (
         (parentPropertyName = elementReference.call(value)),
         parentPropertyName === value
           ? ((value = Array.from(parentPropertyName)),
-            "$i" +
+            '$i' +
               outlineModelWithFormatContext(request, value, 0).toString(16))
           : renderFragment(request, task, Array.from(parentPropertyName))
       );
-    if ("function" === typeof ReadableStream && value instanceof ReadableStream)
+    if ('function' === typeof ReadableStream && value instanceof ReadableStream)
       return serializeReadableStream(request, task, value);
     elementReference = value[ASYNC_ITERATOR];
-    if ("function" === typeof elementReference)
+    if ('function' === typeof elementReference)
       return (
         null !== task.keyPath
           ? ((request = [
               REACT_ELEMENT_TYPE,
               REACT_FRAGMENT_TYPE,
               task.keyPath,
-              { children: value }
+              { children: value },
             ]),
             (request = task.implicitSlot ? [request] : request))
           : ((parentPropertyName = elementReference.call(value)),
@@ -1674,29 +1674,29 @@
               request,
               task,
               value,
-              parentPropertyName
+              parentPropertyName,
             ))),
         request
       );
-    if (value instanceof Date) return "$D" + value.toJSON();
+    if (value instanceof Date) return '$D' + value.toJSON();
     request = getPrototypeOf(value);
     if (
       request !== ObjectPrototype &&
       (null === request || null !== getPrototypeOf(request))
     )
       throw Error(
-        "Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported." +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+        'Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.' +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     return value;
   }
-  if ("string" === typeof value) {
+  if ('string' === typeof value) {
     serializedSize += value.length;
     if (
-      "Z" === value[value.length - 1] &&
+      'Z' === value[value.length - 1] &&
       parent[parentPropertyName] instanceof Date
     )
-      return "$D" + value;
+      return '$D' + value;
     if (1024 <= value.length && null !== byteLengthOfChunk)
       return (
         request.pendingChunks++,
@@ -1704,35 +1704,35 @@
         emitTextChunk(request, task, value, !1),
         serializeByValueID(task)
       );
-    request = "$" === value[0] ? "$" + value : value;
+    request = '$' === value[0] ? '$' + value : value;
     return request;
   }
-  if ("boolean" === typeof value) return value;
-  if ("number" === typeof value)
+  if ('boolean' === typeof value) return value;
+  if ('number' === typeof value)
     return Number.isFinite(value)
       ? 0 === value && -Infinity === 1 / value
-        ? "$-0"
+        ? '$-0'
         : value
       : Infinity === value
-        ? "$Infinity"
+        ? '$Infinity'
         : -Infinity === value
-          ? "$-Infinity"
-          : "$NaN";
-  if ("undefined" === typeof value) return "$undefined";
-  if ("function" === typeof value) {
+          ? '$-Infinity'
+          : '$NaN';
+  if ('undefined' === typeof value) return '$undefined';
+  if ('function' === typeof value) {
     if (value.$$typeof === CLIENT_REFERENCE_TAG$1)
       return serializeClientReference(
         request,
         parent,
         parentPropertyName,
-        value
+        value,
       );
     if (value.$$typeof === SERVER_REFERENCE_TAG)
       return (
         (task = request.writtenServerReferences),
         (parentPropertyName = task.get(value)),
         void 0 !== parentPropertyName
-          ? (request = "$F" + parentPropertyName.toString(16))
+          ? (request = '$F' + parentPropertyName.toString(16))
           : ((parentPropertyName = value.$$bound),
             (parentPropertyName =
               null === parentPropertyName
@@ -1741,33 +1741,33 @@
             (request = outlineModelWithFormatContext(
               request,
               { id: value.$$id, bound: parentPropertyName },
-              0
+              0,
             )),
             task.set(value, request),
-            (request = "$F" + request.toString(16))),
+            (request = '$F' + request.toString(16))),
         request
       );
     if (
       void 0 !== request.temporaryReferences &&
       ((request = request.temporaryReferences.get(value)), void 0 !== request)
     )
-      return "$T" + request;
+      return '$T' + request;
     if (value.$$typeof === TEMPORARY_REFERENCE_TAG)
       throw Error(
-        "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+        'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
       );
     if (/^on[A-Z]/.test(parentPropertyName))
       throw Error(
-        "Event handlers cannot be passed to Client Component props." +
+        'Event handlers cannot be passed to Client Component props.' +
           describeObjectForErrorMessage(parent, parentPropertyName) +
-          "\nIf you need interactivity, consider converting part of this to a Client Component."
+          '\nIf you need interactivity, consider converting part of this to a Client Component.',
       );
     throw Error(
       'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.' +
-        describeObjectForErrorMessage(parent, parentPropertyName)
+        describeObjectForErrorMessage(parent, parentPropertyName),
     );
   }
-  if ("symbol" === typeof value) {
+  if ('symbol' === typeof value) {
     task = request.writtenSymbols;
     elementReference = task.get(value);
     if (void 0 !== elementReference)
@@ -1775,27 +1775,27 @@
     elementReference = value.description;
     if (Symbol.for(elementReference) !== value)
       throw Error(
-        "Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" +
-          (value.description + ") cannot be found among global symbols.") +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+        'Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(' +
+          (value.description + ') cannot be found among global symbols.') +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     request.pendingChunks++;
     parentPropertyName = request.nextChunkId++;
     parent = encodeReferenceChunk(
       request,
       parentPropertyName,
-      "$S" + elementReference
+      '$S' + elementReference,
     );
     request.completedImportChunks.push(parent);
     task.set(value, parentPropertyName);
     return serializeByValueID(parentPropertyName);
   }
-  if ("bigint" === typeof value) return "$n" + value.toString(10);
+  if ('bigint' === typeof value) return '$n' + value.toString(10);
   throw Error(
-    "Type " +
+    'Type ' +
       typeof value +
-      " is not supported in Client Component props." +
-      describeObjectForErrorMessage(parent, parentPropertyName)
+      ' is not supported in Client Component props.' +
+      describeObjectForErrorMessage(parent, parentPropertyName),
   );
 }
 function logRecoverableError(request, error) {
@@ -1807,13 +1807,13 @@
   } finally {
     currentRequest = prevRequest;
   }
-  if (null != errorDigest && "string" !== typeof errorDigest)
+  if (null != errorDigest && 'string' !== typeof errorDigest)
     throw Error(
       'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
         typeof errorDigest +
-        '" instead'
+        '" instead',
     );
-  return errorDigest || "";
+  return errorDigest || '';
 }
 function fatalError(request, error) {
   var onFatalError = request.onFatalError;
@@ -1822,17 +1822,17 @@
     ? ((request.status = 14), closeWithError(request.destination, error))
     : ((request.status = 13), (request.fatalError = error));
   request.cacheController.abort(
-    Error("The render was aborted due to a fatal error.", { cause: error })
+    Error('The render was aborted due to a fatal error.', { cause: error }),
   );
 }
 function emitErrorChunk(request, id, digest) {
   digest = { digest: digest };
-  id = id.toString(16) + ":E" + stringify(digest) + "\n";
+  id = id.toString(16) + ':E' + stringify(digest) + '\n';
   id = stringToChunk(id);
   request.completedErrorChunks.push(id);
 }
 function emitModelChunk(request, id, json) {
-  id = id.toString(16) + ":" + json + "\n";
+  id = id.toString(16) + ':' + json + '\n';
   id = stringToChunk(id);
   request.completedRegularChunks.push(id);
 }
@@ -1841,56 +1841,56 @@
   debug = new Uint8Array(
     typedArray.buffer,
     typedArray.byteOffset,
-    typedArray.byteLength
+    typedArray.byteLength,
   );
   typedArray = 2048 < typedArray.byteLength ? debug.slice() : debug;
   debug = typedArray.byteLength;
-  id = id.toString(16) + ":" + tag + debug.toString(16) + ",";
+  id = id.toString(16) + ':' + tag + debug.toString(16) + ',';
   id = stringToChunk(id);
   request.completedRegularChunks.push(id, typedArray);
 }
 function emitTextChunk(request, id, text, debug) {
   if (null === byteLengthOfChunk)
     throw Error(
-      "Existence of byteLengthOfChunk should have already been checked. This is a bug in React."
+      'Existence of byteLengthOfChunk should have already been checked. This is a bug in React.',
     );
   debug ? request.pendingDebugChunks++ : request.pendingChunks++;
   text = stringToChunk(text);
   debug = text.byteLength;
-  id = id.toString(16) + ":T" + debug.toString(16) + ",";
+  id = id.toString(16) + ':T' + debug.toString(16) + ',';
   id = stringToChunk(id);
   request.completedRegularChunks.push(id, text);
 }
 function emitChunk(request, task, value) {
   var id = task.id;
-  "string" === typeof value && null !== byteLengthOfChunk
+  'string' === typeof value && null !== byteLengthOfChunk
     ? emitTextChunk(request, id, value, !1)
     : value instanceof ArrayBuffer
-      ? emitTypedArrayChunk(request, id, "A", new Uint8Array(value), !1)
+      ? emitTypedArrayChunk(request, id, 'A', new Uint8Array(value), !1)
       : value instanceof Int8Array
-        ? emitTypedArrayChunk(request, id, "O", value, !1)
+        ? emitTypedArrayChunk(request, id, 'O', value, !1)
         : value instanceof Uint8Array
-          ? emitTypedArrayChunk(request, id, "o", value, !1)
+          ? emitTypedArrayChunk(request, id, 'o', value, !1)
           : value instanceof Uint8ClampedArray
-            ? emitTypedArrayChunk(request, id, "U", value, !1)
+            ? emitTypedArrayChunk(request, id, 'U', value, !1)
             : value instanceof Int16Array
-              ? emitTypedArrayChunk(request, id, "S", value, !1)
+              ? emitTypedArrayChunk(request, id, 'S', value, !1)
               : value instanceof Uint16Array
-                ? emitTypedArrayChunk(request, id, "s", value, !1)
+                ? emitTypedArrayChunk(request, id, 's', value, !1)
                 : value instanceof Int32Array
-                  ? emitTypedArrayChunk(request, id, "L", value, !1)
+                  ? emitTypedArrayChunk(request, id, 'L', value, !1)
                   : value instanceof Uint32Array
-                    ? emitTypedArrayChunk(request, id, "l", value, !1)
+                    ? emitTypedArrayChunk(request, id, 'l', value, !1)
                     : value instanceof Float32Array
-                      ? emitTypedArrayChunk(request, id, "G", value, !1)
+                      ? emitTypedArrayChunk(request, id, 'G', value, !1)
                       : value instanceof Float64Array
-                        ? emitTypedArrayChunk(request, id, "g", value, !1)
+                        ? emitTypedArrayChunk(request, id, 'g', value, !1)
                         : value instanceof BigInt64Array
-                          ? emitTypedArrayChunk(request, id, "M", value, !1)
+                          ? emitTypedArrayChunk(request, id, 'M', value, !1)
                           : value instanceof BigUint64Array
-                            ? emitTypedArrayChunk(request, id, "m", value, !1)
+                            ? emitTypedArrayChunk(request, id, 'm', value, !1)
                             : value instanceof DataView
-                              ? emitTypedArrayChunk(request, id, "V", value, !1)
+                              ? emitTypedArrayChunk(request, id, 'V', value, !1)
                               : ((value = stringify(value, task.toJSON)),
                                 emitModelChunk(request, task.id, value));
 }
@@ -1912,13 +1912,13 @@
         request,
         task,
         emptyRoot,
-        "",
-        task.model
+        '',
+        task.model,
       );
       modelRoot = resolvedModel;
       task.keyPath = null;
       task.implicitSlot = !1;
-      if ("object" === typeof resolvedModel && null !== resolvedModel)
+      if ('object' === typeof resolvedModel && null !== resolvedModel)
         request.writtenObjects.set(resolvedModel, serializeByValueID(task.id)),
           emitChunk(request, task, resolvedModel);
       else {
@@ -1947,9 +1947,9 @@
             ? getSuspendedThenable()
             : thrownValue;
         if (
-          "object" === typeof x &&
+          'object' === typeof x &&
           null !== x &&
-          "function" === typeof x.then
+          'function' === typeof x.then
         ) {
           task.status = 0;
           task.thenableState = getThenableStateAfterSuspending();
@@ -2037,7 +2037,7 @@
         currentView &&
           0 < writtenBytes &&
           (destination.enqueue(
-            new Uint8Array(currentView.buffer, 0, writtenBytes)
+            new Uint8Array(currentView.buffer, 0, writtenBytes),
           ),
           (currentView = null),
           (writtenBytes = 0));
@@ -2047,8 +2047,8 @@
     (12 > request.status &&
       request.cacheController.abort(
         Error(
-          "This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources."
-        )
+          'This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources.',
+        ),
       ),
     null !== request.destination &&
       ((request.status = 14),
@@ -2132,13 +2132,13 @@
           var error =
               void 0 === reason
                 ? Error(
-                    "The render was aborted by the server without a reason."
+                    'The render was aborted by the server without a reason.',
                   )
-                : "object" === typeof reason &&
+                : 'object' === typeof reason &&
                     null !== reason &&
-                    "function" === typeof reason.then
+                    'function' === typeof reason.then
                   ? Error(
-                      "The render was aborted by the server with a promise."
+                      'The render was aborted by the server with a promise.',
                     )
                   : reason,
             digest = logRecoverableError(request, error, null),
@@ -2164,11 +2164,11 @@
     }
 }
 function resolveServerReference(bundlerConfig, id) {
-  var name = "",
+  var name = '',
     resolvedModuleData = bundlerConfig[id];
   if (resolvedModuleData) name = resolvedModuleData.name;
   else {
-    var idx = id.lastIndexOf("#");
+    var idx = id.lastIndexOf('#');
     -1 !== idx &&
       ((name = id.slice(idx + 1)),
       (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -2176,7 +2176,7 @@
       throw Error(
         'Could not find the module "' +
           id +
-          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
       );
   }
   return resolvedModuleData.async
@@ -2186,17 +2186,17 @@
 var chunkCache = new Map();
 function requireAsyncModule(id) {
   var promise = __webpack_require__(id);
-  if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+  if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
     return null;
   promise.then(
     function (value) {
-      promise.status = "fulfilled";
+      promise.status = 'fulfilled';
       promise.value = value;
     },
     function (reason) {
-      promise.status = "rejected";
+      promise.status = 'rejected';
       promise.reason = reason;
-    }
+    },
   );
   return promise;
 }
@@ -2227,13 +2227,13 @@
 }
 function requireModule(metadata) {
   var moduleExports = __webpack_require__(metadata[0]);
-  if (4 === metadata.length && "function" === typeof moduleExports.then)
-    if ("fulfilled" === moduleExports.status)
+  if (4 === metadata.length && 'function' === typeof moduleExports.then)
+    if ('fulfilled' === moduleExports.status)
       moduleExports = moduleExports.value;
     else throw moduleExports.reason;
-  return "*" === metadata[2]
+  return '*' === metadata[2]
     ? moduleExports
-    : "" === metadata[2]
+    : '' === metadata[2]
       ? moduleExports.__esModule
         ? moduleExports.default
         : moduleExports
@@ -2256,16 +2256,16 @@
 Chunk.prototype = Object.create(Promise.prototype);
 Chunk.prototype.then = function (resolve, reject) {
   switch (this.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(this);
   }
   switch (this.status) {
-    case "fulfilled":
+    case 'fulfilled':
       resolve(this.value);
       break;
-    case "pending":
-    case "blocked":
-    case "cyclic":
+    case 'pending':
+    case 'blocked':
+    case 'cyclic':
       resolve &&
         (null === this.value && (this.value = []), this.value.push(resolve));
       reject &&
@@ -2276,41 +2276,41 @@
   }
 };
 function createPendingChunk(response) {
-  return new Chunk("pending", null, null, response);
+  return new Chunk('pending', null, null, response);
 }
 function wakeChunk(listeners, value) {
   for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
 }
 function triggerErrorOnChunk(chunk, error) {
-  if ("pending" !== chunk.status && "blocked" !== chunk.status)
+  if ('pending' !== chunk.status && 'blocked' !== chunk.status)
     chunk.reason.error(error);
   else {
     var listeners = chunk.reason;
-    chunk.status = "rejected";
+    chunk.status = 'rejected';
     chunk.reason = error;
     null !== listeners && wakeChunk(listeners, error);
   }
 }
 function resolveModelChunk(chunk, value, id) {
-  if ("pending" !== chunk.status)
+  if ('pending' !== chunk.status)
     (chunk = chunk.reason),
-      "C" === value[0]
-        ? chunk.close("C" === value ? '"$undefined"' : value.slice(1))
+      'C' === value[0]
+        ? chunk.close('C' === value ? '"$undefined"' : value.slice(1))
         : chunk.enqueueModel(value);
   else {
     var resolveListeners = chunk.value,
       rejectListeners = chunk.reason;
-    chunk.status = "resolved_model";
+    chunk.status = 'resolved_model';
     chunk.value = value;
     chunk.reason = id;
     if (null !== resolveListeners)
       switch ((initializeModelChunk(chunk), chunk.status)) {
-        case "fulfilled":
+        case 'fulfilled':
           wakeChunk(resolveListeners, chunk.value);
           break;
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           if (chunk.value)
             for (value = 0; value < resolveListeners.length; value++)
               chunk.value.push(resolveListeners[value]);
@@ -2321,24 +2321,24 @@
                 chunk.reason.push(rejectListeners[value]);
           } else chunk.reason = rejectListeners;
           break;
-        case "rejected":
+        case 'rejected':
           rejectListeners && wakeChunk(rejectListeners, chunk.reason);
       }
   }
 }
 function createResolvedIteratorResultChunk(response, value, done) {
   return new Chunk(
-    "resolved_model",
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
+    'resolved_model',
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
     -1,
-    response
+    response,
   );
 }
 function resolveIteratorResultChunk(chunk, value, done) {
   resolveModelChunk(
     chunk,
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
-    -1
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
+    -1,
   );
 }
 function loadServerReference$1(
@@ -2347,7 +2347,7 @@
   bound,
   parentChunk,
   parentObject,
-  key
+  key,
 ) {
   var serverReference = resolveServerReference(response._bundlerConfig, id);
   id = preloadModule(serverReference);
@@ -2370,16 +2370,16 @@
       !1,
       response,
       createModel,
-      []
+      [],
     ),
-    createModelReject(parentChunk)
+    createModelReject(parentChunk),
   );
   return null;
 }
 function reviveModel(response, parentObj, parentKey, value, reference) {
-  if ("string" === typeof value)
+  if ('string' === typeof value)
     return parseModelString(response, parentObj, parentKey, value, reference);
-  if ("object" === typeof value && null !== value)
+  if ('object' === typeof value && null !== value)
     if (
       (void 0 !== reference &&
         void 0 !== response._temporaryReferences &&
@@ -2390,16 +2390,16 @@
         value[i] = reviveModel(
           response,
           value,
-          "" + i,
+          '' + i,
           value[i],
-          void 0 !== reference ? reference + ":" + i : void 0
+          void 0 !== reference ? reference + ':' + i : void 0,
         );
     else
       for (i in value)
         hasOwnProperty.call(value, i) &&
           ((parentObj =
-            void 0 !== reference && -1 === i.indexOf(":")
-              ? reference + ":" + i
+            void 0 !== reference && -1 === i.indexOf(':')
+              ? reference + ':' + i
               : void 0),
           (parentObj = reviveModel(response, value, i, value[i], parentObj)),
           void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);
@@ -2414,31 +2414,31 @@
   initializingChunkBlockedModel = null;
   var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),
     resolvedModel = chunk.value;
-  chunk.status = "cyclic";
+  chunk.status = 'cyclic';
   chunk.value = null;
   chunk.reason = null;
   try {
     var rawModel = JSON.parse(resolvedModel),
       value = reviveModel(
         chunk._response,
-        { "": rawModel },
-        "",
+        { '': rawModel },
+        '',
         rawModel,
-        rootReference
+        rootReference,
       );
     if (
       null !== initializingChunkBlockedModel &&
       0 < initializingChunkBlockedModel.deps
     )
-      (initializingChunkBlockedModel.value = value), (chunk.status = "blocked");
+      (initializingChunkBlockedModel.value = value), (chunk.status = 'blocked');
     else {
       var resolveListeners = chunk.value;
-      chunk.status = "fulfilled";
+      chunk.status = 'fulfilled';
       chunk.value = value;
       null !== resolveListeners && wakeChunk(resolveListeners, value);
     }
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   } finally {
     (initializingChunk = prevChunk),
       (initializingChunkBlockedModel = prevBlocked);
@@ -2448,7 +2448,7 @@
   response._closed = !0;
   response._closedReason = error;
   response._chunks.forEach(function (chunk) {
-    "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+    'pending' === chunk.status && triggerErrorOnChunk(chunk, error);
   });
 }
 function getChunk(response, id) {
@@ -2458,9 +2458,9 @@
     ((chunk = response._formData.get(response._prefix + id)),
     (chunk =
       null != chunk
-        ? new Chunk("resolved_model", chunk, id, response)
+        ? new Chunk('resolved_model', chunk, id, response)
         : response._closed
-          ? new Chunk("rejected", null, response._closedReason, response)
+          ? new Chunk('rejected', null, response._closedReason, response)
           : createPendingChunk(response)),
     chunks.set(id, chunk));
   return chunk;
@@ -2472,7 +2472,7 @@
   cyclic,
   response,
   map,
-  path
+  path,
 ) {
   if (initializingChunkBlockedModel) {
     var blocked = initializingChunkBlockedModel;
@@ -2480,17 +2480,17 @@
   } else
     blocked = initializingChunkBlockedModel = {
       deps: cyclic ? 0 : 1,
-      value: null
+      value: null,
     };
   return function (value) {
     for (var i = 1; i < path.length; i++) value = value[path[i]];
     parentObject[key] = map(response, value);
-    "" === key && null === blocked.value && (blocked.value = parentObject[key]);
+    '' === key && null === blocked.value && (blocked.value = parentObject[key]);
     blocked.deps--;
     0 === blocked.deps &&
-      "blocked" === chunk.status &&
+      'blocked' === chunk.status &&
       ((value = chunk.value),
-      (chunk.status = "fulfilled"),
+      (chunk.status = 'fulfilled'),
       (chunk.value = blocked.value),
       null !== value && wakeChunk(value, blocked.value));
   };
@@ -2501,34 +2501,34 @@
   };
 }
 function getOutlinedModel(response, reference, parentObject, key, map) {
-  reference = reference.split(":");
+  reference = reference.split(':');
   var id = parseInt(reference[0], 16);
   id = getChunk(response, id);
   switch (id.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(id);
   }
   switch (id.status) {
-    case "fulfilled":
+    case 'fulfilled':
       parentObject = id.value;
       for (key = 1; key < reference.length; key++)
         parentObject = parentObject[reference[key]];
       return map(response, parentObject);
-    case "pending":
-    case "blocked":
-    case "cyclic":
+    case 'pending':
+    case 'blocked':
+    case 'cyclic':
       var parentChunk = initializingChunk;
       id.then(
         createModelResolver(
           parentChunk,
           parentObject,
           key,
-          "cyclic" === id.status,
+          'cyclic' === id.status,
           response,
           map,
-          reference
+          reference,
         ),
-        createModelReject(parentChunk)
+        createModelReject(parentChunk),
       );
       return null;
     default:
@@ -2553,7 +2553,7 @@
   constructor,
   bytesPerElement,
   parentObject,
-  parentKey
+  parentKey,
 ) {
   reference = parseInt(reference.slice(2), 16);
   reference = response._formData.get(response._prefix + reference);
@@ -2572,21 +2572,21 @@
       !1,
       response,
       createModel,
-      []
+      [],
     ),
-    createModelReject(bytesPerElement)
+    createModelReject(bytesPerElement),
   );
   return null;
 }
 function resolveStream(response, id, stream, controller) {
   var chunks = response._chunks;
-  stream = new Chunk("fulfilled", stream, controller, response);
+  stream = new Chunk('fulfilled', stream, controller, response);
   chunks.set(id, stream);
   response = response._formData.getAll(response._prefix + id);
   for (id = 0; id < response.length; id++)
     (chunks = response[id]),
-      "C" === chunks[0]
-        ? controller.close("C" === chunks ? '"$undefined"' : chunks.slice(1))
+      'C' === chunks[0]
+        ? controller.close('C' === chunks ? '"$undefined"' : chunks.slice(1))
         : controller.enqueueModel(chunks);
 }
 function parseReadableStream(response, reference, type) {
@@ -2596,15 +2596,15 @@
     type: type,
     start: function (c) {
       controller = c;
-    }
+    },
   });
   var previousBlockedChunk = null;
   resolveStream(response, reference, type, {
     enqueueModel: function (json) {
       if (null === previousBlockedChunk) {
-        var chunk = new Chunk("resolved_model", json, -1, response);
+        var chunk = new Chunk('resolved_model', json, -1, response);
         initializeModelChunk(chunk);
-        "fulfilled" === chunk.status
+        'fulfilled' === chunk.status
           ? controller.enqueue(chunk.value)
           : (chunk.then(
               function (v) {
@@ -2612,7 +2612,7 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             ),
             (previousBlockedChunk = chunk));
       } else {
@@ -2624,7 +2624,7 @@
           },
           function (e) {
             return controller.error(e);
-          }
+          },
         );
         previousBlockedChunk = chunk$26;
         chunk.then(function () {
@@ -2652,7 +2652,7 @@
           return controller.error(error);
         });
       }
-    }
+    },
   });
   return type;
 }
@@ -2676,15 +2676,15 @@
       return createIterator(function (arg) {
         if (void 0 !== arg)
           throw Error(
-            "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+            'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
           );
         if (nextReadIndex === buffer.length) {
           if (closed)
             return new Chunk(
-              "fulfilled",
+              'fulfilled',
               { done: !0, value: void 0 },
               null,
-              response
+              response,
             );
           buffer[nextReadIndex] = createPendingChunk(response);
         }
@@ -2699,7 +2699,7 @@
         ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
             response,
             value,
-            !1
+            !1,
           ))
         : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
       nextWriteIndex++;
@@ -2710,14 +2710,14 @@
         ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
             response,
             value,
-            !0
+            !0,
           ))
         : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
       for (nextWriteIndex++; nextWriteIndex < buffer.length; )
         resolveIteratorResultChunk(
           buffer[nextWriteIndex++],
           '"$undefined"',
-          !0
+          !0,
         );
     },
     error: function (error) {
@@ -2729,18 +2729,18 @@
 
       )
         triggerErrorOnChunk(buffer[nextWriteIndex++], error);
-    }
+    },
   });
   return iterator;
 }
 function parseModelString(response, obj, key, value, reference) {
-  if ("$" === value[0]) {
+  if ('$' === value[0]) {
     switch (value[1]) {
-      case "$":
+      case '$':
         return value.slice(1);
-      case "@":
+      case '@':
         return (obj = parseInt(value.slice(2), 16)), getChunk(response, obj);
-      case "F":
+      case 'F':
         return (
           (value = value.slice(2)),
           (value = getOutlinedModel(response, value, obj, key, createModel)),
@@ -2750,96 +2750,96 @@
             value.bound,
             initializingChunk,
             obj,
-            key
+            key,
           )
         );
-      case "T":
+      case 'T':
         if (void 0 === reference || void 0 === response._temporaryReferences)
           throw Error(
-            "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+            'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
           );
         return createTemporaryReference(
           response._temporaryReferences,
-          reference
+          reference,
         );
-      case "Q":
+      case 'Q':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, createMap)
         );
-      case "W":
+      case 'W':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, createSet)
         );
-      case "K":
+      case 'K':
         obj = value.slice(2);
-        var formPrefix = response._prefix + obj + "_",
+        var formPrefix = response._prefix + obj + '_',
           data = new FormData();
         response._formData.forEach(function (entry, entryKey) {
           entryKey.startsWith(formPrefix) &&
             data.append(entryKey.slice(formPrefix.length), entry);
         });
         return data;
-      case "i":
+      case 'i':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, extractIterator)
         );
-      case "I":
+      case 'I':
         return Infinity;
-      case "-":
-        return "$-0" === value ? -0 : -Infinity;
-      case "N":
+      case '-':
+        return '$-0' === value ? -0 : -Infinity;
+      case 'N':
         return NaN;
-      case "u":
+      case 'u':
         return;
-      case "D":
+      case 'D':
         return new Date(Date.parse(value.slice(2)));
-      case "n":
+      case 'n':
         return BigInt(value.slice(2));
     }
     switch (value[1]) {
-      case "A":
+      case 'A':
         return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);
-      case "O":
+      case 'O':
         return parseTypedArray(response, value, Int8Array, 1, obj, key);
-      case "o":
+      case 'o':
         return parseTypedArray(response, value, Uint8Array, 1, obj, key);
-      case "U":
+      case 'U':
         return parseTypedArray(response, value, Uint8ClampedArray, 1, obj, key);
-      case "S":
+      case 'S':
         return parseTypedArray(response, value, Int16Array, 2, obj, key);
-      case "s":
+      case 's':
         return parseTypedArray(response, value, Uint16Array, 2, obj, key);
-      case "L":
+      case 'L':
         return parseTypedArray(response, value, Int32Array, 4, obj, key);
-      case "l":
+      case 'l':
         return parseTypedArray(response, value, Uint32Array, 4, obj, key);
-      case "G":
+      case 'G':
         return parseTypedArray(response, value, Float32Array, 4, obj, key);
-      case "g":
+      case 'g':
         return parseTypedArray(response, value, Float64Array, 8, obj, key);
-      case "M":
+      case 'M':
         return parseTypedArray(response, value, BigInt64Array, 8, obj, key);
-      case "m":
+      case 'm':
         return parseTypedArray(response, value, BigUint64Array, 8, obj, key);
-      case "V":
+      case 'V':
         return parseTypedArray(response, value, DataView, 1, obj, key);
-      case "B":
+      case 'B':
         return (
           (obj = parseInt(value.slice(2), 16)),
           response._formData.get(response._prefix + obj)
         );
     }
     switch (value[1]) {
-      case "R":
+      case 'R':
         return parseReadableStream(response, value, void 0);
-      case "r":
-        return parseReadableStream(response, value, "bytes");
-      case "X":
+      case 'r':
+        return parseReadableStream(response, value, 'bytes');
+      case 'X':
         return parseAsyncIterable(response, value, !1);
-      case "x":
+      case 'x':
         return parseAsyncIterable(response, value, !0);
     }
     value = value.slice(1);
@@ -2860,11 +2860,11 @@
     _chunks: chunks,
     _closed: !1,
     _closedReason: null,
-    _temporaryReferences: temporaryReferences
+    _temporaryReferences: temporaryReferences,
   };
 }
 function close(response) {
-  reportGlobalError(response, Error("Connection closed."));
+  reportGlobalError(response, Error('Connection closed.'));
 }
 function loadServerReference(bundlerConfig, id, bound) {
   var serverReference = resolveServerReference(bundlerConfig, id);
@@ -2886,7 +2886,7 @@
   close(body);
   body = getChunk(body, 0);
   body.then(function () {});
-  if ("fulfilled" !== body.status) throw body.reason;
+  if ('fulfilled' !== body.status) throw body.reason;
   return body.value;
 }
 exports.createClientModuleProxy = function (moduleId) {
@@ -2900,12 +2900,12 @@
   var formData = new FormData(),
     action = null;
   body.forEach(function (value, key) {
-    key.startsWith("$ACTION_")
-      ? key.startsWith("$ACTION_REF_")
-        ? ((value = "$ACTION_" + key.slice(12) + ":"),
+    key.startsWith('$ACTION_')
+      ? key.startsWith('$ACTION_REF_')
+        ? ((value = '$ACTION_' + key.slice(12) + ':'),
           (value = decodeBoundActionMetaData(body, serverManifest, value)),
           (action = loadServerReference(serverManifest, value.id, value.bound)))
-        : key.startsWith("$ACTION_ID_") &&
+        : key.startsWith('$ACTION_ID_') &&
           ((value = key.slice(11)),
           (action = loadServerReference(serverManifest, value, null)))
       : formData.append(key, value);
@@ -2917,12 +2917,12 @@
       });
 };
 exports.decodeFormState = function (actionResult, body, serverManifest) {
-  var keyPath = body.get("$ACTION_KEY");
-  if ("string" !== typeof keyPath) return Promise.resolve(null);
+  var keyPath = body.get('$ACTION_KEY');
+  if ('string' !== typeof keyPath) return Promise.resolve(null);
   var metaData = null;
   body.forEach(function (value, key) {
-    key.startsWith("$ACTION_REF_") &&
-      ((value = "$ACTION_" + key.slice(12) + ":"),
+    key.startsWith('$ACTION_REF_') &&
+      ((value = '$ACTION_' + key.slice(12) + ':'),
       (metaData = decodeBoundActionMetaData(body, serverManifest, value)));
   });
   if (null === metaData) return Promise.resolve(null);
@@ -2934,16 +2934,16 @@
   });
 };
 exports.decodeReply = function (body, webpackMap, options) {
-  if ("string" === typeof body) {
+  if ('string' === typeof body) {
     var form = new FormData();
-    form.append("0", body);
+    form.append('0', body);
     body = form;
   }
   body = createResponse(
     webpackMap,
-    "",
+    '',
     options ? options.temporaryReferences : void 0,
-    body
+    body,
   );
   webpackMap = getChunk(body, 0);
   close(body);
@@ -2960,22 +2960,22 @@
       function () {
         var stream = new ReadableStream(
           {
-            type: "bytes",
+            type: 'bytes',
             pull: function (controller) {
               startFlowing(request, controller);
             },
             cancel: function (reason) {
               request.destination = null;
               abort(request, reason);
-            }
+            },
           },
-          { highWaterMark: 0 }
+          { highWaterMark: 0 },
         );
         resolve({ prelude: stream });
       },
       reject,
       options ? options.identifierPrefix : void 0,
-      options ? options.temporaryReferences : void 0
+      options ? options.temporaryReferences : void 0,
     );
     if (options && options.signal) {
       var signal = options.signal;
@@ -2983,9 +2983,9 @@
       else {
         var listener = function () {
           abort(request, signal.reason);
-          signal.removeEventListener("abort", listener);
+          signal.removeEventListener('abort', listener);
         };
-        signal.addEventListener("abort", listener);
+        signal.addEventListener('abort', listener);
       }
     }
     startWork(request);
@@ -2994,23 +2994,23 @@
 exports.registerClientReference = function (
   proxyImplementation,
   id,
-  exportName
+  exportName,
 ) {
   return registerClientReferenceImpl(
     proxyImplementation,
-    id + "#" + exportName,
-    !1
+    id + '#' + exportName,
+    !1,
   );
 };
 exports.registerServerReference = function (reference, id, exportName) {
   return Object.defineProperties(reference, {
     $$typeof: { value: SERVER_REFERENCE_TAG },
     $$id: {
-      value: null === exportName ? id : id + "#" + exportName,
-      configurable: !0
+      value: null === exportName ? id : id + '#' + exportName,
+      configurable: !0,
     },
     $$bound: { value: null, configurable: !0 },
-    bind: { value: bind, configurable: !0 }
+    bind: { value: bind, configurable: !0 },
   });
 };
 exports.renderToReadableStream = function (model, webpackMap, options) {
@@ -3023,7 +3023,7 @@
     noop,
     noop,
     options ? options.identifierPrefix : void 0,
-    options ? options.temporaryReferences : void 0
+    options ? options.temporaryReferences : void 0,
   );
   if (options && options.signal) {
     var signal = options.signal;
@@ -3031,14 +3031,14 @@
     else {
       var listener = function () {
         abort(request, signal.reason);
-        signal.removeEventListener("abort", listener);
+        signal.removeEventListener('abort', listener);
       };
-      signal.addEventListener("abort", listener);
+      signal.addEventListener('abort', listener);
     }
   }
   return new ReadableStream(
     {
-      type: "bytes",
+      type: 'bytes',
       start: function () {
         startWork(request);
       },
@@ -3048,8 +3048,8 @@
       cancel: function (reason) {
         request.destination = null;
         abort(request, reason);
-      }
+      },
     },
-    { highWaterMark: 0 }
+    { highWaterMark: 0 },
   );
 };
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.edge.development.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.edge.development.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js	2025-12-17 14:32:44
@@ -8,35 +8,35 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
+'use strict';
+'production' !== process.env.NODE_ENV &&
   (function () {
     function voidHandler() {}
     function getIteratorFn(maybeIterable) {
-      if (null === maybeIterable || "object" !== typeof maybeIterable)
+      if (null === maybeIterable || 'object' !== typeof maybeIterable)
         return null;
       maybeIterable =
         (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-        maybeIterable["@@iterator"];
-      return "function" === typeof maybeIterable ? maybeIterable : null;
+        maybeIterable['@@iterator'];
+      return 'function' === typeof maybeIterable ? maybeIterable : null;
     }
     function _defineProperty(obj, key, value) {
-      a: if ("object" == typeof key && key) {
+      a: if ('object' == typeof key && key) {
         var e = key[Symbol.toPrimitive];
         if (void 0 !== e) {
-          key = e.call(key, "string");
-          if ("object" != typeof key) break a;
-          throw new TypeError("@@toPrimitive must return a primitive value.");
+          key = e.call(key, 'string');
+          if ('object' != typeof key) break a;
+          throw new TypeError('@@toPrimitive must return a primitive value.');
         }
         key = String(key);
       }
-      key = "symbol" == typeof key ? key : key + "";
+      key = 'symbol' == typeof key ? key : key + '';
       key in obj
         ? Object.defineProperty(obj, key, {
             value: value,
             enumerable: !0,
             configurable: !0,
-            writable: !0
+            writable: !0,
           })
         : (obj[key] = value);
       return obj;
@@ -51,7 +51,7 @@
         if (2048 < chunk.byteLength)
           0 < writtenBytes &&
             (destination.enqueue(
-              new Uint8Array(currentView.buffer, 0, writtenBytes)
+              new Uint8Array(currentView.buffer, 0, writtenBytes),
             ),
             (currentView = new Uint8Array(2048)),
             (writtenBytes = 0)),
@@ -63,7 +63,7 @@
               ? destination.enqueue(currentView)
               : (currentView.set(
                   chunk.subarray(0, allowableBytes),
-                  writtenBytes
+                  writtenBytes,
                 ),
                 destination.enqueue(currentView),
                 (chunk = chunk.subarray(allowableBytes))),
@@ -78,7 +78,7 @@
       currentView &&
         0 < writtenBytes &&
         (destination.enqueue(
-          new Uint8Array(currentView.buffer, 0, writtenBytes)
+          new Uint8Array(currentView.buffer, 0, writtenBytes),
         ),
         (currentView = null),
         (writtenBytes = 0));
@@ -90,7 +90,7 @@
       return chunk.byteLength;
     }
     function closeWithError(destination, error) {
-      "function" === typeof destination.error
+      'function' === typeof destination.error
         ? destination.error(error)
         : destination.close();
     }
@@ -101,7 +101,7 @@
       return Object.defineProperties(proxyImplementation, {
         $$typeof: { value: CLIENT_REFERENCE_TAG$1 },
         $$id: { value: id },
-        $$async: { value: async }
+        $$async: { value: async },
       });
     }
     function bind() {
@@ -109,7 +109,7 @@
       if (this.$$typeof === SERVER_REFERENCE_TAG) {
         null != arguments[0] &&
           console.error(
-            'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().'
+            'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().',
           );
         var args = ArraySlice.call(arguments, 1),
           $$typeof = { value: SERVER_REFERENCE_TAG },
@@ -120,95 +120,95 @@
           $$id: $$id,
           $$bound: args,
           $$location: { value: this.$$location, configurable: !0 },
-          bind: { value: bind, configurable: !0 }
+          bind: { value: bind, configurable: !0 },
         });
       }
       return newFn;
     }
     function getReference(target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "$$id":
+        case '$$id':
           return target.$$id;
-        case "$$async":
+        case '$$async':
           return target.$$async;
-        case "name":
+        case 'name':
           return target.name;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "__esModule":
+        case '__esModule':
           var moduleId = target.$$id;
           target.default = registerClientReferenceImpl(
             function () {
               throw Error(
-                "Attempted to call the default export of " +
+                'Attempted to call the default export of ' +
                   moduleId +
-                  " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+                  " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
               );
             },
-            target.$$id + "#",
-            target.$$async
+            target.$$id + '#',
+            target.$$async,
           );
           return !0;
-        case "then":
+        case 'then':
           if (target.then) return target.then;
           if (target.$$async) return;
           var clientReference = registerClientReferenceImpl(
               {},
               target.$$id,
-              !0
+              !0,
             ),
             proxy = new Proxy(clientReference, proxyHandlers$1);
-          target.status = "fulfilled";
+          target.status = 'fulfilled';
           target.value = proxy;
           return (target.then = registerClientReferenceImpl(
             function (resolve) {
               return Promise.resolve(resolve(proxy));
             },
-            target.$$id + "#then",
-            !1
+            target.$$id + '#then',
+            !1,
           ));
       }
-      if ("symbol" === typeof name)
+      if ('symbol' === typeof name)
         throw Error(
-          "Cannot read Symbol exports. Only named exports are supported on a client module imported on the server."
+          'Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.',
         );
       clientReference = target[name];
       clientReference ||
         ((clientReference = registerClientReferenceImpl(
           function () {
             throw Error(
-              "Attempted to call " +
+              'Attempted to call ' +
                 String(name) +
-                "() from the server but " +
+                '() from the server but ' +
                 String(name) +
-                " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+                " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
             );
           },
-          target.$$id + "#" + name,
-          target.$$async
+          target.$$id + '#' + name,
+          target.$$async,
         )),
-        Object.defineProperty(clientReference, "name", { value: name }),
+        Object.defineProperty(clientReference, 'name', { value: name }),
         (clientReference = target[name] =
           new Proxy(clientReference, deepProxyHandlers)));
       return clientReference;
     }
     function resolveClientReferenceMetadata(config, clientReference) {
       var modulePath = clientReference.$$id,
-        name = "",
+        name = '',
         resolvedModuleData = config[modulePath];
       if (resolvedModuleData) name = resolvedModuleData.name;
       else {
-        var idx = modulePath.lastIndexOf("#");
+        var idx = modulePath.lastIndexOf('#');
         -1 !== idx &&
           ((name = modulePath.slice(idx + 1)),
           (resolvedModuleData = config[modulePath.slice(0, idx)]));
@@ -216,55 +216,55 @@
           throw Error(
             'Could not find the module "' +
               modulePath +
-              '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.'
+              '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.',
           );
       }
       if (!0 === resolvedModuleData.async && !0 === clientReference.$$async)
         throw Error(
           'The module "' +
             modulePath +
-            '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.'
+            '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.',
         );
       return !0 === resolvedModuleData.async || !0 === clientReference.$$async
         ? [resolvedModuleData.id, resolvedModuleData.chunks, name, 1]
         : [resolvedModuleData.id, resolvedModuleData.chunks, name];
     }
     function preload(href, as, options) {
-      if ("string" === typeof href) {
+      if ('string' === typeof href) {
         var request = resolveRequest();
         if (request) {
           var hints = request.hints,
-            key = "L";
-          if ("image" === as && options) {
+            key = 'L';
+          if ('image' === as && options) {
             var imageSrcSet = options.imageSrcSet,
               imageSizes = options.imageSizes,
-              uniquePart = "";
-            "string" === typeof imageSrcSet && "" !== imageSrcSet
-              ? ((uniquePart += "[" + imageSrcSet + "]"),
-                "string" === typeof imageSizes &&
-                  (uniquePart += "[" + imageSizes + "]"))
-              : (uniquePart += "[][]" + href);
-            key += "[image]" + uniquePart;
-          } else key += "[" + as + "]" + href;
+              uniquePart = '';
+            'string' === typeof imageSrcSet && '' !== imageSrcSet
+              ? ((uniquePart += '[' + imageSrcSet + ']'),
+                'string' === typeof imageSizes &&
+                  (uniquePart += '[' + imageSizes + ']'))
+              : (uniquePart += '[][]' + href);
+            key += '[image]' + uniquePart;
+          } else key += '[' + as + ']' + href;
           hints.has(key) ||
             (hints.add(key),
             (options = trimOptions(options))
-              ? emitHint(request, "L", [href, as, options])
-              : emitHint(request, "L", [href, as]));
+              ? emitHint(request, 'L', [href, as, options])
+              : emitHint(request, 'L', [href, as]));
         } else previousDispatcher.L(href, as, options);
       }
     }
     function preloadModule$1(href, options) {
-      if ("string" === typeof href) {
+      if ('string' === typeof href) {
         var request = resolveRequest();
         if (request) {
           var hints = request.hints,
-            key = "m|" + href;
+            key = 'm|' + href;
           if (hints.has(key)) return;
           hints.add(key);
           return (options = trimOptions(options))
-            ? emitHint(request, "m", [href, options])
-            : emitHint(request, "m", href);
+            ? emitHint(request, 'm', [href, options])
+            : emitHint(request, 'm', href);
         }
         previousDispatcher.m(href, options);
       }
@@ -281,63 +281,63 @@
     }
     function getChildFormatContext(parentContext, type, props) {
       switch (type) {
-        case "img":
+        case 'img':
           type = props.src;
           var srcSet = props.srcSet;
           if (
             !(
-              "lazy" === props.loading ||
+              'lazy' === props.loading ||
               (!type && !srcSet) ||
-              ("string" !== typeof type && null != type) ||
-              ("string" !== typeof srcSet && null != srcSet) ||
-              "low" === props.fetchPriority ||
+              ('string' !== typeof type && null != type) ||
+              ('string' !== typeof srcSet && null != srcSet) ||
+              'low' === props.fetchPriority ||
               parentContext & 3
             ) &&
-            ("string" !== typeof type ||
-              ":" !== type[4] ||
-              ("d" !== type[0] && "D" !== type[0]) ||
-              ("a" !== type[1] && "A" !== type[1]) ||
-              ("t" !== type[2] && "T" !== type[2]) ||
-              ("a" !== type[3] && "A" !== type[3])) &&
-            ("string" !== typeof srcSet ||
-              ":" !== srcSet[4] ||
-              ("d" !== srcSet[0] && "D" !== srcSet[0]) ||
-              ("a" !== srcSet[1] && "A" !== srcSet[1]) ||
-              ("t" !== srcSet[2] && "T" !== srcSet[2]) ||
-              ("a" !== srcSet[3] && "A" !== srcSet[3]))
+            ('string' !== typeof type ||
+              ':' !== type[4] ||
+              ('d' !== type[0] && 'D' !== type[0]) ||
+              ('a' !== type[1] && 'A' !== type[1]) ||
+              ('t' !== type[2] && 'T' !== type[2]) ||
+              ('a' !== type[3] && 'A' !== type[3])) &&
+            ('string' !== typeof srcSet ||
+              ':' !== srcSet[4] ||
+              ('d' !== srcSet[0] && 'D' !== srcSet[0]) ||
+              ('a' !== srcSet[1] && 'A' !== srcSet[1]) ||
+              ('t' !== srcSet[2] && 'T' !== srcSet[2]) ||
+              ('a' !== srcSet[3] && 'A' !== srcSet[3]))
           ) {
-            var sizes = "string" === typeof props.sizes ? props.sizes : void 0;
+            var sizes = 'string' === typeof props.sizes ? props.sizes : void 0;
             var input = props.crossOrigin;
-            preload(type || "", "image", {
+            preload(type || '', 'image', {
               imageSrcSet: srcSet,
               imageSizes: sizes,
               crossOrigin:
-                "string" === typeof input
-                  ? "use-credentials" === input
+                'string' === typeof input
+                  ? 'use-credentials' === input
                     ? input
-                    : ""
+                    : ''
                   : void 0,
               integrity: props.integrity,
               type: props.type,
               fetchPriority: props.fetchPriority,
-              referrerPolicy: props.referrerPolicy
+              referrerPolicy: props.referrerPolicy,
             });
           }
           return parentContext;
-        case "link":
+        case 'link':
           type = props.rel;
           srcSet = props.href;
           if (
             !(
               parentContext & 1 ||
               null != props.itemProp ||
-              "string" !== typeof type ||
-              "string" !== typeof srcSet ||
-              "" === srcSet
+              'string' !== typeof type ||
+              'string' !== typeof srcSet ||
+              '' === srcSet
             )
           )
             switch (type) {
-              case "preload":
+              case 'preload':
                 preload(srcSet, props.as, {
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
@@ -347,32 +347,32 @@
                   referrerPolicy: props.referrerPolicy,
                   imageSrcSet: props.imageSrcSet,
                   imageSizes: props.imageSizes,
-                  media: props.media
+                  media: props.media,
                 });
                 break;
-              case "modulepreload":
+              case 'modulepreload':
                 preloadModule$1(srcSet, {
                   as: props.as,
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
-                  nonce: props.nonce
+                  nonce: props.nonce,
                 });
                 break;
-              case "stylesheet":
-                preload(srcSet, "stylesheet", {
+              case 'stylesheet':
+                preload(srcSet, 'stylesheet', {
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
                   nonce: props.nonce,
                   type: props.type,
                   fetchPriority: props.fetchPriority,
                   referrerPolicy: props.referrerPolicy,
-                  media: props.media
+                  media: props.media,
                 });
             }
           return parentContext;
-        case "picture":
+        case 'picture':
           return parentContext | 2;
-        case "noscript":
+        case 'noscript':
           return parentContext | 1;
         default:
           return parentContext;
@@ -382,51 +382,51 @@
       error = [];
       for (var i = framesToSkip; i < structuredStackTrace.length; i++) {
         var callSite = structuredStackTrace[i],
-          name = callSite.getFunctionName() || "<anonymous>";
-        if (name.includes("react_stack_bottom_frame")) break;
+          name = callSite.getFunctionName() || '<anonymous>';
+        if (name.includes('react_stack_bottom_frame')) break;
         else if (callSite.isNative())
           (callSite = callSite.isAsync()),
-            error.push([name, "", 0, 0, 0, 0, callSite]);
+            error.push([name, '', 0, 0, 0, 0, callSite]);
         else {
-          if (callSite.isConstructor()) name = "new " + name;
+          if (callSite.isConstructor()) name = 'new ' + name;
           else if (!callSite.isToplevel()) {
             var callSite$jscomp$0 = callSite;
             name = callSite$jscomp$0.getTypeName();
             var methodName = callSite$jscomp$0.getMethodName();
             callSite$jscomp$0 = callSite$jscomp$0.getFunctionName();
-            var result = "";
+            var result = '';
             callSite$jscomp$0
               ? (name &&
                   identifierRegExp.test(callSite$jscomp$0) &&
                   callSite$jscomp$0 !== name &&
-                  (result += name + "."),
+                  (result += name + '.'),
                 (result += callSite$jscomp$0),
                 !methodName ||
                   callSite$jscomp$0 === methodName ||
-                  callSite$jscomp$0.endsWith("." + methodName) ||
-                  callSite$jscomp$0.endsWith(" " + methodName) ||
-                  (result += " [as " + methodName + "]"))
-              : (name && (result += name + "."),
+                  callSite$jscomp$0.endsWith('.' + methodName) ||
+                  callSite$jscomp$0.endsWith(' ' + methodName) ||
+                  (result += ' [as ' + methodName + ']'))
+              : (name && (result += name + '.'),
                 (result = methodName
                   ? result + methodName
-                  : result + "<anonymous>"));
+                  : result + '<anonymous>'));
             name = result;
           }
-          "<anonymous>" === name && (name = "");
-          methodName = callSite.getScriptNameOrSourceURL() || "<anonymous>";
-          "<anonymous>" === methodName &&
-            ((methodName = ""),
+          '<anonymous>' === name && (name = '');
+          methodName = callSite.getScriptNameOrSourceURL() || '<anonymous>';
+          '<anonymous>' === methodName &&
+            ((methodName = ''),
             callSite.isEval() &&
               (callSite$jscomp$0 = callSite.getEvalOrigin()) &&
-              (methodName = callSite$jscomp$0.toString() + ", <anonymous>"));
+              (methodName = callSite$jscomp$0.toString() + ', <anonymous>'));
           callSite$jscomp$0 = callSite.getLineNumber() || 0;
           result = callSite.getColumnNumber() || 0;
           var enclosingLine =
-              "function" === typeof callSite.getEnclosingLineNumber
+              'function' === typeof callSite.getEnclosingLineNumber
                 ? callSite.getEnclosingLineNumber() || 0
                 : 0,
             enclosingCol =
-              "function" === typeof callSite.getEnclosingColumnNumber
+              'function' === typeof callSite.getEnclosingColumnNumber
                 ? callSite.getEnclosingColumnNumber() || 0
                 : 0;
           callSite = callSite.isAsync();
@@ -437,18 +437,18 @@
             result,
             enclosingLine,
             enclosingCol,
-            callSite
+            callSite,
           ]);
         }
       }
       collectedStackTrace = error;
-      return "";
+      return '';
     }
     function collectStackTrace(error, structuredStackTrace) {
       collectStackTracePrivate(error, structuredStackTrace);
-      error = (error.name || "Error") + ": " + (error.message || "");
+      error = (error.name || 'Error') + ': ' + (error.message || '');
       for (var i = 0; i < structuredStackTrace.length; i++)
-        error += "\n    at " + structuredStackTrace[i].toString();
+        error += '\n    at ' + structuredStackTrace[i].toString();
       return error;
     }
     function parseStackTrace(error, skipFrames) {
@@ -470,23 +470,23 @@
           stackTraceCache.set(error, stack),
           stack
         );
-      stack.startsWith("Error: react-stack-top-frame\n") &&
+      stack.startsWith('Error: react-stack-top-frame\n') &&
         (stack = stack.slice(29));
-      existing = stack.indexOf("react_stack_bottom_frame");
-      -1 !== existing && (existing = stack.lastIndexOf("\n", existing));
+      existing = stack.indexOf('react_stack_bottom_frame');
+      -1 !== existing && (existing = stack.lastIndexOf('\n', existing));
       -1 !== existing && (stack = stack.slice(0, existing));
-      stack = stack.split("\n");
+      stack = stack.split('\n');
       for (existing = []; skipFrames < stack.length; skipFrames++) {
         var parsed = frameRegExp.exec(stack[skipFrames]);
         if (parsed) {
-          var name = parsed[1] || "",
-            isAsync = "async " === parsed[8];
-          "<anonymous>" === name
-            ? (name = "")
-            : name.startsWith("async ") &&
+          var name = parsed[1] || '',
+            isAsync = 'async ' === parsed[8];
+          '<anonymous>' === name
+            ? (name = '')
+            : name.startsWith('async ') &&
               ((name = name.slice(5)), (isAsync = !0));
-          var filename = parsed[2] || parsed[5] || "";
-          "<anonymous>" === filename && (filename = "");
+          var filename = parsed[2] || parsed[5] || '';
+          '<anonymous>' === filename && (filename = '');
           existing.push([
             name,
             filename,
@@ -494,7 +494,7 @@
             +(parsed[4] || parsed[7]),
             0,
             0,
-            isAsync
+            isAsync,
           ]);
         }
       }
@@ -505,10 +505,10 @@
       var reference = Object.defineProperties(
         function () {
           throw Error(
-            "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+            "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
           );
         },
-        { $$typeof: { value: TEMPORARY_REFERENCE_TAG } }
+        { $$typeof: { value: TEMPORARY_REFERENCE_TAG } },
       );
       reference = new Proxy(reference, proxyHandlers);
       temporaryReferences.set(reference, id);
@@ -522,35 +522,35 @@
           (thenableState._stacks || (thenableState._stacks = [])).push(Error()))
         : index !== thenable && (thenable.then(noop, noop), (thenable = index));
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return thenable.value;
-        case "rejected":
+        case 'rejected':
           throw thenable.reason;
         default:
-          "string" === typeof thenable.status
+          'string' === typeof thenable.status
             ? thenable.then(noop, noop)
             : ((thenableState = thenable),
-              (thenableState.status = "pending"),
+              (thenableState.status = 'pending'),
               thenableState.then(
                 function (fulfilledValue) {
-                  if ("pending" === thenable.status) {
+                  if ('pending' === thenable.status) {
                     var fulfilledThenable = thenable;
-                    fulfilledThenable.status = "fulfilled";
+                    fulfilledThenable.status = 'fulfilled';
                     fulfilledThenable.value = fulfilledValue;
                   }
                 },
                 function (error) {
-                  if ("pending" === thenable.status) {
+                  if ('pending' === thenable.status) {
                     var rejectedThenable = thenable;
-                    rejectedThenable.status = "rejected";
+                    rejectedThenable.status = 'rejected';
                     rejectedThenable.reason = error;
                   }
-                }
+                },
               ));
           switch (thenable.status) {
-            case "fulfilled":
+            case 'fulfilled':
               return thenable.value;
-            case "rejected":
+            case 'rejected':
               throw thenable.reason;
           }
           suspendedThenable = thenable;
@@ -560,7 +560,7 @@
     function getSuspendedThenable() {
       if (null === suspendedThenable)
         throw Error(
-          "Expected a suspended thenable. This is a bug in React. Please file an issue."
+          'Expected a suspended thenable. This is a bug in React. Please file an issue.',
         );
       var thenable = suspendedThenable;
       suspendedThenable = null;
@@ -573,15 +573,15 @@
       return state;
     }
     function unsupportedHook() {
-      throw Error("This Hook is not supported in Server Components.");
+      throw Error('This Hook is not supported in Server Components.');
     }
     function unsupportedRefresh() {
       throw Error(
-        "Refreshing the cache is not supported in Server Components."
+        'Refreshing the cache is not supported in Server Components.',
       );
     }
     function unsupportedContext() {
-      throw Error("Cannot read a Client Context from a Server Component.");
+      throw Error('Cannot read a Client Context from a Server Component.');
     }
     function resolveOwner() {
       if (currentOwner) return currentOwner;
@@ -592,9 +592,9 @@
       return null;
     }
     function prepareStackTrace(error, structuredStackTrace) {
-      error = (error.name || "Error") + ": " + (error.message || "");
+      error = (error.name || 'Error') + ': ' + (error.message || '');
       for (var i = 0; i < structuredStackTrace.length; i++)
-        error += "\n    at " + structuredStackTrace[i].toString();
+        error += '\n    at ' + structuredStackTrace[i].toString();
       return error;
     }
     function resetOwnerStackLimit() {
@@ -618,7 +618,7 @@
       var descriptor = Object.getOwnPropertyDescriptor(object, name);
       return void 0 === descriptor
         ? isGetter(getPrototypeOf(object), name)
-        : "function" === typeof descriptor.get;
+        : 'function' === typeof descriptor.get;
     }
     function isSimpleObject(object) {
       if (!isObjectPrototype(getPrototypeOf(object))) return !1;
@@ -631,8 +631,8 @@
         if (
           !descriptor ||
           (!descriptor.enumerable &&
-            (("key" !== names[i] && "ref" !== names[i]) ||
-              "function" !== typeof descriptor.get))
+            (('key' !== names[i] && 'ref' !== names[i]) ||
+              'function' !== typeof descriptor.get))
         )
           return !1;
       }
@@ -648,35 +648,35 @@
     }
     function describeValueForErrorMessage(value) {
       switch (typeof value) {
-        case "string":
+        case 'string':
           return JSON.stringify(
-            10 >= value.length ? value : value.slice(0, 10) + "..."
+            10 >= value.length ? value : value.slice(0, 10) + '...',
           );
-        case "object":
-          if (isArrayImpl(value)) return "[...]";
+        case 'object':
+          if (isArrayImpl(value)) return '[...]';
           if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-            return "client";
+            return 'client';
           value = objectName(value);
-          return "Object" === value ? "{...}" : value;
-        case "function":
+          return 'Object' === value ? '{...}' : value;
+        case 'function':
           return value.$$typeof === CLIENT_REFERENCE_TAG
-            ? "client"
+            ? 'client'
             : (value = value.displayName || value.name)
-              ? "function " + value
-              : "function";
+              ? 'function ' + value
+              : 'function';
         default:
           return String(value);
       }
     }
     function describeElementType(type) {
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (type.$$typeof) {
           case REACT_FORWARD_REF_TYPE:
             return describeElementType(type.render);
@@ -689,74 +689,74 @@
               return describeElementType(type(payload));
             } catch (x) {}
         }
-      return "";
+      return '';
     }
     function describeObjectForErrorMessage(objectOrArray, expandedName) {
       var objKind = objectName(objectOrArray);
-      if ("Object" !== objKind && "Array" !== objKind) return objKind;
+      if ('Object' !== objKind && 'Array' !== objKind) return objKind;
       var start = -1,
         length = 0;
       if (isArrayImpl(objectOrArray))
         if (jsxChildrenParents.has(objectOrArray)) {
           var type = jsxChildrenParents.get(objectOrArray);
-          objKind = "<" + describeElementType(type) + ">";
+          objKind = '<' + describeElementType(type) + '>';
           for (var i = 0; i < objectOrArray.length; i++) {
             var value = objectOrArray[i];
             value =
-              "string" === typeof value
+              'string' === typeof value
                 ? value
-                : "object" === typeof value && null !== value
-                  ? "{" + describeObjectForErrorMessage(value) + "}"
-                  : "{" + describeValueForErrorMessage(value) + "}";
-            "" + i === expandedName
+                : 'object' === typeof value && null !== value
+                  ? '{' + describeObjectForErrorMessage(value) + '}'
+                  : '{' + describeValueForErrorMessage(value) + '}';
+            '' + i === expandedName
               ? ((start = objKind.length),
                 (length = value.length),
                 (objKind += value))
               : (objKind =
                   15 > value.length && 40 > objKind.length + value.length
                     ? objKind + value
-                    : objKind + "{...}");
+                    : objKind + '{...}');
           }
-          objKind += "</" + describeElementType(type) + ">";
+          objKind += '</' + describeElementType(type) + '>';
         } else {
-          objKind = "[";
+          objKind = '[';
           for (type = 0; type < objectOrArray.length; type++)
-            0 < type && (objKind += ", "),
+            0 < type && (objKind += ', '),
               (i = objectOrArray[type]),
               (i =
-                "object" === typeof i && null !== i
+                'object' === typeof i && null !== i
                   ? describeObjectForErrorMessage(i)
                   : describeValueForErrorMessage(i)),
-              "" + type === expandedName
+              '' + type === expandedName
                 ? ((start = objKind.length),
                   (length = i.length),
                   (objKind += i))
                 : (objKind =
                     10 > i.length && 40 > objKind.length + i.length
                       ? objKind + i
-                      : objKind + "...");
-          objKind += "]";
+                      : objKind + '...');
+          objKind += ']';
         }
       else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-        objKind = "<" + describeElementType(objectOrArray.type) + "/>";
+        objKind = '<' + describeElementType(objectOrArray.type) + '/>';
       else {
-        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
         if (jsxPropsParents.has(objectOrArray)) {
           objKind = jsxPropsParents.get(objectOrArray);
-          objKind = "<" + (describeElementType(objKind) || "...");
+          objKind = '<' + (describeElementType(objKind) || '...');
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++) {
-            objKind += " ";
+            objKind += ' ';
             value = type[i];
-            objKind += describeKeyForErrorMessage(value) + "=";
+            objKind += describeKeyForErrorMessage(value) + '=';
             var _value2 = objectOrArray[value];
             var _substr2 =
               value === expandedName &&
-              "object" === typeof _value2 &&
+              'object' === typeof _value2 &&
               null !== _value2
                 ? describeObjectForErrorMessage(_value2)
                 : describeValueForErrorMessage(_value2);
-            "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
+            'string' !== typeof _value2 && (_substr2 = '{' + _substr2 + '}');
             value === expandedName
               ? ((start = objKind.length),
                 (length = _substr2.length),
@@ -764,19 +764,19 @@
               : (objKind =
                   10 > _substr2.length && 40 > objKind.length + _substr2.length
                     ? objKind + _substr2
-                    : objKind + "...");
+                    : objKind + '...');
           }
-          objKind += ">";
+          objKind += '>';
         } else {
-          objKind = "{";
+          objKind = '{';
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++)
-            0 < i && (objKind += ", "),
+            0 < i && (objKind += ', '),
               (value = type[i]),
-              (objKind += describeKeyForErrorMessage(value) + ": "),
+              (objKind += describeKeyForErrorMessage(value) + ': '),
               (_value2 = objectOrArray[value]),
               (_value2 =
-                "object" === typeof _value2 && null !== _value2
+                'object' === typeof _value2 && null !== _value2
                   ? describeObjectForErrorMessage(_value2)
                   : describeValueForErrorMessage(_value2)),
               value === expandedName
@@ -786,22 +786,22 @@
                 : (objKind =
                     10 > _value2.length && 40 > objKind.length + _value2.length
                       ? objKind + _value2
-                      : objKind + "...");
-          objKind += "}";
+                      : objKind + '...');
+          objKind += '}';
         }
       }
       return void 0 === expandedName
         ? objKind
         : -1 < start && 0 < length
-          ? ((objectOrArray = " ".repeat(start) + "^".repeat(length)),
-            "\n  " + objKind + "\n  " + objectOrArray)
-          : "\n  " + objKind;
+          ? ((objectOrArray = ' '.repeat(start) + '^'.repeat(length)),
+            '\n  ' + objKind + '\n  ' + objectOrArray)
+          : '\n  ' + objKind;
     }
     function defaultFilterStackFrame(filename) {
       return (
-        "" !== filename &&
-        !filename.startsWith("node:") &&
-        !filename.includes("node_modules")
+        '' !== filename &&
+        !filename.startsWith('node:') &&
+        !filename.includes('node_modules')
       );
     }
     function filterStackTrace(request, stack) {
@@ -810,9 +810,9 @@
         var callsite = stack[i],
           functionName = callsite[0];
         var url = callsite[1];
-        if (url.startsWith("about://React/")) {
-          var envIdx = url.indexOf("/", 14),
-            suffixIdx = url.lastIndexOf("?");
+        if (url.startsWith('about://React/')) {
+          var envIdx = url.indexOf('/', 14),
+            suffixIdx = url.lastIndexOf('?');
           -1 < envIdx &&
             -1 < suffixIdx &&
             (url = decodeURI(url.slice(envIdx + 1, suffixIdx)));
@@ -829,21 +829,21 @@
       if (
         descriptor &&
         (descriptor.configurable || descriptor.writable) &&
-        "function" === typeof descriptor.value
+        'function' === typeof descriptor.value
       ) {
         var originalMethod = descriptor.value;
-        descriptor = Object.getOwnPropertyDescriptor(originalMethod, "name");
+        descriptor = Object.getOwnPropertyDescriptor(originalMethod, 'name');
         var wrapperMethod = function () {
           var request = resolveRequest();
-          if (("assert" !== methodName || !arguments[0]) && null !== request) {
+          if (('assert' !== methodName || !arguments[0]) && null !== request) {
             a: {
-              var error = Error("react-stack-top-frame");
+              var error = Error('react-stack-top-frame');
               collectedStackTrace = null;
               framesToSkip = 1;
               var previousPrepare = Error.prepareStackTrace;
               Error.prepareStackTrace = collectStackTracePrivate;
               try {
-                if ("" !== error.stack) {
+                if ('' !== error.stack) {
                   var JSCompiler_inline_result = null;
                   break a;
                 }
@@ -854,7 +854,7 @@
             }
             JSCompiler_inline_result = filterStackTrace(
               request,
-              JSCompiler_inline_result || []
+              JSCompiler_inline_result || [],
             );
             request.pendingDebugChunks++;
             error = resolveOwner();
@@ -862,25 +862,25 @@
             a: {
               var env = 0;
               switch (methodName) {
-                case "dir":
-                case "dirxml":
-                case "groupEnd":
-                case "table":
+                case 'dir':
+                case 'dirxml':
+                case 'groupEnd':
+                case 'table':
                   env = null;
                   break a;
-                case "assert":
+                case 'assert':
                   env = 1;
               }
               var format = previousPrepare[env],
                 style = previousPrepare[env + 1],
                 badge = previousPrepare[env + 2];
-              "string" === typeof format &&
-              format.startsWith("\u001b[0m\u001b[7m%c%s\u001b[0m%c") &&
-              "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px" ===
+              'string' === typeof format &&
+              format.startsWith('\u001b[0m\u001b[7m%c%s\u001b[0m%c') &&
+              'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px' ===
                 style &&
-              "string" === typeof badge
+              'string' === typeof badge
                 ? ((format = format.slice(18)),
-                  " " === format[0] && (format = format.slice(1)),
+                  ' ' === format[0] && (format = format.slice(1)),
                   previousPrepare.splice(env, 4, format),
                   (env = badge.slice(1, badge.length - 1)))
                 : (env = null);
@@ -893,9 +893,9 @@
               request,
               (null === request.deferredDebugObjects ? 500 : 10) +
                 JSCompiler_inline_result.length,
-              badge
+              badge,
             );
-            "[" !== previousPrepare[0] &&
+            '[' !== previousPrepare[0] &&
               (previousPrepare = serializeDebugModel(
                 request,
                 10 + JSCompiler_inline_result.length,
@@ -904,28 +904,28 @@
                   JSCompiler_inline_result,
                   error,
                   env,
-                  "Unknown Value: React could not send it from the server."
-                ]
+                  'Unknown Value: React could not send it from the server.',
+                ],
               ));
             JSCompiler_inline_result = stringToChunk(
-              ":W" + previousPrepare + "\n"
+              ':W' + previousPrepare + '\n',
             );
             request.completedDebugChunks.push(JSCompiler_inline_result);
           }
           return originalMethod.apply(this, arguments);
         };
-        descriptor && Object.defineProperty(wrapperMethod, "name", descriptor);
+        descriptor && Object.defineProperty(wrapperMethod, 'name', descriptor);
         Object.defineProperty(consoleInst, methodName, {
-          value: wrapperMethod
+          value: wrapperMethod,
         });
       }
     }
     function getCurrentStackInDEV() {
       var owner = resolveOwner();
-      if (null === owner) return "";
+      if (null === owner) return '';
       try {
-        var info = "";
-        if (owner.owner || "string" !== typeof owner.name) {
+        var info = '';
+        if (owner.owner || 'string' !== typeof owner.name) {
           for (; owner; ) {
             var ownerStack = owner.debugStack;
             if (null != ownerStack) {
@@ -936,16 +936,16 @@
                 Error.prepareStackTrace = prepareStackTrace;
                 var stack = error.stack;
                 Error.prepareStackTrace = prevPrepareStackTrace;
-                stack.startsWith("Error: react-stack-top-frame\n") &&
+                stack.startsWith('Error: react-stack-top-frame\n') &&
                   (stack = stack.slice(29));
-                var idx = stack.indexOf("\n");
+                var idx = stack.indexOf('\n');
                 -1 !== idx && (stack = stack.slice(idx + 1));
-                idx = stack.indexOf("react_stack_bottom_frame");
-                -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
+                idx = stack.indexOf('react_stack_bottom_frame');
+                -1 !== idx && (idx = stack.lastIndexOf('\n', idx));
                 var JSCompiler_inline_result =
-                  -1 !== idx ? (stack = stack.slice(0, idx)) : "";
+                  -1 !== idx ? (stack = stack.slice(0, idx)) : '';
                 info =
-                  JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
+                  JSCompiler_temp_const + ('\n' + JSCompiler_inline_result);
               }
             } else break;
           }
@@ -958,20 +958,20 @@
             } catch (x) {
               (prefix =
                 ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) ||
-                ""),
+                ''),
                 (suffix =
-                  -1 < x.stack.indexOf("\n    at")
-                    ? " (<anonymous>)"
-                    : -1 < x.stack.indexOf("@")
-                      ? "@unknown:0:0"
-                      : "");
+                  -1 < x.stack.indexOf('\n    at')
+                    ? ' (<anonymous>)'
+                    : -1 < x.stack.indexOf('@')
+                      ? '@unknown:0:0'
+                      : '');
             }
           JSCompiler_inline_result$jscomp$0 =
-            "\n" + prefix + JSCompiler_temp_const + suffix;
+            '\n' + prefix + JSCompiler_temp_const + suffix;
         }
       } catch (x) {
         JSCompiler_inline_result$jscomp$0 =
-          "\nError generating stack: " + x.message + "\n" + x.stack;
+          '\nError generating stack: ' + x.message + '\n' + x.stack;
       }
       return JSCompiler_inline_result$jscomp$0;
     }
@@ -990,14 +990,14 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       if (
         null !== ReactSharedInternalsServer.A &&
         ReactSharedInternalsServer.A !== DefaultAsyncDispatcher
       )
         throw Error(
-          "Currently React only supports one RSC renderer at a time."
+          'Currently React only supports one RSC renderer at a time.',
         );
       ReactSharedInternalsServer.A = DefaultAsyncDispatcher;
       ReactSharedInternalsServer.getCurrentStack = getCurrentStackInDEV;
@@ -1024,7 +1024,7 @@
       this.writtenServerReferences = new Map();
       this.writtenObjects = new WeakMap();
       this.temporaryReferences = temporaryReferences;
-      this.identifierPrefix = identifierPrefix || "";
+      this.identifierPrefix = identifierPrefix || '';
       this.identifierCount = 1;
       this.taintCleanupQueue = [];
       this.onError = void 0 === onError ? defaultErrorHandler : onError;
@@ -1038,9 +1038,9 @@
       this.environmentName =
         void 0 === environmentName
           ? function () {
-              return "Server";
+              return 'Server';
             }
-          : "function" !== typeof environmentName
+          : 'function' !== typeof environmentName
             ? function () {
                 return environmentName;
               }
@@ -1067,7 +1067,7 @@
         type,
         null,
         null,
-        null
+        null,
       );
       pingedTasks.push(model);
     }
@@ -1080,7 +1080,7 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       resetOwnerStackLimit();
       return new RequestInstance(
@@ -1095,7 +1095,7 @@
         temporaryReferences,
         environmentName,
         filterStackFrame,
-        keepDebugAlive
+        keepDebugAlive,
       );
     }
     function createPrerenderRequest(
@@ -1109,7 +1109,7 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       resetOwnerStackLimit();
       return new RequestInstance(
@@ -1124,7 +1124,7 @@
         temporaryReferences,
         environmentName,
         filterStackFrame,
-        keepDebugAlive
+        keepDebugAlive,
       );
     }
     function resolveRequest() {
@@ -1138,17 +1138,17 @@
     function serializeDebugThenable(request, counter, thenable) {
       request.pendingDebugChunks++;
       var id = request.nextChunkId++,
-        ref = "$@" + id.toString(16);
+        ref = '$@' + id.toString(16);
       request.writtenDebugObjects.set(thenable, ref);
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             emitOutlinedDebugModelChunk(request, id, counter, thenable.value),
             ref
           );
-        case "rejected":
+        case 'rejected':
           return (
-            emitErrorChunk(request, id, "", thenable.reason, !0, null), ref
+            emitErrorChunk(request, id, '', thenable.reason, !0, null), ref
           );
       }
       if (request.status === ABORTING)
@@ -1157,7 +1157,7 @@
       if (null !== deferredDebugObjects)
         return (
           deferredDebugObjects.retained.set(id, thenable),
-          (ref = "$Y@" + id.toString(16)),
+          (ref = '$Y@' + id.toString(16)),
           request.writtenDebugObjects.set(thenable, ref),
           ref
         );
@@ -1176,9 +1176,9 @@
             ((cancelled = !0),
             request.status === ABORTING
               ? emitDebugHaltChunk(request, id)
-              : emitErrorChunk(request, id, "", reason, !0, null),
+              : emitErrorChunk(request, id, '', reason, !0, null),
             enqueueFlush(request));
-        }
+        },
       );
       Promise.resolve().then(function () {
         cancelled ||
@@ -1200,9 +1200,9 @@
         function (reason) {
           request.status === ABORTING
             ? emitDebugHaltChunk(request, id)
-            : emitErrorChunk(request, id, "", reason, !0, null);
+            : emitErrorChunk(request, id, '', reason, !0, null);
           enqueueFlush(request);
-        }
+        },
       );
     }
     function serializeThenable(request, task, thenable) {
@@ -1216,30 +1216,30 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             forwardDebugInfoFromThenable(
               request,
               newTask,
               thenable,
               null,
-              null
+              null,
             ),
             (newTask.model = thenable.value),
             pingTask(request, newTask),
             newTask.id
           );
-        case "rejected":
+        case 'rejected':
           return (
             forwardDebugInfoFromThenable(
               request,
               newTask,
               thenable,
               null,
-              null
+              null,
             ),
             erroredTask(request, newTask, thenable.reason),
             newTask.id
@@ -1255,18 +1255,18 @@
                   finishAbortedTask(newTask, request, task)),
               newTask.id
             );
-          "string" !== typeof thenable.status &&
-            ((thenable.status = "pending"),
+          'string' !== typeof thenable.status &&
+            ((thenable.status = 'pending'),
             thenable.then(
               function (fulfilledValue) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "fulfilled"),
+                'pending' === thenable.status &&
+                  ((thenable.status = 'fulfilled'),
                   (thenable.value = fulfilledValue));
               },
               function (error) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "rejected"), (thenable.reason = error));
-              }
+                'pending' === thenable.status &&
+                  ((thenable.status = 'rejected'), (thenable.reason = error));
+              },
             ));
       }
       thenable.then(
@@ -1280,7 +1280,7 @@
             ((newTask.timed = !0),
             erroredTask(request, newTask, reason),
             enqueueFlush(request));
-        }
+        },
       );
       return newTask.id;
     }
@@ -1289,12 +1289,12 @@
         if (0 === streamTask.status)
           if (entry.done)
             (streamTask.status = 1),
-              (entry = streamTask.id.toString(16) + ":C\n"),
+              (entry = streamTask.id.toString(16) + ':C\n'),
               request.completedRegularChunks.push(stringToChunk(entry)),
               request.abortableTasks.delete(streamTask),
               request.cacheController.signal.removeEventListener(
-                "abort",
-                abortStream
+                'abort',
+                abortStream,
               ),
               enqueueFlush(request),
               callOnAllReadyIfReady(request);
@@ -1312,8 +1312,8 @@
       function error(reason) {
         0 === streamTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortStream
+            'abort',
+            abortStream,
           ),
           erroredTask(request, streamTask, reason),
           enqueueFlush(request),
@@ -1322,7 +1322,7 @@
       function abortStream() {
         if (0 === streamTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortStream);
+          signal.removeEventListener('abort', abortStream);
           signal = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(streamTask),
@@ -1335,7 +1335,7 @@
       var supportsBYOB = stream.supportsBYOB;
       if (void 0 === supportsBYOB)
         try {
-          stream.getReader({ mode: "byob" }).releaseLock(), (supportsBYOB = !0);
+          stream.getReader({ mode: 'byob' }).releaseLock(), (supportsBYOB = !0);
         } catch (x) {
           supportsBYOB = !1;
         }
@@ -1350,13 +1350,13 @@
           task.time,
           task.debugOwner,
           task.debugStack,
-          task.debugTask
+          task.debugTask,
         );
       request.pendingChunks++;
       task =
-        streamTask.id.toString(16) + ":" + (supportsBYOB ? "r" : "R") + "\n";
+        streamTask.id.toString(16) + ':' + (supportsBYOB ? 'r' : 'R') + '\n';
       request.completedRegularChunks.push(stringToChunk(task));
-      request.cacheController.signal.addEventListener("abort", abortStream);
+      request.cacheController.signal.addEventListener('abort', abortStream);
       reader.read().then(progress, error);
       return serializeByValueID(streamTask.id);
     }
@@ -1366,15 +1366,15 @@
           if (entry.done) {
             streamTask.status = 1;
             if (void 0 === entry.value)
-              var endStreamRow = streamTask.id.toString(16) + ":C\n";
+              var endStreamRow = streamTask.id.toString(16) + ':C\n';
             else
               try {
                 var chunkId = outlineModel(request, entry.value);
                 endStreamRow =
                   streamTask.id.toString(16) +
-                  ":C" +
+                  ':C' +
                   stringify(serializeByValueID(chunkId)) +
-                  "\n";
+                  '\n';
               } catch (x) {
                 error(x);
                 return;
@@ -1382,8 +1382,8 @@
             request.completedRegularChunks.push(stringToChunk(endStreamRow));
             request.abortableTasks.delete(streamTask);
             request.cacheController.signal.removeEventListener(
-              "abort",
-              abortIterable
+              'abort',
+              abortIterable,
             );
             enqueueFlush(request);
             callOnAllReadyIfReady(request);
@@ -1401,18 +1401,18 @@
       function error(reason) {
         0 === streamTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortIterable
+            'abort',
+            abortIterable,
           ),
           erroredTask(request, streamTask, reason),
           enqueueFlush(request),
-          "function" === typeof iterator.throw &&
+          'function' === typeof iterator.throw &&
             iterator.throw(reason).then(error, error));
       }
       function abortIterable() {
         if (0 === streamTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortIterable);
+          signal.removeEventListener('abort', abortIterable);
           var reason = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(streamTask),
@@ -1420,7 +1420,7 @@
               finishHaltedTask(streamTask, request))
             : (erroredTask(request, streamTask, signal.reason),
               enqueueFlush(request));
-          "function" === typeof iterator.throw &&
+          'function' === typeof iterator.throw &&
             iterator.throw(reason).then(error, error);
         }
       }
@@ -1435,68 +1435,68 @@
           task.time,
           task.debugOwner,
           task.debugStack,
-          task.debugTask
+          task.debugTask,
         );
       (task = iterable._debugInfo) &&
         forwardDebugInfo(request, streamTask, task);
       request.pendingChunks++;
       isIterator =
-        streamTask.id.toString(16) + ":" + (isIterator ? "x" : "X") + "\n";
+        streamTask.id.toString(16) + ':' + (isIterator ? 'x' : 'X') + '\n';
       request.completedRegularChunks.push(stringToChunk(isIterator));
-      request.cacheController.signal.addEventListener("abort", abortIterable);
+      request.cacheController.signal.addEventListener('abort', abortIterable);
       callIteratorInDEV(iterator, progress, error);
       return serializeByValueID(streamTask.id);
     }
     function emitHint(request, code, model) {
       model = stringify(model);
-      code = stringToChunk(":H" + code + model + "\n");
+      code = stringToChunk(':H' + code + model + '\n');
       request.completedHintChunks.push(code);
       enqueueFlush(request);
     }
     function readThenable(thenable) {
-      if ("fulfilled" === thenable.status) return thenable.value;
-      if ("rejected" === thenable.status) throw thenable.reason;
+      if ('fulfilled' === thenable.status) return thenable.value;
+      if ('rejected' === thenable.status) throw thenable.reason;
       throw thenable;
     }
     function createLazyWrapperAroundWakeable(request, task, wakeable) {
       switch (wakeable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             forwardDebugInfoFromThenable(request, task, wakeable, null, null),
             wakeable.value
           );
-        case "rejected":
+        case 'rejected':
           forwardDebugInfoFromThenable(request, task, wakeable, null, null);
           break;
         default:
-          "string" !== typeof wakeable.status &&
-            ((wakeable.status = "pending"),
+          'string' !== typeof wakeable.status &&
+            ((wakeable.status = 'pending'),
             wakeable.then(
               function (fulfilledValue) {
                 forwardDebugInfoFromCurrentContext(request, task, wakeable);
-                "pending" === wakeable.status &&
-                  ((wakeable.status = "fulfilled"),
+                'pending' === wakeable.status &&
+                  ((wakeable.status = 'fulfilled'),
                   (wakeable.value = fulfilledValue));
               },
               function (error) {
                 forwardDebugInfoFromCurrentContext(request, task, wakeable);
-                "pending" === wakeable.status &&
-                  ((wakeable.status = "rejected"), (wakeable.reason = error));
-              }
+                'pending' === wakeable.status &&
+                  ((wakeable.status = 'rejected'), (wakeable.reason = error));
+              },
             ));
       }
       return {
         $$typeof: REACT_LAZY_TYPE,
         _payload: wakeable,
-        _init: readThenable
+        _init: readThenable,
       };
     }
     function callWithDebugContextInDEV(request, task, callback, arg) {
       var componentDebugInfo = {
-        name: "",
+        name: '',
         env: task.environmentName,
         key: null,
-        owner: task.debugOwner
+        owner: task.debugOwner,
       };
       componentDebugInfo.stack =
         null === task.debugStack
@@ -1515,18 +1515,18 @@
       request,
       task,
       Component,
-      result
+      result,
     ) {
       if (
-        "object" !== typeof result ||
+        'object' !== typeof result ||
         null === result ||
         isClientReference(result)
       )
         return result;
-      if ("function" === typeof result.then)
+      if ('function' === typeof result.then)
         return (
           result.then(function (resolvedValue) {
-            "object" === typeof resolvedValue &&
+            'object' === typeof resolvedValue &&
               null !== resolvedValue &&
               resolvedValue.$$typeof === REACT_ELEMENT_TYPE &&
               (resolvedValue._store.validated = 1);
@@ -1539,13 +1539,13 @@
         var multiShot = _defineProperty({}, Symbol.iterator, function () {
           var iterator = iteratorFn.call(result);
           iterator !== result ||
-            ("[object GeneratorFunction]" ===
+            ('[object GeneratorFunction]' ===
               Object.prototype.toString.call(Component) &&
-              "[object Generator]" ===
+              '[object Generator]' ===
                 Object.prototype.toString.call(result)) ||
             callWithDebugContextInDEV(request, task, function () {
               console.error(
-                "Returning an Iterator from a Server Component is not supported since it cannot be looped over more than once. "
+                'Returning an Iterator from a Server Component is not supported since it cannot be looped over more than once. ',
               );
             });
           return iterator;
@@ -1553,20 +1553,20 @@
         multiShot._debugInfo = result._debugInfo;
         return multiShot;
       }
-      return "function" !== typeof result[ASYNC_ITERATOR] ||
-        ("function" === typeof ReadableStream &&
+      return 'function' !== typeof result[ASYNC_ITERATOR] ||
+        ('function' === typeof ReadableStream &&
           result instanceof ReadableStream)
         ? result
         : ((multiShot = _defineProperty({}, ASYNC_ITERATOR, function () {
             var iterator = result[ASYNC_ITERATOR]();
             iterator !== result ||
-              ("[object AsyncGeneratorFunction]" ===
+              ('[object AsyncGeneratorFunction]' ===
                 Object.prototype.toString.call(Component) &&
-                "[object AsyncGenerator]" ===
+                '[object AsyncGenerator]' ===
                   Object.prototype.toString.call(result)) ||
               callWithDebugContextInDEV(request, task, function () {
                 console.error(
-                  "Returning an AsyncIterator from a Server Component is not supported since it cannot be looped over more than once. "
+                  'Returning an AsyncIterator from a Server Component is not supported since it cannot be looped over more than once. ',
                 );
               });
             return iterator;
@@ -1580,7 +1580,7 @@
       key,
       Component,
       props,
-      validated
+      validated,
     ) {
       var prevThenableState = task.thenableState;
       task.thenableState = null;
@@ -1589,14 +1589,14 @@
           var componentDebugInfo = prevThenableState._componentDebugInfo;
         else {
           var componentDebugID = task.id;
-          componentDebugInfo = Component.displayName || Component.name || "";
+          componentDebugInfo = Component.displayName || Component.name || '';
           var componentEnv = (0, request.environmentName)();
           request.pendingChunks++;
           componentDebugInfo = {
             name: componentDebugInfo,
             env: componentEnv,
             key: key,
-            owner: task.debugOwner
+            owner: task.debugOwner,
           };
           componentDebugInfo.stack =
             null === task.debugStack
@@ -1630,15 +1630,15 @@
                 callComponentInDEV,
                 Component,
                 props,
-                componentDebugInfo
-              )
+                componentDebugInfo,
+              ),
             )
           : componentStorage.run(
               componentDebugInfo,
               callComponentInDEV,
               Component,
               props,
-              componentDebugInfo
+              componentDebugInfo,
             )
         : task.debugTask
           ? task.debugTask.run(
@@ -1646,15 +1646,15 @@
                 null,
                 Component,
                 props,
-                componentDebugInfo
-              )
+                componentDebugInfo,
+              ),
             )
           : callComponentInDEV(Component, props, componentDebugInfo);
       if (request.status === ABORTING)
         throw (
-          ("object" !== typeof props ||
+          ('object' !== typeof props ||
             null === props ||
-            "function" !== typeof props.then ||
+            'function' !== typeof props.then ||
             isClientReference(props) ||
             props.then(voidHandler, voidHandler),
           null)
@@ -1672,13 +1672,13 @@
             task,
             validated[componentDebugID],
             componentDebugInfo,
-            prevThenableState[componentDebugID]
+            prevThenableState[componentDebugID],
           );
       props = processServerComponentReturnValue(
         request,
         task,
         Component,
-        props
+        props,
       );
       task.debugOwner = componentDebugInfo;
       task.debugStack = null;
@@ -1686,9 +1686,9 @@
       Component = task.keyPath;
       componentDebugInfo = task.implicitSlot;
       null !== key
-        ? (task.keyPath = null === Component ? key : Component + "," + key)
+        ? (task.keyPath = null === Component ? key : Component + ',' + key)
         : null === Component && (task.implicitSlot = !0);
-      request = renderModelDestructive(request, task, emptyRoot, "", props);
+      request = renderModelDestructive(request, task, emptyRoot, '', props);
       task.keyPath = Component;
       task.implicitSlot = componentDebugInfo;
       return request;
@@ -1697,8 +1697,8 @@
       function logKeyError() {
         console.error(
           'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
-          "",
-          ""
+          '',
+          '',
         );
       }
       key = request.didWarnForKey;
@@ -1717,15 +1717,15 @@
                 callComponentInDEV,
                 logKeyError,
                 null,
-                componentDebugInfo
-              )
+                componentDebugInfo,
+              ),
             )
           : componentStorage.run(
               componentDebugInfo,
               callComponentInDEV,
               logKeyError,
               null,
-              componentDebugInfo
+              componentDebugInfo,
             )
         : debugTask
           ? debugTask.run(
@@ -1733,8 +1733,8 @@
                 null,
                 logKeyError,
                 null,
-                componentDebugInfo
-              )
+                componentDebugInfo,
+              ),
             )
           : callComponentInDEV(logKeyError, null, componentDebugInfo);
     }
@@ -1742,7 +1742,7 @@
       for (var i = 0; i < children.length; i++) {
         var child = children[i];
         null === child ||
-          "object" !== typeof child ||
+          'object' !== typeof child ||
           child.$$typeof !== REACT_ELEMENT_TYPE ||
           null !== child.key ||
           child._store.validated ||
@@ -1757,7 +1757,7 @@
             { children: children },
             null,
             null,
-            0
+            0,
           ]),
           task.implicitSlot ? [request] : request
         );
@@ -1778,7 +1778,7 @@
             { children: children },
             null,
             null,
-            0
+            0,
           ]),
           task.implicitSlot ? [request] : request
         );
@@ -1796,7 +1796,7 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       pingTask(request, task);
       return serializeLazyID(task.id);
@@ -1812,7 +1812,7 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       retryTask(request, task);
       return 1 === task.status
@@ -1822,14 +1822,14 @@
     function renderElement(request, task, type, key, ref, props, validated) {
       if (null !== ref && void 0 !== ref)
         throw Error(
-          "Refs cannot be used in Server Components, nor passed to Client Components."
+          'Refs cannot be used in Server Components, nor passed to Client Components.',
         );
       jsxPropsParents.set(props, type);
-      "object" === typeof props.children &&
+      'object' === typeof props.children &&
         null !== props.children &&
         jsxChildrenParents.set(props.children, type);
       if (
-        "function" !== typeof type ||
+        'function' !== typeof type ||
         isClientReference(type) ||
         type.$$typeof === TEMPORARY_REFERENCE_TAG
       ) {
@@ -1837,7 +1837,7 @@
           return (
             2 === validated &&
               ((validated = {
-                name: "Fragment",
+                name: 'Fragment',
                 env: (0, request.environmentName)(),
                 key: key,
                 owner: task.debugOwner,
@@ -1846,11 +1846,11 @@
                     ? null
                     : filterStackTrace(
                         request,
-                        parseStackTrace(task.debugStack, 1)
+                        parseStackTrace(task.debugStack, 1),
                       ),
                 props: props,
                 debugStack: task.debugStack,
-                debugTask: task.debugTask
+                debugTask: task.debugTask,
               }),
               warnForMissingKey(request, key, validated, task.debugTask)),
             (validated = task.implicitSlot),
@@ -1859,15 +1859,15 @@
               request,
               task,
               emptyRoot,
-              "",
-              props.children
+              '',
+              props.children,
             )),
             (task.implicitSlot = validated),
             request
           );
         if (
           null != type &&
-          "object" === typeof type &&
+          'object' === typeof type &&
           !isClientReference(type)
         )
           switch (type.$$typeof) {
@@ -1881,7 +1881,7 @@
                 key,
                 ref,
                 props,
-                validated
+                validated,
               );
             case REACT_FORWARD_REF_TYPE:
               return renderFunctionComponent(
@@ -1890,7 +1890,7 @@
                 key,
                 type.render,
                 props,
-                validated
+                validated,
               );
             case REACT_MEMO_TYPE:
               return renderElement(
@@ -1900,12 +1900,12 @@
                 key,
                 ref,
                 props,
-                validated
+                validated,
               );
             case REACT_ELEMENT_TYPE:
               type._store.validated = 1;
           }
-        else if ("string" === typeof type) {
+        else if ('string' === typeof type) {
           ref = task.formatContext;
           var newFormatContext = getChildFormatContext(ref, type, props);
           ref !== newFormatContext &&
@@ -1913,7 +1913,7 @@
             outlineModelWithFormatContext(
               request,
               props.children,
-              newFormatContext
+              newFormatContext,
             );
         }
       } else
@@ -1923,22 +1923,22 @@
           key,
           type,
           props,
-          validated
+          validated,
         );
       ref = task.keyPath;
-      null === key ? (key = ref) : null !== ref && (key = ref + "," + key);
+      null === key ? (key = ref) : null !== ref && (key = ref + ',' + key);
       newFormatContext = null;
       ref = task.debugOwner;
       null !== ref && outlineComponentInfo(request, ref);
       if (null !== task.debugStack) {
         newFormatContext = filterStackTrace(
           request,
-          parseStackTrace(task.debugStack, 1)
+          parseStackTrace(task.debugStack, 1),
         );
         var id = outlineDebugModel(
           request,
           { objectLimit: 2 * newFormatContext.length + 1 },
-          newFormatContext
+          newFormatContext,
         );
         request.writtenObjects.set(newFormatContext, serializeByValueID(id));
       }
@@ -1949,7 +1949,7 @@
         props,
         ref,
         newFormatContext,
-        validated
+        validated,
       ];
       task = task.implicitSlot && null !== key ? [request] : request;
       return task;
@@ -1978,11 +1978,11 @@
       lastTimestamp,
       debugOwner,
       debugStack,
-      debugTask
+      debugTask,
     ) {
       request.pendingChunks++;
       var id = request.nextChunkId++;
-      "object" !== typeof model ||
+      'object' !== typeof model ||
         null === model ||
         null !== keyPath ||
         implicitSlot ||
@@ -2000,31 +2000,31 @@
         toJSON: function (parentPropertyName, value) {
           var parent = this,
             originalValue = parent[parentPropertyName];
-          "object" !== typeof originalValue ||
+          'object' !== typeof originalValue ||
             originalValue === value ||
             originalValue instanceof Date ||
             callWithDebugContextInDEV(request, task, function () {
-              "Object" !== objectName(originalValue)
-                ? "string" === typeof jsxChildrenParents.get(parent)
+              'Object' !== objectName(originalValue)
+                ? 'string' === typeof jsxChildrenParents.get(parent)
                   ? console.error(
-                      "%s objects cannot be rendered as text children. Try formatting it using toString().%s",
+                      '%s objects cannot be rendered as text children. Try formatting it using toString().%s',
                       objectName(originalValue),
-                      describeObjectForErrorMessage(parent, parentPropertyName)
+                      describeObjectForErrorMessage(parent, parentPropertyName),
                     )
                   : console.error(
-                      "Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s",
+                      'Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s',
                       objectName(originalValue),
-                      describeObjectForErrorMessage(parent, parentPropertyName)
+                      describeObjectForErrorMessage(parent, parentPropertyName),
                     )
                 : console.error(
-                    "Only plain objects can be passed to Client Components from Server Components. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s",
-                    describeObjectForErrorMessage(parent, parentPropertyName)
+                    'Only plain objects can be passed to Client Components from Server Components. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s',
+                    describeObjectForErrorMessage(parent, parentPropertyName),
                   );
             });
           return renderModel(request, task, parent, parentPropertyName, value);
         },
         thenableState: null,
-        timed: !1
+        timed: !1,
       };
       task.time = lastTimestamp;
       task.environmentName = request.environmentName();
@@ -2035,10 +2035,10 @@
       return task;
     }
     function serializeByValueID(id) {
-      return "$" + id.toString(16);
+      return '$' + id.toString(16);
     }
     function serializeLazyID(id) {
-      return "$L" + id.toString(16);
+      return '$L' + id.toString(16);
     }
     function serializeDeferredObject(request, value) {
       var deferredDebugObjects = request.deferredDebugObjects;
@@ -2047,50 +2047,50 @@
           (request = request.nextChunkId++),
           deferredDebugObjects.existing.set(value, request),
           deferredDebugObjects.retained.set(request, value),
-          "$Y" + request.toString(16))
-        : "$Y";
+          '$Y' + request.toString(16))
+        : '$Y';
     }
     function serializeNumber(number) {
       return Number.isFinite(number)
         ? 0 === number && -Infinity === 1 / number
-          ? "$-0"
+          ? '$-0'
           : number
         : Infinity === number
-          ? "$Infinity"
+          ? '$Infinity'
           : -Infinity === number
-            ? "$-Infinity"
-            : "$NaN";
+            ? '$-Infinity'
+            : '$NaN';
     }
     function encodeReferenceChunk(request, id, reference) {
       request = stringify(reference);
-      id = id.toString(16) + ":" + request + "\n";
+      id = id.toString(16) + ':' + request + '\n';
       return stringToChunk(id);
     }
     function serializeClientReference(
       request,
       parent,
       parentPropertyName,
-      clientReference
+      clientReference,
     ) {
       var clientReferenceKey = clientReference.$$async
-          ? clientReference.$$id + "#async"
+          ? clientReference.$$id + '#async'
           : clientReference.$$id,
         writtenClientReferences = request.writtenClientReferences,
         existingId = writtenClientReferences.get(clientReferenceKey);
       if (void 0 !== existingId)
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(existingId)
           : serializeByValueID(existingId);
       try {
         var clientReferenceMetadata = resolveClientReferenceMetadata(
           request.bundlerConfig,
-          clientReference
+          clientReference,
         );
         request.pendingChunks++;
         var importId = request.nextChunkId++;
         emitImportChunk(request, importId, clientReferenceMetadata, !1);
         writtenClientReferences.set(clientReferenceKey, importId);
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(importId)
           : serializeByValueID(importId);
       } catch (x) {
@@ -2107,26 +2107,26 @@
       request,
       parent,
       parentPropertyName,
-      clientReference
+      clientReference,
     ) {
       var existingId = request.writtenClientReferences.get(
         clientReference.$$async
-          ? clientReference.$$id + "#async"
-          : clientReference.$$id
+          ? clientReference.$$id + '#async'
+          : clientReference.$$id,
       );
       if (void 0 !== existingId)
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(existingId)
           : serializeByValueID(existingId);
       try {
         var clientReferenceMetadata = resolveClientReferenceMetadata(
           request.bundlerConfig,
-          clientReference
+          clientReference,
         );
         request.pendingDebugChunks++;
         var importId = request.nextChunkId++;
         emitImportChunk(request, importId, clientReferenceMetadata, !0);
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(importId)
           : serializeByValueID(importId);
       } catch (x) {
@@ -2153,7 +2153,7 @@
         performance.now(),
         null,
         null,
-        null
+        null,
       );
       retryTask(request, value);
       return value.id;
@@ -2161,7 +2161,7 @@
     function serializeServerReference(request, serverReference) {
       var writtenServerReferences = request.writtenServerReferences,
         existingId = writtenServerReferences.get(serverReference);
-      if (void 0 !== existingId) return "$F" + existingId.toString(16);
+      if (void 0 !== existingId) return '$F' + existingId.toString(16);
       existingId = serverReference.$$bound;
       existingId = null === existingId ? null : Promise.resolve(existingId);
       var id = serverReference.$$id,
@@ -2178,16 +2178,16 @@
               id: id,
               bound: existingId,
               name:
-                "function" === typeof serverReference
+                'function' === typeof serverReference
                   ? serverReference.name
-                  : "",
+                  : '',
               env: (0, request.environmentName)(),
-              location: location
+              location: location,
             }
           : { id: id, bound: existingId };
       request = outlineModel(request, existingId);
       writtenServerReferences.set(serverReference, request);
-      return "$F" + request.toString(16);
+      return '$F' + request.toString(16);
     }
     function serializeLargeTextString(request, text) {
       request.pendingChunks++;
@@ -2197,15 +2197,15 @@
     }
     function serializeMap(request, map) {
       map = Array.from(map);
-      return "$Q" + outlineModel(request, map).toString(16);
+      return '$Q' + outlineModel(request, map).toString(16);
     }
     function serializeFormData(request, formData) {
       formData = Array.from(formData.entries());
-      return "$K" + outlineModel(request, formData).toString(16);
+      return '$K' + outlineModel(request, formData).toString(16);
     }
     function serializeSet(request, set) {
       set = Array.from(set);
-      return "$W" + outlineModel(request, set).toString(16);
+      return '$W' + outlineModel(request, set).toString(16);
     }
     function serializeTypedArray(request, tag, typedArray) {
       request.pendingChunks++;
@@ -2226,7 +2226,7 @@
             request,
             id,
             { objectLimit: model.length + 2 },
-            model
+            model,
           ),
             enqueueFlush(request);
         else
@@ -2235,7 +2235,7 @@
           );
       }
       function error(reason) {
-        emitErrorChunk(request, id, "", reason, !0, null);
+        emitErrorChunk(request, id, '', reason, !0, null);
         enqueueFlush(request);
         reader.cancel(reason).then(noop, noop);
       }
@@ -2244,15 +2244,15 @@
       request.pendingDebugChunks++;
       var id = request.nextChunkId++;
       reader.read().then(progress).catch(error);
-      return "$B" + id.toString(16);
+      return '$B' + id.toString(16);
     }
     function serializeBlob(request, blob) {
       function progress(entry) {
         if (0 === newTask.status)
           if (entry.done)
             request.cacheController.signal.removeEventListener(
-              "abort",
-              abortBlob
+              'abort',
+              abortBlob,
             ),
               pingTask(request, newTask);
           else
@@ -2263,8 +2263,8 @@
       function error(reason) {
         0 === newTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortBlob
+            'abort',
+            abortBlob,
           ),
           erroredTask(request, newTask, reason),
           enqueueFlush(request),
@@ -2273,7 +2273,7 @@
       function abortBlob() {
         if (0 === newTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortBlob);
+          signal.removeEventListener('abort', abortBlob);
           signal = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(newTask),
@@ -2294,12 +2294,12 @@
           performance.now(),
           null,
           null,
-          null
+          null,
         ),
         reader = blob.stream().getReader();
-      request.cacheController.signal.addEventListener("abort", abortBlob);
+      request.cacheController.signal.addEventListener('abort', abortBlob);
       reader.read().then(progress).catch(error);
-      return "$B" + newTask.id.toString(16);
+      return '$B' + newTask.id.toString(16);
     }
     function renderModel(request, task, parent, key, value) {
       serializedSize += key.length;
@@ -2310,7 +2310,7 @@
       } catch (thrownValue) {
         parent = task.model;
         parent =
-          "object" === typeof parent &&
+          'object' === typeof parent &&
           null !== parent &&
           (parent.$$typeof === REACT_ELEMENT_TYPE ||
             parent.$$typeof === REACT_LAZY_TYPE);
@@ -2332,9 +2332,9 @@
             ? getSuspendedThenable()
             : thrownValue;
         if (
-          "object" === typeof key &&
+          'object' === typeof key &&
           null !== key &&
-          "function" === typeof key.then
+          'function' === typeof key.then
         )
           return (
             (request = createTask(
@@ -2347,7 +2347,7 @@
               task.time,
               task.debugOwner,
               task.debugStack,
-              task.debugTask
+              task.debugTask,
             )),
             (value = request.ping),
             key.then(value, value),
@@ -2369,7 +2369,7 @@
           prevImplicitSlot,
           key,
           !1,
-          task.debugOwner
+          task.debugOwner,
         );
         return parent
           ? serializeLazyID(prevKeyPath)
@@ -2381,12 +2381,12 @@
       task,
       parent,
       parentPropertyName,
-      value
+      value,
     ) {
       task.model = value;
-      if (value === REACT_ELEMENT_TYPE) return "$";
+      if (value === REACT_ELEMENT_TYPE) return '$';
       if (null === value) return null;
-      if ("object" === typeof value) {
+      if ('object' === typeof value) {
         switch (value.$$typeof) {
           case REACT_ELEMENT_TYPE:
             var elementReference = null,
@@ -2397,11 +2397,11 @@
                 if (modelRoot === value) modelRoot = null;
                 else return _existingReference;
               else
-                -1 === parentPropertyName.indexOf(":") &&
+                -1 === parentPropertyName.indexOf(':') &&
                   ((_existingReference = _writtenObjects.get(parent)),
                   void 0 !== _existingReference &&
                     ((elementReference =
-                      _existingReference + ":" + parentPropertyName),
+                      _existingReference + ':' + parentPropertyName),
                     _writtenObjects.set(value, elementReference)));
             }
             if (serializedSize > MAX_ROW_SIZE) return deferTask(request, task);
@@ -2420,13 +2420,13 @@
               void 0 === value._debugStack ||
               void 0 === value._debugTask
             ) {
-              var key = "";
+              var key = '';
               null !== value.key && (key = ' key="' + value.key + '"');
               console.error(
-                "Attempted to render <%s%s> without development properties. This is not supported. It can happen if:\n- The element is created with a production version of React but rendered in development.\n- The element was cloned with a custom function instead of `React.cloneElement`.\nThe props of this element may help locate this element: %o",
+                'Attempted to render <%s%s> without development properties. This is not supported. It can happen if:\n- The element is created with a production version of React but rendered in development.\n- The element was cloned with a custom function instead of `React.cloneElement`.\nThe props of this element may help locate this element: %o',
                 value.type,
                 key,
-                value.props
+                value.props,
               );
             }
             request = renderElement(
@@ -2436,9 +2436,9 @@
               value.key,
               refProp,
               _existingReference,
-              value._store.validated
+              value._store.validated,
             );
-            "object" === typeof request &&
+            'object' === typeof request &&
               null !== request &&
               null !== elementReference &&
               (_writtenObjects.has(request) ||
@@ -2457,12 +2457,12 @@
               request,
               task,
               emptyRoot,
-              "",
-              elementReference
+              '',
+              elementReference,
             );
           case REACT_LEGACY_ELEMENT_TYPE:
             throw Error(
-              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
+              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.',
             );
         }
         if (isClientReference(value))
@@ -2470,26 +2470,26 @@
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (
           void 0 !== request.temporaryReferences &&
           ((elementReference = request.temporaryReferences.get(value)),
           void 0 !== elementReference)
         )
-          return "$T" + elementReference;
+          return '$T' + elementReference;
         elementReference = request.writtenObjects;
         _writtenObjects = elementReference.get(value);
-        if ("function" === typeof value.then) {
+        if ('function' === typeof value.then) {
           if (void 0 !== _writtenObjects) {
             if (null !== task.keyPath || task.implicitSlot)
               return (
-                "$@" + serializeThenable(request, task, value).toString(16)
+                '$@' + serializeThenable(request, task, value).toString(16)
               );
             if (modelRoot === value) modelRoot = null;
             else return _writtenObjects;
           }
-          request = "$@" + serializeThenable(request, task, value).toString(16);
+          request = '$@' + serializeThenable(request, task, value).toString(16);
           elementReference.set(value, request);
           return request;
         }
@@ -2500,81 +2500,81 @@
             modelRoot = null;
           } else return _writtenObjects;
         else if (
-          -1 === parentPropertyName.indexOf(":") &&
+          -1 === parentPropertyName.indexOf(':') &&
           ((_writtenObjects = elementReference.get(parent)),
           void 0 !== _writtenObjects)
         ) {
           _existingReference = parentPropertyName;
           if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
             switch (parentPropertyName) {
-              case "1":
-                _existingReference = "type";
+              case '1':
+                _existingReference = 'type';
                 break;
-              case "2":
-                _existingReference = "key";
+              case '2':
+                _existingReference = 'key';
                 break;
-              case "3":
-                _existingReference = "props";
+              case '3':
+                _existingReference = 'props';
                 break;
-              case "4":
-                _existingReference = "_owner";
+              case '4':
+                _existingReference = '_owner';
             }
           elementReference.set(
             value,
-            _writtenObjects + ":" + _existingReference
+            _writtenObjects + ':' + _existingReference,
           );
         }
         if (isArrayImpl(value)) return renderFragment(request, task, value);
         if (value instanceof Map) return serializeMap(request, value);
         if (value instanceof Set) return serializeSet(request, value);
-        if ("function" === typeof FormData && value instanceof FormData)
+        if ('function' === typeof FormData && value instanceof FormData)
           return serializeFormData(request, value);
         if (value instanceof Error) return serializeErrorValue(request, value);
         if (value instanceof ArrayBuffer)
-          return serializeTypedArray(request, "A", new Uint8Array(value));
+          return serializeTypedArray(request, 'A', new Uint8Array(value));
         if (value instanceof Int8Array)
-          return serializeTypedArray(request, "O", value);
+          return serializeTypedArray(request, 'O', value);
         if (value instanceof Uint8Array)
-          return serializeTypedArray(request, "o", value);
+          return serializeTypedArray(request, 'o', value);
         if (value instanceof Uint8ClampedArray)
-          return serializeTypedArray(request, "U", value);
+          return serializeTypedArray(request, 'U', value);
         if (value instanceof Int16Array)
-          return serializeTypedArray(request, "S", value);
+          return serializeTypedArray(request, 'S', value);
         if (value instanceof Uint16Array)
-          return serializeTypedArray(request, "s", value);
+          return serializeTypedArray(request, 's', value);
         if (value instanceof Int32Array)
-          return serializeTypedArray(request, "L", value);
+          return serializeTypedArray(request, 'L', value);
         if (value instanceof Uint32Array)
-          return serializeTypedArray(request, "l", value);
+          return serializeTypedArray(request, 'l', value);
         if (value instanceof Float32Array)
-          return serializeTypedArray(request, "G", value);
+          return serializeTypedArray(request, 'G', value);
         if (value instanceof Float64Array)
-          return serializeTypedArray(request, "g", value);
+          return serializeTypedArray(request, 'g', value);
         if (value instanceof BigInt64Array)
-          return serializeTypedArray(request, "M", value);
+          return serializeTypedArray(request, 'M', value);
         if (value instanceof BigUint64Array)
-          return serializeTypedArray(request, "m", value);
+          return serializeTypedArray(request, 'm', value);
         if (value instanceof DataView)
-          return serializeTypedArray(request, "V", value);
-        if ("function" === typeof Blob && value instanceof Blob)
+          return serializeTypedArray(request, 'V', value);
+        if ('function' === typeof Blob && value instanceof Blob)
           return serializeBlob(request, value);
         if ((elementReference = getIteratorFn(value)))
           return (
             (elementReference = elementReference.call(value)),
             elementReference === value
-              ? "$i" +
+              ? '$i' +
                 outlineModel(request, Array.from(elementReference)).toString(16)
               : renderFragment(request, task, Array.from(elementReference))
           );
         if (
-          "function" === typeof ReadableStream &&
+          'function' === typeof ReadableStream &&
           value instanceof ReadableStream
         )
           return serializeReadableStream(request, task, value);
         elementReference = value[ASYNC_ITERATOR];
-        if ("function" === typeof elementReference)
+        if ('function' === typeof elementReference)
           return renderAsyncFragment(request, task, value, elementReference);
-        if (value instanceof Date) return "$D" + value.toJSON();
+        if (value instanceof Date) return '$D' + value.toJSON();
         elementReference = getPrototypeOf(value);
         if (
           elementReference !== ObjectPrototype &&
@@ -2582,22 +2582,22 @@
             null !== getPrototypeOf(elementReference))
         )
           throw Error(
-            "Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported." +
-              describeObjectForErrorMessage(parent, parentPropertyName)
+            'Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.' +
+              describeObjectForErrorMessage(parent, parentPropertyName),
           );
-        if ("Object" !== objectName(value))
+        if ('Object' !== objectName(value))
           callWithDebugContextInDEV(request, task, function () {
             console.error(
-              "Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s",
+              'Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s',
               objectName(value),
-              describeObjectForErrorMessage(parent, parentPropertyName)
+              describeObjectForErrorMessage(parent, parentPropertyName),
             );
           });
         else if (!isSimpleObject(value))
           callWithDebugContextInDEV(request, task, function () {
             console.error(
-              "Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.%s",
-              describeObjectForErrorMessage(parent, parentPropertyName)
+              'Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.%s',
+              describeObjectForErrorMessage(parent, parentPropertyName),
             );
           });
         else if (Object.getOwnPropertySymbols) {
@@ -2605,36 +2605,36 @@
           0 < symbols.length &&
             callWithDebugContextInDEV(request, task, function () {
               console.error(
-                "Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like %s are not supported.%s",
+                'Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like %s are not supported.%s',
                 symbols[0].description,
-                describeObjectForErrorMessage(parent, parentPropertyName)
+                describeObjectForErrorMessage(parent, parentPropertyName),
               );
             });
         }
         return value;
       }
-      if ("string" === typeof value)
+      if ('string' === typeof value)
         return (
           (serializedSize += value.length),
-          "Z" === value[value.length - 1] &&
+          'Z' === value[value.length - 1] &&
           parent[parentPropertyName] instanceof Date
-            ? "$D" + value
+            ? '$D' + value
             : 1024 <= value.length && null !== byteLengthOfChunk
               ? serializeLargeTextString(request, value)
-              : "$" === value[0]
-                ? "$" + value
+              : '$' === value[0]
+                ? '$' + value
                 : value
         );
-      if ("boolean" === typeof value) return value;
-      if ("number" === typeof value) return serializeNumber(value);
-      if ("undefined" === typeof value) return "$undefined";
-      if ("function" === typeof value) {
+      if ('boolean' === typeof value) return value;
+      if ('number' === typeof value) return serializeNumber(value);
+      if ('undefined' === typeof value) return '$undefined';
+      if ('function' === typeof value) {
         if (isClientReference(value))
           return serializeClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (value.$$typeof === SERVER_REFERENCE_TAG)
           return serializeServerReference(request, value);
@@ -2643,38 +2643,38 @@
           ((request = request.temporaryReferences.get(value)),
           void 0 !== request)
         )
-          return "$T" + request;
+          return '$T' + request;
         if (value.$$typeof === TEMPORARY_REFERENCE_TAG)
           throw Error(
-            "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+            'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
           );
         if (/^on[A-Z]/.test(parentPropertyName))
           throw Error(
-            "Event handlers cannot be passed to Client Component props." +
+            'Event handlers cannot be passed to Client Component props.' +
               describeObjectForErrorMessage(parent, parentPropertyName) +
-              "\nIf you need interactivity, consider converting part of this to a Client Component."
+              '\nIf you need interactivity, consider converting part of this to a Client Component.',
           );
         if (
           jsxChildrenParents.has(parent) ||
-          (jsxPropsParents.has(parent) && "children" === parentPropertyName)
+          (jsxPropsParents.has(parent) && 'children' === parentPropertyName)
         )
           throw (
-            ((request = value.displayName || value.name || "Component"),
+            ((request = value.displayName || value.name || 'Component'),
             Error(
-              "Functions are not valid as a child of Client Components. This may happen if you return " +
+              'Functions are not valid as a child of Client Components. This may happen if you return ' +
                 request +
-                " instead of <" +
+                ' instead of <' +
                 request +
-                " /> from render. Or maybe you meant to call this function rather than return it." +
-                describeObjectForErrorMessage(parent, parentPropertyName)
+                ' /> from render. Or maybe you meant to call this function rather than return it.' +
+                describeObjectForErrorMessage(parent, parentPropertyName),
             ))
           );
         throw Error(
           'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.' +
-            describeObjectForErrorMessage(parent, parentPropertyName)
+            describeObjectForErrorMessage(parent, parentPropertyName),
         );
       }
-      if ("symbol" === typeof value) {
+      if ('symbol' === typeof value) {
         task = request.writtenSymbols;
         elementReference = task.get(value);
         if (void 0 !== elementReference)
@@ -2682,9 +2682,9 @@
         elementReference = value.description;
         if (Symbol.for(elementReference) !== value)
           throw Error(
-            "Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" +
-              (value.description + ") cannot be found among global symbols.") +
-              describeObjectForErrorMessage(parent, parentPropertyName)
+            'Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(' +
+              (value.description + ') cannot be found among global symbols.') +
+              describeObjectForErrorMessage(parent, parentPropertyName),
           );
         request.pendingChunks++;
         _writtenObjects = request.nextChunkId++;
@@ -2692,12 +2692,12 @@
         task.set(value, _writtenObjects);
         return serializeByValueID(_writtenObjects);
       }
-      if ("bigint" === typeof value) return "$n" + value.toString(10);
+      if ('bigint' === typeof value) return '$n' + value.toString(10);
       throw Error(
-        "Type " +
+        'Type ' +
           typeof value +
-          " is not supported in Client Component props." +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+          ' is not supported in Client Component props.' +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     }
     function logRecoverableError(request, error, task) {
@@ -2714,7 +2714,7 @@
                   request,
                   task,
                   onError,
-                  error
+                  error,
                 )
               : callWithDebugContextInDEV(request, task, onError, error)
             : supportsRequestStorage
@@ -2723,13 +2723,13 @@
       } finally {
         currentRequest = prevRequest;
       }
-      if (null != errorDigest && "string" !== typeof errorDigest)
+      if (null != errorDigest && 'string' !== typeof errorDigest)
         throw Error(
           'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
             typeof errorDigest +
-            '" instead'
+            '" instead',
         );
-      return errorDigest || "";
+      return errorDigest || '';
     }
     function fatalError(request, error) {
       var onFatalError = request.onFatalError;
@@ -2739,35 +2739,35 @@
           closeWithError(request.destination, error))
         : ((request.status = 13), (request.fatalError = error));
       request.cacheController.abort(
-        Error("The render was aborted due to a fatal error.", { cause: error })
+        Error('The render was aborted due to a fatal error.', { cause: error }),
       );
     }
     function serializeErrorValue(request, error) {
-      var name = "Error",
+      var name = 'Error',
         env = (0, request.environmentName)();
       try {
         name = error.name;
         var message = String(error.message);
         var stack = filterStackTrace(request, parseStackTrace(error, 0));
         var errorEnv = error.environmentName;
-        "string" === typeof errorEnv && (env = errorEnv);
+        'string' === typeof errorEnv && (env = errorEnv);
       } catch (x) {
         (message =
-          "An error occurred but serializing the error message failed."),
+          'An error occurred but serializing the error message failed.'),
           (stack = []);
       }
       return (
-        "$Z" +
+        '$Z' +
         outlineModel(request, {
           name: name,
           message: message,
           stack: stack,
-          env: env
+          env: env,
         }).toString(16)
       );
     }
     function emitErrorChunk(request, id, digest, error, debug, owner) {
-      var name = "Error",
+      var name = 'Error',
         env = (0, request.environmentName)();
       try {
         if (error instanceof Error) {
@@ -2775,16 +2775,16 @@
           var message = String(error.message);
           var stack = filterStackTrace(request, parseStackTrace(error, 0));
           var errorEnv = error.environmentName;
-          "string" === typeof errorEnv && (env = errorEnv);
+          'string' === typeof errorEnv && (env = errorEnv);
         } else
           (message =
-            "object" === typeof error && null !== error
+            'object' === typeof error && null !== error
               ? describeObjectForErrorMessage(error)
               : String(error)),
             (stack = []);
       } catch (x) {
         (message =
-          "An error occurred but serializing the error message failed."),
+          'An error occurred but serializing the error message failed.'),
           (stack = []);
       }
       error = null == owner ? null : outlineComponentInfo(request, owner);
@@ -2794,9 +2794,9 @@
         message: message,
         stack: stack,
         env: env,
-        owner: error
+        owner: error,
       };
-      id = id.toString(16) + ":E" + stringify(digest) + "\n";
+      id = id.toString(16) + ':E' + stringify(digest) + '\n';
       id = stringToChunk(id);
       debug
         ? request.completedDebugChunks.push(id)
@@ -2804,23 +2804,23 @@
     }
     function emitImportChunk(request, id, clientReferenceMetadata, debug) {
       clientReferenceMetadata = stringify(clientReferenceMetadata);
-      id = id.toString(16) + ":I" + clientReferenceMetadata + "\n";
+      id = id.toString(16) + ':I' + clientReferenceMetadata + '\n';
       id = stringToChunk(id);
       debug
         ? request.completedDebugChunks.push(id)
         : request.completedImportChunks.push(id);
     }
     function emitSymbolChunk(request, id, name) {
-      id = encodeReferenceChunk(request, id, "$S" + name);
+      id = encodeReferenceChunk(request, id, '$S' + name);
       request.completedImportChunks.push(id);
     }
     function emitModelChunk(request, id, json) {
-      id = id.toString(16) + ":" + json + "\n";
+      id = id.toString(16) + ':' + json + '\n';
       id = stringToChunk(id);
       request.completedRegularChunks.push(id);
     }
     function emitDebugHaltChunk(request, id) {
-      id = id.toString(16) + ":\n";
+      id = id.toString(16) + ':\n';
       id = stringToChunk(id);
       request.completedDebugChunks.push(id);
     }
@@ -2828,12 +2828,12 @@
       var json = serializeDebugModel(request, 500, debugInfo);
       null !== request.debugDestination
         ? ((debugInfo = request.nextChunkId++),
-          (json = debugInfo.toString(16) + ":" + json + "\n"),
+          (json = debugInfo.toString(16) + ':' + json + '\n'),
           request.pendingDebugChunks++,
           request.completedDebugChunks.push(stringToChunk(json)),
           (id = id.toString(16) + ':D"$' + debugInfo.toString(16) + '"\n'),
           request.completedRegularChunks.push(stringToChunk(id)))
-        : ((id = id.toString(16) + ":D" + json + "\n"),
+        : ((id = id.toString(16) + ':D' + json + '\n'),
           request.completedRegularChunks.push(stringToChunk(id)));
     }
     function outlineComponentInfo(request, componentInfo) {
@@ -2847,7 +2847,7 @@
       existingRef = { objectLimit: existingRef };
       var componentDebugInfo = {
         name: componentInfo.name,
-        key: componentInfo.key
+        key: componentInfo.key,
       };
       null != componentInfo.env && (componentDebugInfo.env = componentInfo.env);
       null != componentInfo.owner &&
@@ -2855,7 +2855,7 @@
       null == componentInfo.stack && null != componentInfo.debugStack
         ? (componentDebugInfo.stack = filterStackTrace(
             request,
-            parseStackTrace(componentInfo.debugStack, 1)
+            parseStackTrace(componentInfo.debugStack, 1),
           ))
         : null != componentInfo.stack &&
           (componentDebugInfo.stack = componentInfo.stack);
@@ -2871,11 +2871,11 @@
       var buffer = new Uint8Array(
         typedArray.buffer,
         typedArray.byteOffset,
-        typedArray.byteLength
+        typedArray.byteLength,
       );
       typedArray = 2048 < typedArray.byteLength ? buffer.slice() : buffer;
       buffer = typedArray.byteLength;
-      id = id.toString(16) + ":" + tag + buffer.toString(16) + ",";
+      id = id.toString(16) + ':' + tag + buffer.toString(16) + ',';
       id = stringToChunk(id);
       debug
         ? request.completedDebugChunks.push(id, typedArray)
@@ -2884,12 +2884,12 @@
     function emitTextChunk(request, id, text, debug) {
       if (null === byteLengthOfChunk)
         throw Error(
-          "Existence of byteLengthOfChunk should have already been checked. This is a bug in React."
+          'Existence of byteLengthOfChunk should have already been checked. This is a bug in React.',
         );
       debug ? request.pendingDebugChunks++ : request.pendingChunks++;
       text = stringToChunk(text);
       var binaryLength = text.byteLength;
-      id = id.toString(16) + ":T" + binaryLength.toString(16) + ",";
+      id = id.toString(16) + ':T' + binaryLength.toString(16) + ',';
       id = stringToChunk(id);
       debug
         ? request.completedDebugChunks.push(id, text)
@@ -2900,17 +2900,17 @@
       counter,
       parent,
       parentPropertyName,
-      value
+      value,
     ) {
       if (null === value) return null;
-      if (value === REACT_ELEMENT_TYPE) return "$";
-      if ("object" === typeof value) {
+      if (value === REACT_ELEMENT_TYPE) return '$';
+      if ('object' === typeof value) {
         if (isClientReference(value))
           return serializeDebugClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (value.$$typeof === CONSTRUCTOR_MARKER) {
           value = value.constructor;
@@ -2918,18 +2918,18 @@
           void 0 === ref &&
             ((request = outlineDebugModel(request, counter, value)),
             (ref = serializeByValueID(request)));
-          return "$P" + ref.slice(1);
+          return '$P' + ref.slice(1);
         }
         if (void 0 !== request.temporaryReferences) {
           var tempRef = request.temporaryReferences.get(value);
-          if (void 0 !== tempRef) return "$T" + tempRef;
+          if (void 0 !== tempRef) return '$T' + tempRef;
         }
         tempRef = request.writtenDebugObjects;
         var existingDebugReference = tempRef.get(value);
         if (void 0 !== existingDebugReference)
           if (debugModelRoot === value) debugModelRoot = null;
           else return existingDebugReference;
-        else if (-1 === parentPropertyName.indexOf(":"))
+        else if (-1 === parentPropertyName.indexOf(':'))
           if (
             ((existingDebugReference = tempRef.get(parent)),
             void 0 !== existingDebugReference)
@@ -2939,21 +2939,21 @@
             var propertyName = parentPropertyName;
             if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
               switch (parentPropertyName) {
-                case "1":
-                  propertyName = "type";
+                case '1':
+                  propertyName = 'type';
                   break;
-                case "2":
-                  propertyName = "key";
+                case '2':
+                  propertyName = 'key';
                   break;
-                case "3":
-                  propertyName = "props";
+                case '3':
+                  propertyName = 'props';
                   break;
-                case "4":
-                  propertyName = "_owner";
+                case '4':
+                  propertyName = '_owner';
               }
-            tempRef.set(value, existingDebugReference + ":" + propertyName);
+            tempRef.set(value, existingDebugReference + ':' + propertyName);
           } else if (debugNoOutline !== value) {
-            if ("function" === typeof value.then)
+            if ('function' === typeof value.then)
               return serializeDebugThenable(request, counter, value);
             request = outlineDebugModel(request, counter, value);
             return serializeByValueID(request);
@@ -2976,17 +2976,17 @@
               request,
               parentPropertyName,
               counter,
-              value
+              value,
             ),
             serializeByValueID(parentPropertyName)
           );
         switch (value.$$typeof) {
           case REACT_ELEMENT_TYPE:
             null != value._owner && outlineComponentInfo(request, value._owner);
-            "object" === typeof value.type &&
+            'object' === typeof value.type &&
               null !== value.type &&
               doNotLimit.add(value.type);
-            "object" === typeof value.key &&
+            'object' === typeof value.key &&
               null !== value.key &&
               doNotLimit.add(value.key);
             doNotLimit.add(value.props);
@@ -2996,7 +2996,7 @@
               for (
                 counter = filterStackTrace(
                   request,
-                  parseStackTrace(value._debugStack, 1)
+                  parseStackTrace(value._debugStack, 1),
                 ),
                   doNotLimit.add(counter),
                   request = 0;
@@ -3011,18 +3011,18 @@
               value.props,
               value._owner,
               counter,
-              value._store.validated
+              value._store.validated,
             ];
           case REACT_LAZY_TYPE:
             value = value._payload;
-            if (null !== value && "object" === typeof value) {
+            if (null !== value && 'object' === typeof value) {
               switch (value._status) {
                 case 1:
                   return (
                     (request = outlineDebugModel(
                       request,
                       counter,
-                      value._result
+                      value._result,
                     )),
                     serializeLazyID(request)
                   );
@@ -3032,34 +3032,34 @@
                     emitErrorChunk(
                       request,
                       counter,
-                      "",
+                      '',
                       value._result,
                       !0,
-                      null
+                      null,
                     ),
                     serializeLazyID(counter)
                   );
               }
               switch (value.status) {
-                case "fulfilled":
+                case 'fulfilled':
                   return (
                     (request = outlineDebugModel(
                       request,
                       counter,
-                      value.value
+                      value.value,
                     )),
                     serializeLazyID(request)
                   );
-                case "rejected":
+                case 'rejected':
                   return (
                     (counter = request.nextChunkId++),
                     emitErrorChunk(
                       request,
                       counter,
-                      "",
+                      '',
                       value.reason,
                       !0,
-                      null
+                      null,
                     ),
                     serializeLazyID(counter)
                   );
@@ -3070,7 +3070,7 @@
             emitDebugHaltChunk(request, value);
             return serializeLazyID(value);
         }
-        if ("function" === typeof value.then)
+        if ('function' === typeof value.then)
           return serializeDebugThenable(request, counter, value);
         if (isArrayImpl(value)) return value;
         if (value instanceof Map) {
@@ -3081,81 +3081,81 @@
             doNotLimit.add(entry);
             var key = entry[0];
             entry = entry[1];
-            "object" === typeof key && null !== key && doNotLimit.add(key);
-            "object" === typeof entry &&
+            'object' === typeof key && null !== key && doNotLimit.add(key);
+            'object' === typeof entry &&
               null !== entry &&
               doNotLimit.add(entry);
           }
-          return "$Q" + outlineDebugModel(request, counter, value).toString(16);
+          return '$Q' + outlineDebugModel(request, counter, value).toString(16);
         }
         if (value instanceof Set) {
           value = Array.from(value);
           counter.objectLimit++;
           for (ref = 0; ref < value.length; ref++)
             (key = value[ref]),
-              "object" === typeof key && null !== key && doNotLimit.add(key);
-          return "$W" + outlineDebugModel(request, counter, value).toString(16);
+              'object' === typeof key && null !== key && doNotLimit.add(key);
+          return '$W' + outlineDebugModel(request, counter, value).toString(16);
         }
-        if ("function" === typeof FormData && value instanceof FormData)
+        if ('function' === typeof FormData && value instanceof FormData)
           return (
             (value = Array.from(value.entries())),
-            "$K" +
+            '$K' +
               outlineDebugModel(
                 request,
                 { objectLimit: 2 * value.length + 1 },
-                value
+                value,
               ).toString(16)
           );
         if (value instanceof Error) {
-          counter = "Error";
+          counter = 'Error';
           var env = (0, request.environmentName)();
           try {
             (counter = value.name),
               (ref = String(value.message)),
               (key = filterStackTrace(request, parseStackTrace(value, 0))),
               (entry = value.environmentName),
-              "string" === typeof entry && (env = entry);
+              'string' === typeof entry && (env = entry);
           } catch (x) {
             (ref =
-              "An error occurred but serializing the error message failed."),
+              'An error occurred but serializing the error message failed.'),
               (key = []);
           }
           request =
-            "$Z" +
+            '$Z' +
             outlineDebugModel(
               request,
               { objectLimit: 2 * key.length + 1 },
-              { name: counter, message: ref, stack: key, env: env }
+              { name: counter, message: ref, stack: key, env: env },
             ).toString(16);
           return request;
         }
         if (value instanceof ArrayBuffer)
-          return serializeDebugTypedArray(request, "A", new Uint8Array(value));
+          return serializeDebugTypedArray(request, 'A', new Uint8Array(value));
         if (value instanceof Int8Array)
-          return serializeDebugTypedArray(request, "O", value);
+          return serializeDebugTypedArray(request, 'O', value);
         if (value instanceof Uint8Array)
-          return serializeDebugTypedArray(request, "o", value);
+          return serializeDebugTypedArray(request, 'o', value);
         if (value instanceof Uint8ClampedArray)
-          return serializeDebugTypedArray(request, "U", value);
+          return serializeDebugTypedArray(request, 'U', value);
         if (value instanceof Int16Array)
-          return serializeDebugTypedArray(request, "S", value);
+          return serializeDebugTypedArray(request, 'S', value);
         if (value instanceof Uint16Array)
-          return serializeDebugTypedArray(request, "s", value);
+          return serializeDebugTypedArray(request, 's', value);
         if (value instanceof Int32Array)
-          return serializeDebugTypedArray(request, "L", value);
+          return serializeDebugTypedArray(request, 'L', value);
         if (value instanceof Uint32Array)
-          return serializeDebugTypedArray(request, "l", value);
+          return serializeDebugTypedArray(request, 'l', value);
         if (value instanceof Float32Array)
-          return serializeDebugTypedArray(request, "G", value);
+          return serializeDebugTypedArray(request, 'G', value);
         if (value instanceof Float64Array)
-          return serializeDebugTypedArray(request, "g", value);
+          return serializeDebugTypedArray(request, 'g', value);
         if (value instanceof BigInt64Array)
-          return serializeDebugTypedArray(request, "M", value);
+          return serializeDebugTypedArray(request, 'M', value);
         if (value instanceof BigUint64Array)
-          return serializeDebugTypedArray(request, "m", value);
+          return serializeDebugTypedArray(request, 'm', value);
         if (value instanceof DataView)
-          return serializeDebugTypedArray(request, "V", value);
-        if ("function" === typeof Blob && value instanceof Blob)
+          return serializeDebugTypedArray(request, 'V', value);
+        if ('function' === typeof Blob && value instanceof Blob)
           return serializeDebugBlob(request, value);
         if (getIteratorFn(value)) return Array.from(value);
         request = getPrototypeOf(value);
@@ -3165,21 +3165,21 @@
             if (hasOwnProperty.call(value, env) || isGetter(request, env))
               counter[env] = value[env];
           ref = request.constructor;
-          "function" !== typeof ref ||
+          'function' !== typeof ref ||
             ref.prototype !== request ||
-            hasOwnProperty.call(value, "") ||
-            isGetter(request, "") ||
-            (counter[""] = { $$typeof: CONSTRUCTOR_MARKER, constructor: ref });
+            hasOwnProperty.call(value, '') ||
+            isGetter(request, '') ||
+            (counter[''] = { $$typeof: CONSTRUCTOR_MARKER, constructor: ref });
           return counter;
         }
         return value;
       }
-      if ("string" === typeof value) {
+      if ('string' === typeof value) {
         if (
-          "Z" === value[value.length - 1] &&
+          'Z' === value[value.length - 1] &&
           parent[parentPropertyName] instanceof Date
         )
-          return "$D" + value;
+          return '$D' + value;
         if (1024 <= value.length) {
           if (0 >= counter.objectLimit)
             return serializeDeferredObject(request, value);
@@ -3189,39 +3189,39 @@
           emitTextChunk(request, counter, value, !0);
           return serializeByValueID(counter);
         }
-        return "$" === value[0] ? "$" + value : value;
+        return '$' === value[0] ? '$' + value : value;
       }
-      if ("boolean" === typeof value) return value;
-      if ("number" === typeof value) return serializeNumber(value);
-      if ("undefined" === typeof value) return "$undefined";
-      if ("function" === typeof value) {
+      if ('boolean' === typeof value) return value;
+      if ('number' === typeof value) return serializeNumber(value);
+      if ('undefined' === typeof value) return '$undefined';
+      if ('function' === typeof value) {
         if (isClientReference(value))
           return serializeDebugClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (
           void 0 !== request.temporaryReferences &&
           ((counter = request.temporaryReferences.get(value)),
           void 0 !== counter)
         )
-          return "$T" + counter;
+          return '$T' + counter;
         counter = request.writtenDebugObjects;
         ref = counter.get(value);
         if (void 0 !== ref) return ref;
         ref = Function.prototype.toString.call(value);
         key = value.name;
         key =
-          "$E" +
-          ("string" === typeof key
-            ? "Object.defineProperty(" +
+          '$E' +
+          ('string' === typeof key
+            ? 'Object.defineProperty(' +
               ref +
               ',"name",{value:' +
               JSON.stringify(key) +
-              "})"
-            : "(" + ref + ")");
+              '})'
+            : '(' + ref + ')');
         request.pendingDebugChunks++;
         ref = request.nextChunkId++;
         key = encodeReferenceChunk(request, ref, key);
@@ -3230,7 +3230,7 @@
         counter.set(value, request);
         return request;
       }
-      if ("symbol" === typeof value) {
+      if ('symbol' === typeof value) {
         counter = request.writtenSymbols.get(value);
         if (void 0 !== counter) return serializeByValueID(counter);
         value = value.description;
@@ -3239,11 +3239,11 @@
         emitSymbolChunk(request, counter, value);
         return serializeByValueID(counter);
       }
-      return "bigint" === typeof value
-        ? "$n" + value.toString(10)
+      return 'bigint' === typeof value
+        ? '$n' + value.toString(10)
         : value instanceof Date
-          ? "$D" + value.toJSON()
-          : "unknown type " + typeof value;
+          ? '$D' + value.toJSON()
+          : 'unknown type ' + typeof value;
     }
     function serializeDebugModel(request, objectLimit, model) {
       function replacer(parentPropertyName, value) {
@@ -3253,11 +3253,11 @@
             counter,
             this,
             parentPropertyName,
-            value
+            value,
           );
         } catch (x) {
           return (
-            "Unknown Value: React could not send it from the server.\n" +
+            'Unknown Value: React could not send it from the server.\n' +
             x.message
           );
         }
@@ -3269,8 +3269,8 @@
         return stringify(model, replacer);
       } catch (x) {
         return stringify(
-          "Unknown Value: React could not send it from the server.\n" +
-            x.message
+          'Unknown Value: React could not send it from the server.\n' +
+            x.message,
         );
       } finally {
         debugNoOutline = objectLimit;
@@ -3284,32 +3284,32 @@
             counter,
             this,
             parentPropertyName,
-            value
+            value,
           );
         } catch (x) {
           return (
-            "Unknown Value: React could not send it from the server.\n" +
+            'Unknown Value: React could not send it from the server.\n' +
             x.message
           );
         }
       }
-      "object" === typeof model && null !== model && doNotLimit.add(model);
+      'object' === typeof model && null !== model && doNotLimit.add(model);
       var prevModelRoot = debugModelRoot;
       debugModelRoot = model;
-      "object" === typeof model &&
+      'object' === typeof model &&
         null !== model &&
         request.writtenDebugObjects.set(model, serializeByValueID(id));
       try {
         var json = stringify(model, replacer);
       } catch (x) {
         json = stringify(
-          "Unknown Value: React could not send it from the server.\n" +
-            x.message
+          'Unknown Value: React could not send it from the server.\n' +
+            x.message,
         );
       } finally {
         debugModelRoot = prevModelRoot;
       }
-      id = id.toString(16) + ":" + json + "\n";
+      id = id.toString(16) + ':' + json + '\n';
       id = stringToChunk(id);
       request.completedDebugChunks.push(id);
     }
@@ -3321,15 +3321,15 @@
     }
     function emitTimeOriginChunk(request, timeOrigin) {
       request.pendingDebugChunks++;
-      timeOrigin = stringToChunk(":N" + timeOrigin + "\n");
+      timeOrigin = stringToChunk(':N' + timeOrigin + '\n');
       request.completedDebugChunks.push(timeOrigin);
     }
     function forwardDebugInfo(request$jscomp$1, task, debugInfo) {
       for (var id = task.id, i = 0; i < debugInfo.length; i++) {
         var info = debugInfo[i];
-        if ("number" === typeof info.time)
+        if ('number' === typeof info.time)
           markOperationEndTime(request$jscomp$1, task, info.time);
-        else if ("string" === typeof info.name)
+        else if ('string' === typeof info.name)
           outlineComponentInfo(request$jscomp$1, info),
             request$jscomp$1.pendingChunks++,
             emitDebugChunk(request$jscomp$1, id, info);
@@ -3348,7 +3348,7 @@
                 null != ioInfo$jscomp$0.debugStack
                   ? filterStackTrace(
                       request,
-                      parseStackTrace(ioInfo$jscomp$0.debugStack, 1)
+                      parseStackTrace(ioInfo$jscomp$0.debugStack, 1),
                     )
                   : ioInfo$jscomp$0.stack;
               var request$jscomp$0 = request,
@@ -3360,7 +3360,7 @@
               var debugIOInfo = {
                 name: ioInfo$jscomp$0.name,
                 start: ioInfo$jscomp$0.start - request$jscomp$0.timeOrigin,
-                end: ioInfo$jscomp$0.end - request$jscomp$0.timeOrigin
+                end: ioInfo$jscomp$0.end - request$jscomp$0.timeOrigin,
               };
               null != env && (debugIOInfo.env = env);
               null != debugStack && (debugIOInfo.stack = debugStack);
@@ -3369,14 +3369,14 @@
               value = serializeDebugModel(
                 request$jscomp$0,
                 objectLimit,
-                debugIOInfo
+                debugIOInfo,
               );
-              id$jscomp$1 = id$jscomp$1.toString(16) + ":J" + value + "\n";
+              id$jscomp$1 = id$jscomp$1.toString(16) + ':J' + value + '\n';
               id$jscomp$1 = stringToChunk(id$jscomp$1);
               request$jscomp$0.completedDebugChunks.push(id$jscomp$1);
               request.writtenDebugObjects.set(
                 ioInfo$jscomp$0,
-                serializeByValueID(id$jscomp$0)
+                serializeByValueID(id$jscomp$0),
               );
             }
             null != info.owner &&
@@ -3385,7 +3385,7 @@
               null == info.stack && null != info.debugStack
                 ? filterStackTrace(
                     request$jscomp$1,
-                    parseStackTrace(info.debugStack, 1)
+                    parseStackTrace(info.debugStack, 1),
                   )
                 : info.stack;
             ioInfo = { awaited: ioInfo };
@@ -3410,22 +3410,22 @@
     }
     function forwardDebugInfoFromAbortedTask(request, task) {
       var model = task.model;
-      "object" === typeof model &&
+      'object' === typeof model &&
         null !== model &&
         (model = model._debugInfo) &&
         forwardDebugInfo(request, task, model);
     }
     function emitTimingChunk(request, id, timestamp) {
       request.pendingChunks++;
-      var json = '{"time":' + (timestamp - request.timeOrigin) + "}";
+      var json = '{"time":' + (timestamp - request.timeOrigin) + '}';
       null !== request.debugDestination
         ? ((timestamp = request.nextChunkId++),
-          (json = timestamp.toString(16) + ":" + json + "\n"),
+          (json = timestamp.toString(16) + ':' + json + '\n'),
           request.pendingDebugChunks++,
           request.completedDebugChunks.push(stringToChunk(json)),
           (id = id.toString(16) + ':D"$' + timestamp.toString(16) + '"\n'),
           request.completedRegularChunks.push(stringToChunk(id)))
-        : ((id = id.toString(16) + ":D" + json + "\n"),
+        : ((id = id.toString(16) + ':D' + json + '\n'),
           request.completedRegularChunks.push(stringToChunk(id)));
     }
     function markOperationEndTime(request, task, timestamp) {
@@ -3437,45 +3437,45 @@
     }
     function emitChunk(request, task, value) {
       var id = task.id;
-      "string" === typeof value && null !== byteLengthOfChunk
+      'string' === typeof value && null !== byteLengthOfChunk
         ? emitTextChunk(request, id, value, !1)
         : value instanceof ArrayBuffer
-          ? emitTypedArrayChunk(request, id, "A", new Uint8Array(value), !1)
+          ? emitTypedArrayChunk(request, id, 'A', new Uint8Array(value), !1)
           : value instanceof Int8Array
-            ? emitTypedArrayChunk(request, id, "O", value, !1)
+            ? emitTypedArrayChunk(request, id, 'O', value, !1)
             : value instanceof Uint8Array
-              ? emitTypedArrayChunk(request, id, "o", value, !1)
+              ? emitTypedArrayChunk(request, id, 'o', value, !1)
               : value instanceof Uint8ClampedArray
-                ? emitTypedArrayChunk(request, id, "U", value, !1)
+                ? emitTypedArrayChunk(request, id, 'U', value, !1)
                 : value instanceof Int16Array
-                  ? emitTypedArrayChunk(request, id, "S", value, !1)
+                  ? emitTypedArrayChunk(request, id, 'S', value, !1)
                   : value instanceof Uint16Array
-                    ? emitTypedArrayChunk(request, id, "s", value, !1)
+                    ? emitTypedArrayChunk(request, id, 's', value, !1)
                     : value instanceof Int32Array
-                      ? emitTypedArrayChunk(request, id, "L", value, !1)
+                      ? emitTypedArrayChunk(request, id, 'L', value, !1)
                       : value instanceof Uint32Array
-                        ? emitTypedArrayChunk(request, id, "l", value, !1)
+                        ? emitTypedArrayChunk(request, id, 'l', value, !1)
                         : value instanceof Float32Array
-                          ? emitTypedArrayChunk(request, id, "G", value, !1)
+                          ? emitTypedArrayChunk(request, id, 'G', value, !1)
                           : value instanceof Float64Array
-                            ? emitTypedArrayChunk(request, id, "g", value, !1)
+                            ? emitTypedArrayChunk(request, id, 'g', value, !1)
                             : value instanceof BigInt64Array
-                              ? emitTypedArrayChunk(request, id, "M", value, !1)
+                              ? emitTypedArrayChunk(request, id, 'M', value, !1)
                               : value instanceof BigUint64Array
                                 ? emitTypedArrayChunk(
                                     request,
                                     id,
-                                    "m",
+                                    'm',
                                     value,
-                                    !1
+                                    !1,
                                   )
                                 : value instanceof DataView
                                   ? emitTypedArrayChunk(
                                       request,
                                       id,
-                                      "V",
+                                      'V',
                                       value,
-                                      !1
+                                      !1,
                                     )
                                   : ((value = stringify(value, task.toJSON)),
                                     emitModelChunk(request, task.id, value));
@@ -3500,8 +3500,8 @@
             request,
             task,
             emptyRoot,
-            "",
-            task.model
+            '',
+            task.model,
           );
           canEmitDebugInfo = !1;
           modelRoot = resolvedModel;
@@ -3512,10 +3512,10 @@
             (request.pendingChunks++,
             emitDebugChunk(request, task.id, { env: currentEnv }));
           task.timed && markOperationEndTime(request, task, performance.now());
-          if ("object" === typeof resolvedModel && null !== resolvedModel)
+          if ('object' === typeof resolvedModel && null !== resolvedModel)
             request.writtenObjects.set(
               resolvedModel,
-              serializeByValueID(task.id)
+              serializeByValueID(task.id),
             ),
               emitChunk(request, task, resolvedModel);
           else {
@@ -3544,9 +3544,9 @@
                 ? getSuspendedThenable()
                 : thrownValue;
             if (
-              "object" === typeof x &&
+              'object' === typeof x &&
               null !== x &&
-              "function" === typeof x.then
+              'function' === typeof x.then
             ) {
               task.status = 0;
               task.thenableState = getThenableStateAfterSuspending();
@@ -3642,7 +3642,7 @@
               (request.pendingChunks--,
               !writeChunkAndReturn(
                 debugDestination,
-                importsChunks[debugChunks]
+                importsChunks[debugChunks],
               ))
             ) {
               request.destination = null;
@@ -3671,7 +3671,7 @@
                 (request.pendingDebugChunks--,
                 !writeChunkAndReturn(
                   debugDestination,
-                  _debugChunks[debugChunks]
+                  _debugChunks[debugChunks],
                 ))
               ) {
                 request.destination = null;
@@ -3690,7 +3690,7 @@
               (request.pendingChunks--,
               !writeChunkAndReturn(
                 debugDestination,
-                regularChunks[debugChunks]
+                regularChunks[debugChunks],
               ))
             ) {
               request.destination = null;
@@ -3721,8 +3721,8 @@
             request.status < ABORTING &&
               request.cacheController.abort(
                 Error(
-                  "This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources."
-                )
+                  'This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources.',
+                ),
               ),
             null !== request.destination &&
               ((request.status = CLOSED),
@@ -3820,13 +3820,13 @@
               var error =
                   void 0 === reason
                     ? Error(
-                        "The render was aborted by the server without a reason."
+                        'The render was aborted by the server without a reason.',
                       )
-                    : "object" === typeof reason &&
+                    : 'object' === typeof reason &&
                         null !== reason &&
-                        "function" === typeof reason.then
+                        'function' === typeof reason.then
                       ? Error(
-                          "The render was aborted by the server with a promise."
+                          'The render was aborted by the server with a promise.',
                         )
                       : reason,
                 digest = logRecoverableError(request, error, null),
@@ -3858,7 +3858,7 @@
       var deferredDebugObjects = request.deferredDebugObjects;
       if (null === deferredDebugObjects)
         throw Error(
-          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React."
+          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React.",
         );
       deferredDebugObjects.retained.forEach(function (value, id) {
         request.pendingDebugChunks--;
@@ -3868,11 +3868,11 @@
       enqueueFlush(request);
     }
     function resolveServerReference(bundlerConfig, id) {
-      var name = "",
+      var name = '',
         resolvedModuleData = bundlerConfig[id];
       if (resolvedModuleData) name = resolvedModuleData.name;
       else {
-        var idx = id.lastIndexOf("#");
+        var idx = id.lastIndexOf('#');
         -1 !== idx &&
           ((name = id.slice(idx + 1)),
           (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -3880,7 +3880,7 @@
           throw Error(
             'Could not find the module "' +
               id +
-              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
           );
       }
       return resolvedModuleData.async
@@ -3889,17 +3889,17 @@
     }
     function requireAsyncModule(id) {
       var promise = __webpack_require__(id);
-      if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+      if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
         return null;
       promise.then(
         function (value) {
-          promise.status = "fulfilled";
+          promise.status = 'fulfilled';
           promise.value = value;
         },
         function (reason) {
-          promise.status = "rejected";
+          promise.status = 'rejected';
           promise.reason = reason;
-        }
+        },
       );
       return promise;
     }
@@ -3933,13 +3933,13 @@
     }
     function requireModule(metadata) {
       var moduleExports = __webpack_require__(metadata[0]);
-      if (4 === metadata.length && "function" === typeof moduleExports.then)
-        if ("fulfilled" === moduleExports.status)
+      if (4 === metadata.length && 'function' === typeof moduleExports.then)
+        if ('fulfilled' === moduleExports.status)
           moduleExports = moduleExports.value;
         else throw moduleExports.reason;
-      return "*" === metadata[2]
+      return '*' === metadata[2]
         ? moduleExports
-        : "" === metadata[2]
+        : '' === metadata[2]
           ? moduleExports.__esModule
             ? moduleExports.default
             : moduleExports
@@ -3952,41 +3952,41 @@
       this._response = response;
     }
     function createPendingChunk(response) {
-      return new Chunk("pending", null, null, response);
+      return new Chunk('pending', null, null, response);
     }
     function wakeChunk(listeners, value) {
       for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
     }
     function triggerErrorOnChunk(chunk, error) {
-      if ("pending" !== chunk.status && "blocked" !== chunk.status)
+      if ('pending' !== chunk.status && 'blocked' !== chunk.status)
         chunk.reason.error(error);
       else {
         var listeners = chunk.reason;
-        chunk.status = "rejected";
+        chunk.status = 'rejected';
         chunk.reason = error;
         null !== listeners && wakeChunk(listeners, error);
       }
     }
     function resolveModelChunk(chunk, value, id) {
-      if ("pending" !== chunk.status)
+      if ('pending' !== chunk.status)
         (chunk = chunk.reason),
-          "C" === value[0]
-            ? chunk.close("C" === value ? '"$undefined"' : value.slice(1))
+          'C' === value[0]
+            ? chunk.close('C' === value ? '"$undefined"' : value.slice(1))
             : chunk.enqueueModel(value);
       else {
         var resolveListeners = chunk.value,
           rejectListeners = chunk.reason;
-        chunk.status = "resolved_model";
+        chunk.status = 'resolved_model';
         chunk.value = value;
         chunk.reason = id;
         if (null !== resolveListeners)
           switch ((initializeModelChunk(chunk), chunk.status)) {
-            case "fulfilled":
+            case 'fulfilled':
               wakeChunk(resolveListeners, chunk.value);
               break;
-            case "pending":
-            case "blocked":
-            case "cyclic":
+            case 'pending':
+            case 'blocked':
+            case 'cyclic':
               if (chunk.value)
                 for (value = 0; value < resolveListeners.length; value++)
                   chunk.value.push(resolveListeners[value]);
@@ -3997,19 +3997,19 @@
                     chunk.reason.push(rejectListeners[value]);
               } else chunk.reason = rejectListeners;
               break;
-            case "rejected":
+            case 'rejected':
               rejectListeners && wakeChunk(rejectListeners, chunk.reason);
           }
       }
     }
     function createResolvedIteratorResultChunk(response, value, done) {
       return new Chunk(
-        "resolved_model",
+        'resolved_model',
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
+          '}',
         -1,
-        response
+        response,
       );
     }
     function resolveIteratorResultChunk(chunk, value, done) {
@@ -4017,8 +4017,8 @@
         chunk,
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
-        -1
+          '}',
+        -1,
       );
     }
     function loadServerReference$1(
@@ -4027,7 +4027,7 @@
       bound,
       parentChunk,
       parentObject,
-      key
+      key,
     ) {
       var serverReference = resolveServerReference(response._bundlerConfig, id);
       id = preloadModule(serverReference);
@@ -4050,22 +4050,22 @@
           !1,
           response,
           createModel,
-          []
+          [],
         ),
-        createModelReject(parentChunk)
+        createModelReject(parentChunk),
       );
       return null;
     }
     function reviveModel(response, parentObj, parentKey, value, reference) {
-      if ("string" === typeof value)
+      if ('string' === typeof value)
         return parseModelString(
           response,
           parentObj,
           parentKey,
           value,
-          reference
+          reference,
         );
-      if ("object" === typeof value && null !== value)
+      if ('object' === typeof value && null !== value)
         if (
           (void 0 !== reference &&
             void 0 !== response._temporaryReferences &&
@@ -4076,23 +4076,23 @@
             value[i] = reviveModel(
               response,
               value,
-              "" + i,
+              '' + i,
               value[i],
-              void 0 !== reference ? reference + ":" + i : void 0
+              void 0 !== reference ? reference + ':' + i : void 0,
             );
         else
           for (i in value)
             hasOwnProperty.call(value, i) &&
               ((parentObj =
-                void 0 !== reference && -1 === i.indexOf(":")
-                  ? reference + ":" + i
+                void 0 !== reference && -1 === i.indexOf(':')
+                  ? reference + ':' + i
                   : void 0),
               (parentObj = reviveModel(
                 response,
                 value,
                 i,
                 value[i],
-                parentObj
+                parentObj,
               )),
               void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);
       return value;
@@ -4105,32 +4105,32 @@
       var rootReference =
           -1 === chunk.reason ? void 0 : chunk.reason.toString(16),
         resolvedModel = chunk.value;
-      chunk.status = "cyclic";
+      chunk.status = 'cyclic';
       chunk.value = null;
       chunk.reason = null;
       try {
         var rawModel = JSON.parse(resolvedModel),
           value = reviveModel(
             chunk._response,
-            { "": rawModel },
-            "",
+            { '': rawModel },
+            '',
             rawModel,
-            rootReference
+            rootReference,
           );
         if (
           null !== initializingChunkBlockedModel &&
           0 < initializingChunkBlockedModel.deps
         )
           (initializingChunkBlockedModel.value = value),
-            (chunk.status = "blocked");
+            (chunk.status = 'blocked');
         else {
           var resolveListeners = chunk.value;
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = value;
           null !== resolveListeners && wakeChunk(resolveListeners, value);
         }
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       } finally {
         (initializingChunk = prevChunk),
           (initializingChunkBlockedModel = prevBlocked);
@@ -4140,7 +4140,7 @@
       response._closed = !0;
       response._closedReason = error;
       response._chunks.forEach(function (chunk) {
-        "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+        'pending' === chunk.status && triggerErrorOnChunk(chunk, error);
       });
     }
     function getChunk(response, id) {
@@ -4150,9 +4150,9 @@
         ((chunk = response._formData.get(response._prefix + id)),
         (chunk =
           null != chunk
-            ? new Chunk("resolved_model", chunk, id, response)
+            ? new Chunk('resolved_model', chunk, id, response)
             : response._closed
-              ? new Chunk("rejected", null, response._closedReason, response)
+              ? new Chunk('rejected', null, response._closedReason, response)
               : createPendingChunk(response)),
         chunks.set(id, chunk));
       return chunk;
@@ -4164,7 +4164,7 @@
       cyclic,
       response,
       map,
-      path
+      path,
     ) {
       if (initializingChunkBlockedModel) {
         var blocked = initializingChunkBlockedModel;
@@ -4172,19 +4172,19 @@
       } else
         blocked = initializingChunkBlockedModel = {
           deps: cyclic ? 0 : 1,
-          value: null
+          value: null,
         };
       return function (value) {
         for (var i = 1; i < path.length; i++) value = value[path[i]];
         parentObject[key] = map(response, value);
-        "" === key &&
+        '' === key &&
           null === blocked.value &&
           (blocked.value = parentObject[key]);
         blocked.deps--;
         0 === blocked.deps &&
-          "blocked" === chunk.status &&
+          'blocked' === chunk.status &&
           ((value = chunk.value),
-          (chunk.status = "fulfilled"),
+          (chunk.status = 'fulfilled'),
           (chunk.value = blocked.value),
           null !== value && wakeChunk(value, blocked.value));
       };
@@ -4195,34 +4195,34 @@
       };
     }
     function getOutlinedModel(response, reference, parentObject, key, map) {
-      reference = reference.split(":");
+      reference = reference.split(':');
       var id = parseInt(reference[0], 16);
       id = getChunk(response, id);
       switch (id.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(id);
       }
       switch (id.status) {
-        case "fulfilled":
+        case 'fulfilled':
           parentObject = id.value;
           for (key = 1; key < reference.length; key++)
             parentObject = parentObject[reference[key]];
           return map(response, parentObject);
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           var parentChunk = initializingChunk;
           id.then(
             createModelResolver(
               parentChunk,
               parentObject,
               key,
-              "cyclic" === id.status,
+              'cyclic' === id.status,
               response,
               map,
-              reference
+              reference,
             ),
-            createModelReject(parentChunk)
+            createModelReject(parentChunk),
           );
           return null;
         default:
@@ -4247,7 +4247,7 @@
       constructor,
       bytesPerElement,
       parentObject,
-      parentKey
+      parentKey,
     ) {
       reference = parseInt(reference.slice(2), 16);
       reference = response._formData.get(response._prefix + reference);
@@ -4266,22 +4266,22 @@
           !1,
           response,
           createModel,
-          []
+          [],
         ),
-        createModelReject(bytesPerElement)
+        createModelReject(bytesPerElement),
       );
       return null;
     }
     function resolveStream(response, id, stream, controller) {
       var chunks = response._chunks;
-      stream = new Chunk("fulfilled", stream, controller, response);
+      stream = new Chunk('fulfilled', stream, controller, response);
       chunks.set(id, stream);
       response = response._formData.getAll(response._prefix + id);
       for (id = 0; id < response.length; id++)
         (chunks = response[id]),
-          "C" === chunks[0]
+          'C' === chunks[0]
             ? controller.close(
-                "C" === chunks ? '"$undefined"' : chunks.slice(1)
+                'C' === chunks ? '"$undefined"' : chunks.slice(1),
               )
             : controller.enqueueModel(chunks);
     }
@@ -4292,15 +4292,15 @@
         type: type,
         start: function (c) {
           controller = c;
-        }
+        },
       });
       var previousBlockedChunk = null;
       resolveStream(response, reference, type, {
         enqueueModel: function (json) {
           if (null === previousBlockedChunk) {
-            var chunk = new Chunk("resolved_model", json, -1, response);
+            var chunk = new Chunk('resolved_model', json, -1, response);
             initializeModelChunk(chunk);
-            "fulfilled" === chunk.status
+            'fulfilled' === chunk.status
               ? controller.enqueue(chunk.value)
               : (chunk.then(
                   function (v) {
@@ -4308,7 +4308,7 @@
                   },
                   function (e) {
                     return controller.error(e);
-                  }
+                  },
                 ),
                 (previousBlockedChunk = chunk));
           } else {
@@ -4320,7 +4320,7 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             );
             previousBlockedChunk = _chunk;
             chunk.then(function () {
@@ -4348,7 +4348,7 @@
               return controller.error(error);
             });
           }
-        }
+        },
       });
       return type;
     }
@@ -4370,15 +4370,15 @@
           return createIterator(function (arg) {
             if (void 0 !== arg)
               throw Error(
-                "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+                'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
               );
             if (nextReadIndex === buffer.length) {
               if (closed)
                 return new Chunk(
-                  "fulfilled",
+                  'fulfilled',
                   { done: !0, value: void 0 },
                   null,
-                  response
+                  response,
                 );
               buffer[nextReadIndex] = createPendingChunk(response);
             }
@@ -4392,7 +4392,7 @@
             ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                 response,
                 value,
-                !1
+                !1,
               ))
             : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
           nextWriteIndex++;
@@ -4403,14 +4403,14 @@
             ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                 response,
                 value,
-                !0
+                !0,
               ))
             : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
           for (nextWriteIndex++; nextWriteIndex < buffer.length; )
             resolveIteratorResultChunk(
               buffer[nextWriteIndex++],
               '"$undefined"',
-              !0
+              !0,
             );
         },
         error: function (error) {
@@ -4422,20 +4422,20 @@
 
           )
             triggerErrorOnChunk(buffer[nextWriteIndex++], error);
-        }
+        },
       });
       return iterator;
     }
     function parseModelString(response, obj, key, value, reference) {
-      if ("$" === value[0]) {
+      if ('$' === value[0]) {
         switch (value[1]) {
-          case "$":
+          case '$':
             return value.slice(1);
-          case "@":
+          case '@':
             return (
               (obj = parseInt(value.slice(2), 16)), getChunk(response, obj)
             );
-          case "F":
+          case 'F':
             return (
               (value = value.slice(2)),
               (value = getOutlinedModel(
@@ -4443,7 +4443,7 @@
                 value,
                 obj,
                 key,
-                createModel
+                createModel,
               )),
               loadServerReference$1(
                 response,
@@ -4451,113 +4451,113 @@
                 value.bound,
                 initializingChunk,
                 obj,
-                key
+                key,
               )
             );
-          case "T":
+          case 'T':
             if (
               void 0 === reference ||
               void 0 === response._temporaryReferences
             )
               throw Error(
-                "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+                'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
               );
             return createTemporaryReference(
               response._temporaryReferences,
-              reference
+              reference,
             );
-          case "Q":
+          case 'Q':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, createMap)
             );
-          case "W":
+          case 'W':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, createSet)
             );
-          case "K":
+          case 'K':
             obj = value.slice(2);
-            var formPrefix = response._prefix + obj + "_",
+            var formPrefix = response._prefix + obj + '_',
               data = new FormData();
             response._formData.forEach(function (entry, entryKey) {
               entryKey.startsWith(formPrefix) &&
                 data.append(entryKey.slice(formPrefix.length), entry);
             });
             return data;
-          case "i":
+          case 'i':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, extractIterator)
             );
-          case "I":
+          case 'I':
             return Infinity;
-          case "-":
-            return "$-0" === value ? -0 : -Infinity;
-          case "N":
+          case '-':
+            return '$-0' === value ? -0 : -Infinity;
+          case 'N':
             return NaN;
-          case "u":
+          case 'u':
             return;
-          case "D":
+          case 'D':
             return new Date(Date.parse(value.slice(2)));
-          case "n":
+          case 'n':
             return BigInt(value.slice(2));
         }
         switch (value[1]) {
-          case "A":
+          case 'A':
             return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);
-          case "O":
+          case 'O':
             return parseTypedArray(response, value, Int8Array, 1, obj, key);
-          case "o":
+          case 'o':
             return parseTypedArray(response, value, Uint8Array, 1, obj, key);
-          case "U":
+          case 'U':
             return parseTypedArray(
               response,
               value,
               Uint8ClampedArray,
               1,
               obj,
-              key
+              key,
             );
-          case "S":
+          case 'S':
             return parseTypedArray(response, value, Int16Array, 2, obj, key);
-          case "s":
+          case 's':
             return parseTypedArray(response, value, Uint16Array, 2, obj, key);
-          case "L":
+          case 'L':
             return parseTypedArray(response, value, Int32Array, 4, obj, key);
-          case "l":
+          case 'l':
             return parseTypedArray(response, value, Uint32Array, 4, obj, key);
-          case "G":
+          case 'G':
             return parseTypedArray(response, value, Float32Array, 4, obj, key);
-          case "g":
+          case 'g':
             return parseTypedArray(response, value, Float64Array, 8, obj, key);
-          case "M":
+          case 'M':
             return parseTypedArray(response, value, BigInt64Array, 8, obj, key);
-          case "m":
+          case 'm':
             return parseTypedArray(
               response,
               value,
               BigUint64Array,
               8,
               obj,
-              key
+              key,
             );
-          case "V":
+          case 'V':
             return parseTypedArray(response, value, DataView, 1, obj, key);
-          case "B":
+          case 'B':
             return (
               (obj = parseInt(value.slice(2), 16)),
               response._formData.get(response._prefix + obj)
             );
         }
         switch (value[1]) {
-          case "R":
+          case 'R':
             return parseReadableStream(response, value, void 0);
-          case "r":
-            return parseReadableStream(response, value, "bytes");
-          case "X":
+          case 'r':
+            return parseReadableStream(response, value, 'bytes');
+          case 'X':
             return parseAsyncIterable(response, value, !1);
-          case "x":
+          case 'x':
             return parseAsyncIterable(response, value, !0);
         }
         value = value.slice(1);
@@ -4568,7 +4568,7 @@
     function createResponse(
       bundlerConfig,
       formFieldPrefix,
-      temporaryReferences
+      temporaryReferences,
     ) {
       var backingFormData =
           3 < arguments.length && void 0 !== arguments[3]
@@ -4582,11 +4582,11 @@
         _chunks: chunks,
         _closed: !1,
         _closedReason: null,
-        _temporaryReferences: temporaryReferences
+        _temporaryReferences: temporaryReferences,
       };
     }
     function close(response) {
-      reportGlobalError(response, Error("Connection closed."));
+      reportGlobalError(response, Error('Connection closed.'));
     }
     function loadServerReference(bundlerConfig, id, bound) {
       var serverReference = resolveServerReference(bundlerConfig, id);
@@ -4608,12 +4608,12 @@
       close(body);
       body = getChunk(body, 0);
       body.then(function () {});
-      if ("fulfilled" !== body.status) throw body.reason;
+      if ('fulfilled' !== body.status) throw body.reason;
       return body.value;
     }
     function startReadingFromDebugChannelReadableStream(
       request$jscomp$0,
-      stream
+      stream,
     ) {
       function progress(_ref) {
         var done = _ref.done,
@@ -4624,19 +4624,19 @@
             (buffer = stringDecoder.decode(buffer)))
           : (buffer = stringDecoder.decode(buffer, decoderOptions));
         stringBuffer = _ref + buffer;
-        _ref = stringBuffer.split("\n");
+        _ref = stringBuffer.split('\n');
         for (buffer = 0; buffer < _ref.length - 1; buffer++) {
           var request = request$jscomp$0,
             message = _ref[buffer],
             deferredDebugObjects = request.deferredDebugObjects;
           if (null === deferredDebugObjects)
             throw Error(
-              "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React."
+              "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React.",
             );
-          if ("" === message) closeDebugChannel(request);
+          if ('' === message) closeDebugChannel(request);
           else {
             var command = message.charCodeAt(0);
-            message = message.slice(2).split(",").map(fromHex);
+            message = message.slice(2).split(',').map(fromHex);
             switch (command) {
               case 82:
                 for (command = 0; command < message.length; command++) {
@@ -4660,7 +4660,7 @@
                         request,
                         id,
                         { objectLimit: 10 },
-                        retainedValue
+                        retainedValue,
                       ),
                       enqueueFlush(request));
                 break;
@@ -4674,12 +4674,12 @@
                         request,
                         id,
                         { objectLimit: 10 },
-                        retainedValue
+                        retainedValue,
                       ));
                 break;
               default:
                 throw Error(
-                  "Unknown command. The debugChannel was not wired up properly."
+                  'Unknown command. The debugChannel was not wired up properly.',
                 );
             }
           }
@@ -4691,32 +4691,32 @@
       function error(e) {
         abort(
           request$jscomp$0,
-          Error("Lost connection to the Debug Channel.", { cause: e })
+          Error('Lost connection to the Debug Channel.', { cause: e }),
         );
       }
       var reader = stream.getReader(),
         stringDecoder = new TextDecoder(),
-        stringBuffer = "";
+        stringBuffer = '';
       reader.read().then(progress).catch(error);
     }
-    var ReactDOM = require("react-dom"),
-      React = require("react"),
-      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-    Symbol.for("react.postpone");
+    var ReactDOM = require('react-dom'),
+      React = require('react'),
+      REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element'),
+      REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+      REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+      REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+      REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+      REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+      REACT_MEMO_TYPE = Symbol.for('react.memo'),
+      REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+      REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
+    Symbol.for('react.postpone');
     var MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
       ASYNC_ITERATOR = Symbol.asyncIterator,
       LocalPromise = Promise,
       scheduleMicrotask =
-        "function" === typeof queueMicrotask
+        'function' === typeof queueMicrotask
           ? queueMicrotask
           : function (callback) {
               LocalPromise.resolve(null)
@@ -4726,52 +4726,52 @@
       currentView = null,
       writtenBytes = 0,
       textEncoder = new TextEncoder(),
-      CLIENT_REFERENCE_TAG$1 = Symbol.for("react.client.reference"),
-      SERVER_REFERENCE_TAG = Symbol.for("react.server.reference"),
+      CLIENT_REFERENCE_TAG$1 = Symbol.for('react.client.reference'),
+      SERVER_REFERENCE_TAG = Symbol.for('react.server.reference'),
       FunctionBind = Function.prototype.bind,
       ArraySlice = Array.prototype.slice,
       PROMISE_PROTOTYPE = Promise.prototype,
       deepProxyHandlers = {
         get: function (target, name) {
           switch (name) {
-            case "$$typeof":
+            case '$$typeof':
               return target.$$typeof;
-            case "$$id":
+            case '$$id':
               return target.$$id;
-            case "$$async":
+            case '$$async':
               return target.$$async;
-            case "name":
+            case 'name':
               return target.name;
-            case "displayName":
+            case 'displayName':
               return;
-            case "defaultProps":
+            case 'defaultProps':
               return;
-            case "_debugInfo":
+            case '_debugInfo':
               return;
-            case "toJSON":
+            case 'toJSON':
               return;
             case Symbol.toPrimitive:
               return Object.prototype[Symbol.toPrimitive];
             case Symbol.toStringTag:
               return Object.prototype[Symbol.toStringTag];
-            case "Provider":
+            case 'Provider':
               throw Error(
-                "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+                'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
               );
-            case "then":
+            case 'then':
               throw Error(
-                "Cannot await or return from a thenable. You cannot await a client module from a server component."
+                'Cannot await or return from a thenable. You cannot await a client module from a server component.',
               );
           }
           throw Error(
-            "Cannot access " +
-              (String(target.name) + "." + String(name)) +
-              " on the server. You cannot dot into a client module from a server component. You can only pass the imported name through."
+            'Cannot access ' +
+              (String(target.name) + '.' + String(name)) +
+              ' on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.',
           );
         },
         set: function () {
-          throw Error("Cannot assign to a client module from a server module.");
-        }
+          throw Error('Cannot assign to a client module from a server module.');
+        },
       },
       proxyHandlers$1 = {
         get: function (target, name) {
@@ -4784,7 +4784,7 @@
               value: getReference(target, name),
               writable: !1,
               configurable: !1,
-              enumerable: !1
+              enumerable: !1,
             }),
             Object.defineProperty(target, name, descriptor));
           return descriptor;
@@ -4793,8 +4793,8 @@
           return PROMISE_PROTOTYPE;
         },
         set: function () {
-          throw Error("Cannot assign to a client module from a server module.");
-        }
+          throw Error('Cannot assign to a client module from a server module.');
+        },
       },
       ReactDOMSharedInternals =
         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
@@ -4803,86 +4803,86 @@
       f: previousDispatcher.f,
       r: previousDispatcher.r,
       D: function (href) {
-        if ("string" === typeof href && href) {
+        if ('string' === typeof href && href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "D|" + href;
-            hints.has(key) || (hints.add(key), emitHint(request, "D", href));
+              key = 'D|' + href;
+            hints.has(key) || (hints.add(key), emitHint(request, 'D', href));
           } else previousDispatcher.D(href);
         }
       },
       C: function (href, crossOrigin) {
-        if ("string" === typeof href) {
+        if ('string' === typeof href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
               key =
-                "C|" +
-                (null == crossOrigin ? "null" : crossOrigin) +
-                "|" +
+                'C|' +
+                (null == crossOrigin ? 'null' : crossOrigin) +
+                '|' +
                 href;
             hints.has(key) ||
               (hints.add(key),
-              "string" === typeof crossOrigin
-                ? emitHint(request, "C", [href, crossOrigin])
-                : emitHint(request, "C", href));
+              'string' === typeof crossOrigin
+                ? emitHint(request, 'C', [href, crossOrigin])
+                : emitHint(request, 'C', href));
           } else previousDispatcher.C(href, crossOrigin);
         }
       },
       L: preload,
       m: preloadModule$1,
       X: function (src, options) {
-        if ("string" === typeof src) {
+        if ('string' === typeof src) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "X|" + src;
+              key = 'X|' + src;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "X", [src, options])
-              : emitHint(request, "X", src);
+              ? emitHint(request, 'X', [src, options])
+              : emitHint(request, 'X', src);
           }
           previousDispatcher.X(src, options);
         }
       },
       S: function (href, precedence, options) {
-        if ("string" === typeof href) {
+        if ('string' === typeof href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "S|" + href;
+              key = 'S|' + href;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "S", [
+              ? emitHint(request, 'S', [
                   href,
-                  "string" === typeof precedence ? precedence : 0,
-                  options
+                  'string' === typeof precedence ? precedence : 0,
+                  options,
                 ])
-              : "string" === typeof precedence
-                ? emitHint(request, "S", [href, precedence])
-                : emitHint(request, "S", href);
+              : 'string' === typeof precedence
+                ? emitHint(request, 'S', [href, precedence])
+                : emitHint(request, 'S', href);
           }
           previousDispatcher.S(href, precedence, options);
         }
       },
       M: function (src, options) {
-        if ("string" === typeof src) {
+        if ('string' === typeof src) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "M|" + src;
+              key = 'M|' + src;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "M", [src, options])
-              : emitHint(request, "M", src);
+              ? emitHint(request, 'M', [src, options])
+              : emitHint(request, 'M', src);
           }
           previousDispatcher.M(src, options);
         }
-      }
+      },
     };
     var framesToSkip = 0,
       collectedStackTrace = null,
@@ -4890,53 +4890,53 @@
       frameRegExp =
         /^ {3} at (?:(.+) \((?:(.+):(\d+):(\d+)|<anonymous>)\)|(?:async )?(.+):(\d+):(\d+)|<anonymous>)$/,
       stackTraceCache = new WeakMap(),
-      supportsRequestStorage = "function" === typeof AsyncLocalStorage,
+      supportsRequestStorage = 'function' === typeof AsyncLocalStorage,
       requestStorage = supportsRequestStorage ? new AsyncLocalStorage() : null,
       supportsComponentStorage = supportsRequestStorage,
       componentStorage = supportsComponentStorage
         ? new AsyncLocalStorage()
         : null,
-      TEMPORARY_REFERENCE_TAG = Symbol.for("react.temporary.reference"),
+      TEMPORARY_REFERENCE_TAG = Symbol.for('react.temporary.reference'),
       proxyHandlers = {
         get: function (target, name) {
           switch (name) {
-            case "$$typeof":
+            case '$$typeof':
               return target.$$typeof;
-            case "name":
+            case 'name':
               return;
-            case "displayName":
+            case 'displayName':
               return;
-            case "defaultProps":
+            case 'defaultProps':
               return;
-            case "_debugInfo":
+            case '_debugInfo':
               return;
-            case "toJSON":
+            case 'toJSON':
               return;
             case Symbol.toPrimitive:
               return Object.prototype[Symbol.toPrimitive];
             case Symbol.toStringTag:
               return Object.prototype[Symbol.toStringTag];
-            case "Provider":
+            case 'Provider':
               throw Error(
-                "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+                'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
               );
-            case "then":
+            case 'then':
               return;
           }
           throw Error(
-            "Cannot access " +
+            'Cannot access ' +
               String(name) +
-              " on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client."
+              ' on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client.',
           );
         },
         set: function () {
           throw Error(
-            "Cannot assign to a temporary client reference from a server module."
+            'Cannot assign to a temporary client reference from a server module.',
           );
-        }
+        },
       },
       SuspenseException = Error(
-        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
+        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.",
       ),
       suspendedThenable = null,
       currentRequest$1 = null,
@@ -4947,10 +4947,10 @@
         readContext: unsupportedContext,
         use: function (usable) {
           if (
-            (null !== usable && "object" === typeof usable) ||
-            "function" === typeof usable
+            (null !== usable && 'object' === typeof usable) ||
+            'function' === typeof usable
           ) {
-            if ("function" === typeof usable.then) {
+            if ('function' === typeof usable.then) {
               var index = thenableIndexCounter;
               thenableIndexCounter += 1;
               null === thenableState && (thenableState = []);
@@ -4964,12 +4964,12 @@
               usable.value.$$typeof === REACT_CONTEXT_TYPE
             )
               throw Error(
-                "Cannot read a Client Context from a Server Component."
+                'Cannot read a Client Context from a Server Component.',
               );
-            throw Error("Cannot use() an already resolved Client Reference.");
+            throw Error('Cannot use() an already resolved Client Reference.');
           }
           throw Error(
-            "An unsupported type was passed to use(): " + String(usable)
+            'An unsupported type was passed to use(): ' + String(usable),
           );
         },
         useCallback: function (callback) {
@@ -4992,14 +4992,14 @@
         useSyncExternalStore: unsupportedHook,
         useId: function () {
           if (null === currentRequest$1)
-            throw Error("useId can only be used while React is rendering");
+            throw Error('useId can only be used while React is rendering');
           var id = currentRequest$1.identifierCount++;
           return (
-            "_" +
+            '_' +
             currentRequest$1.identifierPrefix +
-            "S_" +
+            'S_' +
             id.toString(32) +
-            "_"
+            '_'
           );
         },
         useHostTransitionStatus: unsupportedHook,
@@ -5013,7 +5013,7 @@
         },
         useCacheRefresh: function () {
           return unsupportedRefresh;
-        }
+        },
       };
     HooksDispatcher.useEffectEvent = unsupportedHook;
     var currentOwner = null,
@@ -5028,21 +5028,21 @@
         cacheSignal: function () {
           var request = resolveRequest();
           return request ? request.cacheController.signal : null;
-        }
+        },
       };
     DefaultAsyncDispatcher.getOwner = resolveOwner;
     var ReactSharedInternalsServer =
       React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
     if (!ReactSharedInternalsServer)
       throw Error(
-        'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
+        'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.',
       );
     var prefix, suffix;
-    new ("function" === typeof WeakMap ? WeakMap : Map)();
+    new ('function' === typeof WeakMap ? WeakMap : Map)();
     var lastResetTime = 0;
     if (
-      "object" === typeof performance &&
-      "function" === typeof performance.now
+      'object' === typeof performance &&
+      'function' === typeof performance.now
     ) {
       var localPerformance = performance;
       var getCurrentTime = function () {
@@ -5058,7 +5058,7 @@
         react_stack_bottom_frame: function (
           Component,
           props,
-          componentDebugInfo
+          componentDebugInfo,
         ) {
           currentOwner = componentDebugInfo;
           try {
@@ -5066,7 +5066,7 @@
           } finally {
             currentOwner = null;
           }
-        }
+        },
       },
       callComponentInDEV =
         callComponent.react_stack_bottom_frame.bind(callComponent),
@@ -5074,14 +5074,14 @@
         react_stack_bottom_frame: function (lazy) {
           var init = lazy._init;
           return init(lazy._payload);
-        }
+        },
       },
       callLazyInitInDEV =
         callLazyInit.react_stack_bottom_frame.bind(callLazyInit),
       callIterator = {
         react_stack_bottom_frame: function (iterator, progress, error) {
           iterator.next().then(progress, error);
-        }
+        },
       },
       callIteratorInDEV =
         callIterator.react_stack_bottom_frame.bind(callIterator),
@@ -5089,24 +5089,24 @@
       getPrototypeOf = Object.getPrototypeOf,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
-      CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"),
+      CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference'),
       hasOwnProperty = Object.prototype.hasOwnProperty,
       doNotLimit = new WeakSet();
-    "object" === typeof console &&
+    'object' === typeof console &&
       null !== console &&
-      (patchConsole(console, "assert"),
-      patchConsole(console, "debug"),
-      patchConsole(console, "dir"),
-      patchConsole(console, "dirxml"),
-      patchConsole(console, "error"),
-      patchConsole(console, "group"),
-      patchConsole(console, "groupCollapsed"),
-      patchConsole(console, "groupEnd"),
-      patchConsole(console, "info"),
-      patchConsole(console, "log"),
-      patchConsole(console, "table"),
-      patchConsole(console, "trace"),
-      patchConsole(console, "warn"));
+      (patchConsole(console, 'assert'),
+      patchConsole(console, 'debug'),
+      patchConsole(console, 'dir'),
+      patchConsole(console, 'dirxml'),
+      patchConsole(console, 'error'),
+      patchConsole(console, 'group'),
+      patchConsole(console, 'groupCollapsed'),
+      patchConsole(console, 'groupEnd'),
+      patchConsole(console, 'info'),
+      patchConsole(console, 'log'),
+      patchConsole(console, 'table'),
+      patchConsole(console, 'trace'),
+      patchConsole(console, 'warn'));
     var ObjectPrototype = Object.prototype,
       stringify = JSON.stringify,
       ABORTING = 12,
@@ -5126,16 +5126,16 @@
     Chunk.prototype = Object.create(Promise.prototype);
     Chunk.prototype.then = function (resolve, reject) {
       switch (this.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(this);
       }
       switch (this.status) {
-        case "fulfilled":
+        case 'fulfilled':
           resolve(this.value);
           break;
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           resolve &&
             (null === this.value && (this.value = []),
             this.value.push(resolve));
@@ -5160,16 +5160,16 @@
       var formData = new FormData(),
         action = null;
       body.forEach(function (value, key) {
-        key.startsWith("$ACTION_")
-          ? key.startsWith("$ACTION_REF_")
-            ? ((value = "$ACTION_" + key.slice(12) + ":"),
+        key.startsWith('$ACTION_')
+          ? key.startsWith('$ACTION_REF_')
+            ? ((value = '$ACTION_' + key.slice(12) + ':'),
               (value = decodeBoundActionMetaData(body, serverManifest, value)),
               (action = loadServerReference(
                 serverManifest,
                 value.id,
-                value.bound
+                value.bound,
               )))
-            : key.startsWith("$ACTION_ID_") &&
+            : key.startsWith('$ACTION_ID_') &&
               ((value = key.slice(11)),
               (action = loadServerReference(serverManifest, value, null)))
           : formData.append(key, value);
@@ -5181,12 +5181,12 @@
           });
     };
     exports.decodeFormState = function (actionResult, body, serverManifest) {
-      var keyPath = body.get("$ACTION_KEY");
-      if ("string" !== typeof keyPath) return Promise.resolve(null);
+      var keyPath = body.get('$ACTION_KEY');
+      if ('string' !== typeof keyPath) return Promise.resolve(null);
       var metaData = null;
       body.forEach(function (value, key) {
-        key.startsWith("$ACTION_REF_") &&
-          ((value = "$ACTION_" + key.slice(12) + ":"),
+        key.startsWith('$ACTION_REF_') &&
+          ((value = '$ACTION_' + key.slice(12) + ':'),
           (metaData = decodeBoundActionMetaData(body, serverManifest, value)));
       });
       if (null === metaData) return Promise.resolve(null);
@@ -5198,16 +5198,16 @@
       });
     };
     exports.decodeReply = function (body, webpackMap, options) {
-      if ("string" === typeof body) {
+      if ('string' === typeof body) {
         var form = new FormData();
-        form.append("0", body);
+        form.append('0', body);
         body = form;
       }
       body = createResponse(
         webpackMap,
-        "",
+        '',
         options ? options.temporaryReferences : void 0,
-        body
+        body,
       );
       webpackMap = getChunk(body, 0);
       close(body);
@@ -5216,7 +5216,7 @@
     exports.decodeReplyFromAsyncIterable = function (
       iterable,
       webpackMap,
-      options
+      options,
     ) {
       function progress(entry) {
         if (entry.done) close(response$jscomp$0);
@@ -5224,7 +5224,7 @@
           entry = entry.value;
           var name = entry[0];
           entry = entry[1];
-          if ("string" === typeof entry) {
+          if ('string' === typeof entry) {
             var response = response$jscomp$0;
             response._formData.append(name, entry);
             var prefix = response._prefix;
@@ -5239,14 +5239,14 @@
       }
       function error(reason) {
         reportGlobalError(response$jscomp$0, reason);
-        "function" === typeof iterator.throw &&
+        'function' === typeof iterator.throw &&
           iterator.throw(reason).then(error, error);
       }
       var iterator = iterable[ASYNC_ITERATOR](),
         response$jscomp$0 = createResponse(
           webpackMap,
-          "",
-          options ? options.temporaryReferences : void 0
+          '',
+          options ? options.temporaryReferences : void 0,
         );
       iterator.next().then(progress, error);
       return getChunk(response$jscomp$0, 0);
@@ -5259,16 +5259,16 @@
           function () {
             var stream = new ReadableStream(
               {
-                type: "bytes",
+                type: 'bytes',
                 pull: function (controller) {
                   startFlowing(request, controller);
                 },
                 cancel: function (reason) {
                   request.destination = null;
                   abort(request, reason);
-                }
+                },
               },
-              { highWaterMark: 0 }
+              { highWaterMark: 0 },
             );
             resolve({ prelude: stream });
           },
@@ -5279,7 +5279,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          !1
+          !1,
         );
         if (options && options.signal) {
           var signal = options.signal;
@@ -5287,9 +5287,9 @@
           else {
             var listener = function () {
               abort(request, signal.reason);
-              signal.removeEventListener("abort", listener);
+              signal.removeEventListener('abort', listener);
             };
-            signal.addEventListener("abort", listener);
+            signal.addEventListener('abort', listener);
           }
         }
         startWork(request);
@@ -5298,24 +5298,24 @@
     exports.registerClientReference = function (
       proxyImplementation,
       id,
-      exportName
+      exportName,
     ) {
       return registerClientReferenceImpl(
         proxyImplementation,
-        id + "#" + exportName,
-        !1
+        id + '#' + exportName,
+        !1,
       );
     };
     exports.registerServerReference = function (reference, id, exportName) {
       return Object.defineProperties(reference, {
         $$typeof: { value: SERVER_REFERENCE_TAG },
         $$id: {
-          value: null === exportName ? id : id + "#" + exportName,
-          configurable: !0
+          value: null === exportName ? id : id + '#' + exportName,
+          configurable: !0,
         },
         $$bound: { value: null, configurable: !0 },
-        $$location: { value: Error("react-stack-top-frame"), configurable: !0 },
-        bind: { value: bind, configurable: !0 }
+        $$location: { value: Error('react-stack-top-frame'), configurable: !0 },
+        bind: { value: bind, configurable: !0 },
       });
     };
     exports.renderToReadableStream = function (model, webpackMap, options) {
@@ -5336,7 +5336,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          void 0 !== debugChannelReadable
+          void 0 !== debugChannelReadable,
         );
       if (options && options.signal) {
         var signal = options.signal;
@@ -5344,15 +5344,15 @@
         else {
           var listener = function () {
             abort(request, signal.reason);
-            signal.removeEventListener("abort", listener);
+            signal.removeEventListener('abort', listener);
           };
-          signal.addEventListener("abort", listener);
+          signal.addEventListener('abort', listener);
         }
       }
       void 0 !== debugChannelWritable &&
         new ReadableStream(
           {
-            type: "bytes",
+            type: 'bytes',
             pull: function (controller) {
               if (13 === request.status)
                 (request.status = CLOSED),
@@ -5369,18 +5369,18 @@
                     fatalError(request, error);
                 }
               }
-            }
+            },
           },
-          { highWaterMark: 0 }
+          { highWaterMark: 0 },
         ).pipeTo(debugChannelWritable);
       void 0 !== debugChannelReadable &&
         startReadingFromDebugChannelReadableStream(
           request,
-          debugChannelReadable
+          debugChannelReadable,
         );
       return new ReadableStream(
         {
-          type: "bytes",
+          type: 'bytes',
           start: function () {
             startWork(request);
           },
@@ -5390,9 +5390,9 @@
           cancel: function (reason) {
             request.destination = null;
             abort(request, reason);
-          }
+          },
         },
-        { highWaterMark: 0 }
+        { highWaterMark: 0 },
       );
     };
   })();
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.edge.production.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.production.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.edge.production.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.production.js	2025-12-17 14:32:44
@@ -8,27 +8,27 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-var ReactDOM = require("react-dom"),
-  React = require("react"),
-  REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
-  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-  REACT_MEMO_TYPE = Symbol.for("react.memo"),
-  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-Symbol.for("react.postpone");
+'use strict';
+var ReactDOM = require('react-dom'),
+  React = require('react'),
+  REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element'),
+  REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+  REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+  REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+  REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+  REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+  REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+  REACT_MEMO_TYPE = Symbol.for('react.memo'),
+  REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+  REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
+Symbol.for('react.postpone');
 var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
 function getIteratorFn(maybeIterable) {
-  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  if (null === maybeIterable || 'object' !== typeof maybeIterable) return null;
   maybeIterable =
     (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-    maybeIterable["@@iterator"];
-  return "function" === typeof maybeIterable ? maybeIterable : null;
+    maybeIterable['@@iterator'];
+  return 'function' === typeof maybeIterable ? maybeIterable : null;
 }
 var ASYNC_ITERATOR = Symbol.asyncIterator;
 function handleErrorInNextTick(error) {
@@ -38,7 +38,7 @@
 }
 var LocalPromise = Promise,
   scheduleMicrotask =
-    "function" === typeof queueMicrotask
+    'function' === typeof queueMicrotask
       ? queueMicrotask
       : function (callback) {
           LocalPromise.resolve(null)
@@ -52,7 +52,7 @@
     if (2048 < chunk.byteLength)
       0 < writtenBytes &&
         (destination.enqueue(
-          new Uint8Array(currentView.buffer, 0, writtenBytes)
+          new Uint8Array(currentView.buffer, 0, writtenBytes),
         ),
         (currentView = new Uint8Array(2048)),
         (writtenBytes = 0)),
@@ -80,17 +80,17 @@
   return chunk.byteLength;
 }
 function closeWithError(destination, error) {
-  "function" === typeof destination.error
+  'function' === typeof destination.error
     ? destination.error(error)
     : destination.close();
 }
-var CLIENT_REFERENCE_TAG$1 = Symbol.for("react.client.reference"),
-  SERVER_REFERENCE_TAG = Symbol.for("react.server.reference");
+var CLIENT_REFERENCE_TAG$1 = Symbol.for('react.client.reference'),
+  SERVER_REFERENCE_TAG = Symbol.for('react.server.reference');
 function registerClientReferenceImpl(proxyImplementation, id, async) {
   return Object.defineProperties(proxyImplementation, {
     $$typeof: { value: CLIENT_REFERENCE_TAG$1 },
     $$id: { value: id },
-    $$async: { value: async }
+    $$async: { value: async },
   });
 }
 var FunctionBind = Function.prototype.bind,
@@ -106,7 +106,7 @@
       $$typeof: $$typeof,
       $$id: $$id,
       $$bound: args,
-      bind: { value: bind, configurable: !0 }
+      bind: { value: bind, configurable: !0 },
     });
   }
   return newFn;
@@ -115,114 +115,114 @@
   deepProxyHandlers = {
     get: function (target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "$$id":
+        case '$$id':
           return target.$$id;
-        case "$$async":
+        case '$$async':
           return target.$$async;
-        case "name":
+        case 'name':
           return target.name;
-        case "displayName":
+        case 'displayName':
           return;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "Provider":
+        case 'Provider':
           throw Error(
-            "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+            'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
           );
-        case "then":
+        case 'then':
           throw Error(
-            "Cannot await or return from a thenable. You cannot await a client module from a server component."
+            'Cannot await or return from a thenable. You cannot await a client module from a server component.',
           );
       }
       throw Error(
-        "Cannot access " +
-          (String(target.name) + "." + String(name)) +
-          " on the server. You cannot dot into a client module from a server component. You can only pass the imported name through."
+        'Cannot access ' +
+          (String(target.name) + '.' + String(name)) +
+          ' on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.',
       );
     },
     set: function () {
-      throw Error("Cannot assign to a client module from a server module.");
-    }
+      throw Error('Cannot assign to a client module from a server module.');
+    },
   };
 function getReference(target, name) {
   switch (name) {
-    case "$$typeof":
+    case '$$typeof':
       return target.$$typeof;
-    case "$$id":
+    case '$$id':
       return target.$$id;
-    case "$$async":
+    case '$$async':
       return target.$$async;
-    case "name":
+    case 'name':
       return target.name;
-    case "defaultProps":
+    case 'defaultProps':
       return;
-    case "_debugInfo":
+    case '_debugInfo':
       return;
-    case "toJSON":
+    case 'toJSON':
       return;
     case Symbol.toPrimitive:
       return Object.prototype[Symbol.toPrimitive];
     case Symbol.toStringTag:
       return Object.prototype[Symbol.toStringTag];
-    case "__esModule":
+    case '__esModule':
       var moduleId = target.$$id;
       target.default = registerClientReferenceImpl(
         function () {
           throw Error(
-            "Attempted to call the default export of " +
+            'Attempted to call the default export of ' +
               moduleId +
-              " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+              " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
           );
         },
-        target.$$id + "#",
-        target.$$async
+        target.$$id + '#',
+        target.$$async,
       );
       return !0;
-    case "then":
+    case 'then':
       if (target.then) return target.then;
       if (target.$$async) return;
       var clientReference = registerClientReferenceImpl({}, target.$$id, !0),
         proxy = new Proxy(clientReference, proxyHandlers$1);
-      target.status = "fulfilled";
+      target.status = 'fulfilled';
       target.value = proxy;
       return (target.then = registerClientReferenceImpl(
         function (resolve) {
           return Promise.resolve(resolve(proxy));
         },
-        target.$$id + "#then",
-        !1
+        target.$$id + '#then',
+        !1,
       ));
   }
-  if ("symbol" === typeof name)
+  if ('symbol' === typeof name)
     throw Error(
-      "Cannot read Symbol exports. Only named exports are supported on a client module imported on the server."
+      'Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.',
     );
   clientReference = target[name];
   clientReference ||
     ((clientReference = registerClientReferenceImpl(
       function () {
         throw Error(
-          "Attempted to call " +
+          'Attempted to call ' +
             String(name) +
-            "() from the server but " +
+            '() from the server but ' +
             String(name) +
-            " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+            " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
         );
       },
-      target.$$id + "#" + name,
-      target.$$async
+      target.$$id + '#' + name,
+      target.$$async,
     )),
-    Object.defineProperty(clientReference, "name", { value: name }),
+    Object.defineProperty(clientReference, 'name', { value: name }),
     (clientReference = target[name] =
       new Proxy(clientReference, deepProxyHandlers)));
   return clientReference;
@@ -238,7 +238,7 @@
           value: getReference(target, name),
           writable: !1,
           configurable: !1,
-          enumerable: !1
+          enumerable: !1,
         }),
         Object.defineProperty(target, name, descriptor));
       return descriptor;
@@ -247,8 +247,8 @@
       return PROMISE_PROTOTYPE;
     },
     set: function () {
-      throw Error("Cannot assign to a client module from a server module.");
-    }
+      throw Error('Cannot assign to a client module from a server module.');
+    },
   },
   ReactDOMSharedInternals =
     ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
@@ -262,119 +262,119 @@
   m: preloadModule$1,
   X: preinitScript,
   S: preinitStyle,
-  M: preinitModuleScript
+  M: preinitModuleScript,
 };
 function prefetchDNS(href) {
-  if ("string" === typeof href && href) {
+  if ('string' === typeof href && href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "D|" + href;
-      hints.has(key) || (hints.add(key), emitHint(request, "D", href));
+        key = 'D|' + href;
+      hints.has(key) || (hints.add(key), emitHint(request, 'D', href));
     } else previousDispatcher.D(href);
   }
 }
 function preconnect(href, crossOrigin) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "C|" + (null == crossOrigin ? "null" : crossOrigin) + "|" + href;
+        key = 'C|' + (null == crossOrigin ? 'null' : crossOrigin) + '|' + href;
       hints.has(key) ||
         (hints.add(key),
-        "string" === typeof crossOrigin
-          ? emitHint(request, "C", [href, crossOrigin])
-          : emitHint(request, "C", href));
+        'string' === typeof crossOrigin
+          ? emitHint(request, 'C', [href, crossOrigin])
+          : emitHint(request, 'C', href));
     } else previousDispatcher.C(href, crossOrigin);
   }
 }
 function preload(href, as, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "L";
-      if ("image" === as && options) {
+        key = 'L';
+      if ('image' === as && options) {
         var imageSrcSet = options.imageSrcSet,
           imageSizes = options.imageSizes,
-          uniquePart = "";
-        "string" === typeof imageSrcSet && "" !== imageSrcSet
-          ? ((uniquePart += "[" + imageSrcSet + "]"),
-            "string" === typeof imageSizes &&
-              (uniquePart += "[" + imageSizes + "]"))
-          : (uniquePart += "[][]" + href);
-        key += "[image]" + uniquePart;
-      } else key += "[" + as + "]" + href;
+          uniquePart = '';
+        'string' === typeof imageSrcSet && '' !== imageSrcSet
+          ? ((uniquePart += '[' + imageSrcSet + ']'),
+            'string' === typeof imageSizes &&
+              (uniquePart += '[' + imageSizes + ']'))
+          : (uniquePart += '[][]' + href);
+        key += '[image]' + uniquePart;
+      } else key += '[' + as + ']' + href;
       hints.has(key) ||
         (hints.add(key),
         (options = trimOptions(options))
-          ? emitHint(request, "L", [href, as, options])
-          : emitHint(request, "L", [href, as]));
+          ? emitHint(request, 'L', [href, as, options])
+          : emitHint(request, 'L', [href, as]));
     } else previousDispatcher.L(href, as, options);
   }
 }
 function preloadModule$1(href, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "m|" + href;
+        key = 'm|' + href;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "m", [href, options])
-        : emitHint(request, "m", href);
+        ? emitHint(request, 'm', [href, options])
+        : emitHint(request, 'm', href);
     }
     previousDispatcher.m(href, options);
   }
 }
 function preinitStyle(href, precedence, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "S|" + href;
+        key = 'S|' + href;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "S", [
+        ? emitHint(request, 'S', [
             href,
-            "string" === typeof precedence ? precedence : 0,
-            options
+            'string' === typeof precedence ? precedence : 0,
+            options,
           ])
-        : "string" === typeof precedence
-          ? emitHint(request, "S", [href, precedence])
-          : emitHint(request, "S", href);
+        : 'string' === typeof precedence
+          ? emitHint(request, 'S', [href, precedence])
+          : emitHint(request, 'S', href);
     }
     previousDispatcher.S(href, precedence, options);
   }
 }
 function preinitScript(src, options) {
-  if ("string" === typeof src) {
+  if ('string' === typeof src) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "X|" + src;
+        key = 'X|' + src;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "X", [src, options])
-        : emitHint(request, "X", src);
+        ? emitHint(request, 'X', [src, options])
+        : emitHint(request, 'X', src);
     }
     previousDispatcher.X(src, options);
   }
 }
 function preinitModuleScript(src, options) {
-  if ("string" === typeof src) {
+  if ('string' === typeof src) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "M|" + src;
+        key = 'M|' + src;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "M", [src, options])
-        : emitHint(request, "M", src);
+        ? emitHint(request, 'M', [src, options])
+        : emitHint(request, 'M', src);
     }
     previousDispatcher.M(src, options);
   }
@@ -391,63 +391,63 @@
 }
 function getChildFormatContext(parentContext, type, props) {
   switch (type) {
-    case "img":
+    case 'img':
       type = props.src;
       var srcSet = props.srcSet;
       if (
         !(
-          "lazy" === props.loading ||
+          'lazy' === props.loading ||
           (!type && !srcSet) ||
-          ("string" !== typeof type && null != type) ||
-          ("string" !== typeof srcSet && null != srcSet) ||
-          "low" === props.fetchPriority ||
+          ('string' !== typeof type && null != type) ||
+          ('string' !== typeof srcSet && null != srcSet) ||
+          'low' === props.fetchPriority ||
           parentContext & 3
         ) &&
-        ("string" !== typeof type ||
-          ":" !== type[4] ||
-          ("d" !== type[0] && "D" !== type[0]) ||
-          ("a" !== type[1] && "A" !== type[1]) ||
-          ("t" !== type[2] && "T" !== type[2]) ||
-          ("a" !== type[3] && "A" !== type[3])) &&
-        ("string" !== typeof srcSet ||
-          ":" !== srcSet[4] ||
-          ("d" !== srcSet[0] && "D" !== srcSet[0]) ||
-          ("a" !== srcSet[1] && "A" !== srcSet[1]) ||
-          ("t" !== srcSet[2] && "T" !== srcSet[2]) ||
-          ("a" !== srcSet[3] && "A" !== srcSet[3]))
+        ('string' !== typeof type ||
+          ':' !== type[4] ||
+          ('d' !== type[0] && 'D' !== type[0]) ||
+          ('a' !== type[1] && 'A' !== type[1]) ||
+          ('t' !== type[2] && 'T' !== type[2]) ||
+          ('a' !== type[3] && 'A' !== type[3])) &&
+        ('string' !== typeof srcSet ||
+          ':' !== srcSet[4] ||
+          ('d' !== srcSet[0] && 'D' !== srcSet[0]) ||
+          ('a' !== srcSet[1] && 'A' !== srcSet[1]) ||
+          ('t' !== srcSet[2] && 'T' !== srcSet[2]) ||
+          ('a' !== srcSet[3] && 'A' !== srcSet[3]))
       ) {
-        var sizes = "string" === typeof props.sizes ? props.sizes : void 0;
+        var sizes = 'string' === typeof props.sizes ? props.sizes : void 0;
         var input = props.crossOrigin;
-        preload(type || "", "image", {
+        preload(type || '', 'image', {
           imageSrcSet: srcSet,
           imageSizes: sizes,
           crossOrigin:
-            "string" === typeof input
-              ? "use-credentials" === input
+            'string' === typeof input
+              ? 'use-credentials' === input
                 ? input
-                : ""
+                : ''
               : void 0,
           integrity: props.integrity,
           type: props.type,
           fetchPriority: props.fetchPriority,
-          referrerPolicy: props.referrerPolicy
+          referrerPolicy: props.referrerPolicy,
         });
       }
       return parentContext;
-    case "link":
+    case 'link':
       type = props.rel;
       srcSet = props.href;
       if (
         !(
           parentContext & 1 ||
           null != props.itemProp ||
-          "string" !== typeof type ||
-          "string" !== typeof srcSet ||
-          "" === srcSet
+          'string' !== typeof type ||
+          'string' !== typeof srcSet ||
+          '' === srcSet
         )
       )
         switch (type) {
-          case "preload":
+          case 'preload':
             preload(srcSet, props.as, {
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
@@ -457,86 +457,86 @@
               referrerPolicy: props.referrerPolicy,
               imageSrcSet: props.imageSrcSet,
               imageSizes: props.imageSizes,
-              media: props.media
+              media: props.media,
             });
             break;
-          case "modulepreload":
+          case 'modulepreload':
             preloadModule$1(srcSet, {
               as: props.as,
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
-              nonce: props.nonce
+              nonce: props.nonce,
             });
             break;
-          case "stylesheet":
-            preload(srcSet, "stylesheet", {
+          case 'stylesheet':
+            preload(srcSet, 'stylesheet', {
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
               nonce: props.nonce,
               type: props.type,
               fetchPriority: props.fetchPriority,
               referrerPolicy: props.referrerPolicy,
-              media: props.media
+              media: props.media,
             });
         }
       return parentContext;
-    case "picture":
+    case 'picture':
       return parentContext | 2;
-    case "noscript":
+    case 'noscript':
       return parentContext | 1;
     default:
       return parentContext;
   }
 }
-var supportsRequestStorage = "function" === typeof AsyncLocalStorage,
+var supportsRequestStorage = 'function' === typeof AsyncLocalStorage,
   requestStorage = supportsRequestStorage ? new AsyncLocalStorage() : null,
-  TEMPORARY_REFERENCE_TAG = Symbol.for("react.temporary.reference"),
+  TEMPORARY_REFERENCE_TAG = Symbol.for('react.temporary.reference'),
   proxyHandlers = {
     get: function (target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "name":
+        case 'name':
           return;
-        case "displayName":
+        case 'displayName':
           return;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "Provider":
+        case 'Provider':
           throw Error(
-            "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+            'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
           );
-        case "then":
+        case 'then':
           return;
       }
       throw Error(
-        "Cannot access " +
+        'Cannot access ' +
           String(name) +
-          " on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client."
+          ' on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client.',
       );
     },
     set: function () {
       throw Error(
-        "Cannot assign to a temporary client reference from a server module."
+        'Cannot assign to a temporary client reference from a server module.',
       );
-    }
+    },
   };
 function createTemporaryReference(temporaryReferences, id) {
   var reference = Object.defineProperties(
     function () {
       throw Error(
-        "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+        "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
       );
     },
-    { $$typeof: { value: TEMPORARY_REFERENCE_TAG } }
+    { $$typeof: { value: TEMPORARY_REFERENCE_TAG } },
   );
   reference = new Proxy(reference, proxyHandlers);
   temporaryReferences.set(reference, id);
@@ -544,7 +544,7 @@
 }
 function noop() {}
 var SuspenseException = Error(
-  "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
+  "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.",
 );
 function trackUsedThenable(thenableState, thenable, index) {
   index = thenableState[index];
@@ -552,35 +552,35 @@
     ? thenableState.push(thenable)
     : index !== thenable && (thenable.then(noop, noop), (thenable = index));
   switch (thenable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return thenable.value;
-    case "rejected":
+    case 'rejected':
       throw thenable.reason;
     default:
-      "string" === typeof thenable.status
+      'string' === typeof thenable.status
         ? thenable.then(noop, noop)
         : ((thenableState = thenable),
-          (thenableState.status = "pending"),
+          (thenableState.status = 'pending'),
           thenableState.then(
             function (fulfilledValue) {
-              if ("pending" === thenable.status) {
+              if ('pending' === thenable.status) {
                 var fulfilledThenable = thenable;
-                fulfilledThenable.status = "fulfilled";
+                fulfilledThenable.status = 'fulfilled';
                 fulfilledThenable.value = fulfilledValue;
               }
             },
             function (error) {
-              if ("pending" === thenable.status) {
+              if ('pending' === thenable.status) {
                 var rejectedThenable = thenable;
-                rejectedThenable.status = "rejected";
+                rejectedThenable.status = 'rejected';
                 rejectedThenable.reason = error;
               }
-            }
+            },
           ));
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return thenable.value;
-        case "rejected":
+        case 'rejected':
           throw thenable.reason;
       }
       suspendedThenable = thenable;
@@ -591,7 +591,7 @@
 function getSuspendedThenable() {
   if (null === suspendedThenable)
     throw Error(
-      "Expected a suspended thenable. This is a bug in React. Please file an issue."
+      'Expected a suspended thenable. This is a bug in React. Please file an issue.',
     );
   var thenable = suspendedThenable;
   suspendedThenable = null;
@@ -638,30 +638,30 @@
   },
   useCacheRefresh: function () {
     return unsupportedRefresh;
-  }
+  },
 };
 HooksDispatcher.useEffectEvent = unsupportedHook;
 function unsupportedHook() {
-  throw Error("This Hook is not supported in Server Components.");
+  throw Error('This Hook is not supported in Server Components.');
 }
 function unsupportedRefresh() {
-  throw Error("Refreshing the cache is not supported in Server Components.");
+  throw Error('Refreshing the cache is not supported in Server Components.');
 }
 function unsupportedContext() {
-  throw Error("Cannot read a Client Context from a Server Component.");
+  throw Error('Cannot read a Client Context from a Server Component.');
 }
 function useId() {
   if (null === currentRequest$1)
-    throw Error("useId can only be used while React is rendering");
+    throw Error('useId can only be used while React is rendering');
   var id = currentRequest$1.identifierCount++;
-  return "_" + currentRequest$1.identifierPrefix + "S_" + id.toString(32) + "_";
+  return '_' + currentRequest$1.identifierPrefix + 'S_' + id.toString(32) + '_';
 }
 function use(usable) {
   if (
-    (null !== usable && "object" === typeof usable) ||
-    "function" === typeof usable
+    (null !== usable && 'object' === typeof usable) ||
+    'function' === typeof usable
   ) {
-    if ("function" === typeof usable.then) {
+    if ('function' === typeof usable.then) {
       var index = thenableIndexCounter;
       thenableIndexCounter += 1;
       null === thenableState && (thenableState = []);
@@ -671,10 +671,10 @@
   }
   if (usable.$$typeof === CLIENT_REFERENCE_TAG$1) {
     if (null != usable.value && usable.value.$$typeof === REACT_CONTEXT_TYPE)
-      throw Error("Cannot read a Client Context from a Server Component.");
-    throw Error("Cannot use() an already resolved Client Reference.");
+      throw Error('Cannot read a Client Context from a Server Component.');
+    throw Error('Cannot use() an already resolved Client Reference.');
   }
-  throw Error("An unsupported type was passed to use(): " + String(usable));
+  throw Error('An unsupported type was passed to use(): ' + String(usable));
 }
 var DefaultAsyncDispatcher = {
     getCacheForType: function (resourceType) {
@@ -691,13 +691,13 @@
     cacheSignal: function () {
       var request = resolveRequest();
       return request ? request.cacheController.signal : null;
-    }
+    },
   },
   ReactSharedInternalsServer =
     React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
 if (!ReactSharedInternalsServer)
   throw Error(
-    'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
+    'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.',
   );
 var isArrayImpl = Array.isArray,
   getPrototypeOf = Object.getPrototypeOf;
@@ -707,35 +707,35 @@
 }
 function describeValueForErrorMessage(value) {
   switch (typeof value) {
-    case "string":
+    case 'string':
       return JSON.stringify(
-        10 >= value.length ? value : value.slice(0, 10) + "..."
+        10 >= value.length ? value : value.slice(0, 10) + '...',
       );
-    case "object":
-      if (isArrayImpl(value)) return "[...]";
+    case 'object':
+      if (isArrayImpl(value)) return '[...]';
       if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-        return "client";
+        return 'client';
       value = objectName(value);
-      return "Object" === value ? "{...}" : value;
-    case "function":
+      return 'Object' === value ? '{...}' : value;
+    case 'function':
       return value.$$typeof === CLIENT_REFERENCE_TAG
-        ? "client"
+        ? 'client'
         : (value = value.displayName || value.name)
-          ? "function " + value
-          : "function";
+          ? 'function ' + value
+          : 'function';
     default:
       return String(value);
   }
 }
 function describeElementType(type) {
-  if ("string" === typeof type) return type;
+  if ('string' === typeof type) return type;
   switch (type) {
     case REACT_SUSPENSE_TYPE:
-      return "Suspense";
+      return 'Suspense';
     case REACT_SUSPENSE_LIST_TYPE:
-      return "SuspenseList";
+      return 'SuspenseList';
   }
-  if ("object" === typeof type)
+  if ('object' === typeof type)
     switch (type.$$typeof) {
       case REACT_FORWARD_REF_TYPE:
         return describeElementType(type.render);
@@ -748,45 +748,45 @@
           return describeElementType(type(payload));
         } catch (x) {}
     }
-  return "";
+  return '';
 }
-var CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference");
+var CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference');
 function describeObjectForErrorMessage(objectOrArray, expandedName) {
   var objKind = objectName(objectOrArray);
-  if ("Object" !== objKind && "Array" !== objKind) return objKind;
+  if ('Object' !== objKind && 'Array' !== objKind) return objKind;
   objKind = -1;
   var length = 0;
   if (isArrayImpl(objectOrArray)) {
-    var str = "[";
+    var str = '[';
     for (var i = 0; i < objectOrArray.length; i++) {
-      0 < i && (str += ", ");
+      0 < i && (str += ', ');
       var value = objectOrArray[i];
       value =
-        "object" === typeof value && null !== value
+        'object' === typeof value && null !== value
           ? describeObjectForErrorMessage(value)
           : describeValueForErrorMessage(value);
-      "" + i === expandedName
+      '' + i === expandedName
         ? ((objKind = str.length), (length = value.length), (str += value))
         : (str =
             10 > value.length && 40 > str.length + value.length
               ? str + value
-              : str + "...");
+              : str + '...');
     }
-    str += "]";
+    str += ']';
   } else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-    str = "<" + describeElementType(objectOrArray.type) + "/>";
+    str = '<' + describeElementType(objectOrArray.type) + '/>';
   else {
-    if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
-    str = "{";
+    if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
+    str = '{';
     i = Object.keys(objectOrArray);
     for (value = 0; value < i.length; value++) {
-      0 < value && (str += ", ");
+      0 < value && (str += ', ');
       var name = i[value],
         encodedKey = JSON.stringify(name);
-      str += ('"' + name + '"' === encodedKey ? name : encodedKey) + ": ";
+      str += ('"' + name + '"' === encodedKey ? name : encodedKey) + ': ';
       encodedKey = objectOrArray[name];
       encodedKey =
-        "object" === typeof encodedKey && null !== encodedKey
+        'object' === typeof encodedKey && null !== encodedKey
           ? describeObjectForErrorMessage(encodedKey)
           : describeValueForErrorMessage(encodedKey);
       name === expandedName
@@ -796,16 +796,16 @@
         : (str =
             10 > encodedKey.length && 40 > str.length + encodedKey.length
               ? str + encodedKey
-              : str + "...");
+              : str + '...');
     }
-    str += "}";
+    str += '}';
   }
   return void 0 === expandedName
     ? str
     : -1 < objKind && 0 < length
-      ? ((objectOrArray = " ".repeat(objKind) + "^".repeat(length)),
-        "\n  " + str + "\n  " + objectOrArray)
-      : "\n  " + str;
+      ? ((objectOrArray = ' '.repeat(objKind) + '^'.repeat(length)),
+        '\n  ' + str + '\n  ' + objectOrArray)
+      : '\n  ' + str;
 }
 var hasOwnProperty = Object.prototype.hasOwnProperty,
   ObjectPrototype = Object.prototype,
@@ -822,13 +822,13 @@
   onAllReady,
   onFatalError,
   identifierPrefix,
-  temporaryReferences
+  temporaryReferences,
 ) {
   if (
     null !== ReactSharedInternalsServer.A &&
     ReactSharedInternalsServer.A !== DefaultAsyncDispatcher
   )
-    throw Error("Currently React only supports one RSC renderer at a time.");
+    throw Error('Currently React only supports one RSC renderer at a time.');
   ReactSharedInternalsServer.A = DefaultAsyncDispatcher;
   var abortSet = new Set(),
     pingedTasks = [],
@@ -853,7 +853,7 @@
   this.writtenServerReferences = new Map();
   this.writtenObjects = new WeakMap();
   this.temporaryReferences = temporaryReferences;
-  this.identifierPrefix = identifierPrefix || "";
+  this.identifierPrefix = identifierPrefix || '';
   this.identifierCount = 1;
   this.taintCleanupQueue = [];
   this.onError = void 0 === onError ? defaultErrorHandler : onError;
@@ -879,14 +879,14 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   switch (thenable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return (
         (newTask.model = thenable.value), pingTask(request, newTask), newTask.id
       );
-    case "rejected":
+    case 'rejected':
       return erroredTask(request, newTask, thenable.reason), newTask.id;
     default:
       if (12 === request.status)
@@ -899,18 +899,18 @@
               finishAbortedTask(newTask, request, task)),
           newTask.id
         );
-      "string" !== typeof thenable.status &&
-        ((thenable.status = "pending"),
+      'string' !== typeof thenable.status &&
+        ((thenable.status = 'pending'),
         thenable.then(
           function (fulfilledValue) {
-            "pending" === thenable.status &&
-              ((thenable.status = "fulfilled"),
+            'pending' === thenable.status &&
+              ((thenable.status = 'fulfilled'),
               (thenable.value = fulfilledValue));
           },
           function (error) {
-            "pending" === thenable.status &&
-              ((thenable.status = "rejected"), (thenable.reason = error));
-          }
+            'pending' === thenable.status &&
+              ((thenable.status = 'rejected'), (thenable.reason = error));
+          },
         ));
   }
   thenable.then(
@@ -921,7 +921,7 @@
     function (reason) {
       0 === newTask.status &&
         (erroredTask(request, newTask, reason), enqueueFlush(request));
-    }
+    },
   );
   return newTask.id;
 }
@@ -930,12 +930,12 @@
     if (0 === streamTask.status)
       if (entry.done)
         (streamTask.status = 1),
-          (entry = streamTask.id.toString(16) + ":C\n"),
+          (entry = streamTask.id.toString(16) + ':C\n'),
           request.completedRegularChunks.push(stringToChunk(entry)),
           request.abortableTasks.delete(streamTask),
           request.cacheController.signal.removeEventListener(
-            "abort",
-            abortStream
+            'abort',
+            abortStream,
           ),
           enqueueFlush(request),
           callOnAllReadyIfReady(request);
@@ -952,7 +952,7 @@
   }
   function error(reason) {
     0 === streamTask.status &&
-      (request.cacheController.signal.removeEventListener("abort", abortStream),
+      (request.cacheController.signal.removeEventListener('abort', abortStream),
       erroredTask(request, streamTask, reason),
       enqueueFlush(request),
       reader.cancel(reason).then(error, error));
@@ -960,7 +960,7 @@
   function abortStream() {
     if (0 === streamTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortStream);
+      signal.removeEventListener('abort', abortStream);
       signal = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(streamTask),
@@ -973,7 +973,7 @@
   var supportsBYOB = stream.supportsBYOB;
   if (void 0 === supportsBYOB)
     try {
-      stream.getReader({ mode: "byob" }).releaseLock(), (supportsBYOB = !0);
+      stream.getReader({ mode: 'byob' }).releaseLock(), (supportsBYOB = !0);
     } catch (x) {
       supportsBYOB = !1;
     }
@@ -984,12 +984,12 @@
       task.keyPath,
       task.implicitSlot,
       task.formatContext,
-      request.abortableTasks
+      request.abortableTasks,
     );
   request.pendingChunks++;
-  task = streamTask.id.toString(16) + ":" + (supportsBYOB ? "r" : "R") + "\n";
+  task = streamTask.id.toString(16) + ':' + (supportsBYOB ? 'r' : 'R') + '\n';
   request.completedRegularChunks.push(stringToChunk(task));
-  request.cacheController.signal.addEventListener("abort", abortStream);
+  request.cacheController.signal.addEventListener('abort', abortStream);
   reader.read().then(progress, error);
   return serializeByValueID(streamTask.id);
 }
@@ -999,19 +999,19 @@
       if (entry.done) {
         streamTask.status = 1;
         if (void 0 === entry.value)
-          var endStreamRow = streamTask.id.toString(16) + ":C\n";
+          var endStreamRow = streamTask.id.toString(16) + ':C\n';
         else
           try {
             var chunkId = outlineModelWithFormatContext(
               request,
               entry.value,
-              0
+              0,
             );
             endStreamRow =
               streamTask.id.toString(16) +
-              ":C" +
+              ':C' +
               stringify(serializeByValueID(chunkId)) +
-              "\n";
+              '\n';
           } catch (x) {
             error(x);
             return;
@@ -1019,8 +1019,8 @@
         request.completedRegularChunks.push(stringToChunk(endStreamRow));
         request.abortableTasks.delete(streamTask);
         request.cacheController.signal.removeEventListener(
-          "abort",
-          abortIterable
+          'abort',
+          abortIterable,
         );
         enqueueFlush(request);
         callOnAllReadyIfReady(request);
@@ -1038,18 +1038,18 @@
   function error(reason) {
     0 === streamTask.status &&
       (request.cacheController.signal.removeEventListener(
-        "abort",
-        abortIterable
+        'abort',
+        abortIterable,
       ),
       erroredTask(request, streamTask, reason),
       enqueueFlush(request),
-      "function" === typeof iterator.throw &&
+      'function' === typeof iterator.throw &&
         iterator.throw(reason).then(error, error));
   }
   function abortIterable() {
     if (0 === streamTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortIterable);
+      signal.removeEventListener('abort', abortIterable);
       var reason = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(streamTask),
@@ -1057,7 +1057,7 @@
           finishHaltedTask(streamTask, request))
         : (erroredTask(request, streamTask, signal.reason),
           enqueueFlush(request));
-      "function" === typeof iterator.throw &&
+      'function' === typeof iterator.throw &&
         iterator.throw(reason).then(error, error);
     }
   }
@@ -1068,45 +1068,45 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   request.pendingChunks++;
-  task = streamTask.id.toString(16) + ":" + (iterable ? "x" : "X") + "\n";
+  task = streamTask.id.toString(16) + ':' + (iterable ? 'x' : 'X') + '\n';
   request.completedRegularChunks.push(stringToChunk(task));
-  request.cacheController.signal.addEventListener("abort", abortIterable);
+  request.cacheController.signal.addEventListener('abort', abortIterable);
   iterator.next().then(progress, error);
   return serializeByValueID(streamTask.id);
 }
 function emitHint(request, code, model) {
   model = stringify(model);
-  code = stringToChunk(":H" + code + model + "\n");
+  code = stringToChunk(':H' + code + model + '\n');
   request.completedHintChunks.push(code);
   enqueueFlush(request);
 }
 function readThenable(thenable) {
-  if ("fulfilled" === thenable.status) return thenable.value;
-  if ("rejected" === thenable.status) throw thenable.reason;
+  if ('fulfilled' === thenable.status) return thenable.value;
+  if ('rejected' === thenable.status) throw thenable.reason;
   throw thenable;
 }
 function createLazyWrapperAroundWakeable(request, task, wakeable) {
   switch (wakeable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return wakeable.value;
-    case "rejected":
+    case 'rejected':
       break;
     default:
-      "string" !== typeof wakeable.status &&
-        ((wakeable.status = "pending"),
+      'string' !== typeof wakeable.status &&
+        ((wakeable.status = 'pending'),
         wakeable.then(
           function (fulfilledValue) {
-            "pending" === wakeable.status &&
-              ((wakeable.status = "fulfilled"),
+            'pending' === wakeable.status &&
+              ((wakeable.status = 'fulfilled'),
               (wakeable.value = fulfilledValue));
           },
           function (error) {
-            "pending" === wakeable.status &&
-              ((wakeable.status = "rejected"), (wakeable.reason = error));
-          }
+            'pending' === wakeable.status &&
+              ((wakeable.status = 'rejected'), (wakeable.reason = error));
+          },
         ));
   }
   return { $$typeof: REACT_LAZY_TYPE, _payload: wakeable, _init: readThenable };
@@ -1114,12 +1114,12 @@
 function voidHandler() {}
 function processServerComponentReturnValue(request, task, Component, result) {
   if (
-    "object" !== typeof result ||
+    'object' !== typeof result ||
     null === result ||
     result.$$typeof === CLIENT_REFERENCE_TAG$1
   )
     return result;
-  if ("function" === typeof result.then)
+  if ('function' === typeof result.then)
     return createLazyWrapperAroundWakeable(request, task, result);
   var iteratorFn = getIteratorFn(result);
   return iteratorFn
@@ -1128,8 +1128,8 @@
         return iteratorFn.call(result);
       }),
       request)
-    : "function" !== typeof result[ASYNC_ITERATOR] ||
-        ("function" === typeof ReadableStream &&
+    : 'function' !== typeof result[ASYNC_ITERATOR] ||
+        ('function' === typeof ReadableStream &&
           result instanceof ReadableStream)
       ? result
       : ((request = {}),
@@ -1146,9 +1146,9 @@
   props = Component(props, void 0);
   if (12 === request.status)
     throw (
-      ("object" === typeof props &&
+      ('object' === typeof props &&
         null !== props &&
-        "function" === typeof props.then &&
+        'function' === typeof props.then &&
         props.$$typeof !== CLIENT_REFERENCE_TAG$1 &&
         props.then(voidHandler, voidHandler),
       null)
@@ -1157,9 +1157,9 @@
   Component = task.keyPath;
   prevThenableState = task.implicitSlot;
   null !== key
-    ? (task.keyPath = null === Component ? key : Component + "," + key)
+    ? (task.keyPath = null === Component ? key : Component + ',' + key)
     : null === Component && (task.implicitSlot = !0);
-  request = renderModelDestructive(request, task, emptyRoot, "", props);
+  request = renderModelDestructive(request, task, emptyRoot, '', props);
   task.keyPath = Component;
   task.implicitSlot = prevThenableState;
   return request;
@@ -1170,7 +1170,7 @@
         REACT_ELEMENT_TYPE,
         REACT_FRAGMENT_TYPE,
         task.keyPath,
-        { children: children }
+        { children: children },
       ]),
       task.implicitSlot ? [request] : request)
     : children;
@@ -1183,7 +1183,7 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   pingTask(request, task);
   return serializeLazyID(task.id);
@@ -1191,10 +1191,10 @@
 function renderElement(request, task, type, key, ref, props) {
   if (null !== ref && void 0 !== ref)
     throw Error(
-      "Refs cannot be used in Server Components, nor passed to Client Components."
+      'Refs cannot be used in Server Components, nor passed to Client Components.',
     );
   if (
-    "function" === typeof type &&
+    'function' === typeof type &&
     type.$$typeof !== CLIENT_REFERENCE_TAG$1 &&
     type.$$typeof !== TEMPORARY_REFERENCE_TAG
   )
@@ -1207,15 +1207,15 @@
         request,
         task,
         emptyRoot,
-        "",
-        props.children
+        '',
+        props.children,
       )),
       (task.implicitSlot = type),
       props
     );
   if (
     null != type &&
-    "object" === typeof type &&
+    'object' === typeof type &&
     type.$$typeof !== CLIENT_REFERENCE_TAG$1
   )
     switch (type.$$typeof) {
@@ -1230,7 +1230,7 @@
         return renderElement(request, task, type.type, key, ref, props);
     }
   else
-    "string" === typeof type &&
+    'string' === typeof type &&
       ((ref = task.formatContext),
       (init = getChildFormatContext(ref, type, props)),
       ref !== init &&
@@ -1240,7 +1240,7 @@
   key = task.keyPath;
   null === request
     ? (request = key)
-    : null !== key && (request = key + "," + request);
+    : null !== key && (request = key + ',' + request);
   props = [REACT_ELEMENT_TYPE, type, request, props];
   task = task.implicitSlot && null !== request ? [props] : props;
   return task;
@@ -1264,11 +1264,11 @@
   keyPath,
   implicitSlot,
   formatContext,
-  abortSet
+  abortSet,
 ) {
   request.pendingChunks++;
   var id = request.nextChunkId++;
-  "object" !== typeof model ||
+  'object' !== typeof model ||
     null === model ||
     null !== keyPath ||
     implicitSlot ||
@@ -1293,13 +1293,13 @@
           task,
           this,
           parentPropertyName,
-          value
+          value,
         );
       } catch (thrownValue) {
         if (
           ((parentPropertyName = task.model),
           (parentPropertyName =
-            "object" === typeof parentPropertyName &&
+            'object' === typeof parentPropertyName &&
             null !== parentPropertyName &&
             (parentPropertyName.$$typeof === REACT_ELEMENT_TYPE ||
               parentPropertyName.$$typeof === REACT_LAZY_TYPE)),
@@ -1321,9 +1321,9 @@
             thrownValue === SuspenseException
               ? getSuspendedThenable()
               : thrownValue),
-          "object" === typeof value &&
+          'object' === typeof value &&
             null !== value &&
-            "function" === typeof value.then)
+            'function' === typeof value.then)
         ) {
           JSCompiler_inline_result = createTask(
             request,
@@ -1331,7 +1331,7 @@
             task.keyPath,
             task.implicitSlot,
             task.formatContext,
-            request.abortableTasks
+            request.abortableTasks,
           );
           var ping = JSCompiler_inline_result.ping;
           value.then(ping, ping);
@@ -1355,45 +1355,45 @@
       }
       return JSCompiler_inline_result;
     },
-    thenableState: null
+    thenableState: null,
   };
   abortSet.add(task);
   return task;
 }
 function serializeByValueID(id) {
-  return "$" + id.toString(16);
+  return '$' + id.toString(16);
 }
 function serializeLazyID(id) {
-  return "$L" + id.toString(16);
+  return '$L' + id.toString(16);
 }
 function encodeReferenceChunk(request, id, reference) {
   request = stringify(reference);
-  id = id.toString(16) + ":" + request + "\n";
+  id = id.toString(16) + ':' + request + '\n';
   return stringToChunk(id);
 }
 function serializeClientReference(
   request,
   parent,
   parentPropertyName,
-  clientReference
+  clientReference,
 ) {
   var clientReferenceKey = clientReference.$$async
-      ? clientReference.$$id + "#async"
+      ? clientReference.$$id + '#async'
       : clientReference.$$id,
     writtenClientReferences = request.writtenClientReferences,
     existingId = writtenClientReferences.get(clientReferenceKey);
   if (void 0 !== existingId)
-    return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+    return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
       ? serializeLazyID(existingId)
       : serializeByValueID(existingId);
   try {
     var config = request.bundlerConfig,
       modulePath = clientReference.$$id;
-    existingId = "";
+    existingId = '';
     var resolvedModuleData = config[modulePath];
     if (resolvedModuleData) existingId = resolvedModuleData.name;
     else {
-      var idx = modulePath.lastIndexOf("#");
+      var idx = modulePath.lastIndexOf('#');
       -1 !== idx &&
         ((existingId = modulePath.slice(idx + 1)),
         (resolvedModuleData = config[modulePath.slice(0, idx)]));
@@ -1401,14 +1401,14 @@
         throw Error(
           'Could not find the module "' +
             modulePath +
-            '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.'
+            '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.',
         );
     }
     if (!0 === resolvedModuleData.async && !0 === clientReference.$$async)
       throw Error(
         'The module "' +
           modulePath +
-          '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.'
+          '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.',
       );
     var JSCompiler_inline_result =
       !0 === resolvedModuleData.async || !0 === clientReference.$$async
@@ -1417,11 +1417,11 @@
     request.pendingChunks++;
     var importId = request.nextChunkId++,
       json = stringify(JSCompiler_inline_result),
-      row = importId.toString(16) + ":I" + json + "\n",
+      row = importId.toString(16) + ':I' + json + '\n',
       processedChunk = stringToChunk(row);
     request.completedImportChunks.push(processedChunk);
     writtenClientReferences.set(clientReferenceKey, importId);
-    return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+    return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
       ? serializeLazyID(importId)
       : serializeByValueID(importId);
   } catch (x) {
@@ -1441,7 +1441,7 @@
     null,
     !1,
     formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   retryTask(request, value);
   return value.id;
@@ -1456,7 +1456,7 @@
   function progress(entry) {
     if (0 === newTask.status)
       if (entry.done)
-        request.cacheController.signal.removeEventListener("abort", abortBlob),
+        request.cacheController.signal.removeEventListener('abort', abortBlob),
           pingTask(request, newTask);
       else
         return (
@@ -1465,7 +1465,7 @@
   }
   function error(reason) {
     0 === newTask.status &&
-      (request.cacheController.signal.removeEventListener("abort", abortBlob),
+      (request.cacheController.signal.removeEventListener('abort', abortBlob),
       erroredTask(request, newTask, reason),
       enqueueFlush(request),
       reader.cancel(reason).then(error, error));
@@ -1473,7 +1473,7 @@
   function abortBlob() {
     if (0 === newTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortBlob);
+      signal.removeEventListener('abort', abortBlob);
       signal = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(newTask),
@@ -1486,9 +1486,9 @@
   var model = [blob.type],
     newTask = createTask(request, model, null, !1, 0, request.abortableTasks),
     reader = blob.stream().getReader();
-  request.cacheController.signal.addEventListener("abort", abortBlob);
+  request.cacheController.signal.addEventListener('abort', abortBlob);
   reader.read().then(progress).catch(error);
-  return "$B" + newTask.id.toString(16);
+  return '$B' + newTask.id.toString(16);
 }
 var modelRoot = !1;
 function renderModelDestructive(
@@ -1496,12 +1496,12 @@
   task,
   parent,
   parentPropertyName,
-  value
+  value,
 ) {
   task.model = value;
-  if (value === REACT_ELEMENT_TYPE) return "$";
+  if (value === REACT_ELEMENT_TYPE) return '$';
   if (null === value) return null;
-  if ("object" === typeof value) {
+  if ('object' === typeof value) {
     switch (value.$$typeof) {
       case REACT_ELEMENT_TYPE:
         var elementReference = null,
@@ -1512,10 +1512,10 @@
             if (modelRoot === value) modelRoot = null;
             else return existingReference;
           else
-            -1 === parentPropertyName.indexOf(":") &&
+            -1 === parentPropertyName.indexOf(':') &&
               ((parent = writtenObjects.get(parent)),
               void 0 !== parent &&
-                ((elementReference = parent + ":" + parentPropertyName),
+                ((elementReference = parent + ':' + parentPropertyName),
                 writtenObjects.set(value, elementReference)));
         }
         if (3200 < serializedSize) return deferTask(request, task);
@@ -1527,9 +1527,9 @@
           value.type,
           value.key,
           void 0 !== parent ? parent : null,
-          parentPropertyName
+          parentPropertyName,
         );
-        "object" === typeof request &&
+        'object' === typeof request &&
           null !== request &&
           null !== elementReference &&
           (writtenObjects.has(request) ||
@@ -1541,10 +1541,10 @@
         parentPropertyName = value._init;
         value = parentPropertyName(value._payload);
         if (12 === request.status) throw null;
-        return renderModelDestructive(request, task, emptyRoot, "", value);
+        return renderModelDestructive(request, task, emptyRoot, '', value);
       case REACT_LEGACY_ELEMENT_TYPE:
         throw Error(
-          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
+          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.',
         );
     }
     if (value.$$typeof === CLIENT_REFERENCE_TAG$1)
@@ -1552,24 +1552,24 @@
         request,
         parent,
         parentPropertyName,
-        value
+        value,
       );
     if (
       void 0 !== request.temporaryReferences &&
       ((elementReference = request.temporaryReferences.get(value)),
       void 0 !== elementReference)
     )
-      return "$T" + elementReference;
+      return '$T' + elementReference;
     elementReference = request.writtenObjects;
     writtenObjects = elementReference.get(value);
-    if ("function" === typeof value.then) {
+    if ('function' === typeof value.then) {
       if (void 0 !== writtenObjects) {
         if (null !== task.keyPath || task.implicitSlot)
-          return "$@" + serializeThenable(request, task, value).toString(16);
+          return '$@' + serializeThenable(request, task, value).toString(16);
         if (modelRoot === value) modelRoot = null;
         else return writtenObjects;
       }
-      request = "$@" + serializeThenable(request, task, value).toString(16);
+      request = '$@' + serializeThenable(request, task, value).toString(16);
       elementReference.set(value, request);
       return request;
     }
@@ -1580,92 +1580,92 @@
         modelRoot = null;
       } else return writtenObjects;
     else if (
-      -1 === parentPropertyName.indexOf(":") &&
+      -1 === parentPropertyName.indexOf(':') &&
       ((writtenObjects = elementReference.get(parent)),
       void 0 !== writtenObjects)
     ) {
       existingReference = parentPropertyName;
       if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
         switch (parentPropertyName) {
-          case "1":
-            existingReference = "type";
+          case '1':
+            existingReference = 'type';
             break;
-          case "2":
-            existingReference = "key";
+          case '2':
+            existingReference = 'key';
             break;
-          case "3":
-            existingReference = "props";
+          case '3':
+            existingReference = 'props';
             break;
-          case "4":
-            existingReference = "_owner";
+          case '4':
+            existingReference = '_owner';
         }
-      elementReference.set(value, writtenObjects + ":" + existingReference);
+      elementReference.set(value, writtenObjects + ':' + existingReference);
     }
     if (isArrayImpl(value)) return renderFragment(request, task, value);
     if (value instanceof Map)
       return (
         (value = Array.from(value)),
-        "$Q" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$Q' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
     if (value instanceof Set)
       return (
         (value = Array.from(value)),
-        "$W" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$W' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
-    if ("function" === typeof FormData && value instanceof FormData)
+    if ('function' === typeof FormData && value instanceof FormData)
       return (
         (value = Array.from(value.entries())),
-        "$K" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$K' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
-    if (value instanceof Error) return "$Z";
+    if (value instanceof Error) return '$Z';
     if (value instanceof ArrayBuffer)
-      return serializeTypedArray(request, "A", new Uint8Array(value));
+      return serializeTypedArray(request, 'A', new Uint8Array(value));
     if (value instanceof Int8Array)
-      return serializeTypedArray(request, "O", value);
+      return serializeTypedArray(request, 'O', value);
     if (value instanceof Uint8Array)
-      return serializeTypedArray(request, "o", value);
+      return serializeTypedArray(request, 'o', value);
     if (value instanceof Uint8ClampedArray)
-      return serializeTypedArray(request, "U", value);
+      return serializeTypedArray(request, 'U', value);
     if (value instanceof Int16Array)
-      return serializeTypedArray(request, "S", value);
+      return serializeTypedArray(request, 'S', value);
     if (value instanceof Uint16Array)
-      return serializeTypedArray(request, "s", value);
+      return serializeTypedArray(request, 's', value);
     if (value instanceof Int32Array)
-      return serializeTypedArray(request, "L", value);
+      return serializeTypedArray(request, 'L', value);
     if (value instanceof Uint32Array)
-      return serializeTypedArray(request, "l", value);
+      return serializeTypedArray(request, 'l', value);
     if (value instanceof Float32Array)
-      return serializeTypedArray(request, "G", value);
+      return serializeTypedArray(request, 'G', value);
     if (value instanceof Float64Array)
-      return serializeTypedArray(request, "g", value);
+      return serializeTypedArray(request, 'g', value);
     if (value instanceof BigInt64Array)
-      return serializeTypedArray(request, "M", value);
+      return serializeTypedArray(request, 'M', value);
     if (value instanceof BigUint64Array)
-      return serializeTypedArray(request, "m", value);
+      return serializeTypedArray(request, 'm', value);
     if (value instanceof DataView)
-      return serializeTypedArray(request, "V", value);
-    if ("function" === typeof Blob && value instanceof Blob)
+      return serializeTypedArray(request, 'V', value);
+    if ('function' === typeof Blob && value instanceof Blob)
       return serializeBlob(request, value);
     if ((elementReference = getIteratorFn(value)))
       return (
         (parentPropertyName = elementReference.call(value)),
         parentPropertyName === value
           ? ((value = Array.from(parentPropertyName)),
-            "$i" +
+            '$i' +
               outlineModelWithFormatContext(request, value, 0).toString(16))
           : renderFragment(request, task, Array.from(parentPropertyName))
       );
-    if ("function" === typeof ReadableStream && value instanceof ReadableStream)
+    if ('function' === typeof ReadableStream && value instanceof ReadableStream)
       return serializeReadableStream(request, task, value);
     elementReference = value[ASYNC_ITERATOR];
-    if ("function" === typeof elementReference)
+    if ('function' === typeof elementReference)
       return (
         null !== task.keyPath
           ? ((request = [
               REACT_ELEMENT_TYPE,
               REACT_FRAGMENT_TYPE,
               task.keyPath,
-              { children: value }
+              { children: value },
             ]),
             (request = task.implicitSlot ? [request] : request))
           : ((parentPropertyName = elementReference.call(value)),
@@ -1673,29 +1673,29 @@
               request,
               task,
               value,
-              parentPropertyName
+              parentPropertyName,
             ))),
         request
       );
-    if (value instanceof Date) return "$D" + value.toJSON();
+    if (value instanceof Date) return '$D' + value.toJSON();
     request = getPrototypeOf(value);
     if (
       request !== ObjectPrototype &&
       (null === request || null !== getPrototypeOf(request))
     )
       throw Error(
-        "Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported." +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+        'Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.' +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     return value;
   }
-  if ("string" === typeof value) {
+  if ('string' === typeof value) {
     serializedSize += value.length;
     if (
-      "Z" === value[value.length - 1] &&
+      'Z' === value[value.length - 1] &&
       parent[parentPropertyName] instanceof Date
     )
-      return "$D" + value;
+      return '$D' + value;
     if (1024 <= value.length && null !== byteLengthOfChunk)
       return (
         request.pendingChunks++,
@@ -1703,35 +1703,35 @@
         emitTextChunk(request, task, value, !1),
         serializeByValueID(task)
       );
-    request = "$" === value[0] ? "$" + value : value;
+    request = '$' === value[0] ? '$' + value : value;
     return request;
   }
-  if ("boolean" === typeof value) return value;
-  if ("number" === typeof value)
+  if ('boolean' === typeof value) return value;
+  if ('number' === typeof value)
     return Number.isFinite(value)
       ? 0 === value && -Infinity === 1 / value
-        ? "$-0"
+        ? '$-0'
         : value
       : Infinity === value
-        ? "$Infinity"
+        ? '$Infinity'
         : -Infinity === value
-          ? "$-Infinity"
-          : "$NaN";
-  if ("undefined" === typeof value) return "$undefined";
-  if ("function" === typeof value) {
+          ? '$-Infinity'
+          : '$NaN';
+  if ('undefined' === typeof value) return '$undefined';
+  if ('function' === typeof value) {
     if (value.$$typeof === CLIENT_REFERENCE_TAG$1)
       return serializeClientReference(
         request,
         parent,
         parentPropertyName,
-        value
+        value,
       );
     if (value.$$typeof === SERVER_REFERENCE_TAG)
       return (
         (task = request.writtenServerReferences),
         (parentPropertyName = task.get(value)),
         void 0 !== parentPropertyName
-          ? (request = "$F" + parentPropertyName.toString(16))
+          ? (request = '$F' + parentPropertyName.toString(16))
           : ((parentPropertyName = value.$$bound),
             (parentPropertyName =
               null === parentPropertyName
@@ -1740,33 +1740,33 @@
             (request = outlineModelWithFormatContext(
               request,
               { id: value.$$id, bound: parentPropertyName },
-              0
+              0,
             )),
             task.set(value, request),
-            (request = "$F" + request.toString(16))),
+            (request = '$F' + request.toString(16))),
         request
       );
     if (
       void 0 !== request.temporaryReferences &&
       ((request = request.temporaryReferences.get(value)), void 0 !== request)
     )
-      return "$T" + request;
+      return '$T' + request;
     if (value.$$typeof === TEMPORARY_REFERENCE_TAG)
       throw Error(
-        "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+        'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
       );
     if (/^on[A-Z]/.test(parentPropertyName))
       throw Error(
-        "Event handlers cannot be passed to Client Component props." +
+        'Event handlers cannot be passed to Client Component props.' +
           describeObjectForErrorMessage(parent, parentPropertyName) +
-          "\nIf you need interactivity, consider converting part of this to a Client Component."
+          '\nIf you need interactivity, consider converting part of this to a Client Component.',
       );
     throw Error(
       'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.' +
-        describeObjectForErrorMessage(parent, parentPropertyName)
+        describeObjectForErrorMessage(parent, parentPropertyName),
     );
   }
-  if ("symbol" === typeof value) {
+  if ('symbol' === typeof value) {
     task = request.writtenSymbols;
     elementReference = task.get(value);
     if (void 0 !== elementReference)
@@ -1774,27 +1774,27 @@
     elementReference = value.description;
     if (Symbol.for(elementReference) !== value)
       throw Error(
-        "Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" +
-          (value.description + ") cannot be found among global symbols.") +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+        'Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(' +
+          (value.description + ') cannot be found among global symbols.') +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     request.pendingChunks++;
     parentPropertyName = request.nextChunkId++;
     parent = encodeReferenceChunk(
       request,
       parentPropertyName,
-      "$S" + elementReference
+      '$S' + elementReference,
     );
     request.completedImportChunks.push(parent);
     task.set(value, parentPropertyName);
     return serializeByValueID(parentPropertyName);
   }
-  if ("bigint" === typeof value) return "$n" + value.toString(10);
+  if ('bigint' === typeof value) return '$n' + value.toString(10);
   throw Error(
-    "Type " +
+    'Type ' +
       typeof value +
-      " is not supported in Client Component props." +
-      describeObjectForErrorMessage(parent, parentPropertyName)
+      ' is not supported in Client Component props.' +
+      describeObjectForErrorMessage(parent, parentPropertyName),
   );
 }
 function logRecoverableError(request, error) {
@@ -1808,13 +1808,13 @@
   } finally {
     currentRequest = prevRequest;
   }
-  if (null != errorDigest && "string" !== typeof errorDigest)
+  if (null != errorDigest && 'string' !== typeof errorDigest)
     throw Error(
       'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
         typeof errorDigest +
-        '" instead'
+        '" instead',
     );
-  return errorDigest || "";
+  return errorDigest || '';
 }
 function fatalError(request, error) {
   var onFatalError = request.onFatalError;
@@ -1823,17 +1823,17 @@
     ? ((request.status = 14), closeWithError(request.destination, error))
     : ((request.status = 13), (request.fatalError = error));
   request.cacheController.abort(
-    Error("The render was aborted due to a fatal error.", { cause: error })
+    Error('The render was aborted due to a fatal error.', { cause: error }),
   );
 }
 function emitErrorChunk(request, id, digest) {
   digest = { digest: digest };
-  id = id.toString(16) + ":E" + stringify(digest) + "\n";
+  id = id.toString(16) + ':E' + stringify(digest) + '\n';
   id = stringToChunk(id);
   request.completedErrorChunks.push(id);
 }
 function emitModelChunk(request, id, json) {
-  id = id.toString(16) + ":" + json + "\n";
+  id = id.toString(16) + ':' + json + '\n';
   id = stringToChunk(id);
   request.completedRegularChunks.push(id);
 }
@@ -1842,56 +1842,56 @@
   debug = new Uint8Array(
     typedArray.buffer,
     typedArray.byteOffset,
-    typedArray.byteLength
+    typedArray.byteLength,
   );
   typedArray = 2048 < typedArray.byteLength ? debug.slice() : debug;
   debug = typedArray.byteLength;
-  id = id.toString(16) + ":" + tag + debug.toString(16) + ",";
+  id = id.toString(16) + ':' + tag + debug.toString(16) + ',';
   id = stringToChunk(id);
   request.completedRegularChunks.push(id, typedArray);
 }
 function emitTextChunk(request, id, text, debug) {
   if (null === byteLengthOfChunk)
     throw Error(
-      "Existence of byteLengthOfChunk should have already been checked. This is a bug in React."
+      'Existence of byteLengthOfChunk should have already been checked. This is a bug in React.',
     );
   debug ? request.pendingDebugChunks++ : request.pendingChunks++;
   text = stringToChunk(text);
   debug = text.byteLength;
-  id = id.toString(16) + ":T" + debug.toString(16) + ",";
+  id = id.toString(16) + ':T' + debug.toString(16) + ',';
   id = stringToChunk(id);
   request.completedRegularChunks.push(id, text);
 }
 function emitChunk(request, task, value) {
   var id = task.id;
-  "string" === typeof value && null !== byteLengthOfChunk
+  'string' === typeof value && null !== byteLengthOfChunk
     ? emitTextChunk(request, id, value, !1)
     : value instanceof ArrayBuffer
-      ? emitTypedArrayChunk(request, id, "A", new Uint8Array(value), !1)
+      ? emitTypedArrayChunk(request, id, 'A', new Uint8Array(value), !1)
       : value instanceof Int8Array
-        ? emitTypedArrayChunk(request, id, "O", value, !1)
+        ? emitTypedArrayChunk(request, id, 'O', value, !1)
         : value instanceof Uint8Array
-          ? emitTypedArrayChunk(request, id, "o", value, !1)
+          ? emitTypedArrayChunk(request, id, 'o', value, !1)
           : value instanceof Uint8ClampedArray
-            ? emitTypedArrayChunk(request, id, "U", value, !1)
+            ? emitTypedArrayChunk(request, id, 'U', value, !1)
             : value instanceof Int16Array
-              ? emitTypedArrayChunk(request, id, "S", value, !1)
+              ? emitTypedArrayChunk(request, id, 'S', value, !1)
               : value instanceof Uint16Array
-                ? emitTypedArrayChunk(request, id, "s", value, !1)
+                ? emitTypedArrayChunk(request, id, 's', value, !1)
                 : value instanceof Int32Array
-                  ? emitTypedArrayChunk(request, id, "L", value, !1)
+                  ? emitTypedArrayChunk(request, id, 'L', value, !1)
                   : value instanceof Uint32Array
-                    ? emitTypedArrayChunk(request, id, "l", value, !1)
+                    ? emitTypedArrayChunk(request, id, 'l', value, !1)
                     : value instanceof Float32Array
-                      ? emitTypedArrayChunk(request, id, "G", value, !1)
+                      ? emitTypedArrayChunk(request, id, 'G', value, !1)
                       : value instanceof Float64Array
-                        ? emitTypedArrayChunk(request, id, "g", value, !1)
+                        ? emitTypedArrayChunk(request, id, 'g', value, !1)
                         : value instanceof BigInt64Array
-                          ? emitTypedArrayChunk(request, id, "M", value, !1)
+                          ? emitTypedArrayChunk(request, id, 'M', value, !1)
                           : value instanceof BigUint64Array
-                            ? emitTypedArrayChunk(request, id, "m", value, !1)
+                            ? emitTypedArrayChunk(request, id, 'm', value, !1)
                             : value instanceof DataView
-                              ? emitTypedArrayChunk(request, id, "V", value, !1)
+                              ? emitTypedArrayChunk(request, id, 'V', value, !1)
                               : ((value = stringify(value, task.toJSON)),
                                 emitModelChunk(request, task.id, value));
 }
@@ -1913,13 +1913,13 @@
         request,
         task,
         emptyRoot,
-        "",
-        task.model
+        '',
+        task.model,
       );
       modelRoot = resolvedModel;
       task.keyPath = null;
       task.implicitSlot = !1;
-      if ("object" === typeof resolvedModel && null !== resolvedModel)
+      if ('object' === typeof resolvedModel && null !== resolvedModel)
         request.writtenObjects.set(resolvedModel, serializeByValueID(task.id)),
           emitChunk(request, task, resolvedModel);
       else {
@@ -1948,9 +1948,9 @@
             ? getSuspendedThenable()
             : thrownValue;
         if (
-          "object" === typeof x &&
+          'object' === typeof x &&
           null !== x &&
-          "function" === typeof x.then
+          'function' === typeof x.then
         ) {
           task.status = 0;
           task.thenableState = getThenableStateAfterSuspending();
@@ -2038,7 +2038,7 @@
         currentView &&
           0 < writtenBytes &&
           (destination.enqueue(
-            new Uint8Array(currentView.buffer, 0, writtenBytes)
+            new Uint8Array(currentView.buffer, 0, writtenBytes),
           ),
           (currentView = null),
           (writtenBytes = 0));
@@ -2048,8 +2048,8 @@
     (12 > request.status &&
       request.cacheController.abort(
         Error(
-          "This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources."
-        )
+          'This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources.',
+        ),
       ),
     null !== request.destination &&
       ((request.status = 14),
@@ -2137,13 +2137,13 @@
           var error =
               void 0 === reason
                 ? Error(
-                    "The render was aborted by the server without a reason."
+                    'The render was aborted by the server without a reason.',
                   )
-                : "object" === typeof reason &&
+                : 'object' === typeof reason &&
                     null !== reason &&
-                    "function" === typeof reason.then
+                    'function' === typeof reason.then
                   ? Error(
-                      "The render was aborted by the server with a promise."
+                      'The render was aborted by the server with a promise.',
                     )
                   : reason,
             digest = logRecoverableError(request, error, null),
@@ -2169,11 +2169,11 @@
     }
 }
 function resolveServerReference(bundlerConfig, id) {
-  var name = "",
+  var name = '',
     resolvedModuleData = bundlerConfig[id];
   if (resolvedModuleData) name = resolvedModuleData.name;
   else {
-    var idx = id.lastIndexOf("#");
+    var idx = id.lastIndexOf('#');
     -1 !== idx &&
       ((name = id.slice(idx + 1)),
       (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -2181,7 +2181,7 @@
       throw Error(
         'Could not find the module "' +
           id +
-          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
       );
   }
   return resolvedModuleData.async
@@ -2191,17 +2191,17 @@
 var chunkCache = new Map();
 function requireAsyncModule(id) {
   var promise = __webpack_require__(id);
-  if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+  if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
     return null;
   promise.then(
     function (value) {
-      promise.status = "fulfilled";
+      promise.status = 'fulfilled';
       promise.value = value;
     },
     function (reason) {
-      promise.status = "rejected";
+      promise.status = 'rejected';
       promise.reason = reason;
-    }
+    },
   );
   return promise;
 }
@@ -2231,13 +2231,13 @@
 }
 function requireModule(metadata) {
   var moduleExports = __webpack_require__(metadata[0]);
-  if (4 === metadata.length && "function" === typeof moduleExports.then)
-    if ("fulfilled" === moduleExports.status)
+  if (4 === metadata.length && 'function' === typeof moduleExports.then)
+    if ('fulfilled' === moduleExports.status)
       moduleExports = moduleExports.value;
     else throw moduleExports.reason;
-  return "*" === metadata[2]
+  return '*' === metadata[2]
     ? moduleExports
-    : "" === metadata[2]
+    : '' === metadata[2]
       ? moduleExports.__esModule
         ? moduleExports.default
         : moduleExports
@@ -2252,16 +2252,16 @@
 Chunk.prototype = Object.create(Promise.prototype);
 Chunk.prototype.then = function (resolve, reject) {
   switch (this.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(this);
   }
   switch (this.status) {
-    case "fulfilled":
+    case 'fulfilled':
       resolve(this.value);
       break;
-    case "pending":
-    case "blocked":
-    case "cyclic":
+    case 'pending':
+    case 'blocked':
+    case 'cyclic':
       resolve &&
         (null === this.value && (this.value = []), this.value.push(resolve));
       reject &&
@@ -2272,41 +2272,41 @@
   }
 };
 function createPendingChunk(response) {
-  return new Chunk("pending", null, null, response);
+  return new Chunk('pending', null, null, response);
 }
 function wakeChunk(listeners, value) {
   for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
 }
 function triggerErrorOnChunk(chunk, error) {
-  if ("pending" !== chunk.status && "blocked" !== chunk.status)
+  if ('pending' !== chunk.status && 'blocked' !== chunk.status)
     chunk.reason.error(error);
   else {
     var listeners = chunk.reason;
-    chunk.status = "rejected";
+    chunk.status = 'rejected';
     chunk.reason = error;
     null !== listeners && wakeChunk(listeners, error);
   }
 }
 function resolveModelChunk(chunk, value, id) {
-  if ("pending" !== chunk.status)
+  if ('pending' !== chunk.status)
     (chunk = chunk.reason),
-      "C" === value[0]
-        ? chunk.close("C" === value ? '"$undefined"' : value.slice(1))
+      'C' === value[0]
+        ? chunk.close('C' === value ? '"$undefined"' : value.slice(1))
         : chunk.enqueueModel(value);
   else {
     var resolveListeners = chunk.value,
       rejectListeners = chunk.reason;
-    chunk.status = "resolved_model";
+    chunk.status = 'resolved_model';
     chunk.value = value;
     chunk.reason = id;
     if (null !== resolveListeners)
       switch ((initializeModelChunk(chunk), chunk.status)) {
-        case "fulfilled":
+        case 'fulfilled':
           wakeChunk(resolveListeners, chunk.value);
           break;
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           if (chunk.value)
             for (value = 0; value < resolveListeners.length; value++)
               chunk.value.push(resolveListeners[value]);
@@ -2317,24 +2317,24 @@
                 chunk.reason.push(rejectListeners[value]);
           } else chunk.reason = rejectListeners;
           break;
-        case "rejected":
+        case 'rejected':
           rejectListeners && wakeChunk(rejectListeners, chunk.reason);
       }
   }
 }
 function createResolvedIteratorResultChunk(response, value, done) {
   return new Chunk(
-    "resolved_model",
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
+    'resolved_model',
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
     -1,
-    response
+    response,
   );
 }
 function resolveIteratorResultChunk(chunk, value, done) {
   resolveModelChunk(
     chunk,
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
-    -1
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
+    -1,
   );
 }
 function loadServerReference$1(
@@ -2343,7 +2343,7 @@
   bound,
   parentChunk,
   parentObject,
-  key
+  key,
 ) {
   var serverReference = resolveServerReference(response._bundlerConfig, id);
   id = preloadModule(serverReference);
@@ -2366,16 +2366,16 @@
       !1,
       response,
       createModel,
-      []
+      [],
     ),
-    createModelReject(parentChunk)
+    createModelReject(parentChunk),
   );
   return null;
 }
 function reviveModel(response, parentObj, parentKey, value, reference) {
-  if ("string" === typeof value)
+  if ('string' === typeof value)
     return parseModelString(response, parentObj, parentKey, value, reference);
-  if ("object" === typeof value && null !== value)
+  if ('object' === typeof value && null !== value)
     if (
       (void 0 !== reference &&
         void 0 !== response._temporaryReferences &&
@@ -2386,16 +2386,16 @@
         value[i] = reviveModel(
           response,
           value,
-          "" + i,
+          '' + i,
           value[i],
-          void 0 !== reference ? reference + ":" + i : void 0
+          void 0 !== reference ? reference + ':' + i : void 0,
         );
     else
       for (i in value)
         hasOwnProperty.call(value, i) &&
           ((parentObj =
-            void 0 !== reference && -1 === i.indexOf(":")
-              ? reference + ":" + i
+            void 0 !== reference && -1 === i.indexOf(':')
+              ? reference + ':' + i
               : void 0),
           (parentObj = reviveModel(response, value, i, value[i], parentObj)),
           void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);
@@ -2410,31 +2410,31 @@
   initializingChunkBlockedModel = null;
   var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),
     resolvedModel = chunk.value;
-  chunk.status = "cyclic";
+  chunk.status = 'cyclic';
   chunk.value = null;
   chunk.reason = null;
   try {
     var rawModel = JSON.parse(resolvedModel),
       value = reviveModel(
         chunk._response,
-        { "": rawModel },
-        "",
+        { '': rawModel },
+        '',
         rawModel,
-        rootReference
+        rootReference,
       );
     if (
       null !== initializingChunkBlockedModel &&
       0 < initializingChunkBlockedModel.deps
     )
-      (initializingChunkBlockedModel.value = value), (chunk.status = "blocked");
+      (initializingChunkBlockedModel.value = value), (chunk.status = 'blocked');
     else {
       var resolveListeners = chunk.value;
-      chunk.status = "fulfilled";
+      chunk.status = 'fulfilled';
       chunk.value = value;
       null !== resolveListeners && wakeChunk(resolveListeners, value);
     }
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   } finally {
     (initializingChunk = prevChunk),
       (initializingChunkBlockedModel = prevBlocked);
@@ -2444,7 +2444,7 @@
   response._closed = !0;
   response._closedReason = error;
   response._chunks.forEach(function (chunk) {
-    "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+    'pending' === chunk.status && triggerErrorOnChunk(chunk, error);
   });
 }
 function getChunk(response, id) {
@@ -2454,9 +2454,9 @@
     ((chunk = response._formData.get(response._prefix + id)),
     (chunk =
       null != chunk
-        ? new Chunk("resolved_model", chunk, id, response)
+        ? new Chunk('resolved_model', chunk, id, response)
         : response._closed
-          ? new Chunk("rejected", null, response._closedReason, response)
+          ? new Chunk('rejected', null, response._closedReason, response)
           : createPendingChunk(response)),
     chunks.set(id, chunk));
   return chunk;
@@ -2468,7 +2468,7 @@
   cyclic,
   response,
   map,
-  path
+  path,
 ) {
   if (initializingChunkBlockedModel) {
     var blocked = initializingChunkBlockedModel;
@@ -2476,17 +2476,17 @@
   } else
     blocked = initializingChunkBlockedModel = {
       deps: cyclic ? 0 : 1,
-      value: null
+      value: null,
     };
   return function (value) {
     for (var i = 1; i < path.length; i++) value = value[path[i]];
     parentObject[key] = map(response, value);
-    "" === key && null === blocked.value && (blocked.value = parentObject[key]);
+    '' === key && null === blocked.value && (blocked.value = parentObject[key]);
     blocked.deps--;
     0 === blocked.deps &&
-      "blocked" === chunk.status &&
+      'blocked' === chunk.status &&
       ((value = chunk.value),
-      (chunk.status = "fulfilled"),
+      (chunk.status = 'fulfilled'),
       (chunk.value = blocked.value),
       null !== value && wakeChunk(value, blocked.value));
   };
@@ -2497,34 +2497,34 @@
   };
 }
 function getOutlinedModel(response, reference, parentObject, key, map) {
-  reference = reference.split(":");
+  reference = reference.split(':');
   var id = parseInt(reference[0], 16);
   id = getChunk(response, id);
   switch (id.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(id);
   }
   switch (id.status) {
-    case "fulfilled":
+    case 'fulfilled':
       parentObject = id.value;
       for (key = 1; key < reference.length; key++)
         parentObject = parentObject[reference[key]];
       return map(response, parentObject);
-    case "pending":
-    case "blocked":
-    case "cyclic":
+    case 'pending':
+    case 'blocked':
+    case 'cyclic':
       var parentChunk = initializingChunk;
       id.then(
         createModelResolver(
           parentChunk,
           parentObject,
           key,
-          "cyclic" === id.status,
+          'cyclic' === id.status,
           response,
           map,
-          reference
+          reference,
         ),
-        createModelReject(parentChunk)
+        createModelReject(parentChunk),
       );
       return null;
     default:
@@ -2549,7 +2549,7 @@
   constructor,
   bytesPerElement,
   parentObject,
-  parentKey
+  parentKey,
 ) {
   reference = parseInt(reference.slice(2), 16);
   reference = response._formData.get(response._prefix + reference);
@@ -2568,21 +2568,21 @@
       !1,
       response,
       createModel,
-      []
+      [],
     ),
-    createModelReject(bytesPerElement)
+    createModelReject(bytesPerElement),
   );
   return null;
 }
 function resolveStream(response, id, stream, controller) {
   var chunks = response._chunks;
-  stream = new Chunk("fulfilled", stream, controller, response);
+  stream = new Chunk('fulfilled', stream, controller, response);
   chunks.set(id, stream);
   response = response._formData.getAll(response._prefix + id);
   for (id = 0; id < response.length; id++)
     (chunks = response[id]),
-      "C" === chunks[0]
-        ? controller.close("C" === chunks ? '"$undefined"' : chunks.slice(1))
+      'C' === chunks[0]
+        ? controller.close('C' === chunks ? '"$undefined"' : chunks.slice(1))
         : controller.enqueueModel(chunks);
 }
 function parseReadableStream(response, reference, type) {
@@ -2592,15 +2592,15 @@
     type: type,
     start: function (c) {
       controller = c;
-    }
+    },
   });
   var previousBlockedChunk = null;
   resolveStream(response, reference, type, {
     enqueueModel: function (json) {
       if (null === previousBlockedChunk) {
-        var chunk = new Chunk("resolved_model", json, -1, response);
+        var chunk = new Chunk('resolved_model', json, -1, response);
         initializeModelChunk(chunk);
-        "fulfilled" === chunk.status
+        'fulfilled' === chunk.status
           ? controller.enqueue(chunk.value)
           : (chunk.then(
               function (v) {
@@ -2608,7 +2608,7 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             ),
             (previousBlockedChunk = chunk));
       } else {
@@ -2620,7 +2620,7 @@
           },
           function (e) {
             return controller.error(e);
-          }
+          },
         );
         previousBlockedChunk = chunk$26;
         chunk.then(function () {
@@ -2648,7 +2648,7 @@
           return controller.error(error);
         });
       }
-    }
+    },
   });
   return type;
 }
@@ -2672,15 +2672,15 @@
       return createIterator(function (arg) {
         if (void 0 !== arg)
           throw Error(
-            "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+            'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
           );
         if (nextReadIndex === buffer.length) {
           if (closed)
             return new Chunk(
-              "fulfilled",
+              'fulfilled',
               { done: !0, value: void 0 },
               null,
-              response
+              response,
             );
           buffer[nextReadIndex] = createPendingChunk(response);
         }
@@ -2695,7 +2695,7 @@
         ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
             response,
             value,
-            !1
+            !1,
           ))
         : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
       nextWriteIndex++;
@@ -2706,14 +2706,14 @@
         ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
             response,
             value,
-            !0
+            !0,
           ))
         : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
       for (nextWriteIndex++; nextWriteIndex < buffer.length; )
         resolveIteratorResultChunk(
           buffer[nextWriteIndex++],
           '"$undefined"',
-          !0
+          !0,
         );
     },
     error: function (error) {
@@ -2725,18 +2725,18 @@
 
       )
         triggerErrorOnChunk(buffer[nextWriteIndex++], error);
-    }
+    },
   });
   return iterator;
 }
 function parseModelString(response, obj, key, value, reference) {
-  if ("$" === value[0]) {
+  if ('$' === value[0]) {
     switch (value[1]) {
-      case "$":
+      case '$':
         return value.slice(1);
-      case "@":
+      case '@':
         return (obj = parseInt(value.slice(2), 16)), getChunk(response, obj);
-      case "F":
+      case 'F':
         return (
           (value = value.slice(2)),
           (value = getOutlinedModel(response, value, obj, key, createModel)),
@@ -2746,96 +2746,96 @@
             value.bound,
             initializingChunk,
             obj,
-            key
+            key,
           )
         );
-      case "T":
+      case 'T':
         if (void 0 === reference || void 0 === response._temporaryReferences)
           throw Error(
-            "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+            'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
           );
         return createTemporaryReference(
           response._temporaryReferences,
-          reference
+          reference,
         );
-      case "Q":
+      case 'Q':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, createMap)
         );
-      case "W":
+      case 'W':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, createSet)
         );
-      case "K":
+      case 'K':
         obj = value.slice(2);
-        var formPrefix = response._prefix + obj + "_",
+        var formPrefix = response._prefix + obj + '_',
           data = new FormData();
         response._formData.forEach(function (entry, entryKey) {
           entryKey.startsWith(formPrefix) &&
             data.append(entryKey.slice(formPrefix.length), entry);
         });
         return data;
-      case "i":
+      case 'i':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, extractIterator)
         );
-      case "I":
+      case 'I':
         return Infinity;
-      case "-":
-        return "$-0" === value ? -0 : -Infinity;
-      case "N":
+      case '-':
+        return '$-0' === value ? -0 : -Infinity;
+      case 'N':
         return NaN;
-      case "u":
+      case 'u':
         return;
-      case "D":
+      case 'D':
         return new Date(Date.parse(value.slice(2)));
-      case "n":
+      case 'n':
         return BigInt(value.slice(2));
     }
     switch (value[1]) {
-      case "A":
+      case 'A':
         return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);
-      case "O":
+      case 'O':
         return parseTypedArray(response, value, Int8Array, 1, obj, key);
-      case "o":
+      case 'o':
         return parseTypedArray(response, value, Uint8Array, 1, obj, key);
-      case "U":
+      case 'U':
         return parseTypedArray(response, value, Uint8ClampedArray, 1, obj, key);
-      case "S":
+      case 'S':
         return parseTypedArray(response, value, Int16Array, 2, obj, key);
-      case "s":
+      case 's':
         return parseTypedArray(response, value, Uint16Array, 2, obj, key);
-      case "L":
+      case 'L':
         return parseTypedArray(response, value, Int32Array, 4, obj, key);
-      case "l":
+      case 'l':
         return parseTypedArray(response, value, Uint32Array, 4, obj, key);
-      case "G":
+      case 'G':
         return parseTypedArray(response, value, Float32Array, 4, obj, key);
-      case "g":
+      case 'g':
         return parseTypedArray(response, value, Float64Array, 8, obj, key);
-      case "M":
+      case 'M':
         return parseTypedArray(response, value, BigInt64Array, 8, obj, key);
-      case "m":
+      case 'm':
         return parseTypedArray(response, value, BigUint64Array, 8, obj, key);
-      case "V":
+      case 'V':
         return parseTypedArray(response, value, DataView, 1, obj, key);
-      case "B":
+      case 'B':
         return (
           (obj = parseInt(value.slice(2), 16)),
           response._formData.get(response._prefix + obj)
         );
     }
     switch (value[1]) {
-      case "R":
+      case 'R':
         return parseReadableStream(response, value, void 0);
-      case "r":
-        return parseReadableStream(response, value, "bytes");
-      case "X":
+      case 'r':
+        return parseReadableStream(response, value, 'bytes');
+      case 'X':
         return parseAsyncIterable(response, value, !1);
-      case "x":
+      case 'x':
         return parseAsyncIterable(response, value, !0);
     }
     value = value.slice(1);
@@ -2856,11 +2856,11 @@
     _chunks: chunks,
     _closed: !1,
     _closedReason: null,
-    _temporaryReferences: temporaryReferences
+    _temporaryReferences: temporaryReferences,
   };
 }
 function close(response) {
-  reportGlobalError(response, Error("Connection closed."));
+  reportGlobalError(response, Error('Connection closed.'));
 }
 function loadServerReference(bundlerConfig, id, bound) {
   var serverReference = resolveServerReference(bundlerConfig, id);
@@ -2882,7 +2882,7 @@
   close(body);
   body = getChunk(body, 0);
   body.then(function () {});
-  if ("fulfilled" !== body.status) throw body.reason;
+  if ('fulfilled' !== body.status) throw body.reason;
   return body.value;
 }
 exports.createClientModuleProxy = function (moduleId) {
@@ -2896,12 +2896,12 @@
   var formData = new FormData(),
     action = null;
   body.forEach(function (value, key) {
-    key.startsWith("$ACTION_")
-      ? key.startsWith("$ACTION_REF_")
-        ? ((value = "$ACTION_" + key.slice(12) + ":"),
+    key.startsWith('$ACTION_')
+      ? key.startsWith('$ACTION_REF_')
+        ? ((value = '$ACTION_' + key.slice(12) + ':'),
           (value = decodeBoundActionMetaData(body, serverManifest, value)),
           (action = loadServerReference(serverManifest, value.id, value.bound)))
-        : key.startsWith("$ACTION_ID_") &&
+        : key.startsWith('$ACTION_ID_') &&
           ((value = key.slice(11)),
           (action = loadServerReference(serverManifest, value, null)))
       : formData.append(key, value);
@@ -2913,12 +2913,12 @@
       });
 };
 exports.decodeFormState = function (actionResult, body, serverManifest) {
-  var keyPath = body.get("$ACTION_KEY");
-  if ("string" !== typeof keyPath) return Promise.resolve(null);
+  var keyPath = body.get('$ACTION_KEY');
+  if ('string' !== typeof keyPath) return Promise.resolve(null);
   var metaData = null;
   body.forEach(function (value, key) {
-    key.startsWith("$ACTION_REF_") &&
-      ((value = "$ACTION_" + key.slice(12) + ":"),
+    key.startsWith('$ACTION_REF_') &&
+      ((value = '$ACTION_' + key.slice(12) + ':'),
       (metaData = decodeBoundActionMetaData(body, serverManifest, value)));
   });
   if (null === metaData) return Promise.resolve(null);
@@ -2930,16 +2930,16 @@
   });
 };
 exports.decodeReply = function (body, webpackMap, options) {
-  if ("string" === typeof body) {
+  if ('string' === typeof body) {
     var form = new FormData();
-    form.append("0", body);
+    form.append('0', body);
     body = form;
   }
   body = createResponse(
     webpackMap,
-    "",
+    '',
     options ? options.temporaryReferences : void 0,
-    body
+    body,
   );
   webpackMap = getChunk(body, 0);
   close(body);
@@ -2948,7 +2948,7 @@
 exports.decodeReplyFromAsyncIterable = function (
   iterable,
   webpackMap,
-  options
+  options,
 ) {
   function progress(entry) {
     if (entry.done) close(response);
@@ -2956,7 +2956,7 @@
       entry = entry.value;
       var name = entry[0];
       entry = entry[1];
-      if ("string" === typeof entry) {
+      if ('string' === typeof entry) {
         response._formData.append(name, entry);
         var prefix = response._prefix;
         if (name.startsWith(prefix)) {
@@ -2970,14 +2970,14 @@
   }
   function error(reason) {
     reportGlobalError(response, reason);
-    "function" === typeof iterator.throw &&
+    'function' === typeof iterator.throw &&
       iterator.throw(reason).then(error, error);
   }
   var iterator = iterable[ASYNC_ITERATOR](),
     response = createResponse(
       webpackMap,
-      "",
-      options ? options.temporaryReferences : void 0
+      '',
+      options ? options.temporaryReferences : void 0,
     );
   iterator.next().then(progress, error);
   return getChunk(response, 0);
@@ -2993,22 +2993,22 @@
       function () {
         var stream = new ReadableStream(
           {
-            type: "bytes",
+            type: 'bytes',
             pull: function (controller) {
               startFlowing(request, controller);
             },
             cancel: function (reason) {
               request.destination = null;
               abort(request, reason);
-            }
+            },
           },
-          { highWaterMark: 0 }
+          { highWaterMark: 0 },
         );
         resolve({ prelude: stream });
       },
       reject,
       options ? options.identifierPrefix : void 0,
-      options ? options.temporaryReferences : void 0
+      options ? options.temporaryReferences : void 0,
     );
     if (options && options.signal) {
       var signal = options.signal;
@@ -3016,9 +3016,9 @@
       else {
         var listener = function () {
           abort(request, signal.reason);
-          signal.removeEventListener("abort", listener);
+          signal.removeEventListener('abort', listener);
         };
-        signal.addEventListener("abort", listener);
+        signal.addEventListener('abort', listener);
       }
     }
     startWork(request);
@@ -3027,23 +3027,23 @@
 exports.registerClientReference = function (
   proxyImplementation,
   id,
-  exportName
+  exportName,
 ) {
   return registerClientReferenceImpl(
     proxyImplementation,
-    id + "#" + exportName,
-    !1
+    id + '#' + exportName,
+    !1,
   );
 };
 exports.registerServerReference = function (reference, id, exportName) {
   return Object.defineProperties(reference, {
     $$typeof: { value: SERVER_REFERENCE_TAG },
     $$id: {
-      value: null === exportName ? id : id + "#" + exportName,
-      configurable: !0
+      value: null === exportName ? id : id + '#' + exportName,
+      configurable: !0,
     },
     $$bound: { value: null, configurable: !0 },
-    bind: { value: bind, configurable: !0 }
+    bind: { value: bind, configurable: !0 },
   });
 };
 exports.renderToReadableStream = function (model, webpackMap, options) {
@@ -3056,7 +3056,7 @@
     noop,
     noop,
     options ? options.identifierPrefix : void 0,
-    options ? options.temporaryReferences : void 0
+    options ? options.temporaryReferences : void 0,
   );
   if (options && options.signal) {
     var signal = options.signal;
@@ -3064,14 +3064,14 @@
     else {
       var listener = function () {
         abort(request, signal.reason);
-        signal.removeEventListener("abort", listener);
+        signal.removeEventListener('abort', listener);
       };
-      signal.addEventListener("abort", listener);
+      signal.addEventListener('abort', listener);
     }
   }
   return new ReadableStream(
     {
-      type: "bytes",
+      type: 'bytes',
       start: function () {
         startWork(request);
       },
@@ -3081,8 +3081,8 @@
       cancel: function (reason) {
         request.destination = null;
         abort(request, reason);
-      }
+      },
     },
-    { highWaterMark: 0 }
+    { highWaterMark: 0 },
   );
 };
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.node.development.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.development.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.node.development.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.development.js	2025-12-17 14:32:44
@@ -8,54 +8,54 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
+'use strict';
+'production' !== process.env.NODE_ENV &&
   (function () {
     function voidHandler() {}
     function getIteratorFn(maybeIterable) {
-      if (null === maybeIterable || "object" !== typeof maybeIterable)
+      if (null === maybeIterable || 'object' !== typeof maybeIterable)
         return null;
       maybeIterable =
         (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-        maybeIterable["@@iterator"];
-      return "function" === typeof maybeIterable ? maybeIterable : null;
+        maybeIterable['@@iterator'];
+      return 'function' === typeof maybeIterable ? maybeIterable : null;
     }
     function _defineProperty(obj, key, value) {
-      a: if ("object" == typeof key && key) {
+      a: if ('object' == typeof key && key) {
         var e = key[Symbol.toPrimitive];
         if (void 0 !== e) {
-          key = e.call(key, "string");
-          if ("object" != typeof key) break a;
-          throw new TypeError("@@toPrimitive must return a primitive value.");
+          key = e.call(key, 'string');
+          if ('object' != typeof key) break a;
+          throw new TypeError('@@toPrimitive must return a primitive value.');
         }
         key = String(key);
       }
-      key = "symbol" == typeof key ? key : key + "";
+      key = 'symbol' == typeof key ? key : key + '';
       key in obj
         ? Object.defineProperty(obj, key, {
             value: value,
             enumerable: !0,
             configurable: !0,
-            writable: !0
+            writable: !0,
           })
         : (obj[key] = value);
       return obj;
     }
     function flushBuffered(destination) {
-      "function" === typeof destination.flush && destination.flush();
+      'function' === typeof destination.flush && destination.flush();
     }
     function writeToDestination(destination, view) {
       destination = destination.write(view);
       destinationHasCapacity = destinationHasCapacity && destination;
     }
     function writeChunkAndReturn(destination, chunk) {
-      if ("string" === typeof chunk) {
+      if ('string' === typeof chunk) {
         if (0 !== chunk.length)
           if (2048 < 3 * chunk.length)
             0 < writtenBytes &&
               (writeToDestination(
                 destination,
-                currentView.subarray(0, writtenBytes)
+                currentView.subarray(0, writtenBytes),
               ),
               (currentView = new Uint8Array(2048)),
               (writtenBytes = 0)),
@@ -69,12 +69,12 @@
             read < chunk.length &&
               (writeToDestination(
                 destination,
-                currentView.subarray(0, writtenBytes)
+                currentView.subarray(0, writtenBytes),
               ),
               (currentView = new Uint8Array(2048)),
               (writtenBytes = textEncoder.encodeInto(
                 chunk.slice(read),
-                currentView
+                currentView,
               ).written));
             2048 === writtenBytes &&
               (writeToDestination(destination, currentView),
@@ -87,7 +87,7 @@
             ? (0 < writtenBytes &&
                 (writeToDestination(
                   destination,
-                  currentView.subarray(0, writtenBytes)
+                  currentView.subarray(0, writtenBytes),
                 ),
                 (currentView = new Uint8Array(2048)),
                 (writtenBytes = 0)),
@@ -119,8 +119,8 @@
       destinationHasCapacity = !0;
     }
     function byteLengthOfChunk(chunk) {
-      return "string" === typeof chunk
-        ? Buffer.byteLength(chunk, "utf8")
+      return 'string' === typeof chunk
+        ? Buffer.byteLength(chunk, 'utf8')
         : chunk.byteLength;
     }
     function isClientReference(reference) {
@@ -130,7 +130,7 @@
       return Object.defineProperties(proxyImplementation, {
         $$typeof: { value: CLIENT_REFERENCE_TAG$1 },
         $$id: { value: id },
-        $$async: { value: async }
+        $$async: { value: async },
       });
     }
     function bind() {
@@ -138,7 +138,7 @@
       if (this.$$typeof === SERVER_REFERENCE_TAG) {
         null != arguments[0] &&
           console.error(
-            'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().'
+            'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().',
           );
         var args = ArraySlice.call(arguments, 1),
           $$typeof = { value: SERVER_REFERENCE_TAG },
@@ -149,95 +149,95 @@
           $$id: $$id,
           $$bound: args,
           $$location: { value: this.$$location, configurable: !0 },
-          bind: { value: bind, configurable: !0 }
+          bind: { value: bind, configurable: !0 },
         });
       }
       return newFn;
     }
     function getReference(target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "$$id":
+        case '$$id':
           return target.$$id;
-        case "$$async":
+        case '$$async':
           return target.$$async;
-        case "name":
+        case 'name':
           return target.name;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "__esModule":
+        case '__esModule':
           var moduleId = target.$$id;
           target.default = registerClientReferenceImpl(
             function () {
               throw Error(
-                "Attempted to call the default export of " +
+                'Attempted to call the default export of ' +
                   moduleId +
-                  " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+                  " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
               );
             },
-            target.$$id + "#",
-            target.$$async
+            target.$$id + '#',
+            target.$$async,
           );
           return !0;
-        case "then":
+        case 'then':
           if (target.then) return target.then;
           if (target.$$async) return;
           var clientReference = registerClientReferenceImpl(
               {},
               target.$$id,
-              !0
+              !0,
             ),
             proxy = new Proxy(clientReference, proxyHandlers$1);
-          target.status = "fulfilled";
+          target.status = 'fulfilled';
           target.value = proxy;
           return (target.then = registerClientReferenceImpl(
             function (resolve) {
               return Promise.resolve(resolve(proxy));
             },
-            target.$$id + "#then",
-            !1
+            target.$$id + '#then',
+            !1,
           ));
       }
-      if ("symbol" === typeof name)
+      if ('symbol' === typeof name)
         throw Error(
-          "Cannot read Symbol exports. Only named exports are supported on a client module imported on the server."
+          'Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.',
         );
       clientReference = target[name];
       clientReference ||
         ((clientReference = registerClientReferenceImpl(
           function () {
             throw Error(
-              "Attempted to call " +
+              'Attempted to call ' +
                 String(name) +
-                "() from the server but " +
+                '() from the server but ' +
                 String(name) +
-                " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+                " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
             );
           },
-          target.$$id + "#" + name,
-          target.$$async
+          target.$$id + '#' + name,
+          target.$$async,
         )),
-        Object.defineProperty(clientReference, "name", { value: name }),
+        Object.defineProperty(clientReference, 'name', { value: name }),
         (clientReference = target[name] =
           new Proxy(clientReference, deepProxyHandlers)));
       return clientReference;
     }
     function resolveClientReferenceMetadata(config, clientReference) {
       var modulePath = clientReference.$$id,
-        name = "",
+        name = '',
         resolvedModuleData = config[modulePath];
       if (resolvedModuleData) name = resolvedModuleData.name;
       else {
-        var idx = modulePath.lastIndexOf("#");
+        var idx = modulePath.lastIndexOf('#');
         -1 !== idx &&
           ((name = modulePath.slice(idx + 1)),
           (resolvedModuleData = config[modulePath.slice(0, idx)]));
@@ -245,55 +245,55 @@
           throw Error(
             'Could not find the module "' +
               modulePath +
-              '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.'
+              '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.',
           );
       }
       if (!0 === resolvedModuleData.async && !0 === clientReference.$$async)
         throw Error(
           'The module "' +
             modulePath +
-            '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.'
+            '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.',
         );
       return !0 === resolvedModuleData.async || !0 === clientReference.$$async
         ? [resolvedModuleData.id, resolvedModuleData.chunks, name, 1]
         : [resolvedModuleData.id, resolvedModuleData.chunks, name];
     }
     function preload(href, as, options) {
-      if ("string" === typeof href) {
+      if ('string' === typeof href) {
         var request = resolveRequest();
         if (request) {
           var hints = request.hints,
-            key = "L";
-          if ("image" === as && options) {
+            key = 'L';
+          if ('image' === as && options) {
             var imageSrcSet = options.imageSrcSet,
               imageSizes = options.imageSizes,
-              uniquePart = "";
-            "string" === typeof imageSrcSet && "" !== imageSrcSet
-              ? ((uniquePart += "[" + imageSrcSet + "]"),
-                "string" === typeof imageSizes &&
-                  (uniquePart += "[" + imageSizes + "]"))
-              : (uniquePart += "[][]" + href);
-            key += "[image]" + uniquePart;
-          } else key += "[" + as + "]" + href;
+              uniquePart = '';
+            'string' === typeof imageSrcSet && '' !== imageSrcSet
+              ? ((uniquePart += '[' + imageSrcSet + ']'),
+                'string' === typeof imageSizes &&
+                  (uniquePart += '[' + imageSizes + ']'))
+              : (uniquePart += '[][]' + href);
+            key += '[image]' + uniquePart;
+          } else key += '[' + as + ']' + href;
           hints.has(key) ||
             (hints.add(key),
             (options = trimOptions(options))
-              ? emitHint(request, "L", [href, as, options])
-              : emitHint(request, "L", [href, as]));
+              ? emitHint(request, 'L', [href, as, options])
+              : emitHint(request, 'L', [href, as]));
         } else previousDispatcher.L(href, as, options);
       }
     }
     function preloadModule$1(href, options) {
-      if ("string" === typeof href) {
+      if ('string' === typeof href) {
         var request = resolveRequest();
         if (request) {
           var hints = request.hints,
-            key = "m|" + href;
+            key = 'm|' + href;
           if (hints.has(key)) return;
           hints.add(key);
           return (options = trimOptions(options))
-            ? emitHint(request, "m", [href, options])
-            : emitHint(request, "m", href);
+            ? emitHint(request, 'm', [href, options])
+            : emitHint(request, 'm', href);
         }
         previousDispatcher.m(href, options);
       }
@@ -310,63 +310,63 @@
     }
     function getChildFormatContext(parentContext, type, props) {
       switch (type) {
-        case "img":
+        case 'img':
           type = props.src;
           var srcSet = props.srcSet;
           if (
             !(
-              "lazy" === props.loading ||
+              'lazy' === props.loading ||
               (!type && !srcSet) ||
-              ("string" !== typeof type && null != type) ||
-              ("string" !== typeof srcSet && null != srcSet) ||
-              "low" === props.fetchPriority ||
+              ('string' !== typeof type && null != type) ||
+              ('string' !== typeof srcSet && null != srcSet) ||
+              'low' === props.fetchPriority ||
               parentContext & 3
             ) &&
-            ("string" !== typeof type ||
-              ":" !== type[4] ||
-              ("d" !== type[0] && "D" !== type[0]) ||
-              ("a" !== type[1] && "A" !== type[1]) ||
-              ("t" !== type[2] && "T" !== type[2]) ||
-              ("a" !== type[3] && "A" !== type[3])) &&
-            ("string" !== typeof srcSet ||
-              ":" !== srcSet[4] ||
-              ("d" !== srcSet[0] && "D" !== srcSet[0]) ||
-              ("a" !== srcSet[1] && "A" !== srcSet[1]) ||
-              ("t" !== srcSet[2] && "T" !== srcSet[2]) ||
-              ("a" !== srcSet[3] && "A" !== srcSet[3]))
+            ('string' !== typeof type ||
+              ':' !== type[4] ||
+              ('d' !== type[0] && 'D' !== type[0]) ||
+              ('a' !== type[1] && 'A' !== type[1]) ||
+              ('t' !== type[2] && 'T' !== type[2]) ||
+              ('a' !== type[3] && 'A' !== type[3])) &&
+            ('string' !== typeof srcSet ||
+              ':' !== srcSet[4] ||
+              ('d' !== srcSet[0] && 'D' !== srcSet[0]) ||
+              ('a' !== srcSet[1] && 'A' !== srcSet[1]) ||
+              ('t' !== srcSet[2] && 'T' !== srcSet[2]) ||
+              ('a' !== srcSet[3] && 'A' !== srcSet[3]))
           ) {
-            var sizes = "string" === typeof props.sizes ? props.sizes : void 0;
+            var sizes = 'string' === typeof props.sizes ? props.sizes : void 0;
             var input = props.crossOrigin;
-            preload(type || "", "image", {
+            preload(type || '', 'image', {
               imageSrcSet: srcSet,
               imageSizes: sizes,
               crossOrigin:
-                "string" === typeof input
-                  ? "use-credentials" === input
+                'string' === typeof input
+                  ? 'use-credentials' === input
                     ? input
-                    : ""
+                    : ''
                   : void 0,
               integrity: props.integrity,
               type: props.type,
               fetchPriority: props.fetchPriority,
-              referrerPolicy: props.referrerPolicy
+              referrerPolicy: props.referrerPolicy,
             });
           }
           return parentContext;
-        case "link":
+        case 'link':
           type = props.rel;
           srcSet = props.href;
           if (
             !(
               parentContext & 1 ||
               null != props.itemProp ||
-              "string" !== typeof type ||
-              "string" !== typeof srcSet ||
-              "" === srcSet
+              'string' !== typeof type ||
+              'string' !== typeof srcSet ||
+              '' === srcSet
             )
           )
             switch (type) {
-              case "preload":
+              case 'preload':
                 preload(srcSet, props.as, {
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
@@ -376,32 +376,32 @@
                   referrerPolicy: props.referrerPolicy,
                   imageSrcSet: props.imageSrcSet,
                   imageSizes: props.imageSizes,
-                  media: props.media
+                  media: props.media,
                 });
                 break;
-              case "modulepreload":
+              case 'modulepreload':
                 preloadModule$1(srcSet, {
                   as: props.as,
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
-                  nonce: props.nonce
+                  nonce: props.nonce,
                 });
                 break;
-              case "stylesheet":
-                preload(srcSet, "stylesheet", {
+              case 'stylesheet':
+                preload(srcSet, 'stylesheet', {
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
                   nonce: props.nonce,
                   type: props.type,
                   fetchPriority: props.fetchPriority,
                   referrerPolicy: props.referrerPolicy,
-                  media: props.media
+                  media: props.media,
                 });
             }
           return parentContext;
-        case "picture":
+        case 'picture':
           return parentContext | 2;
-        case "noscript":
+        case 'noscript':
           return parentContext | 1;
         default:
           return parentContext;
@@ -429,51 +429,51 @@
       error = [];
       for (var i = framesToSkip; i < structuredStackTrace.length; i++) {
         var callSite = structuredStackTrace[i],
-          name = callSite.getFunctionName() || "<anonymous>";
-        if (name.includes("react_stack_bottom_frame")) break;
+          name = callSite.getFunctionName() || '<anonymous>';
+        if (name.includes('react_stack_bottom_frame')) break;
         else if (callSite.isNative())
           (callSite = callSite.isAsync()),
-            error.push([name, "", 0, 0, 0, 0, callSite]);
+            error.push([name, '', 0, 0, 0, 0, callSite]);
         else {
-          if (callSite.isConstructor()) name = "new " + name;
+          if (callSite.isConstructor()) name = 'new ' + name;
           else if (!callSite.isToplevel()) {
             var callSite$jscomp$0 = callSite;
             name = callSite$jscomp$0.getTypeName();
             var methodName = callSite$jscomp$0.getMethodName();
             callSite$jscomp$0 = callSite$jscomp$0.getFunctionName();
-            var result = "";
+            var result = '';
             callSite$jscomp$0
               ? (name &&
                   identifierRegExp.test(callSite$jscomp$0) &&
                   callSite$jscomp$0 !== name &&
-                  (result += name + "."),
+                  (result += name + '.'),
                 (result += callSite$jscomp$0),
                 !methodName ||
                   callSite$jscomp$0 === methodName ||
-                  callSite$jscomp$0.endsWith("." + methodName) ||
-                  callSite$jscomp$0.endsWith(" " + methodName) ||
-                  (result += " [as " + methodName + "]"))
-              : (name && (result += name + "."),
+                  callSite$jscomp$0.endsWith('.' + methodName) ||
+                  callSite$jscomp$0.endsWith(' ' + methodName) ||
+                  (result += ' [as ' + methodName + ']'))
+              : (name && (result += name + '.'),
                 (result = methodName
                   ? result + methodName
-                  : result + "<anonymous>"));
+                  : result + '<anonymous>'));
             name = result;
           }
-          "<anonymous>" === name && (name = "");
-          methodName = callSite.getScriptNameOrSourceURL() || "<anonymous>";
-          "<anonymous>" === methodName &&
-            ((methodName = ""),
+          '<anonymous>' === name && (name = '');
+          methodName = callSite.getScriptNameOrSourceURL() || '<anonymous>';
+          '<anonymous>' === methodName &&
+            ((methodName = ''),
             callSite.isEval() &&
               (callSite$jscomp$0 = callSite.getEvalOrigin()) &&
-              (methodName = callSite$jscomp$0.toString() + ", <anonymous>"));
+              (methodName = callSite$jscomp$0.toString() + ', <anonymous>'));
           callSite$jscomp$0 = callSite.getLineNumber() || 0;
           result = callSite.getColumnNumber() || 0;
           var enclosingLine =
-              "function" === typeof callSite.getEnclosingLineNumber
+              'function' === typeof callSite.getEnclosingLineNumber
                 ? callSite.getEnclosingLineNumber() || 0
                 : 0,
             enclosingCol =
-              "function" === typeof callSite.getEnclosingColumnNumber
+              'function' === typeof callSite.getEnclosingColumnNumber
                 ? callSite.getEnclosingColumnNumber() || 0
                 : 0;
           callSite = callSite.isAsync();
@@ -484,18 +484,18 @@
             result,
             enclosingLine,
             enclosingCol,
-            callSite
+            callSite,
           ]);
         }
       }
       collectedStackTrace = error;
-      return "";
+      return '';
     }
     function collectStackTrace(error, structuredStackTrace) {
       collectStackTracePrivate(error, structuredStackTrace);
-      error = (error.name || "Error") + ": " + (error.message || "");
+      error = (error.name || 'Error') + ': ' + (error.message || '');
       for (var i = 0; i < structuredStackTrace.length; i++)
-        error += "\n    at " + structuredStackTrace[i].toString();
+        error += '\n    at ' + structuredStackTrace[i].toString();
       return error;
     }
     function parseStackTracePrivate(error, skipFrames) {
@@ -504,7 +504,7 @@
       skipFrames = Error.prepareStackTrace;
       Error.prepareStackTrace = collectStackTracePrivate;
       try {
-        if ("" !== error.stack) return null;
+        if ('' !== error.stack) return null;
       } finally {
         Error.prepareStackTrace = skipFrames;
       }
@@ -529,23 +529,23 @@
           stackTraceCache.set(error, stack),
           stack
         );
-      stack.startsWith("Error: react-stack-top-frame\n") &&
+      stack.startsWith('Error: react-stack-top-frame\n') &&
         (stack = stack.slice(29));
-      existing = stack.indexOf("react_stack_bottom_frame");
-      -1 !== existing && (existing = stack.lastIndexOf("\n", existing));
+      existing = stack.indexOf('react_stack_bottom_frame');
+      -1 !== existing && (existing = stack.lastIndexOf('\n', existing));
       -1 !== existing && (stack = stack.slice(0, existing));
-      stack = stack.split("\n");
+      stack = stack.split('\n');
       for (existing = []; skipFrames < stack.length; skipFrames++) {
         var parsed = frameRegExp.exec(stack[skipFrames]);
         if (parsed) {
-          var name = parsed[1] || "",
-            isAsync = "async " === parsed[8];
-          "<anonymous>" === name
-            ? (name = "")
-            : name.startsWith("async ") &&
+          var name = parsed[1] || '',
+            isAsync = 'async ' === parsed[8];
+          '<anonymous>' === name
+            ? (name = '')
+            : name.startsWith('async ') &&
               ((name = name.slice(5)), (isAsync = !0));
-          var filename = parsed[2] || parsed[5] || "";
-          "<anonymous>" === filename && (filename = "");
+          var filename = parsed[2] || parsed[5] || '';
+          '<anonymous>' === filename && (filename = '');
           existing.push([
             name,
             filename,
@@ -553,7 +553,7 @@
             +(parsed[4] || parsed[7]),
             0,
             0,
-            isAsync
+            isAsync,
           ]);
         }
       }
@@ -564,10 +564,10 @@
       var reference = Object.defineProperties(
         function () {
           throw Error(
-            "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+            "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
           );
         },
-        { $$typeof: { value: TEMPORARY_REFERENCE_TAG } }
+        { $$typeof: { value: TEMPORARY_REFERENCE_TAG } },
       );
       reference = new Proxy(reference, proxyHandlers);
       temporaryReferences.set(reference, id);
@@ -581,35 +581,35 @@
           (thenableState._stacks || (thenableState._stacks = [])).push(Error()))
         : index !== thenable && (thenable.then(noop, noop), (thenable = index));
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return thenable.value;
-        case "rejected":
+        case 'rejected':
           throw thenable.reason;
         default:
-          "string" === typeof thenable.status
+          'string' === typeof thenable.status
             ? thenable.then(noop, noop)
             : ((thenableState = thenable),
-              (thenableState.status = "pending"),
+              (thenableState.status = 'pending'),
               thenableState.then(
                 function (fulfilledValue) {
-                  if ("pending" === thenable.status) {
+                  if ('pending' === thenable.status) {
                     var fulfilledThenable = thenable;
-                    fulfilledThenable.status = "fulfilled";
+                    fulfilledThenable.status = 'fulfilled';
                     fulfilledThenable.value = fulfilledValue;
                   }
                 },
                 function (error) {
-                  if ("pending" === thenable.status) {
+                  if ('pending' === thenable.status) {
                     var rejectedThenable = thenable;
-                    rejectedThenable.status = "rejected";
+                    rejectedThenable.status = 'rejected';
                     rejectedThenable.reason = error;
                   }
-                }
+                },
               ));
           switch (thenable.status) {
-            case "fulfilled":
+            case 'fulfilled':
               return thenable.value;
-            case "rejected":
+            case 'rejected':
               throw thenable.reason;
           }
           suspendedThenable = thenable;
@@ -619,7 +619,7 @@
     function getSuspendedThenable() {
       if (null === suspendedThenable)
         throw Error(
-          "Expected a suspended thenable. This is a bug in React. Please file an issue."
+          'Expected a suspended thenable. This is a bug in React. Please file an issue.',
         );
       var thenable = suspendedThenable;
       suspendedThenable = null;
@@ -632,20 +632,20 @@
       return state;
     }
     function unsupportedHook() {
-      throw Error("This Hook is not supported in Server Components.");
+      throw Error('This Hook is not supported in Server Components.');
     }
     function unsupportedRefresh() {
       throw Error(
-        "Refreshing the cache is not supported in Server Components."
+        'Refreshing the cache is not supported in Server Components.',
       );
     }
     function unsupportedContext() {
-      throw Error("Cannot read a Client Context from a Server Component.");
+      throw Error('Cannot read a Client Context from a Server Component.');
     }
     function prepareStackTrace(error, structuredStackTrace) {
-      error = (error.name || "Error") + ": " + (error.message || "");
+      error = (error.name || 'Error') + ': ' + (error.message || '');
       for (var i = 0; i < structuredStackTrace.length; i++)
-        error += "\n    at " + structuredStackTrace[i].toString();
+        error += '\n    at ' + structuredStackTrace[i].toString();
       return error;
     }
     function resetOwnerStackLimit() {
@@ -669,7 +669,7 @@
       var descriptor = Object.getOwnPropertyDescriptor(object, name);
       return void 0 === descriptor
         ? isGetter(getPrototypeOf(object), name)
-        : "function" === typeof descriptor.get;
+        : 'function' === typeof descriptor.get;
     }
     function isSimpleObject(object) {
       if (!isObjectPrototype(getPrototypeOf(object))) return !1;
@@ -682,8 +682,8 @@
         if (
           !descriptor ||
           (!descriptor.enumerable &&
-            (("key" !== names[i] && "ref" !== names[i]) ||
-              "function" !== typeof descriptor.get))
+            (('key' !== names[i] && 'ref' !== names[i]) ||
+              'function' !== typeof descriptor.get))
         )
           return !1;
       }
@@ -699,35 +699,35 @@
     }
     function describeValueForErrorMessage(value) {
       switch (typeof value) {
-        case "string":
+        case 'string':
           return JSON.stringify(
-            10 >= value.length ? value : value.slice(0, 10) + "..."
+            10 >= value.length ? value : value.slice(0, 10) + '...',
           );
-        case "object":
-          if (isArrayImpl(value)) return "[...]";
+        case 'object':
+          if (isArrayImpl(value)) return '[...]';
           if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-            return "client";
+            return 'client';
           value = objectName(value);
-          return "Object" === value ? "{...}" : value;
-        case "function":
+          return 'Object' === value ? '{...}' : value;
+        case 'function':
           return value.$$typeof === CLIENT_REFERENCE_TAG
-            ? "client"
+            ? 'client'
             : (value = value.displayName || value.name)
-              ? "function " + value
-              : "function";
+              ? 'function ' + value
+              : 'function';
         default:
           return String(value);
       }
     }
     function describeElementType(type) {
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (type.$$typeof) {
           case REACT_FORWARD_REF_TYPE:
             return describeElementType(type.render);
@@ -740,74 +740,74 @@
               return describeElementType(type(payload));
             } catch (x) {}
         }
-      return "";
+      return '';
     }
     function describeObjectForErrorMessage(objectOrArray, expandedName) {
       var objKind = objectName(objectOrArray);
-      if ("Object" !== objKind && "Array" !== objKind) return objKind;
+      if ('Object' !== objKind && 'Array' !== objKind) return objKind;
       var start = -1,
         length = 0;
       if (isArrayImpl(objectOrArray))
         if (jsxChildrenParents.has(objectOrArray)) {
           var type = jsxChildrenParents.get(objectOrArray);
-          objKind = "<" + describeElementType(type) + ">";
+          objKind = '<' + describeElementType(type) + '>';
           for (var i = 0; i < objectOrArray.length; i++) {
             var value = objectOrArray[i];
             value =
-              "string" === typeof value
+              'string' === typeof value
                 ? value
-                : "object" === typeof value && null !== value
-                  ? "{" + describeObjectForErrorMessage(value) + "}"
-                  : "{" + describeValueForErrorMessage(value) + "}";
-            "" + i === expandedName
+                : 'object' === typeof value && null !== value
+                  ? '{' + describeObjectForErrorMessage(value) + '}'
+                  : '{' + describeValueForErrorMessage(value) + '}';
+            '' + i === expandedName
               ? ((start = objKind.length),
                 (length = value.length),
                 (objKind += value))
               : (objKind =
                   15 > value.length && 40 > objKind.length + value.length
                     ? objKind + value
-                    : objKind + "{...}");
+                    : objKind + '{...}');
           }
-          objKind += "</" + describeElementType(type) + ">";
+          objKind += '</' + describeElementType(type) + '>';
         } else {
-          objKind = "[";
+          objKind = '[';
           for (type = 0; type < objectOrArray.length; type++)
-            0 < type && (objKind += ", "),
+            0 < type && (objKind += ', '),
               (i = objectOrArray[type]),
               (i =
-                "object" === typeof i && null !== i
+                'object' === typeof i && null !== i
                   ? describeObjectForErrorMessage(i)
                   : describeValueForErrorMessage(i)),
-              "" + type === expandedName
+              '' + type === expandedName
                 ? ((start = objKind.length),
                   (length = i.length),
                   (objKind += i))
                 : (objKind =
                     10 > i.length && 40 > objKind.length + i.length
                       ? objKind + i
-                      : objKind + "...");
-          objKind += "]";
+                      : objKind + '...');
+          objKind += ']';
         }
       else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-        objKind = "<" + describeElementType(objectOrArray.type) + "/>";
+        objKind = '<' + describeElementType(objectOrArray.type) + '/>';
       else {
-        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
         if (jsxPropsParents.has(objectOrArray)) {
           objKind = jsxPropsParents.get(objectOrArray);
-          objKind = "<" + (describeElementType(objKind) || "...");
+          objKind = '<' + (describeElementType(objKind) || '...');
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++) {
-            objKind += " ";
+            objKind += ' ';
             value = type[i];
-            objKind += describeKeyForErrorMessage(value) + "=";
+            objKind += describeKeyForErrorMessage(value) + '=';
             var _value2 = objectOrArray[value];
             var _substr2 =
               value === expandedName &&
-              "object" === typeof _value2 &&
+              'object' === typeof _value2 &&
               null !== _value2
                 ? describeObjectForErrorMessage(_value2)
                 : describeValueForErrorMessage(_value2);
-            "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
+            'string' !== typeof _value2 && (_substr2 = '{' + _substr2 + '}');
             value === expandedName
               ? ((start = objKind.length),
                 (length = _substr2.length),
@@ -815,19 +815,19 @@
               : (objKind =
                   10 > _substr2.length && 40 > objKind.length + _substr2.length
                     ? objKind + _substr2
-                    : objKind + "...");
+                    : objKind + '...');
           }
-          objKind += ">";
+          objKind += '>';
         } else {
-          objKind = "{";
+          objKind = '{';
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++)
-            0 < i && (objKind += ", "),
+            0 < i && (objKind += ', '),
               (value = type[i]),
-              (objKind += describeKeyForErrorMessage(value) + ": "),
+              (objKind += describeKeyForErrorMessage(value) + ': '),
               (_value2 = objectOrArray[value]),
               (_value2 =
-                "object" === typeof _value2 && null !== _value2
+                'object' === typeof _value2 && null !== _value2
                   ? describeObjectForErrorMessage(_value2)
                   : describeValueForErrorMessage(_value2)),
               value === expandedName
@@ -837,45 +837,45 @@
                 : (objKind =
                     10 > _value2.length && 40 > objKind.length + _value2.length
                       ? objKind + _value2
-                      : objKind + "...");
-          objKind += "}";
+                      : objKind + '...');
+          objKind += '}';
         }
       }
       return void 0 === expandedName
         ? objKind
         : -1 < start && 0 < length
-          ? ((objectOrArray = " ".repeat(start) + "^".repeat(length)),
-            "\n  " + objKind + "\n  " + objectOrArray)
-          : "\n  " + objKind;
+          ? ((objectOrArray = ' '.repeat(start) + '^'.repeat(length)),
+            '\n  ' + objKind + '\n  ' + objectOrArray)
+          : '\n  ' + objKind;
     }
     function defaultFilterStackFrame(filename) {
       return (
-        "" !== filename &&
-        !filename.startsWith("node:") &&
-        !filename.includes("node_modules")
+        '' !== filename &&
+        !filename.startsWith('node:') &&
+        !filename.includes('node_modules')
       );
     }
     function devirtualizeURL(url) {
-      if (url.startsWith("about://React/")) {
-        var envIdx = url.indexOf("/", 14),
-          suffixIdx = url.lastIndexOf("?");
+      if (url.startsWith('about://React/')) {
+        var envIdx = url.indexOf('/', 14),
+          suffixIdx = url.lastIndexOf('?');
         if (-1 < envIdx && -1 < suffixIdx)
           return decodeURI(url.slice(envIdx + 1, suffixIdx));
       }
       return url;
     }
     function isPromiseCreationInternal(url, functionName) {
-      if ("node:internal/async_hooks" === url) return !0;
-      if ("" !== url) return !1;
+      if ('node:internal/async_hooks' === url) return !0;
+      if ('' !== url) return !1;
       switch (functionName) {
-        case "new Promise":
-        case "Function.withResolvers":
-        case "Function.reject":
-        case "Function.resolve":
-        case "Function.all":
-        case "Function.allSettled":
-        case "Function.race":
-        case "Function.try":
+        case 'new Promise':
+        case 'Function.withResolvers':
+        case 'Function.reject':
+        case 'Function.resolve':
+        case 'Function.all':
+        case 'Function.allSettled':
+        case 'Function.race':
+        case 'Function.try':
           return !0;
         default:
           return !1;
@@ -911,18 +911,18 @@
       return !1;
     }
     function isPromiseAwaitInternal(url, functionName) {
-      if ("node:internal/async_hooks" === url) return !0;
-      if ("" !== url) return !1;
+      if ('node:internal/async_hooks' === url) return !0;
+      if ('' !== url) return !1;
       switch (functionName) {
-        case "Promise.then":
-        case "Promise.catch":
-        case "Promise.finally":
-        case "Function.reject":
-        case "Function.resolve":
-        case "Function.all":
-        case "Function.allSettled":
-        case "Function.race":
-        case "Function.try":
+        case 'Promise.then':
+        case 'Promise.catch':
+        case 'Promise.finally':
+        case 'Function.reject':
+        case 'Function.resolve':
+        case 'Function.all':
+        case 'Function.allSettled':
+        case 'Function.race':
+        case 'Function.try':
           return !0;
         default:
           return !1;
@@ -950,16 +950,16 @@
       if (
         descriptor &&
         (descriptor.configurable || descriptor.writable) &&
-        "function" === typeof descriptor.value
+        'function' === typeof descriptor.value
       ) {
         var originalMethod = descriptor.value;
-        descriptor = Object.getOwnPropertyDescriptor(originalMethod, "name");
+        descriptor = Object.getOwnPropertyDescriptor(originalMethod, 'name');
         var wrapperMethod = function () {
           var request = resolveRequest();
-          if (("assert" !== methodName || !arguments[0]) && null !== request) {
+          if (('assert' !== methodName || !arguments[0]) && null !== request) {
             var stack = filterStackTrace(
               request,
-              parseStackTracePrivate(Error("react-stack-top-frame"), 1) || []
+              parseStackTracePrivate(Error('react-stack-top-frame'), 1) || [],
             );
             request.pendingDebugChunks++;
             var owner = resolveOwner(),
@@ -967,25 +967,25 @@
             a: {
               var env = 0;
               switch (methodName) {
-                case "dir":
-                case "dirxml":
-                case "groupEnd":
-                case "table":
+                case 'dir':
+                case 'dirxml':
+                case 'groupEnd':
+                case 'table':
                   env = null;
                   break a;
-                case "assert":
+                case 'assert':
                   env = 1;
               }
               var format = args[env],
                 style = args[env + 1],
                 badge = args[env + 2];
-              "string" === typeof format &&
-              format.startsWith("\u001b[0m\u001b[7m%c%s\u001b[0m%c") &&
-              "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px" ===
+              'string' === typeof format &&
+              format.startsWith('\u001b[0m\u001b[7m%c%s\u001b[0m%c') &&
+              'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px' ===
                 style &&
-              "string" === typeof badge
+              'string' === typeof badge
                 ? ((format = format.slice(18)),
-                  " " === format[0] && (format = format.slice(1)),
+                  ' ' === format[0] && (format = format.slice(1)),
                   args.splice(env, 4, format),
                   (env = badge.slice(1, badge.length - 1)))
                 : (env = null);
@@ -997,32 +997,32 @@
             args = serializeDebugModel(
               request,
               (null === request.deferredDebugObjects ? 500 : 10) + stack.length,
-              badge
+              badge,
             );
-            "[" !== args[0] &&
+            '[' !== args[0] &&
               (args = serializeDebugModel(request, 10 + stack.length, [
                 methodName,
                 stack,
                 owner,
                 env,
-                "Unknown Value: React could not send it from the server."
+                'Unknown Value: React could not send it from the server.',
               ]));
-            request.completedDebugChunks.push(":W" + args + "\n");
+            request.completedDebugChunks.push(':W' + args + '\n');
           }
           return originalMethod.apply(this, arguments);
         };
-        descriptor && Object.defineProperty(wrapperMethod, "name", descriptor);
+        descriptor && Object.defineProperty(wrapperMethod, 'name', descriptor);
         Object.defineProperty(consoleInst, methodName, {
-          value: wrapperMethod
+          value: wrapperMethod,
         });
       }
     }
     function getCurrentStackInDEV() {
       var owner = resolveOwner();
-      if (null === owner) return "";
+      if (null === owner) return '';
       try {
-        var info = "";
-        if (owner.owner || "string" !== typeof owner.name) {
+        var info = '';
+        if (owner.owner || 'string' !== typeof owner.name) {
           for (; owner; ) {
             var ownerStack = owner.debugStack;
             if (null != ownerStack) {
@@ -1033,16 +1033,16 @@
                 Error.prepareStackTrace = prepareStackTrace;
                 var stack = error.stack;
                 Error.prepareStackTrace = prevPrepareStackTrace;
-                stack.startsWith("Error: react-stack-top-frame\n") &&
+                stack.startsWith('Error: react-stack-top-frame\n') &&
                   (stack = stack.slice(29));
-                var idx = stack.indexOf("\n");
+                var idx = stack.indexOf('\n');
                 -1 !== idx && (stack = stack.slice(idx + 1));
-                idx = stack.indexOf("react_stack_bottom_frame");
-                -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
+                idx = stack.indexOf('react_stack_bottom_frame');
+                -1 !== idx && (idx = stack.lastIndexOf('\n', idx));
                 var JSCompiler_inline_result =
-                  -1 !== idx ? (stack = stack.slice(0, idx)) : "";
+                  -1 !== idx ? (stack = stack.slice(0, idx)) : '';
                 info =
-                  JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
+                  JSCompiler_temp_const + ('\n' + JSCompiler_inline_result);
               }
             } else break;
           }
@@ -1055,20 +1055,20 @@
             } catch (x) {
               (prefix =
                 ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) ||
-                ""),
+                ''),
                 (suffix =
-                  -1 < x.stack.indexOf("\n    at")
-                    ? " (<anonymous>)"
-                    : -1 < x.stack.indexOf("@")
-                      ? "@unknown:0:0"
-                      : "");
+                  -1 < x.stack.indexOf('\n    at')
+                    ? ' (<anonymous>)'
+                    : -1 < x.stack.indexOf('@')
+                      ? '@unknown:0:0'
+                      : '');
             }
           JSCompiler_inline_result$jscomp$0 =
-            "\n" + prefix + JSCompiler_temp_const + suffix;
+            '\n' + prefix + JSCompiler_temp_const + suffix;
         }
       } catch (x) {
         JSCompiler_inline_result$jscomp$0 =
-          "\nError generating stack: " + x.message + "\n" + x.stack;
+          '\nError generating stack: ' + x.message + '\n' + x.stack;
       }
       return JSCompiler_inline_result$jscomp$0;
     }
@@ -1087,14 +1087,14 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       if (
         null !== ReactSharedInternalsServer.A &&
         ReactSharedInternalsServer.A !== DefaultAsyncDispatcher
       )
         throw Error(
-          "Currently React only supports one RSC renderer at a time."
+          'Currently React only supports one RSC renderer at a time.',
         );
       ReactSharedInternalsServer.A = DefaultAsyncDispatcher;
       ReactSharedInternalsServer.getCurrentStack = getCurrentStackInDEV;
@@ -1121,7 +1121,7 @@
       this.writtenServerReferences = new Map();
       this.writtenObjects = new WeakMap();
       this.temporaryReferences = temporaryReferences;
-      this.identifierPrefix = identifierPrefix || "";
+      this.identifierPrefix = identifierPrefix || '';
       this.identifierCount = 1;
       this.taintCleanupQueue = [];
       this.onError = void 0 === onError ? defaultErrorHandler : onError;
@@ -1135,9 +1135,9 @@
       this.environmentName =
         void 0 === environmentName
           ? function () {
-              return "Server";
+              return 'Server';
             }
-          : "function" !== typeof environmentName
+          : 'function' !== typeof environmentName
             ? function () {
                 return environmentName;
               }
@@ -1164,7 +1164,7 @@
         type,
         null,
         null,
-        null
+        null,
       );
       pingedTasks.push(model);
     }
@@ -1177,7 +1177,7 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       resetOwnerStackLimit();
       return new RequestInstance(
@@ -1192,7 +1192,7 @@
         temporaryReferences,
         environmentName,
         filterStackFrame,
-        keepDebugAlive
+        keepDebugAlive,
       );
     }
     function createPrerenderRequest(
@@ -1206,7 +1206,7 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       resetOwnerStackLimit();
       return new RequestInstance(
@@ -1221,7 +1221,7 @@
         temporaryReferences,
         environmentName,
         filterStackFrame,
-        keepDebugAlive
+        keepDebugAlive,
       );
     }
     function resolveRequest() {
@@ -1232,17 +1232,17 @@
     function serializeDebugThenable(request, counter, thenable) {
       request.pendingDebugChunks++;
       var id = request.nextChunkId++,
-        ref = "$@" + id.toString(16);
+        ref = '$@' + id.toString(16);
       request.writtenDebugObjects.set(thenable, ref);
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             emitOutlinedDebugModelChunk(request, id, counter, thenable.value),
             ref
           );
-        case "rejected":
+        case 'rejected':
           return (
-            emitErrorChunk(request, id, "", thenable.reason, !0, null), ref
+            emitErrorChunk(request, id, '', thenable.reason, !0, null), ref
           );
       }
       if (request.status === ABORTING)
@@ -1251,7 +1251,7 @@
       if (null !== deferredDebugObjects)
         return (
           deferredDebugObjects.retained.set(id, thenable),
-          (ref = "$Y@" + id.toString(16)),
+          (ref = '$Y@' + id.toString(16)),
           request.writtenDebugObjects.set(thenable, ref),
           ref
         );
@@ -1270,9 +1270,9 @@
             ((cancelled = !0),
             request.status === ABORTING
               ? emitDebugHaltChunk(request, id)
-              : emitErrorChunk(request, id, "", reason, !0, null),
+              : emitErrorChunk(request, id, '', reason, !0, null),
             enqueueFlush(request));
-        }
+        },
       );
       Promise.resolve().then(function () {
         cancelled ||
@@ -1294,9 +1294,9 @@
         function (reason) {
           request.status === ABORTING
             ? emitDebugHaltChunk(request, id)
-            : emitErrorChunk(request, id, "", reason, !0, null);
+            : emitErrorChunk(request, id, '', reason, !0, null);
           enqueueFlush(request);
-        }
+        },
       );
     }
     function serializeThenable(request, task, thenable) {
@@ -1310,30 +1310,30 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             forwardDebugInfoFromThenable(
               request,
               newTask,
               thenable,
               null,
-              null
+              null,
             ),
             (newTask.model = thenable.value),
             pingTask(request, newTask),
             newTask.id
           );
-        case "rejected":
+        case 'rejected':
           return (
             forwardDebugInfoFromThenable(
               request,
               newTask,
               thenable,
               null,
-              null
+              null,
             ),
             erroredTask(request, newTask, thenable.reason),
             newTask.id
@@ -1349,18 +1349,18 @@
                   finishAbortedTask(newTask, request, task)),
               newTask.id
             );
-          "string" !== typeof thenable.status &&
-            ((thenable.status = "pending"),
+          'string' !== typeof thenable.status &&
+            ((thenable.status = 'pending'),
             thenable.then(
               function (fulfilledValue) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "fulfilled"),
+                'pending' === thenable.status &&
+                  ((thenable.status = 'fulfilled'),
                   (thenable.value = fulfilledValue));
               },
               function (error) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "rejected"), (thenable.reason = error));
-              }
+                'pending' === thenable.status &&
+                  ((thenable.status = 'rejected'), (thenable.reason = error));
+              },
             ));
       }
       thenable.then(
@@ -1374,7 +1374,7 @@
             ((newTask.timed = !0),
             erroredTask(request, newTask, reason),
             enqueueFlush(request));
-        }
+        },
       );
       return newTask.id;
     }
@@ -1383,12 +1383,12 @@
         if (0 === streamTask.status)
           if (entry.done)
             (streamTask.status = 1),
-              (entry = streamTask.id.toString(16) + ":C\n"),
+              (entry = streamTask.id.toString(16) + ':C\n'),
               request.completedRegularChunks.push(entry),
               request.abortableTasks.delete(streamTask),
               request.cacheController.signal.removeEventListener(
-                "abort",
-                abortStream
+                'abort',
+                abortStream,
               ),
               enqueueFlush(request),
               callOnAllReadyIfReady(request);
@@ -1406,8 +1406,8 @@
       function error(reason) {
         0 === streamTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortStream
+            'abort',
+            abortStream,
           ),
           erroredTask(request, streamTask, reason),
           enqueueFlush(request),
@@ -1416,7 +1416,7 @@
       function abortStream() {
         if (0 === streamTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortStream);
+          signal.removeEventListener('abort', abortStream);
           signal = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(streamTask),
@@ -1429,7 +1429,7 @@
       var supportsBYOB = stream.supportsBYOB;
       if (void 0 === supportsBYOB)
         try {
-          stream.getReader({ mode: "byob" }).releaseLock(), (supportsBYOB = !0);
+          stream.getReader({ mode: 'byob' }).releaseLock(), (supportsBYOB = !0);
         } catch (x) {
           supportsBYOB = !1;
         }
@@ -1444,13 +1444,13 @@
           task.time,
           task.debugOwner,
           task.debugStack,
-          task.debugTask
+          task.debugTask,
         );
       request.pendingChunks++;
       task =
-        streamTask.id.toString(16) + ":" + (supportsBYOB ? "r" : "R") + "\n";
+        streamTask.id.toString(16) + ':' + (supportsBYOB ? 'r' : 'R') + '\n';
       request.completedRegularChunks.push(task);
-      request.cacheController.signal.addEventListener("abort", abortStream);
+      request.cacheController.signal.addEventListener('abort', abortStream);
       reader.read().then(progress, error);
       return serializeByValueID(streamTask.id);
     }
@@ -1460,15 +1460,15 @@
           if (entry.done) {
             streamTask.status = 1;
             if (void 0 === entry.value)
-              var endStreamRow = streamTask.id.toString(16) + ":C\n";
+              var endStreamRow = streamTask.id.toString(16) + ':C\n';
             else
               try {
                 var chunkId = outlineModel(request, entry.value);
                 endStreamRow =
                   streamTask.id.toString(16) +
-                  ":C" +
+                  ':C' +
                   stringify(serializeByValueID(chunkId)) +
-                  "\n";
+                  '\n';
               } catch (x) {
                 error(x);
                 return;
@@ -1476,8 +1476,8 @@
             request.completedRegularChunks.push(endStreamRow);
             request.abortableTasks.delete(streamTask);
             request.cacheController.signal.removeEventListener(
-              "abort",
-              abortIterable
+              'abort',
+              abortIterable,
             );
             enqueueFlush(request);
             callOnAllReadyIfReady(request);
@@ -1495,18 +1495,18 @@
       function error(reason) {
         0 === streamTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortIterable
+            'abort',
+            abortIterable,
           ),
           erroredTask(request, streamTask, reason),
           enqueueFlush(request),
-          "function" === typeof iterator.throw &&
+          'function' === typeof iterator.throw &&
             iterator.throw(reason).then(error, error));
       }
       function abortIterable() {
         if (0 === streamTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortIterable);
+          signal.removeEventListener('abort', abortIterable);
           var reason = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(streamTask),
@@ -1514,7 +1514,7 @@
               finishHaltedTask(streamTask, request))
             : (erroredTask(request, streamTask, signal.reason),
               enqueueFlush(request));
-          "function" === typeof iterator.throw &&
+          'function' === typeof iterator.throw &&
             iterator.throw(reason).then(error, error);
         }
       }
@@ -1529,67 +1529,67 @@
           task.time,
           task.debugOwner,
           task.debugStack,
-          task.debugTask
+          task.debugTask,
         );
       (task = iterable._debugInfo) &&
         forwardDebugInfo(request, streamTask, task);
       request.pendingChunks++;
       isIterator =
-        streamTask.id.toString(16) + ":" + (isIterator ? "x" : "X") + "\n";
+        streamTask.id.toString(16) + ':' + (isIterator ? 'x' : 'X') + '\n';
       request.completedRegularChunks.push(isIterator);
-      request.cacheController.signal.addEventListener("abort", abortIterable);
+      request.cacheController.signal.addEventListener('abort', abortIterable);
       callIteratorInDEV(iterator, progress, error);
       return serializeByValueID(streamTask.id);
     }
     function emitHint(request, code, model) {
       model = stringify(model);
-      request.completedHintChunks.push(":H" + code + model + "\n");
+      request.completedHintChunks.push(':H' + code + model + '\n');
       enqueueFlush(request);
     }
     function readThenable(thenable) {
-      if ("fulfilled" === thenable.status) return thenable.value;
-      if ("rejected" === thenable.status) throw thenable.reason;
+      if ('fulfilled' === thenable.status) return thenable.value;
+      if ('rejected' === thenable.status) throw thenable.reason;
       throw thenable;
     }
     function createLazyWrapperAroundWakeable(request, task, wakeable) {
       switch (wakeable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             forwardDebugInfoFromThenable(request, task, wakeable, null, null),
             wakeable.value
           );
-        case "rejected":
+        case 'rejected':
           forwardDebugInfoFromThenable(request, task, wakeable, null, null);
           break;
         default:
-          "string" !== typeof wakeable.status &&
-            ((wakeable.status = "pending"),
+          'string' !== typeof wakeable.status &&
+            ((wakeable.status = 'pending'),
             wakeable.then(
               function (fulfilledValue) {
                 forwardDebugInfoFromCurrentContext(request, task, wakeable);
-                "pending" === wakeable.status &&
-                  ((wakeable.status = "fulfilled"),
+                'pending' === wakeable.status &&
+                  ((wakeable.status = 'fulfilled'),
                   (wakeable.value = fulfilledValue));
               },
               function (error) {
                 forwardDebugInfoFromCurrentContext(request, task, wakeable);
-                "pending" === wakeable.status &&
-                  ((wakeable.status = "rejected"), (wakeable.reason = error));
-              }
+                'pending' === wakeable.status &&
+                  ((wakeable.status = 'rejected'), (wakeable.reason = error));
+              },
             ));
       }
       return {
         $$typeof: REACT_LAZY_TYPE,
         _payload: wakeable,
-        _init: readThenable
+        _init: readThenable,
       };
     }
     function callWithDebugContextInDEV(request, task, callback, arg) {
       var componentDebugInfo = {
-        name: "",
+        name: '',
         env: task.environmentName,
         key: null,
-        owner: task.debugOwner
+        owner: task.debugOwner,
       };
       componentDebugInfo.stack =
         null === task.debugStack
@@ -1608,18 +1608,18 @@
       request,
       task,
       Component,
-      result
+      result,
     ) {
       if (
-        "object" !== typeof result ||
+        'object' !== typeof result ||
         null === result ||
         isClientReference(result)
       )
         return result;
-      if ("function" === typeof result.then)
+      if ('function' === typeof result.then)
         return (
           result.then(function (resolvedValue) {
-            "object" === typeof resolvedValue &&
+            'object' === typeof resolvedValue &&
               null !== resolvedValue &&
               resolvedValue.$$typeof === REACT_ELEMENT_TYPE &&
               (resolvedValue._store.validated = 1);
@@ -1632,13 +1632,13 @@
         var multiShot = _defineProperty({}, Symbol.iterator, function () {
           var iterator = iteratorFn.call(result);
           iterator !== result ||
-            ("[object GeneratorFunction]" ===
+            ('[object GeneratorFunction]' ===
               Object.prototype.toString.call(Component) &&
-              "[object Generator]" ===
+              '[object Generator]' ===
                 Object.prototype.toString.call(result)) ||
             callWithDebugContextInDEV(request, task, function () {
               console.error(
-                "Returning an Iterator from a Server Component is not supported since it cannot be looped over more than once. "
+                'Returning an Iterator from a Server Component is not supported since it cannot be looped over more than once. ',
               );
             });
           return iterator;
@@ -1646,20 +1646,20 @@
         multiShot._debugInfo = result._debugInfo;
         return multiShot;
       }
-      return "function" !== typeof result[ASYNC_ITERATOR] ||
-        ("function" === typeof ReadableStream &&
+      return 'function' !== typeof result[ASYNC_ITERATOR] ||
+        ('function' === typeof ReadableStream &&
           result instanceof ReadableStream)
         ? result
         : ((multiShot = _defineProperty({}, ASYNC_ITERATOR, function () {
             var iterator = result[ASYNC_ITERATOR]();
             iterator !== result ||
-              ("[object AsyncGeneratorFunction]" ===
+              ('[object AsyncGeneratorFunction]' ===
                 Object.prototype.toString.call(Component) &&
-                "[object AsyncGenerator]" ===
+                '[object AsyncGenerator]' ===
                   Object.prototype.toString.call(result)) ||
               callWithDebugContextInDEV(request, task, function () {
                 console.error(
-                  "Returning an AsyncIterator from a Server Component is not supported since it cannot be looped over more than once. "
+                  'Returning an AsyncIterator from a Server Component is not supported since it cannot be looped over more than once. ',
                 );
               });
             return iterator;
@@ -1673,7 +1673,7 @@
       key,
       Component,
       props,
-      validated
+      validated,
     ) {
       var prevThenableState = task.thenableState;
       task.thenableState = null;
@@ -1682,14 +1682,14 @@
           var componentDebugInfo = prevThenableState._componentDebugInfo;
         else {
           var componentDebugID = task.id;
-          componentDebugInfo = Component.displayName || Component.name || "";
+          componentDebugInfo = Component.displayName || Component.name || '';
           var componentEnv = (0, request.environmentName)();
           request.pendingChunks++;
           componentDebugInfo = {
             name: componentDebugInfo,
             env: componentEnv,
             key: key,
-            owner: task.debugOwner
+            owner: task.debugOwner,
           };
           componentDebugInfo.stack =
             null === task.debugStack
@@ -1717,21 +1717,21 @@
               callComponentInDEV,
               Component,
               props,
-              componentDebugInfo
-            )
+              componentDebugInfo,
+            ),
           )
         : componentStorage.run(
             componentDebugInfo,
             callComponentInDEV,
             Component,
             props,
-            componentDebugInfo
+            componentDebugInfo,
           );
       if (request.status === ABORTING)
         throw (
-          ("object" !== typeof props ||
+          ('object' !== typeof props ||
             null === props ||
-            "function" !== typeof props.then ||
+            'function' !== typeof props.then ||
             isClientReference(props) ||
             props.then(voidHandler, voidHandler),
           null)
@@ -1749,13 +1749,13 @@
             task,
             validated[componentDebugID],
             componentDebugInfo,
-            prevThenableState[componentDebugID]
+            prevThenableState[componentDebugID],
           );
       props = processServerComponentReturnValue(
         request,
         task,
         Component,
-        props
+        props,
       );
       task.debugOwner = componentDebugInfo;
       task.debugStack = null;
@@ -1763,9 +1763,9 @@
       Component = task.keyPath;
       componentDebugInfo = task.implicitSlot;
       null !== key
-        ? (task.keyPath = null === Component ? key : Component + "," + key)
+        ? (task.keyPath = null === Component ? key : Component + ',' + key)
         : null === Component && (task.implicitSlot = !0);
-      request = renderModelDestructive(request, task, emptyRoot, "", props);
+      request = renderModelDestructive(request, task, emptyRoot, '', props);
       task.keyPath = Component;
       task.implicitSlot = componentDebugInfo;
       return request;
@@ -1774,8 +1774,8 @@
       function logKeyError() {
         console.error(
           'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
-          "",
-          ""
+          '',
+          '',
         );
       }
       key = request.didWarnForKey;
@@ -1793,22 +1793,22 @@
               callComponentInDEV,
               logKeyError,
               null,
-              componentDebugInfo
-            )
+              componentDebugInfo,
+            ),
           )
         : componentStorage.run(
             componentDebugInfo,
             callComponentInDEV,
             logKeyError,
             null,
-            componentDebugInfo
+            componentDebugInfo,
           );
     }
     function renderFragment(request, task, children) {
       for (var i = 0; i < children.length; i++) {
         var child = children[i];
         null === child ||
-          "object" !== typeof child ||
+          'object' !== typeof child ||
           child.$$typeof !== REACT_ELEMENT_TYPE ||
           null !== child.key ||
           child._store.validated ||
@@ -1823,7 +1823,7 @@
             { children: children },
             null,
             null,
-            0
+            0,
           ]),
           task.implicitSlot ? [request] : request
         );
@@ -1844,7 +1844,7 @@
             { children: children },
             null,
             null,
-            0
+            0,
           ]),
           task.implicitSlot ? [request] : request
         );
@@ -1862,7 +1862,7 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       pingTask(request, task);
       return serializeLazyID(task.id);
@@ -1878,7 +1878,7 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       retryTask(request, task);
       return 1 === task.status
@@ -1888,14 +1888,14 @@
     function renderElement(request, task, type, key, ref, props, validated) {
       if (null !== ref && void 0 !== ref)
         throw Error(
-          "Refs cannot be used in Server Components, nor passed to Client Components."
+          'Refs cannot be used in Server Components, nor passed to Client Components.',
         );
       jsxPropsParents.set(props, type);
-      "object" === typeof props.children &&
+      'object' === typeof props.children &&
         null !== props.children &&
         jsxChildrenParents.set(props.children, type);
       if (
-        "function" !== typeof type ||
+        'function' !== typeof type ||
         isClientReference(type) ||
         type.$$typeof === TEMPORARY_REFERENCE_TAG
       ) {
@@ -1903,7 +1903,7 @@
           return (
             2 === validated &&
               ((validated = {
-                name: "Fragment",
+                name: 'Fragment',
                 env: (0, request.environmentName)(),
                 key: key,
                 owner: task.debugOwner,
@@ -1912,11 +1912,11 @@
                     ? null
                     : filterStackTrace(
                         request,
-                        parseStackTrace(task.debugStack, 1)
+                        parseStackTrace(task.debugStack, 1),
                       ),
                 props: props,
                 debugStack: task.debugStack,
-                debugTask: task.debugTask
+                debugTask: task.debugTask,
               }),
               warnForMissingKey(request, key, validated, task.debugTask)),
             (validated = task.implicitSlot),
@@ -1925,15 +1925,15 @@
               request,
               task,
               emptyRoot,
-              "",
-              props.children
+              '',
+              props.children,
             )),
             (task.implicitSlot = validated),
             request
           );
         if (
           null != type &&
-          "object" === typeof type &&
+          'object' === typeof type &&
           !isClientReference(type)
         )
           switch (type.$$typeof) {
@@ -1947,7 +1947,7 @@
                 key,
                 ref,
                 props,
-                validated
+                validated,
               );
             case REACT_FORWARD_REF_TYPE:
               return renderFunctionComponent(
@@ -1956,7 +1956,7 @@
                 key,
                 type.render,
                 props,
-                validated
+                validated,
               );
             case REACT_MEMO_TYPE:
               return renderElement(
@@ -1966,12 +1966,12 @@
                 key,
                 ref,
                 props,
-                validated
+                validated,
               );
             case REACT_ELEMENT_TYPE:
               type._store.validated = 1;
           }
-        else if ("string" === typeof type) {
+        else if ('string' === typeof type) {
           ref = task.formatContext;
           var newFormatContext = getChildFormatContext(ref, type, props);
           ref !== newFormatContext &&
@@ -1979,7 +1979,7 @@
             outlineModelWithFormatContext(
               request,
               props.children,
-              newFormatContext
+              newFormatContext,
             );
         }
       } else
@@ -1989,22 +1989,22 @@
           key,
           type,
           props,
-          validated
+          validated,
         );
       ref = task.keyPath;
-      null === key ? (key = ref) : null !== ref && (key = ref + "," + key);
+      null === key ? (key = ref) : null !== ref && (key = ref + ',' + key);
       newFormatContext = null;
       ref = task.debugOwner;
       null !== ref && outlineComponentInfo(request, ref);
       if (null !== task.debugStack) {
         newFormatContext = filterStackTrace(
           request,
-          parseStackTrace(task.debugStack, 1)
+          parseStackTrace(task.debugStack, 1),
         );
         var id = outlineDebugModel(
           request,
           { objectLimit: 2 * newFormatContext.length + 1 },
-          newFormatContext
+          newFormatContext,
         );
         request.writtenObjects.set(newFormatContext, serializeByValueID(id));
       }
@@ -2015,7 +2015,7 @@
         props,
         ref,
         newFormatContext,
-        validated
+        validated,
       ];
       task = task.implicitSlot && null !== key ? [request] : request;
       return task;
@@ -2032,7 +2032,7 @@
           task,
           node.previous,
           visited,
-          cutOff
+          cutOff,
         )),
         void 0 === previousIONode)
       )
@@ -2080,7 +2080,7 @@
               task,
               awaited,
               visited,
-              cutOff
+              cutOff,
             );
             if (void 0 === _ioNode) break;
             if (null !== _ioNode) {
@@ -2112,7 +2112,7 @@
                       stack:
                         null === node.stack
                           ? null
-                          : filterStackTrace(request, node.stack)
+                          : filterStackTrace(request, node.stack),
                     }),
                     markOperationEndTime(request, task, endTime),
                     request.status === ABORTING && (previousIONode = void 0))
@@ -2127,7 +2127,7 @@
               (visited.add(node), forwardDebugInfo(request, task, node)));
           return previousIONode;
         default:
-          throw Error("Unknown AsyncSequence tag. This is a bug in React.");
+          throw Error('Unknown AsyncSequence tag. This is a bug in React.');
       }
     }
     function emitAsyncSequence(
@@ -2136,7 +2136,7 @@
       node,
       alreadyForwardedDebugInfo,
       owner,
-      stack
+      stack,
     ) {
       var visited = new Set();
       alreadyForwardedDebugInfo && visited.add(alreadyForwardedDebugInfo);
@@ -2148,7 +2148,7 @@
         (alreadyForwardedDebugInfo = (0, request.environmentName)()),
         (alreadyForwardedDebugInfo = {
           awaited: node,
-          env: alreadyForwardedDebugInfo
+          env: alreadyForwardedDebugInfo,
         }),
         null === owner && null === stack
           ? (null !== task.debugOwner &&
@@ -2156,13 +2156,13 @@
             null !== task.debugStack &&
               (alreadyForwardedDebugInfo.stack = filterStackTrace(
                 request,
-                parseStackTrace(task.debugStack, 1)
+                parseStackTrace(task.debugStack, 1),
               )))
           : (null != owner && (alreadyForwardedDebugInfo.owner = owner),
             null != stack &&
               (alreadyForwardedDebugInfo.stack = filterStackTrace(
                 request,
-                parseStackTrace(stack, 1)
+                parseStackTrace(stack, 1),
               ))),
         advanceTaskTime(request, task, task.time),
         emitDebugChunk(request, task.id, alreadyForwardedDebugInfo),
@@ -2192,11 +2192,11 @@
       lastTimestamp,
       debugOwner,
       debugStack,
-      debugTask
+      debugTask,
     ) {
       request.pendingChunks++;
       var id = request.nextChunkId++;
-      "object" !== typeof model ||
+      'object' !== typeof model ||
         null === model ||
         null !== keyPath ||
         implicitSlot ||
@@ -2214,31 +2214,31 @@
         toJSON: function (parentPropertyName, value) {
           var parent = this,
             originalValue = parent[parentPropertyName];
-          "object" !== typeof originalValue ||
+          'object' !== typeof originalValue ||
             originalValue === value ||
             originalValue instanceof Date ||
             callWithDebugContextInDEV(request, task, function () {
-              "Object" !== objectName(originalValue)
-                ? "string" === typeof jsxChildrenParents.get(parent)
+              'Object' !== objectName(originalValue)
+                ? 'string' === typeof jsxChildrenParents.get(parent)
                   ? console.error(
-                      "%s objects cannot be rendered as text children. Try formatting it using toString().%s",
+                      '%s objects cannot be rendered as text children. Try formatting it using toString().%s',
                       objectName(originalValue),
-                      describeObjectForErrorMessage(parent, parentPropertyName)
+                      describeObjectForErrorMessage(parent, parentPropertyName),
                     )
                   : console.error(
-                      "Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s",
+                      'Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s',
                       objectName(originalValue),
-                      describeObjectForErrorMessage(parent, parentPropertyName)
+                      describeObjectForErrorMessage(parent, parentPropertyName),
                     )
                 : console.error(
-                    "Only plain objects can be passed to Client Components from Server Components. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s",
-                    describeObjectForErrorMessage(parent, parentPropertyName)
+                    'Only plain objects can be passed to Client Components from Server Components. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s',
+                    describeObjectForErrorMessage(parent, parentPropertyName),
                   );
             });
           return renderModel(request, task, parent, parentPropertyName, value);
         },
         thenableState: null,
-        timed: !1
+        timed: !1,
       };
       task.time = lastTimestamp;
       task.environmentName = request.environmentName();
@@ -2249,10 +2249,10 @@
       return task;
     }
     function serializeByValueID(id) {
-      return "$" + id.toString(16);
+      return '$' + id.toString(16);
     }
     function serializeLazyID(id) {
-      return "$L" + id.toString(16);
+      return '$L' + id.toString(16);
     }
     function serializeDeferredObject(request, value) {
       var deferredDebugObjects = request.deferredDebugObjects;
@@ -2261,49 +2261,49 @@
           (request = request.nextChunkId++),
           deferredDebugObjects.existing.set(value, request),
           deferredDebugObjects.retained.set(request, value),
-          "$Y" + request.toString(16))
-        : "$Y";
+          '$Y' + request.toString(16))
+        : '$Y';
     }
     function serializeNumber(number) {
       return Number.isFinite(number)
         ? 0 === number && -Infinity === 1 / number
-          ? "$-0"
+          ? '$-0'
           : number
         : Infinity === number
-          ? "$Infinity"
+          ? '$Infinity'
           : -Infinity === number
-            ? "$-Infinity"
-            : "$NaN";
+            ? '$-Infinity'
+            : '$NaN';
     }
     function encodeReferenceChunk(request, id, reference) {
       request = stringify(reference);
-      return id.toString(16) + ":" + request + "\n";
+      return id.toString(16) + ':' + request + '\n';
     }
     function serializeClientReference(
       request,
       parent,
       parentPropertyName,
-      clientReference
+      clientReference,
     ) {
       var clientReferenceKey = clientReference.$$async
-          ? clientReference.$$id + "#async"
+          ? clientReference.$$id + '#async'
           : clientReference.$$id,
         writtenClientReferences = request.writtenClientReferences,
         existingId = writtenClientReferences.get(clientReferenceKey);
       if (void 0 !== existingId)
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(existingId)
           : serializeByValueID(existingId);
       try {
         var clientReferenceMetadata = resolveClientReferenceMetadata(
           request.bundlerConfig,
-          clientReference
+          clientReference,
         );
         request.pendingChunks++;
         var importId = request.nextChunkId++;
         emitImportChunk(request, importId, clientReferenceMetadata, !1);
         writtenClientReferences.set(clientReferenceKey, importId);
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(importId)
           : serializeByValueID(importId);
       } catch (x) {
@@ -2320,26 +2320,26 @@
       request,
       parent,
       parentPropertyName,
-      clientReference
+      clientReference,
     ) {
       var existingId = request.writtenClientReferences.get(
         clientReference.$$async
-          ? clientReference.$$id + "#async"
-          : clientReference.$$id
+          ? clientReference.$$id + '#async'
+          : clientReference.$$id,
       );
       if (void 0 !== existingId)
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(existingId)
           : serializeByValueID(existingId);
       try {
         var clientReferenceMetadata = resolveClientReferenceMetadata(
           request.bundlerConfig,
-          clientReference
+          clientReference,
         );
         request.pendingDebugChunks++;
         var importId = request.nextChunkId++;
         emitImportChunk(request, importId, clientReferenceMetadata, !0);
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(importId)
           : serializeByValueID(importId);
       } catch (x) {
@@ -2366,7 +2366,7 @@
         performance.now(),
         null,
         null,
-        null
+        null,
       );
       retryTask(request, value);
       return value.id;
@@ -2374,7 +2374,7 @@
     function serializeServerReference(request, serverReference) {
       var writtenServerReferences = request.writtenServerReferences,
         existingId = writtenServerReferences.get(serverReference);
-      if (void 0 !== existingId) return "$F" + existingId.toString(16);
+      if (void 0 !== existingId) return '$F' + existingId.toString(16);
       existingId = serverReference.$$bound;
       existingId = null === existingId ? null : Promise.resolve(existingId);
       var id = serverReference.$$id,
@@ -2391,16 +2391,16 @@
               id: id,
               bound: existingId,
               name:
-                "function" === typeof serverReference
+                'function' === typeof serverReference
                   ? serverReference.name
-                  : "",
+                  : '',
               env: (0, request.environmentName)(),
-              location: location
+              location: location,
             }
           : { id: id, bound: existingId };
       request = outlineModel(request, existingId);
       writtenServerReferences.set(serverReference, request);
-      return "$F" + request.toString(16);
+      return '$F' + request.toString(16);
     }
     function serializeLargeTextString(request, text) {
       request.pendingChunks++;
@@ -2410,15 +2410,15 @@
     }
     function serializeMap(request, map) {
       map = Array.from(map);
-      return "$Q" + outlineModel(request, map).toString(16);
+      return '$Q' + outlineModel(request, map).toString(16);
     }
     function serializeFormData(request, formData) {
       formData = Array.from(formData.entries());
-      return "$K" + outlineModel(request, formData).toString(16);
+      return '$K' + outlineModel(request, formData).toString(16);
     }
     function serializeSet(request, set) {
       set = Array.from(set);
-      return "$W" + outlineModel(request, set).toString(16);
+      return '$W' + outlineModel(request, set).toString(16);
     }
     function serializeTypedArray(request, tag, typedArray) {
       request.pendingChunks++;
@@ -2439,7 +2439,7 @@
             request,
             id,
             { objectLimit: model.length + 2 },
-            model
+            model,
           ),
             enqueueFlush(request);
         else
@@ -2448,7 +2448,7 @@
           );
       }
       function error(reason) {
-        emitErrorChunk(request, id, "", reason, !0, null);
+        emitErrorChunk(request, id, '', reason, !0, null);
         enqueueFlush(request);
         reader.cancel(reason).then(noop, noop);
       }
@@ -2457,15 +2457,15 @@
       request.pendingDebugChunks++;
       var id = request.nextChunkId++;
       reader.read().then(progress).catch(error);
-      return "$B" + id.toString(16);
+      return '$B' + id.toString(16);
     }
     function serializeBlob(request, blob) {
       function progress(entry) {
         if (0 === newTask.status)
           if (entry.done)
             request.cacheController.signal.removeEventListener(
-              "abort",
-              abortBlob
+              'abort',
+              abortBlob,
             ),
               pingTask(request, newTask);
           else
@@ -2476,8 +2476,8 @@
       function error(reason) {
         0 === newTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortBlob
+            'abort',
+            abortBlob,
           ),
           erroredTask(request, newTask, reason),
           enqueueFlush(request),
@@ -2486,7 +2486,7 @@
       function abortBlob() {
         if (0 === newTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortBlob);
+          signal.removeEventListener('abort', abortBlob);
           signal = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(newTask),
@@ -2507,12 +2507,12 @@
           performance.now(),
           null,
           null,
-          null
+          null,
         ),
         reader = blob.stream().getReader();
-      request.cacheController.signal.addEventListener("abort", abortBlob);
+      request.cacheController.signal.addEventListener('abort', abortBlob);
       reader.read().then(progress).catch(error);
-      return "$B" + newTask.id.toString(16);
+      return '$B' + newTask.id.toString(16);
     }
     function renderModel(request, task, parent, key, value) {
       serializedSize += key.length;
@@ -2523,7 +2523,7 @@
       } catch (thrownValue) {
         parent = task.model;
         parent =
-          "object" === typeof parent &&
+          'object' === typeof parent &&
           null !== parent &&
           (parent.$$typeof === REACT_ELEMENT_TYPE ||
             parent.$$typeof === REACT_LAZY_TYPE);
@@ -2545,9 +2545,9 @@
             ? getSuspendedThenable()
             : thrownValue;
         if (
-          "object" === typeof key &&
+          'object' === typeof key &&
           null !== key &&
-          "function" === typeof key.then
+          'function' === typeof key.then
         )
           return (
             (request = createTask(
@@ -2560,7 +2560,7 @@
               task.time,
               task.debugOwner,
               task.debugStack,
-              task.debugTask
+              task.debugTask,
             )),
             (value = request.ping),
             key.then(value, value),
@@ -2582,7 +2582,7 @@
           prevImplicitSlot,
           key,
           !1,
-          task.debugOwner
+          task.debugOwner,
         );
         return parent
           ? serializeLazyID(prevKeyPath)
@@ -2594,12 +2594,12 @@
       task,
       parent,
       parentPropertyName,
-      value
+      value,
     ) {
       task.model = value;
-      if (value === REACT_ELEMENT_TYPE) return "$";
+      if (value === REACT_ELEMENT_TYPE) return '$';
       if (null === value) return null;
-      if ("object" === typeof value) {
+      if ('object' === typeof value) {
         switch (value.$$typeof) {
           case REACT_ELEMENT_TYPE:
             var elementReference = null,
@@ -2610,11 +2610,11 @@
                 if (modelRoot === value) modelRoot = null;
                 else return _existingReference;
               else
-                -1 === parentPropertyName.indexOf(":") &&
+                -1 === parentPropertyName.indexOf(':') &&
                   ((_existingReference = _writtenObjects.get(parent)),
                   void 0 !== _existingReference &&
                     ((elementReference =
-                      _existingReference + ":" + parentPropertyName),
+                      _existingReference + ':' + parentPropertyName),
                     _writtenObjects.set(value, elementReference)));
             }
             if (serializedSize > MAX_ROW_SIZE) return deferTask(request, task);
@@ -2633,13 +2633,13 @@
               void 0 === value._debugStack ||
               void 0 === value._debugTask
             ) {
-              var key = "";
+              var key = '';
               null !== value.key && (key = ' key="' + value.key + '"');
               console.error(
-                "Attempted to render <%s%s> without development properties. This is not supported. It can happen if:\n- The element is created with a production version of React but rendered in development.\n- The element was cloned with a custom function instead of `React.cloneElement`.\nThe props of this element may help locate this element: %o",
+                'Attempted to render <%s%s> without development properties. This is not supported. It can happen if:\n- The element is created with a production version of React but rendered in development.\n- The element was cloned with a custom function instead of `React.cloneElement`.\nThe props of this element may help locate this element: %o',
                 value.type,
                 key,
-                value.props
+                value.props,
               );
             }
             request = renderElement(
@@ -2649,9 +2649,9 @@
               value.key,
               refProp,
               _existingReference,
-              value._store.validated
+              value._store.validated,
             );
-            "object" === typeof request &&
+            'object' === typeof request &&
               null !== request &&
               null !== elementReference &&
               (_writtenObjects.has(request) ||
@@ -2670,12 +2670,12 @@
               request,
               task,
               emptyRoot,
-              "",
-              elementReference
+              '',
+              elementReference,
             );
           case REACT_LEGACY_ELEMENT_TYPE:
             throw Error(
-              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
+              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.',
             );
         }
         if (isClientReference(value))
@@ -2683,26 +2683,26 @@
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (
           void 0 !== request.temporaryReferences &&
           ((elementReference = request.temporaryReferences.get(value)),
           void 0 !== elementReference)
         )
-          return "$T" + elementReference;
+          return '$T' + elementReference;
         elementReference = request.writtenObjects;
         _writtenObjects = elementReference.get(value);
-        if ("function" === typeof value.then) {
+        if ('function' === typeof value.then) {
           if (void 0 !== _writtenObjects) {
             if (null !== task.keyPath || task.implicitSlot)
               return (
-                "$@" + serializeThenable(request, task, value).toString(16)
+                '$@' + serializeThenable(request, task, value).toString(16)
               );
             if (modelRoot === value) modelRoot = null;
             else return _writtenObjects;
           }
-          request = "$@" + serializeThenable(request, task, value).toString(16);
+          request = '$@' + serializeThenable(request, task, value).toString(16);
           elementReference.set(value, request);
           return request;
         }
@@ -2713,81 +2713,81 @@
             modelRoot = null;
           } else return _writtenObjects;
         else if (
-          -1 === parentPropertyName.indexOf(":") &&
+          -1 === parentPropertyName.indexOf(':') &&
           ((_writtenObjects = elementReference.get(parent)),
           void 0 !== _writtenObjects)
         ) {
           _existingReference = parentPropertyName;
           if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
             switch (parentPropertyName) {
-              case "1":
-                _existingReference = "type";
+              case '1':
+                _existingReference = 'type';
                 break;
-              case "2":
-                _existingReference = "key";
+              case '2':
+                _existingReference = 'key';
                 break;
-              case "3":
-                _existingReference = "props";
+              case '3':
+                _existingReference = 'props';
                 break;
-              case "4":
-                _existingReference = "_owner";
+              case '4':
+                _existingReference = '_owner';
             }
           elementReference.set(
             value,
-            _writtenObjects + ":" + _existingReference
+            _writtenObjects + ':' + _existingReference,
           );
         }
         if (isArrayImpl(value)) return renderFragment(request, task, value);
         if (value instanceof Map) return serializeMap(request, value);
         if (value instanceof Set) return serializeSet(request, value);
-        if ("function" === typeof FormData && value instanceof FormData)
+        if ('function' === typeof FormData && value instanceof FormData)
           return serializeFormData(request, value);
         if (value instanceof Error) return serializeErrorValue(request, value);
         if (value instanceof ArrayBuffer)
-          return serializeTypedArray(request, "A", new Uint8Array(value));
+          return serializeTypedArray(request, 'A', new Uint8Array(value));
         if (value instanceof Int8Array)
-          return serializeTypedArray(request, "O", value);
+          return serializeTypedArray(request, 'O', value);
         if (value instanceof Uint8Array)
-          return serializeTypedArray(request, "o", value);
+          return serializeTypedArray(request, 'o', value);
         if (value instanceof Uint8ClampedArray)
-          return serializeTypedArray(request, "U", value);
+          return serializeTypedArray(request, 'U', value);
         if (value instanceof Int16Array)
-          return serializeTypedArray(request, "S", value);
+          return serializeTypedArray(request, 'S', value);
         if (value instanceof Uint16Array)
-          return serializeTypedArray(request, "s", value);
+          return serializeTypedArray(request, 's', value);
         if (value instanceof Int32Array)
-          return serializeTypedArray(request, "L", value);
+          return serializeTypedArray(request, 'L', value);
         if (value instanceof Uint32Array)
-          return serializeTypedArray(request, "l", value);
+          return serializeTypedArray(request, 'l', value);
         if (value instanceof Float32Array)
-          return serializeTypedArray(request, "G", value);
+          return serializeTypedArray(request, 'G', value);
         if (value instanceof Float64Array)
-          return serializeTypedArray(request, "g", value);
+          return serializeTypedArray(request, 'g', value);
         if (value instanceof BigInt64Array)
-          return serializeTypedArray(request, "M", value);
+          return serializeTypedArray(request, 'M', value);
         if (value instanceof BigUint64Array)
-          return serializeTypedArray(request, "m", value);
+          return serializeTypedArray(request, 'm', value);
         if (value instanceof DataView)
-          return serializeTypedArray(request, "V", value);
-        if ("function" === typeof Blob && value instanceof Blob)
+          return serializeTypedArray(request, 'V', value);
+        if ('function' === typeof Blob && value instanceof Blob)
           return serializeBlob(request, value);
         if ((elementReference = getIteratorFn(value)))
           return (
             (elementReference = elementReference.call(value)),
             elementReference === value
-              ? "$i" +
+              ? '$i' +
                 outlineModel(request, Array.from(elementReference)).toString(16)
               : renderFragment(request, task, Array.from(elementReference))
           );
         if (
-          "function" === typeof ReadableStream &&
+          'function' === typeof ReadableStream &&
           value instanceof ReadableStream
         )
           return serializeReadableStream(request, task, value);
         elementReference = value[ASYNC_ITERATOR];
-        if ("function" === typeof elementReference)
+        if ('function' === typeof elementReference)
           return renderAsyncFragment(request, task, value, elementReference);
-        if (value instanceof Date) return "$D" + value.toJSON();
+        if (value instanceof Date) return '$D' + value.toJSON();
         elementReference = getPrototypeOf(value);
         if (
           elementReference !== ObjectPrototype &&
@@ -2795,22 +2795,22 @@
             null !== getPrototypeOf(elementReference))
         )
           throw Error(
-            "Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported." +
-              describeObjectForErrorMessage(parent, parentPropertyName)
+            'Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.' +
+              describeObjectForErrorMessage(parent, parentPropertyName),
           );
-        if ("Object" !== objectName(value))
+        if ('Object' !== objectName(value))
           callWithDebugContextInDEV(request, task, function () {
             console.error(
-              "Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s",
+              'Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s',
               objectName(value),
-              describeObjectForErrorMessage(parent, parentPropertyName)
+              describeObjectForErrorMessage(parent, parentPropertyName),
             );
           });
         else if (!isSimpleObject(value))
           callWithDebugContextInDEV(request, task, function () {
             console.error(
-              "Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.%s",
-              describeObjectForErrorMessage(parent, parentPropertyName)
+              'Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.%s',
+              describeObjectForErrorMessage(parent, parentPropertyName),
             );
           });
         else if (Object.getOwnPropertySymbols) {
@@ -2818,36 +2818,36 @@
           0 < symbols.length &&
             callWithDebugContextInDEV(request, task, function () {
               console.error(
-                "Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like %s are not supported.%s",
+                'Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like %s are not supported.%s',
                 symbols[0].description,
-                describeObjectForErrorMessage(parent, parentPropertyName)
+                describeObjectForErrorMessage(parent, parentPropertyName),
               );
             });
         }
         return value;
       }
-      if ("string" === typeof value)
+      if ('string' === typeof value)
         return (
           (serializedSize += value.length),
-          "Z" === value[value.length - 1] &&
+          'Z' === value[value.length - 1] &&
           parent[parentPropertyName] instanceof Date
-            ? "$D" + value
+            ? '$D' + value
             : 1024 <= value.length && null !== byteLengthOfChunk
               ? serializeLargeTextString(request, value)
-              : "$" === value[0]
-                ? "$" + value
+              : '$' === value[0]
+                ? '$' + value
                 : value
         );
-      if ("boolean" === typeof value) return value;
-      if ("number" === typeof value) return serializeNumber(value);
-      if ("undefined" === typeof value) return "$undefined";
-      if ("function" === typeof value) {
+      if ('boolean' === typeof value) return value;
+      if ('number' === typeof value) return serializeNumber(value);
+      if ('undefined' === typeof value) return '$undefined';
+      if ('function' === typeof value) {
         if (isClientReference(value))
           return serializeClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (value.$$typeof === SERVER_REFERENCE_TAG)
           return serializeServerReference(request, value);
@@ -2856,38 +2856,38 @@
           ((request = request.temporaryReferences.get(value)),
           void 0 !== request)
         )
-          return "$T" + request;
+          return '$T' + request;
         if (value.$$typeof === TEMPORARY_REFERENCE_TAG)
           throw Error(
-            "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+            'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
           );
         if (/^on[A-Z]/.test(parentPropertyName))
           throw Error(
-            "Event handlers cannot be passed to Client Component props." +
+            'Event handlers cannot be passed to Client Component props.' +
               describeObjectForErrorMessage(parent, parentPropertyName) +
-              "\nIf you need interactivity, consider converting part of this to a Client Component."
+              '\nIf you need interactivity, consider converting part of this to a Client Component.',
           );
         if (
           jsxChildrenParents.has(parent) ||
-          (jsxPropsParents.has(parent) && "children" === parentPropertyName)
+          (jsxPropsParents.has(parent) && 'children' === parentPropertyName)
         )
           throw (
-            ((request = value.displayName || value.name || "Component"),
+            ((request = value.displayName || value.name || 'Component'),
             Error(
-              "Functions are not valid as a child of Client Components. This may happen if you return " +
+              'Functions are not valid as a child of Client Components. This may happen if you return ' +
                 request +
-                " instead of <" +
+                ' instead of <' +
                 request +
-                " /> from render. Or maybe you meant to call this function rather than return it." +
-                describeObjectForErrorMessage(parent, parentPropertyName)
+                ' /> from render. Or maybe you meant to call this function rather than return it.' +
+                describeObjectForErrorMessage(parent, parentPropertyName),
             ))
           );
         throw Error(
           'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.' +
-            describeObjectForErrorMessage(parent, parentPropertyName)
+            describeObjectForErrorMessage(parent, parentPropertyName),
         );
       }
-      if ("symbol" === typeof value) {
+      if ('symbol' === typeof value) {
         task = request.writtenSymbols;
         elementReference = task.get(value);
         if (void 0 !== elementReference)
@@ -2895,9 +2895,9 @@
         elementReference = value.description;
         if (Symbol.for(elementReference) !== value)
           throw Error(
-            "Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" +
-              (value.description + ") cannot be found among global symbols.") +
-              describeObjectForErrorMessage(parent, parentPropertyName)
+            'Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(' +
+              (value.description + ') cannot be found among global symbols.') +
+              describeObjectForErrorMessage(parent, parentPropertyName),
           );
         request.pendingChunks++;
         _writtenObjects = request.nextChunkId++;
@@ -2905,12 +2905,12 @@
         task.set(value, _writtenObjects);
         return serializeByValueID(_writtenObjects);
       }
-      if ("bigint" === typeof value) return "$n" + value.toString(10);
+      if ('bigint' === typeof value) return '$n' + value.toString(10);
       throw Error(
-        "Type " +
+        'Type ' +
           typeof value +
-          " is not supported in Client Component props." +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+          ' is not supported in Client Component props.' +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     }
     function logRecoverableError(request, error, task) {
@@ -2926,19 +2926,19 @@
                 request,
                 task,
                 onError,
-                error
+                error,
               )
             : requestStorage.run(void 0, onError, error);
       } finally {
         currentRequest = prevRequest;
       }
-      if (null != errorDigest && "string" !== typeof errorDigest)
+      if (null != errorDigest && 'string' !== typeof errorDigest)
         throw Error(
           'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
             typeof errorDigest +
-            '" instead'
+            '" instead',
         );
-      return errorDigest || "";
+      return errorDigest || '';
     }
     function fatalError(request, error) {
       var onFatalError = request.onFatalError;
@@ -2947,35 +2947,35 @@
         ? ((request.status = CLOSED), request.destination.destroy(error))
         : ((request.status = 13), (request.fatalError = error));
       request.cacheController.abort(
-        Error("The render was aborted due to a fatal error.", { cause: error })
+        Error('The render was aborted due to a fatal error.', { cause: error }),
       );
     }
     function serializeErrorValue(request, error) {
-      var name = "Error",
+      var name = 'Error',
         env = (0, request.environmentName)();
       try {
         name = error.name;
         var message = String(error.message);
         var stack = filterStackTrace(request, parseStackTrace(error, 0));
         var errorEnv = error.environmentName;
-        "string" === typeof errorEnv && (env = errorEnv);
+        'string' === typeof errorEnv && (env = errorEnv);
       } catch (x) {
         (message =
-          "An error occurred but serializing the error message failed."),
+          'An error occurred but serializing the error message failed.'),
           (stack = []);
       }
       return (
-        "$Z" +
+        '$Z' +
         outlineModel(request, {
           name: name,
           message: message,
           stack: stack,
-          env: env
+          env: env,
         }).toString(16)
       );
     }
     function emitErrorChunk(request, id, digest, error, debug, owner) {
-      var name = "Error",
+      var name = 'Error',
         env = (0, request.environmentName)();
       try {
         if (error instanceof Error) {
@@ -2983,16 +2983,16 @@
           var message = String(error.message);
           var stack = filterStackTrace(request, parseStackTrace(error, 0));
           var errorEnv = error.environmentName;
-          "string" === typeof errorEnv && (env = errorEnv);
+          'string' === typeof errorEnv && (env = errorEnv);
         } else
           (message =
-            "object" === typeof error && null !== error
+            'object' === typeof error && null !== error
               ? describeObjectForErrorMessage(error)
               : String(error)),
             (stack = []);
       } catch (x) {
         (message =
-          "An error occurred but serializing the error message failed."),
+          'An error occurred but serializing the error message failed.'),
           (stack = []);
       }
       error = null == owner ? null : outlineComponentInfo(request, owner);
@@ -3002,38 +3002,38 @@
         message: message,
         stack: stack,
         env: env,
-        owner: error
+        owner: error,
       };
-      id = id.toString(16) + ":E" + stringify(digest) + "\n";
+      id = id.toString(16) + ':E' + stringify(digest) + '\n';
       debug
         ? request.completedDebugChunks.push(id)
         : request.completedErrorChunks.push(id);
     }
     function emitImportChunk(request, id, clientReferenceMetadata, debug) {
       clientReferenceMetadata = stringify(clientReferenceMetadata);
-      id = id.toString(16) + ":I" + clientReferenceMetadata + "\n";
+      id = id.toString(16) + ':I' + clientReferenceMetadata + '\n';
       debug
         ? request.completedDebugChunks.push(id)
         : request.completedImportChunks.push(id);
     }
     function emitSymbolChunk(request, id, name) {
-      id = encodeReferenceChunk(request, id, "$S" + name);
+      id = encodeReferenceChunk(request, id, '$S' + name);
       request.completedImportChunks.push(id);
     }
     function emitDebugHaltChunk(request, id) {
-      id = id.toString(16) + ":\n";
+      id = id.toString(16) + ':\n';
       request.completedDebugChunks.push(id);
     }
     function emitDebugChunk(request, id, debugInfo) {
       var json = serializeDebugModel(request, 500, debugInfo);
       null !== request.debugDestination
         ? ((debugInfo = request.nextChunkId++),
-          (json = debugInfo.toString(16) + ":" + json + "\n"),
+          (json = debugInfo.toString(16) + ':' + json + '\n'),
           request.pendingDebugChunks++,
           request.completedDebugChunks.push(json),
           (id = id.toString(16) + ':D"$' + debugInfo.toString(16) + '"\n'),
           request.completedRegularChunks.push(id))
-        : ((id = id.toString(16) + ":D" + json + "\n"),
+        : ((id = id.toString(16) + ':D' + json + '\n'),
           request.completedRegularChunks.push(id));
     }
     function outlineComponentInfo(request, componentInfo) {
@@ -3047,7 +3047,7 @@
       existingRef = { objectLimit: existingRef };
       var componentDebugInfo = {
         name: componentInfo.name,
-        key: componentInfo.key
+        key: componentInfo.key,
       };
       null != componentInfo.env && (componentDebugInfo.env = componentInfo.env);
       null != componentInfo.owner &&
@@ -3055,7 +3055,7 @@
       null == componentInfo.stack && null != componentInfo.debugStack
         ? (componentDebugInfo.stack = filterStackTrace(
             request,
-            parseStackTrace(componentInfo.debugStack, 1)
+            parseStackTrace(componentInfo.debugStack, 1),
           ))
         : null != componentInfo.stack &&
           (componentDebugInfo.stack = componentInfo.stack);
@@ -3075,28 +3075,28 @@
       value,
       env,
       owner,
-      stack
+      stack,
     ) {
       var objectLimit = 10;
       stack && (objectLimit += stack.length);
       name = {
         name: name,
         start: start - request.timeOrigin,
-        end: end - request.timeOrigin
+        end: end - request.timeOrigin,
       };
       null != env && (name.env = env);
       null != stack && (name.stack = stack);
       null != owner && (name.owner = owner);
       void 0 !== value && (name.value = value);
       value = serializeDebugModel(request, objectLimit, name);
-      id = id.toString(16) + ":J" + value + "\n";
+      id = id.toString(16) + ':J' + value + '\n';
       request.completedDebugChunks.push(id);
     }
     function serializeIONode(request, ioNode, promiseRef) {
       var existingRef = request.writtenDebugObjects.get(ioNode);
       if (void 0 !== existingRef) return existingRef;
       existingRef = null;
-      var name = "";
+      var name = '';
       if (null !== ioNode.stack) {
         a: {
           existingRef = ioNode.stack;
@@ -3111,7 +3111,7 @@
         }
         existingRef = filterStackTrace(request, name);
         a: {
-          callsite = "";
+          callsite = '';
           for (
             var filterStackFrame = request.filterStackFrame, i = 0;
             i < name.length;
@@ -3125,10 +3125,10 @@
                 url,
                 functionName,
                 callsite$jscomp$0[2],
-                callsite$jscomp$0[3]
+                callsite$jscomp$0[3],
               )
             ) {
-              if ("" === callsite) {
+              if ('' === callsite) {
                 name = functionName;
                 break a;
               }
@@ -3136,11 +3136,11 @@
               break a;
             } else callsite = functionName;
           }
-          name = "";
+          name = '';
         }
-        name.startsWith("Window.")
+        name.startsWith('Window.')
           ? (name = name.slice(7))
-          : name.startsWith("<anonymous>.") && (name = name.slice(7));
+          : name.startsWith('<anonymous>.') && (name = name.slice(7));
       }
       callsite = ioNode.owner;
       null != callsite && outlineComponentInfo(request, callsite);
@@ -3159,7 +3159,7 @@
         filterStackFrame,
         promiseRef,
         callsite,
-        existingRef
+        existingRef,
       );
       promiseRef = serializeByValueID(callsite$jscomp$0);
       request.writtenDebugObjects.set(ioNode, promiseRef);
@@ -3170,10 +3170,10 @@
       typedArray = new Uint8Array(
         typedArray.buffer,
         typedArray.byteOffset,
-        typedArray.byteLength
+        typedArray.byteLength,
       );
       var binaryLength = typedArray.byteLength;
-      id = id.toString(16) + ":" + tag + binaryLength.toString(16) + ",";
+      id = id.toString(16) + ':' + tag + binaryLength.toString(16) + ',';
       debug
         ? request.completedDebugChunks.push(id, typedArray)
         : request.completedRegularChunks.push(id, typedArray);
@@ -3181,11 +3181,11 @@
     function emitTextChunk(request, id, text, debug) {
       if (null === byteLengthOfChunk)
         throw Error(
-          "Existence of byteLengthOfChunk should have already been checked. This is a bug in React."
+          'Existence of byteLengthOfChunk should have already been checked. This is a bug in React.',
         );
       debug ? request.pendingDebugChunks++ : request.pendingChunks++;
       var binaryLength = byteLengthOfChunk(text);
-      id = id.toString(16) + ":T" + binaryLength.toString(16) + ",";
+      id = id.toString(16) + ':T' + binaryLength.toString(16) + ',';
       debug
         ? request.completedDebugChunks.push(id, text)
         : request.completedRegularChunks.push(id, text);
@@ -3195,17 +3195,17 @@
       counter,
       parent,
       parentPropertyName,
-      value
+      value,
     ) {
       if (null === value) return null;
-      if (value === REACT_ELEMENT_TYPE) return "$";
-      if ("object" === typeof value) {
+      if (value === REACT_ELEMENT_TYPE) return '$';
+      if ('object' === typeof value) {
         if (isClientReference(value))
           return serializeDebugClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (value.$$typeof === CONSTRUCTOR_MARKER) {
           value = value.constructor;
@@ -3213,18 +3213,18 @@
           void 0 === ref &&
             ((request = outlineDebugModel(request, counter, value)),
             (ref = serializeByValueID(request)));
-          return "$P" + ref.slice(1);
+          return '$P' + ref.slice(1);
         }
         if (void 0 !== request.temporaryReferences) {
           var tempRef = request.temporaryReferences.get(value);
-          if (void 0 !== tempRef) return "$T" + tempRef;
+          if (void 0 !== tempRef) return '$T' + tempRef;
         }
         tempRef = request.writtenDebugObjects;
         var existingDebugReference = tempRef.get(value);
         if (void 0 !== existingDebugReference)
           if (debugModelRoot === value) debugModelRoot = null;
           else return existingDebugReference;
-        else if (-1 === parentPropertyName.indexOf(":"))
+        else if (-1 === parentPropertyName.indexOf(':'))
           if (
             ((existingDebugReference = tempRef.get(parent)),
             void 0 !== existingDebugReference)
@@ -3234,21 +3234,21 @@
             var propertyName = parentPropertyName;
             if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
               switch (parentPropertyName) {
-                case "1":
-                  propertyName = "type";
+                case '1':
+                  propertyName = 'type';
                   break;
-                case "2":
-                  propertyName = "key";
+                case '2':
+                  propertyName = 'key';
                   break;
-                case "3":
-                  propertyName = "props";
+                case '3':
+                  propertyName = 'props';
                   break;
-                case "4":
-                  propertyName = "_owner";
+                case '4':
+                  propertyName = '_owner';
               }
-            tempRef.set(value, existingDebugReference + ":" + propertyName);
+            tempRef.set(value, existingDebugReference + ':' + propertyName);
           } else if (debugNoOutline !== value) {
-            if ("function" === typeof value.then)
+            if ('function' === typeof value.then)
               return serializeDebugThenable(request, counter, value);
             request = outlineDebugModel(request, counter, value);
             return serializeByValueID(request);
@@ -3271,17 +3271,17 @@
               request,
               parentPropertyName,
               counter,
-              value
+              value,
             ),
             serializeByValueID(parentPropertyName)
           );
         switch (value.$$typeof) {
           case REACT_ELEMENT_TYPE:
             null != value._owner && outlineComponentInfo(request, value._owner);
-            "object" === typeof value.type &&
+            'object' === typeof value.type &&
               null !== value.type &&
               doNotLimit.add(value.type);
-            "object" === typeof value.key &&
+            'object' === typeof value.key &&
               null !== value.key &&
               doNotLimit.add(value.key);
             doNotLimit.add(value.props);
@@ -3291,7 +3291,7 @@
               for (
                 counter = filterStackTrace(
                   request,
-                  parseStackTrace(value._debugStack, 1)
+                  parseStackTrace(value._debugStack, 1),
                 ),
                   doNotLimit.add(counter),
                   request = 0;
@@ -3306,18 +3306,18 @@
               value.props,
               value._owner,
               counter,
-              value._store.validated
+              value._store.validated,
             ];
           case REACT_LAZY_TYPE:
             value = value._payload;
-            if (null !== value && "object" === typeof value) {
+            if (null !== value && 'object' === typeof value) {
               switch (value._status) {
                 case 1:
                   return (
                     (request = outlineDebugModel(
                       request,
                       counter,
-                      value._result
+                      value._result,
                     )),
                     serializeLazyID(request)
                   );
@@ -3327,34 +3327,34 @@
                     emitErrorChunk(
                       request,
                       counter,
-                      "",
+                      '',
                       value._result,
                       !0,
-                      null
+                      null,
                     ),
                     serializeLazyID(counter)
                   );
               }
               switch (value.status) {
-                case "fulfilled":
+                case 'fulfilled':
                   return (
                     (request = outlineDebugModel(
                       request,
                       counter,
-                      value.value
+                      value.value,
                     )),
                     serializeLazyID(request)
                   );
-                case "rejected":
+                case 'rejected':
                   return (
                     (counter = request.nextChunkId++),
                     emitErrorChunk(
                       request,
                       counter,
-                      "",
+                      '',
                       value.reason,
                       !0,
-                      null
+                      null,
                     ),
                     serializeLazyID(counter)
                   );
@@ -3365,7 +3365,7 @@
             emitDebugHaltChunk(request, value);
             return serializeLazyID(value);
         }
-        if ("function" === typeof value.then)
+        if ('function' === typeof value.then)
           return serializeDebugThenable(request, counter, value);
         if (isArrayImpl(value)) return value;
         if (value instanceof Map) {
@@ -3376,81 +3376,81 @@
             doNotLimit.add(entry);
             var key = entry[0];
             entry = entry[1];
-            "object" === typeof key && null !== key && doNotLimit.add(key);
-            "object" === typeof entry &&
+            'object' === typeof key && null !== key && doNotLimit.add(key);
+            'object' === typeof entry &&
               null !== entry &&
               doNotLimit.add(entry);
           }
-          return "$Q" + outlineDebugModel(request, counter, value).toString(16);
+          return '$Q' + outlineDebugModel(request, counter, value).toString(16);
         }
         if (value instanceof Set) {
           value = Array.from(value);
           counter.objectLimit++;
           for (ref = 0; ref < value.length; ref++)
             (key = value[ref]),
-              "object" === typeof key && null !== key && doNotLimit.add(key);
-          return "$W" + outlineDebugModel(request, counter, value).toString(16);
+              'object' === typeof key && null !== key && doNotLimit.add(key);
+          return '$W' + outlineDebugModel(request, counter, value).toString(16);
         }
-        if ("function" === typeof FormData && value instanceof FormData)
+        if ('function' === typeof FormData && value instanceof FormData)
           return (
             (value = Array.from(value.entries())),
-            "$K" +
+            '$K' +
               outlineDebugModel(
                 request,
                 { objectLimit: 2 * value.length + 1 },
-                value
+                value,
               ).toString(16)
           );
         if (value instanceof Error) {
-          counter = "Error";
+          counter = 'Error';
           var env = (0, request.environmentName)();
           try {
             (counter = value.name),
               (ref = String(value.message)),
               (key = filterStackTrace(request, parseStackTrace(value, 0))),
               (entry = value.environmentName),
-              "string" === typeof entry && (env = entry);
+              'string' === typeof entry && (env = entry);
           } catch (x) {
             (ref =
-              "An error occurred but serializing the error message failed."),
+              'An error occurred but serializing the error message failed.'),
               (key = []);
           }
           request =
-            "$Z" +
+            '$Z' +
             outlineDebugModel(
               request,
               { objectLimit: 2 * key.length + 1 },
-              { name: counter, message: ref, stack: key, env: env }
+              { name: counter, message: ref, stack: key, env: env },
             ).toString(16);
           return request;
         }
         if (value instanceof ArrayBuffer)
-          return serializeDebugTypedArray(request, "A", new Uint8Array(value));
+          return serializeDebugTypedArray(request, 'A', new Uint8Array(value));
         if (value instanceof Int8Array)
-          return serializeDebugTypedArray(request, "O", value);
+          return serializeDebugTypedArray(request, 'O', value);
         if (value instanceof Uint8Array)
-          return serializeDebugTypedArray(request, "o", value);
+          return serializeDebugTypedArray(request, 'o', value);
         if (value instanceof Uint8ClampedArray)
-          return serializeDebugTypedArray(request, "U", value);
+          return serializeDebugTypedArray(request, 'U', value);
         if (value instanceof Int16Array)
-          return serializeDebugTypedArray(request, "S", value);
+          return serializeDebugTypedArray(request, 'S', value);
         if (value instanceof Uint16Array)
-          return serializeDebugTypedArray(request, "s", value);
+          return serializeDebugTypedArray(request, 's', value);
         if (value instanceof Int32Array)
-          return serializeDebugTypedArray(request, "L", value);
+          return serializeDebugTypedArray(request, 'L', value);
         if (value instanceof Uint32Array)
-          return serializeDebugTypedArray(request, "l", value);
+          return serializeDebugTypedArray(request, 'l', value);
         if (value instanceof Float32Array)
-          return serializeDebugTypedArray(request, "G", value);
+          return serializeDebugTypedArray(request, 'G', value);
         if (value instanceof Float64Array)
-          return serializeDebugTypedArray(request, "g", value);
+          return serializeDebugTypedArray(request, 'g', value);
         if (value instanceof BigInt64Array)
-          return serializeDebugTypedArray(request, "M", value);
+          return serializeDebugTypedArray(request, 'M', value);
         if (value instanceof BigUint64Array)
-          return serializeDebugTypedArray(request, "m", value);
+          return serializeDebugTypedArray(request, 'm', value);
         if (value instanceof DataView)
-          return serializeDebugTypedArray(request, "V", value);
-        if ("function" === typeof Blob && value instanceof Blob)
+          return serializeDebugTypedArray(request, 'V', value);
+        if ('function' === typeof Blob && value instanceof Blob)
           return serializeDebugBlob(request, value);
         if (getIteratorFn(value)) return Array.from(value);
         request = getPrototypeOf(value);
@@ -3460,21 +3460,21 @@
             if (hasOwnProperty.call(value, env) || isGetter(request, env))
               counter[env] = value[env];
           ref = request.constructor;
-          "function" !== typeof ref ||
+          'function' !== typeof ref ||
             ref.prototype !== request ||
-            hasOwnProperty.call(value, "") ||
-            isGetter(request, "") ||
-            (counter[""] = { $$typeof: CONSTRUCTOR_MARKER, constructor: ref });
+            hasOwnProperty.call(value, '') ||
+            isGetter(request, '') ||
+            (counter[''] = { $$typeof: CONSTRUCTOR_MARKER, constructor: ref });
           return counter;
         }
         return value;
       }
-      if ("string" === typeof value) {
+      if ('string' === typeof value) {
         if (
-          "Z" === value[value.length - 1] &&
+          'Z' === value[value.length - 1] &&
           parent[parentPropertyName] instanceof Date
         )
-          return "$D" + value;
+          return '$D' + value;
         if (1024 <= value.length) {
           if (0 >= counter.objectLimit)
             return serializeDeferredObject(request, value);
@@ -3484,39 +3484,39 @@
           emitTextChunk(request, counter, value, !0);
           return serializeByValueID(counter);
         }
-        return "$" === value[0] ? "$" + value : value;
+        return '$' === value[0] ? '$' + value : value;
       }
-      if ("boolean" === typeof value) return value;
-      if ("number" === typeof value) return serializeNumber(value);
-      if ("undefined" === typeof value) return "$undefined";
-      if ("function" === typeof value) {
+      if ('boolean' === typeof value) return value;
+      if ('number' === typeof value) return serializeNumber(value);
+      if ('undefined' === typeof value) return '$undefined';
+      if ('function' === typeof value) {
         if (isClientReference(value))
           return serializeDebugClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (
           void 0 !== request.temporaryReferences &&
           ((counter = request.temporaryReferences.get(value)),
           void 0 !== counter)
         )
-          return "$T" + counter;
+          return '$T' + counter;
         counter = request.writtenDebugObjects;
         ref = counter.get(value);
         if (void 0 !== ref) return ref;
         ref = Function.prototype.toString.call(value);
         key = value.name;
         key =
-          "$E" +
-          ("string" === typeof key
-            ? "Object.defineProperty(" +
+          '$E' +
+          ('string' === typeof key
+            ? 'Object.defineProperty(' +
               ref +
               ',"name",{value:' +
               JSON.stringify(key) +
-              "})"
-            : "(" + ref + ")");
+              '})'
+            : '(' + ref + ')');
         request.pendingDebugChunks++;
         ref = request.nextChunkId++;
         key = encodeReferenceChunk(request, ref, key);
@@ -3525,7 +3525,7 @@
         counter.set(value, request);
         return request;
       }
-      if ("symbol" === typeof value) {
+      if ('symbol' === typeof value) {
         counter = request.writtenSymbols.get(value);
         if (void 0 !== counter) return serializeByValueID(counter);
         value = value.description;
@@ -3534,11 +3534,11 @@
         emitSymbolChunk(request, counter, value);
         return serializeByValueID(counter);
       }
-      return "bigint" === typeof value
-        ? "$n" + value.toString(10)
+      return 'bigint' === typeof value
+        ? '$n' + value.toString(10)
         : value instanceof Date
-          ? "$D" + value.toJSON()
-          : "unknown type " + typeof value;
+          ? '$D' + value.toJSON()
+          : 'unknown type ' + typeof value;
     }
     function serializeDebugModel(request, objectLimit, model) {
       function replacer(parentPropertyName, value) {
@@ -3548,11 +3548,11 @@
             counter,
             this,
             parentPropertyName,
-            value
+            value,
           );
         } catch (x) {
           return (
-            "Unknown Value: React could not send it from the server.\n" +
+            'Unknown Value: React could not send it from the server.\n' +
             x.message
           );
         }
@@ -3564,8 +3564,8 @@
         return stringify(model, replacer);
       } catch (x) {
         return stringify(
-          "Unknown Value: React could not send it from the server.\n" +
-            x.message
+          'Unknown Value: React could not send it from the server.\n' +
+            x.message,
         );
       } finally {
         debugNoOutline = objectLimit;
@@ -3579,32 +3579,32 @@
             counter,
             this,
             parentPropertyName,
-            value
+            value,
           );
         } catch (x) {
           return (
-            "Unknown Value: React could not send it from the server.\n" +
+            'Unknown Value: React could not send it from the server.\n' +
             x.message
           );
         }
       }
-      "object" === typeof model && null !== model && doNotLimit.add(model);
+      'object' === typeof model && null !== model && doNotLimit.add(model);
       var prevModelRoot = debugModelRoot;
       debugModelRoot = model;
-      "object" === typeof model &&
+      'object' === typeof model &&
         null !== model &&
         request.writtenDebugObjects.set(model, serializeByValueID(id));
       try {
         var json = stringify(model, replacer);
       } catch (x) {
         json = stringify(
-          "Unknown Value: React could not send it from the server.\n" +
-            x.message
+          'Unknown Value: React could not send it from the server.\n' +
+            x.message,
         );
       } finally {
         debugModelRoot = prevModelRoot;
       }
-      id = id.toString(16) + ":" + json + "\n";
+      id = id.toString(16) + ':' + json + '\n';
       request.completedDebugChunks.push(id);
     }
     function outlineDebugModel(request, counter, model) {
@@ -3615,14 +3615,14 @@
     }
     function emitTimeOriginChunk(request, timeOrigin) {
       request.pendingDebugChunks++;
-      request.completedDebugChunks.push(":N" + timeOrigin + "\n");
+      request.completedDebugChunks.push(':N' + timeOrigin + '\n');
     }
     function forwardDebugInfo(request$jscomp$0, task, debugInfo) {
       for (var id = task.id, i = 0; i < debugInfo.length; i++) {
         var info = debugInfo[i];
-        if ("number" === typeof info.time)
+        if ('number' === typeof info.time)
           markOperationEndTime(request$jscomp$0, task, info.time);
-        else if ("string" === typeof info.name)
+        else if ('string' === typeof info.name)
           outlineComponentInfo(request$jscomp$0, info),
             request$jscomp$0.pendingChunks++,
             emitDebugChunk(request$jscomp$0, id, info);
@@ -3641,7 +3641,7 @@
                 null != ioInfo$jscomp$0.debugStack
                   ? filterStackTrace(
                       request,
-                      parseStackTrace(ioInfo$jscomp$0.debugStack, 1)
+                      parseStackTrace(ioInfo$jscomp$0.debugStack, 1),
                     )
                   : ioInfo$jscomp$0.stack;
               emitIOInfoChunk(
@@ -3653,11 +3653,11 @@
                 ioInfo$jscomp$0.value,
                 ioInfo$jscomp$0.env,
                 owner,
-                debugStack
+                debugStack,
               );
               request.writtenDebugObjects.set(
                 ioInfo$jscomp$0,
-                serializeByValueID(id$jscomp$0)
+                serializeByValueID(id$jscomp$0),
               );
             }
             null != info.owner &&
@@ -3666,7 +3666,7 @@
               null == info.stack && null != info.debugStack
                 ? filterStackTrace(
                     request$jscomp$0,
-                    parseStackTrace(info.debugStack, 1)
+                    parseStackTrace(info.debugStack, 1),
                   )
                 : info.stack;
             ioInfo = { awaited: ioInfo };
@@ -3686,7 +3686,7 @@
       task,
       thenable,
       owner,
-      stack
+      stack,
     ) {
       var debugInfo;
       (debugInfo = thenable._debugInfo) &&
@@ -3705,16 +3705,16 @@
     }
     function forwardDebugInfoFromAbortedTask(request, task) {
       var model = task.model;
-      if ("object" === typeof model && null !== model) {
+      if ('object' === typeof model && null !== model) {
         var debugInfo;
         (debugInfo = model._debugInfo) &&
           forwardDebugInfo(request, task, debugInfo);
         var thenable = null;
-        "function" === typeof model.then
+        'function' === typeof model.then
           ? (thenable = model)
           : model.$$typeof === REACT_LAZY_TYPE &&
             ((model = model._payload),
-            "function" === typeof model.then && (thenable = model));
+            'function' === typeof model.then && (thenable = model));
         if (
           null !== thenable &&
           ((model = getAsyncSequenceFromPromise(thenable)), null !== model)
@@ -3738,15 +3738,15 @@
     }
     function emitTimingChunk(request, id, timestamp) {
       request.pendingChunks++;
-      var json = '{"time":' + (timestamp - request.timeOrigin) + "}";
+      var json = '{"time":' + (timestamp - request.timeOrigin) + '}';
       null !== request.debugDestination
         ? ((timestamp = request.nextChunkId++),
-          (json = timestamp.toString(16) + ":" + json + "\n"),
+          (json = timestamp.toString(16) + ':' + json + '\n'),
           request.pendingDebugChunks++,
           request.completedDebugChunks.push(json),
           (id = id.toString(16) + ':D"$' + timestamp.toString(16) + '"\n'),
           request.completedRegularChunks.push(id))
-        : ((id = id.toString(16) + ":D" + json + "\n"),
+        : ((id = id.toString(16) + ':D' + json + '\n'),
           request.completedRegularChunks.push(id));
     }
     function advanceTaskTime(request, task, timestamp) {
@@ -3765,52 +3765,52 @@
     }
     function emitChunk(request, task, value) {
       var id = task.id;
-      "string" === typeof value && null !== byteLengthOfChunk
+      'string' === typeof value && null !== byteLengthOfChunk
         ? emitTextChunk(request, id, value, !1)
         : value instanceof ArrayBuffer
-          ? emitTypedArrayChunk(request, id, "A", new Uint8Array(value), !1)
+          ? emitTypedArrayChunk(request, id, 'A', new Uint8Array(value), !1)
           : value instanceof Int8Array
-            ? emitTypedArrayChunk(request, id, "O", value, !1)
+            ? emitTypedArrayChunk(request, id, 'O', value, !1)
             : value instanceof Uint8Array
-              ? emitTypedArrayChunk(request, id, "o", value, !1)
+              ? emitTypedArrayChunk(request, id, 'o', value, !1)
               : value instanceof Uint8ClampedArray
-                ? emitTypedArrayChunk(request, id, "U", value, !1)
+                ? emitTypedArrayChunk(request, id, 'U', value, !1)
                 : value instanceof Int16Array
-                  ? emitTypedArrayChunk(request, id, "S", value, !1)
+                  ? emitTypedArrayChunk(request, id, 'S', value, !1)
                   : value instanceof Uint16Array
-                    ? emitTypedArrayChunk(request, id, "s", value, !1)
+                    ? emitTypedArrayChunk(request, id, 's', value, !1)
                     : value instanceof Int32Array
-                      ? emitTypedArrayChunk(request, id, "L", value, !1)
+                      ? emitTypedArrayChunk(request, id, 'L', value, !1)
                       : value instanceof Uint32Array
-                        ? emitTypedArrayChunk(request, id, "l", value, !1)
+                        ? emitTypedArrayChunk(request, id, 'l', value, !1)
                         : value instanceof Float32Array
-                          ? emitTypedArrayChunk(request, id, "G", value, !1)
+                          ? emitTypedArrayChunk(request, id, 'G', value, !1)
                           : value instanceof Float64Array
-                            ? emitTypedArrayChunk(request, id, "g", value, !1)
+                            ? emitTypedArrayChunk(request, id, 'g', value, !1)
                             : value instanceof BigInt64Array
-                              ? emitTypedArrayChunk(request, id, "M", value, !1)
+                              ? emitTypedArrayChunk(request, id, 'M', value, !1)
                               : value instanceof BigUint64Array
                                 ? emitTypedArrayChunk(
                                     request,
                                     id,
-                                    "m",
+                                    'm',
                                     value,
-                                    !1
+                                    !1,
                                   )
                                 : value instanceof DataView
                                   ? emitTypedArrayChunk(
                                       request,
                                       id,
-                                      "V",
+                                      'V',
                                       value,
-                                      !1
+                                      !1,
                                     )
                                   : ((value = stringify(value, task.toJSON)),
                                     (task =
                                       task.id.toString(16) +
-                                      ":" +
+                                      ':' +
                                       value +
-                                      "\n"),
+                                      '\n'),
                                     request.completedRegularChunks.push(task));
     }
     function erroredTask(request, task, error) {
@@ -3833,8 +3833,8 @@
             request,
             task,
             emptyRoot,
-            "",
-            task.model
+            '',
+            task.model,
           );
           canEmitDebugInfo = !1;
           modelRoot = resolvedModel;
@@ -3845,15 +3845,15 @@
             (request.pendingChunks++,
             emitDebugChunk(request, task.id, { env: currentEnv }));
           task.timed && markOperationEndTime(request, task, performance.now());
-          if ("object" === typeof resolvedModel && null !== resolvedModel)
+          if ('object' === typeof resolvedModel && null !== resolvedModel)
             request.writtenObjects.set(
               resolvedModel,
-              serializeByValueID(task.id)
+              serializeByValueID(task.id),
             ),
               emitChunk(request, task, resolvedModel);
           else {
             var json = stringify(resolvedModel),
-              processedChunk = task.id.toString(16) + ":" + json + "\n";
+              processedChunk = task.id.toString(16) + ':' + json + '\n';
             request.completedRegularChunks.push(processedChunk);
           }
           task.status = 1;
@@ -3878,9 +3878,9 @@
                 ? getSuspendedThenable()
                 : thrownValue;
             if (
-              "object" === typeof x &&
+              'object' === typeof x &&
               null !== x &&
-              "function" === typeof x.then
+              'function' === typeof x.then
             ) {
               task.status = 0;
               task.thenableState = getThenableStateAfterSuspending();
@@ -3980,7 +3980,7 @@
               (request.pendingChunks--,
               !writeChunkAndReturn(
                 debugDestination,
-                importsChunks[debugChunks]
+                importsChunks[debugChunks],
               ))
             ) {
               request.destination = null;
@@ -4009,7 +4009,7 @@
                 (request.pendingDebugChunks--,
                 !writeChunkAndReturn(
                   debugDestination,
-                  _debugChunks[debugChunks]
+                  _debugChunks[debugChunks],
                 ))
               ) {
                 request.destination = null;
@@ -4028,7 +4028,7 @@
               (request.pendingChunks--,
               !writeChunkAndReturn(
                 debugDestination,
-                regularChunks[debugChunks]
+                regularChunks[debugChunks],
               ))
             ) {
               request.destination = null;
@@ -4060,8 +4060,8 @@
             request.status < ABORTING &&
               request.cacheController.abort(
                 Error(
-                  "This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources."
-                )
+                  'This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources.',
+                ),
               ),
             null !== request.destination &&
               ((request.status = CLOSED),
@@ -4166,13 +4166,13 @@
               var error =
                   void 0 === reason
                     ? Error(
-                        "The render was aborted by the server without a reason."
+                        'The render was aborted by the server without a reason.',
                       )
-                    : "object" === typeof reason &&
+                    : 'object' === typeof reason &&
                         null !== reason &&
-                        "function" === typeof reason.then
+                        'function' === typeof reason.then
                       ? Error(
-                          "The render was aborted by the server with a promise."
+                          'The render was aborted by the server with a promise.',
                         )
                       : reason,
                 digest = logRecoverableError(request, error, null),
@@ -4204,12 +4204,12 @@
       var deferredDebugObjects = request.deferredDebugObjects;
       if (null === deferredDebugObjects)
         throw Error(
-          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React."
+          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React.",
         );
-      if ("" === message) closeDebugChannel(request);
+      if ('' === message) closeDebugChannel(request);
       else {
         var command = message.charCodeAt(0);
-        message = message.slice(2).split(",").map(fromHex);
+        message = message.slice(2).split(',').map(fromHex);
         switch (command) {
           case 82:
             for (command = 0; command < message.length; command++) {
@@ -4233,7 +4233,7 @@
                     request,
                     id,
                     { objectLimit: 10 },
-                    retainedValue
+                    retainedValue,
                   ),
                   enqueueFlush(request));
             break;
@@ -4247,12 +4247,12 @@
                     request,
                     id,
                     { objectLimit: 10 },
-                    retainedValue
+                    retainedValue,
                   ));
             break;
           default:
             throw Error(
-              "Unknown command. The debugChannel was not wired up properly."
+              'Unknown command. The debugChannel was not wired up properly.',
             );
         }
       }
@@ -4261,7 +4261,7 @@
       var deferredDebugObjects = request.deferredDebugObjects;
       if (null === deferredDebugObjects)
         throw Error(
-          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React."
+          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React.",
         );
       deferredDebugObjects.retained.forEach(function (value, id) {
         request.pendingDebugChunks--;
@@ -4271,11 +4271,11 @@
       enqueueFlush(request);
     }
     function resolveServerReference(bundlerConfig, id) {
-      var name = "",
+      var name = '',
         resolvedModuleData = bundlerConfig[id];
       if (resolvedModuleData) name = resolvedModuleData.name;
       else {
-        var idx = id.lastIndexOf("#");
+        var idx = id.lastIndexOf('#');
         -1 !== idx &&
           ((name = id.slice(idx + 1)),
           (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -4283,7 +4283,7 @@
           throw Error(
             'Could not find the module "' +
               id +
-              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+              '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
           );
       }
       return resolvedModuleData.async
@@ -4292,17 +4292,17 @@
     }
     function requireAsyncModule(id) {
       var promise = __webpack_require__(id);
-      if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+      if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
         return null;
       promise.then(
         function (value) {
-          promise.status = "fulfilled";
+          promise.status = 'fulfilled';
           promise.value = value;
         },
         function (reason) {
-          promise.status = "rejected";
+          promise.status = 'rejected';
           promise.reason = reason;
-        }
+        },
       );
       return promise;
     }
@@ -4336,13 +4336,13 @@
     }
     function requireModule(metadata) {
       var moduleExports = __webpack_require__(metadata[0]);
-      if (4 === metadata.length && "function" === typeof moduleExports.then)
-        if ("fulfilled" === moduleExports.status)
+      if (4 === metadata.length && 'function' === typeof moduleExports.then)
+        if ('fulfilled' === moduleExports.status)
           moduleExports = moduleExports.value;
         else throw moduleExports.reason;
-      return "*" === metadata[2]
+      return '*' === metadata[2]
         ? moduleExports
-        : "" === metadata[2]
+        : '' === metadata[2]
           ? moduleExports.__esModule
             ? moduleExports.default
             : moduleExports
@@ -4355,41 +4355,41 @@
       this._response = response;
     }
     function createPendingChunk(response) {
-      return new Chunk("pending", null, null, response);
+      return new Chunk('pending', null, null, response);
     }
     function wakeChunk(listeners, value) {
       for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
     }
     function triggerErrorOnChunk(chunk, error) {
-      if ("pending" !== chunk.status && "blocked" !== chunk.status)
+      if ('pending' !== chunk.status && 'blocked' !== chunk.status)
         chunk.reason.error(error);
       else {
         var listeners = chunk.reason;
-        chunk.status = "rejected";
+        chunk.status = 'rejected';
         chunk.reason = error;
         null !== listeners && wakeChunk(listeners, error);
       }
     }
     function resolveModelChunk(chunk, value, id) {
-      if ("pending" !== chunk.status)
+      if ('pending' !== chunk.status)
         (chunk = chunk.reason),
-          "C" === value[0]
-            ? chunk.close("C" === value ? '"$undefined"' : value.slice(1))
+          'C' === value[0]
+            ? chunk.close('C' === value ? '"$undefined"' : value.slice(1))
             : chunk.enqueueModel(value);
       else {
         var resolveListeners = chunk.value,
           rejectListeners = chunk.reason;
-        chunk.status = "resolved_model";
+        chunk.status = 'resolved_model';
         chunk.value = value;
         chunk.reason = id;
         if (null !== resolveListeners)
           switch ((initializeModelChunk(chunk), chunk.status)) {
-            case "fulfilled":
+            case 'fulfilled':
               wakeChunk(resolveListeners, chunk.value);
               break;
-            case "pending":
-            case "blocked":
-            case "cyclic":
+            case 'pending':
+            case 'blocked':
+            case 'cyclic':
               if (chunk.value)
                 for (value = 0; value < resolveListeners.length; value++)
                   chunk.value.push(resolveListeners[value]);
@@ -4400,19 +4400,19 @@
                     chunk.reason.push(rejectListeners[value]);
               } else chunk.reason = rejectListeners;
               break;
-            case "rejected":
+            case 'rejected':
               rejectListeners && wakeChunk(rejectListeners, chunk.reason);
           }
       }
     }
     function createResolvedIteratorResultChunk(response, value, done) {
       return new Chunk(
-        "resolved_model",
+        'resolved_model',
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
+          '}',
         -1,
-        response
+        response,
       );
     }
     function resolveIteratorResultChunk(chunk, value, done) {
@@ -4420,8 +4420,8 @@
         chunk,
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
-        -1
+          '}',
+        -1,
       );
     }
     function loadServerReference$1(
@@ -4430,7 +4430,7 @@
       bound,
       parentChunk,
       parentObject,
-      key
+      key,
     ) {
       var serverReference = resolveServerReference(response._bundlerConfig, id);
       id = preloadModule(serverReference);
@@ -4453,22 +4453,22 @@
           !1,
           response,
           createModel,
-          []
+          [],
         ),
-        createModelReject(parentChunk)
+        createModelReject(parentChunk),
       );
       return null;
     }
     function reviveModel(response, parentObj, parentKey, value, reference) {
-      if ("string" === typeof value)
+      if ('string' === typeof value)
         return parseModelString(
           response,
           parentObj,
           parentKey,
           value,
-          reference
+          reference,
         );
-      if ("object" === typeof value && null !== value)
+      if ('object' === typeof value && null !== value)
         if (
           (void 0 !== reference &&
             void 0 !== response._temporaryReferences &&
@@ -4479,23 +4479,23 @@
             value[i] = reviveModel(
               response,
               value,
-              "" + i,
+              '' + i,
               value[i],
-              void 0 !== reference ? reference + ":" + i : void 0
+              void 0 !== reference ? reference + ':' + i : void 0,
             );
         else
           for (i in value)
             hasOwnProperty.call(value, i) &&
               ((parentObj =
-                void 0 !== reference && -1 === i.indexOf(":")
-                  ? reference + ":" + i
+                void 0 !== reference && -1 === i.indexOf(':')
+                  ? reference + ':' + i
                   : void 0),
               (parentObj = reviveModel(
                 response,
                 value,
                 i,
                 value[i],
-                parentObj
+                parentObj,
               )),
               void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);
       return value;
@@ -4508,32 +4508,32 @@
       var rootReference =
           -1 === chunk.reason ? void 0 : chunk.reason.toString(16),
         resolvedModel = chunk.value;
-      chunk.status = "cyclic";
+      chunk.status = 'cyclic';
       chunk.value = null;
       chunk.reason = null;
       try {
         var rawModel = JSON.parse(resolvedModel),
           value = reviveModel(
             chunk._response,
-            { "": rawModel },
-            "",
+            { '': rawModel },
+            '',
             rawModel,
-            rootReference
+            rootReference,
           );
         if (
           null !== initializingChunkBlockedModel &&
           0 < initializingChunkBlockedModel.deps
         )
           (initializingChunkBlockedModel.value = value),
-            (chunk.status = "blocked");
+            (chunk.status = 'blocked');
         else {
           var resolveListeners = chunk.value;
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = value;
           null !== resolveListeners && wakeChunk(resolveListeners, value);
         }
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       } finally {
         (initializingChunk = prevChunk),
           (initializingChunkBlockedModel = prevBlocked);
@@ -4543,7 +4543,7 @@
       response._closed = !0;
       response._closedReason = error;
       response._chunks.forEach(function (chunk) {
-        "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+        'pending' === chunk.status && triggerErrorOnChunk(chunk, error);
       });
     }
     function getChunk(response, id) {
@@ -4553,9 +4553,9 @@
         ((chunk = response._formData.get(response._prefix + id)),
         (chunk =
           null != chunk
-            ? new Chunk("resolved_model", chunk, id, response)
+            ? new Chunk('resolved_model', chunk, id, response)
             : response._closed
-              ? new Chunk("rejected", null, response._closedReason, response)
+              ? new Chunk('rejected', null, response._closedReason, response)
               : createPendingChunk(response)),
         chunks.set(id, chunk));
       return chunk;
@@ -4567,7 +4567,7 @@
       cyclic,
       response,
       map,
-      path
+      path,
     ) {
       if (initializingChunkBlockedModel) {
         var blocked = initializingChunkBlockedModel;
@@ -4575,19 +4575,19 @@
       } else
         blocked = initializingChunkBlockedModel = {
           deps: cyclic ? 0 : 1,
-          value: null
+          value: null,
         };
       return function (value) {
         for (var i = 1; i < path.length; i++) value = value[path[i]];
         parentObject[key] = map(response, value);
-        "" === key &&
+        '' === key &&
           null === blocked.value &&
           (blocked.value = parentObject[key]);
         blocked.deps--;
         0 === blocked.deps &&
-          "blocked" === chunk.status &&
+          'blocked' === chunk.status &&
           ((value = chunk.value),
-          (chunk.status = "fulfilled"),
+          (chunk.status = 'fulfilled'),
           (chunk.value = blocked.value),
           null !== value && wakeChunk(value, blocked.value));
       };
@@ -4598,34 +4598,34 @@
       };
     }
     function getOutlinedModel(response, reference, parentObject, key, map) {
-      reference = reference.split(":");
+      reference = reference.split(':');
       var id = parseInt(reference[0], 16);
       id = getChunk(response, id);
       switch (id.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(id);
       }
       switch (id.status) {
-        case "fulfilled":
+        case 'fulfilled':
           parentObject = id.value;
           for (key = 1; key < reference.length; key++)
             parentObject = parentObject[reference[key]];
           return map(response, parentObject);
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           var parentChunk = initializingChunk;
           id.then(
             createModelResolver(
               parentChunk,
               parentObject,
               key,
-              "cyclic" === id.status,
+              'cyclic' === id.status,
               response,
               map,
-              reference
+              reference,
             ),
-            createModelReject(parentChunk)
+            createModelReject(parentChunk),
           );
           return null;
         default:
@@ -4650,7 +4650,7 @@
       constructor,
       bytesPerElement,
       parentObject,
-      parentKey
+      parentKey,
     ) {
       reference = parseInt(reference.slice(2), 16);
       reference = response._formData.get(response._prefix + reference);
@@ -4669,22 +4669,22 @@
           !1,
           response,
           createModel,
-          []
+          [],
         ),
-        createModelReject(bytesPerElement)
+        createModelReject(bytesPerElement),
       );
       return null;
     }
     function resolveStream(response, id, stream, controller) {
       var chunks = response._chunks;
-      stream = new Chunk("fulfilled", stream, controller, response);
+      stream = new Chunk('fulfilled', stream, controller, response);
       chunks.set(id, stream);
       response = response._formData.getAll(response._prefix + id);
       for (id = 0; id < response.length; id++)
         (chunks = response[id]),
-          "C" === chunks[0]
+          'C' === chunks[0]
             ? controller.close(
-                "C" === chunks ? '"$undefined"' : chunks.slice(1)
+                'C' === chunks ? '"$undefined"' : chunks.slice(1),
               )
             : controller.enqueueModel(chunks);
     }
@@ -4695,15 +4695,15 @@
         type: type,
         start: function (c) {
           controller = c;
-        }
+        },
       });
       var previousBlockedChunk = null;
       resolveStream(response, reference, type, {
         enqueueModel: function (json) {
           if (null === previousBlockedChunk) {
-            var chunk = new Chunk("resolved_model", json, -1, response);
+            var chunk = new Chunk('resolved_model', json, -1, response);
             initializeModelChunk(chunk);
-            "fulfilled" === chunk.status
+            'fulfilled' === chunk.status
               ? controller.enqueue(chunk.value)
               : (chunk.then(
                   function (v) {
@@ -4711,7 +4711,7 @@
                   },
                   function (e) {
                     return controller.error(e);
-                  }
+                  },
                 ),
                 (previousBlockedChunk = chunk));
           } else {
@@ -4723,7 +4723,7 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             );
             previousBlockedChunk = _chunk;
             chunk.then(function () {
@@ -4751,7 +4751,7 @@
               return controller.error(error);
             });
           }
-        }
+        },
       });
       return type;
     }
@@ -4773,15 +4773,15 @@
           return createIterator(function (arg) {
             if (void 0 !== arg)
               throw Error(
-                "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+                'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
               );
             if (nextReadIndex === buffer.length) {
               if (closed)
                 return new Chunk(
-                  "fulfilled",
+                  'fulfilled',
                   { done: !0, value: void 0 },
                   null,
-                  response
+                  response,
                 );
               buffer[nextReadIndex] = createPendingChunk(response);
             }
@@ -4795,7 +4795,7 @@
             ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                 response,
                 value,
-                !1
+                !1,
               ))
             : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
           nextWriteIndex++;
@@ -4806,14 +4806,14 @@
             ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                 response,
                 value,
-                !0
+                !0,
               ))
             : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
           for (nextWriteIndex++; nextWriteIndex < buffer.length; )
             resolveIteratorResultChunk(
               buffer[nextWriteIndex++],
               '"$undefined"',
-              !0
+              !0,
             );
         },
         error: function (error) {
@@ -4825,20 +4825,20 @@
 
           )
             triggerErrorOnChunk(buffer[nextWriteIndex++], error);
-        }
+        },
       });
       return iterator;
     }
     function parseModelString(response, obj, key, value, reference) {
-      if ("$" === value[0]) {
+      if ('$' === value[0]) {
         switch (value[1]) {
-          case "$":
+          case '$':
             return value.slice(1);
-          case "@":
+          case '@':
             return (
               (obj = parseInt(value.slice(2), 16)), getChunk(response, obj)
             );
-          case "F":
+          case 'F':
             return (
               (value = value.slice(2)),
               (value = getOutlinedModel(
@@ -4846,7 +4846,7 @@
                 value,
                 obj,
                 key,
-                createModel
+                createModel,
               )),
               loadServerReference$1(
                 response,
@@ -4854,113 +4854,113 @@
                 value.bound,
                 initializingChunk,
                 obj,
-                key
+                key,
               )
             );
-          case "T":
+          case 'T':
             if (
               void 0 === reference ||
               void 0 === response._temporaryReferences
             )
               throw Error(
-                "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+                'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
               );
             return createTemporaryReference(
               response._temporaryReferences,
-              reference
+              reference,
             );
-          case "Q":
+          case 'Q':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, createMap)
             );
-          case "W":
+          case 'W':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, createSet)
             );
-          case "K":
+          case 'K':
             obj = value.slice(2);
-            var formPrefix = response._prefix + obj + "_",
+            var formPrefix = response._prefix + obj + '_',
               data = new FormData();
             response._formData.forEach(function (entry, entryKey) {
               entryKey.startsWith(formPrefix) &&
                 data.append(entryKey.slice(formPrefix.length), entry);
             });
             return data;
-          case "i":
+          case 'i':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, extractIterator)
             );
-          case "I":
+          case 'I':
             return Infinity;
-          case "-":
-            return "$-0" === value ? -0 : -Infinity;
-          case "N":
+          case '-':
+            return '$-0' === value ? -0 : -Infinity;
+          case 'N':
             return NaN;
-          case "u":
+          case 'u':
             return;
-          case "D":
+          case 'D':
             return new Date(Date.parse(value.slice(2)));
-          case "n":
+          case 'n':
             return BigInt(value.slice(2));
         }
         switch (value[1]) {
-          case "A":
+          case 'A':
             return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);
-          case "O":
+          case 'O':
             return parseTypedArray(response, value, Int8Array, 1, obj, key);
-          case "o":
+          case 'o':
             return parseTypedArray(response, value, Uint8Array, 1, obj, key);
-          case "U":
+          case 'U':
             return parseTypedArray(
               response,
               value,
               Uint8ClampedArray,
               1,
               obj,
-              key
+              key,
             );
-          case "S":
+          case 'S':
             return parseTypedArray(response, value, Int16Array, 2, obj, key);
-          case "s":
+          case 's':
             return parseTypedArray(response, value, Uint16Array, 2, obj, key);
-          case "L":
+          case 'L':
             return parseTypedArray(response, value, Int32Array, 4, obj, key);
-          case "l":
+          case 'l':
             return parseTypedArray(response, value, Uint32Array, 4, obj, key);
-          case "G":
+          case 'G':
             return parseTypedArray(response, value, Float32Array, 4, obj, key);
-          case "g":
+          case 'g':
             return parseTypedArray(response, value, Float64Array, 8, obj, key);
-          case "M":
+          case 'M':
             return parseTypedArray(response, value, BigInt64Array, 8, obj, key);
-          case "m":
+          case 'm':
             return parseTypedArray(
               response,
               value,
               BigUint64Array,
               8,
               obj,
-              key
+              key,
             );
-          case "V":
+          case 'V':
             return parseTypedArray(response, value, DataView, 1, obj, key);
-          case "B":
+          case 'B':
             return (
               (obj = parseInt(value.slice(2), 16)),
               response._formData.get(response._prefix + obj)
             );
         }
         switch (value[1]) {
-          case "R":
+          case 'R':
             return parseReadableStream(response, value, void 0);
-          case "r":
-            return parseReadableStream(response, value, "bytes");
-          case "X":
+          case 'r':
+            return parseReadableStream(response, value, 'bytes');
+          case 'X':
             return parseAsyncIterable(response, value, !1);
-          case "x":
+          case 'x':
             return parseAsyncIterable(response, value, !0);
         }
         value = value.slice(1);
@@ -4971,7 +4971,7 @@
     function createResponse(
       bundlerConfig,
       formFieldPrefix,
-      temporaryReferences
+      temporaryReferences,
     ) {
       var backingFormData =
           3 < arguments.length && void 0 !== arguments[3]
@@ -4985,7 +4985,7 @@
         _chunks: chunks,
         _closed: !1,
         _closedReason: null,
-        _temporaryReferences: temporaryReferences
+        _temporaryReferences: temporaryReferences,
       };
     }
     function resolveField(response, key, value) {
@@ -4997,7 +4997,7 @@
         (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));
     }
     function close(response) {
-      reportGlobalError(response, Error("Connection closed."));
+      reportGlobalError(response, Error('Connection closed.'));
     }
     function loadServerReference(bundlerConfig, id, bound) {
       var serverReference = resolveServerReference(bundlerConfig, id);
@@ -5019,7 +5019,7 @@
       close(body);
       body = getChunk(body, 0);
       body.then(function () {});
-      if ("fulfilled" !== body.status) throw body.reason;
+      if ('fulfilled' !== body.status) throw body.reason;
       return body.value;
     }
     function createDrainHandler(destination, request) {
@@ -5035,12 +5035,12 @@
     }
     function startReadingFromDebugChannelReadable(request, stream) {
       function onData(chunk) {
-        if ("string" === typeof chunk) {
+        if ('string' === typeof chunk) {
           if (lastWasPartial) {
             var JSCompiler_temp_const = stringBuffer;
             var JSCompiler_inline_result = new Uint8Array(0);
             JSCompiler_inline_result = stringDecoder.decode(
-              JSCompiler_inline_result
+              JSCompiler_inline_result,
             );
             stringBuffer = JSCompiler_temp_const + JSCompiler_inline_result;
             lastWasPartial = !1;
@@ -5049,7 +5049,7 @@
         } else
           (stringBuffer += stringDecoder.decode(chunk, decoderOptions)),
             (lastWasPartial = !0);
-        chunk = stringBuffer.split("\n");
+        chunk = stringBuffer.split('\n');
         for (
           JSCompiler_temp_const = 0;
           JSCompiler_temp_const < chunk.length - 1;
@@ -5061,7 +5061,7 @@
       function onError(error) {
         abort(
           request,
-          Error("Lost connection to the Debug Channel.", { cause: error })
+          Error('Lost connection to the Debug Channel.', { cause: error }),
         );
       }
       function onClose() {
@@ -5069,20 +5069,20 @@
       }
       var stringDecoder = new util.TextDecoder(),
         lastWasPartial = !1,
-        stringBuffer = "";
-      "function" === typeof stream.addEventListener &&
-      "string" === typeof stream.binaryType
-        ? ((stream.binaryType = "arraybuffer"),
-          stream.addEventListener("message", function (event) {
+        stringBuffer = '';
+      'function' === typeof stream.addEventListener &&
+      'string' === typeof stream.binaryType
+        ? ((stream.binaryType = 'arraybuffer'),
+          stream.addEventListener('message', function (event) {
             onData(event.data);
           }),
-          stream.addEventListener("error", function (event) {
+          stream.addEventListener('error', function (event) {
             onError(event.error);
           }),
-          stream.addEventListener("close", onClose))
-        : (stream.on("data", onData),
-          stream.on("error", onError),
-          stream.on("end", onClose));
+          stream.addEventListener('close', onClose))
+        : (stream.on('data', onData),
+          stream.on('error', onError),
+          stream.on('end', onClose));
     }
     function createFakeWritableFromWebSocket(webSocket) {
       return {
@@ -5094,19 +5094,19 @@
           webSocket.close();
         },
         destroy: function (reason) {
-          "object" === typeof reason &&
+          'object' === typeof reason &&
             null !== reason &&
             (reason = reason.message);
-          "string" === typeof reason
+          'string' === typeof reason
             ? webSocket.close(1011, reason)
             : webSocket.close(1011);
-        }
+        },
       };
     }
     function createFakeWritableFromReadableStreamController(controller) {
       return {
         write: function (chunk) {
-          "string" === typeof chunk && (chunk = textEncoder.encode(chunk));
+          'string' === typeof chunk && (chunk = textEncoder.encode(chunk));
           controller.enqueue(chunk);
           return !0;
         },
@@ -5114,10 +5114,10 @@
           controller.close();
         },
         destroy: function (error) {
-          "function" === typeof controller.error
+          'function' === typeof controller.error
             ? controller.error(error)
             : controller.close();
-        }
+        },
       };
     }
     function startReadingFromDebugChannelReadableStream(request, stream) {
@@ -5130,7 +5130,7 @@
             (buffer = stringDecoder.decode(buffer)))
           : (buffer = stringDecoder.decode(buffer, decoderOptions));
         stringBuffer = _ref + buffer;
-        _ref = stringBuffer.split("\n");
+        _ref = stringBuffer.split('\n');
         for (buffer = 0; buffer < _ref.length - 1; buffer++)
           resolveDebugMessage(request, _ref[buffer]);
         stringBuffer = _ref[_ref.length - 1];
@@ -5140,12 +5140,12 @@
       function error(e) {
         abort(
           request,
-          Error("Lost connection to the Debug Channel.", { cause: e })
+          Error('Lost connection to the Debug Channel.', { cause: e }),
         );
       }
       var reader = stream.getReader(),
         stringDecoder = new util.TextDecoder(),
-        stringBuffer = "";
+        stringBuffer = '';
       reader.read().then(progress).catch(error);
     }
     function createFakeWritableFromNodeReadable(readable) {
@@ -5158,26 +5158,26 @@
         },
         destroy: function (error) {
           readable.destroy(error);
-        }
+        },
       };
     }
-    var stream = require("stream"),
-      util = require("util");
-    require("crypto");
-    var async_hooks = require("async_hooks"),
-      ReactDOM = require("react-dom"),
-      React = require("react"),
-      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-    Symbol.for("react.postpone");
+    var stream = require('stream'),
+      util = require('util');
+    require('crypto');
+    var async_hooks = require('async_hooks'),
+      ReactDOM = require('react-dom'),
+      React = require('react'),
+      REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element'),
+      REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+      REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+      REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+      REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+      REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+      REACT_MEMO_TYPE = Symbol.for('react.memo'),
+      REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+      REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
+    Symbol.for('react.postpone');
     var MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
       ASYNC_ITERATOR = Symbol.asyncIterator,
       scheduleMicrotask = queueMicrotask,
@@ -5185,52 +5185,52 @@
       writtenBytes = 0,
       destinationHasCapacity = !0,
       textEncoder = new util.TextEncoder(),
-      CLIENT_REFERENCE_TAG$1 = Symbol.for("react.client.reference"),
-      SERVER_REFERENCE_TAG = Symbol.for("react.server.reference"),
+      CLIENT_REFERENCE_TAG$1 = Symbol.for('react.client.reference'),
+      SERVER_REFERENCE_TAG = Symbol.for('react.server.reference'),
       FunctionBind = Function.prototype.bind,
       ArraySlice = Array.prototype.slice,
       PROMISE_PROTOTYPE = Promise.prototype,
       deepProxyHandlers = {
         get: function (target, name) {
           switch (name) {
-            case "$$typeof":
+            case '$$typeof':
               return target.$$typeof;
-            case "$$id":
+            case '$$id':
               return target.$$id;
-            case "$$async":
+            case '$$async':
               return target.$$async;
-            case "name":
+            case 'name':
               return target.name;
-            case "displayName":
+            case 'displayName':
               return;
-            case "defaultProps":
+            case 'defaultProps':
               return;
-            case "_debugInfo":
+            case '_debugInfo':
               return;
-            case "toJSON":
+            case 'toJSON':
               return;
             case Symbol.toPrimitive:
               return Object.prototype[Symbol.toPrimitive];
             case Symbol.toStringTag:
               return Object.prototype[Symbol.toStringTag];
-            case "Provider":
+            case 'Provider':
               throw Error(
-                "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+                'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
               );
-            case "then":
+            case 'then':
               throw Error(
-                "Cannot await or return from a thenable. You cannot await a client module from a server component."
+                'Cannot await or return from a thenable. You cannot await a client module from a server component.',
               );
           }
           throw Error(
-            "Cannot access " +
-              (String(target.name) + "." + String(name)) +
-              " on the server. You cannot dot into a client module from a server component. You can only pass the imported name through."
+            'Cannot access ' +
+              (String(target.name) + '.' + String(name)) +
+              ' on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.',
           );
         },
         set: function () {
-          throw Error("Cannot assign to a client module from a server module.");
-        }
+          throw Error('Cannot assign to a client module from a server module.');
+        },
       },
       proxyHandlers$1 = {
         get: function (target, name) {
@@ -5243,7 +5243,7 @@
               value: getReference(target, name),
               writable: !1,
               configurable: !1,
-              enumerable: !1
+              enumerable: !1,
             }),
             Object.defineProperty(target, name, descriptor));
           return descriptor;
@@ -5252,8 +5252,8 @@
           return PROMISE_PROTOTYPE;
         },
         set: function () {
-          throw Error("Cannot assign to a client module from a server module.");
-        }
+          throw Error('Cannot assign to a client module from a server module.');
+        },
       },
       ReactDOMSharedInternals =
         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
@@ -5262,86 +5262,86 @@
       f: previousDispatcher.f,
       r: previousDispatcher.r,
       D: function (href) {
-        if ("string" === typeof href && href) {
+        if ('string' === typeof href && href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "D|" + href;
-            hints.has(key) || (hints.add(key), emitHint(request, "D", href));
+              key = 'D|' + href;
+            hints.has(key) || (hints.add(key), emitHint(request, 'D', href));
           } else previousDispatcher.D(href);
         }
       },
       C: function (href, crossOrigin) {
-        if ("string" === typeof href) {
+        if ('string' === typeof href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
               key =
-                "C|" +
-                (null == crossOrigin ? "null" : crossOrigin) +
-                "|" +
+                'C|' +
+                (null == crossOrigin ? 'null' : crossOrigin) +
+                '|' +
                 href;
             hints.has(key) ||
               (hints.add(key),
-              "string" === typeof crossOrigin
-                ? emitHint(request, "C", [href, crossOrigin])
-                : emitHint(request, "C", href));
+              'string' === typeof crossOrigin
+                ? emitHint(request, 'C', [href, crossOrigin])
+                : emitHint(request, 'C', href));
           } else previousDispatcher.C(href, crossOrigin);
         }
       },
       L: preload,
       m: preloadModule$1,
       X: function (src, options) {
-        if ("string" === typeof src) {
+        if ('string' === typeof src) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "X|" + src;
+              key = 'X|' + src;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "X", [src, options])
-              : emitHint(request, "X", src);
+              ? emitHint(request, 'X', [src, options])
+              : emitHint(request, 'X', src);
           }
           previousDispatcher.X(src, options);
         }
       },
       S: function (href, precedence, options) {
-        if ("string" === typeof href) {
+        if ('string' === typeof href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "S|" + href;
+              key = 'S|' + href;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "S", [
+              ? emitHint(request, 'S', [
                   href,
-                  "string" === typeof precedence ? precedence : 0,
-                  options
+                  'string' === typeof precedence ? precedence : 0,
+                  options,
                 ])
-              : "string" === typeof precedence
-                ? emitHint(request, "S", [href, precedence])
-                : emitHint(request, "S", href);
+              : 'string' === typeof precedence
+                ? emitHint(request, 'S', [href, precedence])
+                : emitHint(request, 'S', href);
           }
           previousDispatcher.S(href, precedence, options);
         }
       },
       M: function (src, options) {
-        if ("string" === typeof src) {
+        if ('string' === typeof src) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "M|" + src;
+              key = 'M|' + src;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "M", [src, options])
-              : emitHint(request, "M", src);
+              ? emitHint(request, 'M', [src, options])
+              : emitHint(request, 'M', src);
           }
           previousDispatcher.M(src, options);
         }
-      }
+      },
     };
     var currentOwner = null,
       getAsyncId = async_hooks.AsyncResource.prototype.asyncId,
@@ -5356,47 +5356,47 @@
       stackTraceCache = new WeakMap(),
       requestStorage = new async_hooks.AsyncLocalStorage(),
       componentStorage = new async_hooks.AsyncLocalStorage(),
-      TEMPORARY_REFERENCE_TAG = Symbol.for("react.temporary.reference"),
+      TEMPORARY_REFERENCE_TAG = Symbol.for('react.temporary.reference'),
       proxyHandlers = {
         get: function (target, name) {
           switch (name) {
-            case "$$typeof":
+            case '$$typeof':
               return target.$$typeof;
-            case "name":
+            case 'name':
               return;
-            case "displayName":
+            case 'displayName':
               return;
-            case "defaultProps":
+            case 'defaultProps':
               return;
-            case "_debugInfo":
+            case '_debugInfo':
               return;
-            case "toJSON":
+            case 'toJSON':
               return;
             case Symbol.toPrimitive:
               return Object.prototype[Symbol.toPrimitive];
             case Symbol.toStringTag:
               return Object.prototype[Symbol.toStringTag];
-            case "Provider":
+            case 'Provider':
               throw Error(
-                "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+                'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
               );
-            case "then":
+            case 'then':
               return;
           }
           throw Error(
-            "Cannot access " +
+            'Cannot access ' +
               String(name) +
-              " on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client."
+              ' on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client.',
           );
         },
         set: function () {
           throw Error(
-            "Cannot assign to a temporary client reference from a server module."
+            'Cannot assign to a temporary client reference from a server module.',
           );
-        }
+        },
       },
       SuspenseException = Error(
-        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
+        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.",
       ),
       suspendedThenable = null,
       currentRequest$1 = null,
@@ -5407,10 +5407,10 @@
         readContext: unsupportedContext,
         use: function (usable) {
           if (
-            (null !== usable && "object" === typeof usable) ||
-            "function" === typeof usable
+            (null !== usable && 'object' === typeof usable) ||
+            'function' === typeof usable
           ) {
-            if ("function" === typeof usable.then) {
+            if ('function' === typeof usable.then) {
               var index = thenableIndexCounter;
               thenableIndexCounter += 1;
               null === thenableState && (thenableState = []);
@@ -5424,12 +5424,12 @@
               usable.value.$$typeof === REACT_CONTEXT_TYPE
             )
               throw Error(
-                "Cannot read a Client Context from a Server Component."
+                'Cannot read a Client Context from a Server Component.',
               );
-            throw Error("Cannot use() an already resolved Client Reference.");
+            throw Error('Cannot use() an already resolved Client Reference.');
           }
           throw Error(
-            "An unsupported type was passed to use(): " + String(usable)
+            'An unsupported type was passed to use(): ' + String(usable),
           );
         },
         useCallback: function (callback) {
@@ -5452,14 +5452,14 @@
         useSyncExternalStore: unsupportedHook,
         useId: function () {
           if (null === currentRequest$1)
-            throw Error("useId can only be used while React is rendering");
+            throw Error('useId can only be used while React is rendering');
           var id = currentRequest$1.identifierCount++;
           return (
-            "_" +
+            '_' +
             currentRequest$1.identifierPrefix +
-            "S_" +
+            'S_' +
             id.toString(32) +
-            "_"
+            '_'
           );
         },
         useHostTransitionStatus: unsupportedHook,
@@ -5473,7 +5473,7 @@
         },
         useCacheRefresh: function () {
           return unsupportedRefresh;
-        }
+        },
       };
     HooksDispatcher.useEffectEvent = unsupportedHook;
     var DefaultAsyncDispatcher = {
@@ -5487,21 +5487,21 @@
       cacheSignal: function () {
         var request = resolveRequest();
         return request ? request.cacheController.signal : null;
-      }
+      },
     };
     DefaultAsyncDispatcher.getOwner = resolveOwner;
     var ReactSharedInternalsServer =
       React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
     if (!ReactSharedInternalsServer)
       throw Error(
-        'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
+        'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.',
       );
     var prefix, suffix;
-    new ("function" === typeof WeakMap ? WeakMap : Map)();
+    new ('function' === typeof WeakMap ? WeakMap : Map)();
     var lastResetTime = 0;
     if (
-      "object" === typeof performance &&
-      "function" === typeof performance.now
+      'object' === typeof performance &&
+      'function' === typeof performance.now
     ) {
       var localPerformance = performance;
       var getCurrentTime = function () {
@@ -5517,7 +5517,7 @@
         react_stack_bottom_frame: function (
           Component,
           props,
-          componentDebugInfo
+          componentDebugInfo,
         ) {
           currentOwner = componentDebugInfo;
           try {
@@ -5525,7 +5525,7 @@
           } finally {
             currentOwner = null;
           }
-        }
+        },
       },
       callComponentInDEV =
         callComponent.react_stack_bottom_frame.bind(callComponent),
@@ -5533,14 +5533,14 @@
         react_stack_bottom_frame: function (lazy) {
           var init = lazy._init;
           return init(lazy._payload);
-        }
+        },
       },
       callLazyInitInDEV =
         callLazyInit.react_stack_bottom_frame.bind(callLazyInit),
       callIterator = {
         react_stack_bottom_frame: function (iterator, progress, error) {
           iterator.next().then(progress, error);
-        }
+        },
       },
       callIteratorInDEV =
         callIterator.react_stack_bottom_frame.bind(callIterator),
@@ -5548,7 +5548,7 @@
       getPrototypeOf = Object.getPrototypeOf,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
-      CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"),
+      CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference'),
       hasOwnProperty = Object.prototype.hasOwnProperty,
       doNotLimit = new WeakSet();
     (function () {
@@ -5556,7 +5556,7 @@
         .createHook({
           init: function (asyncId, type, triggerAsyncId, resource) {
             var trigger = pendingOperations.get(triggerAsyncId);
-            if ("PROMISE" === type)
+            if ('PROMISE' === type)
               if (
                 ((type = async_hooks.executionAsyncId()),
                 type !== triggerAsyncId)
@@ -5589,7 +5589,7 @@
                   end: -1.1,
                   promise: resource,
                   awaited: trigger,
-                  previous: void 0 === type ? null : type
+                  previous: void 0 === type ? null : type,
                 };
               } else
                 (type = resolveOwner()),
@@ -5602,12 +5602,12 @@
                     end: -1.1,
                     promise: new WeakRef(resource),
                     awaited: void 0 === trigger ? null : trigger,
-                    previous: null
+                    previous: null,
                   });
             else if (
-              "Microtask" !== type &&
-              "TickObject" !== type &&
-              "Immediate" !== type
+              'Microtask' !== type &&
+              'TickObject' !== type &&
+              'Immediate' !== type
             )
               if (void 0 === trigger)
                 (trigger = resolveOwner()),
@@ -5622,7 +5622,7 @@
                     end: -1.1,
                     promise: null,
                     awaited: null,
-                    previous: null
+                    previous: null,
                   });
               else {
                 if (2 === trigger.tag || 4 === trigger.tag)
@@ -5638,7 +5638,7 @@
                       end: -1.1,
                       promise: null,
                       awaited: null,
-                      previous: trigger
+                      previous: trigger,
                     });
               }
             else if (void 0 === trigger) return;
@@ -5655,7 +5655,7 @@
                 case 4:
                   lastRanAwait = resolvePromiseOrAwaitNode(
                     asyncId,
-                    performance.now()
+                    performance.now(),
                   );
                   break;
                 case 2:
@@ -5664,7 +5664,7 @@
                 case 3:
                   resolvePromiseOrAwaitNode(
                     asyncId,
-                    performance.now()
+                    performance.now(),
                   ).previous = lastRanAwait;
                   lastRanAwait = null;
                   break;
@@ -5685,7 +5685,7 @@
                   break;
                 default:
                   throw Error(
-                    "A Promise should never be an IO_NODE. This is a bug in React."
+                    'A Promise should never be an IO_NODE. This is a bug in React.',
                   );
               }
               var currentAsyncId = async_hooks.executionAsyncId();
@@ -5702,7 +5702,7 @@
                       end: node.end,
                       promise: node.promise,
                       awaited: node.awaited,
-                      previous: node.previous
+                      previous: node.previous,
                     }),
                     (node.start = node.end),
                     (node.end = performance.now()),
@@ -5712,25 +5712,25 @@
           },
           destroy: function (asyncId) {
             pendingOperations.delete(asyncId);
-          }
+          },
         })
         .enable();
     })();
-    "object" === typeof console &&
+    'object' === typeof console &&
       null !== console &&
-      (patchConsole(console, "assert"),
-      patchConsole(console, "debug"),
-      patchConsole(console, "dir"),
-      patchConsole(console, "dirxml"),
-      patchConsole(console, "error"),
-      patchConsole(console, "group"),
-      patchConsole(console, "groupCollapsed"),
-      patchConsole(console, "groupEnd"),
-      patchConsole(console, "info"),
-      patchConsole(console, "log"),
-      patchConsole(console, "table"),
-      patchConsole(console, "trace"),
-      patchConsole(console, "warn"));
+      (patchConsole(console, 'assert'),
+      patchConsole(console, 'debug'),
+      patchConsole(console, 'dir'),
+      patchConsole(console, 'dirxml'),
+      patchConsole(console, 'error'),
+      patchConsole(console, 'group'),
+      patchConsole(console, 'groupCollapsed'),
+      patchConsole(console, 'groupEnd'),
+      patchConsole(console, 'info'),
+      patchConsole(console, 'log'),
+      patchConsole(console, 'table'),
+      patchConsole(console, 'trace'),
+      patchConsole(console, 'warn'));
     var ObjectPrototype = Object.prototype,
       stringify = JSON.stringify,
       ABORTING = 12,
@@ -5750,16 +5750,16 @@
     Chunk.prototype = Object.create(Promise.prototype);
     Chunk.prototype.then = function (resolve, reject) {
       switch (this.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(this);
       }
       switch (this.status) {
-        case "fulfilled":
+        case 'fulfilled':
           resolve(this.value);
           break;
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           resolve &&
             (null === this.value && (this.value = []),
             this.value.push(resolve));
@@ -5784,16 +5784,16 @@
       var formData = new FormData(),
         action = null;
       body.forEach(function (value, key) {
-        key.startsWith("$ACTION_")
-          ? key.startsWith("$ACTION_REF_")
-            ? ((value = "$ACTION_" + key.slice(12) + ":"),
+        key.startsWith('$ACTION_')
+          ? key.startsWith('$ACTION_REF_')
+            ? ((value = '$ACTION_' + key.slice(12) + ':'),
               (value = decodeBoundActionMetaData(body, serverManifest, value)),
               (action = loadServerReference(
                 serverManifest,
                 value.id,
-                value.bound
+                value.bound,
               )))
-            : key.startsWith("$ACTION_ID_") &&
+            : key.startsWith('$ACTION_ID_') &&
               ((value = key.slice(11)),
               (action = loadServerReference(serverManifest, value, null)))
           : formData.append(key, value);
@@ -5805,12 +5805,12 @@
           });
     };
     exports.decodeFormState = function (actionResult, body, serverManifest) {
-      var keyPath = body.get("$ACTION_KEY");
-      if ("string" !== typeof keyPath) return Promise.resolve(null);
+      var keyPath = body.get('$ACTION_KEY');
+      if ('string' !== typeof keyPath) return Promise.resolve(null);
       var metaData = null;
       body.forEach(function (value, key) {
-        key.startsWith("$ACTION_REF_") &&
-          ((value = "$ACTION_" + key.slice(12) + ":"),
+        key.startsWith('$ACTION_REF_') &&
+          ((value = '$ACTION_' + key.slice(12) + ':'),
           (metaData = decodeBoundActionMetaData(body, serverManifest, value)));
       });
       if (null === metaData) return Promise.resolve(null);
@@ -5822,16 +5822,16 @@
       });
     };
     exports.decodeReply = function (body, webpackMap, options) {
-      if ("string" === typeof body) {
+      if ('string' === typeof body) {
         var form = new FormData();
-        form.append("0", body);
+        form.append('0', body);
         body = form;
       }
       body = createResponse(
         webpackMap,
-        "",
+        '',
         options ? options.temporaryReferences : void 0,
-        body
+        body,
       );
       webpackMap = getChunk(body, 0);
       close(body);
@@ -5840,7 +5840,7 @@
     exports.decodeReplyFromAsyncIterable = function (
       iterable,
       webpackMap,
-      options
+      options,
     ) {
       function progress(entry) {
         if (entry.done) close(response);
@@ -5848,7 +5848,7 @@
           var _entry$value = entry.value;
           entry = _entry$value[0];
           _entry$value = _entry$value[1];
-          "string" === typeof _entry$value
+          'string' === typeof _entry$value
             ? resolveField(response, entry, _entry$value)
             : response._formData.append(entry, _entry$value);
           iterator.next().then(progress, error);
@@ -5856,14 +5856,14 @@
       }
       function error(reason) {
         reportGlobalError(response, reason);
-        "function" === typeof iterator.throw &&
+        'function' === typeof iterator.throw &&
           iterator.throw(reason).then(error, error);
       }
       var iterator = iterable[ASYNC_ITERATOR](),
         response = createResponse(
           webpackMap,
-          "",
-          options ? options.temporaryReferences : void 0
+          '',
+          options ? options.temporaryReferences : void 0,
         );
       iterator.next().then(progress, error);
       return getChunk(response, 0);
@@ -5871,35 +5871,35 @@
     exports.decodeReplyFromBusboy = function (
       busboyStream,
       webpackMap,
-      options
+      options,
     ) {
       var response = createResponse(
           webpackMap,
-          "",
-          options ? options.temporaryReferences : void 0
+          '',
+          options ? options.temporaryReferences : void 0,
         ),
         pendingFiles = 0,
         queuedFields = [];
-      busboyStream.on("field", function (name, value) {
+      busboyStream.on('field', function (name, value) {
         0 < pendingFiles
           ? queuedFields.push(name, value)
           : resolveField(response, name, value);
       });
-      busboyStream.on("file", function (name, value, _ref2) {
+      busboyStream.on('file', function (name, value, _ref2) {
         var filename = _ref2.filename,
           mimeType = _ref2.mimeType;
-        if ("base64" === _ref2.encoding.toLowerCase())
+        if ('base64' === _ref2.encoding.toLowerCase())
           throw Error(
-            "React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it."
+            "React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.",
           );
         pendingFiles++;
         var JSCompiler_object_inline_chunks_250 = [];
-        value.on("data", function (chunk) {
+        value.on('data', function (chunk) {
           JSCompiler_object_inline_chunks_250.push(chunk);
         });
-        value.on("end", function () {
+        value.on('end', function () {
           var blob = new Blob(JSCompiler_object_inline_chunks_250, {
-            type: mimeType
+            type: mimeType,
           });
           response._formData.append(name, blob, filename);
           pendingFiles--;
@@ -5908,16 +5908,16 @@
               resolveField(
                 response,
                 queuedFields[blob],
-                queuedFields[blob + 1]
+                queuedFields[blob + 1],
               );
             queuedFields.length = 0;
           }
         });
       });
-      busboyStream.on("finish", function () {
+      busboyStream.on('finish', function () {
         close(response);
       });
-      busboyStream.on("error", function (err) {
+      busboyStream.on('error', function (err) {
         reportGlobalError(response, err);
       });
       return getChunk(response, 0);
@@ -5931,11 +5931,11 @@
             var writable,
               stream = new ReadableStream(
                 {
-                  type: "bytes",
+                  type: 'bytes',
                   start: function (controller) {
                     writable =
                       createFakeWritableFromReadableStreamController(
-                        controller
+                        controller,
                       );
                   },
                   pull: function () {
@@ -5944,9 +5944,9 @@
                   cancel: function (reason) {
                     request.destination = null;
                     abort(request, reason);
-                  }
+                  },
                 },
-                { highWaterMark: 0 }
+                { highWaterMark: 0 },
               );
             resolve({ prelude: stream });
           },
@@ -5957,7 +5957,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          !1
+          !1,
         );
         if (options && options.signal) {
           var signal = options.signal;
@@ -5965,9 +5965,9 @@
           else {
             var listener = function () {
               abort(request, signal.reason);
-              signal.removeEventListener("abort", listener);
+              signal.removeEventListener('abort', listener);
             };
-            signal.addEventListener("abort", listener);
+            signal.addEventListener('abort', listener);
           }
         }
         startWork(request);
@@ -5982,7 +5982,7 @@
             var readable = new stream.Readable({
                 read: function () {
                   startFlowing(request, writable);
-                }
+                },
               }),
               writable = createFakeWritableFromNodeReadable(readable);
             resolve({ prelude: readable });
@@ -5994,7 +5994,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          !1
+          !1,
         );
         if (options && options.signal) {
           var signal = options.signal;
@@ -6002,9 +6002,9 @@
           else {
             var listener = function () {
               abort(request, signal.reason);
-              signal.removeEventListener("abort", listener);
+              signal.removeEventListener('abort', listener);
             };
-            signal.addEventListener("abort", listener);
+            signal.addEventListener('abort', listener);
           }
         }
         startWork(request);
@@ -6013,39 +6013,39 @@
     exports.registerClientReference = function (
       proxyImplementation,
       id,
-      exportName
+      exportName,
     ) {
       return registerClientReferenceImpl(
         proxyImplementation,
-        id + "#" + exportName,
-        !1
+        id + '#' + exportName,
+        !1,
       );
     };
     exports.registerServerReference = function (reference, id, exportName) {
       return Object.defineProperties(reference, {
         $$typeof: { value: SERVER_REFERENCE_TAG },
         $$id: {
-          value: null === exportName ? id : id + "#" + exportName,
-          configurable: !0
+          value: null === exportName ? id : id + '#' + exportName,
+          configurable: !0,
         },
         $$bound: { value: null, configurable: !0 },
-        $$location: { value: Error("react-stack-top-frame"), configurable: !0 },
-        bind: { value: bind, configurable: !0 }
+        $$location: { value: Error('react-stack-top-frame'), configurable: !0 },
+        bind: { value: bind, configurable: !0 },
       });
     };
     exports.renderToPipeableStream = function (model, webpackMap, options) {
       var debugChannel = options ? options.debugChannel : void 0,
         debugChannelReadable =
           void 0 === debugChannel ||
-          ("function" !== typeof debugChannel.read &&
-            "number" !== typeof debugChannel.readyState)
+          ('function' !== typeof debugChannel.read &&
+            'number' !== typeof debugChannel.readyState)
             ? void 0
             : debugChannel;
       debugChannel =
         void 0 !== debugChannel
-          ? "function" === typeof debugChannel.write
+          ? 'function' === typeof debugChannel.write
             ? debugChannel
-            : "function" === typeof debugChannel.send
+            : 'function' === typeof debugChannel.send
               ? createFakeWritableFromWebSocket(debugChannel)
               : void 0
           : void 0;
@@ -6058,7 +6058,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          void 0 !== debugChannelReadable
+          void 0 !== debugChannelReadable,
         ),
         hasStartedFlowing = !1;
       startWork(request);
@@ -6069,31 +6069,31 @@
         pipe: function (destination) {
           if (hasStartedFlowing)
             throw Error(
-              "React currently only supports piping to one writable stream."
+              'React currently only supports piping to one writable stream.',
             );
           hasStartedFlowing = !0;
           startFlowing(request, destination);
-          destination.on("drain", createDrainHandler(destination, request));
+          destination.on('drain', createDrainHandler(destination, request));
           destination.on(
-            "error",
+            'error',
             createCancelHandler(
               request,
-              "The destination stream errored while writing data."
-            )
+              'The destination stream errored while writing data.',
+            ),
           );
           if (void 0 === debugChannelReadable)
             destination.on(
-              "close",
+              'close',
               createCancelHandler(
                 request,
-                "The destination stream closed early."
-              )
+                'The destination stream closed early.',
+              ),
             );
           return destination;
         },
         abort: function (reason) {
           abort(request, reason);
-        }
+        },
       };
     };
     exports.renderToReadableStream = function (model, webpackMap, options) {
@@ -6114,7 +6114,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          void 0 !== debugChannelReadable
+          void 0 !== debugChannelReadable,
         );
       if (options && options.signal) {
         var signal = options.signal;
@@ -6122,36 +6122,36 @@
         else {
           var listener = function () {
             abort(request, signal.reason);
-            signal.removeEventListener("abort", listener);
+            signal.removeEventListener('abort', listener);
           };
-          signal.addEventListener("abort", listener);
+          signal.addEventListener('abort', listener);
         }
       }
       if (void 0 !== debugChannelWritable) {
         var debugWritable;
         new ReadableStream(
           {
-            type: "bytes",
+            type: 'bytes',
             start: function (controller) {
               debugWritable =
                 createFakeWritableFromReadableStreamController(controller);
             },
             pull: function () {
               startFlowingDebug(request, debugWritable);
-            }
+            },
           },
-          { highWaterMark: 0 }
+          { highWaterMark: 0 },
         ).pipeTo(debugChannelWritable);
       }
       void 0 !== debugChannelReadable &&
         startReadingFromDebugChannelReadableStream(
           request,
-          debugChannelReadable
+          debugChannelReadable,
         );
       var writable;
       return new ReadableStream(
         {
-          type: "bytes",
+          type: 'bytes',
           start: function (controller) {
             writable =
               createFakeWritableFromReadableStreamController(controller);
@@ -6163,9 +6163,9 @@
           cancel: function (reason) {
             request.destination = null;
             abort(request, reason);
-          }
+          },
         },
-        { highWaterMark: 0 }
+        { highWaterMark: 0 },
       );
     };
   })();
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.node.production.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.production.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.node.production.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.production.js	2025-12-17 14:32:45
@@ -8,31 +8,31 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-var stream = require("stream"),
-  util = require("util");
-require("crypto");
-var async_hooks = require("async_hooks"),
-  ReactDOM = require("react-dom"),
-  React = require("react"),
-  REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
-  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-  REACT_MEMO_TYPE = Symbol.for("react.memo"),
-  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-Symbol.for("react.postpone");
+'use strict';
+var stream = require('stream'),
+  util = require('util');
+require('crypto');
+var async_hooks = require('async_hooks'),
+  ReactDOM = require('react-dom'),
+  React = require('react'),
+  REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element'),
+  REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+  REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+  REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+  REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+  REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+  REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+  REACT_MEMO_TYPE = Symbol.for('react.memo'),
+  REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+  REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
+Symbol.for('react.postpone');
 var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
 function getIteratorFn(maybeIterable) {
-  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  if (null === maybeIterable || 'object' !== typeof maybeIterable) return null;
   maybeIterable =
     (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-    maybeIterable["@@iterator"];
-  return "function" === typeof maybeIterable ? maybeIterable : null;
+    maybeIterable['@@iterator'];
+  return 'function' === typeof maybeIterable ? maybeIterable : null;
 }
 var ASYNC_ITERATOR = Symbol.asyncIterator,
   scheduleMicrotask = queueMicrotask,
@@ -44,13 +44,13 @@
   destinationHasCapacity = destinationHasCapacity && destination;
 }
 function writeChunkAndReturn(destination, chunk) {
-  if ("string" === typeof chunk) {
+  if ('string' === typeof chunk) {
     if (0 !== chunk.length)
       if (2048 < 3 * chunk.length)
         0 < writtenBytes &&
           (writeToDestination(
             destination,
-            currentView.subarray(0, writtenBytes)
+            currentView.subarray(0, writtenBytes),
           ),
           (currentView = new Uint8Array(2048)),
           (writtenBytes = 0)),
@@ -64,12 +64,12 @@
         read < chunk.length &&
           (writeToDestination(
             destination,
-            currentView.subarray(0, writtenBytes)
+            currentView.subarray(0, writtenBytes),
           ),
           (currentView = new Uint8Array(2048)),
           (writtenBytes = textEncoder.encodeInto(
             chunk.slice(read),
-            currentView
+            currentView,
           ).written));
         2048 === writtenBytes &&
           (writeToDestination(destination, currentView),
@@ -82,7 +82,7 @@
         ? (0 < writtenBytes &&
             (writeToDestination(
               destination,
-              currentView.subarray(0, writtenBytes)
+              currentView.subarray(0, writtenBytes),
             ),
             (currentView = new Uint8Array(2048)),
             (writtenBytes = 0)),
@@ -107,17 +107,17 @@
 }
 var textEncoder = new util.TextEncoder();
 function byteLengthOfChunk(chunk) {
-  return "string" === typeof chunk
-    ? Buffer.byteLength(chunk, "utf8")
+  return 'string' === typeof chunk
+    ? Buffer.byteLength(chunk, 'utf8')
     : chunk.byteLength;
 }
-var CLIENT_REFERENCE_TAG$1 = Symbol.for("react.client.reference"),
-  SERVER_REFERENCE_TAG = Symbol.for("react.server.reference");
+var CLIENT_REFERENCE_TAG$1 = Symbol.for('react.client.reference'),
+  SERVER_REFERENCE_TAG = Symbol.for('react.server.reference');
 function registerClientReferenceImpl(proxyImplementation, id, async) {
   return Object.defineProperties(proxyImplementation, {
     $$typeof: { value: CLIENT_REFERENCE_TAG$1 },
     $$id: { value: id },
-    $$async: { value: async }
+    $$async: { value: async },
   });
 }
 var FunctionBind = Function.prototype.bind,
@@ -133,7 +133,7 @@
       $$typeof: $$typeof,
       $$id: $$id,
       $$bound: args,
-      bind: { value: bind, configurable: !0 }
+      bind: { value: bind, configurable: !0 },
     });
   }
   return newFn;
@@ -142,114 +142,114 @@
   deepProxyHandlers = {
     get: function (target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "$$id":
+        case '$$id':
           return target.$$id;
-        case "$$async":
+        case '$$async':
           return target.$$async;
-        case "name":
+        case 'name':
           return target.name;
-        case "displayName":
+        case 'displayName':
           return;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "Provider":
+        case 'Provider':
           throw Error(
-            "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+            'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
           );
-        case "then":
+        case 'then':
           throw Error(
-            "Cannot await or return from a thenable. You cannot await a client module from a server component."
+            'Cannot await or return from a thenable. You cannot await a client module from a server component.',
           );
       }
       throw Error(
-        "Cannot access " +
-          (String(target.name) + "." + String(name)) +
-          " on the server. You cannot dot into a client module from a server component. You can only pass the imported name through."
+        'Cannot access ' +
+          (String(target.name) + '.' + String(name)) +
+          ' on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.',
       );
     },
     set: function () {
-      throw Error("Cannot assign to a client module from a server module.");
-    }
+      throw Error('Cannot assign to a client module from a server module.');
+    },
   };
 function getReference(target, name) {
   switch (name) {
-    case "$$typeof":
+    case '$$typeof':
       return target.$$typeof;
-    case "$$id":
+    case '$$id':
       return target.$$id;
-    case "$$async":
+    case '$$async':
       return target.$$async;
-    case "name":
+    case 'name':
       return target.name;
-    case "defaultProps":
+    case 'defaultProps':
       return;
-    case "_debugInfo":
+    case '_debugInfo':
       return;
-    case "toJSON":
+    case 'toJSON':
       return;
     case Symbol.toPrimitive:
       return Object.prototype[Symbol.toPrimitive];
     case Symbol.toStringTag:
       return Object.prototype[Symbol.toStringTag];
-    case "__esModule":
+    case '__esModule':
       var moduleId = target.$$id;
       target.default = registerClientReferenceImpl(
         function () {
           throw Error(
-            "Attempted to call the default export of " +
+            'Attempted to call the default export of ' +
               moduleId +
-              " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+              " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
           );
         },
-        target.$$id + "#",
-        target.$$async
+        target.$$id + '#',
+        target.$$async,
       );
       return !0;
-    case "then":
+    case 'then':
       if (target.then) return target.then;
       if (target.$$async) return;
       var clientReference = registerClientReferenceImpl({}, target.$$id, !0),
         proxy = new Proxy(clientReference, proxyHandlers$1);
-      target.status = "fulfilled";
+      target.status = 'fulfilled';
       target.value = proxy;
       return (target.then = registerClientReferenceImpl(
         function (resolve) {
           return Promise.resolve(resolve(proxy));
         },
-        target.$$id + "#then",
-        !1
+        target.$$id + '#then',
+        !1,
       ));
   }
-  if ("symbol" === typeof name)
+  if ('symbol' === typeof name)
     throw Error(
-      "Cannot read Symbol exports. Only named exports are supported on a client module imported on the server."
+      'Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.',
     );
   clientReference = target[name];
   clientReference ||
     ((clientReference = registerClientReferenceImpl(
       function () {
         throw Error(
-          "Attempted to call " +
+          'Attempted to call ' +
             String(name) +
-            "() from the server but " +
+            '() from the server but ' +
             String(name) +
-            " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+            " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
         );
       },
-      target.$$id + "#" + name,
-      target.$$async
+      target.$$id + '#' + name,
+      target.$$async,
     )),
-    Object.defineProperty(clientReference, "name", { value: name }),
+    Object.defineProperty(clientReference, 'name', { value: name }),
     (clientReference = target[name] =
       new Proxy(clientReference, deepProxyHandlers)));
   return clientReference;
@@ -265,7 +265,7 @@
           value: getReference(target, name),
           writable: !1,
           configurable: !1,
-          enumerable: !1
+          enumerable: !1,
         }),
         Object.defineProperty(target, name, descriptor));
       return descriptor;
@@ -274,8 +274,8 @@
       return PROMISE_PROTOTYPE;
     },
     set: function () {
-      throw Error("Cannot assign to a client module from a server module.");
-    }
+      throw Error('Cannot assign to a client module from a server module.');
+    },
   },
   ReactDOMSharedInternals =
     ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
@@ -289,119 +289,119 @@
   m: preloadModule$1,
   X: preinitScript,
   S: preinitStyle,
-  M: preinitModuleScript
+  M: preinitModuleScript,
 };
 function prefetchDNS(href) {
-  if ("string" === typeof href && href) {
+  if ('string' === typeof href && href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "D|" + href;
-      hints.has(key) || (hints.add(key), emitHint(request, "D", href));
+        key = 'D|' + href;
+      hints.has(key) || (hints.add(key), emitHint(request, 'D', href));
     } else previousDispatcher.D(href);
   }
 }
 function preconnect(href, crossOrigin) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "C|" + (null == crossOrigin ? "null" : crossOrigin) + "|" + href;
+        key = 'C|' + (null == crossOrigin ? 'null' : crossOrigin) + '|' + href;
       hints.has(key) ||
         (hints.add(key),
-        "string" === typeof crossOrigin
-          ? emitHint(request, "C", [href, crossOrigin])
-          : emitHint(request, "C", href));
+        'string' === typeof crossOrigin
+          ? emitHint(request, 'C', [href, crossOrigin])
+          : emitHint(request, 'C', href));
     } else previousDispatcher.C(href, crossOrigin);
   }
 }
 function preload(href, as, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "L";
-      if ("image" === as && options) {
+        key = 'L';
+      if ('image' === as && options) {
         var imageSrcSet = options.imageSrcSet,
           imageSizes = options.imageSizes,
-          uniquePart = "";
-        "string" === typeof imageSrcSet && "" !== imageSrcSet
-          ? ((uniquePart += "[" + imageSrcSet + "]"),
-            "string" === typeof imageSizes &&
-              (uniquePart += "[" + imageSizes + "]"))
-          : (uniquePart += "[][]" + href);
-        key += "[image]" + uniquePart;
-      } else key += "[" + as + "]" + href;
+          uniquePart = '';
+        'string' === typeof imageSrcSet && '' !== imageSrcSet
+          ? ((uniquePart += '[' + imageSrcSet + ']'),
+            'string' === typeof imageSizes &&
+              (uniquePart += '[' + imageSizes + ']'))
+          : (uniquePart += '[][]' + href);
+        key += '[image]' + uniquePart;
+      } else key += '[' + as + ']' + href;
       hints.has(key) ||
         (hints.add(key),
         (options = trimOptions(options))
-          ? emitHint(request, "L", [href, as, options])
-          : emitHint(request, "L", [href, as]));
+          ? emitHint(request, 'L', [href, as, options])
+          : emitHint(request, 'L', [href, as]));
     } else previousDispatcher.L(href, as, options);
   }
 }
 function preloadModule$1(href, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "m|" + href;
+        key = 'm|' + href;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "m", [href, options])
-        : emitHint(request, "m", href);
+        ? emitHint(request, 'm', [href, options])
+        : emitHint(request, 'm', href);
     }
     previousDispatcher.m(href, options);
   }
 }
 function preinitStyle(href, precedence, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "S|" + href;
+        key = 'S|' + href;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "S", [
+        ? emitHint(request, 'S', [
             href,
-            "string" === typeof precedence ? precedence : 0,
-            options
+            'string' === typeof precedence ? precedence : 0,
+            options,
           ])
-        : "string" === typeof precedence
-          ? emitHint(request, "S", [href, precedence])
-          : emitHint(request, "S", href);
+        : 'string' === typeof precedence
+          ? emitHint(request, 'S', [href, precedence])
+          : emitHint(request, 'S', href);
     }
     previousDispatcher.S(href, precedence, options);
   }
 }
 function preinitScript(src, options) {
-  if ("string" === typeof src) {
+  if ('string' === typeof src) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "X|" + src;
+        key = 'X|' + src;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "X", [src, options])
-        : emitHint(request, "X", src);
+        ? emitHint(request, 'X', [src, options])
+        : emitHint(request, 'X', src);
     }
     previousDispatcher.X(src, options);
   }
 }
 function preinitModuleScript(src, options) {
-  if ("string" === typeof src) {
+  if ('string' === typeof src) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "M|" + src;
+        key = 'M|' + src;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "M", [src, options])
-        : emitHint(request, "M", src);
+        ? emitHint(request, 'M', [src, options])
+        : emitHint(request, 'M', src);
     }
     previousDispatcher.M(src, options);
   }
@@ -418,63 +418,63 @@
 }
 function getChildFormatContext(parentContext, type, props) {
   switch (type) {
-    case "img":
+    case 'img':
       type = props.src;
       var srcSet = props.srcSet;
       if (
         !(
-          "lazy" === props.loading ||
+          'lazy' === props.loading ||
           (!type && !srcSet) ||
-          ("string" !== typeof type && null != type) ||
-          ("string" !== typeof srcSet && null != srcSet) ||
-          "low" === props.fetchPriority ||
+          ('string' !== typeof type && null != type) ||
+          ('string' !== typeof srcSet && null != srcSet) ||
+          'low' === props.fetchPriority ||
           parentContext & 3
         ) &&
-        ("string" !== typeof type ||
-          ":" !== type[4] ||
-          ("d" !== type[0] && "D" !== type[0]) ||
-          ("a" !== type[1] && "A" !== type[1]) ||
-          ("t" !== type[2] && "T" !== type[2]) ||
-          ("a" !== type[3] && "A" !== type[3])) &&
-        ("string" !== typeof srcSet ||
-          ":" !== srcSet[4] ||
-          ("d" !== srcSet[0] && "D" !== srcSet[0]) ||
-          ("a" !== srcSet[1] && "A" !== srcSet[1]) ||
-          ("t" !== srcSet[2] && "T" !== srcSet[2]) ||
-          ("a" !== srcSet[3] && "A" !== srcSet[3]))
+        ('string' !== typeof type ||
+          ':' !== type[4] ||
+          ('d' !== type[0] && 'D' !== type[0]) ||
+          ('a' !== type[1] && 'A' !== type[1]) ||
+          ('t' !== type[2] && 'T' !== type[2]) ||
+          ('a' !== type[3] && 'A' !== type[3])) &&
+        ('string' !== typeof srcSet ||
+          ':' !== srcSet[4] ||
+          ('d' !== srcSet[0] && 'D' !== srcSet[0]) ||
+          ('a' !== srcSet[1] && 'A' !== srcSet[1]) ||
+          ('t' !== srcSet[2] && 'T' !== srcSet[2]) ||
+          ('a' !== srcSet[3] && 'A' !== srcSet[3]))
       ) {
-        var sizes = "string" === typeof props.sizes ? props.sizes : void 0;
+        var sizes = 'string' === typeof props.sizes ? props.sizes : void 0;
         var input = props.crossOrigin;
-        preload(type || "", "image", {
+        preload(type || '', 'image', {
           imageSrcSet: srcSet,
           imageSizes: sizes,
           crossOrigin:
-            "string" === typeof input
-              ? "use-credentials" === input
+            'string' === typeof input
+              ? 'use-credentials' === input
                 ? input
-                : ""
+                : ''
               : void 0,
           integrity: props.integrity,
           type: props.type,
           fetchPriority: props.fetchPriority,
-          referrerPolicy: props.referrerPolicy
+          referrerPolicy: props.referrerPolicy,
         });
       }
       return parentContext;
-    case "link":
+    case 'link':
       type = props.rel;
       srcSet = props.href;
       if (
         !(
           parentContext & 1 ||
           null != props.itemProp ||
-          "string" !== typeof type ||
-          "string" !== typeof srcSet ||
-          "" === srcSet
+          'string' !== typeof type ||
+          'string' !== typeof srcSet ||
+          '' === srcSet
         )
       )
         switch (type) {
-          case "preload":
+          case 'preload':
             preload(srcSet, props.as, {
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
@@ -484,85 +484,85 @@
               referrerPolicy: props.referrerPolicy,
               imageSrcSet: props.imageSrcSet,
               imageSizes: props.imageSizes,
-              media: props.media
+              media: props.media,
             });
             break;
-          case "modulepreload":
+          case 'modulepreload':
             preloadModule$1(srcSet, {
               as: props.as,
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
-              nonce: props.nonce
+              nonce: props.nonce,
             });
             break;
-          case "stylesheet":
-            preload(srcSet, "stylesheet", {
+          case 'stylesheet':
+            preload(srcSet, 'stylesheet', {
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
               nonce: props.nonce,
               type: props.type,
               fetchPriority: props.fetchPriority,
               referrerPolicy: props.referrerPolicy,
-              media: props.media
+              media: props.media,
             });
         }
       return parentContext;
-    case "picture":
+    case 'picture':
       return parentContext | 2;
-    case "noscript":
+    case 'noscript':
       return parentContext | 1;
     default:
       return parentContext;
   }
 }
 var requestStorage = new async_hooks.AsyncLocalStorage(),
-  TEMPORARY_REFERENCE_TAG = Symbol.for("react.temporary.reference"),
+  TEMPORARY_REFERENCE_TAG = Symbol.for('react.temporary.reference'),
   proxyHandlers = {
     get: function (target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "name":
+        case 'name':
           return;
-        case "displayName":
+        case 'displayName':
           return;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "Provider":
+        case 'Provider':
           throw Error(
-            "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+            'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
           );
-        case "then":
+        case 'then':
           return;
       }
       throw Error(
-        "Cannot access " +
+        'Cannot access ' +
           String(name) +
-          " on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client."
+          ' on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client.',
       );
     },
     set: function () {
       throw Error(
-        "Cannot assign to a temporary client reference from a server module."
+        'Cannot assign to a temporary client reference from a server module.',
       );
-    }
+    },
   };
 function createTemporaryReference(temporaryReferences, id) {
   var reference = Object.defineProperties(
     function () {
       throw Error(
-        "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+        "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
       );
     },
-    { $$typeof: { value: TEMPORARY_REFERENCE_TAG } }
+    { $$typeof: { value: TEMPORARY_REFERENCE_TAG } },
   );
   reference = new Proxy(reference, proxyHandlers);
   temporaryReferences.set(reference, id);
@@ -570,7 +570,7 @@
 }
 function noop() {}
 var SuspenseException = Error(
-  "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
+  "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.",
 );
 function trackUsedThenable(thenableState, thenable, index) {
   index = thenableState[index];
@@ -578,35 +578,35 @@
     ? thenableState.push(thenable)
     : index !== thenable && (thenable.then(noop, noop), (thenable = index));
   switch (thenable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return thenable.value;
-    case "rejected":
+    case 'rejected':
       throw thenable.reason;
     default:
-      "string" === typeof thenable.status
+      'string' === typeof thenable.status
         ? thenable.then(noop, noop)
         : ((thenableState = thenable),
-          (thenableState.status = "pending"),
+          (thenableState.status = 'pending'),
           thenableState.then(
             function (fulfilledValue) {
-              if ("pending" === thenable.status) {
+              if ('pending' === thenable.status) {
                 var fulfilledThenable = thenable;
-                fulfilledThenable.status = "fulfilled";
+                fulfilledThenable.status = 'fulfilled';
                 fulfilledThenable.value = fulfilledValue;
               }
             },
             function (error) {
-              if ("pending" === thenable.status) {
+              if ('pending' === thenable.status) {
                 var rejectedThenable = thenable;
-                rejectedThenable.status = "rejected";
+                rejectedThenable.status = 'rejected';
                 rejectedThenable.reason = error;
               }
-            }
+            },
           ));
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return thenable.value;
-        case "rejected":
+        case 'rejected':
           throw thenable.reason;
       }
       suspendedThenable = thenable;
@@ -617,7 +617,7 @@
 function getSuspendedThenable() {
   if (null === suspendedThenable)
     throw Error(
-      "Expected a suspended thenable. This is a bug in React. Please file an issue."
+      'Expected a suspended thenable. This is a bug in React. Please file an issue.',
     );
   var thenable = suspendedThenable;
   suspendedThenable = null;
@@ -664,30 +664,30 @@
   },
   useCacheRefresh: function () {
     return unsupportedRefresh;
-  }
+  },
 };
 HooksDispatcher.useEffectEvent = unsupportedHook;
 function unsupportedHook() {
-  throw Error("This Hook is not supported in Server Components.");
+  throw Error('This Hook is not supported in Server Components.');
 }
 function unsupportedRefresh() {
-  throw Error("Refreshing the cache is not supported in Server Components.");
+  throw Error('Refreshing the cache is not supported in Server Components.');
 }
 function unsupportedContext() {
-  throw Error("Cannot read a Client Context from a Server Component.");
+  throw Error('Cannot read a Client Context from a Server Component.');
 }
 function useId() {
   if (null === currentRequest$1)
-    throw Error("useId can only be used while React is rendering");
+    throw Error('useId can only be used while React is rendering');
   var id = currentRequest$1.identifierCount++;
-  return "_" + currentRequest$1.identifierPrefix + "S_" + id.toString(32) + "_";
+  return '_' + currentRequest$1.identifierPrefix + 'S_' + id.toString(32) + '_';
 }
 function use(usable) {
   if (
-    (null !== usable && "object" === typeof usable) ||
-    "function" === typeof usable
+    (null !== usable && 'object' === typeof usable) ||
+    'function' === typeof usable
   ) {
-    if ("function" === typeof usable.then) {
+    if ('function' === typeof usable.then) {
       var index = thenableIndexCounter;
       thenableIndexCounter += 1;
       null === thenableState && (thenableState = []);
@@ -697,10 +697,10 @@
   }
   if (usable.$$typeof === CLIENT_REFERENCE_TAG$1) {
     if (null != usable.value && usable.value.$$typeof === REACT_CONTEXT_TYPE)
-      throw Error("Cannot read a Client Context from a Server Component.");
-    throw Error("Cannot use() an already resolved Client Reference.");
+      throw Error('Cannot read a Client Context from a Server Component.');
+    throw Error('Cannot use() an already resolved Client Reference.');
   }
-  throw Error("An unsupported type was passed to use(): " + String(usable));
+  throw Error('An unsupported type was passed to use(): ' + String(usable));
 }
 var DefaultAsyncDispatcher = {
     getCacheForType: function (resourceType) {
@@ -717,13 +717,13 @@
     cacheSignal: function () {
       var request = resolveRequest();
       return request ? request.cacheController.signal : null;
-    }
+    },
   },
   ReactSharedInternalsServer =
     React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
 if (!ReactSharedInternalsServer)
   throw Error(
-    'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
+    'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.',
   );
 var isArrayImpl = Array.isArray,
   getPrototypeOf = Object.getPrototypeOf;
@@ -733,35 +733,35 @@
 }
 function describeValueForErrorMessage(value) {
   switch (typeof value) {
-    case "string":
+    case 'string':
       return JSON.stringify(
-        10 >= value.length ? value : value.slice(0, 10) + "..."
+        10 >= value.length ? value : value.slice(0, 10) + '...',
       );
-    case "object":
-      if (isArrayImpl(value)) return "[...]";
+    case 'object':
+      if (isArrayImpl(value)) return '[...]';
       if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-        return "client";
+        return 'client';
       value = objectName(value);
-      return "Object" === value ? "{...}" : value;
-    case "function":
+      return 'Object' === value ? '{...}' : value;
+    case 'function':
       return value.$$typeof === CLIENT_REFERENCE_TAG
-        ? "client"
+        ? 'client'
         : (value = value.displayName || value.name)
-          ? "function " + value
-          : "function";
+          ? 'function ' + value
+          : 'function';
     default:
       return String(value);
   }
 }
 function describeElementType(type) {
-  if ("string" === typeof type) return type;
+  if ('string' === typeof type) return type;
   switch (type) {
     case REACT_SUSPENSE_TYPE:
-      return "Suspense";
+      return 'Suspense';
     case REACT_SUSPENSE_LIST_TYPE:
-      return "SuspenseList";
+      return 'SuspenseList';
   }
-  if ("object" === typeof type)
+  if ('object' === typeof type)
     switch (type.$$typeof) {
       case REACT_FORWARD_REF_TYPE:
         return describeElementType(type.render);
@@ -774,45 +774,45 @@
           return describeElementType(type(payload));
         } catch (x) {}
     }
-  return "";
+  return '';
 }
-var CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference");
+var CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference');
 function describeObjectForErrorMessage(objectOrArray, expandedName) {
   var objKind = objectName(objectOrArray);
-  if ("Object" !== objKind && "Array" !== objKind) return objKind;
+  if ('Object' !== objKind && 'Array' !== objKind) return objKind;
   objKind = -1;
   var length = 0;
   if (isArrayImpl(objectOrArray)) {
-    var str = "[";
+    var str = '[';
     for (var i = 0; i < objectOrArray.length; i++) {
-      0 < i && (str += ", ");
+      0 < i && (str += ', ');
       var value = objectOrArray[i];
       value =
-        "object" === typeof value && null !== value
+        'object' === typeof value && null !== value
           ? describeObjectForErrorMessage(value)
           : describeValueForErrorMessage(value);
-      "" + i === expandedName
+      '' + i === expandedName
         ? ((objKind = str.length), (length = value.length), (str += value))
         : (str =
             10 > value.length && 40 > str.length + value.length
               ? str + value
-              : str + "...");
+              : str + '...');
     }
-    str += "]";
+    str += ']';
   } else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-    str = "<" + describeElementType(objectOrArray.type) + "/>";
+    str = '<' + describeElementType(objectOrArray.type) + '/>';
   else {
-    if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
-    str = "{";
+    if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
+    str = '{';
     i = Object.keys(objectOrArray);
     for (value = 0; value < i.length; value++) {
-      0 < value && (str += ", ");
+      0 < value && (str += ', ');
       var name = i[value],
         encodedKey = JSON.stringify(name);
-      str += ('"' + name + '"' === encodedKey ? name : encodedKey) + ": ";
+      str += ('"' + name + '"' === encodedKey ? name : encodedKey) + ': ';
       encodedKey = objectOrArray[name];
       encodedKey =
-        "object" === typeof encodedKey && null !== encodedKey
+        'object' === typeof encodedKey && null !== encodedKey
           ? describeObjectForErrorMessage(encodedKey)
           : describeValueForErrorMessage(encodedKey);
       name === expandedName
@@ -822,16 +822,16 @@
         : (str =
             10 > encodedKey.length && 40 > str.length + encodedKey.length
               ? str + encodedKey
-              : str + "...");
+              : str + '...');
     }
-    str += "}";
+    str += '}';
   }
   return void 0 === expandedName
     ? str
     : -1 < objKind && 0 < length
-      ? ((objectOrArray = " ".repeat(objKind) + "^".repeat(length)),
-        "\n  " + str + "\n  " + objectOrArray)
-      : "\n  " + str;
+      ? ((objectOrArray = ' '.repeat(objKind) + '^'.repeat(length)),
+        '\n  ' + str + '\n  ' + objectOrArray)
+      : '\n  ' + str;
 }
 var hasOwnProperty = Object.prototype.hasOwnProperty,
   ObjectPrototype = Object.prototype,
@@ -848,13 +848,13 @@
   onAllReady,
   onFatalError,
   identifierPrefix,
-  temporaryReferences
+  temporaryReferences,
 ) {
   if (
     null !== ReactSharedInternalsServer.A &&
     ReactSharedInternalsServer.A !== DefaultAsyncDispatcher
   )
-    throw Error("Currently React only supports one RSC renderer at a time.");
+    throw Error('Currently React only supports one RSC renderer at a time.');
   ReactSharedInternalsServer.A = DefaultAsyncDispatcher;
   var abortSet = new Set(),
     pingedTasks = [],
@@ -879,7 +879,7 @@
   this.writtenServerReferences = new Map();
   this.writtenObjects = new WeakMap();
   this.temporaryReferences = temporaryReferences;
-  this.identifierPrefix = identifierPrefix || "";
+  this.identifierPrefix = identifierPrefix || '';
   this.identifierCount = 1;
   this.taintCleanupQueue = [];
   this.onError = void 0 === onError ? defaultErrorHandler : onError;
@@ -902,14 +902,14 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   switch (thenable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return (
         (newTask.model = thenable.value), pingTask(request, newTask), newTask.id
       );
-    case "rejected":
+    case 'rejected':
       return erroredTask(request, newTask, thenable.reason), newTask.id;
     default:
       if (12 === request.status)
@@ -922,18 +922,18 @@
               finishAbortedTask(newTask, request, task)),
           newTask.id
         );
-      "string" !== typeof thenable.status &&
-        ((thenable.status = "pending"),
+      'string' !== typeof thenable.status &&
+        ((thenable.status = 'pending'),
         thenable.then(
           function (fulfilledValue) {
-            "pending" === thenable.status &&
-              ((thenable.status = "fulfilled"),
+            'pending' === thenable.status &&
+              ((thenable.status = 'fulfilled'),
               (thenable.value = fulfilledValue));
           },
           function (error) {
-            "pending" === thenable.status &&
-              ((thenable.status = "rejected"), (thenable.reason = error));
-          }
+            'pending' === thenable.status &&
+              ((thenable.status = 'rejected'), (thenable.reason = error));
+          },
         ));
   }
   thenable.then(
@@ -944,7 +944,7 @@
     function (reason) {
       0 === newTask.status &&
         (erroredTask(request, newTask, reason), enqueueFlush(request));
-    }
+    },
   );
   return newTask.id;
 }
@@ -953,12 +953,12 @@
     if (0 === streamTask.status)
       if (entry.done)
         (streamTask.status = 1),
-          (entry = streamTask.id.toString(16) + ":C\n"),
+          (entry = streamTask.id.toString(16) + ':C\n'),
           request.completedRegularChunks.push(entry),
           request.abortableTasks.delete(streamTask),
           request.cacheController.signal.removeEventListener(
-            "abort",
-            abortStream
+            'abort',
+            abortStream,
           ),
           enqueueFlush(request),
           callOnAllReadyIfReady(request);
@@ -975,7 +975,7 @@
   }
   function error(reason) {
     0 === streamTask.status &&
-      (request.cacheController.signal.removeEventListener("abort", abortStream),
+      (request.cacheController.signal.removeEventListener('abort', abortStream),
       erroredTask(request, streamTask, reason),
       enqueueFlush(request),
       reader.cancel(reason).then(error, error));
@@ -983,7 +983,7 @@
   function abortStream() {
     if (0 === streamTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortStream);
+      signal.removeEventListener('abort', abortStream);
       signal = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(streamTask),
@@ -996,7 +996,7 @@
   var supportsBYOB = stream.supportsBYOB;
   if (void 0 === supportsBYOB)
     try {
-      stream.getReader({ mode: "byob" }).releaseLock(), (supportsBYOB = !0);
+      stream.getReader({ mode: 'byob' }).releaseLock(), (supportsBYOB = !0);
     } catch (x) {
       supportsBYOB = !1;
     }
@@ -1007,12 +1007,12 @@
       task.keyPath,
       task.implicitSlot,
       task.formatContext,
-      request.abortableTasks
+      request.abortableTasks,
     );
   request.pendingChunks++;
-  task = streamTask.id.toString(16) + ":" + (supportsBYOB ? "r" : "R") + "\n";
+  task = streamTask.id.toString(16) + ':' + (supportsBYOB ? 'r' : 'R') + '\n';
   request.completedRegularChunks.push(task);
-  request.cacheController.signal.addEventListener("abort", abortStream);
+  request.cacheController.signal.addEventListener('abort', abortStream);
   reader.read().then(progress, error);
   return serializeByValueID(streamTask.id);
 }
@@ -1022,19 +1022,19 @@
       if (entry.done) {
         streamTask.status = 1;
         if (void 0 === entry.value)
-          var endStreamRow = streamTask.id.toString(16) + ":C\n";
+          var endStreamRow = streamTask.id.toString(16) + ':C\n';
         else
           try {
             var chunkId = outlineModelWithFormatContext(
               request,
               entry.value,
-              0
+              0,
             );
             endStreamRow =
               streamTask.id.toString(16) +
-              ":C" +
+              ':C' +
               stringify(serializeByValueID(chunkId)) +
-              "\n";
+              '\n';
           } catch (x) {
             error(x);
             return;
@@ -1042,8 +1042,8 @@
         request.completedRegularChunks.push(endStreamRow);
         request.abortableTasks.delete(streamTask);
         request.cacheController.signal.removeEventListener(
-          "abort",
-          abortIterable
+          'abort',
+          abortIterable,
         );
         enqueueFlush(request);
         callOnAllReadyIfReady(request);
@@ -1061,18 +1061,18 @@
   function error(reason) {
     0 === streamTask.status &&
       (request.cacheController.signal.removeEventListener(
-        "abort",
-        abortIterable
+        'abort',
+        abortIterable,
       ),
       erroredTask(request, streamTask, reason),
       enqueueFlush(request),
-      "function" === typeof iterator.throw &&
+      'function' === typeof iterator.throw &&
         iterator.throw(reason).then(error, error));
   }
   function abortIterable() {
     if (0 === streamTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortIterable);
+      signal.removeEventListener('abort', abortIterable);
       var reason = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(streamTask),
@@ -1080,7 +1080,7 @@
           finishHaltedTask(streamTask, request))
         : (erroredTask(request, streamTask, signal.reason),
           enqueueFlush(request));
-      "function" === typeof iterator.throw &&
+      'function' === typeof iterator.throw &&
         iterator.throw(reason).then(error, error);
     }
   }
@@ -1091,44 +1091,44 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   request.pendingChunks++;
-  task = streamTask.id.toString(16) + ":" + (iterable ? "x" : "X") + "\n";
+  task = streamTask.id.toString(16) + ':' + (iterable ? 'x' : 'X') + '\n';
   request.completedRegularChunks.push(task);
-  request.cacheController.signal.addEventListener("abort", abortIterable);
+  request.cacheController.signal.addEventListener('abort', abortIterable);
   iterator.next().then(progress, error);
   return serializeByValueID(streamTask.id);
 }
 function emitHint(request, code, model) {
   model = stringify(model);
-  request.completedHintChunks.push(":H" + code + model + "\n");
+  request.completedHintChunks.push(':H' + code + model + '\n');
   enqueueFlush(request);
 }
 function readThenable(thenable) {
-  if ("fulfilled" === thenable.status) return thenable.value;
-  if ("rejected" === thenable.status) throw thenable.reason;
+  if ('fulfilled' === thenable.status) return thenable.value;
+  if ('rejected' === thenable.status) throw thenable.reason;
   throw thenable;
 }
 function createLazyWrapperAroundWakeable(request, task, wakeable) {
   switch (wakeable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return wakeable.value;
-    case "rejected":
+    case 'rejected':
       break;
     default:
-      "string" !== typeof wakeable.status &&
-        ((wakeable.status = "pending"),
+      'string' !== typeof wakeable.status &&
+        ((wakeable.status = 'pending'),
         wakeable.then(
           function (fulfilledValue) {
-            "pending" === wakeable.status &&
-              ((wakeable.status = "fulfilled"),
+            'pending' === wakeable.status &&
+              ((wakeable.status = 'fulfilled'),
               (wakeable.value = fulfilledValue));
           },
           function (error) {
-            "pending" === wakeable.status &&
-              ((wakeable.status = "rejected"), (wakeable.reason = error));
-          }
+            'pending' === wakeable.status &&
+              ((wakeable.status = 'rejected'), (wakeable.reason = error));
+          },
         ));
   }
   return { $$typeof: REACT_LAZY_TYPE, _payload: wakeable, _init: readThenable };
@@ -1136,12 +1136,12 @@
 function voidHandler() {}
 function processServerComponentReturnValue(request, task, Component, result) {
   if (
-    "object" !== typeof result ||
+    'object' !== typeof result ||
     null === result ||
     result.$$typeof === CLIENT_REFERENCE_TAG$1
   )
     return result;
-  if ("function" === typeof result.then)
+  if ('function' === typeof result.then)
     return createLazyWrapperAroundWakeable(request, task, result);
   var iteratorFn = getIteratorFn(result);
   return iteratorFn
@@ -1150,8 +1150,8 @@
         return iteratorFn.call(result);
       }),
       request)
-    : "function" !== typeof result[ASYNC_ITERATOR] ||
-        ("function" === typeof ReadableStream &&
+    : 'function' !== typeof result[ASYNC_ITERATOR] ||
+        ('function' === typeof ReadableStream &&
           result instanceof ReadableStream)
       ? result
       : ((request = {}),
@@ -1168,9 +1168,9 @@
   props = Component(props, void 0);
   if (12 === request.status)
     throw (
-      ("object" === typeof props &&
+      ('object' === typeof props &&
         null !== props &&
-        "function" === typeof props.then &&
+        'function' === typeof props.then &&
         props.$$typeof !== CLIENT_REFERENCE_TAG$1 &&
         props.then(voidHandler, voidHandler),
       null)
@@ -1179,9 +1179,9 @@
   Component = task.keyPath;
   prevThenableState = task.implicitSlot;
   null !== key
-    ? (task.keyPath = null === Component ? key : Component + "," + key)
+    ? (task.keyPath = null === Component ? key : Component + ',' + key)
     : null === Component && (task.implicitSlot = !0);
-  request = renderModelDestructive(request, task, emptyRoot, "", props);
+  request = renderModelDestructive(request, task, emptyRoot, '', props);
   task.keyPath = Component;
   task.implicitSlot = prevThenableState;
   return request;
@@ -1192,7 +1192,7 @@
         REACT_ELEMENT_TYPE,
         REACT_FRAGMENT_TYPE,
         task.keyPath,
-        { children: children }
+        { children: children },
       ]),
       task.implicitSlot ? [request] : request)
     : children;
@@ -1205,7 +1205,7 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   pingTask(request, task);
   return serializeLazyID(task.id);
@@ -1213,10 +1213,10 @@
 function renderElement(request, task, type, key, ref, props) {
   if (null !== ref && void 0 !== ref)
     throw Error(
-      "Refs cannot be used in Server Components, nor passed to Client Components."
+      'Refs cannot be used in Server Components, nor passed to Client Components.',
     );
   if (
-    "function" === typeof type &&
+    'function' === typeof type &&
     type.$$typeof !== CLIENT_REFERENCE_TAG$1 &&
     type.$$typeof !== TEMPORARY_REFERENCE_TAG
   )
@@ -1229,15 +1229,15 @@
         request,
         task,
         emptyRoot,
-        "",
-        props.children
+        '',
+        props.children,
       )),
       (task.implicitSlot = type),
       props
     );
   if (
     null != type &&
-    "object" === typeof type &&
+    'object' === typeof type &&
     type.$$typeof !== CLIENT_REFERENCE_TAG$1
   )
     switch (type.$$typeof) {
@@ -1252,7 +1252,7 @@
         return renderElement(request, task, type.type, key, ref, props);
     }
   else
-    "string" === typeof type &&
+    'string' === typeof type &&
       ((ref = task.formatContext),
       (init = getChildFormatContext(ref, type, props)),
       ref !== init &&
@@ -1262,7 +1262,7 @@
   key = task.keyPath;
   null === request
     ? (request = key)
-    : null !== key && (request = key + "," + request);
+    : null !== key && (request = key + ',' + request);
   props = [REACT_ELEMENT_TYPE, type, request, props];
   task = task.implicitSlot && null !== request ? [props] : props;
   return task;
@@ -1286,11 +1286,11 @@
   keyPath,
   implicitSlot,
   formatContext,
-  abortSet
+  abortSet,
 ) {
   request.pendingChunks++;
   var id = request.nextChunkId++;
-  "object" !== typeof model ||
+  'object' !== typeof model ||
     null === model ||
     null !== keyPath ||
     implicitSlot ||
@@ -1315,13 +1315,13 @@
           task,
           this,
           parentPropertyName,
-          value
+          value,
         );
       } catch (thrownValue) {
         if (
           ((parentPropertyName = task.model),
           (parentPropertyName =
-            "object" === typeof parentPropertyName &&
+            'object' === typeof parentPropertyName &&
             null !== parentPropertyName &&
             (parentPropertyName.$$typeof === REACT_ELEMENT_TYPE ||
               parentPropertyName.$$typeof === REACT_LAZY_TYPE)),
@@ -1343,9 +1343,9 @@
             thrownValue === SuspenseException
               ? getSuspendedThenable()
               : thrownValue),
-          "object" === typeof value &&
+          'object' === typeof value &&
             null !== value &&
-            "function" === typeof value.then)
+            'function' === typeof value.then)
         ) {
           JSCompiler_inline_result = createTask(
             request,
@@ -1353,7 +1353,7 @@
             task.keyPath,
             task.implicitSlot,
             task.formatContext,
-            request.abortableTasks
+            request.abortableTasks,
           );
           var ping = JSCompiler_inline_result.ping;
           value.then(ping, ping);
@@ -1377,44 +1377,44 @@
       }
       return JSCompiler_inline_result;
     },
-    thenableState: null
+    thenableState: null,
   };
   abortSet.add(task);
   return task;
 }
 function serializeByValueID(id) {
-  return "$" + id.toString(16);
+  return '$' + id.toString(16);
 }
 function serializeLazyID(id) {
-  return "$L" + id.toString(16);
+  return '$L' + id.toString(16);
 }
 function encodeReferenceChunk(request, id, reference) {
   request = stringify(reference);
-  return id.toString(16) + ":" + request + "\n";
+  return id.toString(16) + ':' + request + '\n';
 }
 function serializeClientReference(
   request,
   parent,
   parentPropertyName,
-  clientReference
+  clientReference,
 ) {
   var clientReferenceKey = clientReference.$$async
-      ? clientReference.$$id + "#async"
+      ? clientReference.$$id + '#async'
       : clientReference.$$id,
     writtenClientReferences = request.writtenClientReferences,
     existingId = writtenClientReferences.get(clientReferenceKey);
   if (void 0 !== existingId)
-    return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+    return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
       ? serializeLazyID(existingId)
       : serializeByValueID(existingId);
   try {
     var config = request.bundlerConfig,
       modulePath = clientReference.$$id;
-    existingId = "";
+    existingId = '';
     var resolvedModuleData = config[modulePath];
     if (resolvedModuleData) existingId = resolvedModuleData.name;
     else {
-      var idx = modulePath.lastIndexOf("#");
+      var idx = modulePath.lastIndexOf('#');
       -1 !== idx &&
         ((existingId = modulePath.slice(idx + 1)),
         (resolvedModuleData = config[modulePath.slice(0, idx)]));
@@ -1422,14 +1422,14 @@
         throw Error(
           'Could not find the module "' +
             modulePath +
-            '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.'
+            '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.',
         );
     }
     if (!0 === resolvedModuleData.async && !0 === clientReference.$$async)
       throw Error(
         'The module "' +
           modulePath +
-          '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.'
+          '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.',
       );
     var JSCompiler_inline_result =
       !0 === resolvedModuleData.async || !0 === clientReference.$$async
@@ -1438,10 +1438,10 @@
     request.pendingChunks++;
     var importId = request.nextChunkId++,
       json = stringify(JSCompiler_inline_result),
-      processedChunk = importId.toString(16) + ":I" + json + "\n";
+      processedChunk = importId.toString(16) + ':I' + json + '\n';
     request.completedImportChunks.push(processedChunk);
     writtenClientReferences.set(clientReferenceKey, importId);
-    return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+    return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
       ? serializeLazyID(importId)
       : serializeByValueID(importId);
   } catch (x) {
@@ -1461,7 +1461,7 @@
     null,
     !1,
     formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   retryTask(request, value);
   return value.id;
@@ -1476,7 +1476,7 @@
   function progress(entry) {
     if (0 === newTask.status)
       if (entry.done)
-        request.cacheController.signal.removeEventListener("abort", abortBlob),
+        request.cacheController.signal.removeEventListener('abort', abortBlob),
           pingTask(request, newTask);
       else
         return (
@@ -1485,7 +1485,7 @@
   }
   function error(reason) {
     0 === newTask.status &&
-      (request.cacheController.signal.removeEventListener("abort", abortBlob),
+      (request.cacheController.signal.removeEventListener('abort', abortBlob),
       erroredTask(request, newTask, reason),
       enqueueFlush(request),
       reader.cancel(reason).then(error, error));
@@ -1493,7 +1493,7 @@
   function abortBlob() {
     if (0 === newTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortBlob);
+      signal.removeEventListener('abort', abortBlob);
       signal = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(newTask),
@@ -1506,9 +1506,9 @@
   var model = [blob.type],
     newTask = createTask(request, model, null, !1, 0, request.abortableTasks),
     reader = blob.stream().getReader();
-  request.cacheController.signal.addEventListener("abort", abortBlob);
+  request.cacheController.signal.addEventListener('abort', abortBlob);
   reader.read().then(progress).catch(error);
-  return "$B" + newTask.id.toString(16);
+  return '$B' + newTask.id.toString(16);
 }
 var modelRoot = !1;
 function renderModelDestructive(
@@ -1516,12 +1516,12 @@
   task,
   parent,
   parentPropertyName,
-  value
+  value,
 ) {
   task.model = value;
-  if (value === REACT_ELEMENT_TYPE) return "$";
+  if (value === REACT_ELEMENT_TYPE) return '$';
   if (null === value) return null;
-  if ("object" === typeof value) {
+  if ('object' === typeof value) {
     switch (value.$$typeof) {
       case REACT_ELEMENT_TYPE:
         var elementReference = null,
@@ -1532,10 +1532,10 @@
             if (modelRoot === value) modelRoot = null;
             else return existingReference;
           else
-            -1 === parentPropertyName.indexOf(":") &&
+            -1 === parentPropertyName.indexOf(':') &&
               ((parent = writtenObjects.get(parent)),
               void 0 !== parent &&
-                ((elementReference = parent + ":" + parentPropertyName),
+                ((elementReference = parent + ':' + parentPropertyName),
                 writtenObjects.set(value, elementReference)));
         }
         if (3200 < serializedSize) return deferTask(request, task);
@@ -1547,9 +1547,9 @@
           value.type,
           value.key,
           void 0 !== parent ? parent : null,
-          parentPropertyName
+          parentPropertyName,
         );
-        "object" === typeof request &&
+        'object' === typeof request &&
           null !== request &&
           null !== elementReference &&
           (writtenObjects.has(request) ||
@@ -1561,10 +1561,10 @@
         parentPropertyName = value._init;
         value = parentPropertyName(value._payload);
         if (12 === request.status) throw null;
-        return renderModelDestructive(request, task, emptyRoot, "", value);
+        return renderModelDestructive(request, task, emptyRoot, '', value);
       case REACT_LEGACY_ELEMENT_TYPE:
         throw Error(
-          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
+          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.',
         );
     }
     if (value.$$typeof === CLIENT_REFERENCE_TAG$1)
@@ -1572,24 +1572,24 @@
         request,
         parent,
         parentPropertyName,
-        value
+        value,
       );
     if (
       void 0 !== request.temporaryReferences &&
       ((elementReference = request.temporaryReferences.get(value)),
       void 0 !== elementReference)
     )
-      return "$T" + elementReference;
+      return '$T' + elementReference;
     elementReference = request.writtenObjects;
     writtenObjects = elementReference.get(value);
-    if ("function" === typeof value.then) {
+    if ('function' === typeof value.then) {
       if (void 0 !== writtenObjects) {
         if (null !== task.keyPath || task.implicitSlot)
-          return "$@" + serializeThenable(request, task, value).toString(16);
+          return '$@' + serializeThenable(request, task, value).toString(16);
         if (modelRoot === value) modelRoot = null;
         else return writtenObjects;
       }
-      request = "$@" + serializeThenable(request, task, value).toString(16);
+      request = '$@' + serializeThenable(request, task, value).toString(16);
       elementReference.set(value, request);
       return request;
     }
@@ -1600,92 +1600,92 @@
         modelRoot = null;
       } else return writtenObjects;
     else if (
-      -1 === parentPropertyName.indexOf(":") &&
+      -1 === parentPropertyName.indexOf(':') &&
       ((writtenObjects = elementReference.get(parent)),
       void 0 !== writtenObjects)
     ) {
       existingReference = parentPropertyName;
       if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
         switch (parentPropertyName) {
-          case "1":
-            existingReference = "type";
+          case '1':
+            existingReference = 'type';
             break;
-          case "2":
-            existingReference = "key";
+          case '2':
+            existingReference = 'key';
             break;
-          case "3":
-            existingReference = "props";
+          case '3':
+            existingReference = 'props';
             break;
-          case "4":
-            existingReference = "_owner";
+          case '4':
+            existingReference = '_owner';
         }
-      elementReference.set(value, writtenObjects + ":" + existingReference);
+      elementReference.set(value, writtenObjects + ':' + existingReference);
     }
     if (isArrayImpl(value)) return renderFragment(request, task, value);
     if (value instanceof Map)
       return (
         (value = Array.from(value)),
-        "$Q" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$Q' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
     if (value instanceof Set)
       return (
         (value = Array.from(value)),
-        "$W" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$W' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
-    if ("function" === typeof FormData && value instanceof FormData)
+    if ('function' === typeof FormData && value instanceof FormData)
       return (
         (value = Array.from(value.entries())),
-        "$K" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$K' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
-    if (value instanceof Error) return "$Z";
+    if (value instanceof Error) return '$Z';
     if (value instanceof ArrayBuffer)
-      return serializeTypedArray(request, "A", new Uint8Array(value));
+      return serializeTypedArray(request, 'A', new Uint8Array(value));
     if (value instanceof Int8Array)
-      return serializeTypedArray(request, "O", value);
+      return serializeTypedArray(request, 'O', value);
     if (value instanceof Uint8Array)
-      return serializeTypedArray(request, "o", value);
+      return serializeTypedArray(request, 'o', value);
     if (value instanceof Uint8ClampedArray)
-      return serializeTypedArray(request, "U", value);
+      return serializeTypedArray(request, 'U', value);
     if (value instanceof Int16Array)
-      return serializeTypedArray(request, "S", value);
+      return serializeTypedArray(request, 'S', value);
     if (value instanceof Uint16Array)
-      return serializeTypedArray(request, "s", value);
+      return serializeTypedArray(request, 's', value);
     if (value instanceof Int32Array)
-      return serializeTypedArray(request, "L", value);
+      return serializeTypedArray(request, 'L', value);
     if (value instanceof Uint32Array)
-      return serializeTypedArray(request, "l", value);
+      return serializeTypedArray(request, 'l', value);
     if (value instanceof Float32Array)
-      return serializeTypedArray(request, "G", value);
+      return serializeTypedArray(request, 'G', value);
     if (value instanceof Float64Array)
-      return serializeTypedArray(request, "g", value);
+      return serializeTypedArray(request, 'g', value);
     if (value instanceof BigInt64Array)
-      return serializeTypedArray(request, "M", value);
+      return serializeTypedArray(request, 'M', value);
     if (value instanceof BigUint64Array)
-      return serializeTypedArray(request, "m", value);
+      return serializeTypedArray(request, 'm', value);
     if (value instanceof DataView)
-      return serializeTypedArray(request, "V", value);
-    if ("function" === typeof Blob && value instanceof Blob)
+      return serializeTypedArray(request, 'V', value);
+    if ('function' === typeof Blob && value instanceof Blob)
       return serializeBlob(request, value);
     if ((elementReference = getIteratorFn(value)))
       return (
         (parentPropertyName = elementReference.call(value)),
         parentPropertyName === value
           ? ((value = Array.from(parentPropertyName)),
-            "$i" +
+            '$i' +
               outlineModelWithFormatContext(request, value, 0).toString(16))
           : renderFragment(request, task, Array.from(parentPropertyName))
       );
-    if ("function" === typeof ReadableStream && value instanceof ReadableStream)
+    if ('function' === typeof ReadableStream && value instanceof ReadableStream)
       return serializeReadableStream(request, task, value);
     elementReference = value[ASYNC_ITERATOR];
-    if ("function" === typeof elementReference)
+    if ('function' === typeof elementReference)
       return (
         null !== task.keyPath
           ? ((request = [
               REACT_ELEMENT_TYPE,
               REACT_FRAGMENT_TYPE,
               task.keyPath,
-              { children: value }
+              { children: value },
             ]),
             (request = task.implicitSlot ? [request] : request))
           : ((parentPropertyName = elementReference.call(value)),
@@ -1693,29 +1693,29 @@
               request,
               task,
               value,
-              parentPropertyName
+              parentPropertyName,
             ))),
         request
       );
-    if (value instanceof Date) return "$D" + value.toJSON();
+    if (value instanceof Date) return '$D' + value.toJSON();
     request = getPrototypeOf(value);
     if (
       request !== ObjectPrototype &&
       (null === request || null !== getPrototypeOf(request))
     )
       throw Error(
-        "Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported." +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+        'Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.' +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     return value;
   }
-  if ("string" === typeof value) {
+  if ('string' === typeof value) {
     serializedSize += value.length;
     if (
-      "Z" === value[value.length - 1] &&
+      'Z' === value[value.length - 1] &&
       parent[parentPropertyName] instanceof Date
     )
-      return "$D" + value;
+      return '$D' + value;
     if (1024 <= value.length && null !== byteLengthOfChunk)
       return (
         request.pendingChunks++,
@@ -1723,35 +1723,35 @@
         emitTextChunk(request, task, value, !1),
         serializeByValueID(task)
       );
-    request = "$" === value[0] ? "$" + value : value;
+    request = '$' === value[0] ? '$' + value : value;
     return request;
   }
-  if ("boolean" === typeof value) return value;
-  if ("number" === typeof value)
+  if ('boolean' === typeof value) return value;
+  if ('number' === typeof value)
     return Number.isFinite(value)
       ? 0 === value && -Infinity === 1 / value
-        ? "$-0"
+        ? '$-0'
         : value
       : Infinity === value
-        ? "$Infinity"
+        ? '$Infinity'
         : -Infinity === value
-          ? "$-Infinity"
-          : "$NaN";
-  if ("undefined" === typeof value) return "$undefined";
-  if ("function" === typeof value) {
+          ? '$-Infinity'
+          : '$NaN';
+  if ('undefined' === typeof value) return '$undefined';
+  if ('function' === typeof value) {
     if (value.$$typeof === CLIENT_REFERENCE_TAG$1)
       return serializeClientReference(
         request,
         parent,
         parentPropertyName,
-        value
+        value,
       );
     if (value.$$typeof === SERVER_REFERENCE_TAG)
       return (
         (task = request.writtenServerReferences),
         (parentPropertyName = task.get(value)),
         void 0 !== parentPropertyName
-          ? (request = "$F" + parentPropertyName.toString(16))
+          ? (request = '$F' + parentPropertyName.toString(16))
           : ((parentPropertyName = value.$$bound),
             (parentPropertyName =
               null === parentPropertyName
@@ -1760,33 +1760,33 @@
             (request = outlineModelWithFormatContext(
               request,
               { id: value.$$id, bound: parentPropertyName },
-              0
+              0,
             )),
             task.set(value, request),
-            (request = "$F" + request.toString(16))),
+            (request = '$F' + request.toString(16))),
         request
       );
     if (
       void 0 !== request.temporaryReferences &&
       ((request = request.temporaryReferences.get(value)), void 0 !== request)
     )
-      return "$T" + request;
+      return '$T' + request;
     if (value.$$typeof === TEMPORARY_REFERENCE_TAG)
       throw Error(
-        "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+        'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
       );
     if (/^on[A-Z]/.test(parentPropertyName))
       throw Error(
-        "Event handlers cannot be passed to Client Component props." +
+        'Event handlers cannot be passed to Client Component props.' +
           describeObjectForErrorMessage(parent, parentPropertyName) +
-          "\nIf you need interactivity, consider converting part of this to a Client Component."
+          '\nIf you need interactivity, consider converting part of this to a Client Component.',
       );
     throw Error(
       'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.' +
-        describeObjectForErrorMessage(parent, parentPropertyName)
+        describeObjectForErrorMessage(parent, parentPropertyName),
     );
   }
-  if ("symbol" === typeof value) {
+  if ('symbol' === typeof value) {
     task = request.writtenSymbols;
     elementReference = task.get(value);
     if (void 0 !== elementReference)
@@ -1794,27 +1794,27 @@
     elementReference = value.description;
     if (Symbol.for(elementReference) !== value)
       throw Error(
-        "Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" +
-          (value.description + ") cannot be found among global symbols.") +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+        'Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(' +
+          (value.description + ') cannot be found among global symbols.') +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     request.pendingChunks++;
     parentPropertyName = request.nextChunkId++;
     parent = encodeReferenceChunk(
       request,
       parentPropertyName,
-      "$S" + elementReference
+      '$S' + elementReference,
     );
     request.completedImportChunks.push(parent);
     task.set(value, parentPropertyName);
     return serializeByValueID(parentPropertyName);
   }
-  if ("bigint" === typeof value) return "$n" + value.toString(10);
+  if ('bigint' === typeof value) return '$n' + value.toString(10);
   throw Error(
-    "Type " +
+    'Type ' +
       typeof value +
-      " is not supported in Client Component props." +
-      describeObjectForErrorMessage(parent, parentPropertyName)
+      ' is not supported in Client Component props.' +
+      describeObjectForErrorMessage(parent, parentPropertyName),
   );
 }
 function logRecoverableError(request, error) {
@@ -1825,13 +1825,13 @@
   } finally {
     currentRequest = prevRequest;
   }
-  if (null != errorDigest && "string" !== typeof errorDigest)
+  if (null != errorDigest && 'string' !== typeof errorDigest)
     throw Error(
       'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
         typeof errorDigest +
-        '" instead'
+        '" instead',
     );
-  return errorDigest || "";
+  return errorDigest || '';
 }
 function fatalError(request, error) {
   var onFatalError = request.onFatalError;
@@ -1840,12 +1840,12 @@
     ? ((request.status = 14), request.destination.destroy(error))
     : ((request.status = 13), (request.fatalError = error));
   request.cacheController.abort(
-    Error("The render was aborted due to a fatal error.", { cause: error })
+    Error('The render was aborted due to a fatal error.', { cause: error }),
   );
 }
 function emitErrorChunk(request, id, digest) {
   digest = { digest: digest };
-  id = id.toString(16) + ":E" + stringify(digest) + "\n";
+  id = id.toString(16) + ':E' + stringify(digest) + '\n';
   request.completedErrorChunks.push(id);
 }
 function emitTypedArrayChunk(request, id, tag, typedArray, debug) {
@@ -1853,55 +1853,55 @@
   typedArray = new Uint8Array(
     typedArray.buffer,
     typedArray.byteOffset,
-    typedArray.byteLength
+    typedArray.byteLength,
   );
   debug = typedArray.byteLength;
-  id = id.toString(16) + ":" + tag + debug.toString(16) + ",";
+  id = id.toString(16) + ':' + tag + debug.toString(16) + ',';
   request.completedRegularChunks.push(id, typedArray);
 }
 function emitTextChunk(request, id, text, debug) {
   if (null === byteLengthOfChunk)
     throw Error(
-      "Existence of byteLengthOfChunk should have already been checked. This is a bug in React."
+      'Existence of byteLengthOfChunk should have already been checked. This is a bug in React.',
     );
   debug ? request.pendingDebugChunks++ : request.pendingChunks++;
   debug = byteLengthOfChunk(text);
-  id = id.toString(16) + ":T" + debug.toString(16) + ",";
+  id = id.toString(16) + ':T' + debug.toString(16) + ',';
   request.completedRegularChunks.push(id, text);
 }
 function emitChunk(request, task, value) {
   var id = task.id;
-  "string" === typeof value && null !== byteLengthOfChunk
+  'string' === typeof value && null !== byteLengthOfChunk
     ? emitTextChunk(request, id, value, !1)
     : value instanceof ArrayBuffer
-      ? emitTypedArrayChunk(request, id, "A", new Uint8Array(value), !1)
+      ? emitTypedArrayChunk(request, id, 'A', new Uint8Array(value), !1)
       : value instanceof Int8Array
-        ? emitTypedArrayChunk(request, id, "O", value, !1)
+        ? emitTypedArrayChunk(request, id, 'O', value, !1)
         : value instanceof Uint8Array
-          ? emitTypedArrayChunk(request, id, "o", value, !1)
+          ? emitTypedArrayChunk(request, id, 'o', value, !1)
           : value instanceof Uint8ClampedArray
-            ? emitTypedArrayChunk(request, id, "U", value, !1)
+            ? emitTypedArrayChunk(request, id, 'U', value, !1)
             : value instanceof Int16Array
-              ? emitTypedArrayChunk(request, id, "S", value, !1)
+              ? emitTypedArrayChunk(request, id, 'S', value, !1)
               : value instanceof Uint16Array
-                ? emitTypedArrayChunk(request, id, "s", value, !1)
+                ? emitTypedArrayChunk(request, id, 's', value, !1)
                 : value instanceof Int32Array
-                  ? emitTypedArrayChunk(request, id, "L", value, !1)
+                  ? emitTypedArrayChunk(request, id, 'L', value, !1)
                   : value instanceof Uint32Array
-                    ? emitTypedArrayChunk(request, id, "l", value, !1)
+                    ? emitTypedArrayChunk(request, id, 'l', value, !1)
                     : value instanceof Float32Array
-                      ? emitTypedArrayChunk(request, id, "G", value, !1)
+                      ? emitTypedArrayChunk(request, id, 'G', value, !1)
                       : value instanceof Float64Array
-                        ? emitTypedArrayChunk(request, id, "g", value, !1)
+                        ? emitTypedArrayChunk(request, id, 'g', value, !1)
                         : value instanceof BigInt64Array
-                          ? emitTypedArrayChunk(request, id, "M", value, !1)
+                          ? emitTypedArrayChunk(request, id, 'M', value, !1)
                           : value instanceof BigUint64Array
-                            ? emitTypedArrayChunk(request, id, "m", value, !1)
+                            ? emitTypedArrayChunk(request, id, 'm', value, !1)
                             : value instanceof DataView
-                              ? emitTypedArrayChunk(request, id, "V", value, !1)
+                              ? emitTypedArrayChunk(request, id, 'V', value, !1)
                               : ((value = stringify(value, task.toJSON)),
                                 (task =
-                                  task.id.toString(16) + ":" + value + "\n"),
+                                  task.id.toString(16) + ':' + value + '\n'),
                                 request.completedRegularChunks.push(task));
 }
 function erroredTask(request, task, error) {
@@ -1922,18 +1922,18 @@
         request,
         task,
         emptyRoot,
-        "",
-        task.model
+        '',
+        task.model,
       );
       modelRoot = resolvedModel;
       task.keyPath = null;
       task.implicitSlot = !1;
-      if ("object" === typeof resolvedModel && null !== resolvedModel)
+      if ('object' === typeof resolvedModel && null !== resolvedModel)
         request.writtenObjects.set(resolvedModel, serializeByValueID(task.id)),
           emitChunk(request, task, resolvedModel);
       else {
         var json = stringify(resolvedModel),
-          processedChunk = task.id.toString(16) + ":" + json + "\n";
+          processedChunk = task.id.toString(16) + ':' + json + '\n';
         request.completedRegularChunks.push(processedChunk);
       }
       task.status = 1;
@@ -1958,9 +1958,9 @@
             ? getSuspendedThenable()
             : thrownValue;
         if (
-          "object" === typeof x &&
+          'object' === typeof x &&
           null !== x &&
-          "function" === typeof x.then
+          'function' === typeof x.then
         ) {
           task.status = 0;
           task.thenableState = getThenableStateAfterSuspending();
@@ -2075,14 +2075,14 @@
         (writtenBytes = 0),
         (destinationHasCapacity = !0);
     }
-    "function" === typeof destination.flush && destination.flush();
+    'function' === typeof destination.flush && destination.flush();
   }
   0 === request.pendingChunks &&
     (12 > request.status &&
       request.cacheController.abort(
         Error(
-          "This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources."
-        )
+          'This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources.',
+        ),
       ),
     null !== request.destination &&
       ((request.status = 14),
@@ -2166,13 +2166,13 @@
           var error =
               void 0 === reason
                 ? Error(
-                    "The render was aborted by the server without a reason."
+                    'The render was aborted by the server without a reason.',
                   )
-                : "object" === typeof reason &&
+                : 'object' === typeof reason &&
                     null !== reason &&
-                    "function" === typeof reason.then
+                    'function' === typeof reason.then
                   ? Error(
-                      "The render was aborted by the server with a promise."
+                      'The render was aborted by the server with a promise.',
                     )
                   : reason,
             digest = logRecoverableError(request, error, null),
@@ -2198,11 +2198,11 @@
     }
 }
 function resolveServerReference(bundlerConfig, id) {
-  var name = "",
+  var name = '',
     resolvedModuleData = bundlerConfig[id];
   if (resolvedModuleData) name = resolvedModuleData.name;
   else {
-    var idx = id.lastIndexOf("#");
+    var idx = id.lastIndexOf('#');
     -1 !== idx &&
       ((name = id.slice(idx + 1)),
       (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));
@@ -2210,7 +2210,7 @@
       throw Error(
         'Could not find the module "' +
           id +
-          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'
+          '" in the React Server Manifest. This is probably a bug in the React Server Components bundler.',
       );
   }
   return resolvedModuleData.async
@@ -2220,17 +2220,17 @@
 var chunkCache = new Map();
 function requireAsyncModule(id) {
   var promise = __webpack_require__(id);
-  if ("function" !== typeof promise.then || "fulfilled" === promise.status)
+  if ('function' !== typeof promise.then || 'fulfilled' === promise.status)
     return null;
   promise.then(
     function (value) {
-      promise.status = "fulfilled";
+      promise.status = 'fulfilled';
       promise.value = value;
     },
     function (reason) {
-      promise.status = "rejected";
+      promise.status = 'rejected';
       promise.reason = reason;
-    }
+    },
   );
   return promise;
 }
@@ -2260,13 +2260,13 @@
 }
 function requireModule(metadata) {
   var moduleExports = __webpack_require__(metadata[0]);
-  if (4 === metadata.length && "function" === typeof moduleExports.then)
-    if ("fulfilled" === moduleExports.status)
+  if (4 === metadata.length && 'function' === typeof moduleExports.then)
+    if ('fulfilled' === moduleExports.status)
       moduleExports = moduleExports.value;
     else throw moduleExports.reason;
-  return "*" === metadata[2]
+  return '*' === metadata[2]
     ? moduleExports
-    : "" === metadata[2]
+    : '' === metadata[2]
       ? moduleExports.__esModule
         ? moduleExports.default
         : moduleExports
@@ -2281,16 +2281,16 @@
 Chunk.prototype = Object.create(Promise.prototype);
 Chunk.prototype.then = function (resolve, reject) {
   switch (this.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(this);
   }
   switch (this.status) {
-    case "fulfilled":
+    case 'fulfilled':
       resolve(this.value);
       break;
-    case "pending":
-    case "blocked":
-    case "cyclic":
+    case 'pending':
+    case 'blocked':
+    case 'cyclic':
       resolve &&
         (null === this.value && (this.value = []), this.value.push(resolve));
       reject &&
@@ -2301,41 +2301,41 @@
   }
 };
 function createPendingChunk(response) {
-  return new Chunk("pending", null, null, response);
+  return new Chunk('pending', null, null, response);
 }
 function wakeChunk(listeners, value) {
   for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
 }
 function triggerErrorOnChunk(chunk, error) {
-  if ("pending" !== chunk.status && "blocked" !== chunk.status)
+  if ('pending' !== chunk.status && 'blocked' !== chunk.status)
     chunk.reason.error(error);
   else {
     var listeners = chunk.reason;
-    chunk.status = "rejected";
+    chunk.status = 'rejected';
     chunk.reason = error;
     null !== listeners && wakeChunk(listeners, error);
   }
 }
 function resolveModelChunk(chunk, value, id) {
-  if ("pending" !== chunk.status)
+  if ('pending' !== chunk.status)
     (chunk = chunk.reason),
-      "C" === value[0]
-        ? chunk.close("C" === value ? '"$undefined"' : value.slice(1))
+      'C' === value[0]
+        ? chunk.close('C' === value ? '"$undefined"' : value.slice(1))
         : chunk.enqueueModel(value);
   else {
     var resolveListeners = chunk.value,
       rejectListeners = chunk.reason;
-    chunk.status = "resolved_model";
+    chunk.status = 'resolved_model';
     chunk.value = value;
     chunk.reason = id;
     if (null !== resolveListeners)
       switch ((initializeModelChunk(chunk), chunk.status)) {
-        case "fulfilled":
+        case 'fulfilled':
           wakeChunk(resolveListeners, chunk.value);
           break;
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           if (chunk.value)
             for (value = 0; value < resolveListeners.length; value++)
               chunk.value.push(resolveListeners[value]);
@@ -2346,24 +2346,24 @@
                 chunk.reason.push(rejectListeners[value]);
           } else chunk.reason = rejectListeners;
           break;
-        case "rejected":
+        case 'rejected':
           rejectListeners && wakeChunk(rejectListeners, chunk.reason);
       }
   }
 }
 function createResolvedIteratorResultChunk(response, value, done) {
   return new Chunk(
-    "resolved_model",
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
+    'resolved_model',
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
     -1,
-    response
+    response,
   );
 }
 function resolveIteratorResultChunk(chunk, value, done) {
   resolveModelChunk(
     chunk,
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
-    -1
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
+    -1,
   );
 }
 function loadServerReference$1(
@@ -2372,7 +2372,7 @@
   bound,
   parentChunk,
   parentObject,
-  key
+  key,
 ) {
   var serverReference = resolveServerReference(response._bundlerConfig, id);
   id = preloadModule(serverReference);
@@ -2395,16 +2395,16 @@
       !1,
       response,
       createModel,
-      []
+      [],
     ),
-    createModelReject(parentChunk)
+    createModelReject(parentChunk),
   );
   return null;
 }
 function reviveModel(response, parentObj, parentKey, value, reference) {
-  if ("string" === typeof value)
+  if ('string' === typeof value)
     return parseModelString(response, parentObj, parentKey, value, reference);
-  if ("object" === typeof value && null !== value)
+  if ('object' === typeof value && null !== value)
     if (
       (void 0 !== reference &&
         void 0 !== response._temporaryReferences &&
@@ -2415,16 +2415,16 @@
         value[i] = reviveModel(
           response,
           value,
-          "" + i,
+          '' + i,
           value[i],
-          void 0 !== reference ? reference + ":" + i : void 0
+          void 0 !== reference ? reference + ':' + i : void 0,
         );
     else
       for (i in value)
         hasOwnProperty.call(value, i) &&
           ((parentObj =
-            void 0 !== reference && -1 === i.indexOf(":")
-              ? reference + ":" + i
+            void 0 !== reference && -1 === i.indexOf(':')
+              ? reference + ':' + i
               : void 0),
           (parentObj = reviveModel(response, value, i, value[i], parentObj)),
           void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);
@@ -2439,31 +2439,31 @@
   initializingChunkBlockedModel = null;
   var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),
     resolvedModel = chunk.value;
-  chunk.status = "cyclic";
+  chunk.status = 'cyclic';
   chunk.value = null;
   chunk.reason = null;
   try {
     var rawModel = JSON.parse(resolvedModel),
       value = reviveModel(
         chunk._response,
-        { "": rawModel },
-        "",
+        { '': rawModel },
+        '',
         rawModel,
-        rootReference
+        rootReference,
       );
     if (
       null !== initializingChunkBlockedModel &&
       0 < initializingChunkBlockedModel.deps
     )
-      (initializingChunkBlockedModel.value = value), (chunk.status = "blocked");
+      (initializingChunkBlockedModel.value = value), (chunk.status = 'blocked');
     else {
       var resolveListeners = chunk.value;
-      chunk.status = "fulfilled";
+      chunk.status = 'fulfilled';
       chunk.value = value;
       null !== resolveListeners && wakeChunk(resolveListeners, value);
     }
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   } finally {
     (initializingChunk = prevChunk),
       (initializingChunkBlockedModel = prevBlocked);
@@ -2473,7 +2473,7 @@
   response._closed = !0;
   response._closedReason = error;
   response._chunks.forEach(function (chunk) {
-    "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+    'pending' === chunk.status && triggerErrorOnChunk(chunk, error);
   });
 }
 function getChunk(response, id) {
@@ -2483,9 +2483,9 @@
     ((chunk = response._formData.get(response._prefix + id)),
     (chunk =
       null != chunk
-        ? new Chunk("resolved_model", chunk, id, response)
+        ? new Chunk('resolved_model', chunk, id, response)
         : response._closed
-          ? new Chunk("rejected", null, response._closedReason, response)
+          ? new Chunk('rejected', null, response._closedReason, response)
           : createPendingChunk(response)),
     chunks.set(id, chunk));
   return chunk;
@@ -2497,7 +2497,7 @@
   cyclic,
   response,
   map,
-  path
+  path,
 ) {
   if (initializingChunkBlockedModel) {
     var blocked = initializingChunkBlockedModel;
@@ -2505,17 +2505,17 @@
   } else
     blocked = initializingChunkBlockedModel = {
       deps: cyclic ? 0 : 1,
-      value: null
+      value: null,
     };
   return function (value) {
     for (var i = 1; i < path.length; i++) value = value[path[i]];
     parentObject[key] = map(response, value);
-    "" === key && null === blocked.value && (blocked.value = parentObject[key]);
+    '' === key && null === blocked.value && (blocked.value = parentObject[key]);
     blocked.deps--;
     0 === blocked.deps &&
-      "blocked" === chunk.status &&
+      'blocked' === chunk.status &&
       ((value = chunk.value),
-      (chunk.status = "fulfilled"),
+      (chunk.status = 'fulfilled'),
       (chunk.value = blocked.value),
       null !== value && wakeChunk(value, blocked.value));
   };
@@ -2526,34 +2526,34 @@
   };
 }
 function getOutlinedModel(response, reference, parentObject, key, map) {
-  reference = reference.split(":");
+  reference = reference.split(':');
   var id = parseInt(reference[0], 16);
   id = getChunk(response, id);
   switch (id.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(id);
   }
   switch (id.status) {
-    case "fulfilled":
+    case 'fulfilled':
       parentObject = id.value;
       for (key = 1; key < reference.length; key++)
         parentObject = parentObject[reference[key]];
       return map(response, parentObject);
-    case "pending":
-    case "blocked":
-    case "cyclic":
+    case 'pending':
+    case 'blocked':
+    case 'cyclic':
       var parentChunk = initializingChunk;
       id.then(
         createModelResolver(
           parentChunk,
           parentObject,
           key,
-          "cyclic" === id.status,
+          'cyclic' === id.status,
           response,
           map,
-          reference
+          reference,
         ),
-        createModelReject(parentChunk)
+        createModelReject(parentChunk),
       );
       return null;
     default:
@@ -2578,7 +2578,7 @@
   constructor,
   bytesPerElement,
   parentObject,
-  parentKey
+  parentKey,
 ) {
   reference = parseInt(reference.slice(2), 16);
   reference = response._formData.get(response._prefix + reference);
@@ -2597,21 +2597,21 @@
       !1,
       response,
       createModel,
-      []
+      [],
     ),
-    createModelReject(bytesPerElement)
+    createModelReject(bytesPerElement),
   );
   return null;
 }
 function resolveStream(response, id, stream, controller) {
   var chunks = response._chunks;
-  stream = new Chunk("fulfilled", stream, controller, response);
+  stream = new Chunk('fulfilled', stream, controller, response);
   chunks.set(id, stream);
   response = response._formData.getAll(response._prefix + id);
   for (id = 0; id < response.length; id++)
     (chunks = response[id]),
-      "C" === chunks[0]
-        ? controller.close("C" === chunks ? '"$undefined"' : chunks.slice(1))
+      'C' === chunks[0]
+        ? controller.close('C' === chunks ? '"$undefined"' : chunks.slice(1))
         : controller.enqueueModel(chunks);
 }
 function parseReadableStream(response, reference, type) {
@@ -2621,15 +2621,15 @@
     type: type,
     start: function (c) {
       controller = c;
-    }
+    },
   });
   var previousBlockedChunk = null;
   resolveStream(response, reference, type, {
     enqueueModel: function (json) {
       if (null === previousBlockedChunk) {
-        var chunk = new Chunk("resolved_model", json, -1, response);
+        var chunk = new Chunk('resolved_model', json, -1, response);
         initializeModelChunk(chunk);
-        "fulfilled" === chunk.status
+        'fulfilled' === chunk.status
           ? controller.enqueue(chunk.value)
           : (chunk.then(
               function (v) {
@@ -2637,7 +2637,7 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             ),
             (previousBlockedChunk = chunk));
       } else {
@@ -2649,7 +2649,7 @@
           },
           function (e) {
             return controller.error(e);
-          }
+          },
         );
         previousBlockedChunk = chunk$26;
         chunk.then(function () {
@@ -2677,7 +2677,7 @@
           return controller.error(error);
         });
       }
-    }
+    },
   });
   return type;
 }
@@ -2701,15 +2701,15 @@
       return createIterator(function (arg) {
         if (void 0 !== arg)
           throw Error(
-            "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+            'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
           );
         if (nextReadIndex === buffer.length) {
           if (closed)
             return new Chunk(
-              "fulfilled",
+              'fulfilled',
               { done: !0, value: void 0 },
               null,
-              response
+              response,
             );
           buffer[nextReadIndex] = createPendingChunk(response);
         }
@@ -2724,7 +2724,7 @@
         ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
             response,
             value,
-            !1
+            !1,
           ))
         : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
       nextWriteIndex++;
@@ -2735,14 +2735,14 @@
         ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
             response,
             value,
-            !0
+            !0,
           ))
         : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
       for (nextWriteIndex++; nextWriteIndex < buffer.length; )
         resolveIteratorResultChunk(
           buffer[nextWriteIndex++],
           '"$undefined"',
-          !0
+          !0,
         );
     },
     error: function (error) {
@@ -2754,18 +2754,18 @@
 
       )
         triggerErrorOnChunk(buffer[nextWriteIndex++], error);
-    }
+    },
   });
   return iterator;
 }
 function parseModelString(response, obj, key, value, reference) {
-  if ("$" === value[0]) {
+  if ('$' === value[0]) {
     switch (value[1]) {
-      case "$":
+      case '$':
         return value.slice(1);
-      case "@":
+      case '@':
         return (obj = parseInt(value.slice(2), 16)), getChunk(response, obj);
-      case "F":
+      case 'F':
         return (
           (value = value.slice(2)),
           (value = getOutlinedModel(response, value, obj, key, createModel)),
@@ -2775,96 +2775,96 @@
             value.bound,
             initializingChunk,
             obj,
-            key
+            key,
           )
         );
-      case "T":
+      case 'T':
         if (void 0 === reference || void 0 === response._temporaryReferences)
           throw Error(
-            "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+            'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
           );
         return createTemporaryReference(
           response._temporaryReferences,
-          reference
+          reference,
         );
-      case "Q":
+      case 'Q':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, createMap)
         );
-      case "W":
+      case 'W':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, createSet)
         );
-      case "K":
+      case 'K':
         obj = value.slice(2);
-        var formPrefix = response._prefix + obj + "_",
+        var formPrefix = response._prefix + obj + '_',
           data = new FormData();
         response._formData.forEach(function (entry, entryKey) {
           entryKey.startsWith(formPrefix) &&
             data.append(entryKey.slice(formPrefix.length), entry);
         });
         return data;
-      case "i":
+      case 'i':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, extractIterator)
         );
-      case "I":
+      case 'I':
         return Infinity;
-      case "-":
-        return "$-0" === value ? -0 : -Infinity;
-      case "N":
+      case '-':
+        return '$-0' === value ? -0 : -Infinity;
+      case 'N':
         return NaN;
-      case "u":
+      case 'u':
         return;
-      case "D":
+      case 'D':
         return new Date(Date.parse(value.slice(2)));
-      case "n":
+      case 'n':
         return BigInt(value.slice(2));
     }
     switch (value[1]) {
-      case "A":
+      case 'A':
         return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);
-      case "O":
+      case 'O':
         return parseTypedArray(response, value, Int8Array, 1, obj, key);
-      case "o":
+      case 'o':
         return parseTypedArray(response, value, Uint8Array, 1, obj, key);
-      case "U":
+      case 'U':
         return parseTypedArray(response, value, Uint8ClampedArray, 1, obj, key);
-      case "S":
+      case 'S':
         return parseTypedArray(response, value, Int16Array, 2, obj, key);
-      case "s":
+      case 's':
         return parseTypedArray(response, value, Uint16Array, 2, obj, key);
-      case "L":
+      case 'L':
         return parseTypedArray(response, value, Int32Array, 4, obj, key);
-      case "l":
+      case 'l':
         return parseTypedArray(response, value, Uint32Array, 4, obj, key);
-      case "G":
+      case 'G':
         return parseTypedArray(response, value, Float32Array, 4, obj, key);
-      case "g":
+      case 'g':
         return parseTypedArray(response, value, Float64Array, 8, obj, key);
-      case "M":
+      case 'M':
         return parseTypedArray(response, value, BigInt64Array, 8, obj, key);
-      case "m":
+      case 'm':
         return parseTypedArray(response, value, BigUint64Array, 8, obj, key);
-      case "V":
+      case 'V':
         return parseTypedArray(response, value, DataView, 1, obj, key);
-      case "B":
+      case 'B':
         return (
           (obj = parseInt(value.slice(2), 16)),
           response._formData.get(response._prefix + obj)
         );
     }
     switch (value[1]) {
-      case "R":
+      case 'R':
         return parseReadableStream(response, value, void 0);
-      case "r":
-        return parseReadableStream(response, value, "bytes");
-      case "X":
+      case 'r':
+        return parseReadableStream(response, value, 'bytes');
+      case 'X':
         return parseAsyncIterable(response, value, !1);
-      case "x":
+      case 'x':
         return parseAsyncIterable(response, value, !0);
     }
     value = value.slice(1);
@@ -2885,7 +2885,7 @@
     _chunks: chunks,
     _closed: !1,
     _closedReason: null,
-    _temporaryReferences: temporaryReferences
+    _temporaryReferences: temporaryReferences,
   };
 }
 function resolveField(response, key, value) {
@@ -2897,7 +2897,7 @@
     (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));
 }
 function close(response) {
-  reportGlobalError(response, Error("Connection closed."));
+  reportGlobalError(response, Error('Connection closed.'));
 }
 function loadServerReference(bundlerConfig, id, bound) {
   var serverReference = resolveServerReference(bundlerConfig, id);
@@ -2919,7 +2919,7 @@
   close(body);
   body = getChunk(body, 0);
   body.then(function () {});
-  if ("fulfilled" !== body.status) throw body.reason;
+  if ('fulfilled' !== body.status) throw body.reason;
   return body.value;
 }
 function createDrainHandler(destination, request) {
@@ -2936,7 +2936,7 @@
 function createFakeWritableFromReadableStreamController(controller) {
   return {
     write: function (chunk) {
-      "string" === typeof chunk && (chunk = textEncoder.encode(chunk));
+      'string' === typeof chunk && (chunk = textEncoder.encode(chunk));
       controller.enqueue(chunk);
       return !0;
     },
@@ -2944,10 +2944,10 @@
       controller.close();
     },
     destroy: function (error) {
-      "function" === typeof controller.error
+      'function' === typeof controller.error
         ? controller.error(error)
         : controller.close();
-    }
+    },
   };
 }
 function createFakeWritableFromNodeReadable(readable) {
@@ -2960,7 +2960,7 @@
     },
     destroy: function (error) {
       readable.destroy(error);
-    }
+    },
   };
 }
 exports.createClientModuleProxy = function (moduleId) {
@@ -2974,12 +2974,12 @@
   var formData = new FormData(),
     action = null;
   body.forEach(function (value, key) {
-    key.startsWith("$ACTION_")
-      ? key.startsWith("$ACTION_REF_")
-        ? ((value = "$ACTION_" + key.slice(12) + ":"),
+    key.startsWith('$ACTION_')
+      ? key.startsWith('$ACTION_REF_')
+        ? ((value = '$ACTION_' + key.slice(12) + ':'),
           (value = decodeBoundActionMetaData(body, serverManifest, value)),
           (action = loadServerReference(serverManifest, value.id, value.bound)))
-        : key.startsWith("$ACTION_ID_") &&
+        : key.startsWith('$ACTION_ID_') &&
           ((value = key.slice(11)),
           (action = loadServerReference(serverManifest, value, null)))
       : formData.append(key, value);
@@ -2991,12 +2991,12 @@
       });
 };
 exports.decodeFormState = function (actionResult, body, serverManifest) {
-  var keyPath = body.get("$ACTION_KEY");
-  if ("string" !== typeof keyPath) return Promise.resolve(null);
+  var keyPath = body.get('$ACTION_KEY');
+  if ('string' !== typeof keyPath) return Promise.resolve(null);
   var metaData = null;
   body.forEach(function (value, key) {
-    key.startsWith("$ACTION_REF_") &&
-      ((value = "$ACTION_" + key.slice(12) + ":"),
+    key.startsWith('$ACTION_REF_') &&
+      ((value = '$ACTION_' + key.slice(12) + ':'),
       (metaData = decodeBoundActionMetaData(body, serverManifest, value)));
   });
   if (null === metaData) return Promise.resolve(null);
@@ -3008,16 +3008,16 @@
   });
 };
 exports.decodeReply = function (body, webpackMap, options) {
-  if ("string" === typeof body) {
+  if ('string' === typeof body) {
     var form = new FormData();
-    form.append("0", body);
+    form.append('0', body);
     body = form;
   }
   body = createResponse(
     webpackMap,
-    "",
+    '',
     options ? options.temporaryReferences : void 0,
-    body
+    body,
   );
   webpackMap = getChunk(body, 0);
   close(body);
@@ -3026,7 +3026,7 @@
 exports.decodeReplyFromAsyncIterable = function (
   iterable,
   webpackMap,
-  options
+  options,
 ) {
   function progress(entry) {
     if (entry.done) close(response);
@@ -3034,7 +3034,7 @@
       var _entry$value = entry.value;
       entry = _entry$value[0];
       _entry$value = _entry$value[1];
-      "string" === typeof _entry$value
+      'string' === typeof _entry$value
         ? resolveField(response, entry, _entry$value)
         : response._formData.append(entry, _entry$value);
       iterator.next().then(progress, error);
@@ -3042,14 +3042,14 @@
   }
   function error(reason) {
     reportGlobalError(response, reason);
-    "function" === typeof iterator.throw &&
+    'function' === typeof iterator.throw &&
       iterator.throw(reason).then(error, error);
   }
   var iterator = iterable[ASYNC_ITERATOR](),
     response = createResponse(
       webpackMap,
-      "",
-      options ? options.temporaryReferences : void 0
+      '',
+      options ? options.temporaryReferences : void 0,
     );
   iterator.next().then(progress, error);
   return getChunk(response, 0);
@@ -3057,31 +3057,31 @@
 exports.decodeReplyFromBusboy = function (busboyStream, webpackMap, options) {
   var response = createResponse(
       webpackMap,
-      "",
-      options ? options.temporaryReferences : void 0
+      '',
+      options ? options.temporaryReferences : void 0,
     ),
     pendingFiles = 0,
     queuedFields = [];
-  busboyStream.on("field", function (name, value) {
+  busboyStream.on('field', function (name, value) {
     0 < pendingFiles
       ? queuedFields.push(name, value)
       : resolveField(response, name, value);
   });
-  busboyStream.on("file", function (name, value, _ref2) {
+  busboyStream.on('file', function (name, value, _ref2) {
     var filename = _ref2.filename,
       mimeType = _ref2.mimeType;
-    if ("base64" === _ref2.encoding.toLowerCase())
+    if ('base64' === _ref2.encoding.toLowerCase())
       throw Error(
-        "React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it."
+        "React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.",
       );
     pendingFiles++;
     var JSCompiler_object_inline_chunks_274 = [];
-    value.on("data", function (chunk) {
+    value.on('data', function (chunk) {
       JSCompiler_object_inline_chunks_274.push(chunk);
     });
-    value.on("end", function () {
+    value.on('end', function () {
       var blob = new Blob(JSCompiler_object_inline_chunks_274, {
-        type: mimeType
+        type: mimeType,
       });
       response._formData.append(name, blob, filename);
       pendingFiles--;
@@ -3092,10 +3092,10 @@
       }
     });
   });
-  busboyStream.on("finish", function () {
+  busboyStream.on('finish', function () {
     close(response);
   });
-  busboyStream.on("error", function (err) {
+  busboyStream.on('error', function (err) {
     reportGlobalError(response, err);
   });
   return getChunk(response, 0);
@@ -3112,7 +3112,7 @@
         var writable,
           stream = new ReadableStream(
             {
-              type: "bytes",
+              type: 'bytes',
               start: function (controller) {
                 writable =
                   createFakeWritableFromReadableStreamController(controller);
@@ -3123,15 +3123,15 @@
               cancel: function (reason) {
                 request.destination = null;
                 abort(request, reason);
-              }
+              },
             },
-            { highWaterMark: 0 }
+            { highWaterMark: 0 },
           );
         resolve({ prelude: stream });
       },
       reject,
       options ? options.identifierPrefix : void 0,
-      options ? options.temporaryReferences : void 0
+      options ? options.temporaryReferences : void 0,
     );
     if (options && options.signal) {
       var signal = options.signal;
@@ -3139,9 +3139,9 @@
       else {
         var listener = function () {
           abort(request, signal.reason);
-          signal.removeEventListener("abort", listener);
+          signal.removeEventListener('abort', listener);
         };
-        signal.addEventListener("abort", listener);
+        signal.addEventListener('abort', listener);
       }
     }
     startWork(request);
@@ -3159,14 +3159,14 @@
         var readable = new stream.Readable({
             read: function () {
               startFlowing(request, writable);
-            }
+            },
           }),
           writable = createFakeWritableFromNodeReadable(readable);
         resolve({ prelude: readable });
       },
       reject,
       options ? options.identifierPrefix : void 0,
-      options ? options.temporaryReferences : void 0
+      options ? options.temporaryReferences : void 0,
     );
     if (options && options.signal) {
       var signal = options.signal;
@@ -3174,9 +3174,9 @@
       else {
         var listener = function () {
           abort(request, signal.reason);
-          signal.removeEventListener("abort", listener);
+          signal.removeEventListener('abort', listener);
         };
-        signal.addEventListener("abort", listener);
+        signal.addEventListener('abort', listener);
       }
     }
     startWork(request);
@@ -3185,23 +3185,23 @@
 exports.registerClientReference = function (
   proxyImplementation,
   id,
-  exportName
+  exportName,
 ) {
   return registerClientReferenceImpl(
     proxyImplementation,
-    id + "#" + exportName,
-    !1
+    id + '#' + exportName,
+    !1,
   );
 };
 exports.registerServerReference = function (reference, id, exportName) {
   return Object.defineProperties(reference, {
     $$typeof: { value: SERVER_REFERENCE_TAG },
     $$id: {
-      value: null === exportName ? id : id + "#" + exportName,
-      configurable: !0
+      value: null === exportName ? id : id + '#' + exportName,
+      configurable: !0,
     },
     $$bound: { value: null, configurable: !0 },
-    bind: { value: bind, configurable: !0 }
+    bind: { value: bind, configurable: !0 },
   });
 };
 exports.renderToPipeableStream = function (model, webpackMap, options) {
@@ -3214,7 +3214,7 @@
       noop,
       noop,
       options ? options.identifierPrefix : void 0,
-      options ? options.temporaryReferences : void 0
+      options ? options.temporaryReferences : void 0,
     ),
     hasStartedFlowing = !1;
   startWork(request);
@@ -3222,27 +3222,27 @@
     pipe: function (destination) {
       if (hasStartedFlowing)
         throw Error(
-          "React currently only supports piping to one writable stream."
+          'React currently only supports piping to one writable stream.',
         );
       hasStartedFlowing = !0;
       startFlowing(request, destination);
-      destination.on("drain", createDrainHandler(destination, request));
+      destination.on('drain', createDrainHandler(destination, request));
       destination.on(
-        "error",
+        'error',
         createCancelHandler(
           request,
-          "The destination stream errored while writing data."
-        )
+          'The destination stream errored while writing data.',
+        ),
       );
       destination.on(
-        "close",
-        createCancelHandler(request, "The destination stream closed early.")
+        'close',
+        createCancelHandler(request, 'The destination stream closed early.'),
       );
       return destination;
     },
     abort: function (reason) {
       abort(request, reason);
-    }
+    },
   };
 };
 exports.renderToReadableStream = function (model, webpackMap, options) {
@@ -3255,7 +3255,7 @@
     noop,
     noop,
     options ? options.identifierPrefix : void 0,
-    options ? options.temporaryReferences : void 0
+    options ? options.temporaryReferences : void 0,
   );
   if (options && options.signal) {
     var signal = options.signal;
@@ -3263,15 +3263,15 @@
     else {
       var listener = function () {
         abort(request, signal.reason);
-        signal.removeEventListener("abort", listener);
+        signal.removeEventListener('abort', listener);
       };
-      signal.addEventListener("abort", listener);
+      signal.addEventListener('abort', listener);
     }
   }
   var writable;
   return new ReadableStream(
     {
-      type: "bytes",
+      type: 'bytes',
       start: function (controller) {
         writable = createFakeWritableFromReadableStreamController(controller);
         startWork(request);
@@ -3282,8 +3282,8 @@
       cancel: function (reason) {
         request.destination = null;
         abort(request, reason);
-      }
+      },
     },
-    { highWaterMark: 0 }
+    { highWaterMark: 0 },
   );
 };
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.node.unbundled.development.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.node.unbundled.development.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js	2025-12-17 14:32:45
@@ -8,54 +8,54 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
+'use strict';
+'production' !== process.env.NODE_ENV &&
   (function () {
     function voidHandler() {}
     function getIteratorFn(maybeIterable) {
-      if (null === maybeIterable || "object" !== typeof maybeIterable)
+      if (null === maybeIterable || 'object' !== typeof maybeIterable)
         return null;
       maybeIterable =
         (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-        maybeIterable["@@iterator"];
-      return "function" === typeof maybeIterable ? maybeIterable : null;
+        maybeIterable['@@iterator'];
+      return 'function' === typeof maybeIterable ? maybeIterable : null;
     }
     function _defineProperty(obj, key, value) {
-      a: if ("object" == typeof key && key) {
+      a: if ('object' == typeof key && key) {
         var e = key[Symbol.toPrimitive];
         if (void 0 !== e) {
-          key = e.call(key, "string");
-          if ("object" != typeof key) break a;
-          throw new TypeError("@@toPrimitive must return a primitive value.");
+          key = e.call(key, 'string');
+          if ('object' != typeof key) break a;
+          throw new TypeError('@@toPrimitive must return a primitive value.');
         }
         key = String(key);
       }
-      key = "symbol" == typeof key ? key : key + "";
+      key = 'symbol' == typeof key ? key : key + '';
       key in obj
         ? Object.defineProperty(obj, key, {
             value: value,
             enumerable: !0,
             configurable: !0,
-            writable: !0
+            writable: !0,
           })
         : (obj[key] = value);
       return obj;
     }
     function flushBuffered(destination) {
-      "function" === typeof destination.flush && destination.flush();
+      'function' === typeof destination.flush && destination.flush();
     }
     function writeToDestination(destination, view) {
       destination = destination.write(view);
       destinationHasCapacity = destinationHasCapacity && destination;
     }
     function writeChunkAndReturn(destination, chunk) {
-      if ("string" === typeof chunk) {
+      if ('string' === typeof chunk) {
         if (0 !== chunk.length)
           if (2048 < 3 * chunk.length)
             0 < writtenBytes &&
               (writeToDestination(
                 destination,
-                currentView.subarray(0, writtenBytes)
+                currentView.subarray(0, writtenBytes),
               ),
               (currentView = new Uint8Array(2048)),
               (writtenBytes = 0)),
@@ -69,12 +69,12 @@
             read < chunk.length &&
               (writeToDestination(
                 destination,
-                currentView.subarray(0, writtenBytes)
+                currentView.subarray(0, writtenBytes),
               ),
               (currentView = new Uint8Array(2048)),
               (writtenBytes = textEncoder.encodeInto(
                 chunk.slice(read),
-                currentView
+                currentView,
               ).written));
             2048 === writtenBytes &&
               (writeToDestination(destination, currentView),
@@ -87,7 +87,7 @@
             ? (0 < writtenBytes &&
                 (writeToDestination(
                   destination,
-                  currentView.subarray(0, writtenBytes)
+                  currentView.subarray(0, writtenBytes),
                 ),
                 (currentView = new Uint8Array(2048)),
                 (writtenBytes = 0)),
@@ -119,8 +119,8 @@
       destinationHasCapacity = !0;
     }
     function byteLengthOfChunk(chunk) {
-      return "string" === typeof chunk
-        ? Buffer.byteLength(chunk, "utf8")
+      return 'string' === typeof chunk
+        ? Buffer.byteLength(chunk, 'utf8')
         : chunk.byteLength;
     }
     function isClientReference(reference) {
@@ -130,7 +130,7 @@
       return Object.defineProperties(proxyImplementation, {
         $$typeof: { value: CLIENT_REFERENCE_TAG$1 },
         $$id: { value: id },
-        $$async: { value: async }
+        $$async: { value: async },
       });
     }
     function bind() {
@@ -138,7 +138,7 @@
       if (this.$$typeof === SERVER_REFERENCE_TAG) {
         null != arguments[0] &&
           console.error(
-            'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().'
+            'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().',
           );
         var args = ArraySlice.call(arguments, 1),
           $$typeof = { value: SERVER_REFERENCE_TAG },
@@ -149,95 +149,95 @@
           $$id: $$id,
           $$bound: args,
           $$location: { value: this.$$location, configurable: !0 },
-          bind: { value: bind, configurable: !0 }
+          bind: { value: bind, configurable: !0 },
         });
       }
       return newFn;
     }
     function getReference(target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "$$id":
+        case '$$id':
           return target.$$id;
-        case "$$async":
+        case '$$async':
           return target.$$async;
-        case "name":
+        case 'name':
           return target.name;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "__esModule":
+        case '__esModule':
           var moduleId = target.$$id;
           target.default = registerClientReferenceImpl(
             function () {
               throw Error(
-                "Attempted to call the default export of " +
+                'Attempted to call the default export of ' +
                   moduleId +
-                  " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+                  " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
               );
             },
-            target.$$id + "#",
-            target.$$async
+            target.$$id + '#',
+            target.$$async,
           );
           return !0;
-        case "then":
+        case 'then':
           if (target.then) return target.then;
           if (target.$$async) return;
           var clientReference = registerClientReferenceImpl(
               {},
               target.$$id,
-              !0
+              !0,
             ),
             proxy = new Proxy(clientReference, proxyHandlers$1);
-          target.status = "fulfilled";
+          target.status = 'fulfilled';
           target.value = proxy;
           return (target.then = registerClientReferenceImpl(
             function (resolve) {
               return Promise.resolve(resolve(proxy));
             },
-            target.$$id + "#then",
-            !1
+            target.$$id + '#then',
+            !1,
           ));
       }
-      if ("symbol" === typeof name)
+      if ('symbol' === typeof name)
         throw Error(
-          "Cannot read Symbol exports. Only named exports are supported on a client module imported on the server."
+          'Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.',
         );
       clientReference = target[name];
       clientReference ||
         ((clientReference = registerClientReferenceImpl(
           function () {
             throw Error(
-              "Attempted to call " +
+              'Attempted to call ' +
                 String(name) +
-                "() from the server but " +
+                '() from the server but ' +
                 String(name) +
-                " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+                " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
             );
           },
-          target.$$id + "#" + name,
-          target.$$async
+          target.$$id + '#' + name,
+          target.$$async,
         )),
-        Object.defineProperty(clientReference, "name", { value: name }),
+        Object.defineProperty(clientReference, 'name', { value: name }),
         (clientReference = target[name] =
           new Proxy(clientReference, deepProxyHandlers)));
       return clientReference;
     }
     function resolveClientReferenceMetadata(config, clientReference) {
       var modulePath = clientReference.$$id,
-        name = "",
+        name = '',
         resolvedModuleData = config[modulePath];
       if (resolvedModuleData) name = resolvedModuleData.name;
       else {
-        var idx = modulePath.lastIndexOf("#");
+        var idx = modulePath.lastIndexOf('#');
         -1 !== idx &&
           ((name = modulePath.slice(idx + 1)),
           (resolvedModuleData = config[modulePath.slice(0, idx)]));
@@ -245,55 +245,55 @@
           throw Error(
             'Could not find the module "' +
               modulePath +
-              '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.'
+              '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.',
           );
       }
       if (!0 === resolvedModuleData.async && !0 === clientReference.$$async)
         throw Error(
           'The module "' +
             modulePath +
-            '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.'
+            '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.',
         );
       return !0 === resolvedModuleData.async || !0 === clientReference.$$async
         ? [resolvedModuleData.id, resolvedModuleData.chunks, name, 1]
         : [resolvedModuleData.id, resolvedModuleData.chunks, name];
     }
     function preload(href, as, options) {
-      if ("string" === typeof href) {
+      if ('string' === typeof href) {
         var request = resolveRequest();
         if (request) {
           var hints = request.hints,
-            key = "L";
-          if ("image" === as && options) {
+            key = 'L';
+          if ('image' === as && options) {
             var imageSrcSet = options.imageSrcSet,
               imageSizes = options.imageSizes,
-              uniquePart = "";
-            "string" === typeof imageSrcSet && "" !== imageSrcSet
-              ? ((uniquePart += "[" + imageSrcSet + "]"),
-                "string" === typeof imageSizes &&
-                  (uniquePart += "[" + imageSizes + "]"))
-              : (uniquePart += "[][]" + href);
-            key += "[image]" + uniquePart;
-          } else key += "[" + as + "]" + href;
+              uniquePart = '';
+            'string' === typeof imageSrcSet && '' !== imageSrcSet
+              ? ((uniquePart += '[' + imageSrcSet + ']'),
+                'string' === typeof imageSizes &&
+                  (uniquePart += '[' + imageSizes + ']'))
+              : (uniquePart += '[][]' + href);
+            key += '[image]' + uniquePart;
+          } else key += '[' + as + ']' + href;
           hints.has(key) ||
             (hints.add(key),
             (options = trimOptions(options))
-              ? emitHint(request, "L", [href, as, options])
-              : emitHint(request, "L", [href, as]));
+              ? emitHint(request, 'L', [href, as, options])
+              : emitHint(request, 'L', [href, as]));
         } else previousDispatcher.L(href, as, options);
       }
     }
     function preloadModule$1(href, options) {
-      if ("string" === typeof href) {
+      if ('string' === typeof href) {
         var request = resolveRequest();
         if (request) {
           var hints = request.hints,
-            key = "m|" + href;
+            key = 'm|' + href;
           if (hints.has(key)) return;
           hints.add(key);
           return (options = trimOptions(options))
-            ? emitHint(request, "m", [href, options])
-            : emitHint(request, "m", href);
+            ? emitHint(request, 'm', [href, options])
+            : emitHint(request, 'm', href);
         }
         previousDispatcher.m(href, options);
       }
@@ -310,63 +310,63 @@
     }
     function getChildFormatContext(parentContext, type, props) {
       switch (type) {
-        case "img":
+        case 'img':
           type = props.src;
           var srcSet = props.srcSet;
           if (
             !(
-              "lazy" === props.loading ||
+              'lazy' === props.loading ||
               (!type && !srcSet) ||
-              ("string" !== typeof type && null != type) ||
-              ("string" !== typeof srcSet && null != srcSet) ||
-              "low" === props.fetchPriority ||
+              ('string' !== typeof type && null != type) ||
+              ('string' !== typeof srcSet && null != srcSet) ||
+              'low' === props.fetchPriority ||
               parentContext & 3
             ) &&
-            ("string" !== typeof type ||
-              ":" !== type[4] ||
-              ("d" !== type[0] && "D" !== type[0]) ||
-              ("a" !== type[1] && "A" !== type[1]) ||
-              ("t" !== type[2] && "T" !== type[2]) ||
-              ("a" !== type[3] && "A" !== type[3])) &&
-            ("string" !== typeof srcSet ||
-              ":" !== srcSet[4] ||
-              ("d" !== srcSet[0] && "D" !== srcSet[0]) ||
-              ("a" !== srcSet[1] && "A" !== srcSet[1]) ||
-              ("t" !== srcSet[2] && "T" !== srcSet[2]) ||
-              ("a" !== srcSet[3] && "A" !== srcSet[3]))
+            ('string' !== typeof type ||
+              ':' !== type[4] ||
+              ('d' !== type[0] && 'D' !== type[0]) ||
+              ('a' !== type[1] && 'A' !== type[1]) ||
+              ('t' !== type[2] && 'T' !== type[2]) ||
+              ('a' !== type[3] && 'A' !== type[3])) &&
+            ('string' !== typeof srcSet ||
+              ':' !== srcSet[4] ||
+              ('d' !== srcSet[0] && 'D' !== srcSet[0]) ||
+              ('a' !== srcSet[1] && 'A' !== srcSet[1]) ||
+              ('t' !== srcSet[2] && 'T' !== srcSet[2]) ||
+              ('a' !== srcSet[3] && 'A' !== srcSet[3]))
           ) {
-            var sizes = "string" === typeof props.sizes ? props.sizes : void 0;
+            var sizes = 'string' === typeof props.sizes ? props.sizes : void 0;
             var input = props.crossOrigin;
-            preload(type || "", "image", {
+            preload(type || '', 'image', {
               imageSrcSet: srcSet,
               imageSizes: sizes,
               crossOrigin:
-                "string" === typeof input
-                  ? "use-credentials" === input
+                'string' === typeof input
+                  ? 'use-credentials' === input
                     ? input
-                    : ""
+                    : ''
                   : void 0,
               integrity: props.integrity,
               type: props.type,
               fetchPriority: props.fetchPriority,
-              referrerPolicy: props.referrerPolicy
+              referrerPolicy: props.referrerPolicy,
             });
           }
           return parentContext;
-        case "link":
+        case 'link':
           type = props.rel;
           srcSet = props.href;
           if (
             !(
               parentContext & 1 ||
               null != props.itemProp ||
-              "string" !== typeof type ||
-              "string" !== typeof srcSet ||
-              "" === srcSet
+              'string' !== typeof type ||
+              'string' !== typeof srcSet ||
+              '' === srcSet
             )
           )
             switch (type) {
-              case "preload":
+              case 'preload':
                 preload(srcSet, props.as, {
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
@@ -376,32 +376,32 @@
                   referrerPolicy: props.referrerPolicy,
                   imageSrcSet: props.imageSrcSet,
                   imageSizes: props.imageSizes,
-                  media: props.media
+                  media: props.media,
                 });
                 break;
-              case "modulepreload":
+              case 'modulepreload':
                 preloadModule$1(srcSet, {
                   as: props.as,
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
-                  nonce: props.nonce
+                  nonce: props.nonce,
                 });
                 break;
-              case "stylesheet":
-                preload(srcSet, "stylesheet", {
+              case 'stylesheet':
+                preload(srcSet, 'stylesheet', {
                   crossOrigin: props.crossOrigin,
                   integrity: props.integrity,
                   nonce: props.nonce,
                   type: props.type,
                   fetchPriority: props.fetchPriority,
                   referrerPolicy: props.referrerPolicy,
-                  media: props.media
+                  media: props.media,
                 });
             }
           return parentContext;
-        case "picture":
+        case 'picture':
           return parentContext | 2;
-        case "noscript":
+        case 'noscript':
           return parentContext | 1;
         default:
           return parentContext;
@@ -429,51 +429,51 @@
       error = [];
       for (var i = framesToSkip; i < structuredStackTrace.length; i++) {
         var callSite = structuredStackTrace[i],
-          name = callSite.getFunctionName() || "<anonymous>";
-        if (name.includes("react_stack_bottom_frame")) break;
+          name = callSite.getFunctionName() || '<anonymous>';
+        if (name.includes('react_stack_bottom_frame')) break;
         else if (callSite.isNative())
           (callSite = callSite.isAsync()),
-            error.push([name, "", 0, 0, 0, 0, callSite]);
+            error.push([name, '', 0, 0, 0, 0, callSite]);
         else {
-          if (callSite.isConstructor()) name = "new " + name;
+          if (callSite.isConstructor()) name = 'new ' + name;
           else if (!callSite.isToplevel()) {
             var callSite$jscomp$0 = callSite;
             name = callSite$jscomp$0.getTypeName();
             var methodName = callSite$jscomp$0.getMethodName();
             callSite$jscomp$0 = callSite$jscomp$0.getFunctionName();
-            var result = "";
+            var result = '';
             callSite$jscomp$0
               ? (name &&
                   identifierRegExp.test(callSite$jscomp$0) &&
                   callSite$jscomp$0 !== name &&
-                  (result += name + "."),
+                  (result += name + '.'),
                 (result += callSite$jscomp$0),
                 !methodName ||
                   callSite$jscomp$0 === methodName ||
-                  callSite$jscomp$0.endsWith("." + methodName) ||
-                  callSite$jscomp$0.endsWith(" " + methodName) ||
-                  (result += " [as " + methodName + "]"))
-              : (name && (result += name + "."),
+                  callSite$jscomp$0.endsWith('.' + methodName) ||
+                  callSite$jscomp$0.endsWith(' ' + methodName) ||
+                  (result += ' [as ' + methodName + ']'))
+              : (name && (result += name + '.'),
                 (result = methodName
                   ? result + methodName
-                  : result + "<anonymous>"));
+                  : result + '<anonymous>'));
             name = result;
           }
-          "<anonymous>" === name && (name = "");
-          methodName = callSite.getScriptNameOrSourceURL() || "<anonymous>";
-          "<anonymous>" === methodName &&
-            ((methodName = ""),
+          '<anonymous>' === name && (name = '');
+          methodName = callSite.getScriptNameOrSourceURL() || '<anonymous>';
+          '<anonymous>' === methodName &&
+            ((methodName = ''),
             callSite.isEval() &&
               (callSite$jscomp$0 = callSite.getEvalOrigin()) &&
-              (methodName = callSite$jscomp$0.toString() + ", <anonymous>"));
+              (methodName = callSite$jscomp$0.toString() + ', <anonymous>'));
           callSite$jscomp$0 = callSite.getLineNumber() || 0;
           result = callSite.getColumnNumber() || 0;
           var enclosingLine =
-              "function" === typeof callSite.getEnclosingLineNumber
+              'function' === typeof callSite.getEnclosingLineNumber
                 ? callSite.getEnclosingLineNumber() || 0
                 : 0,
             enclosingCol =
-              "function" === typeof callSite.getEnclosingColumnNumber
+              'function' === typeof callSite.getEnclosingColumnNumber
                 ? callSite.getEnclosingColumnNumber() || 0
                 : 0;
           callSite = callSite.isAsync();
@@ -484,18 +484,18 @@
             result,
             enclosingLine,
             enclosingCol,
-            callSite
+            callSite,
           ]);
         }
       }
       collectedStackTrace = error;
-      return "";
+      return '';
     }
     function collectStackTrace(error, structuredStackTrace) {
       collectStackTracePrivate(error, structuredStackTrace);
-      error = (error.name || "Error") + ": " + (error.message || "");
+      error = (error.name || 'Error') + ': ' + (error.message || '');
       for (var i = 0; i < structuredStackTrace.length; i++)
-        error += "\n    at " + structuredStackTrace[i].toString();
+        error += '\n    at ' + structuredStackTrace[i].toString();
       return error;
     }
     function parseStackTracePrivate(error, skipFrames) {
@@ -504,7 +504,7 @@
       skipFrames = Error.prepareStackTrace;
       Error.prepareStackTrace = collectStackTracePrivate;
       try {
-        if ("" !== error.stack) return null;
+        if ('' !== error.stack) return null;
       } finally {
         Error.prepareStackTrace = skipFrames;
       }
@@ -529,23 +529,23 @@
           stackTraceCache.set(error, stack),
           stack
         );
-      stack.startsWith("Error: react-stack-top-frame\n") &&
+      stack.startsWith('Error: react-stack-top-frame\n') &&
         (stack = stack.slice(29));
-      existing = stack.indexOf("react_stack_bottom_frame");
-      -1 !== existing && (existing = stack.lastIndexOf("\n", existing));
+      existing = stack.indexOf('react_stack_bottom_frame');
+      -1 !== existing && (existing = stack.lastIndexOf('\n', existing));
       -1 !== existing && (stack = stack.slice(0, existing));
-      stack = stack.split("\n");
+      stack = stack.split('\n');
       for (existing = []; skipFrames < stack.length; skipFrames++) {
         var parsed = frameRegExp.exec(stack[skipFrames]);
         if (parsed) {
-          var name = parsed[1] || "",
-            isAsync = "async " === parsed[8];
-          "<anonymous>" === name
-            ? (name = "")
-            : name.startsWith("async ") &&
+          var name = parsed[1] || '',
+            isAsync = 'async ' === parsed[8];
+          '<anonymous>' === name
+            ? (name = '')
+            : name.startsWith('async ') &&
               ((name = name.slice(5)), (isAsync = !0));
-          var filename = parsed[2] || parsed[5] || "";
-          "<anonymous>" === filename && (filename = "");
+          var filename = parsed[2] || parsed[5] || '';
+          '<anonymous>' === filename && (filename = '');
           existing.push([
             name,
             filename,
@@ -553,7 +553,7 @@
             +(parsed[4] || parsed[7]),
             0,
             0,
-            isAsync
+            isAsync,
           ]);
         }
       }
@@ -564,10 +564,10 @@
       var reference = Object.defineProperties(
         function () {
           throw Error(
-            "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+            "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
           );
         },
-        { $$typeof: { value: TEMPORARY_REFERENCE_TAG } }
+        { $$typeof: { value: TEMPORARY_REFERENCE_TAG } },
       );
       reference = new Proxy(reference, proxyHandlers);
       temporaryReferences.set(reference, id);
@@ -581,35 +581,35 @@
           (thenableState._stacks || (thenableState._stacks = [])).push(Error()))
         : index !== thenable && (thenable.then(noop, noop), (thenable = index));
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return thenable.value;
-        case "rejected":
+        case 'rejected':
           throw thenable.reason;
         default:
-          "string" === typeof thenable.status
+          'string' === typeof thenable.status
             ? thenable.then(noop, noop)
             : ((thenableState = thenable),
-              (thenableState.status = "pending"),
+              (thenableState.status = 'pending'),
               thenableState.then(
                 function (fulfilledValue) {
-                  if ("pending" === thenable.status) {
+                  if ('pending' === thenable.status) {
                     var fulfilledThenable = thenable;
-                    fulfilledThenable.status = "fulfilled";
+                    fulfilledThenable.status = 'fulfilled';
                     fulfilledThenable.value = fulfilledValue;
                   }
                 },
                 function (error) {
-                  if ("pending" === thenable.status) {
+                  if ('pending' === thenable.status) {
                     var rejectedThenable = thenable;
-                    rejectedThenable.status = "rejected";
+                    rejectedThenable.status = 'rejected';
                     rejectedThenable.reason = error;
                   }
-                }
+                },
               ));
           switch (thenable.status) {
-            case "fulfilled":
+            case 'fulfilled':
               return thenable.value;
-            case "rejected":
+            case 'rejected':
               throw thenable.reason;
           }
           suspendedThenable = thenable;
@@ -619,7 +619,7 @@
     function getSuspendedThenable() {
       if (null === suspendedThenable)
         throw Error(
-          "Expected a suspended thenable. This is a bug in React. Please file an issue."
+          'Expected a suspended thenable. This is a bug in React. Please file an issue.',
         );
       var thenable = suspendedThenable;
       suspendedThenable = null;
@@ -632,20 +632,20 @@
       return state;
     }
     function unsupportedHook() {
-      throw Error("This Hook is not supported in Server Components.");
+      throw Error('This Hook is not supported in Server Components.');
     }
     function unsupportedRefresh() {
       throw Error(
-        "Refreshing the cache is not supported in Server Components."
+        'Refreshing the cache is not supported in Server Components.',
       );
     }
     function unsupportedContext() {
-      throw Error("Cannot read a Client Context from a Server Component.");
+      throw Error('Cannot read a Client Context from a Server Component.');
     }
     function prepareStackTrace(error, structuredStackTrace) {
-      error = (error.name || "Error") + ": " + (error.message || "");
+      error = (error.name || 'Error') + ': ' + (error.message || '');
       for (var i = 0; i < structuredStackTrace.length; i++)
-        error += "\n    at " + structuredStackTrace[i].toString();
+        error += '\n    at ' + structuredStackTrace[i].toString();
       return error;
     }
     function resetOwnerStackLimit() {
@@ -669,7 +669,7 @@
       var descriptor = Object.getOwnPropertyDescriptor(object, name);
       return void 0 === descriptor
         ? isGetter(getPrototypeOf(object), name)
-        : "function" === typeof descriptor.get;
+        : 'function' === typeof descriptor.get;
     }
     function isSimpleObject(object) {
       if (!isObjectPrototype(getPrototypeOf(object))) return !1;
@@ -682,8 +682,8 @@
         if (
           !descriptor ||
           (!descriptor.enumerable &&
-            (("key" !== names[i] && "ref" !== names[i]) ||
-              "function" !== typeof descriptor.get))
+            (('key' !== names[i] && 'ref' !== names[i]) ||
+              'function' !== typeof descriptor.get))
         )
           return !1;
       }
@@ -699,35 +699,35 @@
     }
     function describeValueForErrorMessage(value) {
       switch (typeof value) {
-        case "string":
+        case 'string':
           return JSON.stringify(
-            10 >= value.length ? value : value.slice(0, 10) + "..."
+            10 >= value.length ? value : value.slice(0, 10) + '...',
           );
-        case "object":
-          if (isArrayImpl(value)) return "[...]";
+        case 'object':
+          if (isArrayImpl(value)) return '[...]';
           if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-            return "client";
+            return 'client';
           value = objectName(value);
-          return "Object" === value ? "{...}" : value;
-        case "function":
+          return 'Object' === value ? '{...}' : value;
+        case 'function':
           return value.$$typeof === CLIENT_REFERENCE_TAG
-            ? "client"
+            ? 'client'
             : (value = value.displayName || value.name)
-              ? "function " + value
-              : "function";
+              ? 'function ' + value
+              : 'function';
         default:
           return String(value);
       }
     }
     function describeElementType(type) {
-      if ("string" === typeof type) return type;
+      if ('string' === typeof type) return type;
       switch (type) {
         case REACT_SUSPENSE_TYPE:
-          return "Suspense";
+          return 'Suspense';
         case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
+          return 'SuspenseList';
       }
-      if ("object" === typeof type)
+      if ('object' === typeof type)
         switch (type.$$typeof) {
           case REACT_FORWARD_REF_TYPE:
             return describeElementType(type.render);
@@ -740,74 +740,74 @@
               return describeElementType(type(payload));
             } catch (x) {}
         }
-      return "";
+      return '';
     }
     function describeObjectForErrorMessage(objectOrArray, expandedName) {
       var objKind = objectName(objectOrArray);
-      if ("Object" !== objKind && "Array" !== objKind) return objKind;
+      if ('Object' !== objKind && 'Array' !== objKind) return objKind;
       var start = -1,
         length = 0;
       if (isArrayImpl(objectOrArray))
         if (jsxChildrenParents.has(objectOrArray)) {
           var type = jsxChildrenParents.get(objectOrArray);
-          objKind = "<" + describeElementType(type) + ">";
+          objKind = '<' + describeElementType(type) + '>';
           for (var i = 0; i < objectOrArray.length; i++) {
             var value = objectOrArray[i];
             value =
-              "string" === typeof value
+              'string' === typeof value
                 ? value
-                : "object" === typeof value && null !== value
-                  ? "{" + describeObjectForErrorMessage(value) + "}"
-                  : "{" + describeValueForErrorMessage(value) + "}";
-            "" + i === expandedName
+                : 'object' === typeof value && null !== value
+                  ? '{' + describeObjectForErrorMessage(value) + '}'
+                  : '{' + describeValueForErrorMessage(value) + '}';
+            '' + i === expandedName
               ? ((start = objKind.length),
                 (length = value.length),
                 (objKind += value))
               : (objKind =
                   15 > value.length && 40 > objKind.length + value.length
                     ? objKind + value
-                    : objKind + "{...}");
+                    : objKind + '{...}');
           }
-          objKind += "</" + describeElementType(type) + ">";
+          objKind += '</' + describeElementType(type) + '>';
         } else {
-          objKind = "[";
+          objKind = '[';
           for (type = 0; type < objectOrArray.length; type++)
-            0 < type && (objKind += ", "),
+            0 < type && (objKind += ', '),
               (i = objectOrArray[type]),
               (i =
-                "object" === typeof i && null !== i
+                'object' === typeof i && null !== i
                   ? describeObjectForErrorMessage(i)
                   : describeValueForErrorMessage(i)),
-              "" + type === expandedName
+              '' + type === expandedName
                 ? ((start = objKind.length),
                   (length = i.length),
                   (objKind += i))
                 : (objKind =
                     10 > i.length && 40 > objKind.length + i.length
                       ? objKind + i
-                      : objKind + "...");
-          objKind += "]";
+                      : objKind + '...');
+          objKind += ']';
         }
       else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-        objKind = "<" + describeElementType(objectOrArray.type) + "/>";
+        objKind = '<' + describeElementType(objectOrArray.type) + '/>';
       else {
-        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
         if (jsxPropsParents.has(objectOrArray)) {
           objKind = jsxPropsParents.get(objectOrArray);
-          objKind = "<" + (describeElementType(objKind) || "...");
+          objKind = '<' + (describeElementType(objKind) || '...');
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++) {
-            objKind += " ";
+            objKind += ' ';
             value = type[i];
-            objKind += describeKeyForErrorMessage(value) + "=";
+            objKind += describeKeyForErrorMessage(value) + '=';
             var _value2 = objectOrArray[value];
             var _substr2 =
               value === expandedName &&
-              "object" === typeof _value2 &&
+              'object' === typeof _value2 &&
               null !== _value2
                 ? describeObjectForErrorMessage(_value2)
                 : describeValueForErrorMessage(_value2);
-            "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
+            'string' !== typeof _value2 && (_substr2 = '{' + _substr2 + '}');
             value === expandedName
               ? ((start = objKind.length),
                 (length = _substr2.length),
@@ -815,19 +815,19 @@
               : (objKind =
                   10 > _substr2.length && 40 > objKind.length + _substr2.length
                     ? objKind + _substr2
-                    : objKind + "...");
+                    : objKind + '...');
           }
-          objKind += ">";
+          objKind += '>';
         } else {
-          objKind = "{";
+          objKind = '{';
           type = Object.keys(objectOrArray);
           for (i = 0; i < type.length; i++)
-            0 < i && (objKind += ", "),
+            0 < i && (objKind += ', '),
               (value = type[i]),
-              (objKind += describeKeyForErrorMessage(value) + ": "),
+              (objKind += describeKeyForErrorMessage(value) + ': '),
               (_value2 = objectOrArray[value]),
               (_value2 =
-                "object" === typeof _value2 && null !== _value2
+                'object' === typeof _value2 && null !== _value2
                   ? describeObjectForErrorMessage(_value2)
                   : describeValueForErrorMessage(_value2)),
               value === expandedName
@@ -837,45 +837,45 @@
                 : (objKind =
                     10 > _value2.length && 40 > objKind.length + _value2.length
                       ? objKind + _value2
-                      : objKind + "...");
-          objKind += "}";
+                      : objKind + '...');
+          objKind += '}';
         }
       }
       return void 0 === expandedName
         ? objKind
         : -1 < start && 0 < length
-          ? ((objectOrArray = " ".repeat(start) + "^".repeat(length)),
-            "\n  " + objKind + "\n  " + objectOrArray)
-          : "\n  " + objKind;
+          ? ((objectOrArray = ' '.repeat(start) + '^'.repeat(length)),
+            '\n  ' + objKind + '\n  ' + objectOrArray)
+          : '\n  ' + objKind;
     }
     function defaultFilterStackFrame(filename) {
       return (
-        "" !== filename &&
-        !filename.startsWith("node:") &&
-        !filename.includes("node_modules")
+        '' !== filename &&
+        !filename.startsWith('node:') &&
+        !filename.includes('node_modules')
       );
     }
     function devirtualizeURL(url) {
-      if (url.startsWith("about://React/")) {
-        var envIdx = url.indexOf("/", 14),
-          suffixIdx = url.lastIndexOf("?");
+      if (url.startsWith('about://React/')) {
+        var envIdx = url.indexOf('/', 14),
+          suffixIdx = url.lastIndexOf('?');
         if (-1 < envIdx && -1 < suffixIdx)
           return decodeURI(url.slice(envIdx + 1, suffixIdx));
       }
       return url;
     }
     function isPromiseCreationInternal(url, functionName) {
-      if ("node:internal/async_hooks" === url) return !0;
-      if ("" !== url) return !1;
+      if ('node:internal/async_hooks' === url) return !0;
+      if ('' !== url) return !1;
       switch (functionName) {
-        case "new Promise":
-        case "Function.withResolvers":
-        case "Function.reject":
-        case "Function.resolve":
-        case "Function.all":
-        case "Function.allSettled":
-        case "Function.race":
-        case "Function.try":
+        case 'new Promise':
+        case 'Function.withResolvers':
+        case 'Function.reject':
+        case 'Function.resolve':
+        case 'Function.all':
+        case 'Function.allSettled':
+        case 'Function.race':
+        case 'Function.try':
           return !0;
         default:
           return !1;
@@ -911,18 +911,18 @@
       return !1;
     }
     function isPromiseAwaitInternal(url, functionName) {
-      if ("node:internal/async_hooks" === url) return !0;
-      if ("" !== url) return !1;
+      if ('node:internal/async_hooks' === url) return !0;
+      if ('' !== url) return !1;
       switch (functionName) {
-        case "Promise.then":
-        case "Promise.catch":
-        case "Promise.finally":
-        case "Function.reject":
-        case "Function.resolve":
-        case "Function.all":
-        case "Function.allSettled":
-        case "Function.race":
-        case "Function.try":
+        case 'Promise.then':
+        case 'Promise.catch':
+        case 'Promise.finally':
+        case 'Function.reject':
+        case 'Function.resolve':
+        case 'Function.all':
+        case 'Function.allSettled':
+        case 'Function.race':
+        case 'Function.try':
           return !0;
         default:
           return !1;
@@ -950,16 +950,16 @@
       if (
         descriptor &&
         (descriptor.configurable || descriptor.writable) &&
-        "function" === typeof descriptor.value
+        'function' === typeof descriptor.value
       ) {
         var originalMethod = descriptor.value;
-        descriptor = Object.getOwnPropertyDescriptor(originalMethod, "name");
+        descriptor = Object.getOwnPropertyDescriptor(originalMethod, 'name');
         var wrapperMethod = function () {
           var request = resolveRequest();
-          if (("assert" !== methodName || !arguments[0]) && null !== request) {
+          if (('assert' !== methodName || !arguments[0]) && null !== request) {
             var stack = filterStackTrace(
               request,
-              parseStackTracePrivate(Error("react-stack-top-frame"), 1) || []
+              parseStackTracePrivate(Error('react-stack-top-frame'), 1) || [],
             );
             request.pendingDebugChunks++;
             var owner = resolveOwner(),
@@ -967,25 +967,25 @@
             a: {
               var env = 0;
               switch (methodName) {
-                case "dir":
-                case "dirxml":
-                case "groupEnd":
-                case "table":
+                case 'dir':
+                case 'dirxml':
+                case 'groupEnd':
+                case 'table':
                   env = null;
                   break a;
-                case "assert":
+                case 'assert':
                   env = 1;
               }
               var format = args[env],
                 style = args[env + 1],
                 badge = args[env + 2];
-              "string" === typeof format &&
-              format.startsWith("\u001b[0m\u001b[7m%c%s\u001b[0m%c") &&
-              "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px" ===
+              'string' === typeof format &&
+              format.startsWith('\u001b[0m\u001b[7m%c%s\u001b[0m%c') &&
+              'background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px' ===
                 style &&
-              "string" === typeof badge
+              'string' === typeof badge
                 ? ((format = format.slice(18)),
-                  " " === format[0] && (format = format.slice(1)),
+                  ' ' === format[0] && (format = format.slice(1)),
                   args.splice(env, 4, format),
                   (env = badge.slice(1, badge.length - 1)))
                 : (env = null);
@@ -997,32 +997,32 @@
             args = serializeDebugModel(
               request,
               (null === request.deferredDebugObjects ? 500 : 10) + stack.length,
-              badge
+              badge,
             );
-            "[" !== args[0] &&
+            '[' !== args[0] &&
               (args = serializeDebugModel(request, 10 + stack.length, [
                 methodName,
                 stack,
                 owner,
                 env,
-                "Unknown Value: React could not send it from the server."
+                'Unknown Value: React could not send it from the server.',
               ]));
-            request.completedDebugChunks.push(":W" + args + "\n");
+            request.completedDebugChunks.push(':W' + args + '\n');
           }
           return originalMethod.apply(this, arguments);
         };
-        descriptor && Object.defineProperty(wrapperMethod, "name", descriptor);
+        descriptor && Object.defineProperty(wrapperMethod, 'name', descriptor);
         Object.defineProperty(consoleInst, methodName, {
-          value: wrapperMethod
+          value: wrapperMethod,
         });
       }
     }
     function getCurrentStackInDEV() {
       var owner = resolveOwner();
-      if (null === owner) return "";
+      if (null === owner) return '';
       try {
-        var info = "";
-        if (owner.owner || "string" !== typeof owner.name) {
+        var info = '';
+        if (owner.owner || 'string' !== typeof owner.name) {
           for (; owner; ) {
             var ownerStack = owner.debugStack;
             if (null != ownerStack) {
@@ -1033,16 +1033,16 @@
                 Error.prepareStackTrace = prepareStackTrace;
                 var stack = error.stack;
                 Error.prepareStackTrace = prevPrepareStackTrace;
-                stack.startsWith("Error: react-stack-top-frame\n") &&
+                stack.startsWith('Error: react-stack-top-frame\n') &&
                   (stack = stack.slice(29));
-                var idx = stack.indexOf("\n");
+                var idx = stack.indexOf('\n');
                 -1 !== idx && (stack = stack.slice(idx + 1));
-                idx = stack.indexOf("react_stack_bottom_frame");
-                -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
+                idx = stack.indexOf('react_stack_bottom_frame');
+                -1 !== idx && (idx = stack.lastIndexOf('\n', idx));
                 var JSCompiler_inline_result =
-                  -1 !== idx ? (stack = stack.slice(0, idx)) : "";
+                  -1 !== idx ? (stack = stack.slice(0, idx)) : '';
                 info =
-                  JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
+                  JSCompiler_temp_const + ('\n' + JSCompiler_inline_result);
               }
             } else break;
           }
@@ -1055,20 +1055,20 @@
             } catch (x) {
               (prefix =
                 ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) ||
-                ""),
+                ''),
                 (suffix =
-                  -1 < x.stack.indexOf("\n    at")
-                    ? " (<anonymous>)"
-                    : -1 < x.stack.indexOf("@")
-                      ? "@unknown:0:0"
-                      : "");
+                  -1 < x.stack.indexOf('\n    at')
+                    ? ' (<anonymous>)'
+                    : -1 < x.stack.indexOf('@')
+                      ? '@unknown:0:0'
+                      : '');
             }
           JSCompiler_inline_result$jscomp$0 =
-            "\n" + prefix + JSCompiler_temp_const + suffix;
+            '\n' + prefix + JSCompiler_temp_const + suffix;
         }
       } catch (x) {
         JSCompiler_inline_result$jscomp$0 =
-          "\nError generating stack: " + x.message + "\n" + x.stack;
+          '\nError generating stack: ' + x.message + '\n' + x.stack;
       }
       return JSCompiler_inline_result$jscomp$0;
     }
@@ -1087,14 +1087,14 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       if (
         null !== ReactSharedInternalsServer.A &&
         ReactSharedInternalsServer.A !== DefaultAsyncDispatcher
       )
         throw Error(
-          "Currently React only supports one RSC renderer at a time."
+          'Currently React only supports one RSC renderer at a time.',
         );
       ReactSharedInternalsServer.A = DefaultAsyncDispatcher;
       ReactSharedInternalsServer.getCurrentStack = getCurrentStackInDEV;
@@ -1121,7 +1121,7 @@
       this.writtenServerReferences = new Map();
       this.writtenObjects = new WeakMap();
       this.temporaryReferences = temporaryReferences;
-      this.identifierPrefix = identifierPrefix || "";
+      this.identifierPrefix = identifierPrefix || '';
       this.identifierCount = 1;
       this.taintCleanupQueue = [];
       this.onError = void 0 === onError ? defaultErrorHandler : onError;
@@ -1135,9 +1135,9 @@
       this.environmentName =
         void 0 === environmentName
           ? function () {
-              return "Server";
+              return 'Server';
             }
-          : "function" !== typeof environmentName
+          : 'function' !== typeof environmentName
             ? function () {
                 return environmentName;
               }
@@ -1164,7 +1164,7 @@
         type,
         null,
         null,
-        null
+        null,
       );
       pingedTasks.push(model);
     }
@@ -1177,7 +1177,7 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       resetOwnerStackLimit();
       return new RequestInstance(
@@ -1192,7 +1192,7 @@
         temporaryReferences,
         environmentName,
         filterStackFrame,
-        keepDebugAlive
+        keepDebugAlive,
       );
     }
     function createPrerenderRequest(
@@ -1206,7 +1206,7 @@
       temporaryReferences,
       environmentName,
       filterStackFrame,
-      keepDebugAlive
+      keepDebugAlive,
     ) {
       resetOwnerStackLimit();
       return new RequestInstance(
@@ -1221,7 +1221,7 @@
         temporaryReferences,
         environmentName,
         filterStackFrame,
-        keepDebugAlive
+        keepDebugAlive,
       );
     }
     function resolveRequest() {
@@ -1232,17 +1232,17 @@
     function serializeDebugThenable(request, counter, thenable) {
       request.pendingDebugChunks++;
       var id = request.nextChunkId++,
-        ref = "$@" + id.toString(16);
+        ref = '$@' + id.toString(16);
       request.writtenDebugObjects.set(thenable, ref);
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             emitOutlinedDebugModelChunk(request, id, counter, thenable.value),
             ref
           );
-        case "rejected":
+        case 'rejected':
           return (
-            emitErrorChunk(request, id, "", thenable.reason, !0, null), ref
+            emitErrorChunk(request, id, '', thenable.reason, !0, null), ref
           );
       }
       if (request.status === ABORTING)
@@ -1251,7 +1251,7 @@
       if (null !== deferredDebugObjects)
         return (
           deferredDebugObjects.retained.set(id, thenable),
-          (ref = "$Y@" + id.toString(16)),
+          (ref = '$Y@' + id.toString(16)),
           request.writtenDebugObjects.set(thenable, ref),
           ref
         );
@@ -1270,9 +1270,9 @@
             ((cancelled = !0),
             request.status === ABORTING
               ? emitDebugHaltChunk(request, id)
-              : emitErrorChunk(request, id, "", reason, !0, null),
+              : emitErrorChunk(request, id, '', reason, !0, null),
             enqueueFlush(request));
-        }
+        },
       );
       Promise.resolve().then(function () {
         cancelled ||
@@ -1294,9 +1294,9 @@
         function (reason) {
           request.status === ABORTING
             ? emitDebugHaltChunk(request, id)
-            : emitErrorChunk(request, id, "", reason, !0, null);
+            : emitErrorChunk(request, id, '', reason, !0, null);
           enqueueFlush(request);
-        }
+        },
       );
     }
     function serializeThenable(request, task, thenable) {
@@ -1310,30 +1310,30 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             forwardDebugInfoFromThenable(
               request,
               newTask,
               thenable,
               null,
-              null
+              null,
             ),
             (newTask.model = thenable.value),
             pingTask(request, newTask),
             newTask.id
           );
-        case "rejected":
+        case 'rejected':
           return (
             forwardDebugInfoFromThenable(
               request,
               newTask,
               thenable,
               null,
-              null
+              null,
             ),
             erroredTask(request, newTask, thenable.reason),
             newTask.id
@@ -1349,18 +1349,18 @@
                   finishAbortedTask(newTask, request, task)),
               newTask.id
             );
-          "string" !== typeof thenable.status &&
-            ((thenable.status = "pending"),
+          'string' !== typeof thenable.status &&
+            ((thenable.status = 'pending'),
             thenable.then(
               function (fulfilledValue) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "fulfilled"),
+                'pending' === thenable.status &&
+                  ((thenable.status = 'fulfilled'),
                   (thenable.value = fulfilledValue));
               },
               function (error) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "rejected"), (thenable.reason = error));
-              }
+                'pending' === thenable.status &&
+                  ((thenable.status = 'rejected'), (thenable.reason = error));
+              },
             ));
       }
       thenable.then(
@@ -1374,7 +1374,7 @@
             ((newTask.timed = !0),
             erroredTask(request, newTask, reason),
             enqueueFlush(request));
-        }
+        },
       );
       return newTask.id;
     }
@@ -1383,12 +1383,12 @@
         if (0 === streamTask.status)
           if (entry.done)
             (streamTask.status = 1),
-              (entry = streamTask.id.toString(16) + ":C\n"),
+              (entry = streamTask.id.toString(16) + ':C\n'),
               request.completedRegularChunks.push(entry),
               request.abortableTasks.delete(streamTask),
               request.cacheController.signal.removeEventListener(
-                "abort",
-                abortStream
+                'abort',
+                abortStream,
               ),
               enqueueFlush(request),
               callOnAllReadyIfReady(request);
@@ -1406,8 +1406,8 @@
       function error(reason) {
         0 === streamTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortStream
+            'abort',
+            abortStream,
           ),
           erroredTask(request, streamTask, reason),
           enqueueFlush(request),
@@ -1416,7 +1416,7 @@
       function abortStream() {
         if (0 === streamTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortStream);
+          signal.removeEventListener('abort', abortStream);
           signal = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(streamTask),
@@ -1429,7 +1429,7 @@
       var supportsBYOB = stream.supportsBYOB;
       if (void 0 === supportsBYOB)
         try {
-          stream.getReader({ mode: "byob" }).releaseLock(), (supportsBYOB = !0);
+          stream.getReader({ mode: 'byob' }).releaseLock(), (supportsBYOB = !0);
         } catch (x) {
           supportsBYOB = !1;
         }
@@ -1444,13 +1444,13 @@
           task.time,
           task.debugOwner,
           task.debugStack,
-          task.debugTask
+          task.debugTask,
         );
       request.pendingChunks++;
       task =
-        streamTask.id.toString(16) + ":" + (supportsBYOB ? "r" : "R") + "\n";
+        streamTask.id.toString(16) + ':' + (supportsBYOB ? 'r' : 'R') + '\n';
       request.completedRegularChunks.push(task);
-      request.cacheController.signal.addEventListener("abort", abortStream);
+      request.cacheController.signal.addEventListener('abort', abortStream);
       reader.read().then(progress, error);
       return serializeByValueID(streamTask.id);
     }
@@ -1460,15 +1460,15 @@
           if (entry.done) {
             streamTask.status = 1;
             if (void 0 === entry.value)
-              var endStreamRow = streamTask.id.toString(16) + ":C\n";
+              var endStreamRow = streamTask.id.toString(16) + ':C\n';
             else
               try {
                 var chunkId = outlineModel(request, entry.value);
                 endStreamRow =
                   streamTask.id.toString(16) +
-                  ":C" +
+                  ':C' +
                   stringify(serializeByValueID(chunkId)) +
-                  "\n";
+                  '\n';
               } catch (x) {
                 error(x);
                 return;
@@ -1476,8 +1476,8 @@
             request.completedRegularChunks.push(endStreamRow);
             request.abortableTasks.delete(streamTask);
             request.cacheController.signal.removeEventListener(
-              "abort",
-              abortIterable
+              'abort',
+              abortIterable,
             );
             enqueueFlush(request);
             callOnAllReadyIfReady(request);
@@ -1495,18 +1495,18 @@
       function error(reason) {
         0 === streamTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortIterable
+            'abort',
+            abortIterable,
           ),
           erroredTask(request, streamTask, reason),
           enqueueFlush(request),
-          "function" === typeof iterator.throw &&
+          'function' === typeof iterator.throw &&
             iterator.throw(reason).then(error, error));
       }
       function abortIterable() {
         if (0 === streamTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortIterable);
+          signal.removeEventListener('abort', abortIterable);
           var reason = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(streamTask),
@@ -1514,7 +1514,7 @@
               finishHaltedTask(streamTask, request))
             : (erroredTask(request, streamTask, signal.reason),
               enqueueFlush(request));
-          "function" === typeof iterator.throw &&
+          'function' === typeof iterator.throw &&
             iterator.throw(reason).then(error, error);
         }
       }
@@ -1529,67 +1529,67 @@
           task.time,
           task.debugOwner,
           task.debugStack,
-          task.debugTask
+          task.debugTask,
         );
       (task = iterable._debugInfo) &&
         forwardDebugInfo(request, streamTask, task);
       request.pendingChunks++;
       isIterator =
-        streamTask.id.toString(16) + ":" + (isIterator ? "x" : "X") + "\n";
+        streamTask.id.toString(16) + ':' + (isIterator ? 'x' : 'X') + '\n';
       request.completedRegularChunks.push(isIterator);
-      request.cacheController.signal.addEventListener("abort", abortIterable);
+      request.cacheController.signal.addEventListener('abort', abortIterable);
       callIteratorInDEV(iterator, progress, error);
       return serializeByValueID(streamTask.id);
     }
     function emitHint(request, code, model) {
       model = stringify(model);
-      request.completedHintChunks.push(":H" + code + model + "\n");
+      request.completedHintChunks.push(':H' + code + model + '\n');
       enqueueFlush(request);
     }
     function readThenable(thenable) {
-      if ("fulfilled" === thenable.status) return thenable.value;
-      if ("rejected" === thenable.status) throw thenable.reason;
+      if ('fulfilled' === thenable.status) return thenable.value;
+      if ('rejected' === thenable.status) throw thenable.reason;
       throw thenable;
     }
     function createLazyWrapperAroundWakeable(request, task, wakeable) {
       switch (wakeable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return (
             forwardDebugInfoFromThenable(request, task, wakeable, null, null),
             wakeable.value
           );
-        case "rejected":
+        case 'rejected':
           forwardDebugInfoFromThenable(request, task, wakeable, null, null);
           break;
         default:
-          "string" !== typeof wakeable.status &&
-            ((wakeable.status = "pending"),
+          'string' !== typeof wakeable.status &&
+            ((wakeable.status = 'pending'),
             wakeable.then(
               function (fulfilledValue) {
                 forwardDebugInfoFromCurrentContext(request, task, wakeable);
-                "pending" === wakeable.status &&
-                  ((wakeable.status = "fulfilled"),
+                'pending' === wakeable.status &&
+                  ((wakeable.status = 'fulfilled'),
                   (wakeable.value = fulfilledValue));
               },
               function (error) {
                 forwardDebugInfoFromCurrentContext(request, task, wakeable);
-                "pending" === wakeable.status &&
-                  ((wakeable.status = "rejected"), (wakeable.reason = error));
-              }
+                'pending' === wakeable.status &&
+                  ((wakeable.status = 'rejected'), (wakeable.reason = error));
+              },
             ));
       }
       return {
         $$typeof: REACT_LAZY_TYPE,
         _payload: wakeable,
-        _init: readThenable
+        _init: readThenable,
       };
     }
     function callWithDebugContextInDEV(request, task, callback, arg) {
       var componentDebugInfo = {
-        name: "",
+        name: '',
         env: task.environmentName,
         key: null,
-        owner: task.debugOwner
+        owner: task.debugOwner,
       };
       componentDebugInfo.stack =
         null === task.debugStack
@@ -1608,18 +1608,18 @@
       request,
       task,
       Component,
-      result
+      result,
     ) {
       if (
-        "object" !== typeof result ||
+        'object' !== typeof result ||
         null === result ||
         isClientReference(result)
       )
         return result;
-      if ("function" === typeof result.then)
+      if ('function' === typeof result.then)
         return (
           result.then(function (resolvedValue) {
-            "object" === typeof resolvedValue &&
+            'object' === typeof resolvedValue &&
               null !== resolvedValue &&
               resolvedValue.$$typeof === REACT_ELEMENT_TYPE &&
               (resolvedValue._store.validated = 1);
@@ -1632,13 +1632,13 @@
         var multiShot = _defineProperty({}, Symbol.iterator, function () {
           var iterator = iteratorFn.call(result);
           iterator !== result ||
-            ("[object GeneratorFunction]" ===
+            ('[object GeneratorFunction]' ===
               Object.prototype.toString.call(Component) &&
-              "[object Generator]" ===
+              '[object Generator]' ===
                 Object.prototype.toString.call(result)) ||
             callWithDebugContextInDEV(request, task, function () {
               console.error(
-                "Returning an Iterator from a Server Component is not supported since it cannot be looped over more than once. "
+                'Returning an Iterator from a Server Component is not supported since it cannot be looped over more than once. ',
               );
             });
           return iterator;
@@ -1646,20 +1646,20 @@
         multiShot._debugInfo = result._debugInfo;
         return multiShot;
       }
-      return "function" !== typeof result[ASYNC_ITERATOR] ||
-        ("function" === typeof ReadableStream &&
+      return 'function' !== typeof result[ASYNC_ITERATOR] ||
+        ('function' === typeof ReadableStream &&
           result instanceof ReadableStream)
         ? result
         : ((multiShot = _defineProperty({}, ASYNC_ITERATOR, function () {
             var iterator = result[ASYNC_ITERATOR]();
             iterator !== result ||
-              ("[object AsyncGeneratorFunction]" ===
+              ('[object AsyncGeneratorFunction]' ===
                 Object.prototype.toString.call(Component) &&
-                "[object AsyncGenerator]" ===
+                '[object AsyncGenerator]' ===
                   Object.prototype.toString.call(result)) ||
               callWithDebugContextInDEV(request, task, function () {
                 console.error(
-                  "Returning an AsyncIterator from a Server Component is not supported since it cannot be looped over more than once. "
+                  'Returning an AsyncIterator from a Server Component is not supported since it cannot be looped over more than once. ',
                 );
               });
             return iterator;
@@ -1673,7 +1673,7 @@
       key,
       Component,
       props,
-      validated
+      validated,
     ) {
       var prevThenableState = task.thenableState;
       task.thenableState = null;
@@ -1682,14 +1682,14 @@
           var componentDebugInfo = prevThenableState._componentDebugInfo;
         else {
           var componentDebugID = task.id;
-          componentDebugInfo = Component.displayName || Component.name || "";
+          componentDebugInfo = Component.displayName || Component.name || '';
           var componentEnv = (0, request.environmentName)();
           request.pendingChunks++;
           componentDebugInfo = {
             name: componentDebugInfo,
             env: componentEnv,
             key: key,
-            owner: task.debugOwner
+            owner: task.debugOwner,
           };
           componentDebugInfo.stack =
             null === task.debugStack
@@ -1717,21 +1717,21 @@
               callComponentInDEV,
               Component,
               props,
-              componentDebugInfo
-            )
+              componentDebugInfo,
+            ),
           )
         : componentStorage.run(
             componentDebugInfo,
             callComponentInDEV,
             Component,
             props,
-            componentDebugInfo
+            componentDebugInfo,
           );
       if (request.status === ABORTING)
         throw (
-          ("object" !== typeof props ||
+          ('object' !== typeof props ||
             null === props ||
-            "function" !== typeof props.then ||
+            'function' !== typeof props.then ||
             isClientReference(props) ||
             props.then(voidHandler, voidHandler),
           null)
@@ -1749,13 +1749,13 @@
             task,
             validated[componentDebugID],
             componentDebugInfo,
-            prevThenableState[componentDebugID]
+            prevThenableState[componentDebugID],
           );
       props = processServerComponentReturnValue(
         request,
         task,
         Component,
-        props
+        props,
       );
       task.debugOwner = componentDebugInfo;
       task.debugStack = null;
@@ -1763,9 +1763,9 @@
       Component = task.keyPath;
       componentDebugInfo = task.implicitSlot;
       null !== key
-        ? (task.keyPath = null === Component ? key : Component + "," + key)
+        ? (task.keyPath = null === Component ? key : Component + ',' + key)
         : null === Component && (task.implicitSlot = !0);
-      request = renderModelDestructive(request, task, emptyRoot, "", props);
+      request = renderModelDestructive(request, task, emptyRoot, '', props);
       task.keyPath = Component;
       task.implicitSlot = componentDebugInfo;
       return request;
@@ -1774,8 +1774,8 @@
       function logKeyError() {
         console.error(
           'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
-          "",
-          ""
+          '',
+          '',
         );
       }
       key = request.didWarnForKey;
@@ -1793,22 +1793,22 @@
               callComponentInDEV,
               logKeyError,
               null,
-              componentDebugInfo
-            )
+              componentDebugInfo,
+            ),
           )
         : componentStorage.run(
             componentDebugInfo,
             callComponentInDEV,
             logKeyError,
             null,
-            componentDebugInfo
+            componentDebugInfo,
           );
     }
     function renderFragment(request, task, children) {
       for (var i = 0; i < children.length; i++) {
         var child = children[i];
         null === child ||
-          "object" !== typeof child ||
+          'object' !== typeof child ||
           child.$$typeof !== REACT_ELEMENT_TYPE ||
           null !== child.key ||
           child._store.validated ||
@@ -1823,7 +1823,7 @@
             { children: children },
             null,
             null,
-            0
+            0,
           ]),
           task.implicitSlot ? [request] : request
         );
@@ -1844,7 +1844,7 @@
             { children: children },
             null,
             null,
-            0
+            0,
           ]),
           task.implicitSlot ? [request] : request
         );
@@ -1862,7 +1862,7 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       pingTask(request, task);
       return serializeLazyID(task.id);
@@ -1878,7 +1878,7 @@
         task.time,
         task.debugOwner,
         task.debugStack,
-        task.debugTask
+        task.debugTask,
       );
       retryTask(request, task);
       return 1 === task.status
@@ -1888,14 +1888,14 @@
     function renderElement(request, task, type, key, ref, props, validated) {
       if (null !== ref && void 0 !== ref)
         throw Error(
-          "Refs cannot be used in Server Components, nor passed to Client Components."
+          'Refs cannot be used in Server Components, nor passed to Client Components.',
         );
       jsxPropsParents.set(props, type);
-      "object" === typeof props.children &&
+      'object' === typeof props.children &&
         null !== props.children &&
         jsxChildrenParents.set(props.children, type);
       if (
-        "function" !== typeof type ||
+        'function' !== typeof type ||
         isClientReference(type) ||
         type.$$typeof === TEMPORARY_REFERENCE_TAG
       ) {
@@ -1903,7 +1903,7 @@
           return (
             2 === validated &&
               ((validated = {
-                name: "Fragment",
+                name: 'Fragment',
                 env: (0, request.environmentName)(),
                 key: key,
                 owner: task.debugOwner,
@@ -1912,11 +1912,11 @@
                     ? null
                     : filterStackTrace(
                         request,
-                        parseStackTrace(task.debugStack, 1)
+                        parseStackTrace(task.debugStack, 1),
                       ),
                 props: props,
                 debugStack: task.debugStack,
-                debugTask: task.debugTask
+                debugTask: task.debugTask,
               }),
               warnForMissingKey(request, key, validated, task.debugTask)),
             (validated = task.implicitSlot),
@@ -1925,15 +1925,15 @@
               request,
               task,
               emptyRoot,
-              "",
-              props.children
+              '',
+              props.children,
             )),
             (task.implicitSlot = validated),
             request
           );
         if (
           null != type &&
-          "object" === typeof type &&
+          'object' === typeof type &&
           !isClientReference(type)
         )
           switch (type.$$typeof) {
@@ -1947,7 +1947,7 @@
                 key,
                 ref,
                 props,
-                validated
+                validated,
               );
             case REACT_FORWARD_REF_TYPE:
               return renderFunctionComponent(
@@ -1956,7 +1956,7 @@
                 key,
                 type.render,
                 props,
-                validated
+                validated,
               );
             case REACT_MEMO_TYPE:
               return renderElement(
@@ -1966,12 +1966,12 @@
                 key,
                 ref,
                 props,
-                validated
+                validated,
               );
             case REACT_ELEMENT_TYPE:
               type._store.validated = 1;
           }
-        else if ("string" === typeof type) {
+        else if ('string' === typeof type) {
           ref = task.formatContext;
           var newFormatContext = getChildFormatContext(ref, type, props);
           ref !== newFormatContext &&
@@ -1979,7 +1979,7 @@
             outlineModelWithFormatContext(
               request,
               props.children,
-              newFormatContext
+              newFormatContext,
             );
         }
       } else
@@ -1989,22 +1989,22 @@
           key,
           type,
           props,
-          validated
+          validated,
         );
       ref = task.keyPath;
-      null === key ? (key = ref) : null !== ref && (key = ref + "," + key);
+      null === key ? (key = ref) : null !== ref && (key = ref + ',' + key);
       newFormatContext = null;
       ref = task.debugOwner;
       null !== ref && outlineComponentInfo(request, ref);
       if (null !== task.debugStack) {
         newFormatContext = filterStackTrace(
           request,
-          parseStackTrace(task.debugStack, 1)
+          parseStackTrace(task.debugStack, 1),
         );
         var id = outlineDebugModel(
           request,
           { objectLimit: 2 * newFormatContext.length + 1 },
-          newFormatContext
+          newFormatContext,
         );
         request.writtenObjects.set(newFormatContext, serializeByValueID(id));
       }
@@ -2015,7 +2015,7 @@
         props,
         ref,
         newFormatContext,
-        validated
+        validated,
       ];
       task = task.implicitSlot && null !== key ? [request] : request;
       return task;
@@ -2032,7 +2032,7 @@
           task,
           node.previous,
           visited,
-          cutOff
+          cutOff,
         )),
         void 0 === previousIONode)
       )
@@ -2080,7 +2080,7 @@
               task,
               awaited,
               visited,
-              cutOff
+              cutOff,
             );
             if (void 0 === _ioNode) break;
             if (null !== _ioNode) {
@@ -2112,7 +2112,7 @@
                       stack:
                         null === node.stack
                           ? null
-                          : filterStackTrace(request, node.stack)
+                          : filterStackTrace(request, node.stack),
                     }),
                     markOperationEndTime(request, task, endTime),
                     request.status === ABORTING && (previousIONode = void 0))
@@ -2127,7 +2127,7 @@
               (visited.add(node), forwardDebugInfo(request, task, node)));
           return previousIONode;
         default:
-          throw Error("Unknown AsyncSequence tag. This is a bug in React.");
+          throw Error('Unknown AsyncSequence tag. This is a bug in React.');
       }
     }
     function emitAsyncSequence(
@@ -2136,7 +2136,7 @@
       node,
       alreadyForwardedDebugInfo,
       owner,
-      stack
+      stack,
     ) {
       var visited = new Set();
       alreadyForwardedDebugInfo && visited.add(alreadyForwardedDebugInfo);
@@ -2148,7 +2148,7 @@
         (alreadyForwardedDebugInfo = (0, request.environmentName)()),
         (alreadyForwardedDebugInfo = {
           awaited: node,
-          env: alreadyForwardedDebugInfo
+          env: alreadyForwardedDebugInfo,
         }),
         null === owner && null === stack
           ? (null !== task.debugOwner &&
@@ -2156,13 +2156,13 @@
             null !== task.debugStack &&
               (alreadyForwardedDebugInfo.stack = filterStackTrace(
                 request,
-                parseStackTrace(task.debugStack, 1)
+                parseStackTrace(task.debugStack, 1),
               )))
           : (null != owner && (alreadyForwardedDebugInfo.owner = owner),
             null != stack &&
               (alreadyForwardedDebugInfo.stack = filterStackTrace(
                 request,
-                parseStackTrace(stack, 1)
+                parseStackTrace(stack, 1),
               ))),
         advanceTaskTime(request, task, task.time),
         emitDebugChunk(request, task.id, alreadyForwardedDebugInfo),
@@ -2192,11 +2192,11 @@
       lastTimestamp,
       debugOwner,
       debugStack,
-      debugTask
+      debugTask,
     ) {
       request.pendingChunks++;
       var id = request.nextChunkId++;
-      "object" !== typeof model ||
+      'object' !== typeof model ||
         null === model ||
         null !== keyPath ||
         implicitSlot ||
@@ -2214,31 +2214,31 @@
         toJSON: function (parentPropertyName, value) {
           var parent = this,
             originalValue = parent[parentPropertyName];
-          "object" !== typeof originalValue ||
+          'object' !== typeof originalValue ||
             originalValue === value ||
             originalValue instanceof Date ||
             callWithDebugContextInDEV(request, task, function () {
-              "Object" !== objectName(originalValue)
-                ? "string" === typeof jsxChildrenParents.get(parent)
+              'Object' !== objectName(originalValue)
+                ? 'string' === typeof jsxChildrenParents.get(parent)
                   ? console.error(
-                      "%s objects cannot be rendered as text children. Try formatting it using toString().%s",
+                      '%s objects cannot be rendered as text children. Try formatting it using toString().%s',
                       objectName(originalValue),
-                      describeObjectForErrorMessage(parent, parentPropertyName)
+                      describeObjectForErrorMessage(parent, parentPropertyName),
                     )
                   : console.error(
-                      "Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s",
+                      'Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s',
                       objectName(originalValue),
-                      describeObjectForErrorMessage(parent, parentPropertyName)
+                      describeObjectForErrorMessage(parent, parentPropertyName),
                     )
                 : console.error(
-                    "Only plain objects can be passed to Client Components from Server Components. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s",
-                    describeObjectForErrorMessage(parent, parentPropertyName)
+                    'Only plain objects can be passed to Client Components from Server Components. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s',
+                    describeObjectForErrorMessage(parent, parentPropertyName),
                   );
             });
           return renderModel(request, task, parent, parentPropertyName, value);
         },
         thenableState: null,
-        timed: !1
+        timed: !1,
       };
       task.time = lastTimestamp;
       task.environmentName = request.environmentName();
@@ -2249,10 +2249,10 @@
       return task;
     }
     function serializeByValueID(id) {
-      return "$" + id.toString(16);
+      return '$' + id.toString(16);
     }
     function serializeLazyID(id) {
-      return "$L" + id.toString(16);
+      return '$L' + id.toString(16);
     }
     function serializeDeferredObject(request, value) {
       var deferredDebugObjects = request.deferredDebugObjects;
@@ -2261,49 +2261,49 @@
           (request = request.nextChunkId++),
           deferredDebugObjects.existing.set(value, request),
           deferredDebugObjects.retained.set(request, value),
-          "$Y" + request.toString(16))
-        : "$Y";
+          '$Y' + request.toString(16))
+        : '$Y';
     }
     function serializeNumber(number) {
       return Number.isFinite(number)
         ? 0 === number && -Infinity === 1 / number
-          ? "$-0"
+          ? '$-0'
           : number
         : Infinity === number
-          ? "$Infinity"
+          ? '$Infinity'
           : -Infinity === number
-            ? "$-Infinity"
-            : "$NaN";
+            ? '$-Infinity'
+            : '$NaN';
     }
     function encodeReferenceChunk(request, id, reference) {
       request = stringify(reference);
-      return id.toString(16) + ":" + request + "\n";
+      return id.toString(16) + ':' + request + '\n';
     }
     function serializeClientReference(
       request,
       parent,
       parentPropertyName,
-      clientReference
+      clientReference,
     ) {
       var clientReferenceKey = clientReference.$$async
-          ? clientReference.$$id + "#async"
+          ? clientReference.$$id + '#async'
           : clientReference.$$id,
         writtenClientReferences = request.writtenClientReferences,
         existingId = writtenClientReferences.get(clientReferenceKey);
       if (void 0 !== existingId)
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(existingId)
           : serializeByValueID(existingId);
       try {
         var clientReferenceMetadata = resolveClientReferenceMetadata(
           request.bundlerConfig,
-          clientReference
+          clientReference,
         );
         request.pendingChunks++;
         var importId = request.nextChunkId++;
         emitImportChunk(request, importId, clientReferenceMetadata, !1);
         writtenClientReferences.set(clientReferenceKey, importId);
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(importId)
           : serializeByValueID(importId);
       } catch (x) {
@@ -2320,26 +2320,26 @@
       request,
       parent,
       parentPropertyName,
-      clientReference
+      clientReference,
     ) {
       var existingId = request.writtenClientReferences.get(
         clientReference.$$async
-          ? clientReference.$$id + "#async"
-          : clientReference.$$id
+          ? clientReference.$$id + '#async'
+          : clientReference.$$id,
       );
       if (void 0 !== existingId)
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(existingId)
           : serializeByValueID(existingId);
       try {
         var clientReferenceMetadata = resolveClientReferenceMetadata(
           request.bundlerConfig,
-          clientReference
+          clientReference,
         );
         request.pendingDebugChunks++;
         var importId = request.nextChunkId++;
         emitImportChunk(request, importId, clientReferenceMetadata, !0);
-        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+        return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
           ? serializeLazyID(importId)
           : serializeByValueID(importId);
       } catch (x) {
@@ -2366,7 +2366,7 @@
         performance.now(),
         null,
         null,
-        null
+        null,
       );
       retryTask(request, value);
       return value.id;
@@ -2374,7 +2374,7 @@
     function serializeServerReference(request, serverReference) {
       var writtenServerReferences = request.writtenServerReferences,
         existingId = writtenServerReferences.get(serverReference);
-      if (void 0 !== existingId) return "$F" + existingId.toString(16);
+      if (void 0 !== existingId) return '$F' + existingId.toString(16);
       existingId = serverReference.$$bound;
       existingId = null === existingId ? null : Promise.resolve(existingId);
       var id = serverReference.$$id,
@@ -2391,16 +2391,16 @@
               id: id,
               bound: existingId,
               name:
-                "function" === typeof serverReference
+                'function' === typeof serverReference
                   ? serverReference.name
-                  : "",
+                  : '',
               env: (0, request.environmentName)(),
-              location: location
+              location: location,
             }
           : { id: id, bound: existingId };
       request = outlineModel(request, existingId);
       writtenServerReferences.set(serverReference, request);
-      return "$F" + request.toString(16);
+      return '$F' + request.toString(16);
     }
     function serializeLargeTextString(request, text) {
       request.pendingChunks++;
@@ -2410,15 +2410,15 @@
     }
     function serializeMap(request, map) {
       map = Array.from(map);
-      return "$Q" + outlineModel(request, map).toString(16);
+      return '$Q' + outlineModel(request, map).toString(16);
     }
     function serializeFormData(request, formData) {
       formData = Array.from(formData.entries());
-      return "$K" + outlineModel(request, formData).toString(16);
+      return '$K' + outlineModel(request, formData).toString(16);
     }
     function serializeSet(request, set) {
       set = Array.from(set);
-      return "$W" + outlineModel(request, set).toString(16);
+      return '$W' + outlineModel(request, set).toString(16);
     }
     function serializeTypedArray(request, tag, typedArray) {
       request.pendingChunks++;
@@ -2439,7 +2439,7 @@
             request,
             id,
             { objectLimit: model.length + 2 },
-            model
+            model,
           ),
             enqueueFlush(request);
         else
@@ -2448,7 +2448,7 @@
           );
       }
       function error(reason) {
-        emitErrorChunk(request, id, "", reason, !0, null);
+        emitErrorChunk(request, id, '', reason, !0, null);
         enqueueFlush(request);
         reader.cancel(reason).then(noop, noop);
       }
@@ -2457,15 +2457,15 @@
       request.pendingDebugChunks++;
       var id = request.nextChunkId++;
       reader.read().then(progress).catch(error);
-      return "$B" + id.toString(16);
+      return '$B' + id.toString(16);
     }
     function serializeBlob(request, blob) {
       function progress(entry) {
         if (0 === newTask.status)
           if (entry.done)
             request.cacheController.signal.removeEventListener(
-              "abort",
-              abortBlob
+              'abort',
+              abortBlob,
             ),
               pingTask(request, newTask);
           else
@@ -2476,8 +2476,8 @@
       function error(reason) {
         0 === newTask.status &&
           (request.cacheController.signal.removeEventListener(
-            "abort",
-            abortBlob
+            'abort',
+            abortBlob,
           ),
           erroredTask(request, newTask, reason),
           enqueueFlush(request),
@@ -2486,7 +2486,7 @@
       function abortBlob() {
         if (0 === newTask.status) {
           var signal = request.cacheController.signal;
-          signal.removeEventListener("abort", abortBlob);
+          signal.removeEventListener('abort', abortBlob);
           signal = signal.reason;
           21 === request.type
             ? (request.abortableTasks.delete(newTask),
@@ -2507,12 +2507,12 @@
           performance.now(),
           null,
           null,
-          null
+          null,
         ),
         reader = blob.stream().getReader();
-      request.cacheController.signal.addEventListener("abort", abortBlob);
+      request.cacheController.signal.addEventListener('abort', abortBlob);
       reader.read().then(progress).catch(error);
-      return "$B" + newTask.id.toString(16);
+      return '$B' + newTask.id.toString(16);
     }
     function renderModel(request, task, parent, key, value) {
       serializedSize += key.length;
@@ -2523,7 +2523,7 @@
       } catch (thrownValue) {
         parent = task.model;
         parent =
-          "object" === typeof parent &&
+          'object' === typeof parent &&
           null !== parent &&
           (parent.$$typeof === REACT_ELEMENT_TYPE ||
             parent.$$typeof === REACT_LAZY_TYPE);
@@ -2545,9 +2545,9 @@
             ? getSuspendedThenable()
             : thrownValue;
         if (
-          "object" === typeof key &&
+          'object' === typeof key &&
           null !== key &&
-          "function" === typeof key.then
+          'function' === typeof key.then
         )
           return (
             (request = createTask(
@@ -2560,7 +2560,7 @@
               task.time,
               task.debugOwner,
               task.debugStack,
-              task.debugTask
+              task.debugTask,
             )),
             (value = request.ping),
             key.then(value, value),
@@ -2582,7 +2582,7 @@
           prevImplicitSlot,
           key,
           !1,
-          task.debugOwner
+          task.debugOwner,
         );
         return parent
           ? serializeLazyID(prevKeyPath)
@@ -2594,12 +2594,12 @@
       task,
       parent,
       parentPropertyName,
-      value
+      value,
     ) {
       task.model = value;
-      if (value === REACT_ELEMENT_TYPE) return "$";
+      if (value === REACT_ELEMENT_TYPE) return '$';
       if (null === value) return null;
-      if ("object" === typeof value) {
+      if ('object' === typeof value) {
         switch (value.$$typeof) {
           case REACT_ELEMENT_TYPE:
             var elementReference = null,
@@ -2610,11 +2610,11 @@
                 if (modelRoot === value) modelRoot = null;
                 else return _existingReference;
               else
-                -1 === parentPropertyName.indexOf(":") &&
+                -1 === parentPropertyName.indexOf(':') &&
                   ((_existingReference = _writtenObjects.get(parent)),
                   void 0 !== _existingReference &&
                     ((elementReference =
-                      _existingReference + ":" + parentPropertyName),
+                      _existingReference + ':' + parentPropertyName),
                     _writtenObjects.set(value, elementReference)));
             }
             if (serializedSize > MAX_ROW_SIZE) return deferTask(request, task);
@@ -2633,13 +2633,13 @@
               void 0 === value._debugStack ||
               void 0 === value._debugTask
             ) {
-              var key = "";
+              var key = '';
               null !== value.key && (key = ' key="' + value.key + '"');
               console.error(
-                "Attempted to render <%s%s> without development properties. This is not supported. It can happen if:\n- The element is created with a production version of React but rendered in development.\n- The element was cloned with a custom function instead of `React.cloneElement`.\nThe props of this element may help locate this element: %o",
+                'Attempted to render <%s%s> without development properties. This is not supported. It can happen if:\n- The element is created with a production version of React but rendered in development.\n- The element was cloned with a custom function instead of `React.cloneElement`.\nThe props of this element may help locate this element: %o',
                 value.type,
                 key,
-                value.props
+                value.props,
               );
             }
             request = renderElement(
@@ -2649,9 +2649,9 @@
               value.key,
               refProp,
               _existingReference,
-              value._store.validated
+              value._store.validated,
             );
-            "object" === typeof request &&
+            'object' === typeof request &&
               null !== request &&
               null !== elementReference &&
               (_writtenObjects.has(request) ||
@@ -2670,12 +2670,12 @@
               request,
               task,
               emptyRoot,
-              "",
-              elementReference
+              '',
+              elementReference,
             );
           case REACT_LEGACY_ELEMENT_TYPE:
             throw Error(
-              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
+              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.',
             );
         }
         if (isClientReference(value))
@@ -2683,26 +2683,26 @@
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (
           void 0 !== request.temporaryReferences &&
           ((elementReference = request.temporaryReferences.get(value)),
           void 0 !== elementReference)
         )
-          return "$T" + elementReference;
+          return '$T' + elementReference;
         elementReference = request.writtenObjects;
         _writtenObjects = elementReference.get(value);
-        if ("function" === typeof value.then) {
+        if ('function' === typeof value.then) {
           if (void 0 !== _writtenObjects) {
             if (null !== task.keyPath || task.implicitSlot)
               return (
-                "$@" + serializeThenable(request, task, value).toString(16)
+                '$@' + serializeThenable(request, task, value).toString(16)
               );
             if (modelRoot === value) modelRoot = null;
             else return _writtenObjects;
           }
-          request = "$@" + serializeThenable(request, task, value).toString(16);
+          request = '$@' + serializeThenable(request, task, value).toString(16);
           elementReference.set(value, request);
           return request;
         }
@@ -2713,81 +2713,81 @@
             modelRoot = null;
           } else return _writtenObjects;
         else if (
-          -1 === parentPropertyName.indexOf(":") &&
+          -1 === parentPropertyName.indexOf(':') &&
           ((_writtenObjects = elementReference.get(parent)),
           void 0 !== _writtenObjects)
         ) {
           _existingReference = parentPropertyName;
           if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
             switch (parentPropertyName) {
-              case "1":
-                _existingReference = "type";
+              case '1':
+                _existingReference = 'type';
                 break;
-              case "2":
-                _existingReference = "key";
+              case '2':
+                _existingReference = 'key';
                 break;
-              case "3":
-                _existingReference = "props";
+              case '3':
+                _existingReference = 'props';
                 break;
-              case "4":
-                _existingReference = "_owner";
+              case '4':
+                _existingReference = '_owner';
             }
           elementReference.set(
             value,
-            _writtenObjects + ":" + _existingReference
+            _writtenObjects + ':' + _existingReference,
           );
         }
         if (isArrayImpl(value)) return renderFragment(request, task, value);
         if (value instanceof Map) return serializeMap(request, value);
         if (value instanceof Set) return serializeSet(request, value);
-        if ("function" === typeof FormData && value instanceof FormData)
+        if ('function' === typeof FormData && value instanceof FormData)
           return serializeFormData(request, value);
         if (value instanceof Error) return serializeErrorValue(request, value);
         if (value instanceof ArrayBuffer)
-          return serializeTypedArray(request, "A", new Uint8Array(value));
+          return serializeTypedArray(request, 'A', new Uint8Array(value));
         if (value instanceof Int8Array)
-          return serializeTypedArray(request, "O", value);
+          return serializeTypedArray(request, 'O', value);
         if (value instanceof Uint8Array)
-          return serializeTypedArray(request, "o", value);
+          return serializeTypedArray(request, 'o', value);
         if (value instanceof Uint8ClampedArray)
-          return serializeTypedArray(request, "U", value);
+          return serializeTypedArray(request, 'U', value);
         if (value instanceof Int16Array)
-          return serializeTypedArray(request, "S", value);
+          return serializeTypedArray(request, 'S', value);
         if (value instanceof Uint16Array)
-          return serializeTypedArray(request, "s", value);
+          return serializeTypedArray(request, 's', value);
         if (value instanceof Int32Array)
-          return serializeTypedArray(request, "L", value);
+          return serializeTypedArray(request, 'L', value);
         if (value instanceof Uint32Array)
-          return serializeTypedArray(request, "l", value);
+          return serializeTypedArray(request, 'l', value);
         if (value instanceof Float32Array)
-          return serializeTypedArray(request, "G", value);
+          return serializeTypedArray(request, 'G', value);
         if (value instanceof Float64Array)
-          return serializeTypedArray(request, "g", value);
+          return serializeTypedArray(request, 'g', value);
         if (value instanceof BigInt64Array)
-          return serializeTypedArray(request, "M", value);
+          return serializeTypedArray(request, 'M', value);
         if (value instanceof BigUint64Array)
-          return serializeTypedArray(request, "m", value);
+          return serializeTypedArray(request, 'm', value);
         if (value instanceof DataView)
-          return serializeTypedArray(request, "V", value);
-        if ("function" === typeof Blob && value instanceof Blob)
+          return serializeTypedArray(request, 'V', value);
+        if ('function' === typeof Blob && value instanceof Blob)
           return serializeBlob(request, value);
         if ((elementReference = getIteratorFn(value)))
           return (
             (elementReference = elementReference.call(value)),
             elementReference === value
-              ? "$i" +
+              ? '$i' +
                 outlineModel(request, Array.from(elementReference)).toString(16)
               : renderFragment(request, task, Array.from(elementReference))
           );
         if (
-          "function" === typeof ReadableStream &&
+          'function' === typeof ReadableStream &&
           value instanceof ReadableStream
         )
           return serializeReadableStream(request, task, value);
         elementReference = value[ASYNC_ITERATOR];
-        if ("function" === typeof elementReference)
+        if ('function' === typeof elementReference)
           return renderAsyncFragment(request, task, value, elementReference);
-        if (value instanceof Date) return "$D" + value.toJSON();
+        if (value instanceof Date) return '$D' + value.toJSON();
         elementReference = getPrototypeOf(value);
         if (
           elementReference !== ObjectPrototype &&
@@ -2795,22 +2795,22 @@
             null !== getPrototypeOf(elementReference))
         )
           throw Error(
-            "Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported." +
-              describeObjectForErrorMessage(parent, parentPropertyName)
+            'Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.' +
+              describeObjectForErrorMessage(parent, parentPropertyName),
           );
-        if ("Object" !== objectName(value))
+        if ('Object' !== objectName(value))
           callWithDebugContextInDEV(request, task, function () {
             console.error(
-              "Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s",
+              'Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s',
               objectName(value),
-              describeObjectForErrorMessage(parent, parentPropertyName)
+              describeObjectForErrorMessage(parent, parentPropertyName),
             );
           });
         else if (!isSimpleObject(value))
           callWithDebugContextInDEV(request, task, function () {
             console.error(
-              "Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.%s",
-              describeObjectForErrorMessage(parent, parentPropertyName)
+              'Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.%s',
+              describeObjectForErrorMessage(parent, parentPropertyName),
             );
           });
         else if (Object.getOwnPropertySymbols) {
@@ -2818,36 +2818,36 @@
           0 < symbols.length &&
             callWithDebugContextInDEV(request, task, function () {
               console.error(
-                "Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like %s are not supported.%s",
+                'Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like %s are not supported.%s',
                 symbols[0].description,
-                describeObjectForErrorMessage(parent, parentPropertyName)
+                describeObjectForErrorMessage(parent, parentPropertyName),
               );
             });
         }
         return value;
       }
-      if ("string" === typeof value)
+      if ('string' === typeof value)
         return (
           (serializedSize += value.length),
-          "Z" === value[value.length - 1] &&
+          'Z' === value[value.length - 1] &&
           parent[parentPropertyName] instanceof Date
-            ? "$D" + value
+            ? '$D' + value
             : 1024 <= value.length && null !== byteLengthOfChunk
               ? serializeLargeTextString(request, value)
-              : "$" === value[0]
-                ? "$" + value
+              : '$' === value[0]
+                ? '$' + value
                 : value
         );
-      if ("boolean" === typeof value) return value;
-      if ("number" === typeof value) return serializeNumber(value);
-      if ("undefined" === typeof value) return "$undefined";
-      if ("function" === typeof value) {
+      if ('boolean' === typeof value) return value;
+      if ('number' === typeof value) return serializeNumber(value);
+      if ('undefined' === typeof value) return '$undefined';
+      if ('function' === typeof value) {
         if (isClientReference(value))
           return serializeClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (value.$$typeof === SERVER_REFERENCE_TAG)
           return serializeServerReference(request, value);
@@ -2856,38 +2856,38 @@
           ((request = request.temporaryReferences.get(value)),
           void 0 !== request)
         )
-          return "$T" + request;
+          return '$T' + request;
         if (value.$$typeof === TEMPORARY_REFERENCE_TAG)
           throw Error(
-            "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+            'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
           );
         if (/^on[A-Z]/.test(parentPropertyName))
           throw Error(
-            "Event handlers cannot be passed to Client Component props." +
+            'Event handlers cannot be passed to Client Component props.' +
               describeObjectForErrorMessage(parent, parentPropertyName) +
-              "\nIf you need interactivity, consider converting part of this to a Client Component."
+              '\nIf you need interactivity, consider converting part of this to a Client Component.',
           );
         if (
           jsxChildrenParents.has(parent) ||
-          (jsxPropsParents.has(parent) && "children" === parentPropertyName)
+          (jsxPropsParents.has(parent) && 'children' === parentPropertyName)
         )
           throw (
-            ((request = value.displayName || value.name || "Component"),
+            ((request = value.displayName || value.name || 'Component'),
             Error(
-              "Functions are not valid as a child of Client Components. This may happen if you return " +
+              'Functions are not valid as a child of Client Components. This may happen if you return ' +
                 request +
-                " instead of <" +
+                ' instead of <' +
                 request +
-                " /> from render. Or maybe you meant to call this function rather than return it." +
-                describeObjectForErrorMessage(parent, parentPropertyName)
+                ' /> from render. Or maybe you meant to call this function rather than return it.' +
+                describeObjectForErrorMessage(parent, parentPropertyName),
             ))
           );
         throw Error(
           'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.' +
-            describeObjectForErrorMessage(parent, parentPropertyName)
+            describeObjectForErrorMessage(parent, parentPropertyName),
         );
       }
-      if ("symbol" === typeof value) {
+      if ('symbol' === typeof value) {
         task = request.writtenSymbols;
         elementReference = task.get(value);
         if (void 0 !== elementReference)
@@ -2895,9 +2895,9 @@
         elementReference = value.description;
         if (Symbol.for(elementReference) !== value)
           throw Error(
-            "Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" +
-              (value.description + ") cannot be found among global symbols.") +
-              describeObjectForErrorMessage(parent, parentPropertyName)
+            'Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(' +
+              (value.description + ') cannot be found among global symbols.') +
+              describeObjectForErrorMessage(parent, parentPropertyName),
           );
         request.pendingChunks++;
         _writtenObjects = request.nextChunkId++;
@@ -2905,12 +2905,12 @@
         task.set(value, _writtenObjects);
         return serializeByValueID(_writtenObjects);
       }
-      if ("bigint" === typeof value) return "$n" + value.toString(10);
+      if ('bigint' === typeof value) return '$n' + value.toString(10);
       throw Error(
-        "Type " +
+        'Type ' +
           typeof value +
-          " is not supported in Client Component props." +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+          ' is not supported in Client Component props.' +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     }
     function logRecoverableError(request, error, task) {
@@ -2926,19 +2926,19 @@
                 request,
                 task,
                 onError,
-                error
+                error,
               )
             : requestStorage.run(void 0, onError, error);
       } finally {
         currentRequest = prevRequest;
       }
-      if (null != errorDigest && "string" !== typeof errorDigest)
+      if (null != errorDigest && 'string' !== typeof errorDigest)
         throw Error(
           'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
             typeof errorDigest +
-            '" instead'
+            '" instead',
         );
-      return errorDigest || "";
+      return errorDigest || '';
     }
     function fatalError(request, error) {
       var onFatalError = request.onFatalError;
@@ -2947,35 +2947,35 @@
         ? ((request.status = CLOSED), request.destination.destroy(error))
         : ((request.status = 13), (request.fatalError = error));
       request.cacheController.abort(
-        Error("The render was aborted due to a fatal error.", { cause: error })
+        Error('The render was aborted due to a fatal error.', { cause: error }),
       );
     }
     function serializeErrorValue(request, error) {
-      var name = "Error",
+      var name = 'Error',
         env = (0, request.environmentName)();
       try {
         name = error.name;
         var message = String(error.message);
         var stack = filterStackTrace(request, parseStackTrace(error, 0));
         var errorEnv = error.environmentName;
-        "string" === typeof errorEnv && (env = errorEnv);
+        'string' === typeof errorEnv && (env = errorEnv);
       } catch (x) {
         (message =
-          "An error occurred but serializing the error message failed."),
+          'An error occurred but serializing the error message failed.'),
           (stack = []);
       }
       return (
-        "$Z" +
+        '$Z' +
         outlineModel(request, {
           name: name,
           message: message,
           stack: stack,
-          env: env
+          env: env,
         }).toString(16)
       );
     }
     function emitErrorChunk(request, id, digest, error, debug, owner) {
-      var name = "Error",
+      var name = 'Error',
         env = (0, request.environmentName)();
       try {
         if (error instanceof Error) {
@@ -2983,16 +2983,16 @@
           var message = String(error.message);
           var stack = filterStackTrace(request, parseStackTrace(error, 0));
           var errorEnv = error.environmentName;
-          "string" === typeof errorEnv && (env = errorEnv);
+          'string' === typeof errorEnv && (env = errorEnv);
         } else
           (message =
-            "object" === typeof error && null !== error
+            'object' === typeof error && null !== error
               ? describeObjectForErrorMessage(error)
               : String(error)),
             (stack = []);
       } catch (x) {
         (message =
-          "An error occurred but serializing the error message failed."),
+          'An error occurred but serializing the error message failed.'),
           (stack = []);
       }
       error = null == owner ? null : outlineComponentInfo(request, owner);
@@ -3002,38 +3002,38 @@
         message: message,
         stack: stack,
         env: env,
-        owner: error
+        owner: error,
       };
-      id = id.toString(16) + ":E" + stringify(digest) + "\n";
+      id = id.toString(16) + ':E' + stringify(digest) + '\n';
       debug
         ? request.completedDebugChunks.push(id)
         : request.completedErrorChunks.push(id);
     }
     function emitImportChunk(request, id, clientReferenceMetadata, debug) {
       clientReferenceMetadata = stringify(clientReferenceMetadata);
-      id = id.toString(16) + ":I" + clientReferenceMetadata + "\n";
+      id = id.toString(16) + ':I' + clientReferenceMetadata + '\n';
       debug
         ? request.completedDebugChunks.push(id)
         : request.completedImportChunks.push(id);
     }
     function emitSymbolChunk(request, id, name) {
-      id = encodeReferenceChunk(request, id, "$S" + name);
+      id = encodeReferenceChunk(request, id, '$S' + name);
       request.completedImportChunks.push(id);
     }
     function emitDebugHaltChunk(request, id) {
-      id = id.toString(16) + ":\n";
+      id = id.toString(16) + ':\n';
       request.completedDebugChunks.push(id);
     }
     function emitDebugChunk(request, id, debugInfo) {
       var json = serializeDebugModel(request, 500, debugInfo);
       null !== request.debugDestination
         ? ((debugInfo = request.nextChunkId++),
-          (json = debugInfo.toString(16) + ":" + json + "\n"),
+          (json = debugInfo.toString(16) + ':' + json + '\n'),
           request.pendingDebugChunks++,
           request.completedDebugChunks.push(json),
           (id = id.toString(16) + ':D"$' + debugInfo.toString(16) + '"\n'),
           request.completedRegularChunks.push(id))
-        : ((id = id.toString(16) + ":D" + json + "\n"),
+        : ((id = id.toString(16) + ':D' + json + '\n'),
           request.completedRegularChunks.push(id));
     }
     function outlineComponentInfo(request, componentInfo) {
@@ -3047,7 +3047,7 @@
       existingRef = { objectLimit: existingRef };
       var componentDebugInfo = {
         name: componentInfo.name,
-        key: componentInfo.key
+        key: componentInfo.key,
       };
       null != componentInfo.env && (componentDebugInfo.env = componentInfo.env);
       null != componentInfo.owner &&
@@ -3055,7 +3055,7 @@
       null == componentInfo.stack && null != componentInfo.debugStack
         ? (componentDebugInfo.stack = filterStackTrace(
             request,
-            parseStackTrace(componentInfo.debugStack, 1)
+            parseStackTrace(componentInfo.debugStack, 1),
           ))
         : null != componentInfo.stack &&
           (componentDebugInfo.stack = componentInfo.stack);
@@ -3075,28 +3075,28 @@
       value,
       env,
       owner,
-      stack
+      stack,
     ) {
       var objectLimit = 10;
       stack && (objectLimit += stack.length);
       name = {
         name: name,
         start: start - request.timeOrigin,
-        end: end - request.timeOrigin
+        end: end - request.timeOrigin,
       };
       null != env && (name.env = env);
       null != stack && (name.stack = stack);
       null != owner && (name.owner = owner);
       void 0 !== value && (name.value = value);
       value = serializeDebugModel(request, objectLimit, name);
-      id = id.toString(16) + ":J" + value + "\n";
+      id = id.toString(16) + ':J' + value + '\n';
       request.completedDebugChunks.push(id);
     }
     function serializeIONode(request, ioNode, promiseRef) {
       var existingRef = request.writtenDebugObjects.get(ioNode);
       if (void 0 !== existingRef) return existingRef;
       existingRef = null;
-      var name = "";
+      var name = '';
       if (null !== ioNode.stack) {
         a: {
           existingRef = ioNode.stack;
@@ -3111,7 +3111,7 @@
         }
         existingRef = filterStackTrace(request, name);
         a: {
-          callsite = "";
+          callsite = '';
           for (
             var filterStackFrame = request.filterStackFrame, i = 0;
             i < name.length;
@@ -3125,10 +3125,10 @@
                 url,
                 functionName,
                 callsite$jscomp$0[2],
-                callsite$jscomp$0[3]
+                callsite$jscomp$0[3],
               )
             ) {
-              if ("" === callsite) {
+              if ('' === callsite) {
                 name = functionName;
                 break a;
               }
@@ -3136,11 +3136,11 @@
               break a;
             } else callsite = functionName;
           }
-          name = "";
+          name = '';
         }
-        name.startsWith("Window.")
+        name.startsWith('Window.')
           ? (name = name.slice(7))
-          : name.startsWith("<anonymous>.") && (name = name.slice(7));
+          : name.startsWith('<anonymous>.') && (name = name.slice(7));
       }
       callsite = ioNode.owner;
       null != callsite && outlineComponentInfo(request, callsite);
@@ -3159,7 +3159,7 @@
         filterStackFrame,
         promiseRef,
         callsite,
-        existingRef
+        existingRef,
       );
       promiseRef = serializeByValueID(callsite$jscomp$0);
       request.writtenDebugObjects.set(ioNode, promiseRef);
@@ -3170,10 +3170,10 @@
       typedArray = new Uint8Array(
         typedArray.buffer,
         typedArray.byteOffset,
-        typedArray.byteLength
+        typedArray.byteLength,
       );
       var binaryLength = typedArray.byteLength;
-      id = id.toString(16) + ":" + tag + binaryLength.toString(16) + ",";
+      id = id.toString(16) + ':' + tag + binaryLength.toString(16) + ',';
       debug
         ? request.completedDebugChunks.push(id, typedArray)
         : request.completedRegularChunks.push(id, typedArray);
@@ -3181,11 +3181,11 @@
     function emitTextChunk(request, id, text, debug) {
       if (null === byteLengthOfChunk)
         throw Error(
-          "Existence of byteLengthOfChunk should have already been checked. This is a bug in React."
+          'Existence of byteLengthOfChunk should have already been checked. This is a bug in React.',
         );
       debug ? request.pendingDebugChunks++ : request.pendingChunks++;
       var binaryLength = byteLengthOfChunk(text);
-      id = id.toString(16) + ":T" + binaryLength.toString(16) + ",";
+      id = id.toString(16) + ':T' + binaryLength.toString(16) + ',';
       debug
         ? request.completedDebugChunks.push(id, text)
         : request.completedRegularChunks.push(id, text);
@@ -3195,17 +3195,17 @@
       counter,
       parent,
       parentPropertyName,
-      value
+      value,
     ) {
       if (null === value) return null;
-      if (value === REACT_ELEMENT_TYPE) return "$";
-      if ("object" === typeof value) {
+      if (value === REACT_ELEMENT_TYPE) return '$';
+      if ('object' === typeof value) {
         if (isClientReference(value))
           return serializeDebugClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (value.$$typeof === CONSTRUCTOR_MARKER) {
           value = value.constructor;
@@ -3213,18 +3213,18 @@
           void 0 === ref &&
             ((request = outlineDebugModel(request, counter, value)),
             (ref = serializeByValueID(request)));
-          return "$P" + ref.slice(1);
+          return '$P' + ref.slice(1);
         }
         if (void 0 !== request.temporaryReferences) {
           var tempRef = request.temporaryReferences.get(value);
-          if (void 0 !== tempRef) return "$T" + tempRef;
+          if (void 0 !== tempRef) return '$T' + tempRef;
         }
         tempRef = request.writtenDebugObjects;
         var existingDebugReference = tempRef.get(value);
         if (void 0 !== existingDebugReference)
           if (debugModelRoot === value) debugModelRoot = null;
           else return existingDebugReference;
-        else if (-1 === parentPropertyName.indexOf(":"))
+        else if (-1 === parentPropertyName.indexOf(':'))
           if (
             ((existingDebugReference = tempRef.get(parent)),
             void 0 !== existingDebugReference)
@@ -3234,21 +3234,21 @@
             var propertyName = parentPropertyName;
             if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
               switch (parentPropertyName) {
-                case "1":
-                  propertyName = "type";
+                case '1':
+                  propertyName = 'type';
                   break;
-                case "2":
-                  propertyName = "key";
+                case '2':
+                  propertyName = 'key';
                   break;
-                case "3":
-                  propertyName = "props";
+                case '3':
+                  propertyName = 'props';
                   break;
-                case "4":
-                  propertyName = "_owner";
+                case '4':
+                  propertyName = '_owner';
               }
-            tempRef.set(value, existingDebugReference + ":" + propertyName);
+            tempRef.set(value, existingDebugReference + ':' + propertyName);
           } else if (debugNoOutline !== value) {
-            if ("function" === typeof value.then)
+            if ('function' === typeof value.then)
               return serializeDebugThenable(request, counter, value);
             request = outlineDebugModel(request, counter, value);
             return serializeByValueID(request);
@@ -3271,17 +3271,17 @@
               request,
               parentPropertyName,
               counter,
-              value
+              value,
             ),
             serializeByValueID(parentPropertyName)
           );
         switch (value.$$typeof) {
           case REACT_ELEMENT_TYPE:
             null != value._owner && outlineComponentInfo(request, value._owner);
-            "object" === typeof value.type &&
+            'object' === typeof value.type &&
               null !== value.type &&
               doNotLimit.add(value.type);
-            "object" === typeof value.key &&
+            'object' === typeof value.key &&
               null !== value.key &&
               doNotLimit.add(value.key);
             doNotLimit.add(value.props);
@@ -3291,7 +3291,7 @@
               for (
                 counter = filterStackTrace(
                   request,
-                  parseStackTrace(value._debugStack, 1)
+                  parseStackTrace(value._debugStack, 1),
                 ),
                   doNotLimit.add(counter),
                   request = 0;
@@ -3306,18 +3306,18 @@
               value.props,
               value._owner,
               counter,
-              value._store.validated
+              value._store.validated,
             ];
           case REACT_LAZY_TYPE:
             value = value._payload;
-            if (null !== value && "object" === typeof value) {
+            if (null !== value && 'object' === typeof value) {
               switch (value._status) {
                 case 1:
                   return (
                     (request = outlineDebugModel(
                       request,
                       counter,
-                      value._result
+                      value._result,
                     )),
                     serializeLazyID(request)
                   );
@@ -3327,34 +3327,34 @@
                     emitErrorChunk(
                       request,
                       counter,
-                      "",
+                      '',
                       value._result,
                       !0,
-                      null
+                      null,
                     ),
                     serializeLazyID(counter)
                   );
               }
               switch (value.status) {
-                case "fulfilled":
+                case 'fulfilled':
                   return (
                     (request = outlineDebugModel(
                       request,
                       counter,
-                      value.value
+                      value.value,
                     )),
                     serializeLazyID(request)
                   );
-                case "rejected":
+                case 'rejected':
                   return (
                     (counter = request.nextChunkId++),
                     emitErrorChunk(
                       request,
                       counter,
-                      "",
+                      '',
                       value.reason,
                       !0,
-                      null
+                      null,
                     ),
                     serializeLazyID(counter)
                   );
@@ -3365,7 +3365,7 @@
             emitDebugHaltChunk(request, value);
             return serializeLazyID(value);
         }
-        if ("function" === typeof value.then)
+        if ('function' === typeof value.then)
           return serializeDebugThenable(request, counter, value);
         if (isArrayImpl(value)) return value;
         if (value instanceof Map) {
@@ -3376,81 +3376,81 @@
             doNotLimit.add(entry);
             var key = entry[0];
             entry = entry[1];
-            "object" === typeof key && null !== key && doNotLimit.add(key);
-            "object" === typeof entry &&
+            'object' === typeof key && null !== key && doNotLimit.add(key);
+            'object' === typeof entry &&
               null !== entry &&
               doNotLimit.add(entry);
           }
-          return "$Q" + outlineDebugModel(request, counter, value).toString(16);
+          return '$Q' + outlineDebugModel(request, counter, value).toString(16);
         }
         if (value instanceof Set) {
           value = Array.from(value);
           counter.objectLimit++;
           for (ref = 0; ref < value.length; ref++)
             (key = value[ref]),
-              "object" === typeof key && null !== key && doNotLimit.add(key);
-          return "$W" + outlineDebugModel(request, counter, value).toString(16);
+              'object' === typeof key && null !== key && doNotLimit.add(key);
+          return '$W' + outlineDebugModel(request, counter, value).toString(16);
         }
-        if ("function" === typeof FormData && value instanceof FormData)
+        if ('function' === typeof FormData && value instanceof FormData)
           return (
             (value = Array.from(value.entries())),
-            "$K" +
+            '$K' +
               outlineDebugModel(
                 request,
                 { objectLimit: 2 * value.length + 1 },
-                value
+                value,
               ).toString(16)
           );
         if (value instanceof Error) {
-          counter = "Error";
+          counter = 'Error';
           var env = (0, request.environmentName)();
           try {
             (counter = value.name),
               (ref = String(value.message)),
               (key = filterStackTrace(request, parseStackTrace(value, 0))),
               (entry = value.environmentName),
-              "string" === typeof entry && (env = entry);
+              'string' === typeof entry && (env = entry);
           } catch (x) {
             (ref =
-              "An error occurred but serializing the error message failed."),
+              'An error occurred but serializing the error message failed.'),
               (key = []);
           }
           request =
-            "$Z" +
+            '$Z' +
             outlineDebugModel(
               request,
               { objectLimit: 2 * key.length + 1 },
-              { name: counter, message: ref, stack: key, env: env }
+              { name: counter, message: ref, stack: key, env: env },
             ).toString(16);
           return request;
         }
         if (value instanceof ArrayBuffer)
-          return serializeDebugTypedArray(request, "A", new Uint8Array(value));
+          return serializeDebugTypedArray(request, 'A', new Uint8Array(value));
         if (value instanceof Int8Array)
-          return serializeDebugTypedArray(request, "O", value);
+          return serializeDebugTypedArray(request, 'O', value);
         if (value instanceof Uint8Array)
-          return serializeDebugTypedArray(request, "o", value);
+          return serializeDebugTypedArray(request, 'o', value);
         if (value instanceof Uint8ClampedArray)
-          return serializeDebugTypedArray(request, "U", value);
+          return serializeDebugTypedArray(request, 'U', value);
         if (value instanceof Int16Array)
-          return serializeDebugTypedArray(request, "S", value);
+          return serializeDebugTypedArray(request, 'S', value);
         if (value instanceof Uint16Array)
-          return serializeDebugTypedArray(request, "s", value);
+          return serializeDebugTypedArray(request, 's', value);
         if (value instanceof Int32Array)
-          return serializeDebugTypedArray(request, "L", value);
+          return serializeDebugTypedArray(request, 'L', value);
         if (value instanceof Uint32Array)
-          return serializeDebugTypedArray(request, "l", value);
+          return serializeDebugTypedArray(request, 'l', value);
         if (value instanceof Float32Array)
-          return serializeDebugTypedArray(request, "G", value);
+          return serializeDebugTypedArray(request, 'G', value);
         if (value instanceof Float64Array)
-          return serializeDebugTypedArray(request, "g", value);
+          return serializeDebugTypedArray(request, 'g', value);
         if (value instanceof BigInt64Array)
-          return serializeDebugTypedArray(request, "M", value);
+          return serializeDebugTypedArray(request, 'M', value);
         if (value instanceof BigUint64Array)
-          return serializeDebugTypedArray(request, "m", value);
+          return serializeDebugTypedArray(request, 'm', value);
         if (value instanceof DataView)
-          return serializeDebugTypedArray(request, "V", value);
-        if ("function" === typeof Blob && value instanceof Blob)
+          return serializeDebugTypedArray(request, 'V', value);
+        if ('function' === typeof Blob && value instanceof Blob)
           return serializeDebugBlob(request, value);
         if (getIteratorFn(value)) return Array.from(value);
         request = getPrototypeOf(value);
@@ -3460,21 +3460,21 @@
             if (hasOwnProperty.call(value, env) || isGetter(request, env))
               counter[env] = value[env];
           ref = request.constructor;
-          "function" !== typeof ref ||
+          'function' !== typeof ref ||
             ref.prototype !== request ||
-            hasOwnProperty.call(value, "") ||
-            isGetter(request, "") ||
-            (counter[""] = { $$typeof: CONSTRUCTOR_MARKER, constructor: ref });
+            hasOwnProperty.call(value, '') ||
+            isGetter(request, '') ||
+            (counter[''] = { $$typeof: CONSTRUCTOR_MARKER, constructor: ref });
           return counter;
         }
         return value;
       }
-      if ("string" === typeof value) {
+      if ('string' === typeof value) {
         if (
-          "Z" === value[value.length - 1] &&
+          'Z' === value[value.length - 1] &&
           parent[parentPropertyName] instanceof Date
         )
-          return "$D" + value;
+          return '$D' + value;
         if (1024 <= value.length) {
           if (0 >= counter.objectLimit)
             return serializeDeferredObject(request, value);
@@ -3484,39 +3484,39 @@
           emitTextChunk(request, counter, value, !0);
           return serializeByValueID(counter);
         }
-        return "$" === value[0] ? "$" + value : value;
+        return '$' === value[0] ? '$' + value : value;
       }
-      if ("boolean" === typeof value) return value;
-      if ("number" === typeof value) return serializeNumber(value);
-      if ("undefined" === typeof value) return "$undefined";
-      if ("function" === typeof value) {
+      if ('boolean' === typeof value) return value;
+      if ('number' === typeof value) return serializeNumber(value);
+      if ('undefined' === typeof value) return '$undefined';
+      if ('function' === typeof value) {
         if (isClientReference(value))
           return serializeDebugClientReference(
             request,
             parent,
             parentPropertyName,
-            value
+            value,
           );
         if (
           void 0 !== request.temporaryReferences &&
           ((counter = request.temporaryReferences.get(value)),
           void 0 !== counter)
         )
-          return "$T" + counter;
+          return '$T' + counter;
         counter = request.writtenDebugObjects;
         ref = counter.get(value);
         if (void 0 !== ref) return ref;
         ref = Function.prototype.toString.call(value);
         key = value.name;
         key =
-          "$E" +
-          ("string" === typeof key
-            ? "Object.defineProperty(" +
+          '$E' +
+          ('string' === typeof key
+            ? 'Object.defineProperty(' +
               ref +
               ',"name",{value:' +
               JSON.stringify(key) +
-              "})"
-            : "(" + ref + ")");
+              '})'
+            : '(' + ref + ')');
         request.pendingDebugChunks++;
         ref = request.nextChunkId++;
         key = encodeReferenceChunk(request, ref, key);
@@ -3525,7 +3525,7 @@
         counter.set(value, request);
         return request;
       }
-      if ("symbol" === typeof value) {
+      if ('symbol' === typeof value) {
         counter = request.writtenSymbols.get(value);
         if (void 0 !== counter) return serializeByValueID(counter);
         value = value.description;
@@ -3534,11 +3534,11 @@
         emitSymbolChunk(request, counter, value);
         return serializeByValueID(counter);
       }
-      return "bigint" === typeof value
-        ? "$n" + value.toString(10)
+      return 'bigint' === typeof value
+        ? '$n' + value.toString(10)
         : value instanceof Date
-          ? "$D" + value.toJSON()
-          : "unknown type " + typeof value;
+          ? '$D' + value.toJSON()
+          : 'unknown type ' + typeof value;
     }
     function serializeDebugModel(request, objectLimit, model) {
       function replacer(parentPropertyName, value) {
@@ -3548,11 +3548,11 @@
             counter,
             this,
             parentPropertyName,
-            value
+            value,
           );
         } catch (x) {
           return (
-            "Unknown Value: React could not send it from the server.\n" +
+            'Unknown Value: React could not send it from the server.\n' +
             x.message
           );
         }
@@ -3564,8 +3564,8 @@
         return stringify(model, replacer);
       } catch (x) {
         return stringify(
-          "Unknown Value: React could not send it from the server.\n" +
-            x.message
+          'Unknown Value: React could not send it from the server.\n' +
+            x.message,
         );
       } finally {
         debugNoOutline = objectLimit;
@@ -3579,32 +3579,32 @@
             counter,
             this,
             parentPropertyName,
-            value
+            value,
           );
         } catch (x) {
           return (
-            "Unknown Value: React could not send it from the server.\n" +
+            'Unknown Value: React could not send it from the server.\n' +
             x.message
           );
         }
       }
-      "object" === typeof model && null !== model && doNotLimit.add(model);
+      'object' === typeof model && null !== model && doNotLimit.add(model);
       var prevModelRoot = debugModelRoot;
       debugModelRoot = model;
-      "object" === typeof model &&
+      'object' === typeof model &&
         null !== model &&
         request.writtenDebugObjects.set(model, serializeByValueID(id));
       try {
         var json = stringify(model, replacer);
       } catch (x) {
         json = stringify(
-          "Unknown Value: React could not send it from the server.\n" +
-            x.message
+          'Unknown Value: React could not send it from the server.\n' +
+            x.message,
         );
       } finally {
         debugModelRoot = prevModelRoot;
       }
-      id = id.toString(16) + ":" + json + "\n";
+      id = id.toString(16) + ':' + json + '\n';
       request.completedDebugChunks.push(id);
     }
     function outlineDebugModel(request, counter, model) {
@@ -3615,14 +3615,14 @@
     }
     function emitTimeOriginChunk(request, timeOrigin) {
       request.pendingDebugChunks++;
-      request.completedDebugChunks.push(":N" + timeOrigin + "\n");
+      request.completedDebugChunks.push(':N' + timeOrigin + '\n');
     }
     function forwardDebugInfo(request$jscomp$0, task, debugInfo) {
       for (var id = task.id, i = 0; i < debugInfo.length; i++) {
         var info = debugInfo[i];
-        if ("number" === typeof info.time)
+        if ('number' === typeof info.time)
           markOperationEndTime(request$jscomp$0, task, info.time);
-        else if ("string" === typeof info.name)
+        else if ('string' === typeof info.name)
           outlineComponentInfo(request$jscomp$0, info),
             request$jscomp$0.pendingChunks++,
             emitDebugChunk(request$jscomp$0, id, info);
@@ -3641,7 +3641,7 @@
                 null != ioInfo$jscomp$0.debugStack
                   ? filterStackTrace(
                       request,
-                      parseStackTrace(ioInfo$jscomp$0.debugStack, 1)
+                      parseStackTrace(ioInfo$jscomp$0.debugStack, 1),
                     )
                   : ioInfo$jscomp$0.stack;
               emitIOInfoChunk(
@@ -3653,11 +3653,11 @@
                 ioInfo$jscomp$0.value,
                 ioInfo$jscomp$0.env,
                 owner,
-                debugStack
+                debugStack,
               );
               request.writtenDebugObjects.set(
                 ioInfo$jscomp$0,
-                serializeByValueID(id$jscomp$0)
+                serializeByValueID(id$jscomp$0),
               );
             }
             null != info.owner &&
@@ -3666,7 +3666,7 @@
               null == info.stack && null != info.debugStack
                 ? filterStackTrace(
                     request$jscomp$0,
-                    parseStackTrace(info.debugStack, 1)
+                    parseStackTrace(info.debugStack, 1),
                   )
                 : info.stack;
             ioInfo = { awaited: ioInfo };
@@ -3686,7 +3686,7 @@
       task,
       thenable,
       owner,
-      stack
+      stack,
     ) {
       var debugInfo;
       (debugInfo = thenable._debugInfo) &&
@@ -3705,16 +3705,16 @@
     }
     function forwardDebugInfoFromAbortedTask(request, task) {
       var model = task.model;
-      if ("object" === typeof model && null !== model) {
+      if ('object' === typeof model && null !== model) {
         var debugInfo;
         (debugInfo = model._debugInfo) &&
           forwardDebugInfo(request, task, debugInfo);
         var thenable = null;
-        "function" === typeof model.then
+        'function' === typeof model.then
           ? (thenable = model)
           : model.$$typeof === REACT_LAZY_TYPE &&
             ((model = model._payload),
-            "function" === typeof model.then && (thenable = model));
+            'function' === typeof model.then && (thenable = model));
         if (
           null !== thenable &&
           ((model = getAsyncSequenceFromPromise(thenable)), null !== model)
@@ -3738,15 +3738,15 @@
     }
     function emitTimingChunk(request, id, timestamp) {
       request.pendingChunks++;
-      var json = '{"time":' + (timestamp - request.timeOrigin) + "}";
+      var json = '{"time":' + (timestamp - request.timeOrigin) + '}';
       null !== request.debugDestination
         ? ((timestamp = request.nextChunkId++),
-          (json = timestamp.toString(16) + ":" + json + "\n"),
+          (json = timestamp.toString(16) + ':' + json + '\n'),
           request.pendingDebugChunks++,
           request.completedDebugChunks.push(json),
           (id = id.toString(16) + ':D"$' + timestamp.toString(16) + '"\n'),
           request.completedRegularChunks.push(id))
-        : ((id = id.toString(16) + ":D" + json + "\n"),
+        : ((id = id.toString(16) + ':D' + json + '\n'),
           request.completedRegularChunks.push(id));
     }
     function advanceTaskTime(request, task, timestamp) {
@@ -3765,52 +3765,52 @@
     }
     function emitChunk(request, task, value) {
       var id = task.id;
-      "string" === typeof value && null !== byteLengthOfChunk
+      'string' === typeof value && null !== byteLengthOfChunk
         ? emitTextChunk(request, id, value, !1)
         : value instanceof ArrayBuffer
-          ? emitTypedArrayChunk(request, id, "A", new Uint8Array(value), !1)
+          ? emitTypedArrayChunk(request, id, 'A', new Uint8Array(value), !1)
           : value instanceof Int8Array
-            ? emitTypedArrayChunk(request, id, "O", value, !1)
+            ? emitTypedArrayChunk(request, id, 'O', value, !1)
             : value instanceof Uint8Array
-              ? emitTypedArrayChunk(request, id, "o", value, !1)
+              ? emitTypedArrayChunk(request, id, 'o', value, !1)
               : value instanceof Uint8ClampedArray
-                ? emitTypedArrayChunk(request, id, "U", value, !1)
+                ? emitTypedArrayChunk(request, id, 'U', value, !1)
                 : value instanceof Int16Array
-                  ? emitTypedArrayChunk(request, id, "S", value, !1)
+                  ? emitTypedArrayChunk(request, id, 'S', value, !1)
                   : value instanceof Uint16Array
-                    ? emitTypedArrayChunk(request, id, "s", value, !1)
+                    ? emitTypedArrayChunk(request, id, 's', value, !1)
                     : value instanceof Int32Array
-                      ? emitTypedArrayChunk(request, id, "L", value, !1)
+                      ? emitTypedArrayChunk(request, id, 'L', value, !1)
                       : value instanceof Uint32Array
-                        ? emitTypedArrayChunk(request, id, "l", value, !1)
+                        ? emitTypedArrayChunk(request, id, 'l', value, !1)
                         : value instanceof Float32Array
-                          ? emitTypedArrayChunk(request, id, "G", value, !1)
+                          ? emitTypedArrayChunk(request, id, 'G', value, !1)
                           : value instanceof Float64Array
-                            ? emitTypedArrayChunk(request, id, "g", value, !1)
+                            ? emitTypedArrayChunk(request, id, 'g', value, !1)
                             : value instanceof BigInt64Array
-                              ? emitTypedArrayChunk(request, id, "M", value, !1)
+                              ? emitTypedArrayChunk(request, id, 'M', value, !1)
                               : value instanceof BigUint64Array
                                 ? emitTypedArrayChunk(
                                     request,
                                     id,
-                                    "m",
+                                    'm',
                                     value,
-                                    !1
+                                    !1,
                                   )
                                 : value instanceof DataView
                                   ? emitTypedArrayChunk(
                                       request,
                                       id,
-                                      "V",
+                                      'V',
                                       value,
-                                      !1
+                                      !1,
                                     )
                                   : ((value = stringify(value, task.toJSON)),
                                     (task =
                                       task.id.toString(16) +
-                                      ":" +
+                                      ':' +
                                       value +
-                                      "\n"),
+                                      '\n'),
                                     request.completedRegularChunks.push(task));
     }
     function erroredTask(request, task, error) {
@@ -3833,8 +3833,8 @@
             request,
             task,
             emptyRoot,
-            "",
-            task.model
+            '',
+            task.model,
           );
           canEmitDebugInfo = !1;
           modelRoot = resolvedModel;
@@ -3845,15 +3845,15 @@
             (request.pendingChunks++,
             emitDebugChunk(request, task.id, { env: currentEnv }));
           task.timed && markOperationEndTime(request, task, performance.now());
-          if ("object" === typeof resolvedModel && null !== resolvedModel)
+          if ('object' === typeof resolvedModel && null !== resolvedModel)
             request.writtenObjects.set(
               resolvedModel,
-              serializeByValueID(task.id)
+              serializeByValueID(task.id),
             ),
               emitChunk(request, task, resolvedModel);
           else {
             var json = stringify(resolvedModel),
-              processedChunk = task.id.toString(16) + ":" + json + "\n";
+              processedChunk = task.id.toString(16) + ':' + json + '\n';
             request.completedRegularChunks.push(processedChunk);
           }
           task.status = 1;
@@ -3878,9 +3878,9 @@
                 ? getSuspendedThenable()
                 : thrownValue;
             if (
-              "object" === typeof x &&
+              'object' === typeof x &&
               null !== x &&
-              "function" === typeof x.then
+              'function' === typeof x.then
             ) {
               task.status = 0;
               task.thenableState = getThenableStateAfterSuspending();
@@ -3980,7 +3980,7 @@
               (request.pendingChunks--,
               !writeChunkAndReturn(
                 debugDestination,
-                importsChunks[debugChunks]
+                importsChunks[debugChunks],
               ))
             ) {
               request.destination = null;
@@ -4009,7 +4009,7 @@
                 (request.pendingDebugChunks--,
                 !writeChunkAndReturn(
                   debugDestination,
-                  _debugChunks[debugChunks]
+                  _debugChunks[debugChunks],
                 ))
               ) {
                 request.destination = null;
@@ -4028,7 +4028,7 @@
               (request.pendingChunks--,
               !writeChunkAndReturn(
                 debugDestination,
-                regularChunks[debugChunks]
+                regularChunks[debugChunks],
               ))
             ) {
               request.destination = null;
@@ -4060,8 +4060,8 @@
             request.status < ABORTING &&
               request.cacheController.abort(
                 Error(
-                  "This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources."
-                )
+                  'This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources.',
+                ),
               ),
             null !== request.destination &&
               ((request.status = CLOSED),
@@ -4166,13 +4166,13 @@
               var error =
                   void 0 === reason
                     ? Error(
-                        "The render was aborted by the server without a reason."
+                        'The render was aborted by the server without a reason.',
                       )
-                    : "object" === typeof reason &&
+                    : 'object' === typeof reason &&
                         null !== reason &&
-                        "function" === typeof reason.then
+                        'function' === typeof reason.then
                       ? Error(
-                          "The render was aborted by the server with a promise."
+                          'The render was aborted by the server with a promise.',
                         )
                       : reason,
                 digest = logRecoverableError(request, error, null),
@@ -4204,12 +4204,12 @@
       var deferredDebugObjects = request.deferredDebugObjects;
       if (null === deferredDebugObjects)
         throw Error(
-          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React."
+          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React.",
         );
-      if ("" === message) closeDebugChannel(request);
+      if ('' === message) closeDebugChannel(request);
       else {
         var command = message.charCodeAt(0);
-        message = message.slice(2).split(",").map(fromHex);
+        message = message.slice(2).split(',').map(fromHex);
         switch (command) {
           case 82:
             for (command = 0; command < message.length; command++) {
@@ -4233,7 +4233,7 @@
                     request,
                     id,
                     { objectLimit: 10 },
-                    retainedValue
+                    retainedValue,
                   ),
                   enqueueFlush(request));
             break;
@@ -4247,12 +4247,12 @@
                     request,
                     id,
                     { objectLimit: 10 },
-                    retainedValue
+                    retainedValue,
                   ));
             break;
           default:
             throw Error(
-              "Unknown command. The debugChannel was not wired up properly."
+              'Unknown command. The debugChannel was not wired up properly.',
             );
         }
       }
@@ -4261,7 +4261,7 @@
       var deferredDebugObjects = request.deferredDebugObjects;
       if (null === deferredDebugObjects)
         throw Error(
-          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React."
+          "resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React.",
         );
       deferredDebugObjects.retained.forEach(function (value, id) {
         request.pendingDebugChunks--;
@@ -4271,7 +4271,7 @@
       enqueueFlush(request);
     }
     function resolveServerReference(bundlerConfig, id) {
-      var idx = id.lastIndexOf("#");
+      var idx = id.lastIndexOf('#');
       bundlerConfig = id.slice(0, idx);
       id = id.slice(idx + 1);
       return { specifier: bundlerConfig, name: id };
@@ -4279,7 +4279,7 @@
     function preloadModule(metadata) {
       var existingPromise = asyncModuleCache.get(metadata.specifier);
       if (existingPromise)
-        return "fulfilled" === existingPromise.status ? null : existingPromise;
+        return 'fulfilled' === existingPromise.status ? null : existingPromise;
       var modulePromise = import(metadata.specifier);
       metadata.async &&
         (modulePromise = modulePromise.then(function (value) {
@@ -4288,26 +4288,26 @@
       modulePromise.then(
         function (value) {
           var fulfilledThenable = modulePromise;
-          fulfilledThenable.status = "fulfilled";
+          fulfilledThenable.status = 'fulfilled';
           fulfilledThenable.value = value;
         },
         function (reason) {
           var rejectedThenable = modulePromise;
-          rejectedThenable.status = "rejected";
+          rejectedThenable.status = 'rejected';
           rejectedThenable.reason = reason;
-        }
+        },
       );
       asyncModuleCache.set(metadata.specifier, modulePromise);
       return modulePromise;
     }
     function requireModule(metadata) {
       var moduleExports = asyncModuleCache.get(metadata.specifier);
-      if ("fulfilled" === moduleExports.status)
+      if ('fulfilled' === moduleExports.status)
         moduleExports = moduleExports.value;
       else throw moduleExports.reason;
-      return "*" === metadata.name
+      return '*' === metadata.name
         ? moduleExports
-        : "" === metadata.name
+        : '' === metadata.name
           ? moduleExports.default
           : moduleExports[metadata.name];
     }
@@ -4318,41 +4318,41 @@
       this._response = response;
     }
     function createPendingChunk(response) {
-      return new Chunk("pending", null, null, response);
+      return new Chunk('pending', null, null, response);
     }
     function wakeChunk(listeners, value) {
       for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
     }
     function triggerErrorOnChunk(chunk, error) {
-      if ("pending" !== chunk.status && "blocked" !== chunk.status)
+      if ('pending' !== chunk.status && 'blocked' !== chunk.status)
         chunk.reason.error(error);
       else {
         var listeners = chunk.reason;
-        chunk.status = "rejected";
+        chunk.status = 'rejected';
         chunk.reason = error;
         null !== listeners && wakeChunk(listeners, error);
       }
     }
     function resolveModelChunk(chunk, value, id) {
-      if ("pending" !== chunk.status)
+      if ('pending' !== chunk.status)
         (chunk = chunk.reason),
-          "C" === value[0]
-            ? chunk.close("C" === value ? '"$undefined"' : value.slice(1))
+          'C' === value[0]
+            ? chunk.close('C' === value ? '"$undefined"' : value.slice(1))
             : chunk.enqueueModel(value);
       else {
         var resolveListeners = chunk.value,
           rejectListeners = chunk.reason;
-        chunk.status = "resolved_model";
+        chunk.status = 'resolved_model';
         chunk.value = value;
         chunk.reason = id;
         if (null !== resolveListeners)
           switch ((initializeModelChunk(chunk), chunk.status)) {
-            case "fulfilled":
+            case 'fulfilled':
               wakeChunk(resolveListeners, chunk.value);
               break;
-            case "pending":
-            case "blocked":
-            case "cyclic":
+            case 'pending':
+            case 'blocked':
+            case 'cyclic':
               if (chunk.value)
                 for (value = 0; value < resolveListeners.length; value++)
                   chunk.value.push(resolveListeners[value]);
@@ -4363,19 +4363,19 @@
                     chunk.reason.push(rejectListeners[value]);
               } else chunk.reason = rejectListeners;
               break;
-            case "rejected":
+            case 'rejected':
               rejectListeners && wakeChunk(rejectListeners, chunk.reason);
           }
       }
     }
     function createResolvedIteratorResultChunk(response, value, done) {
       return new Chunk(
-        "resolved_model",
+        'resolved_model',
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
+          '}',
         -1,
-        response
+        response,
       );
     }
     function resolveIteratorResultChunk(chunk, value, done) {
@@ -4383,8 +4383,8 @@
         chunk,
         (done ? '{"done":true,"value":' : '{"done":false,"value":') +
           value +
-          "}",
-        -1
+          '}',
+        -1,
       );
     }
     function loadServerReference$1(
@@ -4393,7 +4393,7 @@
       bound,
       parentChunk,
       parentObject,
-      key
+      key,
     ) {
       var serverReference = resolveServerReference(response._bundlerConfig, id);
       id = preloadModule(serverReference);
@@ -4416,22 +4416,22 @@
           !1,
           response,
           createModel,
-          []
+          [],
         ),
-        createModelReject(parentChunk)
+        createModelReject(parentChunk),
       );
       return null;
     }
     function reviveModel(response, parentObj, parentKey, value, reference) {
-      if ("string" === typeof value)
+      if ('string' === typeof value)
         return parseModelString(
           response,
           parentObj,
           parentKey,
           value,
-          reference
+          reference,
         );
-      if ("object" === typeof value && null !== value)
+      if ('object' === typeof value && null !== value)
         if (
           (void 0 !== reference &&
             void 0 !== response._temporaryReferences &&
@@ -4442,23 +4442,23 @@
             value[i] = reviveModel(
               response,
               value,
-              "" + i,
+              '' + i,
               value[i],
-              void 0 !== reference ? reference + ":" + i : void 0
+              void 0 !== reference ? reference + ':' + i : void 0,
             );
         else
           for (i in value)
             hasOwnProperty.call(value, i) &&
               ((parentObj =
-                void 0 !== reference && -1 === i.indexOf(":")
-                  ? reference + ":" + i
+                void 0 !== reference && -1 === i.indexOf(':')
+                  ? reference + ':' + i
                   : void 0),
               (parentObj = reviveModel(
                 response,
                 value,
                 i,
                 value[i],
-                parentObj
+                parentObj,
               )),
               void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);
       return value;
@@ -4471,32 +4471,32 @@
       var rootReference =
           -1 === chunk.reason ? void 0 : chunk.reason.toString(16),
         resolvedModel = chunk.value;
-      chunk.status = "cyclic";
+      chunk.status = 'cyclic';
       chunk.value = null;
       chunk.reason = null;
       try {
         var rawModel = JSON.parse(resolvedModel),
           value = reviveModel(
             chunk._response,
-            { "": rawModel },
-            "",
+            { '': rawModel },
+            '',
             rawModel,
-            rootReference
+            rootReference,
           );
         if (
           null !== initializingChunkBlockedModel &&
           0 < initializingChunkBlockedModel.deps
         )
           (initializingChunkBlockedModel.value = value),
-            (chunk.status = "blocked");
+            (chunk.status = 'blocked');
         else {
           var resolveListeners = chunk.value;
-          chunk.status = "fulfilled";
+          chunk.status = 'fulfilled';
           chunk.value = value;
           null !== resolveListeners && wakeChunk(resolveListeners, value);
         }
       } catch (error) {
-        (chunk.status = "rejected"), (chunk.reason = error);
+        (chunk.status = 'rejected'), (chunk.reason = error);
       } finally {
         (initializingChunk = prevChunk),
           (initializingChunkBlockedModel = prevBlocked);
@@ -4506,7 +4506,7 @@
       response._closed = !0;
       response._closedReason = error;
       response._chunks.forEach(function (chunk) {
-        "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+        'pending' === chunk.status && triggerErrorOnChunk(chunk, error);
       });
     }
     function getChunk(response, id) {
@@ -4516,9 +4516,9 @@
         ((chunk = response._formData.get(response._prefix + id)),
         (chunk =
           null != chunk
-            ? new Chunk("resolved_model", chunk, id, response)
+            ? new Chunk('resolved_model', chunk, id, response)
             : response._closed
-              ? new Chunk("rejected", null, response._closedReason, response)
+              ? new Chunk('rejected', null, response._closedReason, response)
               : createPendingChunk(response)),
         chunks.set(id, chunk));
       return chunk;
@@ -4530,7 +4530,7 @@
       cyclic,
       response,
       map,
-      path
+      path,
     ) {
       if (initializingChunkBlockedModel) {
         var blocked = initializingChunkBlockedModel;
@@ -4538,19 +4538,19 @@
       } else
         blocked = initializingChunkBlockedModel = {
           deps: cyclic ? 0 : 1,
-          value: null
+          value: null,
         };
       return function (value) {
         for (var i = 1; i < path.length; i++) value = value[path[i]];
         parentObject[key] = map(response, value);
-        "" === key &&
+        '' === key &&
           null === blocked.value &&
           (blocked.value = parentObject[key]);
         blocked.deps--;
         0 === blocked.deps &&
-          "blocked" === chunk.status &&
+          'blocked' === chunk.status &&
           ((value = chunk.value),
-          (chunk.status = "fulfilled"),
+          (chunk.status = 'fulfilled'),
           (chunk.value = blocked.value),
           null !== value && wakeChunk(value, blocked.value));
       };
@@ -4561,34 +4561,34 @@
       };
     }
     function getOutlinedModel(response, reference, parentObject, key, map) {
-      reference = reference.split(":");
+      reference = reference.split(':');
       var id = parseInt(reference[0], 16);
       id = getChunk(response, id);
       switch (id.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(id);
       }
       switch (id.status) {
-        case "fulfilled":
+        case 'fulfilled':
           parentObject = id.value;
           for (key = 1; key < reference.length; key++)
             parentObject = parentObject[reference[key]];
           return map(response, parentObject);
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           var parentChunk = initializingChunk;
           id.then(
             createModelResolver(
               parentChunk,
               parentObject,
               key,
-              "cyclic" === id.status,
+              'cyclic' === id.status,
               response,
               map,
-              reference
+              reference,
             ),
-            createModelReject(parentChunk)
+            createModelReject(parentChunk),
           );
           return null;
         default:
@@ -4613,7 +4613,7 @@
       constructor,
       bytesPerElement,
       parentObject,
-      parentKey
+      parentKey,
     ) {
       reference = parseInt(reference.slice(2), 16);
       reference = response._formData.get(response._prefix + reference);
@@ -4632,22 +4632,22 @@
           !1,
           response,
           createModel,
-          []
+          [],
         ),
-        createModelReject(bytesPerElement)
+        createModelReject(bytesPerElement),
       );
       return null;
     }
     function resolveStream(response, id, stream, controller) {
       var chunks = response._chunks;
-      stream = new Chunk("fulfilled", stream, controller, response);
+      stream = new Chunk('fulfilled', stream, controller, response);
       chunks.set(id, stream);
       response = response._formData.getAll(response._prefix + id);
       for (id = 0; id < response.length; id++)
         (chunks = response[id]),
-          "C" === chunks[0]
+          'C' === chunks[0]
             ? controller.close(
-                "C" === chunks ? '"$undefined"' : chunks.slice(1)
+                'C' === chunks ? '"$undefined"' : chunks.slice(1),
               )
             : controller.enqueueModel(chunks);
     }
@@ -4658,15 +4658,15 @@
         type: type,
         start: function (c) {
           controller = c;
-        }
+        },
       });
       var previousBlockedChunk = null;
       resolveStream(response, reference, type, {
         enqueueModel: function (json) {
           if (null === previousBlockedChunk) {
-            var chunk = new Chunk("resolved_model", json, -1, response);
+            var chunk = new Chunk('resolved_model', json, -1, response);
             initializeModelChunk(chunk);
-            "fulfilled" === chunk.status
+            'fulfilled' === chunk.status
               ? controller.enqueue(chunk.value)
               : (chunk.then(
                   function (v) {
@@ -4674,7 +4674,7 @@
                   },
                   function (e) {
                     return controller.error(e);
-                  }
+                  },
                 ),
                 (previousBlockedChunk = chunk));
           } else {
@@ -4686,7 +4686,7 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             );
             previousBlockedChunk = _chunk;
             chunk.then(function () {
@@ -4714,7 +4714,7 @@
               return controller.error(error);
             });
           }
-        }
+        },
       });
       return type;
     }
@@ -4736,15 +4736,15 @@
           return createIterator(function (arg) {
             if (void 0 !== arg)
               throw Error(
-                "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+                'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
               );
             if (nextReadIndex === buffer.length) {
               if (closed)
                 return new Chunk(
-                  "fulfilled",
+                  'fulfilled',
                   { done: !0, value: void 0 },
                   null,
-                  response
+                  response,
                 );
               buffer[nextReadIndex] = createPendingChunk(response);
             }
@@ -4758,7 +4758,7 @@
             ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                 response,
                 value,
-                !1
+                !1,
               ))
             : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
           nextWriteIndex++;
@@ -4769,14 +4769,14 @@
             ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
                 response,
                 value,
-                !0
+                !0,
               ))
             : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
           for (nextWriteIndex++; nextWriteIndex < buffer.length; )
             resolveIteratorResultChunk(
               buffer[nextWriteIndex++],
               '"$undefined"',
-              !0
+              !0,
             );
         },
         error: function (error) {
@@ -4788,20 +4788,20 @@
 
           )
             triggerErrorOnChunk(buffer[nextWriteIndex++], error);
-        }
+        },
       });
       return iterator;
     }
     function parseModelString(response, obj, key, value, reference) {
-      if ("$" === value[0]) {
+      if ('$' === value[0]) {
         switch (value[1]) {
-          case "$":
+          case '$':
             return value.slice(1);
-          case "@":
+          case '@':
             return (
               (obj = parseInt(value.slice(2), 16)), getChunk(response, obj)
             );
-          case "F":
+          case 'F':
             return (
               (value = value.slice(2)),
               (value = getOutlinedModel(
@@ -4809,7 +4809,7 @@
                 value,
                 obj,
                 key,
-                createModel
+                createModel,
               )),
               loadServerReference$1(
                 response,
@@ -4817,113 +4817,113 @@
                 value.bound,
                 initializingChunk,
                 obj,
-                key
+                key,
               )
             );
-          case "T":
+          case 'T':
             if (
               void 0 === reference ||
               void 0 === response._temporaryReferences
             )
               throw Error(
-                "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+                'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
               );
             return createTemporaryReference(
               response._temporaryReferences,
-              reference
+              reference,
             );
-          case "Q":
+          case 'Q':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, createMap)
             );
-          case "W":
+          case 'W':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, createSet)
             );
-          case "K":
+          case 'K':
             obj = value.slice(2);
-            var formPrefix = response._prefix + obj + "_",
+            var formPrefix = response._prefix + obj + '_',
               data = new FormData();
             response._formData.forEach(function (entry, entryKey) {
               entryKey.startsWith(formPrefix) &&
                 data.append(entryKey.slice(formPrefix.length), entry);
             });
             return data;
-          case "i":
+          case 'i':
             return (
               (value = value.slice(2)),
               getOutlinedModel(response, value, obj, key, extractIterator)
             );
-          case "I":
+          case 'I':
             return Infinity;
-          case "-":
-            return "$-0" === value ? -0 : -Infinity;
-          case "N":
+          case '-':
+            return '$-0' === value ? -0 : -Infinity;
+          case 'N':
             return NaN;
-          case "u":
+          case 'u':
             return;
-          case "D":
+          case 'D':
             return new Date(Date.parse(value.slice(2)));
-          case "n":
+          case 'n':
             return BigInt(value.slice(2));
         }
         switch (value[1]) {
-          case "A":
+          case 'A':
             return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);
-          case "O":
+          case 'O':
             return parseTypedArray(response, value, Int8Array, 1, obj, key);
-          case "o":
+          case 'o':
             return parseTypedArray(response, value, Uint8Array, 1, obj, key);
-          case "U":
+          case 'U':
             return parseTypedArray(
               response,
               value,
               Uint8ClampedArray,
               1,
               obj,
-              key
+              key,
             );
-          case "S":
+          case 'S':
             return parseTypedArray(response, value, Int16Array, 2, obj, key);
-          case "s":
+          case 's':
             return parseTypedArray(response, value, Uint16Array, 2, obj, key);
-          case "L":
+          case 'L':
             return parseTypedArray(response, value, Int32Array, 4, obj, key);
-          case "l":
+          case 'l':
             return parseTypedArray(response, value, Uint32Array, 4, obj, key);
-          case "G":
+          case 'G':
             return parseTypedArray(response, value, Float32Array, 4, obj, key);
-          case "g":
+          case 'g':
             return parseTypedArray(response, value, Float64Array, 8, obj, key);
-          case "M":
+          case 'M':
             return parseTypedArray(response, value, BigInt64Array, 8, obj, key);
-          case "m":
+          case 'm':
             return parseTypedArray(
               response,
               value,
               BigUint64Array,
               8,
               obj,
-              key
+              key,
             );
-          case "V":
+          case 'V':
             return parseTypedArray(response, value, DataView, 1, obj, key);
-          case "B":
+          case 'B':
             return (
               (obj = parseInt(value.slice(2), 16)),
               response._formData.get(response._prefix + obj)
             );
         }
         switch (value[1]) {
-          case "R":
+          case 'R':
             return parseReadableStream(response, value, void 0);
-          case "r":
-            return parseReadableStream(response, value, "bytes");
-          case "X":
+          case 'r':
+            return parseReadableStream(response, value, 'bytes');
+          case 'X':
             return parseAsyncIterable(response, value, !1);
-          case "x":
+          case 'x':
             return parseAsyncIterable(response, value, !0);
         }
         value = value.slice(1);
@@ -4934,7 +4934,7 @@
     function createResponse(
       bundlerConfig,
       formFieldPrefix,
-      temporaryReferences
+      temporaryReferences,
     ) {
       var backingFormData =
           3 < arguments.length && void 0 !== arguments[3]
@@ -4948,7 +4948,7 @@
         _chunks: chunks,
         _closed: !1,
         _closedReason: null,
-        _temporaryReferences: temporaryReferences
+        _temporaryReferences: temporaryReferences,
       };
     }
     function resolveField(response, key, value) {
@@ -4960,7 +4960,7 @@
         (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));
     }
     function close(response) {
-      reportGlobalError(response, Error("Connection closed."));
+      reportGlobalError(response, Error('Connection closed.'));
     }
     function loadServerReference(bundlerConfig, id, bound) {
       var serverReference = resolveServerReference(bundlerConfig, id);
@@ -4982,7 +4982,7 @@
       close(body);
       body = getChunk(body, 0);
       body.then(function () {});
-      if ("fulfilled" !== body.status) throw body.reason;
+      if ('fulfilled' !== body.status) throw body.reason;
       return body.value;
     }
     function createDrainHandler(destination, request) {
@@ -4998,12 +4998,12 @@
     }
     function startReadingFromDebugChannelReadable(request, stream) {
       function onData(chunk) {
-        if ("string" === typeof chunk) {
+        if ('string' === typeof chunk) {
           if (lastWasPartial) {
             var JSCompiler_temp_const = stringBuffer;
             var JSCompiler_inline_result = new Uint8Array(0);
             JSCompiler_inline_result = stringDecoder.decode(
-              JSCompiler_inline_result
+              JSCompiler_inline_result,
             );
             stringBuffer = JSCompiler_temp_const + JSCompiler_inline_result;
             lastWasPartial = !1;
@@ -5012,7 +5012,7 @@
         } else
           (stringBuffer += stringDecoder.decode(chunk, decoderOptions)),
             (lastWasPartial = !0);
-        chunk = stringBuffer.split("\n");
+        chunk = stringBuffer.split('\n');
         for (
           JSCompiler_temp_const = 0;
           JSCompiler_temp_const < chunk.length - 1;
@@ -5024,7 +5024,7 @@
       function onError(error) {
         abort(
           request,
-          Error("Lost connection to the Debug Channel.", { cause: error })
+          Error('Lost connection to the Debug Channel.', { cause: error }),
         );
       }
       function onClose() {
@@ -5032,20 +5032,20 @@
       }
       var stringDecoder = new util.TextDecoder(),
         lastWasPartial = !1,
-        stringBuffer = "";
-      "function" === typeof stream.addEventListener &&
-      "string" === typeof stream.binaryType
-        ? ((stream.binaryType = "arraybuffer"),
-          stream.addEventListener("message", function (event) {
+        stringBuffer = '';
+      'function' === typeof stream.addEventListener &&
+      'string' === typeof stream.binaryType
+        ? ((stream.binaryType = 'arraybuffer'),
+          stream.addEventListener('message', function (event) {
             onData(event.data);
           }),
-          stream.addEventListener("error", function (event) {
+          stream.addEventListener('error', function (event) {
             onError(event.error);
           }),
-          stream.addEventListener("close", onClose))
-        : (stream.on("data", onData),
-          stream.on("error", onError),
-          stream.on("end", onClose));
+          stream.addEventListener('close', onClose))
+        : (stream.on('data', onData),
+          stream.on('error', onError),
+          stream.on('end', onClose));
     }
     function createFakeWritableFromWebSocket(webSocket) {
       return {
@@ -5057,19 +5057,19 @@
           webSocket.close();
         },
         destroy: function (reason) {
-          "object" === typeof reason &&
+          'object' === typeof reason &&
             null !== reason &&
             (reason = reason.message);
-          "string" === typeof reason
+          'string' === typeof reason
             ? webSocket.close(1011, reason)
             : webSocket.close(1011);
-        }
+        },
       };
     }
     function createFakeWritableFromReadableStreamController(controller) {
       return {
         write: function (chunk) {
-          "string" === typeof chunk && (chunk = textEncoder.encode(chunk));
+          'string' === typeof chunk && (chunk = textEncoder.encode(chunk));
           controller.enqueue(chunk);
           return !0;
         },
@@ -5077,10 +5077,10 @@
           controller.close();
         },
         destroy: function (error) {
-          "function" === typeof controller.error
+          'function' === typeof controller.error
             ? controller.error(error)
             : controller.close();
-        }
+        },
       };
     }
     function startReadingFromDebugChannelReadableStream(request, stream) {
@@ -5093,7 +5093,7 @@
             (buffer = stringDecoder.decode(buffer)))
           : (buffer = stringDecoder.decode(buffer, decoderOptions));
         stringBuffer = _ref + buffer;
-        _ref = stringBuffer.split("\n");
+        _ref = stringBuffer.split('\n');
         for (buffer = 0; buffer < _ref.length - 1; buffer++)
           resolveDebugMessage(request, _ref[buffer]);
         stringBuffer = _ref[_ref.length - 1];
@@ -5103,12 +5103,12 @@
       function error(e) {
         abort(
           request,
-          Error("Lost connection to the Debug Channel.", { cause: e })
+          Error('Lost connection to the Debug Channel.', { cause: e }),
         );
       }
       var reader = stream.getReader(),
         stringDecoder = new util.TextDecoder(),
-        stringBuffer = "";
+        stringBuffer = '';
       reader.read().then(progress).catch(error);
     }
     function createFakeWritableFromNodeReadable(readable) {
@@ -5121,26 +5121,26 @@
         },
         destroy: function (error) {
           readable.destroy(error);
-        }
+        },
       };
     }
-    var stream = require("stream"),
-      util = require("util");
-    require("crypto");
-    var async_hooks = require("async_hooks"),
-      ReactDOM = require("react-dom"),
-      React = require("react"),
-      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-    Symbol.for("react.postpone");
+    var stream = require('stream'),
+      util = require('util');
+    require('crypto');
+    var async_hooks = require('async_hooks'),
+      ReactDOM = require('react-dom'),
+      React = require('react'),
+      REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element'),
+      REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+      REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+      REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+      REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+      REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+      REACT_MEMO_TYPE = Symbol.for('react.memo'),
+      REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+      REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
+    Symbol.for('react.postpone');
     var MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
       ASYNC_ITERATOR = Symbol.asyncIterator,
       scheduleMicrotask = queueMicrotask,
@@ -5148,52 +5148,52 @@
       writtenBytes = 0,
       destinationHasCapacity = !0,
       textEncoder = new util.TextEncoder(),
-      CLIENT_REFERENCE_TAG$1 = Symbol.for("react.client.reference"),
-      SERVER_REFERENCE_TAG = Symbol.for("react.server.reference"),
+      CLIENT_REFERENCE_TAG$1 = Symbol.for('react.client.reference'),
+      SERVER_REFERENCE_TAG = Symbol.for('react.server.reference'),
       FunctionBind = Function.prototype.bind,
       ArraySlice = Array.prototype.slice,
       PROMISE_PROTOTYPE = Promise.prototype,
       deepProxyHandlers = {
         get: function (target, name) {
           switch (name) {
-            case "$$typeof":
+            case '$$typeof':
               return target.$$typeof;
-            case "$$id":
+            case '$$id':
               return target.$$id;
-            case "$$async":
+            case '$$async':
               return target.$$async;
-            case "name":
+            case 'name':
               return target.name;
-            case "displayName":
+            case 'displayName':
               return;
-            case "defaultProps":
+            case 'defaultProps':
               return;
-            case "_debugInfo":
+            case '_debugInfo':
               return;
-            case "toJSON":
+            case 'toJSON':
               return;
             case Symbol.toPrimitive:
               return Object.prototype[Symbol.toPrimitive];
             case Symbol.toStringTag:
               return Object.prototype[Symbol.toStringTag];
-            case "Provider":
+            case 'Provider':
               throw Error(
-                "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+                'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
               );
-            case "then":
+            case 'then':
               throw Error(
-                "Cannot await or return from a thenable. You cannot await a client module from a server component."
+                'Cannot await or return from a thenable. You cannot await a client module from a server component.',
               );
           }
           throw Error(
-            "Cannot access " +
-              (String(target.name) + "." + String(name)) +
-              " on the server. You cannot dot into a client module from a server component. You can only pass the imported name through."
+            'Cannot access ' +
+              (String(target.name) + '.' + String(name)) +
+              ' on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.',
           );
         },
         set: function () {
-          throw Error("Cannot assign to a client module from a server module.");
-        }
+          throw Error('Cannot assign to a client module from a server module.');
+        },
       },
       proxyHandlers$1 = {
         get: function (target, name) {
@@ -5206,7 +5206,7 @@
               value: getReference(target, name),
               writable: !1,
               configurable: !1,
-              enumerable: !1
+              enumerable: !1,
             }),
             Object.defineProperty(target, name, descriptor));
           return descriptor;
@@ -5215,8 +5215,8 @@
           return PROMISE_PROTOTYPE;
         },
         set: function () {
-          throw Error("Cannot assign to a client module from a server module.");
-        }
+          throw Error('Cannot assign to a client module from a server module.');
+        },
       },
       ReactDOMSharedInternals =
         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
@@ -5225,86 +5225,86 @@
       f: previousDispatcher.f,
       r: previousDispatcher.r,
       D: function (href) {
-        if ("string" === typeof href && href) {
+        if ('string' === typeof href && href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "D|" + href;
-            hints.has(key) || (hints.add(key), emitHint(request, "D", href));
+              key = 'D|' + href;
+            hints.has(key) || (hints.add(key), emitHint(request, 'D', href));
           } else previousDispatcher.D(href);
         }
       },
       C: function (href, crossOrigin) {
-        if ("string" === typeof href) {
+        if ('string' === typeof href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
               key =
-                "C|" +
-                (null == crossOrigin ? "null" : crossOrigin) +
-                "|" +
+                'C|' +
+                (null == crossOrigin ? 'null' : crossOrigin) +
+                '|' +
                 href;
             hints.has(key) ||
               (hints.add(key),
-              "string" === typeof crossOrigin
-                ? emitHint(request, "C", [href, crossOrigin])
-                : emitHint(request, "C", href));
+              'string' === typeof crossOrigin
+                ? emitHint(request, 'C', [href, crossOrigin])
+                : emitHint(request, 'C', href));
           } else previousDispatcher.C(href, crossOrigin);
         }
       },
       L: preload,
       m: preloadModule$1,
       X: function (src, options) {
-        if ("string" === typeof src) {
+        if ('string' === typeof src) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "X|" + src;
+              key = 'X|' + src;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "X", [src, options])
-              : emitHint(request, "X", src);
+              ? emitHint(request, 'X', [src, options])
+              : emitHint(request, 'X', src);
           }
           previousDispatcher.X(src, options);
         }
       },
       S: function (href, precedence, options) {
-        if ("string" === typeof href) {
+        if ('string' === typeof href) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "S|" + href;
+              key = 'S|' + href;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "S", [
+              ? emitHint(request, 'S', [
                   href,
-                  "string" === typeof precedence ? precedence : 0,
-                  options
+                  'string' === typeof precedence ? precedence : 0,
+                  options,
                 ])
-              : "string" === typeof precedence
-                ? emitHint(request, "S", [href, precedence])
-                : emitHint(request, "S", href);
+              : 'string' === typeof precedence
+                ? emitHint(request, 'S', [href, precedence])
+                : emitHint(request, 'S', href);
           }
           previousDispatcher.S(href, precedence, options);
         }
       },
       M: function (src, options) {
-        if ("string" === typeof src) {
+        if ('string' === typeof src) {
           var request = resolveRequest();
           if (request) {
             var hints = request.hints,
-              key = "M|" + src;
+              key = 'M|' + src;
             if (hints.has(key)) return;
             hints.add(key);
             return (options = trimOptions(options))
-              ? emitHint(request, "M", [src, options])
-              : emitHint(request, "M", src);
+              ? emitHint(request, 'M', [src, options])
+              : emitHint(request, 'M', src);
           }
           previousDispatcher.M(src, options);
         }
-      }
+      },
     };
     var currentOwner = null,
       getAsyncId = async_hooks.AsyncResource.prototype.asyncId,
@@ -5319,47 +5319,47 @@
       stackTraceCache = new WeakMap(),
       requestStorage = new async_hooks.AsyncLocalStorage(),
       componentStorage = new async_hooks.AsyncLocalStorage(),
-      TEMPORARY_REFERENCE_TAG = Symbol.for("react.temporary.reference"),
+      TEMPORARY_REFERENCE_TAG = Symbol.for('react.temporary.reference'),
       proxyHandlers = {
         get: function (target, name) {
           switch (name) {
-            case "$$typeof":
+            case '$$typeof':
               return target.$$typeof;
-            case "name":
+            case 'name':
               return;
-            case "displayName":
+            case 'displayName':
               return;
-            case "defaultProps":
+            case 'defaultProps':
               return;
-            case "_debugInfo":
+            case '_debugInfo':
               return;
-            case "toJSON":
+            case 'toJSON':
               return;
             case Symbol.toPrimitive:
               return Object.prototype[Symbol.toPrimitive];
             case Symbol.toStringTag:
               return Object.prototype[Symbol.toStringTag];
-            case "Provider":
+            case 'Provider':
               throw Error(
-                "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+                'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
               );
-            case "then":
+            case 'then':
               return;
           }
           throw Error(
-            "Cannot access " +
+            'Cannot access ' +
               String(name) +
-              " on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client."
+              ' on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client.',
           );
         },
         set: function () {
           throw Error(
-            "Cannot assign to a temporary client reference from a server module."
+            'Cannot assign to a temporary client reference from a server module.',
           );
-        }
+        },
       },
       SuspenseException = Error(
-        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
+        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.",
       ),
       suspendedThenable = null,
       currentRequest$1 = null,
@@ -5370,10 +5370,10 @@
         readContext: unsupportedContext,
         use: function (usable) {
           if (
-            (null !== usable && "object" === typeof usable) ||
-            "function" === typeof usable
+            (null !== usable && 'object' === typeof usable) ||
+            'function' === typeof usable
           ) {
-            if ("function" === typeof usable.then) {
+            if ('function' === typeof usable.then) {
               var index = thenableIndexCounter;
               thenableIndexCounter += 1;
               null === thenableState && (thenableState = []);
@@ -5387,12 +5387,12 @@
               usable.value.$$typeof === REACT_CONTEXT_TYPE
             )
               throw Error(
-                "Cannot read a Client Context from a Server Component."
+                'Cannot read a Client Context from a Server Component.',
               );
-            throw Error("Cannot use() an already resolved Client Reference.");
+            throw Error('Cannot use() an already resolved Client Reference.');
           }
           throw Error(
-            "An unsupported type was passed to use(): " + String(usable)
+            'An unsupported type was passed to use(): ' + String(usable),
           );
         },
         useCallback: function (callback) {
@@ -5415,14 +5415,14 @@
         useSyncExternalStore: unsupportedHook,
         useId: function () {
           if (null === currentRequest$1)
-            throw Error("useId can only be used while React is rendering");
+            throw Error('useId can only be used while React is rendering');
           var id = currentRequest$1.identifierCount++;
           return (
-            "_" +
+            '_' +
             currentRequest$1.identifierPrefix +
-            "S_" +
+            'S_' +
             id.toString(32) +
-            "_"
+            '_'
           );
         },
         useHostTransitionStatus: unsupportedHook,
@@ -5436,7 +5436,7 @@
         },
         useCacheRefresh: function () {
           return unsupportedRefresh;
-        }
+        },
       };
     HooksDispatcher.useEffectEvent = unsupportedHook;
     var DefaultAsyncDispatcher = {
@@ -5450,21 +5450,21 @@
       cacheSignal: function () {
         var request = resolveRequest();
         return request ? request.cacheController.signal : null;
-      }
+      },
     };
     DefaultAsyncDispatcher.getOwner = resolveOwner;
     var ReactSharedInternalsServer =
       React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
     if (!ReactSharedInternalsServer)
       throw Error(
-        'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
+        'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.',
       );
     var prefix, suffix;
-    new ("function" === typeof WeakMap ? WeakMap : Map)();
+    new ('function' === typeof WeakMap ? WeakMap : Map)();
     var lastResetTime = 0;
     if (
-      "object" === typeof performance &&
-      "function" === typeof performance.now
+      'object' === typeof performance &&
+      'function' === typeof performance.now
     ) {
       var localPerformance = performance;
       var getCurrentTime = function () {
@@ -5480,7 +5480,7 @@
         react_stack_bottom_frame: function (
           Component,
           props,
-          componentDebugInfo
+          componentDebugInfo,
         ) {
           currentOwner = componentDebugInfo;
           try {
@@ -5488,7 +5488,7 @@
           } finally {
             currentOwner = null;
           }
-        }
+        },
       },
       callComponentInDEV =
         callComponent.react_stack_bottom_frame.bind(callComponent),
@@ -5496,14 +5496,14 @@
         react_stack_bottom_frame: function (lazy) {
           var init = lazy._init;
           return init(lazy._payload);
-        }
+        },
       },
       callLazyInitInDEV =
         callLazyInit.react_stack_bottom_frame.bind(callLazyInit),
       callIterator = {
         react_stack_bottom_frame: function (iterator, progress, error) {
           iterator.next().then(progress, error);
-        }
+        },
       },
       callIteratorInDEV =
         callIterator.react_stack_bottom_frame.bind(callIterator),
@@ -5511,7 +5511,7 @@
       getPrototypeOf = Object.getPrototypeOf,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
-      CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"),
+      CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference'),
       hasOwnProperty = Object.prototype.hasOwnProperty,
       doNotLimit = new WeakSet();
     (function () {
@@ -5519,7 +5519,7 @@
         .createHook({
           init: function (asyncId, type, triggerAsyncId, resource) {
             var trigger = pendingOperations.get(triggerAsyncId);
-            if ("PROMISE" === type)
+            if ('PROMISE' === type)
               if (
                 ((type = async_hooks.executionAsyncId()),
                 type !== triggerAsyncId)
@@ -5552,7 +5552,7 @@
                   end: -1.1,
                   promise: resource,
                   awaited: trigger,
-                  previous: void 0 === type ? null : type
+                  previous: void 0 === type ? null : type,
                 };
               } else
                 (type = resolveOwner()),
@@ -5565,12 +5565,12 @@
                     end: -1.1,
                     promise: new WeakRef(resource),
                     awaited: void 0 === trigger ? null : trigger,
-                    previous: null
+                    previous: null,
                   });
             else if (
-              "Microtask" !== type &&
-              "TickObject" !== type &&
-              "Immediate" !== type
+              'Microtask' !== type &&
+              'TickObject' !== type &&
+              'Immediate' !== type
             )
               if (void 0 === trigger)
                 (trigger = resolveOwner()),
@@ -5585,7 +5585,7 @@
                     end: -1.1,
                     promise: null,
                     awaited: null,
-                    previous: null
+                    previous: null,
                   });
               else {
                 if (2 === trigger.tag || 4 === trigger.tag)
@@ -5601,7 +5601,7 @@
                       end: -1.1,
                       promise: null,
                       awaited: null,
-                      previous: trigger
+                      previous: trigger,
                     });
               }
             else if (void 0 === trigger) return;
@@ -5618,7 +5618,7 @@
                 case 4:
                   lastRanAwait = resolvePromiseOrAwaitNode(
                     asyncId,
-                    performance.now()
+                    performance.now(),
                   );
                   break;
                 case 2:
@@ -5627,7 +5627,7 @@
                 case 3:
                   resolvePromiseOrAwaitNode(
                     asyncId,
-                    performance.now()
+                    performance.now(),
                   ).previous = lastRanAwait;
                   lastRanAwait = null;
                   break;
@@ -5648,7 +5648,7 @@
                   break;
                 default:
                   throw Error(
-                    "A Promise should never be an IO_NODE. This is a bug in React."
+                    'A Promise should never be an IO_NODE. This is a bug in React.',
                   );
               }
               var currentAsyncId = async_hooks.executionAsyncId();
@@ -5665,7 +5665,7 @@
                       end: node.end,
                       promise: node.promise,
                       awaited: node.awaited,
-                      previous: node.previous
+                      previous: node.previous,
                     }),
                     (node.start = node.end),
                     (node.end = performance.now()),
@@ -5675,25 +5675,25 @@
           },
           destroy: function (asyncId) {
             pendingOperations.delete(asyncId);
-          }
+          },
         })
         .enable();
     })();
-    "object" === typeof console &&
+    'object' === typeof console &&
       null !== console &&
-      (patchConsole(console, "assert"),
-      patchConsole(console, "debug"),
-      patchConsole(console, "dir"),
-      patchConsole(console, "dirxml"),
-      patchConsole(console, "error"),
-      patchConsole(console, "group"),
-      patchConsole(console, "groupCollapsed"),
-      patchConsole(console, "groupEnd"),
-      patchConsole(console, "info"),
-      patchConsole(console, "log"),
-      patchConsole(console, "table"),
-      patchConsole(console, "trace"),
-      patchConsole(console, "warn"));
+      (patchConsole(console, 'assert'),
+      patchConsole(console, 'debug'),
+      patchConsole(console, 'dir'),
+      patchConsole(console, 'dirxml'),
+      patchConsole(console, 'error'),
+      patchConsole(console, 'group'),
+      patchConsole(console, 'groupCollapsed'),
+      patchConsole(console, 'groupEnd'),
+      patchConsole(console, 'info'),
+      patchConsole(console, 'log'),
+      patchConsole(console, 'table'),
+      patchConsole(console, 'trace'),
+      patchConsole(console, 'warn'));
     var ObjectPrototype = Object.prototype,
       stringify = JSON.stringify,
       ABORTING = 12,
@@ -5713,16 +5713,16 @@
     Chunk.prototype = Object.create(Promise.prototype);
     Chunk.prototype.then = function (resolve, reject) {
       switch (this.status) {
-        case "resolved_model":
+        case 'resolved_model':
           initializeModelChunk(this);
       }
       switch (this.status) {
-        case "fulfilled":
+        case 'fulfilled':
           resolve(this.value);
           break;
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           resolve &&
             (null === this.value && (this.value = []),
             this.value.push(resolve));
@@ -5747,16 +5747,16 @@
       var formData = new FormData(),
         action = null;
       body.forEach(function (value, key) {
-        key.startsWith("$ACTION_")
-          ? key.startsWith("$ACTION_REF_")
-            ? ((value = "$ACTION_" + key.slice(12) + ":"),
+        key.startsWith('$ACTION_')
+          ? key.startsWith('$ACTION_REF_')
+            ? ((value = '$ACTION_' + key.slice(12) + ':'),
               (value = decodeBoundActionMetaData(body, serverManifest, value)),
               (action = loadServerReference(
                 serverManifest,
                 value.id,
-                value.bound
+                value.bound,
               )))
-            : key.startsWith("$ACTION_ID_") &&
+            : key.startsWith('$ACTION_ID_') &&
               ((value = key.slice(11)),
               (action = loadServerReference(serverManifest, value, null)))
           : formData.append(key, value);
@@ -5768,12 +5768,12 @@
           });
     };
     exports.decodeFormState = function (actionResult, body, serverManifest) {
-      var keyPath = body.get("$ACTION_KEY");
-      if ("string" !== typeof keyPath) return Promise.resolve(null);
+      var keyPath = body.get('$ACTION_KEY');
+      if ('string' !== typeof keyPath) return Promise.resolve(null);
       var metaData = null;
       body.forEach(function (value, key) {
-        key.startsWith("$ACTION_REF_") &&
-          ((value = "$ACTION_" + key.slice(12) + ":"),
+        key.startsWith('$ACTION_REF_') &&
+          ((value = '$ACTION_' + key.slice(12) + ':'),
           (metaData = decodeBoundActionMetaData(body, serverManifest, value)));
       });
       if (null === metaData) return Promise.resolve(null);
@@ -5785,16 +5785,16 @@
       });
     };
     exports.decodeReply = function (body, webpackMap, options) {
-      if ("string" === typeof body) {
+      if ('string' === typeof body) {
         var form = new FormData();
-        form.append("0", body);
+        form.append('0', body);
         body = form;
       }
       body = createResponse(
         webpackMap,
-        "",
+        '',
         options ? options.temporaryReferences : void 0,
-        body
+        body,
       );
       webpackMap = getChunk(body, 0);
       close(body);
@@ -5803,7 +5803,7 @@
     exports.decodeReplyFromAsyncIterable = function (
       iterable,
       webpackMap,
-      options
+      options,
     ) {
       function progress(entry) {
         if (entry.done) close(response);
@@ -5811,7 +5811,7 @@
           var _entry$value = entry.value;
           entry = _entry$value[0];
           _entry$value = _entry$value[1];
-          "string" === typeof _entry$value
+          'string' === typeof _entry$value
             ? resolveField(response, entry, _entry$value)
             : response._formData.append(entry, _entry$value);
           iterator.next().then(progress, error);
@@ -5819,14 +5819,14 @@
       }
       function error(reason) {
         reportGlobalError(response, reason);
-        "function" === typeof iterator.throw &&
+        'function' === typeof iterator.throw &&
           iterator.throw(reason).then(error, error);
       }
       var iterator = iterable[ASYNC_ITERATOR](),
         response = createResponse(
           webpackMap,
-          "",
-          options ? options.temporaryReferences : void 0
+          '',
+          options ? options.temporaryReferences : void 0,
         );
       iterator.next().then(progress, error);
       return getChunk(response, 0);
@@ -5834,35 +5834,35 @@
     exports.decodeReplyFromBusboy = function (
       busboyStream,
       webpackMap,
-      options
+      options,
     ) {
       var response = createResponse(
           webpackMap,
-          "",
-          options ? options.temporaryReferences : void 0
+          '',
+          options ? options.temporaryReferences : void 0,
         ),
         pendingFiles = 0,
         queuedFields = [];
-      busboyStream.on("field", function (name, value) {
+      busboyStream.on('field', function (name, value) {
         0 < pendingFiles
           ? queuedFields.push(name, value)
           : resolveField(response, name, value);
       });
-      busboyStream.on("file", function (name, value, _ref2) {
+      busboyStream.on('file', function (name, value, _ref2) {
         var filename = _ref2.filename,
           mimeType = _ref2.mimeType;
-        if ("base64" === _ref2.encoding.toLowerCase())
+        if ('base64' === _ref2.encoding.toLowerCase())
           throw Error(
-            "React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it."
+            "React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.",
           );
         pendingFiles++;
         var JSCompiler_object_inline_chunks_250 = [];
-        value.on("data", function (chunk) {
+        value.on('data', function (chunk) {
           JSCompiler_object_inline_chunks_250.push(chunk);
         });
-        value.on("end", function () {
+        value.on('end', function () {
           var blob = new Blob(JSCompiler_object_inline_chunks_250, {
-            type: mimeType
+            type: mimeType,
           });
           response._formData.append(name, blob, filename);
           pendingFiles--;
@@ -5871,16 +5871,16 @@
               resolveField(
                 response,
                 queuedFields[blob],
-                queuedFields[blob + 1]
+                queuedFields[blob + 1],
               );
             queuedFields.length = 0;
           }
         });
       });
-      busboyStream.on("finish", function () {
+      busboyStream.on('finish', function () {
         close(response);
       });
-      busboyStream.on("error", function (err) {
+      busboyStream.on('error', function (err) {
         reportGlobalError(response, err);
       });
       return getChunk(response, 0);
@@ -5894,11 +5894,11 @@
             var writable,
               stream = new ReadableStream(
                 {
-                  type: "bytes",
+                  type: 'bytes',
                   start: function (controller) {
                     writable =
                       createFakeWritableFromReadableStreamController(
-                        controller
+                        controller,
                       );
                   },
                   pull: function () {
@@ -5907,9 +5907,9 @@
                   cancel: function (reason) {
                     request.destination = null;
                     abort(request, reason);
-                  }
+                  },
                 },
-                { highWaterMark: 0 }
+                { highWaterMark: 0 },
               );
             resolve({ prelude: stream });
           },
@@ -5920,7 +5920,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          !1
+          !1,
         );
         if (options && options.signal) {
           var signal = options.signal;
@@ -5928,9 +5928,9 @@
           else {
             var listener = function () {
               abort(request, signal.reason);
-              signal.removeEventListener("abort", listener);
+              signal.removeEventListener('abort', listener);
             };
-            signal.addEventListener("abort", listener);
+            signal.addEventListener('abort', listener);
           }
         }
         startWork(request);
@@ -5945,7 +5945,7 @@
             var readable = new stream.Readable({
                 read: function () {
                   startFlowing(request, writable);
-                }
+                },
               }),
               writable = createFakeWritableFromNodeReadable(readable);
             resolve({ prelude: readable });
@@ -5957,7 +5957,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          !1
+          !1,
         );
         if (options && options.signal) {
           var signal = options.signal;
@@ -5965,9 +5965,9 @@
           else {
             var listener = function () {
               abort(request, signal.reason);
-              signal.removeEventListener("abort", listener);
+              signal.removeEventListener('abort', listener);
             };
-            signal.addEventListener("abort", listener);
+            signal.addEventListener('abort', listener);
           }
         }
         startWork(request);
@@ -5976,39 +5976,39 @@
     exports.registerClientReference = function (
       proxyImplementation,
       id,
-      exportName
+      exportName,
     ) {
       return registerClientReferenceImpl(
         proxyImplementation,
-        id + "#" + exportName,
-        !1
+        id + '#' + exportName,
+        !1,
       );
     };
     exports.registerServerReference = function (reference, id, exportName) {
       return Object.defineProperties(reference, {
         $$typeof: { value: SERVER_REFERENCE_TAG },
         $$id: {
-          value: null === exportName ? id : id + "#" + exportName,
-          configurable: !0
+          value: null === exportName ? id : id + '#' + exportName,
+          configurable: !0,
         },
         $$bound: { value: null, configurable: !0 },
-        $$location: { value: Error("react-stack-top-frame"), configurable: !0 },
-        bind: { value: bind, configurable: !0 }
+        $$location: { value: Error('react-stack-top-frame'), configurable: !0 },
+        bind: { value: bind, configurable: !0 },
       });
     };
     exports.renderToPipeableStream = function (model, webpackMap, options) {
       var debugChannel = options ? options.debugChannel : void 0,
         debugChannelReadable =
           void 0 === debugChannel ||
-          ("function" !== typeof debugChannel.read &&
-            "number" !== typeof debugChannel.readyState)
+          ('function' !== typeof debugChannel.read &&
+            'number' !== typeof debugChannel.readyState)
             ? void 0
             : debugChannel;
       debugChannel =
         void 0 !== debugChannel
-          ? "function" === typeof debugChannel.write
+          ? 'function' === typeof debugChannel.write
             ? debugChannel
-            : "function" === typeof debugChannel.send
+            : 'function' === typeof debugChannel.send
               ? createFakeWritableFromWebSocket(debugChannel)
               : void 0
           : void 0;
@@ -6021,7 +6021,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          void 0 !== debugChannelReadable
+          void 0 !== debugChannelReadable,
         ),
         hasStartedFlowing = !1;
       startWork(request);
@@ -6032,31 +6032,31 @@
         pipe: function (destination) {
           if (hasStartedFlowing)
             throw Error(
-              "React currently only supports piping to one writable stream."
+              'React currently only supports piping to one writable stream.',
             );
           hasStartedFlowing = !0;
           startFlowing(request, destination);
-          destination.on("drain", createDrainHandler(destination, request));
+          destination.on('drain', createDrainHandler(destination, request));
           destination.on(
-            "error",
+            'error',
             createCancelHandler(
               request,
-              "The destination stream errored while writing data."
-            )
+              'The destination stream errored while writing data.',
+            ),
           );
           if (void 0 === debugChannelReadable)
             destination.on(
-              "close",
+              'close',
               createCancelHandler(
                 request,
-                "The destination stream closed early."
-              )
+                'The destination stream closed early.',
+              ),
             );
           return destination;
         },
         abort: function (reason) {
           abort(request, reason);
-        }
+        },
       };
     };
     exports.renderToReadableStream = function (model, webpackMap, options) {
@@ -6077,7 +6077,7 @@
           options ? options.temporaryReferences : void 0,
           options ? options.environmentName : void 0,
           options ? options.filterStackFrame : void 0,
-          void 0 !== debugChannelReadable
+          void 0 !== debugChannelReadable,
         );
       if (options && options.signal) {
         var signal = options.signal;
@@ -6085,36 +6085,36 @@
         else {
           var listener = function () {
             abort(request, signal.reason);
-            signal.removeEventListener("abort", listener);
+            signal.removeEventListener('abort', listener);
           };
-          signal.addEventListener("abort", listener);
+          signal.addEventListener('abort', listener);
         }
       }
       if (void 0 !== debugChannelWritable) {
         var debugWritable;
         new ReadableStream(
           {
-            type: "bytes",
+            type: 'bytes',
             start: function (controller) {
               debugWritable =
                 createFakeWritableFromReadableStreamController(controller);
             },
             pull: function () {
               startFlowingDebug(request, debugWritable);
-            }
+            },
           },
-          { highWaterMark: 0 }
+          { highWaterMark: 0 },
         ).pipeTo(debugChannelWritable);
       }
       void 0 !== debugChannelReadable &&
         startReadingFromDebugChannelReadableStream(
           request,
-          debugChannelReadable
+          debugChannelReadable,
         );
       var writable;
       return new ReadableStream(
         {
-          type: "bytes",
+          type: 'bytes',
           start: function (controller) {
             writable =
               createFakeWritableFromReadableStreamController(controller);
@@ -6126,9 +6126,9 @@
           cancel: function (reason) {
             request.destination = null;
             abort(request, reason);
-          }
+          },
         },
-        { highWaterMark: 0 }
+        { highWaterMark: 0 },
       );
     };
   })();
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.node.unbundled.production.js packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.js
--- npm/react-server-dom-webpack@19.2.0/cjs/react-server-dom-webpack-server.node.unbundled.production.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.js	2025-12-17 14:32:45
@@ -8,31 +8,31 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-"use strict";
-var stream = require("stream"),
-  util = require("util");
-require("crypto");
-var async_hooks = require("async_hooks"),
-  ReactDOM = require("react-dom"),
-  React = require("react"),
-  REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
-  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-  REACT_MEMO_TYPE = Symbol.for("react.memo"),
-  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-Symbol.for("react.postpone");
+'use strict';
+var stream = require('stream'),
+  util = require('util');
+require('crypto');
+var async_hooks = require('async_hooks'),
+  ReactDOM = require('react-dom'),
+  React = require('react'),
+  REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element'),
+  REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
+  REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
+  REACT_CONTEXT_TYPE = Symbol.for('react.context'),
+  REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
+  REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
+  REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
+  REACT_MEMO_TYPE = Symbol.for('react.memo'),
+  REACT_LAZY_TYPE = Symbol.for('react.lazy'),
+  REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
+Symbol.for('react.postpone');
 var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
 function getIteratorFn(maybeIterable) {
-  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  if (null === maybeIterable || 'object' !== typeof maybeIterable) return null;
   maybeIterable =
     (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-    maybeIterable["@@iterator"];
-  return "function" === typeof maybeIterable ? maybeIterable : null;
+    maybeIterable['@@iterator'];
+  return 'function' === typeof maybeIterable ? maybeIterable : null;
 }
 var ASYNC_ITERATOR = Symbol.asyncIterator,
   scheduleMicrotask = queueMicrotask,
@@ -44,13 +44,13 @@
   destinationHasCapacity = destinationHasCapacity && destination;
 }
 function writeChunkAndReturn(destination, chunk) {
-  if ("string" === typeof chunk) {
+  if ('string' === typeof chunk) {
     if (0 !== chunk.length)
       if (2048 < 3 * chunk.length)
         0 < writtenBytes &&
           (writeToDestination(
             destination,
-            currentView.subarray(0, writtenBytes)
+            currentView.subarray(0, writtenBytes),
           ),
           (currentView = new Uint8Array(2048)),
           (writtenBytes = 0)),
@@ -64,12 +64,12 @@
         read < chunk.length &&
           (writeToDestination(
             destination,
-            currentView.subarray(0, writtenBytes)
+            currentView.subarray(0, writtenBytes),
           ),
           (currentView = new Uint8Array(2048)),
           (writtenBytes = textEncoder.encodeInto(
             chunk.slice(read),
-            currentView
+            currentView,
           ).written));
         2048 === writtenBytes &&
           (writeToDestination(destination, currentView),
@@ -82,7 +82,7 @@
         ? (0 < writtenBytes &&
             (writeToDestination(
               destination,
-              currentView.subarray(0, writtenBytes)
+              currentView.subarray(0, writtenBytes),
             ),
             (currentView = new Uint8Array(2048)),
             (writtenBytes = 0)),
@@ -107,17 +107,17 @@
 }
 var textEncoder = new util.TextEncoder();
 function byteLengthOfChunk(chunk) {
-  return "string" === typeof chunk
-    ? Buffer.byteLength(chunk, "utf8")
+  return 'string' === typeof chunk
+    ? Buffer.byteLength(chunk, 'utf8')
     : chunk.byteLength;
 }
-var CLIENT_REFERENCE_TAG$1 = Symbol.for("react.client.reference"),
-  SERVER_REFERENCE_TAG = Symbol.for("react.server.reference");
+var CLIENT_REFERENCE_TAG$1 = Symbol.for('react.client.reference'),
+  SERVER_REFERENCE_TAG = Symbol.for('react.server.reference');
 function registerClientReferenceImpl(proxyImplementation, id, async) {
   return Object.defineProperties(proxyImplementation, {
     $$typeof: { value: CLIENT_REFERENCE_TAG$1 },
     $$id: { value: id },
-    $$async: { value: async }
+    $$async: { value: async },
   });
 }
 var FunctionBind = Function.prototype.bind,
@@ -133,7 +133,7 @@
       $$typeof: $$typeof,
       $$id: $$id,
       $$bound: args,
-      bind: { value: bind, configurable: !0 }
+      bind: { value: bind, configurable: !0 },
     });
   }
   return newFn;
@@ -142,114 +142,114 @@
   deepProxyHandlers = {
     get: function (target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "$$id":
+        case '$$id':
           return target.$$id;
-        case "$$async":
+        case '$$async':
           return target.$$async;
-        case "name":
+        case 'name':
           return target.name;
-        case "displayName":
+        case 'displayName':
           return;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "Provider":
+        case 'Provider':
           throw Error(
-            "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+            'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
           );
-        case "then":
+        case 'then':
           throw Error(
-            "Cannot await or return from a thenable. You cannot await a client module from a server component."
+            'Cannot await or return from a thenable. You cannot await a client module from a server component.',
           );
       }
       throw Error(
-        "Cannot access " +
-          (String(target.name) + "." + String(name)) +
-          " on the server. You cannot dot into a client module from a server component. You can only pass the imported name through."
+        'Cannot access ' +
+          (String(target.name) + '.' + String(name)) +
+          ' on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.',
       );
     },
     set: function () {
-      throw Error("Cannot assign to a client module from a server module.");
-    }
+      throw Error('Cannot assign to a client module from a server module.');
+    },
   };
 function getReference(target, name) {
   switch (name) {
-    case "$$typeof":
+    case '$$typeof':
       return target.$$typeof;
-    case "$$id":
+    case '$$id':
       return target.$$id;
-    case "$$async":
+    case '$$async':
       return target.$$async;
-    case "name":
+    case 'name':
       return target.name;
-    case "defaultProps":
+    case 'defaultProps':
       return;
-    case "_debugInfo":
+    case '_debugInfo':
       return;
-    case "toJSON":
+    case 'toJSON':
       return;
     case Symbol.toPrimitive:
       return Object.prototype[Symbol.toPrimitive];
     case Symbol.toStringTag:
       return Object.prototype[Symbol.toStringTag];
-    case "__esModule":
+    case '__esModule':
       var moduleId = target.$$id;
       target.default = registerClientReferenceImpl(
         function () {
           throw Error(
-            "Attempted to call the default export of " +
+            'Attempted to call the default export of ' +
               moduleId +
-              " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+              " from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
           );
         },
-        target.$$id + "#",
-        target.$$async
+        target.$$id + '#',
+        target.$$async,
       );
       return !0;
-    case "then":
+    case 'then':
       if (target.then) return target.then;
       if (target.$$async) return;
       var clientReference = registerClientReferenceImpl({}, target.$$id, !0),
         proxy = new Proxy(clientReference, proxyHandlers$1);
-      target.status = "fulfilled";
+      target.status = 'fulfilled';
       target.value = proxy;
       return (target.then = registerClientReferenceImpl(
         function (resolve) {
           return Promise.resolve(resolve(proxy));
         },
-        target.$$id + "#then",
-        !1
+        target.$$id + '#then',
+        !1,
       ));
   }
-  if ("symbol" === typeof name)
+  if ('symbol' === typeof name)
     throw Error(
-      "Cannot read Symbol exports. Only named exports are supported on a client module imported on the server."
+      'Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.',
     );
   clientReference = target[name];
   clientReference ||
     ((clientReference = registerClientReferenceImpl(
       function () {
         throw Error(
-          "Attempted to call " +
+          'Attempted to call ' +
             String(name) +
-            "() from the server but " +
+            '() from the server but ' +
             String(name) +
-            " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+            " is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
         );
       },
-      target.$$id + "#" + name,
-      target.$$async
+      target.$$id + '#' + name,
+      target.$$async,
     )),
-    Object.defineProperty(clientReference, "name", { value: name }),
+    Object.defineProperty(clientReference, 'name', { value: name }),
     (clientReference = target[name] =
       new Proxy(clientReference, deepProxyHandlers)));
   return clientReference;
@@ -265,7 +265,7 @@
           value: getReference(target, name),
           writable: !1,
           configurable: !1,
-          enumerable: !1
+          enumerable: !1,
         }),
         Object.defineProperty(target, name, descriptor));
       return descriptor;
@@ -274,8 +274,8 @@
       return PROMISE_PROTOTYPE;
     },
     set: function () {
-      throw Error("Cannot assign to a client module from a server module.");
-    }
+      throw Error('Cannot assign to a client module from a server module.');
+    },
   },
   ReactDOMSharedInternals =
     ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
@@ -289,119 +289,119 @@
   m: preloadModule$1,
   X: preinitScript,
   S: preinitStyle,
-  M: preinitModuleScript
+  M: preinitModuleScript,
 };
 function prefetchDNS(href) {
-  if ("string" === typeof href && href) {
+  if ('string' === typeof href && href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "D|" + href;
-      hints.has(key) || (hints.add(key), emitHint(request, "D", href));
+        key = 'D|' + href;
+      hints.has(key) || (hints.add(key), emitHint(request, 'D', href));
     } else previousDispatcher.D(href);
   }
 }
 function preconnect(href, crossOrigin) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "C|" + (null == crossOrigin ? "null" : crossOrigin) + "|" + href;
+        key = 'C|' + (null == crossOrigin ? 'null' : crossOrigin) + '|' + href;
       hints.has(key) ||
         (hints.add(key),
-        "string" === typeof crossOrigin
-          ? emitHint(request, "C", [href, crossOrigin])
-          : emitHint(request, "C", href));
+        'string' === typeof crossOrigin
+          ? emitHint(request, 'C', [href, crossOrigin])
+          : emitHint(request, 'C', href));
     } else previousDispatcher.C(href, crossOrigin);
   }
 }
 function preload(href, as, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "L";
-      if ("image" === as && options) {
+        key = 'L';
+      if ('image' === as && options) {
         var imageSrcSet = options.imageSrcSet,
           imageSizes = options.imageSizes,
-          uniquePart = "";
-        "string" === typeof imageSrcSet && "" !== imageSrcSet
-          ? ((uniquePart += "[" + imageSrcSet + "]"),
-            "string" === typeof imageSizes &&
-              (uniquePart += "[" + imageSizes + "]"))
-          : (uniquePart += "[][]" + href);
-        key += "[image]" + uniquePart;
-      } else key += "[" + as + "]" + href;
+          uniquePart = '';
+        'string' === typeof imageSrcSet && '' !== imageSrcSet
+          ? ((uniquePart += '[' + imageSrcSet + ']'),
+            'string' === typeof imageSizes &&
+              (uniquePart += '[' + imageSizes + ']'))
+          : (uniquePart += '[][]' + href);
+        key += '[image]' + uniquePart;
+      } else key += '[' + as + ']' + href;
       hints.has(key) ||
         (hints.add(key),
         (options = trimOptions(options))
-          ? emitHint(request, "L", [href, as, options])
-          : emitHint(request, "L", [href, as]));
+          ? emitHint(request, 'L', [href, as, options])
+          : emitHint(request, 'L', [href, as]));
     } else previousDispatcher.L(href, as, options);
   }
 }
 function preloadModule$1(href, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "m|" + href;
+        key = 'm|' + href;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "m", [href, options])
-        : emitHint(request, "m", href);
+        ? emitHint(request, 'm', [href, options])
+        : emitHint(request, 'm', href);
     }
     previousDispatcher.m(href, options);
   }
 }
 function preinitStyle(href, precedence, options) {
-  if ("string" === typeof href) {
+  if ('string' === typeof href) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "S|" + href;
+        key = 'S|' + href;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "S", [
+        ? emitHint(request, 'S', [
             href,
-            "string" === typeof precedence ? precedence : 0,
-            options
+            'string' === typeof precedence ? precedence : 0,
+            options,
           ])
-        : "string" === typeof precedence
-          ? emitHint(request, "S", [href, precedence])
-          : emitHint(request, "S", href);
+        : 'string' === typeof precedence
+          ? emitHint(request, 'S', [href, precedence])
+          : emitHint(request, 'S', href);
     }
     previousDispatcher.S(href, precedence, options);
   }
 }
 function preinitScript(src, options) {
-  if ("string" === typeof src) {
+  if ('string' === typeof src) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "X|" + src;
+        key = 'X|' + src;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "X", [src, options])
-        : emitHint(request, "X", src);
+        ? emitHint(request, 'X', [src, options])
+        : emitHint(request, 'X', src);
     }
     previousDispatcher.X(src, options);
   }
 }
 function preinitModuleScript(src, options) {
-  if ("string" === typeof src) {
+  if ('string' === typeof src) {
     var request = resolveRequest();
     if (request) {
       var hints = request.hints,
-        key = "M|" + src;
+        key = 'M|' + src;
       if (hints.has(key)) return;
       hints.add(key);
       return (options = trimOptions(options))
-        ? emitHint(request, "M", [src, options])
-        : emitHint(request, "M", src);
+        ? emitHint(request, 'M', [src, options])
+        : emitHint(request, 'M', src);
     }
     previousDispatcher.M(src, options);
   }
@@ -418,63 +418,63 @@
 }
 function getChildFormatContext(parentContext, type, props) {
   switch (type) {
-    case "img":
+    case 'img':
       type = props.src;
       var srcSet = props.srcSet;
       if (
         !(
-          "lazy" === props.loading ||
+          'lazy' === props.loading ||
           (!type && !srcSet) ||
-          ("string" !== typeof type && null != type) ||
-          ("string" !== typeof srcSet && null != srcSet) ||
-          "low" === props.fetchPriority ||
+          ('string' !== typeof type && null != type) ||
+          ('string' !== typeof srcSet && null != srcSet) ||
+          'low' === props.fetchPriority ||
           parentContext & 3
         ) &&
-        ("string" !== typeof type ||
-          ":" !== type[4] ||
-          ("d" !== type[0] && "D" !== type[0]) ||
-          ("a" !== type[1] && "A" !== type[1]) ||
-          ("t" !== type[2] && "T" !== type[2]) ||
-          ("a" !== type[3] && "A" !== type[3])) &&
-        ("string" !== typeof srcSet ||
-          ":" !== srcSet[4] ||
-          ("d" !== srcSet[0] && "D" !== srcSet[0]) ||
-          ("a" !== srcSet[1] && "A" !== srcSet[1]) ||
-          ("t" !== srcSet[2] && "T" !== srcSet[2]) ||
-          ("a" !== srcSet[3] && "A" !== srcSet[3]))
+        ('string' !== typeof type ||
+          ':' !== type[4] ||
+          ('d' !== type[0] && 'D' !== type[0]) ||
+          ('a' !== type[1] && 'A' !== type[1]) ||
+          ('t' !== type[2] && 'T' !== type[2]) ||
+          ('a' !== type[3] && 'A' !== type[3])) &&
+        ('string' !== typeof srcSet ||
+          ':' !== srcSet[4] ||
+          ('d' !== srcSet[0] && 'D' !== srcSet[0]) ||
+          ('a' !== srcSet[1] && 'A' !== srcSet[1]) ||
+          ('t' !== srcSet[2] && 'T' !== srcSet[2]) ||
+          ('a' !== srcSet[3] && 'A' !== srcSet[3]))
       ) {
-        var sizes = "string" === typeof props.sizes ? props.sizes : void 0;
+        var sizes = 'string' === typeof props.sizes ? props.sizes : void 0;
         var input = props.crossOrigin;
-        preload(type || "", "image", {
+        preload(type || '', 'image', {
           imageSrcSet: srcSet,
           imageSizes: sizes,
           crossOrigin:
-            "string" === typeof input
-              ? "use-credentials" === input
+            'string' === typeof input
+              ? 'use-credentials' === input
                 ? input
-                : ""
+                : ''
               : void 0,
           integrity: props.integrity,
           type: props.type,
           fetchPriority: props.fetchPriority,
-          referrerPolicy: props.referrerPolicy
+          referrerPolicy: props.referrerPolicy,
         });
       }
       return parentContext;
-    case "link":
+    case 'link':
       type = props.rel;
       srcSet = props.href;
       if (
         !(
           parentContext & 1 ||
           null != props.itemProp ||
-          "string" !== typeof type ||
-          "string" !== typeof srcSet ||
-          "" === srcSet
+          'string' !== typeof type ||
+          'string' !== typeof srcSet ||
+          '' === srcSet
         )
       )
         switch (type) {
-          case "preload":
+          case 'preload':
             preload(srcSet, props.as, {
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
@@ -484,85 +484,85 @@
               referrerPolicy: props.referrerPolicy,
               imageSrcSet: props.imageSrcSet,
               imageSizes: props.imageSizes,
-              media: props.media
+              media: props.media,
             });
             break;
-          case "modulepreload":
+          case 'modulepreload':
             preloadModule$1(srcSet, {
               as: props.as,
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
-              nonce: props.nonce
+              nonce: props.nonce,
             });
             break;
-          case "stylesheet":
-            preload(srcSet, "stylesheet", {
+          case 'stylesheet':
+            preload(srcSet, 'stylesheet', {
               crossOrigin: props.crossOrigin,
               integrity: props.integrity,
               nonce: props.nonce,
               type: props.type,
               fetchPriority: props.fetchPriority,
               referrerPolicy: props.referrerPolicy,
-              media: props.media
+              media: props.media,
             });
         }
       return parentContext;
-    case "picture":
+    case 'picture':
       return parentContext | 2;
-    case "noscript":
+    case 'noscript':
       return parentContext | 1;
     default:
       return parentContext;
   }
 }
 var requestStorage = new async_hooks.AsyncLocalStorage(),
-  TEMPORARY_REFERENCE_TAG = Symbol.for("react.temporary.reference"),
+  TEMPORARY_REFERENCE_TAG = Symbol.for('react.temporary.reference'),
   proxyHandlers = {
     get: function (target, name) {
       switch (name) {
-        case "$$typeof":
+        case '$$typeof':
           return target.$$typeof;
-        case "name":
+        case 'name':
           return;
-        case "displayName":
+        case 'displayName':
           return;
-        case "defaultProps":
+        case 'defaultProps':
           return;
-        case "_debugInfo":
+        case '_debugInfo':
           return;
-        case "toJSON":
+        case 'toJSON':
           return;
         case Symbol.toPrimitive:
           return Object.prototype[Symbol.toPrimitive];
         case Symbol.toStringTag:
           return Object.prototype[Symbol.toStringTag];
-        case "Provider":
+        case 'Provider':
           throw Error(
-            "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+            'Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.',
           );
-        case "then":
+        case 'then':
           return;
       }
       throw Error(
-        "Cannot access " +
+        'Cannot access ' +
           String(name) +
-          " on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client."
+          ' on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client.',
       );
     },
     set: function () {
       throw Error(
-        "Cannot assign to a temporary client reference from a server module."
+        'Cannot assign to a temporary client reference from a server module.',
       );
-    }
+    },
   };
 function createTemporaryReference(temporaryReferences, id) {
   var reference = Object.defineProperties(
     function () {
       throw Error(
-        "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+        "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.",
       );
     },
-    { $$typeof: { value: TEMPORARY_REFERENCE_TAG } }
+    { $$typeof: { value: TEMPORARY_REFERENCE_TAG } },
   );
   reference = new Proxy(reference, proxyHandlers);
   temporaryReferences.set(reference, id);
@@ -570,7 +570,7 @@
 }
 function noop() {}
 var SuspenseException = Error(
-  "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
+  "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.",
 );
 function trackUsedThenable(thenableState, thenable, index) {
   index = thenableState[index];
@@ -578,35 +578,35 @@
     ? thenableState.push(thenable)
     : index !== thenable && (thenable.then(noop, noop), (thenable = index));
   switch (thenable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return thenable.value;
-    case "rejected":
+    case 'rejected':
       throw thenable.reason;
     default:
-      "string" === typeof thenable.status
+      'string' === typeof thenable.status
         ? thenable.then(noop, noop)
         : ((thenableState = thenable),
-          (thenableState.status = "pending"),
+          (thenableState.status = 'pending'),
           thenableState.then(
             function (fulfilledValue) {
-              if ("pending" === thenable.status) {
+              if ('pending' === thenable.status) {
                 var fulfilledThenable = thenable;
-                fulfilledThenable.status = "fulfilled";
+                fulfilledThenable.status = 'fulfilled';
                 fulfilledThenable.value = fulfilledValue;
               }
             },
             function (error) {
-              if ("pending" === thenable.status) {
+              if ('pending' === thenable.status) {
                 var rejectedThenable = thenable;
-                rejectedThenable.status = "rejected";
+                rejectedThenable.status = 'rejected';
                 rejectedThenable.reason = error;
               }
-            }
+            },
           ));
       switch (thenable.status) {
-        case "fulfilled":
+        case 'fulfilled':
           return thenable.value;
-        case "rejected":
+        case 'rejected':
           throw thenable.reason;
       }
       suspendedThenable = thenable;
@@ -617,7 +617,7 @@
 function getSuspendedThenable() {
   if (null === suspendedThenable)
     throw Error(
-      "Expected a suspended thenable. This is a bug in React. Please file an issue."
+      'Expected a suspended thenable. This is a bug in React. Please file an issue.',
     );
   var thenable = suspendedThenable;
   suspendedThenable = null;
@@ -664,30 +664,30 @@
   },
   useCacheRefresh: function () {
     return unsupportedRefresh;
-  }
+  },
 };
 HooksDispatcher.useEffectEvent = unsupportedHook;
 function unsupportedHook() {
-  throw Error("This Hook is not supported in Server Components.");
+  throw Error('This Hook is not supported in Server Components.');
 }
 function unsupportedRefresh() {
-  throw Error("Refreshing the cache is not supported in Server Components.");
+  throw Error('Refreshing the cache is not supported in Server Components.');
 }
 function unsupportedContext() {
-  throw Error("Cannot read a Client Context from a Server Component.");
+  throw Error('Cannot read a Client Context from a Server Component.');
 }
 function useId() {
   if (null === currentRequest$1)
-    throw Error("useId can only be used while React is rendering");
+    throw Error('useId can only be used while React is rendering');
   var id = currentRequest$1.identifierCount++;
-  return "_" + currentRequest$1.identifierPrefix + "S_" + id.toString(32) + "_";
+  return '_' + currentRequest$1.identifierPrefix + 'S_' + id.toString(32) + '_';
 }
 function use(usable) {
   if (
-    (null !== usable && "object" === typeof usable) ||
-    "function" === typeof usable
+    (null !== usable && 'object' === typeof usable) ||
+    'function' === typeof usable
   ) {
-    if ("function" === typeof usable.then) {
+    if ('function' === typeof usable.then) {
       var index = thenableIndexCounter;
       thenableIndexCounter += 1;
       null === thenableState && (thenableState = []);
@@ -697,10 +697,10 @@
   }
   if (usable.$$typeof === CLIENT_REFERENCE_TAG$1) {
     if (null != usable.value && usable.value.$$typeof === REACT_CONTEXT_TYPE)
-      throw Error("Cannot read a Client Context from a Server Component.");
-    throw Error("Cannot use() an already resolved Client Reference.");
+      throw Error('Cannot read a Client Context from a Server Component.');
+    throw Error('Cannot use() an already resolved Client Reference.');
   }
-  throw Error("An unsupported type was passed to use(): " + String(usable));
+  throw Error('An unsupported type was passed to use(): ' + String(usable));
 }
 var DefaultAsyncDispatcher = {
     getCacheForType: function (resourceType) {
@@ -717,13 +717,13 @@
     cacheSignal: function () {
       var request = resolveRequest();
       return request ? request.cacheController.signal : null;
-    }
+    },
   },
   ReactSharedInternalsServer =
     React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
 if (!ReactSharedInternalsServer)
   throw Error(
-    'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
+    'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.',
   );
 var isArrayImpl = Array.isArray,
   getPrototypeOf = Object.getPrototypeOf;
@@ -733,35 +733,35 @@
 }
 function describeValueForErrorMessage(value) {
   switch (typeof value) {
-    case "string":
+    case 'string':
       return JSON.stringify(
-        10 >= value.length ? value : value.slice(0, 10) + "..."
+        10 >= value.length ? value : value.slice(0, 10) + '...',
       );
-    case "object":
-      if (isArrayImpl(value)) return "[...]";
+    case 'object':
+      if (isArrayImpl(value)) return '[...]';
       if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
-        return "client";
+        return 'client';
       value = objectName(value);
-      return "Object" === value ? "{...}" : value;
-    case "function":
+      return 'Object' === value ? '{...}' : value;
+    case 'function':
       return value.$$typeof === CLIENT_REFERENCE_TAG
-        ? "client"
+        ? 'client'
         : (value = value.displayName || value.name)
-          ? "function " + value
-          : "function";
+          ? 'function ' + value
+          : 'function';
     default:
       return String(value);
   }
 }
 function describeElementType(type) {
-  if ("string" === typeof type) return type;
+  if ('string' === typeof type) return type;
   switch (type) {
     case REACT_SUSPENSE_TYPE:
-      return "Suspense";
+      return 'Suspense';
     case REACT_SUSPENSE_LIST_TYPE:
-      return "SuspenseList";
+      return 'SuspenseList';
   }
-  if ("object" === typeof type)
+  if ('object' === typeof type)
     switch (type.$$typeof) {
       case REACT_FORWARD_REF_TYPE:
         return describeElementType(type.render);
@@ -774,45 +774,45 @@
           return describeElementType(type(payload));
         } catch (x) {}
     }
-  return "";
+  return '';
 }
-var CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference");
+var CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference');
 function describeObjectForErrorMessage(objectOrArray, expandedName) {
   var objKind = objectName(objectOrArray);
-  if ("Object" !== objKind && "Array" !== objKind) return objKind;
+  if ('Object' !== objKind && 'Array' !== objKind) return objKind;
   objKind = -1;
   var length = 0;
   if (isArrayImpl(objectOrArray)) {
-    var str = "[";
+    var str = '[';
     for (var i = 0; i < objectOrArray.length; i++) {
-      0 < i && (str += ", ");
+      0 < i && (str += ', ');
       var value = objectOrArray[i];
       value =
-        "object" === typeof value && null !== value
+        'object' === typeof value && null !== value
           ? describeObjectForErrorMessage(value)
           : describeValueForErrorMessage(value);
-      "" + i === expandedName
+      '' + i === expandedName
         ? ((objKind = str.length), (length = value.length), (str += value))
         : (str =
             10 > value.length && 40 > str.length + value.length
               ? str + value
-              : str + "...");
+              : str + '...');
     }
-    str += "]";
+    str += ']';
   } else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
-    str = "<" + describeElementType(objectOrArray.type) + "/>";
+    str = '<' + describeElementType(objectOrArray.type) + '/>';
   else {
-    if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
-    str = "{";
+    if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return 'client';
+    str = '{';
     i = Object.keys(objectOrArray);
     for (value = 0; value < i.length; value++) {
-      0 < value && (str += ", ");
+      0 < value && (str += ', ');
       var name = i[value],
         encodedKey = JSON.stringify(name);
-      str += ('"' + name + '"' === encodedKey ? name : encodedKey) + ": ";
+      str += ('"' + name + '"' === encodedKey ? name : encodedKey) + ': ';
       encodedKey = objectOrArray[name];
       encodedKey =
-        "object" === typeof encodedKey && null !== encodedKey
+        'object' === typeof encodedKey && null !== encodedKey
           ? describeObjectForErrorMessage(encodedKey)
           : describeValueForErrorMessage(encodedKey);
       name === expandedName
@@ -822,16 +822,16 @@
         : (str =
             10 > encodedKey.length && 40 > str.length + encodedKey.length
               ? str + encodedKey
-              : str + "...");
+              : str + '...');
     }
-    str += "}";
+    str += '}';
   }
   return void 0 === expandedName
     ? str
     : -1 < objKind && 0 < length
-      ? ((objectOrArray = " ".repeat(objKind) + "^".repeat(length)),
-        "\n  " + str + "\n  " + objectOrArray)
-      : "\n  " + str;
+      ? ((objectOrArray = ' '.repeat(objKind) + '^'.repeat(length)),
+        '\n  ' + str + '\n  ' + objectOrArray)
+      : '\n  ' + str;
 }
 var hasOwnProperty = Object.prototype.hasOwnProperty,
   ObjectPrototype = Object.prototype,
@@ -848,13 +848,13 @@
   onAllReady,
   onFatalError,
   identifierPrefix,
-  temporaryReferences
+  temporaryReferences,
 ) {
   if (
     null !== ReactSharedInternalsServer.A &&
     ReactSharedInternalsServer.A !== DefaultAsyncDispatcher
   )
-    throw Error("Currently React only supports one RSC renderer at a time.");
+    throw Error('Currently React only supports one RSC renderer at a time.');
   ReactSharedInternalsServer.A = DefaultAsyncDispatcher;
   var abortSet = new Set(),
     pingedTasks = [],
@@ -879,7 +879,7 @@
   this.writtenServerReferences = new Map();
   this.writtenObjects = new WeakMap();
   this.temporaryReferences = temporaryReferences;
-  this.identifierPrefix = identifierPrefix || "";
+  this.identifierPrefix = identifierPrefix || '';
   this.identifierCount = 1;
   this.taintCleanupQueue = [];
   this.onError = void 0 === onError ? defaultErrorHandler : onError;
@@ -902,14 +902,14 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   switch (thenable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return (
         (newTask.model = thenable.value), pingTask(request, newTask), newTask.id
       );
-    case "rejected":
+    case 'rejected':
       return erroredTask(request, newTask, thenable.reason), newTask.id;
     default:
       if (12 === request.status)
@@ -922,18 +922,18 @@
               finishAbortedTask(newTask, request, task)),
           newTask.id
         );
-      "string" !== typeof thenable.status &&
-        ((thenable.status = "pending"),
+      'string' !== typeof thenable.status &&
+        ((thenable.status = 'pending'),
         thenable.then(
           function (fulfilledValue) {
-            "pending" === thenable.status &&
-              ((thenable.status = "fulfilled"),
+            'pending' === thenable.status &&
+              ((thenable.status = 'fulfilled'),
               (thenable.value = fulfilledValue));
           },
           function (error) {
-            "pending" === thenable.status &&
-              ((thenable.status = "rejected"), (thenable.reason = error));
-          }
+            'pending' === thenable.status &&
+              ((thenable.status = 'rejected'), (thenable.reason = error));
+          },
         ));
   }
   thenable.then(
@@ -944,7 +944,7 @@
     function (reason) {
       0 === newTask.status &&
         (erroredTask(request, newTask, reason), enqueueFlush(request));
-    }
+    },
   );
   return newTask.id;
 }
@@ -953,12 +953,12 @@
     if (0 === streamTask.status)
       if (entry.done)
         (streamTask.status = 1),
-          (entry = streamTask.id.toString(16) + ":C\n"),
+          (entry = streamTask.id.toString(16) + ':C\n'),
           request.completedRegularChunks.push(entry),
           request.abortableTasks.delete(streamTask),
           request.cacheController.signal.removeEventListener(
-            "abort",
-            abortStream
+            'abort',
+            abortStream,
           ),
           enqueueFlush(request),
           callOnAllReadyIfReady(request);
@@ -975,7 +975,7 @@
   }
   function error(reason) {
     0 === streamTask.status &&
-      (request.cacheController.signal.removeEventListener("abort", abortStream),
+      (request.cacheController.signal.removeEventListener('abort', abortStream),
       erroredTask(request, streamTask, reason),
       enqueueFlush(request),
       reader.cancel(reason).then(error, error));
@@ -983,7 +983,7 @@
   function abortStream() {
     if (0 === streamTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortStream);
+      signal.removeEventListener('abort', abortStream);
       signal = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(streamTask),
@@ -996,7 +996,7 @@
   var supportsBYOB = stream.supportsBYOB;
   if (void 0 === supportsBYOB)
     try {
-      stream.getReader({ mode: "byob" }).releaseLock(), (supportsBYOB = !0);
+      stream.getReader({ mode: 'byob' }).releaseLock(), (supportsBYOB = !0);
     } catch (x) {
       supportsBYOB = !1;
     }
@@ -1007,12 +1007,12 @@
       task.keyPath,
       task.implicitSlot,
       task.formatContext,
-      request.abortableTasks
+      request.abortableTasks,
     );
   request.pendingChunks++;
-  task = streamTask.id.toString(16) + ":" + (supportsBYOB ? "r" : "R") + "\n";
+  task = streamTask.id.toString(16) + ':' + (supportsBYOB ? 'r' : 'R') + '\n';
   request.completedRegularChunks.push(task);
-  request.cacheController.signal.addEventListener("abort", abortStream);
+  request.cacheController.signal.addEventListener('abort', abortStream);
   reader.read().then(progress, error);
   return serializeByValueID(streamTask.id);
 }
@@ -1022,19 +1022,19 @@
       if (entry.done) {
         streamTask.status = 1;
         if (void 0 === entry.value)
-          var endStreamRow = streamTask.id.toString(16) + ":C\n";
+          var endStreamRow = streamTask.id.toString(16) + ':C\n';
         else
           try {
             var chunkId = outlineModelWithFormatContext(
               request,
               entry.value,
-              0
+              0,
             );
             endStreamRow =
               streamTask.id.toString(16) +
-              ":C" +
+              ':C' +
               stringify(serializeByValueID(chunkId)) +
-              "\n";
+              '\n';
           } catch (x) {
             error(x);
             return;
@@ -1042,8 +1042,8 @@
         request.completedRegularChunks.push(endStreamRow);
         request.abortableTasks.delete(streamTask);
         request.cacheController.signal.removeEventListener(
-          "abort",
-          abortIterable
+          'abort',
+          abortIterable,
         );
         enqueueFlush(request);
         callOnAllReadyIfReady(request);
@@ -1061,18 +1061,18 @@
   function error(reason) {
     0 === streamTask.status &&
       (request.cacheController.signal.removeEventListener(
-        "abort",
-        abortIterable
+        'abort',
+        abortIterable,
       ),
       erroredTask(request, streamTask, reason),
       enqueueFlush(request),
-      "function" === typeof iterator.throw &&
+      'function' === typeof iterator.throw &&
         iterator.throw(reason).then(error, error));
   }
   function abortIterable() {
     if (0 === streamTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortIterable);
+      signal.removeEventListener('abort', abortIterable);
       var reason = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(streamTask),
@@ -1080,7 +1080,7 @@
           finishHaltedTask(streamTask, request))
         : (erroredTask(request, streamTask, signal.reason),
           enqueueFlush(request));
-      "function" === typeof iterator.throw &&
+      'function' === typeof iterator.throw &&
         iterator.throw(reason).then(error, error);
     }
   }
@@ -1091,44 +1091,44 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   request.pendingChunks++;
-  task = streamTask.id.toString(16) + ":" + (iterable ? "x" : "X") + "\n";
+  task = streamTask.id.toString(16) + ':' + (iterable ? 'x' : 'X') + '\n';
   request.completedRegularChunks.push(task);
-  request.cacheController.signal.addEventListener("abort", abortIterable);
+  request.cacheController.signal.addEventListener('abort', abortIterable);
   iterator.next().then(progress, error);
   return serializeByValueID(streamTask.id);
 }
 function emitHint(request, code, model) {
   model = stringify(model);
-  request.completedHintChunks.push(":H" + code + model + "\n");
+  request.completedHintChunks.push(':H' + code + model + '\n');
   enqueueFlush(request);
 }
 function readThenable(thenable) {
-  if ("fulfilled" === thenable.status) return thenable.value;
-  if ("rejected" === thenable.status) throw thenable.reason;
+  if ('fulfilled' === thenable.status) return thenable.value;
+  if ('rejected' === thenable.status) throw thenable.reason;
   throw thenable;
 }
 function createLazyWrapperAroundWakeable(request, task, wakeable) {
   switch (wakeable.status) {
-    case "fulfilled":
+    case 'fulfilled':
       return wakeable.value;
-    case "rejected":
+    case 'rejected':
       break;
     default:
-      "string" !== typeof wakeable.status &&
-        ((wakeable.status = "pending"),
+      'string' !== typeof wakeable.status &&
+        ((wakeable.status = 'pending'),
         wakeable.then(
           function (fulfilledValue) {
-            "pending" === wakeable.status &&
-              ((wakeable.status = "fulfilled"),
+            'pending' === wakeable.status &&
+              ((wakeable.status = 'fulfilled'),
               (wakeable.value = fulfilledValue));
           },
           function (error) {
-            "pending" === wakeable.status &&
-              ((wakeable.status = "rejected"), (wakeable.reason = error));
-          }
+            'pending' === wakeable.status &&
+              ((wakeable.status = 'rejected'), (wakeable.reason = error));
+          },
         ));
   }
   return { $$typeof: REACT_LAZY_TYPE, _payload: wakeable, _init: readThenable };
@@ -1136,12 +1136,12 @@
 function voidHandler() {}
 function processServerComponentReturnValue(request, task, Component, result) {
   if (
-    "object" !== typeof result ||
+    'object' !== typeof result ||
     null === result ||
     result.$$typeof === CLIENT_REFERENCE_TAG$1
   )
     return result;
-  if ("function" === typeof result.then)
+  if ('function' === typeof result.then)
     return createLazyWrapperAroundWakeable(request, task, result);
   var iteratorFn = getIteratorFn(result);
   return iteratorFn
@@ -1150,8 +1150,8 @@
         return iteratorFn.call(result);
       }),
       request)
-    : "function" !== typeof result[ASYNC_ITERATOR] ||
-        ("function" === typeof ReadableStream &&
+    : 'function' !== typeof result[ASYNC_ITERATOR] ||
+        ('function' === typeof ReadableStream &&
           result instanceof ReadableStream)
       ? result
       : ((request = {}),
@@ -1168,9 +1168,9 @@
   props = Component(props, void 0);
   if (12 === request.status)
     throw (
-      ("object" === typeof props &&
+      ('object' === typeof props &&
         null !== props &&
-        "function" === typeof props.then &&
+        'function' === typeof props.then &&
         props.$$typeof !== CLIENT_REFERENCE_TAG$1 &&
         props.then(voidHandler, voidHandler),
       null)
@@ -1179,9 +1179,9 @@
   Component = task.keyPath;
   prevThenableState = task.implicitSlot;
   null !== key
-    ? (task.keyPath = null === Component ? key : Component + "," + key)
+    ? (task.keyPath = null === Component ? key : Component + ',' + key)
     : null === Component && (task.implicitSlot = !0);
-  request = renderModelDestructive(request, task, emptyRoot, "", props);
+  request = renderModelDestructive(request, task, emptyRoot, '', props);
   task.keyPath = Component;
   task.implicitSlot = prevThenableState;
   return request;
@@ -1192,7 +1192,7 @@
         REACT_ELEMENT_TYPE,
         REACT_FRAGMENT_TYPE,
         task.keyPath,
-        { children: children }
+        { children: children },
       ]),
       task.implicitSlot ? [request] : request)
     : children;
@@ -1205,7 +1205,7 @@
     task.keyPath,
     task.implicitSlot,
     task.formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   pingTask(request, task);
   return serializeLazyID(task.id);
@@ -1213,10 +1213,10 @@
 function renderElement(request, task, type, key, ref, props) {
   if (null !== ref && void 0 !== ref)
     throw Error(
-      "Refs cannot be used in Server Components, nor passed to Client Components."
+      'Refs cannot be used in Server Components, nor passed to Client Components.',
     );
   if (
-    "function" === typeof type &&
+    'function' === typeof type &&
     type.$$typeof !== CLIENT_REFERENCE_TAG$1 &&
     type.$$typeof !== TEMPORARY_REFERENCE_TAG
   )
@@ -1229,15 +1229,15 @@
         request,
         task,
         emptyRoot,
-        "",
-        props.children
+        '',
+        props.children,
       )),
       (task.implicitSlot = type),
       props
     );
   if (
     null != type &&
-    "object" === typeof type &&
+    'object' === typeof type &&
     type.$$typeof !== CLIENT_REFERENCE_TAG$1
   )
     switch (type.$$typeof) {
@@ -1252,7 +1252,7 @@
         return renderElement(request, task, type.type, key, ref, props);
     }
   else
-    "string" === typeof type &&
+    'string' === typeof type &&
       ((ref = task.formatContext),
       (init = getChildFormatContext(ref, type, props)),
       ref !== init &&
@@ -1262,7 +1262,7 @@
   key = task.keyPath;
   null === request
     ? (request = key)
-    : null !== key && (request = key + "," + request);
+    : null !== key && (request = key + ',' + request);
   props = [REACT_ELEMENT_TYPE, type, request, props];
   task = task.implicitSlot && null !== request ? [props] : props;
   return task;
@@ -1286,11 +1286,11 @@
   keyPath,
   implicitSlot,
   formatContext,
-  abortSet
+  abortSet,
 ) {
   request.pendingChunks++;
   var id = request.nextChunkId++;
-  "object" !== typeof model ||
+  'object' !== typeof model ||
     null === model ||
     null !== keyPath ||
     implicitSlot ||
@@ -1315,13 +1315,13 @@
           task,
           this,
           parentPropertyName,
-          value
+          value,
         );
       } catch (thrownValue) {
         if (
           ((parentPropertyName = task.model),
           (parentPropertyName =
-            "object" === typeof parentPropertyName &&
+            'object' === typeof parentPropertyName &&
             null !== parentPropertyName &&
             (parentPropertyName.$$typeof === REACT_ELEMENT_TYPE ||
               parentPropertyName.$$typeof === REACT_LAZY_TYPE)),
@@ -1343,9 +1343,9 @@
             thrownValue === SuspenseException
               ? getSuspendedThenable()
               : thrownValue),
-          "object" === typeof value &&
+          'object' === typeof value &&
             null !== value &&
-            "function" === typeof value.then)
+            'function' === typeof value.then)
         ) {
           JSCompiler_inline_result = createTask(
             request,
@@ -1353,7 +1353,7 @@
             task.keyPath,
             task.implicitSlot,
             task.formatContext,
-            request.abortableTasks
+            request.abortableTasks,
           );
           var ping = JSCompiler_inline_result.ping;
           value.then(ping, ping);
@@ -1377,44 +1377,44 @@
       }
       return JSCompiler_inline_result;
     },
-    thenableState: null
+    thenableState: null,
   };
   abortSet.add(task);
   return task;
 }
 function serializeByValueID(id) {
-  return "$" + id.toString(16);
+  return '$' + id.toString(16);
 }
 function serializeLazyID(id) {
-  return "$L" + id.toString(16);
+  return '$L' + id.toString(16);
 }
 function encodeReferenceChunk(request, id, reference) {
   request = stringify(reference);
-  return id.toString(16) + ":" + request + "\n";
+  return id.toString(16) + ':' + request + '\n';
 }
 function serializeClientReference(
   request,
   parent,
   parentPropertyName,
-  clientReference
+  clientReference,
 ) {
   var clientReferenceKey = clientReference.$$async
-      ? clientReference.$$id + "#async"
+      ? clientReference.$$id + '#async'
       : clientReference.$$id,
     writtenClientReferences = request.writtenClientReferences,
     existingId = writtenClientReferences.get(clientReferenceKey);
   if (void 0 !== existingId)
-    return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+    return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
       ? serializeLazyID(existingId)
       : serializeByValueID(existingId);
   try {
     var config = request.bundlerConfig,
       modulePath = clientReference.$$id;
-    existingId = "";
+    existingId = '';
     var resolvedModuleData = config[modulePath];
     if (resolvedModuleData) existingId = resolvedModuleData.name;
     else {
-      var idx = modulePath.lastIndexOf("#");
+      var idx = modulePath.lastIndexOf('#');
       -1 !== idx &&
         ((existingId = modulePath.slice(idx + 1)),
         (resolvedModuleData = config[modulePath.slice(0, idx)]));
@@ -1422,14 +1422,14 @@
         throw Error(
           'Could not find the module "' +
             modulePath +
-            '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.'
+            '" in the React Client Manifest. This is probably a bug in the React Server Components bundler.',
         );
     }
     if (!0 === resolvedModuleData.async && !0 === clientReference.$$async)
       throw Error(
         'The module "' +
           modulePath +
-          '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.'
+          '" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.',
       );
     var JSCompiler_inline_result =
       !0 === resolvedModuleData.async || !0 === clientReference.$$async
@@ -1438,10 +1438,10 @@
     request.pendingChunks++;
     var importId = request.nextChunkId++,
       json = stringify(JSCompiler_inline_result),
-      processedChunk = importId.toString(16) + ":I" + json + "\n";
+      processedChunk = importId.toString(16) + ':I' + json + '\n';
     request.completedImportChunks.push(processedChunk);
     writtenClientReferences.set(clientReferenceKey, importId);
-    return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+    return parent[0] === REACT_ELEMENT_TYPE && '1' === parentPropertyName
       ? serializeLazyID(importId)
       : serializeByValueID(importId);
   } catch (x) {
@@ -1461,7 +1461,7 @@
     null,
     !1,
     formatContext,
-    request.abortableTasks
+    request.abortableTasks,
   );
   retryTask(request, value);
   return value.id;
@@ -1476,7 +1476,7 @@
   function progress(entry) {
     if (0 === newTask.status)
       if (entry.done)
-        request.cacheController.signal.removeEventListener("abort", abortBlob),
+        request.cacheController.signal.removeEventListener('abort', abortBlob),
           pingTask(request, newTask);
       else
         return (
@@ -1485,7 +1485,7 @@
   }
   function error(reason) {
     0 === newTask.status &&
-      (request.cacheController.signal.removeEventListener("abort", abortBlob),
+      (request.cacheController.signal.removeEventListener('abort', abortBlob),
       erroredTask(request, newTask, reason),
       enqueueFlush(request),
       reader.cancel(reason).then(error, error));
@@ -1493,7 +1493,7 @@
   function abortBlob() {
     if (0 === newTask.status) {
       var signal = request.cacheController.signal;
-      signal.removeEventListener("abort", abortBlob);
+      signal.removeEventListener('abort', abortBlob);
       signal = signal.reason;
       21 === request.type
         ? (request.abortableTasks.delete(newTask),
@@ -1506,9 +1506,9 @@
   var model = [blob.type],
     newTask = createTask(request, model, null, !1, 0, request.abortableTasks),
     reader = blob.stream().getReader();
-  request.cacheController.signal.addEventListener("abort", abortBlob);
+  request.cacheController.signal.addEventListener('abort', abortBlob);
   reader.read().then(progress).catch(error);
-  return "$B" + newTask.id.toString(16);
+  return '$B' + newTask.id.toString(16);
 }
 var modelRoot = !1;
 function renderModelDestructive(
@@ -1516,12 +1516,12 @@
   task,
   parent,
   parentPropertyName,
-  value
+  value,
 ) {
   task.model = value;
-  if (value === REACT_ELEMENT_TYPE) return "$";
+  if (value === REACT_ELEMENT_TYPE) return '$';
   if (null === value) return null;
-  if ("object" === typeof value) {
+  if ('object' === typeof value) {
     switch (value.$$typeof) {
       case REACT_ELEMENT_TYPE:
         var elementReference = null,
@@ -1532,10 +1532,10 @@
             if (modelRoot === value) modelRoot = null;
             else return existingReference;
           else
-            -1 === parentPropertyName.indexOf(":") &&
+            -1 === parentPropertyName.indexOf(':') &&
               ((parent = writtenObjects.get(parent)),
               void 0 !== parent &&
-                ((elementReference = parent + ":" + parentPropertyName),
+                ((elementReference = parent + ':' + parentPropertyName),
                 writtenObjects.set(value, elementReference)));
         }
         if (3200 < serializedSize) return deferTask(request, task);
@@ -1547,9 +1547,9 @@
           value.type,
           value.key,
           void 0 !== parent ? parent : null,
-          parentPropertyName
+          parentPropertyName,
         );
-        "object" === typeof request &&
+        'object' === typeof request &&
           null !== request &&
           null !== elementReference &&
           (writtenObjects.has(request) ||
@@ -1561,10 +1561,10 @@
         parentPropertyName = value._init;
         value = parentPropertyName(value._payload);
         if (12 === request.status) throw null;
-        return renderModelDestructive(request, task, emptyRoot, "", value);
+        return renderModelDestructive(request, task, emptyRoot, '', value);
       case REACT_LEGACY_ELEMENT_TYPE:
         throw Error(
-          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
+          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.',
         );
     }
     if (value.$$typeof === CLIENT_REFERENCE_TAG$1)
@@ -1572,24 +1572,24 @@
         request,
         parent,
         parentPropertyName,
-        value
+        value,
       );
     if (
       void 0 !== request.temporaryReferences &&
       ((elementReference = request.temporaryReferences.get(value)),
       void 0 !== elementReference)
     )
-      return "$T" + elementReference;
+      return '$T' + elementReference;
     elementReference = request.writtenObjects;
     writtenObjects = elementReference.get(value);
-    if ("function" === typeof value.then) {
+    if ('function' === typeof value.then) {
       if (void 0 !== writtenObjects) {
         if (null !== task.keyPath || task.implicitSlot)
-          return "$@" + serializeThenable(request, task, value).toString(16);
+          return '$@' + serializeThenable(request, task, value).toString(16);
         if (modelRoot === value) modelRoot = null;
         else return writtenObjects;
       }
-      request = "$@" + serializeThenable(request, task, value).toString(16);
+      request = '$@' + serializeThenable(request, task, value).toString(16);
       elementReference.set(value, request);
       return request;
     }
@@ -1600,92 +1600,92 @@
         modelRoot = null;
       } else return writtenObjects;
     else if (
-      -1 === parentPropertyName.indexOf(":") &&
+      -1 === parentPropertyName.indexOf(':') &&
       ((writtenObjects = elementReference.get(parent)),
       void 0 !== writtenObjects)
     ) {
       existingReference = parentPropertyName;
       if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
         switch (parentPropertyName) {
-          case "1":
-            existingReference = "type";
+          case '1':
+            existingReference = 'type';
             break;
-          case "2":
-            existingReference = "key";
+          case '2':
+            existingReference = 'key';
             break;
-          case "3":
-            existingReference = "props";
+          case '3':
+            existingReference = 'props';
             break;
-          case "4":
-            existingReference = "_owner";
+          case '4':
+            existingReference = '_owner';
         }
-      elementReference.set(value, writtenObjects + ":" + existingReference);
+      elementReference.set(value, writtenObjects + ':' + existingReference);
     }
     if (isArrayImpl(value)) return renderFragment(request, task, value);
     if (value instanceof Map)
       return (
         (value = Array.from(value)),
-        "$Q" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$Q' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
     if (value instanceof Set)
       return (
         (value = Array.from(value)),
-        "$W" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$W' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
-    if ("function" === typeof FormData && value instanceof FormData)
+    if ('function' === typeof FormData && value instanceof FormData)
       return (
         (value = Array.from(value.entries())),
-        "$K" + outlineModelWithFormatContext(request, value, 0).toString(16)
+        '$K' + outlineModelWithFormatContext(request, value, 0).toString(16)
       );
-    if (value instanceof Error) return "$Z";
+    if (value instanceof Error) return '$Z';
     if (value instanceof ArrayBuffer)
-      return serializeTypedArray(request, "A", new Uint8Array(value));
+      return serializeTypedArray(request, 'A', new Uint8Array(value));
     if (value instanceof Int8Array)
-      return serializeTypedArray(request, "O", value);
+      return serializeTypedArray(request, 'O', value);
     if (value instanceof Uint8Array)
-      return serializeTypedArray(request, "o", value);
+      return serializeTypedArray(request, 'o', value);
     if (value instanceof Uint8ClampedArray)
-      return serializeTypedArray(request, "U", value);
+      return serializeTypedArray(request, 'U', value);
     if (value instanceof Int16Array)
-      return serializeTypedArray(request, "S", value);
+      return serializeTypedArray(request, 'S', value);
     if (value instanceof Uint16Array)
-      return serializeTypedArray(request, "s", value);
+      return serializeTypedArray(request, 's', value);
     if (value instanceof Int32Array)
-      return serializeTypedArray(request, "L", value);
+      return serializeTypedArray(request, 'L', value);
     if (value instanceof Uint32Array)
-      return serializeTypedArray(request, "l", value);
+      return serializeTypedArray(request, 'l', value);
     if (value instanceof Float32Array)
-      return serializeTypedArray(request, "G", value);
+      return serializeTypedArray(request, 'G', value);
     if (value instanceof Float64Array)
-      return serializeTypedArray(request, "g", value);
+      return serializeTypedArray(request, 'g', value);
     if (value instanceof BigInt64Array)
-      return serializeTypedArray(request, "M", value);
+      return serializeTypedArray(request, 'M', value);
     if (value instanceof BigUint64Array)
-      return serializeTypedArray(request, "m", value);
+      return serializeTypedArray(request, 'm', value);
     if (value instanceof DataView)
-      return serializeTypedArray(request, "V", value);
-    if ("function" === typeof Blob && value instanceof Blob)
+      return serializeTypedArray(request, 'V', value);
+    if ('function' === typeof Blob && value instanceof Blob)
       return serializeBlob(request, value);
     if ((elementReference = getIteratorFn(value)))
       return (
         (parentPropertyName = elementReference.call(value)),
         parentPropertyName === value
           ? ((value = Array.from(parentPropertyName)),
-            "$i" +
+            '$i' +
               outlineModelWithFormatContext(request, value, 0).toString(16))
           : renderFragment(request, task, Array.from(parentPropertyName))
       );
-    if ("function" === typeof ReadableStream && value instanceof ReadableStream)
+    if ('function' === typeof ReadableStream && value instanceof ReadableStream)
       return serializeReadableStream(request, task, value);
     elementReference = value[ASYNC_ITERATOR];
-    if ("function" === typeof elementReference)
+    if ('function' === typeof elementReference)
       return (
         null !== task.keyPath
           ? ((request = [
               REACT_ELEMENT_TYPE,
               REACT_FRAGMENT_TYPE,
               task.keyPath,
-              { children: value }
+              { children: value },
             ]),
             (request = task.implicitSlot ? [request] : request))
           : ((parentPropertyName = elementReference.call(value)),
@@ -1693,29 +1693,29 @@
               request,
               task,
               value,
-              parentPropertyName
+              parentPropertyName,
             ))),
         request
       );
-    if (value instanceof Date) return "$D" + value.toJSON();
+    if (value instanceof Date) return '$D' + value.toJSON();
     request = getPrototypeOf(value);
     if (
       request !== ObjectPrototype &&
       (null === request || null !== getPrototypeOf(request))
     )
       throw Error(
-        "Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported." +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+        'Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.' +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     return value;
   }
-  if ("string" === typeof value) {
+  if ('string' === typeof value) {
     serializedSize += value.length;
     if (
-      "Z" === value[value.length - 1] &&
+      'Z' === value[value.length - 1] &&
       parent[parentPropertyName] instanceof Date
     )
-      return "$D" + value;
+      return '$D' + value;
     if (1024 <= value.length && null !== byteLengthOfChunk)
       return (
         request.pendingChunks++,
@@ -1723,35 +1723,35 @@
         emitTextChunk(request, task, value, !1),
         serializeByValueID(task)
       );
-    request = "$" === value[0] ? "$" + value : value;
+    request = '$' === value[0] ? '$' + value : value;
     return request;
   }
-  if ("boolean" === typeof value) return value;
-  if ("number" === typeof value)
+  if ('boolean' === typeof value) return value;
+  if ('number' === typeof value)
     return Number.isFinite(value)
       ? 0 === value && -Infinity === 1 / value
-        ? "$-0"
+        ? '$-0'
         : value
       : Infinity === value
-        ? "$Infinity"
+        ? '$Infinity'
         : -Infinity === value
-          ? "$-Infinity"
-          : "$NaN";
-  if ("undefined" === typeof value) return "$undefined";
-  if ("function" === typeof value) {
+          ? '$-Infinity'
+          : '$NaN';
+  if ('undefined' === typeof value) return '$undefined';
+  if ('function' === typeof value) {
     if (value.$$typeof === CLIENT_REFERENCE_TAG$1)
       return serializeClientReference(
         request,
         parent,
         parentPropertyName,
-        value
+        value,
       );
     if (value.$$typeof === SERVER_REFERENCE_TAG)
       return (
         (task = request.writtenServerReferences),
         (parentPropertyName = task.get(value)),
         void 0 !== parentPropertyName
-          ? (request = "$F" + parentPropertyName.toString(16))
+          ? (request = '$F' + parentPropertyName.toString(16))
           : ((parentPropertyName = value.$$bound),
             (parentPropertyName =
               null === parentPropertyName
@@ -1760,33 +1760,33 @@
             (request = outlineModelWithFormatContext(
               request,
               { id: value.$$id, bound: parentPropertyName },
-              0
+              0,
             )),
             task.set(value, request),
-            (request = "$F" + request.toString(16))),
+            (request = '$F' + request.toString(16))),
         request
       );
     if (
       void 0 !== request.temporaryReferences &&
       ((request = request.temporaryReferences.get(value)), void 0 !== request)
     )
-      return "$T" + request;
+      return '$T' + request;
     if (value.$$typeof === TEMPORARY_REFERENCE_TAG)
       throw Error(
-        "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+        'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
       );
     if (/^on[A-Z]/.test(parentPropertyName))
       throw Error(
-        "Event handlers cannot be passed to Client Component props." +
+        'Event handlers cannot be passed to Client Component props.' +
           describeObjectForErrorMessage(parent, parentPropertyName) +
-          "\nIf you need interactivity, consider converting part of this to a Client Component."
+          '\nIf you need interactivity, consider converting part of this to a Client Component.',
       );
     throw Error(
       'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.' +
-        describeObjectForErrorMessage(parent, parentPropertyName)
+        describeObjectForErrorMessage(parent, parentPropertyName),
     );
   }
-  if ("symbol" === typeof value) {
+  if ('symbol' === typeof value) {
     task = request.writtenSymbols;
     elementReference = task.get(value);
     if (void 0 !== elementReference)
@@ -1794,27 +1794,27 @@
     elementReference = value.description;
     if (Symbol.for(elementReference) !== value)
       throw Error(
-        "Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" +
-          (value.description + ") cannot be found among global symbols.") +
-          describeObjectForErrorMessage(parent, parentPropertyName)
+        'Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(' +
+          (value.description + ') cannot be found among global symbols.') +
+          describeObjectForErrorMessage(parent, parentPropertyName),
       );
     request.pendingChunks++;
     parentPropertyName = request.nextChunkId++;
     parent = encodeReferenceChunk(
       request,
       parentPropertyName,
-      "$S" + elementReference
+      '$S' + elementReference,
     );
     request.completedImportChunks.push(parent);
     task.set(value, parentPropertyName);
     return serializeByValueID(parentPropertyName);
   }
-  if ("bigint" === typeof value) return "$n" + value.toString(10);
+  if ('bigint' === typeof value) return '$n' + value.toString(10);
   throw Error(
-    "Type " +
+    'Type ' +
       typeof value +
-      " is not supported in Client Component props." +
-      describeObjectForErrorMessage(parent, parentPropertyName)
+      ' is not supported in Client Component props.' +
+      describeObjectForErrorMessage(parent, parentPropertyName),
   );
 }
 function logRecoverableError(request, error) {
@@ -1825,13 +1825,13 @@
   } finally {
     currentRequest = prevRequest;
   }
-  if (null != errorDigest && "string" !== typeof errorDigest)
+  if (null != errorDigest && 'string' !== typeof errorDigest)
     throw Error(
       'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
         typeof errorDigest +
-        '" instead'
+        '" instead',
     );
-  return errorDigest || "";
+  return errorDigest || '';
 }
 function fatalError(request, error) {
   var onFatalError = request.onFatalError;
@@ -1840,12 +1840,12 @@
     ? ((request.status = 14), request.destination.destroy(error))
     : ((request.status = 13), (request.fatalError = error));
   request.cacheController.abort(
-    Error("The render was aborted due to a fatal error.", { cause: error })
+    Error('The render was aborted due to a fatal error.', { cause: error }),
   );
 }
 function emitErrorChunk(request, id, digest) {
   digest = { digest: digest };
-  id = id.toString(16) + ":E" + stringify(digest) + "\n";
+  id = id.toString(16) + ':E' + stringify(digest) + '\n';
   request.completedErrorChunks.push(id);
 }
 function emitTypedArrayChunk(request, id, tag, typedArray, debug) {
@@ -1853,55 +1853,55 @@
   typedArray = new Uint8Array(
     typedArray.buffer,
     typedArray.byteOffset,
-    typedArray.byteLength
+    typedArray.byteLength,
   );
   debug = typedArray.byteLength;
-  id = id.toString(16) + ":" + tag + debug.toString(16) + ",";
+  id = id.toString(16) + ':' + tag + debug.toString(16) + ',';
   request.completedRegularChunks.push(id, typedArray);
 }
 function emitTextChunk(request, id, text, debug) {
   if (null === byteLengthOfChunk)
     throw Error(
-      "Existence of byteLengthOfChunk should have already been checked. This is a bug in React."
+      'Existence of byteLengthOfChunk should have already been checked. This is a bug in React.',
     );
   debug ? request.pendingDebugChunks++ : request.pendingChunks++;
   debug = byteLengthOfChunk(text);
-  id = id.toString(16) + ":T" + debug.toString(16) + ",";
+  id = id.toString(16) + ':T' + debug.toString(16) + ',';
   request.completedRegularChunks.push(id, text);
 }
 function emitChunk(request, task, value) {
   var id = task.id;
-  "string" === typeof value && null !== byteLengthOfChunk
+  'string' === typeof value && null !== byteLengthOfChunk
     ? emitTextChunk(request, id, value, !1)
     : value instanceof ArrayBuffer
-      ? emitTypedArrayChunk(request, id, "A", new Uint8Array(value), !1)
+      ? emitTypedArrayChunk(request, id, 'A', new Uint8Array(value), !1)
       : value instanceof Int8Array
-        ? emitTypedArrayChunk(request, id, "O", value, !1)
+        ? emitTypedArrayChunk(request, id, 'O', value, !1)
         : value instanceof Uint8Array
-          ? emitTypedArrayChunk(request, id, "o", value, !1)
+          ? emitTypedArrayChunk(request, id, 'o', value, !1)
           : value instanceof Uint8ClampedArray
-            ? emitTypedArrayChunk(request, id, "U", value, !1)
+            ? emitTypedArrayChunk(request, id, 'U', value, !1)
             : value instanceof Int16Array
-              ? emitTypedArrayChunk(request, id, "S", value, !1)
+              ? emitTypedArrayChunk(request, id, 'S', value, !1)
               : value instanceof Uint16Array
-                ? emitTypedArrayChunk(request, id, "s", value, !1)
+                ? emitTypedArrayChunk(request, id, 's', value, !1)
                 : value instanceof Int32Array
-                  ? emitTypedArrayChunk(request, id, "L", value, !1)
+                  ? emitTypedArrayChunk(request, id, 'L', value, !1)
                   : value instanceof Uint32Array
-                    ? emitTypedArrayChunk(request, id, "l", value, !1)
+                    ? emitTypedArrayChunk(request, id, 'l', value, !1)
                     : value instanceof Float32Array
-                      ? emitTypedArrayChunk(request, id, "G", value, !1)
+                      ? emitTypedArrayChunk(request, id, 'G', value, !1)
                       : value instanceof Float64Array
-                        ? emitTypedArrayChunk(request, id, "g", value, !1)
+                        ? emitTypedArrayChunk(request, id, 'g', value, !1)
                         : value instanceof BigInt64Array
-                          ? emitTypedArrayChunk(request, id, "M", value, !1)
+                          ? emitTypedArrayChunk(request, id, 'M', value, !1)
                           : value instanceof BigUint64Array
-                            ? emitTypedArrayChunk(request, id, "m", value, !1)
+                            ? emitTypedArrayChunk(request, id, 'm', value, !1)
                             : value instanceof DataView
-                              ? emitTypedArrayChunk(request, id, "V", value, !1)
+                              ? emitTypedArrayChunk(request, id, 'V', value, !1)
                               : ((value = stringify(value, task.toJSON)),
                                 (task =
-                                  task.id.toString(16) + ":" + value + "\n"),
+                                  task.id.toString(16) + ':' + value + '\n'),
                                 request.completedRegularChunks.push(task));
 }
 function erroredTask(request, task, error) {
@@ -1922,18 +1922,18 @@
         request,
         task,
         emptyRoot,
-        "",
-        task.model
+        '',
+        task.model,
       );
       modelRoot = resolvedModel;
       task.keyPath = null;
       task.implicitSlot = !1;
-      if ("object" === typeof resolvedModel && null !== resolvedModel)
+      if ('object' === typeof resolvedModel && null !== resolvedModel)
         request.writtenObjects.set(resolvedModel, serializeByValueID(task.id)),
           emitChunk(request, task, resolvedModel);
       else {
         var json = stringify(resolvedModel),
-          processedChunk = task.id.toString(16) + ":" + json + "\n";
+          processedChunk = task.id.toString(16) + ':' + json + '\n';
         request.completedRegularChunks.push(processedChunk);
       }
       task.status = 1;
@@ -1958,9 +1958,9 @@
             ? getSuspendedThenable()
             : thrownValue;
         if (
-          "object" === typeof x &&
+          'object' === typeof x &&
           null !== x &&
-          "function" === typeof x.then
+          'function' === typeof x.then
         ) {
           task.status = 0;
           task.thenableState = getThenableStateAfterSuspending();
@@ -2075,14 +2075,14 @@
         (writtenBytes = 0),
         (destinationHasCapacity = !0);
     }
-    "function" === typeof destination.flush && destination.flush();
+    'function' === typeof destination.flush && destination.flush();
   }
   0 === request.pendingChunks &&
     (12 > request.status &&
       request.cacheController.abort(
         Error(
-          "This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources."
-        )
+          'This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources.',
+        ),
       ),
     null !== request.destination &&
       ((request.status = 14),
@@ -2166,13 +2166,13 @@
           var error =
               void 0 === reason
                 ? Error(
-                    "The render was aborted by the server without a reason."
+                    'The render was aborted by the server without a reason.',
                   )
-                : "object" === typeof reason &&
+                : 'object' === typeof reason &&
                     null !== reason &&
-                    "function" === typeof reason.then
+                    'function' === typeof reason.then
                   ? Error(
-                      "The render was aborted by the server with a promise."
+                      'The render was aborted by the server with a promise.',
                     )
                   : reason,
             digest = logRecoverableError(request, error, null),
@@ -2198,7 +2198,7 @@
     }
 }
 function resolveServerReference(bundlerConfig, id) {
-  var idx = id.lastIndexOf("#");
+  var idx = id.lastIndexOf('#');
   bundlerConfig = id.slice(0, idx);
   id = id.slice(idx + 1);
   return { specifier: bundlerConfig, name: id };
@@ -2207,7 +2207,7 @@
 function preloadModule(metadata) {
   var existingPromise = asyncModuleCache.get(metadata.specifier);
   if (existingPromise)
-    return "fulfilled" === existingPromise.status ? null : existingPromise;
+    return 'fulfilled' === existingPromise.status ? null : existingPromise;
   var modulePromise = import(metadata.specifier);
   metadata.async &&
     (modulePromise = modulePromise.then(function (value) {
@@ -2216,25 +2216,25 @@
   modulePromise.then(
     function (value) {
       var fulfilledThenable = modulePromise;
-      fulfilledThenable.status = "fulfilled";
+      fulfilledThenable.status = 'fulfilled';
       fulfilledThenable.value = value;
     },
     function (reason) {
       var rejectedThenable = modulePromise;
-      rejectedThenable.status = "rejected";
+      rejectedThenable.status = 'rejected';
       rejectedThenable.reason = reason;
-    }
+    },
   );
   asyncModuleCache.set(metadata.specifier, modulePromise);
   return modulePromise;
 }
 function requireModule(metadata) {
   var moduleExports = asyncModuleCache.get(metadata.specifier);
-  if ("fulfilled" === moduleExports.status) moduleExports = moduleExports.value;
+  if ('fulfilled' === moduleExports.status) moduleExports = moduleExports.value;
   else throw moduleExports.reason;
-  return "*" === metadata.name
+  return '*' === metadata.name
     ? moduleExports
-    : "" === metadata.name
+    : '' === metadata.name
       ? moduleExports.default
       : moduleExports[metadata.name];
 }
@@ -2247,16 +2247,16 @@
 Chunk.prototype = Object.create(Promise.prototype);
 Chunk.prototype.then = function (resolve, reject) {
   switch (this.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(this);
   }
   switch (this.status) {
-    case "fulfilled":
+    case 'fulfilled':
       resolve(this.value);
       break;
-    case "pending":
-    case "blocked":
-    case "cyclic":
+    case 'pending':
+    case 'blocked':
+    case 'cyclic':
       resolve &&
         (null === this.value && (this.value = []), this.value.push(resolve));
       reject &&
@@ -2267,41 +2267,41 @@
   }
 };
 function createPendingChunk(response) {
-  return new Chunk("pending", null, null, response);
+  return new Chunk('pending', null, null, response);
 }
 function wakeChunk(listeners, value) {
   for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
 }
 function triggerErrorOnChunk(chunk, error) {
-  if ("pending" !== chunk.status && "blocked" !== chunk.status)
+  if ('pending' !== chunk.status && 'blocked' !== chunk.status)
     chunk.reason.error(error);
   else {
     var listeners = chunk.reason;
-    chunk.status = "rejected";
+    chunk.status = 'rejected';
     chunk.reason = error;
     null !== listeners && wakeChunk(listeners, error);
   }
 }
 function resolveModelChunk(chunk, value, id) {
-  if ("pending" !== chunk.status)
+  if ('pending' !== chunk.status)
     (chunk = chunk.reason),
-      "C" === value[0]
-        ? chunk.close("C" === value ? '"$undefined"' : value.slice(1))
+      'C' === value[0]
+        ? chunk.close('C' === value ? '"$undefined"' : value.slice(1))
         : chunk.enqueueModel(value);
   else {
     var resolveListeners = chunk.value,
       rejectListeners = chunk.reason;
-    chunk.status = "resolved_model";
+    chunk.status = 'resolved_model';
     chunk.value = value;
     chunk.reason = id;
     if (null !== resolveListeners)
       switch ((initializeModelChunk(chunk), chunk.status)) {
-        case "fulfilled":
+        case 'fulfilled':
           wakeChunk(resolveListeners, chunk.value);
           break;
-        case "pending":
-        case "blocked":
-        case "cyclic":
+        case 'pending':
+        case 'blocked':
+        case 'cyclic':
           if (chunk.value)
             for (value = 0; value < resolveListeners.length; value++)
               chunk.value.push(resolveListeners[value]);
@@ -2312,24 +2312,24 @@
                 chunk.reason.push(rejectListeners[value]);
           } else chunk.reason = rejectListeners;
           break;
-        case "rejected":
+        case 'rejected':
           rejectListeners && wakeChunk(rejectListeners, chunk.reason);
       }
   }
 }
 function createResolvedIteratorResultChunk(response, value, done) {
   return new Chunk(
-    "resolved_model",
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
+    'resolved_model',
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
     -1,
-    response
+    response,
   );
 }
 function resolveIteratorResultChunk(chunk, value, done) {
   resolveModelChunk(
     chunk,
-    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
-    -1
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}',
+    -1,
   );
 }
 function loadServerReference$1(
@@ -2338,7 +2338,7 @@
   bound,
   parentChunk,
   parentObject,
-  key
+  key,
 ) {
   var serverReference = resolveServerReference(response._bundlerConfig, id);
   id = preloadModule(serverReference);
@@ -2361,16 +2361,16 @@
       !1,
       response,
       createModel,
-      []
+      [],
     ),
-    createModelReject(parentChunk)
+    createModelReject(parentChunk),
   );
   return null;
 }
 function reviveModel(response, parentObj, parentKey, value, reference) {
-  if ("string" === typeof value)
+  if ('string' === typeof value)
     return parseModelString(response, parentObj, parentKey, value, reference);
-  if ("object" === typeof value && null !== value)
+  if ('object' === typeof value && null !== value)
     if (
       (void 0 !== reference &&
         void 0 !== response._temporaryReferences &&
@@ -2381,16 +2381,16 @@
         value[i] = reviveModel(
           response,
           value,
-          "" + i,
+          '' + i,
           value[i],
-          void 0 !== reference ? reference + ":" + i : void 0
+          void 0 !== reference ? reference + ':' + i : void 0,
         );
     else
       for (i in value)
         hasOwnProperty.call(value, i) &&
           ((parentObj =
-            void 0 !== reference && -1 === i.indexOf(":")
-              ? reference + ":" + i
+            void 0 !== reference && -1 === i.indexOf(':')
+              ? reference + ':' + i
               : void 0),
           (parentObj = reviveModel(response, value, i, value[i], parentObj)),
           void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);
@@ -2405,31 +2405,31 @@
   initializingChunkBlockedModel = null;
   var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),
     resolvedModel = chunk.value;
-  chunk.status = "cyclic";
+  chunk.status = 'cyclic';
   chunk.value = null;
   chunk.reason = null;
   try {
     var rawModel = JSON.parse(resolvedModel),
       value = reviveModel(
         chunk._response,
-        { "": rawModel },
-        "",
+        { '': rawModel },
+        '',
         rawModel,
-        rootReference
+        rootReference,
       );
     if (
       null !== initializingChunkBlockedModel &&
       0 < initializingChunkBlockedModel.deps
     )
-      (initializingChunkBlockedModel.value = value), (chunk.status = "blocked");
+      (initializingChunkBlockedModel.value = value), (chunk.status = 'blocked');
     else {
       var resolveListeners = chunk.value;
-      chunk.status = "fulfilled";
+      chunk.status = 'fulfilled';
       chunk.value = value;
       null !== resolveListeners && wakeChunk(resolveListeners, value);
     }
   } catch (error) {
-    (chunk.status = "rejected"), (chunk.reason = error);
+    (chunk.status = 'rejected'), (chunk.reason = error);
   } finally {
     (initializingChunk = prevChunk),
       (initializingChunkBlockedModel = prevBlocked);
@@ -2439,7 +2439,7 @@
   response._closed = !0;
   response._closedReason = error;
   response._chunks.forEach(function (chunk) {
-    "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+    'pending' === chunk.status && triggerErrorOnChunk(chunk, error);
   });
 }
 function getChunk(response, id) {
@@ -2449,9 +2449,9 @@
     ((chunk = response._formData.get(response._prefix + id)),
     (chunk =
       null != chunk
-        ? new Chunk("resolved_model", chunk, id, response)
+        ? new Chunk('resolved_model', chunk, id, response)
         : response._closed
-          ? new Chunk("rejected", null, response._closedReason, response)
+          ? new Chunk('rejected', null, response._closedReason, response)
           : createPendingChunk(response)),
     chunks.set(id, chunk));
   return chunk;
@@ -2463,7 +2463,7 @@
   cyclic,
   response,
   map,
-  path
+  path,
 ) {
   if (initializingChunkBlockedModel) {
     var blocked = initializingChunkBlockedModel;
@@ -2471,17 +2471,17 @@
   } else
     blocked = initializingChunkBlockedModel = {
       deps: cyclic ? 0 : 1,
-      value: null
+      value: null,
     };
   return function (value) {
     for (var i = 1; i < path.length; i++) value = value[path[i]];
     parentObject[key] = map(response, value);
-    "" === key && null === blocked.value && (blocked.value = parentObject[key]);
+    '' === key && null === blocked.value && (blocked.value = parentObject[key]);
     blocked.deps--;
     0 === blocked.deps &&
-      "blocked" === chunk.status &&
+      'blocked' === chunk.status &&
       ((value = chunk.value),
-      (chunk.status = "fulfilled"),
+      (chunk.status = 'fulfilled'),
       (chunk.value = blocked.value),
       null !== value && wakeChunk(value, blocked.value));
   };
@@ -2492,34 +2492,34 @@
   };
 }
 function getOutlinedModel(response, reference, parentObject, key, map) {
-  reference = reference.split(":");
+  reference = reference.split(':');
   var id = parseInt(reference[0], 16);
   id = getChunk(response, id);
   switch (id.status) {
-    case "resolved_model":
+    case 'resolved_model':
       initializeModelChunk(id);
   }
   switch (id.status) {
-    case "fulfilled":
+    case 'fulfilled':
       parentObject = id.value;
       for (key = 1; key < reference.length; key++)
         parentObject = parentObject[reference[key]];
       return map(response, parentObject);
-    case "pending":
-    case "blocked":
-    case "cyclic":
+    case 'pending':
+    case 'blocked':
+    case 'cyclic':
       var parentChunk = initializingChunk;
       id.then(
         createModelResolver(
           parentChunk,
           parentObject,
           key,
-          "cyclic" === id.status,
+          'cyclic' === id.status,
           response,
           map,
-          reference
+          reference,
         ),
-        createModelReject(parentChunk)
+        createModelReject(parentChunk),
       );
       return null;
     default:
@@ -2544,7 +2544,7 @@
   constructor,
   bytesPerElement,
   parentObject,
-  parentKey
+  parentKey,
 ) {
   reference = parseInt(reference.slice(2), 16);
   reference = response._formData.get(response._prefix + reference);
@@ -2563,21 +2563,21 @@
       !1,
       response,
       createModel,
-      []
+      [],
     ),
-    createModelReject(bytesPerElement)
+    createModelReject(bytesPerElement),
   );
   return null;
 }
 function resolveStream(response, id, stream, controller) {
   var chunks = response._chunks;
-  stream = new Chunk("fulfilled", stream, controller, response);
+  stream = new Chunk('fulfilled', stream, controller, response);
   chunks.set(id, stream);
   response = response._formData.getAll(response._prefix + id);
   for (id = 0; id < response.length; id++)
     (chunks = response[id]),
-      "C" === chunks[0]
-        ? controller.close("C" === chunks ? '"$undefined"' : chunks.slice(1))
+      'C' === chunks[0]
+        ? controller.close('C' === chunks ? '"$undefined"' : chunks.slice(1))
         : controller.enqueueModel(chunks);
 }
 function parseReadableStream(response, reference, type) {
@@ -2587,15 +2587,15 @@
     type: type,
     start: function (c) {
       controller = c;
-    }
+    },
   });
   var previousBlockedChunk = null;
   resolveStream(response, reference, type, {
     enqueueModel: function (json) {
       if (null === previousBlockedChunk) {
-        var chunk = new Chunk("resolved_model", json, -1, response);
+        var chunk = new Chunk('resolved_model', json, -1, response);
         initializeModelChunk(chunk);
-        "fulfilled" === chunk.status
+        'fulfilled' === chunk.status
           ? controller.enqueue(chunk.value)
           : (chunk.then(
               function (v) {
@@ -2603,7 +2603,7 @@
               },
               function (e) {
                 return controller.error(e);
-              }
+              },
             ),
             (previousBlockedChunk = chunk));
       } else {
@@ -2615,7 +2615,7 @@
           },
           function (e) {
             return controller.error(e);
-          }
+          },
         );
         previousBlockedChunk = chunk$26;
         chunk.then(function () {
@@ -2643,7 +2643,7 @@
           return controller.error(error);
         });
       }
-    }
+    },
   });
   return type;
 }
@@ -2667,15 +2667,15 @@
       return createIterator(function (arg) {
         if (void 0 !== arg)
           throw Error(
-            "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+            'Values cannot be passed to next() of AsyncIterables passed to Client Components.',
           );
         if (nextReadIndex === buffer.length) {
           if (closed)
             return new Chunk(
-              "fulfilled",
+              'fulfilled',
               { done: !0, value: void 0 },
               null,
-              response
+              response,
             );
           buffer[nextReadIndex] = createPendingChunk(response);
         }
@@ -2690,7 +2690,7 @@
         ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
             response,
             value,
-            !1
+            !1,
           ))
         : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
       nextWriteIndex++;
@@ -2701,14 +2701,14 @@
         ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
             response,
             value,
-            !0
+            !0,
           ))
         : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
       for (nextWriteIndex++; nextWriteIndex < buffer.length; )
         resolveIteratorResultChunk(
           buffer[nextWriteIndex++],
           '"$undefined"',
-          !0
+          !0,
         );
     },
     error: function (error) {
@@ -2720,18 +2720,18 @@
 
       )
         triggerErrorOnChunk(buffer[nextWriteIndex++], error);
-    }
+    },
   });
   return iterator;
 }
 function parseModelString(response, obj, key, value, reference) {
-  if ("$" === value[0]) {
+  if ('$' === value[0]) {
     switch (value[1]) {
-      case "$":
+      case '$':
         return value.slice(1);
-      case "@":
+      case '@':
         return (obj = parseInt(value.slice(2), 16)), getChunk(response, obj);
-      case "F":
+      case 'F':
         return (
           (value = value.slice(2)),
           (value = getOutlinedModel(response, value, obj, key, createModel)),
@@ -2741,96 +2741,96 @@
             value.bound,
             initializingChunk,
             obj,
-            key
+            key,
           )
         );
-      case "T":
+      case 'T':
         if (void 0 === reference || void 0 === response._temporaryReferences)
           throw Error(
-            "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+            'Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.',
           );
         return createTemporaryReference(
           response._temporaryReferences,
-          reference
+          reference,
         );
-      case "Q":
+      case 'Q':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, createMap)
         );
-      case "W":
+      case 'W':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, createSet)
         );
-      case "K":
+      case 'K':
         obj = value.slice(2);
-        var formPrefix = response._prefix + obj + "_",
+        var formPrefix = response._prefix + obj + '_',
           data = new FormData();
         response._formData.forEach(function (entry, entryKey) {
           entryKey.startsWith(formPrefix) &&
             data.append(entryKey.slice(formPrefix.length), entry);
         });
         return data;
-      case "i":
+      case 'i':
         return (
           (value = value.slice(2)),
           getOutlinedModel(response, value, obj, key, extractIterator)
         );
-      case "I":
+      case 'I':
         return Infinity;
-      case "-":
-        return "$-0" === value ? -0 : -Infinity;
-      case "N":
+      case '-':
+        return '$-0' === value ? -0 : -Infinity;
+      case 'N':
         return NaN;
-      case "u":
+      case 'u':
         return;
-      case "D":
+      case 'D':
         return new Date(Date.parse(value.slice(2)));
-      case "n":
+      case 'n':
         return BigInt(value.slice(2));
     }
     switch (value[1]) {
-      case "A":
+      case 'A':
         return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);
-      case "O":
+      case 'O':
         return parseTypedArray(response, value, Int8Array, 1, obj, key);
-      case "o":
+      case 'o':
         return parseTypedArray(response, value, Uint8Array, 1, obj, key);
-      case "U":
+      case 'U':
         return parseTypedArray(response, value, Uint8ClampedArray, 1, obj, key);
-      case "S":
+      case 'S':
         return parseTypedArray(response, value, Int16Array, 2, obj, key);
-      case "s":
+      case 's':
         return parseTypedArray(response, value, Uint16Array, 2, obj, key);
-      case "L":
+      case 'L':
         return parseTypedArray(response, value, Int32Array, 4, obj, key);
-      case "l":
+      case 'l':
         return parseTypedArray(response, value, Uint32Array, 4, obj, key);
-      case "G":
+      case 'G':
         return parseTypedArray(response, value, Float32Array, 4, obj, key);
-      case "g":
+      case 'g':
         return parseTypedArray(response, value, Float64Array, 8, obj, key);
-      case "M":
+      case 'M':
         return parseTypedArray(response, value, BigInt64Array, 8, obj, key);
-      case "m":
+      case 'm':
         return parseTypedArray(response, value, BigUint64Array, 8, obj, key);
-      case "V":
+      case 'V':
         return parseTypedArray(response, value, DataView, 1, obj, key);
-      case "B":
+      case 'B':
         return (
           (obj = parseInt(value.slice(2), 16)),
           response._formData.get(response._prefix + obj)
         );
     }
     switch (value[1]) {
-      case "R":
+      case 'R':
         return parseReadableStream(response, value, void 0);
-      case "r":
-        return parseReadableStream(response, value, "bytes");
-      case "X":
+      case 'r':
+        return parseReadableStream(response, value, 'bytes');
+      case 'X':
         return parseAsyncIterable(response, value, !1);
-      case "x":
+      case 'x':
         return parseAsyncIterable(response, value, !0);
     }
     value = value.slice(1);
@@ -2851,7 +2851,7 @@
     _chunks: chunks,
     _closed: !1,
     _closedReason: null,
-    _temporaryReferences: temporaryReferences
+    _temporaryReferences: temporaryReferences,
   };
 }
 function resolveField(response, key, value) {
@@ -2863,7 +2863,7 @@
     (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));
 }
 function close(response) {
-  reportGlobalError(response, Error("Connection closed."));
+  reportGlobalError(response, Error('Connection closed.'));
 }
 function loadServerReference(bundlerConfig, id, bound) {
   var serverReference = resolveServerReference(bundlerConfig, id);
@@ -2885,7 +2885,7 @@
   close(body);
   body = getChunk(body, 0);
   body.then(function () {});
-  if ("fulfilled" !== body.status) throw body.reason;
+  if ('fulfilled' !== body.status) throw body.reason;
   return body.value;
 }
 function createDrainHandler(destination, request) {
@@ -2902,7 +2902,7 @@
 function createFakeWritableFromReadableStreamController(controller) {
   return {
     write: function (chunk) {
-      "string" === typeof chunk && (chunk = textEncoder.encode(chunk));
+      'string' === typeof chunk && (chunk = textEncoder.encode(chunk));
       controller.enqueue(chunk);
       return !0;
     },
@@ -2910,10 +2910,10 @@
       controller.close();
     },
     destroy: function (error) {
-      "function" === typeof controller.error
+      'function' === typeof controller.error
         ? controller.error(error)
         : controller.close();
-    }
+    },
   };
 }
 function createFakeWritableFromNodeReadable(readable) {
@@ -2926,7 +2926,7 @@
     },
     destroy: function (error) {
       readable.destroy(error);
-    }
+    },
   };
 }
 exports.createClientModuleProxy = function (moduleId) {
@@ -2940,12 +2940,12 @@
   var formData = new FormData(),
     action = null;
   body.forEach(function (value, key) {
-    key.startsWith("$ACTION_")
-      ? key.startsWith("$ACTION_REF_")
-        ? ((value = "$ACTION_" + key.slice(12) + ":"),
+    key.startsWith('$ACTION_')
+      ? key.startsWith('$ACTION_REF_')
+        ? ((value = '$ACTION_' + key.slice(12) + ':'),
           (value = decodeBoundActionMetaData(body, serverManifest, value)),
           (action = loadServerReference(serverManifest, value.id, value.bound)))
-        : key.startsWith("$ACTION_ID_") &&
+        : key.startsWith('$ACTION_ID_') &&
           ((value = key.slice(11)),
           (action = loadServerReference(serverManifest, value, null)))
       : formData.append(key, value);
@@ -2957,12 +2957,12 @@
       });
 };
 exports.decodeFormState = function (actionResult, body, serverManifest) {
-  var keyPath = body.get("$ACTION_KEY");
-  if ("string" !== typeof keyPath) return Promise.resolve(null);
+  var keyPath = body.get('$ACTION_KEY');
+  if ('string' !== typeof keyPath) return Promise.resolve(null);
   var metaData = null;
   body.forEach(function (value, key) {
-    key.startsWith("$ACTION_REF_") &&
-      ((value = "$ACTION_" + key.slice(12) + ":"),
+    key.startsWith('$ACTION_REF_') &&
+      ((value = '$ACTION_' + key.slice(12) + ':'),
       (metaData = decodeBoundActionMetaData(body, serverManifest, value)));
   });
   if (null === metaData) return Promise.resolve(null);
@@ -2974,16 +2974,16 @@
   });
 };
 exports.decodeReply = function (body, webpackMap, options) {
-  if ("string" === typeof body) {
+  if ('string' === typeof body) {
     var form = new FormData();
-    form.append("0", body);
+    form.append('0', body);
     body = form;
   }
   body = createResponse(
     webpackMap,
-    "",
+    '',
     options ? options.temporaryReferences : void 0,
-    body
+    body,
   );
   webpackMap = getChunk(body, 0);
   close(body);
@@ -2992,7 +2992,7 @@
 exports.decodeReplyFromAsyncIterable = function (
   iterable,
   webpackMap,
-  options
+  options,
 ) {
   function progress(entry) {
     if (entry.done) close(response);
@@ -3000,7 +3000,7 @@
       var _entry$value = entry.value;
       entry = _entry$value[0];
       _entry$value = _entry$value[1];
-      "string" === typeof _entry$value
+      'string' === typeof _entry$value
         ? resolveField(response, entry, _entry$value)
         : response._formData.append(entry, _entry$value);
       iterator.next().then(progress, error);
@@ -3008,14 +3008,14 @@
   }
   function error(reason) {
     reportGlobalError(response, reason);
-    "function" === typeof iterator.throw &&
+    'function' === typeof iterator.throw &&
       iterator.throw(reason).then(error, error);
   }
   var iterator = iterable[ASYNC_ITERATOR](),
     response = createResponse(
       webpackMap,
-      "",
-      options ? options.temporaryReferences : void 0
+      '',
+      options ? options.temporaryReferences : void 0,
     );
   iterator.next().then(progress, error);
   return getChunk(response, 0);
@@ -3023,31 +3023,31 @@
 exports.decodeReplyFromBusboy = function (busboyStream, webpackMap, options) {
   var response = createResponse(
       webpackMap,
-      "",
-      options ? options.temporaryReferences : void 0
+      '',
+      options ? options.temporaryReferences : void 0,
     ),
     pendingFiles = 0,
     queuedFields = [];
-  busboyStream.on("field", function (name, value) {
+  busboyStream.on('field', function (name, value) {
     0 < pendingFiles
       ? queuedFields.push(name, value)
       : resolveField(response, name, value);
   });
-  busboyStream.on("file", function (name, value, _ref2) {
+  busboyStream.on('file', function (name, value, _ref2) {
     var filename = _ref2.filename,
       mimeType = _ref2.mimeType;
-    if ("base64" === _ref2.encoding.toLowerCase())
+    if ('base64' === _ref2.encoding.toLowerCase())
       throw Error(
-        "React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it."
+        "React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.",
       );
     pendingFiles++;
     var JSCompiler_object_inline_chunks_274 = [];
-    value.on("data", function (chunk) {
+    value.on('data', function (chunk) {
       JSCompiler_object_inline_chunks_274.push(chunk);
     });
-    value.on("end", function () {
+    value.on('end', function () {
       var blob = new Blob(JSCompiler_object_inline_chunks_274, {
-        type: mimeType
+        type: mimeType,
       });
       response._formData.append(name, blob, filename);
       pendingFiles--;
@@ -3058,10 +3058,10 @@
       }
     });
   });
-  busboyStream.on("finish", function () {
+  busboyStream.on('finish', function () {
     close(response);
   });
-  busboyStream.on("error", function (err) {
+  busboyStream.on('error', function (err) {
     reportGlobalError(response, err);
   });
   return getChunk(response, 0);
@@ -3078,7 +3078,7 @@
         var writable,
           stream = new ReadableStream(
             {
-              type: "bytes",
+              type: 'bytes',
               start: function (controller) {
                 writable =
                   createFakeWritableFromReadableStreamController(controller);
@@ -3089,15 +3089,15 @@
               cancel: function (reason) {
                 request.destination = null;
                 abort(request, reason);
-              }
+              },
             },
-            { highWaterMark: 0 }
+            { highWaterMark: 0 },
           );
         resolve({ prelude: stream });
       },
       reject,
       options ? options.identifierPrefix : void 0,
-      options ? options.temporaryReferences : void 0
+      options ? options.temporaryReferences : void 0,
     );
     if (options && options.signal) {
       var signal = options.signal;
@@ -3105,9 +3105,9 @@
       else {
         var listener = function () {
           abort(request, signal.reason);
-          signal.removeEventListener("abort", listener);
+          signal.removeEventListener('abort', listener);
         };
-        signal.addEventListener("abort", listener);
+        signal.addEventListener('abort', listener);
       }
     }
     startWork(request);
@@ -3125,14 +3125,14 @@
         var readable = new stream.Readable({
             read: function () {
               startFlowing(request, writable);
-            }
+            },
           }),
           writable = createFakeWritableFromNodeReadable(readable);
         resolve({ prelude: readable });
       },
       reject,
       options ? options.identifierPrefix : void 0,
-      options ? options.temporaryReferences : void 0
+      options ? options.temporaryReferences : void 0,
     );
     if (options && options.signal) {
       var signal = options.signal;
@@ -3140,9 +3140,9 @@
       else {
         var listener = function () {
           abort(request, signal.reason);
-          signal.removeEventListener("abort", listener);
+          signal.removeEventListener('abort', listener);
         };
-        signal.addEventListener("abort", listener);
+        signal.addEventListener('abort', listener);
       }
     }
     startWork(request);
@@ -3151,23 +3151,23 @@
 exports.registerClientReference = function (
   proxyImplementation,
   id,
-  exportName
+  exportName,
 ) {
   return registerClientReferenceImpl(
     proxyImplementation,
-    id + "#" + exportName,
-    !1
+    id + '#' + exportName,
+    !1,
   );
 };
 exports.registerServerReference = function (reference, id, exportName) {
   return Object.defineProperties(reference, {
     $$typeof: { value: SERVER_REFERENCE_TAG },
     $$id: {
-      value: null === exportName ? id : id + "#" + exportName,
-      configurable: !0
+      value: null === exportName ? id : id + '#' + exportName,
+      configurable: !0,
     },
     $$bound: { value: null, configurable: !0 },
-    bind: { value: bind, configurable: !0 }
+    bind: { value: bind, configurable: !0 },
   });
 };
 exports.renderToPipeableStream = function (model, webpackMap, options) {
@@ -3180,7 +3180,7 @@
       noop,
       noop,
       options ? options.identifierPrefix : void 0,
-      options ? options.temporaryReferences : void 0
+      options ? options.temporaryReferences : void 0,
     ),
     hasStartedFlowing = !1;
   startWork(request);
@@ -3188,27 +3188,27 @@
     pipe: function (destination) {
       if (hasStartedFlowing)
         throw Error(
-          "React currently only supports piping to one writable stream."
+          'React currently only supports piping to one writable stream.',
         );
       hasStartedFlowing = !0;
       startFlowing(request, destination);
-      destination.on("drain", createDrainHandler(destination, request));
+      destination.on('drain', createDrainHandler(destination, request));
       destination.on(
-        "error",
+        'error',
         createCancelHandler(
           request,
-          "The destination stream errored while writing data."
-        )
+          'The destination stream errored while writing data.',
+        ),
       );
       destination.on(
-        "close",
-        createCancelHandler(request, "The destination stream closed early.")
+        'close',
+        createCancelHandler(request, 'The destination stream closed early.'),
       );
       return destination;
     },
     abort: function (reason) {
       abort(request, reason);
-    }
+    },
   };
 };
 exports.renderToReadableStream = function (model, webpackMap, options) {
@@ -3221,7 +3221,7 @@
     noop,
     noop,
     options ? options.identifierPrefix : void 0,
-    options ? options.temporaryReferences : void 0
+    options ? options.temporaryReferences : void 0,
   );
   if (options && options.signal) {
     var signal = options.signal;
@@ -3229,15 +3229,15 @@
     else {
       var listener = function () {
         abort(request, signal.reason);
-        signal.removeEventListener("abort", listener);
+        signal.removeEventListener('abort', listener);
       };
-      signal.addEventListener("abort", listener);
+      signal.addEventListener('abort', listener);
     }
   }
   var writable;
   return new ReadableStream(
     {
-      type: "bytes",
+      type: 'bytes',
       start: function (controller) {
         writable = createFakeWritableFromReadableStreamController(controller);
         startWork(request);
@@ -3248,8 +3248,8 @@
       cancel: function (reason) {
         request.destination = null;
         abort(request, reason);
-      }
+      },
     },
-    { highWaterMark: 0 }
+    { highWaterMark: 0 },
   );
 };
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/rsc-client-loader.js packages/react-server-dom-webpack/cjs/rsc-client-loader.js
--- npm/react-server-dom-webpack@19.2.0/cjs/rsc-client-loader.js	1969-12-31 16:00:00
+++ packages/react-server-dom-webpack/cjs/rsc-client-loader.js	2025-11-26 23:54:07
@@ -0,0 +1,137 @@
+/**
+ * rsc-client-loader.js
+ *
+ * Webpack loader for the CLIENT (browser) layer.
+ *
+ * Transformations:
+ * - 'use server' modules  createServerReference() calls
+ * - 'use client' modules  Pass through (actual components)
+ *
+ * This loader runs in the BROWSER.
+ */
+
+'use strict';
+
+const acorn = require('acorn-loose');
+const url = require('url');
+
+function getDirective(source) {
+  if (!source.includes('use client') && !source.includes('use server'))
+    return null;
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type !== 'ExpressionStatement' || !node.directive) break;
+      if (node.directive === 'use client') return 'use client';
+      if (node.directive === 'use server') return 'use server';
+    }
+  } catch (e) {
+    return null;
+  }
+  return null;
+}
+
+function getExports(source) {
+  const exports = [];
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type === 'ExportNamedDeclaration') {
+        if (node.declaration) {
+          if (
+            node.declaration.type === 'FunctionDeclaration' &&
+            node.declaration.id
+          ) {
+            exports.push(node.declaration.id.name);
+          }
+          if (node.declaration.type === 'VariableDeclaration') {
+            for (const decl of node.declaration.declarations) {
+              if (decl.id && decl.id.type === 'Identifier') {
+                exports.push(decl.id.name);
+              }
+            }
+          }
+        }
+      }
+      if (node.type === 'ExportDefaultDeclaration') {
+        exports.push('default');
+      }
+    }
+  } catch (e) {
+    // Ignore parse errors
+  }
+  return exports;
+}
+
+// Shared map for server references (populated by loader, read by plugin)
+const serverReferencesMap = new Map();
+
+function rscClientLoader(source) {
+  const directive = getDirective(source);
+
+  // Mark the module with the detected directive so the plugin can discover client refs
+  if (this && this._module && this._module.buildInfo) {
+    this._module.buildInfo.rscDirective = directive;
+  }
+
+  // 'use server'  Create server references
+  if (directive === 'use server') {
+    const resourcePath = this.resourcePath;
+    const moduleUrl = url.pathToFileURL(resourcePath).href;
+    const exports = getExports(source);
+
+    // Register in shared map for plugin to generate manifest
+    for (const name of exports) {
+      const actionId = `${moduleUrl}#${name}`;
+      serverReferencesMap.set(actionId, {
+        id: moduleUrl,
+        name: name,
+        chunks: [],
+      });
+    }
+
+    // Get loader options for callServer import source
+    const options = this.getOptions ? this.getOptions() : {};
+    const callServerImport = options.callServerModule
+      ? `import { callServer } from '${options.callServerModule}';`
+      : `const callServer = globalThis.__RSC_CALL_SERVER__ || ((id, args) => {
+          throw new Error('callServer not initialized. Set globalThis.__RSC_CALL_SERVER__');
+        });`;
+
+    let output = `
+// RSC Client Loader: 'use server' module transformed to server references
+import { createServerReference } from 'react-server-dom-webpack/client';
+${callServerImport}
+`;
+
+    for (const name of exports) {
+      const actionId = `${moduleUrl}#${name}`;
+
+      if (name === 'default') {
+        output += `
+const _default = createServerReference('${actionId}', callServer);
+export default _default;
+`;
+      } else {
+        output += `
+export const ${name} = createServerReference('${actionId}', callServer);
+`;
+      }
+    }
+
+    return output;
+  }
+
+  // 'use client' and other modules - pass through unchanged
+  return source;
+}
+
+// Export the loader function and the shared map
+module.exports = rscClientLoader;
+module.exports.serverReferencesMap = serverReferencesMap;
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/rsc-server-loader.js packages/react-server-dom-webpack/cjs/rsc-server-loader.js
--- npm/react-server-dom-webpack@19.2.0/cjs/rsc-server-loader.js	1969-12-31 16:00:00
+++ packages/react-server-dom-webpack/cjs/rsc-server-loader.js	2025-12-17 14:32:45
@@ -0,0 +1,399 @@
+/**
+ * rsc-server-loader.js
+ *
+ * Webpack loader for the RSC (React Server Components) layer.
+ *
+ * Transformations:
+ * - 'use client' modules  createClientReference() proxies
+ * - 'use server' modules  registerServerReference() metadata added
+ * - Inline 'use server' functions  registerServerReference() for each function
+ *
+ * This loader runs on the SERVER during RSC rendering.
+ */
+
+'use strict';
+
+const acorn = require('acorn-loose');
+const url = require('url');
+
+function getDirective(source) {
+  if (!source.includes('use client') && !source.includes('use server'))
+    return null;
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type !== 'ExpressionStatement' || !node.directive) break;
+      if (node.directive === 'use client') return 'use client';
+      if (node.directive === 'use server') return 'use server';
+    }
+  } catch (e) {
+    return null;
+  }
+  return null;
+}
+
+function getExports(source) {
+  const exports = [];
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type === 'ExportNamedDeclaration') {
+        if (node.declaration) {
+          if (
+            node.declaration.type === 'FunctionDeclaration' &&
+            node.declaration.id
+          ) {
+            exports.push({ name: node.declaration.id.name, type: 'function' });
+          }
+          if (node.declaration.type === 'VariableDeclaration') {
+            for (const decl of node.declaration.declarations) {
+              if (decl.id && decl.id.type === 'Identifier') {
+                exports.push({ name: decl.id.name, type: 'variable' });
+              }
+            }
+          }
+        }
+        if (node.specifiers) {
+          for (const spec of node.specifiers) {
+            exports.push({ name: spec.exported.name, type: 'reexport' });
+          }
+        }
+      }
+      if (node.type === 'ExportDefaultDeclaration') {
+        // Capture the actual function/class name for default exports
+        // This allows us to reference it directly instead of exports.default
+        let localName = null;
+        if (node.declaration) {
+          if (
+            node.declaration.type === 'FunctionDeclaration' &&
+            node.declaration.id
+          ) {
+            localName = node.declaration.id.name;
+          } else if (
+            node.declaration.type === 'ClassDeclaration' &&
+            node.declaration.id
+          ) {
+            localName = node.declaration.id.name;
+          } else if (node.declaration.type === 'Identifier') {
+            localName = node.declaration.name;
+          }
+        }
+        exports.push({ name: 'default', type: 'default', localName });
+      }
+    }
+  } catch (e) {
+    // Ignore parse errors
+  }
+  return exports;
+}
+
+/**
+ * Check if a function body starts with 'use server' directive
+ */
+function hasUseServerDirective(body) {
+  if (
+    !body ||
+    body.type !== 'BlockStatement' ||
+    !body.body ||
+    body.body.length === 0
+  ) {
+    return false;
+  }
+  const firstStmt = body.body[0];
+  return (
+    firstStmt.type === 'ExpressionStatement' &&
+    firstStmt.expression &&
+    firstStmt.expression.type === 'Literal' &&
+    firstStmt.expression.value === 'use server'
+  );
+}
+
+// Shared map for inline server actions (populated by loader, read by plugin)
+// Key format: "moduleUrl#actionName"
+const inlineServerActionsMap = new Map();
+
+// Track which modules have entries in the map (for clearing stale entries on rebuild)
+const moduleEntriesMap = new Map(); // moduleUrl -> Set of actionIds
+
+/**
+ * Find all inline server action functions in the source
+ * These are functions with 'use server' as their first statement
+ */
+function findInlineServerActions(source) {
+  const actions = [];
+  let actionCounter = 0;
+
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+
+    function visit(node, parent, parentKey) {
+      if (!node || typeof node !== 'object') return;
+
+      // Check function declarations
+      if (
+        node.type === 'FunctionDeclaration' &&
+        node.id &&
+        hasUseServerDirective(node.body)
+      ) {
+        actions.push({
+          name: node.id.name,
+          start: node.start,
+          end: node.end,
+          isAsync: node.async,
+          generated: false,
+        });
+      }
+
+      // Check function expressions and arrow functions assigned to variables
+      if (node.type === 'VariableDeclaration') {
+        for (const decl of node.declarations) {
+          if (decl.init && decl.id && decl.id.type === 'Identifier') {
+            const init = decl.init;
+            if (
+              (init.type === 'FunctionExpression' ||
+                init.type === 'ArrowFunctionExpression') &&
+              hasUseServerDirective(init.body)
+            ) {
+              actions.push({
+                name: decl.id.name,
+                start: node.start,
+                end: node.end,
+                isAsync: init.async,
+                generated: false,
+              });
+            }
+          }
+        }
+      }
+
+      // Check async function expressions passed directly (e.g., as props or in JSX)
+      if (
+        (node.type === 'FunctionExpression' ||
+          node.type === 'ArrowFunctionExpression') &&
+        hasUseServerDirective(node.body) &&
+        parent &&
+        parent.type !== 'VariableDeclarator'
+      ) {
+        // Anonymous inline action - generate a name
+        actionCounter++;
+        actions.push({
+          name: `$$ACTION_${actionCounter}`,
+          start: node.start,
+          end: node.end,
+          isAsync: node.async,
+          generated: true,
+          node: node,
+        });
+      }
+
+      // Recurse into child nodes
+      for (const key in node) {
+        if (key === 'parent') continue;
+        const child = node[key];
+        if (Array.isArray(child)) {
+          for (const c of child) {
+            visit(c, node, key);
+          }
+        } else if (child && typeof child === 'object' && child.type) {
+          visit(child, node, key);
+        }
+      }
+    }
+
+    visit(ast, null, null);
+  } catch (e) {
+    // Ignore parse errors
+  }
+
+  return actions;
+}
+
+module.exports = function rscServerLoader(source) {
+  const directive = getDirective(source);
+  const resourcePath = this.resourcePath;
+  const moduleUrl = url.pathToFileURL(resourcePath).href;
+
+  // Mark directive on buildInfo so the plugin can discover client refs from module graph
+  if (this && this._module && this._module.buildInfo) {
+    this._module.buildInfo.rscDirective = directive;
+  }
+
+  // 'use client'  Create client references (proxies)
+  if (directive === 'use client') {
+    const exports = getExports(source);
+
+    let output = `
+// RSC Server Loader: 'use client' module transformed to client references
+import { createClientModuleProxy } from 'react-server-dom-webpack/server.node';
+
+const proxy = createClientModuleProxy('${moduleUrl}');
+`;
+
+    for (const exp of exports) {
+      if (exp.name === 'default') {
+        output += `export default proxy.default;\n`;
+      } else {
+        output += `export const ${exp.name} = proxy['${exp.name}'];\n`;
+      }
+    }
+
+    return output;
+  }
+
+  // 'use server' at file level  Keep original + register server references
+  if (directive === 'use server') {
+    const exports = getExports(source);
+
+    // IMPORTANT: Keep 'use server' directive FIRST so ReactFlightPlugin can detect it
+    // The plugin's parser hook breaks out of the loop when it sees a non-directive statement
+    // Import must come AFTER the 'use server' directive line
+    const directiveLine = "'use server';\n";
+
+    // Remove the 'use server' directive from the original source since we'll add it back at the top
+    // Match 'use server' or "use server" with optional semicolon and whitespace
+    const sourceWithoutDirective = source.replace(
+      /^(['"])use server\1\s*;?\s*\n?/,
+      '',
+    );
+
+    // Import after directive so webpack resolves it through its module system (ensures singleton)
+    const importStatement = `// RSC Server Loader: Import for server action registration
+import { registerServerReference as __rsc_registerServerReference__ } from 'react-server-dom-webpack/server.node';
+`;
+
+    // Registration code uses the imported function
+    let registration = `
+// RSC Server Loader: Server action registration
+;(function() {
+  var registerServerReference = __rsc_registerServerReference__;
+`;
+
+    for (const exp of exports) {
+      const actionId = `${moduleUrl}#${exp.name}`;
+      if (exp.name === 'default') {
+        // For default exports, use the local function name if available
+        // This works with webpack's ES module output where exports.default is undefined
+        if (exp.localName) {
+          registration += `
+  if (typeof ${exp.localName} === 'function') {
+    registerServerReference(${exp.localName}, '${moduleUrl}', 'default');
+  }
+`;
+        } else {
+          // Fallback for anonymous default exports - try module.exports pattern
+          registration += `
+  if (typeof module !== 'undefined' && typeof module.exports === 'function') {
+    registerServerReference(module.exports, '${moduleUrl}', 'default');
+  } else if (typeof exports !== 'undefined' && typeof exports.default === 'function') {
+    registerServerReference(exports.default, '${moduleUrl}', 'default');
+  }
+`;
+        }
+      } else {
+        registration += `
+  if (typeof ${exp.name} === 'function') {
+    registerServerReference(${exp.name}, '${moduleUrl}', '${exp.name}');
+  }
+`;
+      }
+    }
+
+    registration += `})();`;
+
+    // Order: 'use server' directive (FIRST)  import  original source (without directive)  registration
+    return (
+      directiveLine +
+      importStatement +
+      sourceWithoutDirective +
+      '\n' +
+      registration
+    );
+  }
+
+  // Check for inline 'use server' functions (inside Server Components)
+  if (source.includes('use server')) {
+    const inlineActions = findInlineServerActions(source);
+
+    // Filter out anonymous/generated actions - they require source rewriting we don't support yet
+    // Only named functions (function declarations or variable-assigned functions) can be registered
+    const namedActions = inlineActions.filter((action) => !action.generated);
+
+    // Always clear stale entries for this module from previous compilation
+    // This ensures removed actions don't persist in the manifest
+    const existingEntries = moduleEntriesMap.get(moduleUrl);
+    if (existingEntries) {
+      for (const actionId of existingEntries) {
+        inlineServerActionsMap.delete(actionId);
+      }
+      moduleEntriesMap.delete(moduleUrl);
+    }
+
+    if (namedActions.length > 0) {
+      // Track new entries for this module
+      const newEntries = new Set();
+
+      // Register inline actions in shared map for plugin to generate manifest
+      for (const action of namedActions) {
+        const actionId = `${moduleUrl}#${action.name}`;
+        newEntries.add(actionId);
+        inlineServerActionsMap.set(actionId, {
+          id: moduleUrl,
+          name: action.name,
+          chunks: [],
+        });
+      }
+
+      moduleEntriesMap.set(moduleUrl, newEntries);
+
+      // Insert registration INSIDE the same scope as each action definition
+      // Sort by position descending so we can insert from end to beginning without affecting positions
+      const sorted = [...namedActions].sort((a, b) => b.end - a.end);
+
+      let result = source;
+
+      for (const action of sorted) {
+        // Insert registration right after the function definition, in the same lexical scope
+        // Use the imported __rsc_registerServerReference__ which webpack resolves through its module system
+        const registration = `\n;(function(){
+  if(typeof ${action.name}==='function'){
+    __rsc_registerServerReference__(${action.name},'${moduleUrl}','${action.name}');
+  }
+})();`;
+
+        result =
+          result.slice(0, action.end) + registration + result.slice(action.end);
+      }
+
+      // Prepend import for registerServerReference so webpack resolves it properly
+      const importPrefix = `// RSC Server Loader: Import for inline server action registration
+import { registerServerReference as __rsc_registerServerReference__ } from 'react-server-dom-webpack/server.node';
+`;
+      return importPrefix + result;
+    } else if (inlineActions.length > 0) {
+      // We found anonymous inline actions but can't register them
+      // Log a warning in development
+      if (process.env.NODE_ENV !== 'production') {
+        console.warn(
+          `[rsc-server-loader] Found ${inlineActions.length} anonymous inline 'use server' function(s) in ${resourcePath}. ` +
+            `These cannot be registered as server actions. Assign the function to a variable first.`,
+        );
+      }
+    }
+  }
+
+  // No directive - pass through unchanged
+  return source;
+};
+
+// Export helper for testing and the shared map
+module.exports.findInlineServerActions = findInlineServerActions;
+module.exports.inlineServerActionsMap = inlineServerActionsMap;
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/cjs/rsc-ssr-loader.js packages/react-server-dom-webpack/cjs/rsc-ssr-loader.js
--- npm/react-server-dom-webpack@19.2.0/cjs/rsc-ssr-loader.js	1969-12-31 16:00:00
+++ packages/react-server-dom-webpack/cjs/rsc-ssr-loader.js	2025-11-26 23:54:07
@@ -0,0 +1,117 @@
+/**
+ * rsc-ssr-loader.js
+ *
+ * Webpack loader for the SSR (Server-Side Rendering) layer.
+ *
+ * Transformations:
+ * - 'use server' modules  Stubs that throw errors
+ *   (Server actions should not be called during SSR)
+ * - 'use client' modules  Pass through (actual components for SSR)
+ *
+ * This loader runs on the SERVER during SSR/hydration.
+ */
+
+'use strict';
+
+const acorn = require('acorn-loose');
+const url = require('url');
+
+function getDirective(source) {
+  if (!source.includes('use client') && !source.includes('use server'))
+    return null;
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type !== 'ExpressionStatement' || !node.directive) break;
+      if (node.directive === 'use client') return 'use client';
+      if (node.directive === 'use server') return 'use server';
+    }
+  } catch (e) {
+    return null;
+  }
+  return null;
+}
+
+function getExports(source) {
+  const exports = [];
+  try {
+    const ast = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+    });
+    for (const node of ast.body) {
+      if (node.type === 'ExportNamedDeclaration') {
+        if (node.declaration) {
+          if (
+            node.declaration.type === 'FunctionDeclaration' &&
+            node.declaration.id
+          ) {
+            exports.push(node.declaration.id.name);
+          }
+          if (node.declaration.type === 'VariableDeclaration') {
+            for (const decl of node.declaration.declarations) {
+              if (decl.id && decl.id.type === 'Identifier') {
+                exports.push(decl.id.name);
+              }
+            }
+          }
+        }
+      }
+      if (node.type === 'ExportDefaultDeclaration') {
+        exports.push('default');
+      }
+    }
+  } catch (e) {
+    // Ignore parse errors
+  }
+  return exports;
+}
+
+module.exports = function rscSsrLoader(source) {
+  const directive = getDirective(source);
+
+  // 'use server'  Create stubs that throw errors
+  // Server actions should never be called during SSR
+  if (directive === 'use server') {
+    const exports = getExports(source);
+    const resourcePath = this.resourcePath;
+
+    let output = `'use strict';
+// RSC SSR Loader: 'use server' module replaced with stubs
+// Server actions cannot be called during SSR
+`;
+
+    const defaultExport = exports.includes('default');
+
+    exports.forEach((name) => {
+      const stubBody = `function() {
+  throw new Error(
+    'Server action "${name}" from "${resourcePath}" cannot be called during SSR. ' +
+    'Server actions should only be invoked from client-side code after hydration.'
+  );
+}`;
+
+      if (name === 'default') {
+        // Keep an ESM-style marker for tests while emitting CJS
+        output += `// export default function()\n`;
+        output += `module.exports = ${stubBody};\n`;
+      } else {
+        output += `// export const ${name} = function()\n`;
+        output += `exports.${name} = ${stubBody};\n`;
+      }
+    });
+
+    if (!defaultExport) {
+      output += `module.exports = exports;\n`;
+    }
+
+    return output;
+  }
+
+  // 'use client' and other modules - pass through unchanged
+  // SSR needs the actual client component code to render
+  return source;
+};
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/esm/react-server-dom-webpack-node-loader.production.js packages/react-server-dom-webpack/esm/react-server-dom-webpack-node-loader.production.js
--- npm/react-server-dom-webpack@19.2.0/esm/react-server-dom-webpack-node-loader.production.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/esm/react-server-dom-webpack-node-loader.production.js	2025-12-17 14:32:45
@@ -1,5 +1,5 @@
 /**
-* @license React
+ * @license React
  * react-server-dom-webpack-node-loader.production.js
  *
  * Copyright (c) Meta Platforms, Inc. and affiliates.
@@ -22,12 +22,15 @@
   stashedResolve = defaultResolve;
   if (!context.conditions.includes('react-server')) {
     context = assign({}, context, {
-      conditions: [].concat(context.conditions, ['react-server'])
+      conditions: [].concat(context.conditions, ['react-server']),
     });
     if (!warnedAboutConditionsFlag) {
       warnedAboutConditionsFlag = true;
       // eslint-disable-next-line react-internal/no-production-logging
-      console.warn('You did not run Node.js with the `--conditions react-server` flag. ' + 'Any "react-server" override will only work with ESM imports.');
+      console.warn(
+        'You did not run Node.js with the `--conditions react-server` flag. ' +
+          'Any "react-server" override will only work with ESM imports.',
+      );
     }
   }
   return await defaultResolve(specifier, context, defaultResolve);
@@ -37,7 +40,14 @@
   stashedGetSource = defaultGetSource;
   return defaultGetSource(url, context, defaultGetSource);
 }
-function addExportedEntry(exportedEntries, localNames, localName, exportedName, type, loc) {
+function addExportedEntry(
+  exportedEntries,
+  localNames,
+  localName,
+  exportedName,
+  type,
+  loc,
+) {
   if (localNames.has(localName)) {
     // If the same local name is exported more than once, we only need one of the names.
     return;
@@ -50,21 +60,30 @@
     originalLine: -1,
     originalColumn: -1,
     originalSource: -1,
-    nameIndex: -1
+    nameIndex: -1,
   });
 }
 function addLocalExportedNames(exportedEntries, localNames, node) {
   switch (node.type) {
     case 'Identifier':
-      addExportedEntry(exportedEntries, localNames, node.name, node.name, null, node.loc);
+      addExportedEntry(
+        exportedEntries,
+        localNames,
+        node.name,
+        node.name,
+        null,
+        node.loc,
+      );
       return;
     case 'ObjectPattern':
-      for (let i = 0; i < node.properties.length; i++) addLocalExportedNames(exportedEntries, localNames, node.properties[i]);
+      for (let i = 0; i < node.properties.length; i++)
+        addLocalExportedNames(exportedEntries, localNames, node.properties[i]);
       return;
     case 'ArrayPattern':
       for (let i = 0; i < node.elements.length; i++) {
         const element = node.elements[i];
-        if (element) addLocalExportedNames(exportedEntries, localNames, element);
+        if (element)
+          addLocalExportedNames(exportedEntries, localNames, element);
       }
       return;
     case 'Property':
@@ -96,10 +115,24 @@
         break;
       case 'ExportDefaultDeclaration':
         if (node.declaration.type === 'Identifier') {
-          addExportedEntry(exportedEntries, localNames, node.declaration.name, 'default', null, node.declaration.loc);
+          addExportedEntry(
+            exportedEntries,
+            localNames,
+            node.declaration.name,
+            'default',
+            null,
+            node.declaration.loc,
+          );
         } else if (node.declaration.type === 'FunctionDeclaration') {
           if (node.declaration.id) {
-            addExportedEntry(exportedEntries, localNames, node.declaration.id.name, 'default', 'function', node.declaration.id.loc);
+            addExportedEntry(
+              exportedEntries,
+              localNames,
+              node.declaration.id.name,
+              'default',
+              'function',
+              node.declaration.id.loc,
+            );
           }
         }
         continue;
@@ -108,24 +141,47 @@
           if (node.declaration.type === 'VariableDeclaration') {
             const declarations = node.declaration.declarations;
             for (let j = 0; j < declarations.length; j++) {
-              addLocalExportedNames(exportedEntries, localNames, declarations[j].id);
+              addLocalExportedNames(
+                exportedEntries,
+                localNames,
+                declarations[j].id,
+              );
             }
           } else {
             const name = node.declaration.id.name;
-            addExportedEntry(exportedEntries, localNames, name, name, node.declaration.type === 'FunctionDeclaration' ? 'function' : null, node.declaration.id.loc);
+            addExportedEntry(
+              exportedEntries,
+              localNames,
+              name,
+              name,
+              node.declaration.type === 'FunctionDeclaration'
+                ? 'function'
+                : null,
+              node.declaration.id.loc,
+            );
           }
         }
         if (node.specifiers) {
           const specifiers = node.specifiers;
           for (let j = 0; j < specifiers.length; j++) {
             const specifier = specifiers[j];
-            addExportedEntry(exportedEntries, localNames, specifier.local.name, specifier.exported.name, null, specifier.local.loc);
+            addExportedEntry(
+              exportedEntries,
+              localNames,
+              specifier.local.name,
+              specifier.exported.name,
+              null,
+              specifier.local.loc,
+            );
           }
         }
         continue;
     }
   }
-  let mappings = sourceMap && typeof sourceMap.mappings === 'string' ? sourceMap.mappings : '';
+  let mappings =
+    sourceMap && typeof sourceMap.mappings === 'string'
+      ? sourceMap.mappings
+      : '';
   let newSrc = source;
   if (exportedEntries.length > 0) {
     let lastSourceIndex = 0;
@@ -140,39 +196,53 @@
       let nextEntryIdx = 0;
       let nextEntryLine = exportedEntries[nextEntryIdx].loc.start.line;
       let nextEntryColumn = exportedEntries[nextEntryIdx].loc.start.column;
-      readMappings(mappings, (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
-        if (generatedLine > nextEntryLine || generatedLine === nextEntryLine && generatedColumn > nextEntryColumn) {
-          // We're past the entry which means that the best match we have is the previous entry.
-          if (lastMappedLine === nextEntryLine) {
-            // Match
-            exportedEntries[nextEntryIdx].originalLine = lastOriginalLine;
-            exportedEntries[nextEntryIdx].originalColumn = lastOriginalColumn;
-            exportedEntries[nextEntryIdx].originalSource = lastSourceIndex;
-            exportedEntries[nextEntryIdx].nameIndex = lastNameIndex;
+      readMappings(
+        mappings,
+        (
+          generatedLine,
+          generatedColumn,
+          sourceIndex,
+          originalLine,
+          originalColumn,
+          nameIndex,
+        ) => {
+          if (
+            generatedLine > nextEntryLine ||
+            (generatedLine === nextEntryLine &&
+              generatedColumn > nextEntryColumn)
+          ) {
+            // We're past the entry which means that the best match we have is the previous entry.
+            if (lastMappedLine === nextEntryLine) {
+              // Match
+              exportedEntries[nextEntryIdx].originalLine = lastOriginalLine;
+              exportedEntries[nextEntryIdx].originalColumn = lastOriginalColumn;
+              exportedEntries[nextEntryIdx].originalSource = lastSourceIndex;
+              exportedEntries[nextEntryIdx].nameIndex = lastNameIndex;
+            }
+            nextEntryIdx++;
+            if (nextEntryIdx < exportedEntries.length) {
+              nextEntryLine = exportedEntries[nextEntryIdx].loc.start.line;
+              nextEntryColumn = exportedEntries[nextEntryIdx].loc.start.column;
+            } else {
+              nextEntryLine = -1;
+              nextEntryColumn = -1;
+            }
           }
-          nextEntryIdx++;
-          if (nextEntryIdx < exportedEntries.length) {
-            nextEntryLine = exportedEntries[nextEntryIdx].loc.start.line;
-            nextEntryColumn = exportedEntries[nextEntryIdx].loc.start.column;
-          } else {
-            nextEntryLine = -1;
-            nextEntryColumn = -1;
+          lastMappedLine = generatedLine;
+          if (sourceIndex > -1) {
+            lastSourceIndex = sourceIndex;
           }
-        }
-        lastMappedLine = generatedLine;
-        if (sourceIndex > -1) {
-          lastSourceIndex = sourceIndex;
-        }
-        if (originalLine > -1) {
-          lastOriginalLine = originalLine;
-        }
-        if (originalColumn > -1) {
-          lastOriginalColumn = originalColumn;
-        }
-        if (nameIndex > -1) {
-          lastNameIndex = nameIndex;
-        }
-      });
+          if (originalLine > -1) {
+            lastOriginalLine = originalLine;
+          }
+          if (originalColumn > -1) {
+            lastOriginalColumn = originalColumn;
+          }
+          if (nameIndex > -1) {
+            lastNameIndex = nameIndex;
+          }
+        },
+      );
       if (nextEntryIdx < exportedEntries.length) {
         if (lastMappedLine === nextEntryLine) {
           // Match
@@ -182,18 +252,28 @@
           exportedEntries[nextEntryIdx].nameIndex = lastNameIndex;
         }
       }
-      for (let lastIdx = mappings.length - 1; lastIdx >= 0 && mappings[lastIdx] === ';'; lastIdx--) {
+      for (
+        let lastIdx = mappings.length - 1;
+        lastIdx >= 0 && mappings[lastIdx] === ';';
+        lastIdx--
+      ) {
         // If the last mapped lines don't contain any segments, we don't get a callback from readMappings
         // so we need to pad the number of mapped lines, with one for each empty line.
         lastMappedLine++;
       }
       sourceLineCount = program.loc.end.line;
       if (sourceLineCount < lastMappedLine) {
-        throw new Error('The source map has more mappings than there are lines.');
+        throw new Error(
+          'The source map has more mappings than there are lines.',
+        );
       }
       // If the original source string had more lines than there are mappings in the source map.
       // Add some extra padding of unmapped lines so that any lines that we add line up.
-      for (let extraLines = sourceLineCount - lastMappedLine; extraLines > 0; extraLines--) {
+      for (
+        let extraLines = sourceLineCount - lastMappedLine;
+        extraLines > 0;
+        extraLines--
+      ) {
         mappings += ';';
       }
     } else {
@@ -210,7 +290,7 @@
         sources: [url],
         sourcesContent: [source],
         mappings: mappings,
-        sourceRoot: ''
+        sourceRoot: '',
       };
       lastSourceIndex = 0;
       lastOriginalLine = sourceLineCount;
@@ -227,7 +307,8 @@
       }
     }
     newSrc += '\n\n;';
-    newSrc += 'import {registerServerReference} from "react-server-dom-webpack/server";\n';
+    newSrc +=
+      'import {registerServerReference} from "react-server-dom-webpack/server";\n';
     if (mappings) {
       mappings += ';;';
     }
@@ -235,7 +316,14 @@
 
     // Create an empty mapping pointing to where we last left off to reset the counters.
     let generatedLine = 1;
-    createMapping(generatedLine, 0, lastSourceIndex, lastOriginalLine, lastOriginalColumn, lastNameIndex);
+    createMapping(
+      generatedLine,
+      0,
+      lastSourceIndex,
+      lastOriginalLine,
+      lastOriginalColumn,
+      lastNameIndex,
+    );
     for (let i = 0; i < exportedEntries.length; i++) {
       const entry = exportedEntries[i];
       generatedLine++;
@@ -246,13 +334,22 @@
       newSrc += 'registerServerReference(' + entry.localName + ',';
       newSrc += JSON.stringify(url) + ',';
       newSrc += JSON.stringify(entry.exportedName) + ');\n';
-      mappings += createMapping(generatedLine, 0, entry.originalSource, entry.originalLine, entry.originalColumn, entry.nameIndex);
+      mappings += createMapping(
+        generatedLine,
+        0,
+        entry.originalSource,
+        entry.originalLine,
+        entry.originalColumn,
+        entry.nameIndex,
+      );
     }
   }
   if (sourceMap) {
     // Override with an new mappings and serialize an inline source map.
     sourceMap.mappings = mappings;
-    newSrc += '//# sourceMappingURL=data:application/json;charset=utf-8;base64,' + Buffer.from(JSON.stringify(sourceMap)).toString('base64');
+    newSrc +=
+      '//# sourceMappingURL=data:application/json;charset=utf-8;base64,' +
+      Buffer.from(JSON.stringify(sourceMap)).toString('base64');
   }
   return newSrc;
 }
@@ -262,7 +359,8 @@
       names.push(node.name);
       return;
     case 'ObjectPattern':
-      for (let i = 0; i < node.properties.length; i++) addExportNames(names, node.properties[i]);
+      for (let i = 0; i < node.properties.length; i++)
+        addExportNames(names, node.properties[i]);
       return;
     case 'ArrayPattern':
       for (let i = 0; i < node.elements.length; i++) {
@@ -292,12 +390,18 @@
   // always convert to explicit exported names instead.
   const conditions = ['node', 'import'];
   if (stashedResolve === null) {
-    throw new Error('Expected resolve to have been called before transformSource');
+    throw new Error(
+      'Expected resolve to have been called before transformSource',
+    );
   }
-  return stashedResolve(specifier, {
-    conditions,
-    parentURL
-  }, stashedResolve);
+  return stashedResolve(
+    specifier,
+    {
+      conditions,
+      parentURL,
+    },
+    stashedResolve,
+  );
 }
 async function parseExportNamesInto(body, names, parentURL, loader) {
   for (let i = 0; i < body.length; i++) {
@@ -308,13 +412,20 @@
           addExportNames(names, node.exported);
           continue;
         } else {
-          const _await$resolveClientI = await resolveClientImport(node.source.value, parentURL),
+          const _await$resolveClientI = await resolveClientImport(
+              node.source.value,
+              parentURL,
+            ),
             url = _await$resolveClientI.url;
-          const _await$loader = await loader(url, {
-              format: 'module',
-              conditions: [],
-              importAssertions: {}
-            }, loader),
+          const _await$loader = await loader(
+              url,
+              {
+                format: 'module',
+                conditions: [],
+                importAssertions: {},
+              },
+              loader,
+            ),
             source = _await$loader.source;
           if (typeof source !== 'string') {
             throw new Error('Expected the transformed source to be a string.');
@@ -323,7 +434,7 @@
           try {
             childBody = acorn.parse(source, {
               ecmaVersion: '2024',
-              sourceType: 'module'
+              sourceType: 'module',
             }).body;
           } catch (x) {
             // eslint-disable-next-line react-internal/no-production-logging
@@ -364,17 +475,39 @@
   if (names.length === 0) {
     return '';
   }
-  let newSrc = 'import {registerClientReference} from "react-server-dom-webpack/server";\n';
+  let newSrc =
+    'import {registerClientReference} from "react-server-dom-webpack/server";\n';
   for (let i = 0; i < names.length; i++) {
     const name = names[i];
     if (name === 'default') {
       newSrc += 'export default ';
       newSrc += 'registerClientReference(function() {';
-      newSrc += 'throw new Error(' + JSON.stringify("Attempted to call the default export of " + url + " from the server " + "but it's on the client. It's not possible to invoke a client function from " + "the server, it can only be rendered as a Component or passed to props of a " + "Client Component.") + ');';
+      newSrc +=
+        'throw new Error(' +
+        JSON.stringify(
+          'Attempted to call the default export of ' +
+            url +
+            ' from the server ' +
+            "but it's on the client. It's not possible to invoke a client function from " +
+            'the server, it can only be rendered as a Component or passed to props of a ' +
+            'Client Component.',
+        ) +
+        ');';
     } else {
       newSrc += 'export const ' + name + ' = ';
       newSrc += 'registerClientReference(function() {';
-      newSrc += 'throw new Error(' + JSON.stringify("Attempted to call " + name + "() from the server but " + name + " is on the client. " + "It's not possible to invoke a client function from the server, it can " + "only be rendered as a Component or passed to props of a Client Component.") + ');';
+      newSrc +=
+        'throw new Error(' +
+        JSON.stringify(
+          'Attempted to call ' +
+            name +
+            '() from the server but ' +
+            name +
+            ' is on the client. ' +
+            "It's not possible to invoke a client function from the server, it can " +
+            'only be rendered as a Component or passed to props of a Client Component.',
+        ) +
+        ');';
     }
     newSrc += '},';
     newSrc += JSON.stringify(url) + ',';
@@ -387,26 +520,39 @@
 }
 async function loadClientImport(url, defaultTransformSource) {
   if (stashedGetSource === null) {
-    throw new Error('Expected getSource to have been called before transformSource');
+    throw new Error(
+      'Expected getSource to have been called before transformSource',
+    );
   }
   // TODO: Validate that this is another module by calling getFormat.
-  const _await$stashedGetSour = await stashedGetSource(url, {
-      format: 'module'
-    }, stashedGetSource),
+  const _await$stashedGetSour = await stashedGetSource(
+      url,
+      {
+        format: 'module',
+      },
+      stashedGetSource,
+    ),
     source = _await$stashedGetSour.source;
-  const result = await defaultTransformSource(source, {
-    format: 'module',
-    url
-  }, defaultTransformSource);
+  const result = await defaultTransformSource(
+    source,
+    {
+      format: 'module',
+      url,
+    },
+    defaultTransformSource,
+  );
   return {
     format: 'module',
-    source: result.source
+    source: result.source,
   };
 }
 async function transformModuleIfNeeded(source, url, loader) {
   // Do a quick check for the exact string. If it doesn't exist, don't
   // bother parsing.
-  if (source.indexOf('use client') === -1 && source.indexOf('use server') === -1) {
+  if (
+    source.indexOf('use client') === -1 &&
+    source.indexOf('use server') === -1
+  ) {
     return source;
   }
   let sourceMappingURL = null;
@@ -420,13 +566,16 @@
       sourceType: 'module',
       locations: true,
       onComment(block, text, start, end, startLoc, endLoc) {
-        if (text.startsWith('# sourceMappingURL=') || text.startsWith('@ sourceMappingURL=')) {
+        if (
+          text.startsWith('# sourceMappingURL=') ||
+          text.startsWith('@ sourceMappingURL=')
+        ) {
           sourceMappingURL = text.slice(19);
           sourceMappingStart = start;
           sourceMappingEnd = end;
           sourceMappingLines = endLoc.line - startLoc.line;
         }
-      }
+      },
     });
   } catch (x) {
     // eslint-disable-next-line react-internal/no-production-logging
@@ -452,29 +601,39 @@
     return source;
   }
   if (useClient && useServer) {
-    throw new Error('Cannot have both "use client" and "use server" directives in the same file.');
+    throw new Error(
+      'Cannot have both "use client" and "use server" directives in the same file.',
+    );
   }
   let sourceMap = null;
   if (sourceMappingURL) {
-    const sourceMapResult = await loader(sourceMappingURL,
-    // $FlowFixMe
-    {
-      format: 'json',
-      conditions: [],
-      importAssertions: {
-        type: 'json'
+    const sourceMapResult = await loader(
+      sourceMappingURL,
+      // $FlowFixMe
+      {
+        format: 'json',
+        conditions: [],
+        importAssertions: {
+          type: 'json',
+        },
+        importAttributes: {
+          type: 'json',
+        },
       },
-      importAttributes: {
-        type: 'json'
-      }
-    }, loader);
-    const sourceMapString = typeof sourceMapResult.source === 'string' ? sourceMapResult.source :
-    // $FlowFixMe
-    sourceMapResult.source.toString('utf8');
+      loader,
+    );
+    const sourceMapString =
+      typeof sourceMapResult.source === 'string'
+        ? sourceMapResult.source
+        : // $FlowFixMe
+          sourceMapResult.source.toString('utf8');
     sourceMap = JSON.parse(sourceMapString);
 
     // Strip the source mapping comment. We'll re-add it below if needed.
-    source = source.slice(0, sourceMappingStart) + '\n'.repeat(sourceMappingLines) + source.slice(sourceMappingEnd);
+    source =
+      source.slice(0, sourceMappingStart) +
+      '\n'.repeat(sourceMappingLines) +
+      source.slice(sourceMappingEnd);
   }
   if (useClient) {
     return transformClientModule(program, url, sourceMap, loader);
@@ -482,17 +641,25 @@
   return transformServerModule(source, program, url, sourceMap);
 }
 async function transformSource(source, context, defaultTransformSource) {
-  const transformed = await defaultTransformSource(source, context, defaultTransformSource);
+  const transformed = await defaultTransformSource(
+    source,
+    context,
+    defaultTransformSource,
+  );
   if (context.format === 'module') {
     const transformedSource = transformed.source;
     if (typeof transformedSource !== 'string') {
       throw new Error('Expected source to have been transformed to a string.');
     }
-    const newSrc = await transformModuleIfNeeded(transformedSource, context.url, (url, ctx, defaultLoad) => {
-      return loadClientImport(url, defaultTransformSource);
-    });
+    const newSrc = await transformModuleIfNeeded(
+      transformedSource,
+      context.url,
+      (url, ctx, defaultLoad) => {
+        return loadClientImport(url, defaultTransformSource);
+      },
+    );
     return {
-      source: newSrc
+      source: newSrc,
     };
   }
   return transformed;
@@ -503,10 +670,14 @@
     if (typeof result.source !== 'string') {
       throw new Error('Expected source to have been loaded into a string.');
     }
-    const newSrc = await transformModuleIfNeeded(result.source, url, defaultLoad);
+    const newSrc = await transformModuleIfNeeded(
+      result.source,
+      url,
+      defaultLoad,
+    );
     return {
       format: 'module',
-      source: newSrc
+      source: newSrc,
     };
   }
   return result;
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/package.json packages/react-server-dom-webpack/package.json
--- npm/react-server-dom-webpack@19.2.0/package.json	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/package.json	2025-12-17 14:25:38
@@ -2,6 +2,7 @@
   "name": "react-server-dom-webpack",
   "description": "React Server Components bindings for DOM using Webpack. This is intended to be integrated into meta-frameworks. It is not intended to be imported directly.",
   "version": "19.2.0",
+  "private": true,
   "keywords": [
     "react"
   ],
@@ -87,6 +88,9 @@
     "./static.node.unbundled": "./static.node.unbundled.js",
     "./node-loader": "./esm/react-server-dom-webpack-node-loader.production.js",
     "./node-register": "./node-register.js",
+    "./rsc-server-loader": "./cjs/rsc-server-loader.js",
+    "./rsc-ssr-loader": "./cjs/rsc-ssr-loader.js",
+    "./rsc-client-loader": "./cjs/rsc-client-loader.js",
     "./package.json": "./package.json"
   },
   "main": "index.js",
@@ -108,4 +112,4 @@
     "neo-async": "^2.6.1",
     "webpack-sources": "^3.2.0"
   }
-}
\ No newline at end of file
+}
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/server.js packages/react-server-dom-webpack/server.js
--- npm/react-server-dom-webpack@19.2.0/server.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/server.js	2025-12-17 14:32:45
@@ -2,5 +2,5 @@
 
 throw new Error(
   'The React Server Writer cannot be used outside a react-server environment. ' +
-    'You must configure Node.js using the `--conditions react-server` flag.'
+    'You must configure Node.js using the `--conditions react-server` flag.',
 );
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/server.node.js packages/react-server-dom-webpack/server.node.js
--- npm/react-server-dom-webpack@19.2.0/server.node.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/server.node.js	2025-12-17 14:32:45
@@ -7,6 +7,95 @@
   s = require('./cjs/react-server-dom-webpack-server.node.development.js');
 }
 
+// Use globalThis to ensure singleton registry across webpack module instances.
+// This is necessary because webpack's share scope may create multiple module
+// instances with different IDs that each execute this code.
+const REGISTRY_KEY = '__RSC_SERVER_ACTION_REGISTRY__';
+const MANIFEST_KEY = '__RSC_DYNAMIC_MANIFEST__';
+
+// Global registry for inline server actions
+// This allows action lookup for functions not exported from modules
+if (!globalThis[REGISTRY_KEY]) {
+  globalThis[REGISTRY_KEY] = new Map();
+}
+const serverActionRegistry = globalThis[REGISTRY_KEY];
+
+// Dynamic manifest entries for actions registered at runtime (inline actions)
+// Key: actionId, Value: { id, name, chunks }
+if (!globalThis[MANIFEST_KEY]) {
+  globalThis[MANIFEST_KEY] = new Map();
+}
+const dynamicServerActionsManifest = globalThis[MANIFEST_KEY];
+
+/**
+ * Wrap registerServerReference to also store in global registry
+ * This enables lookup of inline server actions defined inside components
+ */
+function registerServerReferenceWithRegistry(reference, id, exportName) {
+  // Call the original implementation
+  const result = s.registerServerReference(reference, id, exportName);
+
+  // Store in global registry for lookup
+  const actionId = exportName === null ? id : id + '#' + exportName;
+  serverActionRegistry.set(actionId, reference);
+
+  // Debug: log registration
+  if (process.env.RSC_DEBUG) {
+    console.log(
+      `[RSC Registry] Registered action: ${actionId} (registry size: ${serverActionRegistry.size})`,
+    );
+  }
+
+  // Also keep a manifest entry so decodeReply can resolve dynamic inline actions
+  dynamicServerActionsManifest.set(actionId, {
+    id,
+    name: exportName === null ? 'default' : exportName,
+    chunks: [],
+  });
+
+  return result;
+}
+
+/**
+ * Get a server action function by its ID
+ * Used by action handlers to find inline server actions
+ */
+function getServerAction(actionId) {
+  const result = serverActionRegistry.get(actionId);
+  // Debug: log lookup
+  if (process.env.RSC_DEBUG) {
+    console.log(
+      `[RSC Registry] Lookup action: ${actionId} -> ${result ? 'FOUND' : 'NOT FOUND'} (registry size: ${serverActionRegistry.size})`,
+    );
+    if (!result) {
+      console.log(
+        `[RSC Registry] Available actions: ${Array.from(serverActionRegistry.keys()).join(', ')}`,
+      );
+    }
+  }
+  return result;
+}
+
+function getDynamicServerActionsManifest() {
+  const entries = {};
+  for (const [key, value] of dynamicServerActionsManifest) {
+    entries[key] = value;
+  }
+  return entries;
+}
+
+/**
+ * Clear the server action registry (for testing purposes)
+ * This is needed when reloading bundles in tests to ensure fresh state
+ */
+function clearServerActionRegistry() {
+  serverActionRegistry.clear();
+  dynamicServerActionsManifest.clear();
+  if (process.env.RSC_DEBUG) {
+    console.log('[RSC Registry] Cleared registry and manifest');
+  }
+}
+
 exports.renderToReadableStream = s.renderToReadableStream;
 exports.renderToPipeableStream = s.renderToPipeableStream;
 exports.decodeReply = s.decodeReply;
@@ -14,7 +103,13 @@
 exports.decodeReplyFromAsyncIterable = s.decodeReplyFromAsyncIterable;
 exports.decodeAction = s.decodeAction;
 exports.decodeFormState = s.decodeFormState;
-exports.registerServerReference = s.registerServerReference;
+exports.registerServerReference = registerServerReferenceWithRegistry;
 exports.registerClientReference = s.registerClientReference;
 exports.createClientModuleProxy = s.createClientModuleProxy;
 exports.createTemporaryReferenceSet = s.createTemporaryReferenceSet;
+
+// Export registry access for action handlers
+exports.getServerAction = getServerAction;
+exports.serverActionRegistry = serverActionRegistry;
+exports.getDynamicServerActionsManifest = getDynamicServerActionsManifest;
+exports.clearServerActionRegistry = clearServerActionRegistry;
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/server.node.unbundled.js packages/react-server-dom-webpack/server.node.unbundled.js
--- npm/react-server-dom-webpack@19.2.0/server.node.unbundled.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/server.node.unbundled.js	2025-11-24 22:02:45
@@ -7,6 +7,51 @@
   s = require('./cjs/react-server-dom-webpack-server.node.unbundled.development.js');
 }
 
+// Global registry for inline server actions
+// This allows action lookup for functions not exported from modules
+const serverActionRegistry = new Map();
+
+// Dynamic manifest entries for actions registered at runtime (inline actions)
+const dynamicServerActionsManifest = new Map();
+
+/**
+ * Wrap registerServerReference to also store in global registry
+ * This enables lookup of inline server actions defined inside components
+ */
+function registerServerReferenceWithRegistry(reference, id, exportName) {
+  // Call the original implementation
+  const result = s.registerServerReference(reference, id, exportName);
+
+  // Store in global registry for lookup
+  const actionId = exportName === null ? id : id + '#' + exportName;
+  serverActionRegistry.set(actionId, reference);
+
+  // Keep a manifest entry so decodeReply can resolve dynamic inline actions
+  dynamicServerActionsManifest.set(actionId, {
+    id,
+    name: exportName === null ? 'default' : exportName,
+    chunks: [],
+  });
+
+  return result;
+}
+
+/**
+ * Get a server action function by its ID
+ * Used by action handlers to find inline server actions
+ */
+function getServerAction(actionId) {
+  return serverActionRegistry.get(actionId);
+}
+
+function getDynamicServerActionsManifest() {
+  const entries = {};
+  for (const [key, value] of dynamicServerActionsManifest) {
+    entries[key] = value;
+  }
+  return entries;
+}
+
 exports.renderToReadableStream = s.renderToReadableStream;
 exports.renderToPipeableStream = s.renderToPipeableStream;
 exports.decodeReply = s.decodeReply;
@@ -14,7 +59,12 @@
 exports.decodeReplyFromAsyncIterable = s.decodeReplyFromAsyncIterable;
 exports.decodeAction = s.decodeAction;
 exports.decodeFormState = s.decodeFormState;
-exports.registerServerReference = s.registerServerReference;
+exports.registerServerReference = registerServerReferenceWithRegistry;
 exports.registerClientReference = s.registerClientReference;
 exports.createClientModuleProxy = s.createClientModuleProxy;
 exports.createTemporaryReferenceSet = s.createTemporaryReferenceSet;
+
+// Export registry access for action handlers
+exports.getServerAction = getServerAction;
+exports.serverActionRegistry = serverActionRegistry;
+exports.getDynamicServerActionsManifest = getDynamicServerActionsManifest;
diff -ruN --exclude node_modules --exclude .DS_Store npm/react-server-dom-webpack@19.2.0/static.js packages/react-server-dom-webpack/static.js
--- npm/react-server-dom-webpack@19.2.0/static.js	1985-10-26 01:15:00
+++ packages/react-server-dom-webpack/static.js	2025-12-17 14:32:45
@@ -2,5 +2,5 @@
 
 throw new Error(
   'The React Server Writer cannot be used outside a react-server environment. ' +
-    'You must configure Node.js using the `--conditions react-server` flag.'
+    'You must configure Node.js using the `--conditions react-server` flag.',
 );
