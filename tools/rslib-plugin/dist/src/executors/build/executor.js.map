{"version":3,"file":"executor.js","names":[],"sources":["../../../../src/executors/build/executor.ts"],"sourcesContent":["import type { ExecutorContext } from '@nx/devkit';\nimport { join, resolve } from 'path';\nimport { pathToFileURL } from 'url';\nimport { copyFileSync, existsSync, mkdirSync } from 'fs';\nimport { glob } from 'glob';\n\nexport interface RslibBuildExecutorOptions {\n  configFile?: string;\n  outputPath?: string;\n  watch?: boolean;\n  mode?: 'development' | 'production';\n  verbose?: boolean;\n  main?: string;\n  additionalEntryPoints?: string[];\n  external?: string[];\n  format?: ('cjs' | 'esm' | 'umd' | 'iife')[];\n  tsConfig?: string;\n  assets?: (\n    | string\n    | {\n        glob: string;\n        input: string;\n        output: string;\n        ignore?: string[];\n      }\n  )[];\n  project?: string;\n}\n\nasync function copyAssets(\n  assets: RslibBuildExecutorOptions['assets'],\n  projectPath: string,\n  outputPath: string,\n): Promise<void> {\n  if (!assets || assets.length === 0) return;\n\n  for (const asset of assets) {\n    if (typeof asset === 'string') {\n      // Simple string asset - copy as is\n      const srcPath = resolve(projectPath, asset);\n      const destPath = resolve(outputPath, asset);\n\n      if (existsSync(srcPath)) {\n        const destDir = resolve(destPath, '..');\n        if (!existsSync(destDir)) {\n          mkdirSync(destDir, { recursive: true });\n        }\n        copyFileSync(srcPath, destPath);\n      }\n    } else {\n      // Complex asset object with glob\n      const pattern = join(asset.input, asset.glob);\n      const files = await glob(pattern, {\n        cwd: projectPath,\n        ignore: asset.ignore,\n      });\n\n      for (const file of files) {\n        const srcPath = resolve(projectPath, file);\n        const destPath = resolve(\n          outputPath,\n          asset.output,\n          file.replace(asset.input, '').replace(/^\\//, ''),\n        );\n\n        const destDir = resolve(destPath, '..');\n        if (!existsSync(destDir)) {\n          mkdirSync(destDir, { recursive: true });\n        }\n        copyFileSync(srcPath, destPath);\n      }\n    }\n  }\n}\n\nfunction generateRslibConfig(\n  options: RslibBuildExecutorOptions,\n  projectPath: string,\n  workspaceRoot: string,\n) {\n  const entryPoints: Record<string, string> = {};\n\n  // Add main entry point\n  if (options.main) {\n    // Handle both relative (from workspace root) and absolute paths\n    const mainPath = options.main.startsWith(projectPath)\n      ? options.main\n      : join(workspaceRoot, options.main);\n    entryPoints['index'] = mainPath;\n  }\n\n  // Add additional entry points\n  if (options.additionalEntryPoints) {\n    for (const entryPoint of options.additionalEntryPoints) {\n      // Extract just the filename without extension for the entry name\n      const name =\n        entryPoint\n          .split('/')\n          .pop()\n          ?.replace(/\\.(ts|tsx|js|jsx)$/, '') || 'entry';\n      const entryPath = entryPoint.startsWith(projectPath)\n        ? entryPoint\n        : join(workspaceRoot, entryPoint);\n      entryPoints[name] = entryPath;\n    }\n  }\n\n  const formats = options.format || ['esm'];\n\n  // Only generate DTS for the first format to avoid duplicates\n  const libConfigs = formats.map((format, index) => ({\n    format: format as any,\n    bundle: true,\n    autoExternal: true,\n    dts: index === 0, // Only generate DTS for the first format\n    output: {\n      distPath: {\n        root: options.outputPath\n          ? options.outputPath.startsWith('/')\n            ? options.outputPath\n            : join(workspaceRoot, options.outputPath)\n          : join(projectPath, 'dist'),\n      },\n    },\n  }));\n\n  // Handle tsConfig path - support both relative to project and workspace root\n  let tsconfigPath: string | undefined;\n  if (options.tsConfig) {\n    if (options.tsConfig.startsWith(projectPath)) {\n      tsconfigPath = options.tsConfig;\n    } else if (options.tsConfig.startsWith('/')) {\n      tsconfigPath = options.tsConfig;\n    } else {\n      // Relative path from workspace root (Nx convention)\n      tsconfigPath = join(workspaceRoot, options.tsConfig);\n    }\n  }\n\n  // Convert external array to externals object for rspack\n  const externals: Record<string, string> = {};\n  if (options.external) {\n    for (const ext of options.external) {\n      if (ext.includes('*')) {\n        // Handle glob patterns like \"@module-federation/*\"\n        const pattern = ext.replace(/\\*/g, '(.*)');\n        externals[pattern] = ext;\n      } else {\n        externals[ext] = ext;\n      }\n    }\n  }\n\n  return {\n    lib: libConfigs,\n    source: {\n      entry: entryPoints,\n      tsconfigPath,\n    },\n    tools: {\n      rspack: {\n        externals,\n      },\n    },\n  };\n}\n\nexport default async function rslibBuildExecutor(\n  options: RslibBuildExecutorOptions,\n  context: ExecutorContext,\n): Promise<{ success: boolean }> {\n  const projectRoot =\n    context.projectGraph?.nodes[context.projectName!]?.data?.root;\n\n  if (!projectRoot) {\n    throw new Error(`Could not find project root for ${context.projectName}`);\n  }\n\n  console.info(`Executing rslib build for ${context.projectName}...`);\n\n  if (options.verbose) {\n    console.info(`Options: ${JSON.stringify(options, null, 2)}`);\n    console.info(`Project root: ${projectRoot}`);\n    console.info(`Workspace root: ${context.root}`);\n  }\n\n  try {\n    const projectPath = join(context.root, projectRoot);\n    const outputPath = options.outputPath\n      ? join(context.root, options.outputPath)\n      : join(projectPath, 'dist');\n\n    console.info(`Running: rslib build`);\n    console.info(`Working directory: ${projectPath}`);\n    console.info(`Output path: ${outputPath}`);\n\n    // Import the rslib build function\n    const { build, loadConfig } = await import('@rslib/core');\n\n    let config;\n\n    // Try to load existing config file first\n    const configFile = options.configFile || 'rslib.config.ts';\n    const configPath = resolve(projectPath, configFile);\n\n    if (existsSync(configPath)) {\n      if (options.verbose) {\n        console.info(`Loading existing config from ${configPath}`);\n      }\n      const { content } = await loadConfig({\n        cwd: projectPath,\n        path: configPath,\n      });\n      config = content;\n    } else {\n      // Generate config from options if no config file exists\n      if (options.verbose) {\n        console.info('Generating rslib config from executor options');\n      }\n      config = generateRslibConfig(options, projectPath, context.root);\n    }\n\n    // Set environment\n    process.env['NODE_ENV'] = options.mode || 'production';\n\n    // Change to project directory for rslib to work correctly\n    const originalCwd = process.cwd();\n    process.chdir(projectPath);\n\n    try {\n      // Call rslib build API directly\n      await build(config, {\n        watch: options.watch || false,\n        root: projectPath,\n      });\n\n      // Copy assets after build\n      await copyAssets(options.assets, projectPath, outputPath);\n\n      console.info('✅ Rslib build completed successfully');\n      return { success: true };\n    } finally {\n      // Restore original working directory\n      process.chdir(originalCwd);\n    }\n  } catch (error) {\n    console.error('❌ Rslib build failed:', error);\n    return { success: false };\n  }\n}\n"],"mappings":"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"}